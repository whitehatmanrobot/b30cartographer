ak;
            }
            szUser++;
        }
        szUser = argv[3];
    }

    if (_wcsicmp(argv[1],g_szExtend) == 0) {
        WinError = Client32ExtendSchema(szTree,
                                        szContext,
                                        szUser,
                                        szPwd);
        if (WinError == ERROR_MOD_NOT_FOUND) {
            WinError = NWAPIExtendSchema(szTree,
                                         szContext,
                                         szUser,
                                         szPwd);
            if (WinError) {
                if (WinError == 1) {
                    WinError = 0;
                    SelectivePrint(MSG_EXTENDED_ALREADY, szTree);
                }
                BAIL();
            }
            else {
                SelectivePrint(MSG_EXTEND_SUCCESS,szTree);
            }
        }
        else if (WinError) {
            if (WinError == 1) {
                WinError = 0;
                SelectivePrint(MSG_EXTENDED_ALREADY, szTree);
            }
            BAIL();
        }
        else {
            SelectivePrint(MSG_EXTEND_SUCCESS,szTree);
        }
    }
    else if (_wcsicmp(argv[1],g_szCheck) == 0) {
        BOOL fExtended;
        WinError = Client32CheckSchemaExtension(szTree,
                                                szContext,
                                                szUser,
                                                szPwd,
                                                &fExtended);
        if (WinError == ERROR_MOD_NOT_FOUND) {
            WinError = NWAPICheckSchemaExtension(szTree,
                                                 szContext,
                                                 szUser,
                                                 szPwd,
                                                 &fExtended);
            if (WinError) {
                BAIL();
            }
        }
        else if (WinError) {
            BAIL();
        }
        if (fExtended) {
            WinError = 1;
            SelectivePrint(MSG_EXTENDED,szTree);
        }
        else {
            WinError = 0;
            SelectivePrint(MSG_NOT_EXTENDED,szTree);
        }
    }
    else {
        SelectivePrint(MSG_HELP);
        BAIL();
    }

error:
    if (WinError && (WinError != 1)) {
        SelectivePrint(MSG_ERROR,WinError);
        SelectivePrintWin32(WinError);

    }
    return WinError;
}

void SelectivePrint(DWORD messageID, ...)
{
    static BOOLEAN bTriedOpen = FALSE;
    PWSTR pszMessageBuffer = NULL;
    DWORD dwSize;
    va_list ap;
    DWORD dwLen;

    va_start(ap, messageID);

    dwLen = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER, 
                   NULL, 
                   messageID, 
                   0, 
                   (PWSTR)&pszMessageBuffer, 
                   4095, 
                   &ap);
    if (dwLen == 0)
    {
        DWORD WinError = GetLastError();
        ERR(("Error formatting message: %d\n", WinError));
        BAIL();
    }

    dwSize = wcslen(pszMessageBuffer);
    if (pszMessageBuffer[dwSize-2] == '\r') {
        pszMessageBuffer[dwSize-2] = '\n';
        pszMessageBuffer[dwSize-1] = '\0';
    }


    fwprintf(stdout,pszMessageBuffer);
error:
    va_end(ap);
    if (pszMessageBuffer) {
        LocalFree(pszMessageBuffer);
    }
    return;
}

void SelectivePrintWin32(DWORD dwError)
{
    DWORD dwLen;
    WCHAR szMessage[256];

    dwLen = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          dwError,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                          szMessage,
                          256,
                          NULL);
    if (dwLen == 0)
    {
        DWORD WinError = GetLastError();
        ERR(("Error formatting message: %d\n", WinError));
        BAIL();
    }

    fwprintf(stdout,szMessage);
error:
    return;
}

#define     CR              0xD
#define     BACKSPACE       0x8
#define     NULLC           '\0'
#define     NEWLINE         '\n'

BOOL
GetPassword(
    PWSTR  szBuffer,
    DWORD  dwLength,
    DWORD  *pdwLengthReturn
    )
{
    WCHAR   ch;
    PWSTR   pszBufCur = szBuffer;
    DWORD   c;
    int     err;
    DWORD   mode;

    //
    // make space for NULL terminator
    //
    dwLength -= 1;                  
    *pdwLengthReturn = 0;               

    GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), 
                   &mode);
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                   (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), 
                          &ch, 
                          1, 
                          &c, 
                          0);
        if (!err || c != 1)
            ch = 0xffff;
    
        if ((ch == CR) || (ch == 0xffff))    // end of line
            break;

        if (ch == BACKSPACE) {  // back up one or two 
            //
            // IF pszBufCur == buf then the next two lines are a no op.
            // Because the user has basically backspaced back to the start
            //
            if (pszBufCur != szBuffer) {
                pszBufCur--;
                (*pdwLengthReturn)--;
            }
        }
        else {

            *pszBufCur = ch;

            if (*pdwLengthReturn < dwLength) 
                pszBufCur++ ;                   // don't overflow buf 
            (*pdwLengthReturn)++;            // always increment pdwLengthReturn 
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);

    //
    // NULL terminate the string
    //
    *pszBufCur = NULLC;         
    putchar(NEWLINE);

    return((*pdwLengthReturn <= dwLength) ? TRUE : FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ndsext\exe\client32.cpp ===
#include "main.h"
#include <nwcalls.h>
#include <nwnet.h>
#include <nwlocale.h>
#include "typedef.h"

DWORD LoadNetwareDLLs();

PF_NWCallsInit pfNWCallsInit = NULL;
PF_NWFreeUnicodeTables pfNWFreeUnicodeTables= NULL;
PF_NWInitUnicodeTables pfNWInitUnicodeTables= NULL;
PF_NWLlocaleconv pfNWLlocaleconv= NULL;
PF_NWDSFreeContext pfNWDSFreeContext= NULL;
PF_NWDSFreeBuf pfNWDSFreeBuf= NULL;
PF_NWDSLogout pfNWDSLogout= NULL;
PF_NWDSGetAttrDef pfNWDSGetAttrDef= NULL;
PF_NWDSGetAttrCount pfNWDSGetAttrCount= NULL;
PF_NWDSReadAttrDef pfNWDSReadAttrDef= NULL;
PF_NWDSPutAttrName pfNWDSPutAttrName= NULL;
PF_NWDSInitBuf pfNWDSInitBuf= NULL;
PF_NWDSAllocBuf pfNWDSAllocBuf= NULL;
PF_NWDSLogin pfNWDSLogin= NULL;
PF_NWDSSetContext pfNWDSSetContext= NULL;
PF_NWDSGetContext pfNWDSGetContext= NULL;
PF_NWIsDSAuthenticated pfNWIsDSAuthenticated= NULL;
PF_NWDSCreateContext pfNWDSCreateContext= NULL;
PF_NWDSModifyClassDef pfNWDSModifyClassDef = NULL;
PF_NWDSDefineAttr pfNWDSDefineAttr = NULL;
HINSTANCE calwin32LibraryHandle = NULL;
HINSTANCE locwin32LibraryHandle = NULL;
HINSTANCE netwin32LibraryHandle = NULL;

DWORD Client32CheckSchemaExtension(
    PWSTR szServer, 
    PWSTR szContext,
    PWSTR szUser, 
    PWSTR szPasswd,
    BOOL *pfExtended
    )
{
    NWDSContextHandle  context = NULL;
    pBuf_T             pInBuf = NULL;
    pBuf_T             pOutBuf = NULL;
    BOOL               fFreeUnicodeTable = FALSE;
    BOOL               fLoggedIn= FALSE;
    BOOL               fLogout = TRUE;

    nint32             lIterationHandle;
    Attr_Info_T        attrInfo;
    NWDSCCODE          ccode;
    nuint32            luTotalAttr;
    nstr8              strAttrName[MAX_SCHEMA_NAME_CHARS];
    nuint              i;
    LCONV              lConvInfo;

    nstr8              treeName[MAX_DN_CHARS+1];
    nstr8              strName[MAX_DN_CHARS+1];

    BOOL               fSchemaExtended = FALSE;
    DWORD WinError;

    PSTR pszServer = NULL;
    PSTR pszContext = NULL;
    PSTR pszUser = NULL;
    PSTR pszPasswd = NULL;

    //
    // We only check server and extended because they are the only must-have
    // parameters
    //
    if (!(szServer && pfExtended)) {
        ERR(("Invalid parameters.\n"));
        WinError = ERROR_INVALID_PARAMETER;
        BAIL();
    }

    //
    // Basic initialization
    //
    WinError = LoadNetwareDLLs();
    if (WinError) {
        BAIL();
    }

    ccode = pfNWCallsInit(NULL,NULL);
    if (ccode) {
        ERR(("NWCallsInit returned %X\n", ccode));
        BAIL();
    }

    pfNWLlocaleconv(&lConvInfo);

    ccode = pfNWInitUnicodeTables(lConvInfo.country_id,
                                lConvInfo.code_page);
    if (ccode) {
        ERR(("NWInitUnicodeTables returned %X\n", ccode));
        BAIL();
    }

    fFreeUnicodeTable = TRUE;
    
    context = pfNWDSCreateContext();
    if (context == (NWDSContextHandle)ERR_CONTEXT_CREATION) {
        ERR(("NWDSCreateContext failed\n"));
        BAIL();
    }

    pszServer = AllocateAnsiString(szServer);
    if (pszServer == NULL) {
        WinError = ERROR_NO_SYSTEM_RESOURCES;
        BAIL();
    }

    if (szContext == NULL) {
        goto doit;
    }

    pszContext = AllocateAnsiString(szContext);
    if (pszContext == NULL) {
        WinError = ERROR_NO_SYSTEM_RESOURCES;
        BAIL();
    }
    pszUser = AllocateAnsiString(szUser);
    if (pszUser == NULL) {
        WinError = ERROR_NO_SYSTEM_RESOURCES;
        BAIL();
    }
    pszPasswd = AllocateAnsiString(szPasswd);
    if (pszPasswd == NULL) {
        WinError = ERROR_NO_SYSTEM_RESOURCES;
        BAIL();
    }

    if(!pfNWIsDSAuthenticated()) {
        DEBUGOUT(("The system is not authenticated.\n"));
    }
    else {
        DEBUGOUT(("The system has been authenticated already\n"));

        //
        // Get Current tree's name
        //  
        ccode = pfNWDSGetContext(context, DCK_TREE_NAME, &treeName);
        if(ccode) {
            ERR(("Get context returned %X\n", ccode));
            BAIL();
        }
        DEBUGOUT(("Current Tree is %s.\n",treeName));
    
        //
        // Get current context's name
        //
        ccode = pfNWDSGetContext(context, DCK_NAME_CONTEXT, &strName);
        if(ccode) {
            ERR(("\nGet context returned %X", ccode));
            BAIL();
        }
        DEBUGOUT(("Current Context is %s.\n",strName));
        
        //
        // If the current tree and context is the same as the desired tree
        // and context, we do not need to logout. Because that would blow out
        // the connection.
        //
        if ((_stricmp(treeName,pszServer) == 0) && 
            (_stricmp(strName,pszContext) == 0)) {
            DEBUGOUT(("Will not logout.\n",strName));
            fLogout = FALSE;  
        }
    }

    //  
    // Set context to another tree
    //
    ccode = pfNWDSSetContext(context,
                           DCK_TREE_NAME,
                           pszServer
                           );
    if(ccode) {
        ERR(("\nSet context returned %X", ccode));
        BAIL();
    }
    
    //
    // Set context to another context   
    //
    ccode = pfNWDSSetContext(
                        context,
                        DCK_NAME_CONTEXT,
                        pszContext
                        );
    if(ccode) {
        ERR(("\nSet context returned %X", ccode));
        BAIL();
    }
    
    //
    // Get Current tree's name
    //  
    ccode = pfNWDSGetContext(context, DCK_TREE_NAME, &treeName);
    if(ccode) {
        ERR(("\nGet context returned %X", ccode));
        BAIL();
    }
    DEBUGOUT(("Current tree is %s.\n",treeName));

    ccode = pfNWDSGetContext(context, DCK_NAME_CONTEXT, &strName);
    if(ccode) {
        ERR(("\nGet context returned %X", ccode));
        BAIL();
    }
    DEBUGOUT(("Current conext is now %s.\n",strName));

    //
    // Logging into new tree
    //  
    DEBUGOUT(("Logging in...\n"));
    ccode = pfNWDSLogin(context, 0, pszUser, pszPasswd, 0);
    if(ccode) {
        ERR(("\nNWDSLogin returned %X\n", ccode));
        BAIL();
    }
    else { 
        fLoggedIn = TRUE; 
        DEBUGOUT(("Logged in successfully.\n"));
    }

doit:
    if(pfNWIsDSAuthenticated())
        DEBUGOUT(("The system has been authenticated already\n"));
    else
        DEBUGOUT(("The system is not authenticated.\n"));

    ccode = pfNWDSAllocBuf(DEFAULT_MESSAGE_LEN, &pInBuf);
    if(ccode) {
        ERR(("\nNWDSAllocBuf returned %X", ccode));
        BAIL();
    }
    
    ccode = pfNWDSAllocBuf(DEFAULT_MESSAGE_LEN, &pOutBuf);
    if(ccode) {
        ERR(("\nNWDSAllocBuf returned %X", ccode));
        BAIL();
    }
    
    ccode = pfNWDSInitBuf(context, DSV_READ_ATTR_DEF, pInBuf);
    if(ccode) {
        ERR(("\nNWDSInitBuf returned %X", ccode));
        BAIL();
    }
    
    ccode = pfNWDSPutAttrName(context, pInBuf, (PSTR)g_szAttributeNameA);
    if(ccode) {
        ERR(("\nNWDSPutAttrName returned %X", ccode));
        BAIL();
    }
    
    lIterationHandle = NO_MORE_ITERATIONS;  

    ccode = pfNWDSReadAttrDef(context,
                            DS_ATTR_DEFS,    /* infoType, attribute definitions    */
                            FALSE,           /* allAttrs = false, passing in one   */
                            pInBuf,          /* through this buffer (strAttrNames) */
                            &lIterationHandle,
                            pOutBuf);
    if (ccode == ERR_NO_SUCH_ATTRIBUTE) {
        ccode = 0;
        BAIL();
    }
    else if (ccode) {
        ERR(("\nNWDSReadAttrDef returned %X", ccode));
        BAIL();
    }
    
    ccode = pfNWDSGetAttrCount(context, pOutBuf, &luTotalAttr);
    if(ccode) {
        ERR(("\nNWDSGetAttrCount returned %X", ccode));
        BAIL();
    }

    if (luTotalAttr == 1) {
        ccode = pfNWDSGetAttrDef(context, pOutBuf, strAttrName, &attrInfo);
        if(ccode) {
            ERR(("\nNWDSGetAttrCount returned %X", ccode));
            BAIL();
        }
        if (strcmp(strAttrName,(PSTR)g_szAttributeNameA) == 0) {
            fSchemaExtended = TRUE;
        }
        DEBUGOUT(("Successfully retrieved information off Client32.\n"));
    }  

error:
    if (fLogout & fLoggedIn) {
        DEBUGOUT(("We are logging out.\n",strName));
        pfNWDSLogout(context);
    }
    if (pInBuf)
        pfNWDSFreeBuf(pInBuf);
    if (pOutBuf)
        pfNWDSFreeBuf(pOutBuf);
    if (context)
        pfNWDSFreeContext(context);
    if (fFreeUnicodeTable)
        pfNWFreeUnicodeTables();
    if (pszServer)
        MemFree(pszServer);
    if (pszContext)
        MemFree(pszContext);
    if (pszUser)
        MemFree(pszUser);
    if (pszPasswd)
        MemFree(pszPasswd);
    
    *pfExtended = fSchemaExtended;

    if (WinError == 0 && (ccode != 0)) {
        WinError = ERROR_EXTENDED_ERROR;
        SelectivePrint(MSG_NETWARE_ERROR,ccode);
    }
    return WinError;
}

DWORD Client32ExtendSchema(
    PWSTR szServer, 
    PWSTR szContext,
    PWSTR szUser, 
    PWSTR szPasswd
    )
{
    NWDSContextHandle  context = NULL;
    pBuf_T             pInBuf = NULL;
    pBuf_T             pOutBuf = NULL;
    BOOL               fFreeUnicodeTable = FALSE;
    BOOL               fLoggedIn= FALSE;
    BOOL               fLogout = TRUE;

    NWDSCCODE          ccode;
    nstr8              strAttrName[MAX_SCHEMA_NAME_CHARS];
    nuint              i;
    LCONV              lConvInfo;

    DWORD dwSyntaxId;
    DWORD dwMinValue = 0;
    DWORD dwMaxValue = -1;
    Asn1ID_T *pasn1ID;
    Attr_Info_T AttrInfo;

    nstr8              treeName[MAX_DN_CHARS+1];
    nstr8              strName[MAX_DN_CHARS+1];

    DWORD WinError;

    PSTR pszServer = NULL;
    PSTR pszContext = NULL;
    PSTR pszUser = NULL;
    PSTR pszPasswd = NULL;

    //
    // We only check server and extended because they are the only must-have
    // parameters
    //
    if (!(szServer)) {
        ERR(("Invalid parameters.\n"));
        WinError = ERROR_INVALID_PARAMETER;
        BAIL();
    }

    WinError = LoadNetwareDLLs();
    if (WinError) {
        BAIL();
    }

    ccode = pfNWCallsInit(NULL,NULL);
    if (ccode) {
        ERR(("NWCallsInit returned %X\n", ccode));
        BAIL();
    }

    pfNWLlocaleconv(&lConvInfo);

    ccode = pfNWInitUnicodeTables(lConvInfo.country_id,
                                lConvInfo.code_page);
    if (ccode) {
        ERR(("NWInitUnicodeTables returned %X\n", ccode));
        BAIL();
    }

    fFreeUnicodeTable = TRUE;
    
    context = pfNWDSCreateContext();
    if (context == (NWDSContextHandle)ERR_CONTEXT_CREATION) {
        ERR(("NWDSCreateContext failed\n"));
        BAIL();
    }

    pszServer = AllocateAnsiString(szServer);
    if (pszServer == NULL) {
        WinError = ERROR_NO_SYSTEM_RESOURCES;
        BAIL();
    }

    if (szContext == NULL) {
        goto extendnow;
    }

    pszContext = AllocateAnsiString(szContext);
    if (pszContext == NULL) {
        WinError = ERROR_NO_SYSTEM_RESOURCES;
        BAIL();
    }
    pszUser = AllocateAnsiString(szUser);
    if (pszUser == NULL) {
        WinError = ERROR_NO_SYSTEM_RESOURCES;
        BAIL();
    }
    pszPasswd = AllocateAnsiString(szPasswd);
    if (pszPasswd == NULL) {
        WinError = ERROR_NO_SYSTEM_RESOURCES;
        BAIL();
    }
    
    if(!pfNWIsDSAuthenticated()) {
        DEBUGOUT(("The system is not authenticated.\n"));
    }
    else {
        DEBUGOUT(("The system has been authenticated already\n"));

        //
        // Get Current tree's name
        //  
        ccode = pfNWDSGetContext(context, DCK_TREE_NAME, &treeName);
        if(ccode) {
            ERR(("Get context returned %X\n", ccode));
            BAIL();
        }
        DEBUGOUT(("Current Tree is %s.\n",treeName));
    
        //
        // Get current context's name
        //
        ccode = pfNWDSGetContext(context, DCK_NAME_CONTEXT, &strName);
        if(ccode) {
            ERR(("\nGet context returned %X", ccode));
            BAIL();
        }
        DEBUGOUT(("Current Context is %s.\n",strName));
        
        //
        // If the current tree and context is the same as the desired tree
        // and context, we do not need to logout. Because that would blow out
        // the connection.
        //
        if ((_stricmp(treeName,pszServer) == 0) && 
            (_stricmp(strName,pszContext) == 0)) {
            DEBUGOUT(("Will not logout.\n",strName));
            fLogout = FALSE;  
        }
    }

    //  
    // Set context to another tree
    //
    ccode = pfNWDSSetContext(context,
                           DCK_TREE_NAME,
                           pszServer
                           );
    if(ccode) {
        ERR(("\nSet context returned %X", ccode));
        BAIL();
    }
    
    //
    // Set context to another context   
    //
    ccode = pfNWDSSetContext(
                        context,
                        DCK_NAME_CONTEXT,
                        pszContext
                        );
    if(ccode) {
        ERR(("\nSet context returned %X", ccode));
        BAIL();
    }
    
    //
    // Get Current tree's name
    //  
    ccode = pfNWDSGetContext(context, DCK_TREE_NAME, &treeName);
    if(ccode) {
        ERR(("\nGet context returned %X", ccode));
        BAIL();
    }
    DEBUGOUT(("Current tree is %s.\n",treeName));

    ccode = pfNWDSGetContext(context, DCK_NAME_CONTEXT, &strName);
    if(ccode) {
        ERR(("\nGet context returned %X", ccode));
        BAIL();
    }
    DEBUGOUT(("Current conext is now %s.\n",strName));

    //
    // Logging into new tree
    //  
    DEBUGOUT(("Logging in...\n"));
    ccode = pfNWDSLogin(context, 0, pszUser, pszPasswd, 0);
    if(ccode) {
        ERR(("\nNWDSLogin returned %X\n", ccode));
        BAIL();
    }
    else { 
        fLoggedIn = TRUE; 
        DEBUGOUT(("Logged in successfully.\n"));
    }

extendnow:
    if(pfNWIsDSAuthenticated())
        DEBUGOUT(("The system has been authenticated already\n"));
    else
        DEBUGOUT(("The system is not authenticated.\n"));

    AttrInfo.attrFlags = DS_SINGLE_VALUED_ATTR;
    AttrInfo.attrSyntaxID = SYN_OCTET_STRING;
    AttrInfo.attrLower = dwMinValue;
    AttrInfo.attrUpper = dwMaxValue;
    pasn1ID = &(AttrInfo.asn1ID);
    memset(pasn1ID->data,0,32);
    pasn1ID->length = 32;
    memcpy(pasn1ID->data,g_pbASN,g_dwASN);

   ccode = pfNWDSDefineAttr(context,
                          (PSTR)g_szAttributeNameA,
                          &AttrInfo);
   if(ccode) {
        if (ccode == ERR_ATTRIBUTE_ALREADY_EXISTS) {
            ERR(("\nNWDSDefineAttr returned %X", ccode));
            ERR(("The schema has been extended already\n", ccode));
            WinError = 1;
            BAIL();
        }
        ERR(("\nNWDSDefineAttr returned %X", ccode));
        BAIL();
   }

    ccode = pfNWDSAllocBuf(DEFAULT_MESSAGE_LEN, &pInBuf);
    if(ccode) {
        ERR(("\nNWDSAllocBuf returned %X", ccode));
        BAIL();
    }

    ccode = pfNWDSInitBuf(context, DSV_MODIFY_CLASS_DEF, pInBuf);
    if(ccode) {
        ERR(("\nNWDSInitBuf returned %X", ccode));
        BAIL();
    }
    
    ccode = pfNWDSPutAttrName(context, pInBuf, (PSTR)g_szAttributeNameA);
    if(ccode) {
        ERR(("\nNWDSPutAttrName returned %X", ccode));
        BAIL();
    }

    ccode = pfNWDSModifyClassDef(context, (PSTR)g_szClassA, pInBuf);
    if(ccode) {
        if (ccode == ERR_DUPLICATE_OPTIONAL) {
            ERR(("\nNWDSPutAttrName returned %X\n",ccode));
            ERR(("The schema has been extended already\n", ccode));
            WinError = 1;
            BAIL();
        }
        ERR(("\nNWDSPutAttrName returned %X", ccode));
        BAIL();
    }

error:
    if (fLogout & fLoggedIn) {
        DEBUGOUT(("We are logging out.\n",strName));
        pfNWDSLogout(context);
    }
    if (pInBuf)
        pfNWDSFreeBuf(pInBuf);
    if (context)
        pfNWDSFreeContext(context);
    if (fFreeUnicodeTable)
        pfNWFreeUnicodeTables();
    if (pszServer)
        MemFree(pszServer);
    if (pszContext)
        MemFree(pszContext);
    if (pszUser)
        MemFree(pszUser);
    if (pszPasswd)
        MemFree(pszPasswd);
    
    if (WinError == 0 && (ccode != 0)) {
        WinError = ERROR_EXTENDED_ERROR;
        SelectivePrint(MSG_NETWARE_ERROR,ccode);
    }
    return WinError;
}


DWORD LoadNetwareDLLs() 
{
    DWORD WinError = 0;

    calwin32LibraryHandle = LoadLibraryA("calwin32.DLL");
    if (calwin32LibraryHandle == NULL) {
        WinError = GetLastError();
        ERR(("loadlib failed with %d\n,WinError"));
        BAIL();
    }
    locwin32LibraryHandle = LoadLibraryA("locwin32.DLL");
    if (locwin32LibraryHandle == NULL) {
        WinError = GetLastError();
        ERR(("loadlib failed with %d\n,WinError"));
        BAIL();
    }
    netwin32LibraryHandle = LoadLibraryA("netwin32.DLL");
    if (netwin32LibraryHandle == NULL) {
        WinError = GetLastError();
        ERR(("loadlib failed with %d\n,WinError"));
        BAIL();
    }

    pfNWCallsInit =  (PF_NWCallsInit) GetProcAddress(
                                        calwin32LibraryHandle,
                                        "NWCallsInit");
    if (pfNWCallsInit == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWFreeUnicodeTables =  (PF_NWFreeUnicodeTables) GetProcAddress(
                                        locwin32LibraryHandle,
                                        "NWFreeUnicodeTables");
    if (pfNWFreeUnicodeTables == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWInitUnicodeTables =  (PF_NWInitUnicodeTables) GetProcAddress(
                                        locwin32LibraryHandle,
                                        "NWInitUnicodeTables");
    if (pfNWInitUnicodeTables == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWLlocaleconv =  (PF_NWLlocaleconv) GetProcAddress(
                                        locwin32LibraryHandle,
                                        "NWLlocaleconv");
    if (pfNWLlocaleconv == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWDSFreeContext =  (PF_NWDSFreeContext) GetProcAddress(
                                        netwin32LibraryHandle,
                                        "NWDSFreeContext");
    if (pfNWDSFreeContext == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWDSFreeBuf =  (PF_NWDSFreeBuf) GetProcAddress(
                                        netwin32LibraryHandle,
                                        "NWDSFreeBuf");
    if (pfNWDSFreeBuf == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWDSLogout =  (PF_NWDSLogout) GetProcAddress(
                                        netwin32LibraryHandle,
                                        "NWDSLogout");
    if (pfNWDSLogout == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWDSGetAttrDef =  (PF_NWDSGetAttrDef) GetProcAddress(
                                        netwin32LibraryHandle,
                                        "NWDSGetAttrDef");
    if (pfNWDSGetAttrDef == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWDSGetAttrCount =  (PF_NWDSGetAttrCount) GetProcAddress(
                                        netwin32LibraryHandle,
                                        "NWDSGetAttrCount");
    if (pfNWDSGetAttrCount == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWDSReadAttrDef =  (PF_NWDSReadAttrDef) GetProcAddress(
                                        netwin32LibraryHandle,
                                        "NWDSReadAttrDef");
    if (pfNWDSReadAttrDef == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWDSPutAttrName =  (PF_NWDSPutAttrName) GetProcAddress(
                                        netwin32LibraryHandle,
                                        "NWDSPutAttrName");
    if (pfNWDSPutAttrName == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWDSInitBuf =  (PF_NWDSInitBuf) GetProcAddress(
                                        netwin32LibraryHandle,
                                        "NWDSInitBuf");
    if (pfNWDSInitBuf == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWDSAllocBuf =  (PF_NWDSAllocBuf) GetProcAddress(
                                        netwin32LibraryHandle,
                                        "NWDSAllocBuf");
    if (pfNWDSAllocBuf == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWDSLogin =  (PF_NWDSLogin) GetProcAddress(
                                        netwin32LibraryHandle,
                                        "NWDSLogin");
    if (pfNWDSLogin == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWDSSetContext =  (PF_NWDSSetContext) GetProcAddress(
                                        netwin32LibraryHandle,
                                        "NWDSSetContext");
    if (pfNWDSSetContext == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWDSGetContext =  (PF_NWDSGetContext) GetProcAddress(
                                        netwin32LibraryHandle,
                                        "NWDSGetContext");
    if (pfNWDSGetContext == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWIsDSAuthenticated =  (PF_NWIsDSAuthenticated) GetProcAddress(
                                        netwin32LibraryHandle,
                                        "NWIsDSAuthenticated");
    if (pfNWIsDSAuthenticated == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWDSCreateContext =  (PF_NWDSCreateContext) GetProcAddress(
                                        netwin32LibraryHandle,
                                        "NWDSCreateContext");
    if (pfNWDSCreateContext == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWDSModifyClassDef =  (PF_NWDSModifyClassDef) GetProcAddress(
                                        netwin32LibraryHandle,
                                        "NWDSModifyClassDef");
    if (pfNWDSModifyClassDef == NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
    pfNWDSDefineAttr =  (PF_NWDSDefineAttr) GetProcAddress(
                                        netwin32LibraryHandle,
                                        "NWDSDefineAttr");
    if (pfNWDSDefineAttr== NULL) {
        WinError = GetLastError();
        ERR(("getprocaddress failed with %d\n,WinError"));
        BAIL();
    }
error:
    return WinError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ndsext\exe\main.h ===
#ifndef _MAIN_H
#define _MAIN_H

//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Windows Headers
//
#include <windows.h>
#include <rpc.h>

//
// CRunTime Includes
//
#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include <string.h>

//
// ********** Other Includes
//
#include "memory.h"
#include "debug.h"
#include "msg.h"
#include "globals.h"

DWORD Client32CheckSchemaExtension(
    PWSTR szServer, 
    PWSTR szContext,
    PWSTR szUser, 
    PWSTR szPasswd,
    BOOL *pfExtended
    );

DWORD NWAPICheckSchemaExtension(
    PWSTR szServer, 
    PWSTR szContext,
    PWSTR szUser, 
    PWSTR szPasswd,
    BOOL *pfExtended
    );

DWORD NWAPIExtendSchema(
    PWSTR szServer, 
    PWSTR szContext,
    PWSTR szUser, 
    PWSTR szPasswd
    );

DWORD Client32ExtendSchema(
    PWSTR szServer, 
    PWSTR szContext,
    PWSTR szUser, 
    PWSTR szPasswd
    );

void SelectivePrint(DWORD messageID, ...);
void SelectivePrintWin32(DWORD dwError);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ndsext\inc\memory.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    memory.h

Abstract:

    This is the header file that will be precompiled. Include this in all
    the source files

Environment:

    User mode

Revision History:

    10/08/98 -felixw-
        Created it

--*/

#ifndef _MEMORY
#define _MEMORY

#ifdef __cplusplus
extern "C" {
#endif

#define LL_MEMORY_ERROR    0x00000100 

STDAPI_(PSTR)
MemAllocStr_E(PSTR in);
STDAPI_(PWSTR)
MemAllocStrW_E(PWSTR in);
STDAPI_(LPVOID)
MemAlloc_E(DWORD dwBytes);
STDAPI_(LPVOID)
MemRealloc_E(LPVOID IpMem, DWORD dwBytes);

DWORD
MemSize(
   LPVOID pMem
);

LPVOID
MemAlloc(
    DWORD cb
);

BOOL
MemFree(
   LPVOID pMem
);

LPVOID
MemRealloc(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

PSTR
MemAllocStr(
    PSTR pStr
);

PWSTR
MemAllocStrW(
    PWSTR pStr
);


BOOL
MemReallocStr(
   PSTR *ppStr,
   PSTR pStr
);

int UnicodeToAnsiString(PCWSTR pszUnicode,PSTR pszAnsi);
PSTR AllocateAnsiString(PCWSTR  pszUnicodeString);
PWSTR AllocateUnicodeString(PCSTR  pszAnsiString);
int AnsiToUnicodeString(PCSTR pszAnsi,PWSTR pszUnicode);

#if DBG

extern LIST_ENTRY MemList ;

extern CRITICAL_SECTION MemCritSect ;

STDAPI_(VOID) InitMem(
    VOID
    ) ;

VOID AssertMemLeaks(
    VOID
    ) ;


VOID
DumpMemoryTracker();

#else

#define InitMem()
#define AssertMemLeaks()
#define DumpMemoryTracker()

#endif

#ifdef __cplusplus
}
#endif


#endif // _MEMORY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ndsext\exe\nw32.cpp ===
#include "main.h"
#include <ndsapi32.h>
#include <nds32.h>
#include <ndsattr.h>
#include <ndssntx.h>

DWORD NWAPICheckSchemaExtension(
    PWSTR szServer, 
    PWSTR szContext,
    PWSTR szUser, 
    PWSTR szPasswd,
    BOOL *pfExtended
    )
{       
    DWORD  dwStatus = NO_ERROR;

    HANDLE hAttrOperationData = NULL;
    HANDLE hTree = NULL;
    DWORD dwNumEntries = 0L;
    DWORD dwInfoType;
    LPNDS_ATTR_DEF lpAttrDef = NULL;
    DWORD WinError = 0;

    BOOL fSchemaExtended = FALSE;

    DWORD dwSize;
    PWSTR pszUserName = NULL;
    PWSTR pszServerName = NULL;

    if (!(szServer && pfExtended)) {
        ERR(("Invalid parameters.\n"));
        WinError = ERROR_INVALID_PARAMETER;
        BAIL();
    }

    dwSize = (wcslen((PWSTR)g_szServerPrefix) + wcslen(szServer) + 1) * sizeof(WCHAR);
    pszServerName = (PWSTR)MemAlloc(dwSize);
    if (pszServerName== NULL) {
        WinError = ERROR_NO_SYSTEM_RESOURCES;
        BAIL();
    }

    wcscpy(pszServerName,(PWSTR)g_szServerPrefix);
    wcscat(pszServerName,szServer);

    if (szContext) {
        dwSize = wcslen(szContext) + wcslen(szUser) + wcslen((PWSTR)g_szDot) + 1;
        dwSize *= sizeof(WCHAR);
    
        pszUserName = (PWSTR)MemAlloc(dwSize);
        if (pszUserName == NULL) {
            WinError = ERROR_NO_SYSTEM_RESOURCES;
            BAIL();
        }
    
        wcscpy(pszUserName,szUser);
        wcscat(pszUserName,g_szDot);
        wcscat(pszUserName,szContext);
    }

    dwStatus = NwNdsOpenObject(pszServerName,
                               pszUserName,
                               szPasswd,
                               &hTree,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
    
    if ( dwStatus ) {   
        WinError = GetLastError();
        ERR(( "Error: NwNdsOpenObject returned dwStatus 0x%.8X\n", dwStatus));
        ERR(( "Error: GetLastError returned: 0x%.8X\n\n",WinError));
        BAIL();
    }

    dwStatus = NwNdsCreateBuffer(
                        NDS_SCHEMA_READ_ATTR_DEF,
                        &hAttrOperationData
                        );
    if ( dwStatus ) {   
        WinError = GetLastError();
        ERR(( "Error: NwNdsOpenObject returned dwStatus 0x%.8X\n", dwStatus));
        ERR(( "Error: GetLastError returned: 0x%.8X\n\n",WinError));
        BAIL();
    }

    dwStatus = NwNdsPutInBuffer(
                   (PWSTR)g_szAttributeName,
                   0,
                   NULL,
                   0,
                   0,
                   hAttrOperationData
                   );
    if ( dwStatus ) {   
        WinError = GetLastError();
        ERR(( "Error: NwNdsOpenObject returned dwStatus 0x%.8X\n", dwStatus));
        ERR(( "Error: GetLastError returned: 0x%.8X\n\n",WinError));
        BAIL();
    }

    dwStatus = NwNdsReadAttrDef(
                   hTree,
                   NDS_INFO_NAMES_DEFS,
                   & hAttrOperationData
                   );
    if (dwStatus == NDS_ERR_NO_SUCH_ATTRIBUTE) {
        dwStatus = 0;
        goto error;
    }
    else if ( dwStatus ) {   
        WinError = GetLastError();
        ERR(( "Error: NwNdsOpenObject returned dwStatus 0x%.8X\n", dwStatus));
        ERR(( "Error: GetLastError returned: 0x%.8X\n\n",WinError));
        BAIL();
    }

    dwStatus = NwNdsGetAttrDefListFromBuffer(
                   hAttrOperationData,
                   & dwNumEntries,
                   & dwInfoType,
                   (void **)& lpAttrDef
                   );
    if ( dwStatus ) {   
        WinError = GetLastError();
        ERR(( "Error: NwNdsOpenObject returned dwStatus 0x%.8X\n", dwStatus));
        ERR(( "Error: GetLastError returned: 0x%.8X\n\n",WinError));
        BAIL();
    }

    if (dwNumEntries == 1 && dwInfoType == 1) {
        if (wcscmp(lpAttrDef->szAttributeName,g_szAttributeName) == 0) {
            fSchemaExtended = TRUE;
        }
        DEBUGOUT(("Successfully retrieved information off GSNW/CSNW.\n"));
    }
error:
    *pfExtended = fSchemaExtended;
    if (dwStatus && dwStatus != -1) {
        SelectivePrint(MSG_NETWARE_ERROR,dwStatus);
    }
    if(hTree){
        dwStatus = NwNdsCloseObject(hTree);
    }
    if(hAttrOperationData){
        dwStatus = NwNdsFreeBuffer(hAttrOperationData);
    }
    if (pszUserName) 
        MemFree(pszUserName);
    if (pszServerName)
        MemFree(pszServerName);
    return WinError;
}

DWORD NWAPIExtendSchema(
    PWSTR szServer, 
    PWSTR szContext,
    PWSTR szUser, 
    PWSTR szPasswd
    )
{       
    DWORD dwSyntaxId;
    DWORD dwMinValue = 0;
    DWORD dwMaxValue = -1;
    ASN1_ID  asn1Id;
    DWORD  dwStatus = NO_ERROR;
    HANDLE hTree;
    HANDLE hClasses = NULL;
    DWORD WinError = NO_ERROR;

    DWORD dwSize;
    PWSTR pszUserName = NULL;
    PWSTR pszServerName = NULL;

    if (!(szServer)) {
        ERR(("Invalid parameters.\n"));
        WinError = ERROR_INVALID_PARAMETER;
        BAIL();
    }

    dwSize = (wcslen((PWSTR)g_szServerPrefix) + wcslen(szServer) + 1) * sizeof(WCHAR);
    pszServerName = (PWSTR)MemAlloc(dwSize);
    if (pszServerName== NULL) {
        WinError = ERROR_NO_SYSTEM_RESOURCES;
        BAIL();
    }

    wcscpy(pszServerName,(PWSTR)g_szServerPrefix);
    wcscat(pszServerName,szServer);

    if (szContext) {
        dwSize = wcslen(szContext) + wcslen(szUser) + wcslen((PWSTR)g_szDot) + 1;
        dwSize *= sizeof(WCHAR);
    
        pszUserName = (PWSTR)MemAlloc(dwSize);
        if (pszUserName == NULL) {
            WinError = ERROR_NO_SYSTEM_RESOURCES;
            BAIL();
        }
    
        wcscpy(pszUserName,szUser);
        wcscat(pszUserName,g_szDot);
        wcscat(pszUserName,szContext);
    }

    asn1Id.length = 32;
    memset(asn1Id.data,0,32);
    memcpy(asn1Id.data,g_pbASN,g_dwASN);

    dwStatus = NwNdsOpenObject(pszServerName,
                               pszUserName,
                               szPasswd,
                               &hTree,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL );
    
    if (dwStatus) {   
        WinError = GetLastError();
        ERR(( "\nError: NwNdsOpenObject returned dwStatus 0x%.8X\n", dwStatus ));
        ERR(( "Error: GetLastError returned: 0x%.8X\n\n",WinError));
        BAIL();
    }
    
    dwStatus = NwNdsDefineAttribute(hTree,
                                    (PWSTR)g_szAttributeName,
                                    NDS_SINGLE_VALUED_ATTR,
                                    NDS_SYNTAX_ID_9,
                                    dwMinValue,
                                    dwMaxValue,
                                    asn1Id );
    if ( dwStatus ) {
        if (dwStatus == NDS_ERR_ATTRIBUTE_ALREADY_EXISTS) {
            DEBUGOUT(("The attribute exists already!\n"));
            dwStatus = 0;
            WinError = 1;
            BAIL();
        }
        WinError = GetLastError();
        ERR(( "\nError: NwNdsDefineAttribute returned dwStatus 0x%.8X\n", dwStatus ));
        ERR(( "Error: GetLastError returned: 0x%.8X\n\n",WinError));
        BAIL();
    }

    dwStatus = NwNdsAddAttributeToClass(hTree,
                                        (PWSTR)g_szClass,
                                        (PWSTR)g_szAttributeName);
    if ( dwStatus ) {
        WinError = GetLastError();
        ERR(( "\nError: NwNdsAddAttributeToClass returned dwStatus 0x%.8X\n", dwStatus ));
        ERR(( "Error: GetLastError returned: 0x%.8X\n\n",WinError));
        BAIL();
    }

error:
    if(hTree)
        dwStatus = NwNdsCloseObject(hTree);
    if (pszUserName) 
        MemFree(pszUserName);
    if (pszServerName)
        MemFree(pszServerName);
    if (dwStatus && dwStatus != -1) {
        SelectivePrint(MSG_NETWARE_ERROR,dwStatus);
    }
    return WinError;
}


DWORD NWAPIUnextendSchema(
    PWSTR szServer, 
    PWSTR szContext,
    PWSTR szUser, 
    PWSTR szPasswd
    )
{
    DWORD dwStatus = NO_ERROR;
    HANDLE hTree = NULL;
    DWORD dwSize;
    PWSTR pszUserName = NULL;
    PWSTR pszServerName = NULL;
    DWORD WinError = NO_ERROR;

    if (!(szServer && szContext && szUser && szPasswd)) {
        ERR(("Invalid parameters.\n"));
        WinError = ERROR_INVALID_PARAMETER;
        BAIL();
    }

    dwSize = wcslen(szContext) + wcslen(szUser) + wcslen((PWSTR)g_szDot) + 1;
    dwSize *= sizeof(WCHAR);

    pszUserName = (PWSTR)MemAlloc(dwSize);
    if (pszUserName == NULL) {
        WinError = ERROR_NO_SYSTEM_RESOURCES;
        BAIL();
    }

    wcscpy(pszUserName,szUser);
    wcscat(pszUserName,g_szDot);
    wcscat(pszUserName,szContext);

    dwSize = (wcslen((PWSTR)g_szServerPrefix) + wcslen(szServer) + 1) * sizeof(WCHAR);
    pszServerName = (PWSTR)MemAlloc(dwSize);
    if (pszServerName== NULL) {
        WinError = ERROR_NO_SYSTEM_RESOURCES;
        BAIL();
    }

    wcscpy(pszServerName,(PWSTR)g_szServerPrefix);
    wcscat(pszServerName,szServer);
    
    dwStatus = NwNdsOpenObject( pszServerName,
                                pszUserName,
                                szPasswd,
                                &hTree,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL );
    if (dwStatus) {   
        WinError = GetLastError();
        ERR(( "\nError: NwNdsOpenObject returned dwStatus 0x%.8X\n", dwStatus ));
        ERR(( "Error: GetLastError returned: 0x%.8X\n\n",WinError));
        BAIL();
    }

    dwStatus = NwNdsDeleteAttrDef( hTree, 
                                   (PWSTR)g_szAttributeName );
    if (dwStatus) {
        WinError = GetLastError();
        ERR(( "\nError: NwNdsDeleteAttrDef returned dwStatus 0x%.8X\n", dwStatus ));
        ERR(( "Error: GetLastError returned: 0x%.8X\n\n",WinError));
        BAIL();
    }

error:
    if(hTree)
        dwStatus = NwNdsCloseObject(hTree);
    if (pszUserName) 
        MemFree(pszUserName);
    if (pszServerName)
        MemFree(pszServerName);
    return WinError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ndsext\inc\debug.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debugging support for the DirSync project. None of these
    generate any code in the retail build.

Environment:

    User mode

Revision History:

    03/18/98 -srinivac-
        Created it

--*/


#ifndef _DEBUG_H_
#define _DEBUG_H_

#ifdef __cplusplus
extern "C" {
#endif

#if DBG

//
// External functions
//

STDAPI_(PCSTR) StripDirPrefixA(PCSTR);

//
// This variable maintains the current debug level. Any calls to generate
// debug messages succeeds if the requested level is greater than or equal
// to the current level.
//

extern DWORD gdwDebugLevel;

//
// List of debug levels for gdwDebugLevel
//

#define DBG_LEVEL_VERBOSE   0x00000001
#define DBG_LEVEL_INFO      0x00000002
#define DBG_LEVEL_WARNING   0x00000003
#define DBG_LEVEL_ERROR     0x00000004


//
// Internal macros. Don't call these directly
//

#define CHECK_DBG_LEVEL(level)  ((level) >= gdwDebugLevel)

#define DBGMSG(level, msg)                                              \
        {                                                               \
            if (CHECK_DBG_LEVEL(level))                                 \
            {                                                           \
                DbgPrint("DirSync(%d): %s(%u): ",                       \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DbgPrint msg;                                           \
            }                                                           \
        }


#define DBGPRINT(level, msg)                                            \
        {                                                               \
            if (CHECK_DBG_LEVEL(level))                                 \
            {                                                           \
                DbgPrint msg;                                           \
            }                                                           \
        }


//
// These are the main macros that you'll be using in your code.
// Note that you should enclose the msg in additional
// paranthesis as shown in the example below.
//
// WARNING(("Out of memory"));
// ERR(("Incorrect return value: %d", rc));
//

#define VERBOSE(msg)       DBGMSG(DBG_LEVEL_VERBOSE, msg)
#define INFO(msg)          DBGMSG(DBG_LEVEL_INFO,   msg)
#define WARNING(msg)       DBGMSG(DBG_LEVEL_WARNING, msg)
#define ERR(msg)           DBGMSG(DBG_LEVEL_ERROR,   msg)
#define ERR_RIP(msg)       DBGMSG(DBG_LEVEL_ERROR,   msg);RIP()
#define RIP()              DebugBreak()
#define DEBUGOUT(msg)      DbgPrint msg


//
// These macros are used for asserting certain conditions. They are
// independent of the debugging level.
// These also require additional paranthesis to enclose the msg as
// shown below.
//
// ASSERT(x > 0);
// ASSERTMSG(x > 0, ("x less than 0: x=%d", x));
//

#ifdef ASSERT
#undef ASSERT
#undef ASSERTMSG
#endif

#define ASSERT(expr)                                                    \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
                DbgPrint("DirSync(%d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DebugBreak();                                           \
            }                                                           \
        }


#define ASSERTMSG(expr, msg)                                            \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
                DbgPrint("DirSync(%d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DbgPrint msg;                                           \
                DbgPrint("\n");                                         \
                DebugBreak();                                           \
            }                                                           \
        }

#else // !DBG

#define DBGMSG(level, msg)
#define VERBOSE(msg)
#define INFO(msg)
#define WARNING(msg)
#define ERR(msg)
#define ERR_RIP(msg)
#define RIP()
#define DEBUGOUT(msg)

#define ASSERT(expr)
#define ASSERTMSG(expr, msg)

#endif

//
// The following macros let you enable debugging on a per feature basis.
// To use these macros, here is what you should do:
//
// At the beginning of the file (after header includes):
//
//  1. Define a bit constant for each capability you want to debug
//  2. For each feature, add the following line
//       DEFINE_FEATURE_FLAGS(featurename, flags);
//     where flags is a bit-wise OR of the capabilities you want to debug for
//     that feature
//  3. In your code add the following line wherever you want debug messages
//       FEATURE_DEBUG(featurename, flag, (msg));
//
//  E.g. let us say I am implementing a memory manager, and I would like to
//       trace memory allocations and frees. Here is what I would do
//
//       #define FLAG_ALLOCATE   1
//       #define FLAG_FREE       2
//
//       DEFINE_FEATURE_FLAGS(MemMgr, FLAG_ALLOCATE);
//
//       void *MemAlloc(DWORD dwSize)
//       {
//           FEATURE_DEBUG(MemMgr, FLAG_ALLOCATE, ("Memory of size %d allocated", dwSize));
//           ...
//       }
//
//       void MemFree(void *pvMem)
//       {
//           FEATURE_DEBUG(MemMgr, FKAG_FREE, ("Memory freed"));
//           ...
//       }
//
//  Note that I have set this up to send only alloc messages to the debugger,
//  but I can break into the debugger and modify dwMemMgrDbgFlags to
//  send free messages as well.
//
//  Once component testing of a feature is completed, flags parameter in
//  DEFINE_FEATURE_FLAGS should be changed to 0, so by default this feature
//  does not send debug messages to the debugger.
//

#if DBG

//
// Global debug flag that can used to set values to all other flags
//

extern DWORD gdwGlobalDbgFlags;

#define DEFINE_FEATURE_FLAGS(feature, flags)                            \
            DWORD gdw##feature##DbgFlags = (flags)

#define EXTERN_FEATURE_FLAGS(feature)                                   \
            extern DWORD gdw##feature##DbgFlags

#define FEATURE_DEBUG(feature, flag, msg)                               \
        {                                                               \
            if (gdw##feature##DbgFlags & (flag) ||                      \
                gdwGlobalDbgFlags & (flag))                             \
            {                                                           \
                DbgPrint msg;                                           \
            }                                                           \
        }

#define FEATURE_DEBUG_FN(feature, flag, func)                           \
        {                                                               \
            if (gdw##feature##DbgFlags & (flag) ||                      \
                gdwGlobalDbgFlags & (flag))                             \
            {                                                           \
                func;                                                   \
            }                                                           \
        }

#define FLAG_INFO               0x01
#define FLAG_VERBOSE            0x02
#define FLAG_FNTRACE            0x04
#define FLAG_FULLTRACE          0xFFFF

#else // !DBG

#define DEFINE_FEATURE_FLAGS(feature, flags)
#define EXTERN_FEATURE_FLAGS(feature)
#define FEATURE_DEBUG(feature, flag, msg)
#define FEATURE_DEBUG_FN(feature, flag, func)

#endif // !DBG

//
// Macros for error handling
//

#define BAIL_ON_FAILURE(hr)                             \
            if (FAILED(hr))                             \
            {                                           \
                goto error;                             \
            }

#define BAIL_ON_FAILURE_WITH_MSG(err, msg)              \
            if (FAILED(hr))                             \
            {                                           \
                ERR(msg);                               \
                goto error;                             \
            }

#define BAIL_ON_NULL(ptr)                               \
            if ((ptr) == NULL)                          \
            {                                           \
                ERR(("Error allocating memory\n"));     \
                hr = E_OUTOFMEMORY;                     \
                goto error;                             \
            }

#define BAIL()  goto error


#ifdef __cplusplus
}
#endif

#endif  // ifndef _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ndsext\exe\typedef.h ===
//
// calwin32
//
typedef NWCCODE (*PF_NWCallsInit) (
  nptr reserved1,
  nptr reserved2
);

//
// locwin32
//
typedef nint (*PF_NWFreeUnicodeTables) (
   void
);

typedef nint (*PF_NWInitUnicodeTables) (
   nint countryCode,
   nint codePage
);

typedef LCONV N_FAR * (*PF_NWLlocaleconv) (
    LCONV N_FAR *lconvPtr
);


//
// netwin32
//

typedef NWDSCCODE (*PF_NWDSModifyClassDef) (
   NWDSContextHandle context,
   pnstr8            className,
   pBuf_T            optionalAttrs
);

typedef NWDSCCODE (*PF_NWDSFreeContext) (
   NWDSContextHandle context
);

typedef NWDSCCODE (*PF_NWDSFreeBuf) (
   pBuf_T   buf
);

typedef NWDSCCODE (*PF_NWDSLogout) (
   NWDSContextHandle context
);

typedef NWDSCCODE (*PF_NWDSGetAttrDef) (
   NWDSContextHandle context,
   pBuf_T            buf,
   pnstr8            attrName,
   pAttr_Info_T      attrInfo
);

typedef NWDSCCODE (*PF_NWDSGetAttrCount) (
   NWDSContextHandle context,
   pBuf_T            buf,
   pnuint32          attrCount
);

typedef NWDSCCODE (*PF_NWDSReadAttrDef) (
   NWDSContextHandle context,
   nuint32           infoType,
   nbool8            allAttrs,
   pBuf_T            attrNames,
   pnint32           iterationHandle,
   pBuf_T            attrDefs
);

typedef NWDSCCODE (*PF_NWDSPutAttrName) (
   NWDSContextHandle context,
   pBuf_T            buf,
   pnstr8            attrName
);

typedef NWDSCCODE (*PF_NWDSInitBuf) (
   NWDSContextHandle context,
   nuint32           operation,
   pBuf_T            buf
);

typedef NWDSCCODE (*PF_NWDSAllocBuf) (
   size_t   size,
   ppBuf_T  buf
);

typedef NWDSCCODE (*PF_NWDSLogin) (
   NWDSContextHandle context,
   nflag32           optionsFlag,
   pnstr8            objectName,
   pnstr8            password,
   nuint32           validityPeriod
);

typedef NWDSCCODE (*PF_NWDSSetContext) (
   NWDSContextHandle context,
   nint              key,
   nptr              value
);
typedef NWDSCCODE (*PF_NWDSGetContext) (
   NWDSContextHandle context,
   nint              key,
   nptr              value
);

typedef NWCCODE (*PF_NWIsDSAuthenticated) (
   void
);

typedef NWDSContextHandle (*PF_NWDSCreateContext) (
   void
);

typedef NWDSContextHandle (*PF_NWDSDefineAttr) (
   NWDSContextHandle context,
   pnstr8            attrName,
   pAttr_Info_T      attrDef
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ndsext\inc\utils.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    This is the header file that will be precompiled. Include this in all
    the source files

Environment:

    User mode

Revision History:

    03/20/98 -srinivac-
        Created it

--*/

#ifndef _UTILS_H_
#define _UTILS_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <objidl.h>
#include <stdio.h>

#include "symhelp.h"
#include "debug.h"
#include "memory.h"

#endif // ifndef _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ndsext\utils\debug.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This file contains debug support functions. These do not produce any
    code in the retail build.

Environment:

    User mode

Revision History:

    03/20/98 -srinivac-
        Created it

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <objidl.h>
#include <stdio.h>

#include "symhelp.h"
#include "debug.h"

#if DBG

//
// Variable for maintaining current debug level
//

DWORD gdwDebugLevel = DBG_LEVEL_WARNING;

//
// Global debugging flag
//

DWORD gdwGlobalDbgFlags = 0;

PCSTR
StripDirPrefixA(
    PCSTR pszPathName
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    DWORD dwLen = lstrlenA(pszPathName);

    pszPathName += dwLen - 1;       // go to the end

    while (*pszPathName != '\\' && dwLen--)
    {
        pszPathName--;
    }

    return pszPathName + 1;
}

#endif  // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ndsext\utils\memory.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module provides all the memory management functions 

Author:

    Krishna Ganugapati (KrishnaG) 03-Feb-1994

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
#include "debug.h"
#include "memory.h"
#include "symhelp.h"

//#define WORD_ALIGN_DOWN(addr) ((LPBYTE)((DWORD)addr &= ~1))
#define DWORD_ALIGN_UP(size) ((size+3)&~3)

DWORD
MemSizeOri(
   LPVOID pMem
);

int
UnicodeToAnsiString(
    PCWSTR pszUnicode,
    PSTR pszAnsi
    )

/*++

Routine Description:

    Convert a Unicode string to ansi. If the same string is passed in to the
    result string pszAnsi, it will use the same blob of memory.

Arguments:

    pszUnicode - the unicode string to be converted to an ansi string
    pszAnsi  - the result ansi string

Return Value:

--*/

{
    PSTR  pszTemp = NULL;
    int   rc = 0;
    DWORD dwLength = 0;

    dwLength = wcslen(pszUnicode) + 1;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if(pszAnsi == (PSTR)pszUnicode) {
        pszTemp = (PSTR)MemAlloc_E(dwLength);
        if (!pszTemp) {
            return rc;
        }
        pszAnsi = pszTemp;
    }

    if(pszAnsi) {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pszUnicode,
                                  dwLength,
                                  pszAnsi,
                                  dwLength,
                                  NULL,
                                  NULL );
    }

    //
    // If szTemp is non-null, we must copy the resulting string
    // so that it looks as if we did it in place:
    //
    if( pszTemp && ( rc > 0 ) ) {
        pszAnsi = (PSTR)pszUnicode;
        strcpy( pszAnsi, pszTemp );
        MemFree( pszTemp );
    }

    return rc;
}

PSTR
AllocateAnsiString(
    PCWSTR  pszUnicodeString
    )

/*++

Routine Description:

    Allocate an Ansi string with a unicode string as input

Arguments:

    pszUnicodeString - the unicode string to be converted to an ansi string

Return Value:

--*/

{
    PSTR pszAnsiString = NULL;
    int rc = 0;

    ASSERT(pszUnicodeString);

    pszAnsiString = (PSTR)MemAlloc(wcslen(pszUnicodeString)+1);

    if (pszAnsiString) {
        rc = UnicodeToAnsiString(
                pszUnicodeString,
                pszAnsiString
                );
    }

    if (rc>0) {
        return pszAnsiString;
    }

    if (pszAnsiString) {
        MemFree(pszAnsiString);
    }

    return NULL;
}

int
AnsiToUnicodeString(
    PCSTR pszAnsi,
    PWSTR pszUnicode
    )

/*++

Routine Description:

    Convert an ansi string to unicode. An output string of enough size
    is expected to be passed in.

Arguments:

    pszUnicode - the unicode string to be converted to an ansi string
    pszAnsi  - the result ansi string

Return Value:

--*/

{
    int rc;
    DWORD dwLength = strlen(pszAnsi);

    rc = MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             pszAnsi,
                             dwLength + 1,
                             pszUnicode,
                             dwLength + 1);

    //
    // Ensure NULL termination.
    //
    pszUnicode[dwLength] = 0;

    return rc;
}


LPWSTR
AllocateUnicodeString(
    PCSTR  pszAnsiString
    )

/*++

Routine Description:

    Allocate a Unicode string with an ansi string as input

Arguments:

    pszAnsiString - the ansi string to be converted to a unicode string

Return Value:

--*/

{
    PWSTR  pszUnicodeString = NULL;
    int rc;

    ASSERT(pszAnsiString);

    pszUnicodeString = (PWSTR)MemAlloc(strlen(pszAnsiString)*sizeof(WCHAR) +
                                       sizeof(WCHAR));

    if (pszUnicodeString) {
        rc = AnsiToUnicodeString(
                pszAnsiString,
                pszUnicodeString
                );
    }

    if (rc>0) {
        return pszUnicodeString;
    }

    if (pszUnicodeString) {
        MemFree(pszUnicodeString);
    }
    return NULL;
}

PSTR MemAllocStr_E(
    PSTR pszIn
    ) 
{
    PSTR pszTemp;
    
    pszTemp = (PSTR)MemAlloc_E((strlen(pszIn)+1)*sizeof(char));
    
    if (pszTemp==NULL) {
        return NULL;
    }

    return strcpy(pszTemp, pszIn);

}

PWSTR MemAllocStrW_E(
    PWSTR pszIn
    ) 
{
    PWSTR pszTemp;
    
    pszTemp = (PWSTR)MemAlloc_E((wcslen(pszIn)+1)*sizeof(WCHAR));
    
    if (pszTemp==NULL) {
        return NULL;
    }

    return wcscpy(pszTemp, pszIn);

}


LPVOID MemAlloc_E(
    DWORD dwBytes
    ) 
{
    LPVOID pReturn = NULL;
    pReturn = MemAlloc(dwBytes);
    if (!pReturn) {
        RaiseException(LL_MEMORY_ERROR, 0, 0, NULL);    
    }
    return pReturn;
}

LPVOID MemRealloc_E(
            LPVOID IpMem, 
            DWORD dwBytes
            ) 
{
    DWORD dwSize;
    LPVOID pReturn = NULL;

    dwSize = MemSizeOri(IpMem);

    pReturn = MemRealloc(IpMem,dwSize,dwBytes);
    if (!pReturn) {
        RaiseException(LL_MEMORY_ERROR, 0, 0, NULL);    
    }
    return pReturn;

}   

#if DBG

DWORD dwMemoryLog = 1;

#define MAXDEPTH 10

typedef struct _MEMTAG {
    DWORD Tag ;
    DWORD Size ;
    PVOID pvBackTrace[MAXDEPTH+1];
    LPSTR pszSymbol[MAXDEPTH+1];
    DWORD uDepth;
    LIST_ENTRY List ;
} MEMTAG, *PMEMTAG ;

LIST_ENTRY       MemList ;
DWORD            MemCount ;
CRITICAL_SECTION MemCritSect ;

/*++

Routine Description:

    This function initializes the mem tracking code. Must be call
    during DLL load an ONLY during DLL load.

Arguments:

    None

Return Value:

    None.

--*/
VOID InitMem(
    VOID
)
{
    InitializeCriticalSection(&MemCritSect) ;
    InitializeListHead(&MemList) ;
    MemCount = 0 ;
}

/*++

Routine Description:

    This function asserts that the mem list is empty on exit.

Arguments:

    None

Return Value:

    None.

--*/
VOID AssertMemLeaks(
    VOID
)
{
    ASSERT(IsListEmpty(&MemList)) ;
}

#endif

LPVOID
MemAlloc(
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
#if DBG
    DWORD cbNew ;
    PMEMTAG pMem ;
    DWORD i = 0;

    ULONG ulHash;

    //
    // adjust size for our tag and one spare dword at end
    // and allocate the memory
    //
    cb = DWORD_ALIGN_UP(cb);

    cbNew = cb + ( sizeof(MEMTAG) + sizeof(DWORD) );

    pMem=(PMEMTAG)LocalAlloc(LPTR, cbNew);

    if (!pMem) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    //
    // fill in deadbeef at end and tag info.
    // and insert it into the MemList
    //

    *(LPDWORD)((LPBYTE)pMem+cbNew-sizeof(DWORD)) = 0xdeadbeef;
    pMem->Tag = 0xB00FB00F ;
    pMem->Size = cb ;


    //
    // Capture a backtrace at this spot for debugging.
    //

#if (defined(i386) && !defined(WIN95))

    pMem->uDepth = RtlCaptureStackBackTrace(
                            0,
                            MAXDEPTH,
                            pMem->pvBackTrace,
                            &ulHash
                            );



#else

    pMem->uDepth = 0;

#endif


    EnterCriticalSection(&MemCritSect) ;
    InsertHeadList(&MemList, &pMem->List) ;
    MemCount++ ;
    LeaveCriticalSection(&MemCritSect) ;

    //
    // skip past the mem tag
    //
    pMem++ ;
    return (LPVOID)(pMem);
#else
    return(LocalAlloc(LPTR, cb));
#endif

}

BOOL
MemFree(
   LPVOID pMem
)
{
#if DBG
    DWORD        cb;
    DWORD        cbNew = 0;
    PMEMTAG pNewMem ;
    LPDWORD      pRetAddr;
    DWORD i = 0;



    pNewMem = (PMEMTAG)pMem;
    pNewMem -- ;

    cb = pNewMem->Size;
    cbNew = cb + sizeof(DWORD) + sizeof(MEMTAG);

    //
    // check the trailing deadbeef and remove from list
    //

    if (*(LPDWORD)(((LPBYTE)pNewMem) + cbNew - sizeof(DWORD)) != 0xdeadbeef) {
        ERR(("Freeing memory not allocated by MemAlloc"));
        return FALSE;
    }

    EnterCriticalSection(&MemCritSect) ;
    RemoveEntryList(&pNewMem->List) ;
    MemCount-- ;
    LeaveCriticalSection(&MemCritSect) ;


    for (i = 0; i < pNewMem->uDepth; i++) {

        if (pNewMem->pszSymbol[i]) {
            LocalFree(pNewMem->pszSymbol[i]);
        }
    }


    //
    // Whack freed memory with known pattern
    //

    memset(pMem, 0x65, cb);
    return(LocalFree((LPVOID)pNewMem) == NULL);

#else

    return(LocalFree(pMem) == NULL);

#endif


}

DWORD
MemSize(
   LPVOID pMem
)
{
#if DBG
    DWORD        cb;
    DWORD        cbNew = 0;
    PMEMTAG      pNewMem ;
    LPDWORD      pRetAddr;
    DWORD i = 0;



    pNewMem = (PMEMTAG)pMem;
    pNewMem -- ;

    cb = pNewMem->Size;
    cbNew = cb + sizeof(DWORD) + sizeof(MEMTAG);

    if (*(LPDWORD)(((LPBYTE)pNewMem) + cbNew - sizeof(DWORD)) != 0xdeadbeef) {
        ERR(("Getting size not allocated by MemAlloc!"));
        return 0;
    }

    return((DWORD)LocalSize((LPVOID)pNewMem));
#else
    return((DWORD)LocalSize(pMem));
#endif
}

DWORD
MemSizeOri(
   LPVOID pMem
)
{
#if DBG
    DWORD        cb;
    PMEMTAG      pNewMem ;

    pNewMem = (PMEMTAG)pMem;
    pNewMem -- ;

    cb = pNewMem->Size;

    return((DWORD)cb);
#else
    return((DWORD)LocalSize(pMem));
#endif
}



LPVOID
MemRealloc(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
)
{
    LPVOID pNewMem;

    pNewMem=MemAlloc(cbNew);

    if (pOldMem && pNewMem) {
        memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        MemFree(pOldMem);
    }

    return pNewMem;
}

LPSTR
MemAllocStr(
    LPSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
   LPSTR pMem;

   if (!pStr)
      return 0;

   if (pMem = (LPSTR)MemAlloc( strlen(pStr)*sizeof(CHAR) + sizeof(CHAR) ))
      strcpy(pMem, pStr);

   return pMem;
}

PWSTR
MemAllocStrW(
    PWSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
   PWSTR pMem;

   if (!pStr)
      return 0;

   if (pMem = (PWSTR)MemAlloc( wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR) ))
      wcscpy(pMem, pStr);

   return pMem;
}

BOOL
MemReallocStr(
   LPSTR *ppStr,
   LPSTR pStr
)
{
   if (ppStr && (*ppStr)) {
        MemFree(*ppStr);
        *ppStr=MemAllocStr(pStr);

        return TRUE;
    }
    else {
        return FALSE;
    }
}


#if DBG
VOID
DumpMemoryTracker(
    VOID
    )
{
#ifndef _WIN64
   LIST_ENTRY* pEntry;
   MEMTAG*  pMem;
   BYTE*       pTemp;
   DWORD i = 0;
   CHAR szSymbolPath[MAX_PATH+1];
   DWORD dwCount = 0;

   pEntry   = MemList.Flink;

   if (!dwMemoryLog) {
      return;
   }


   if ( pEntry == &MemList ) {
       OutputDebugStringA( "No Memory leaks found\n" );
   }

   while( pEntry != &MemList )
   {
      CHAR szLeak[1024];

      pTemp = (BYTE*)pEntry;
      pTemp = pTemp - sizeof(DWORD) - sizeof(DWORD)
              - sizeof(DWORD) -
              (sizeof(CHAR*) + sizeof(LPVOID))*( MAXDEPTH +1);
      pMem  = (MEMTAG*)pTemp;

      sprintf(
        szLeak,
        "[oleds] Memory leak!!! Addresss = %.8x Size = %ld \n",
        pMem + 1,
        pMem->Size
        );
      OutputDebugStringA( szLeak );


     for (i = 0; i < pMem->uDepth; i++) {

         dwCount = TranslateAddress(
                     (ULONG)pMem->pvBackTrace[ i ],
                     szSymbolPath,
                     MAX_PATH
                     );
         szSymbolPath[dwCount] = '\0';
         sprintf(szLeak, "%s\n",szSymbolPath);
         OutputDebugStringA( szLeak);

     }

      pEntry   = pEntry->Flink;
   }
#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nocairo\newop.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:  MEMORY.CXX
//
//----------------------------------------------------------------------------

#include "dswarn.h"
#include <ADs.hxx>


//+---------------------------------------------------------------------------
//
//  Function:   ADsAlloc, public
//
//  Synopsis:   Global allocator for ADs.
//
//  Effects:    Keeps track of the most recent heap allocation in each
//        thread. This information is used to determine when to
//        unlink CUnwindable objects.
//
//  Arguments:  [size] -- Size of the memory to allocate.
//
//  Returns:    A pointer to the allocated memory.
//
//  Modifies:   _pLastNew in _exceptioncontext.
//
//----------------------------------------------------------------------------

void*
ADsAlloc( size_t size )
{
    void *p;

    p  = (void *)LocalAlloc( LMEM_FIXED, size );

    return ( p );
}


//+---------------------------------------------------------------------------
//
//  Function:   ADsFree
//
//  Synopsis:   Matches the ADsAlloc above
//
//  Arguments:  [p] -- The pointer to delete.
//
//  Requires:   [p] was called with ADsFree
//
//  Derivation: Never override.
//
//----------------------------------------------------------------------------

void
ADsFree ( void * p )
{
    if( p == NULL ){
        return;
    }

    if( LocalFree( (HLOCAL)p ) != NULL )
        Win4Assert(!"Bad ptr for operator delete");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nocairo\oledsdbg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       oledsdbg.cxx
//
//  Contents:
//
//
//  History:
//
//----------------------------------------------------------------------------

#include "dswarn.h"
#include <ADs.hxx>

#if DBG==1

#include <stdio.h>
#include <printf.h>


unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

CRITICAL_SECTION g_csDP; // used by debug print routines

//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguments:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

void APINOT
vdprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs
    )
{

    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
        EnterCriticalSection(&g_csDP);
        DWORD tid = GetCurrentThreadId();
        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf( "%03d> ", tid );
                w4dprintf("%s: ", pszComp);
            }
            w4vdprintf(ppszfmt, pargs);
        }

        if (Win4InfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4printf( "%03d> ", tid );
                w4printf("%s: ", pszComp);
            }
            w4vprintf(ppszfmt, pargs);
        }

        LeaveCriticalSection(&g_csDP);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int APINOT
PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile
    )
{

    int id;
    static char szAssertCaption[100];

    DWORD tid = GetCurrentThreadId();

    sprintf(szAssertCaption,"File: %s line %u, thread id %d",
        szFile, iLine, tid);

    id = MessageBoxA(
                NULL,
                (char *) szMsg,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                );

    return id;
}


//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:
//
//----------------------------------------------------------------------------


void APINOT
Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage
    )
{

    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s File: %s Line: %u, thread id %d\n",
                   szMessage, szFile, iLine, tid);
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ndsext\utils\symhelp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Defines the interfaces to the SYMHELP dynamic link library.  Useful for programs
    that want to maintain a debug informaiton data base.

Author:

    Steve Wood (stevewo) 11-Mar-1994

Revision History:

    Mike Seaman (mikese) 20-Jan-1995    Added TranslateAddress

--*/

#ifndef _DEBUGFILE_
#define _DEBUGFILE_

#include <debnot.h>

#ifndef _WIN64
typedef enum _LOAD_SYMBOLS_FILTER_REASON {
    LoadSymbolsPathNotFound,
    LoadSymbolsDeferredLoad,
    LoadSymbolsLoad,
    LoadSymbolsUnload,
    LoadSymbolsUnableToLoad
} LOAD_SYMBOLS_FILTER_REASON;

typedef BOOL (*PLOAD_SYMBOLS_FILTER_ROUTINE)(
    HANDLE UniqueProcess,
    LPSTR ImageFilePath,
    DWORD ImageBase,
    DWORD ImageSize,
    LOAD_SYMBOLS_FILTER_REASON Reason
    );

BOOL
InitializeImageDebugInformation(
    IN PLOAD_SYMBOLS_FILTER_ROUTINE LoadSymbolsFilter,
    IN HANDLE TargetProcess,
    IN BOOL NewProcess,
    IN BOOL GetKernelSymbols
    );

BOOL
AddImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase,
    IN DWORD ImageSize
    );

BOOL
RemoveImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase
    );

PIMAGE_DEBUG_INFORMATION
FindImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN DWORD Address
    );

ULONG
GetSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    );

//
// The following function is essentially identical in operation to
//  GetSymbolicNameForAddress, except that it:
//
//  1. Operates only on the calling process.
//  2. Does not require any previous calls to AddImageDebugInformation et al.
//     That is, debug information for all currently loaded modules will
//     be added automatically.

ULONG
TranslateAddress (
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    );

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ndsext\utils\symhelp.c ===
#ifndef _WIN64
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    symhelp.c

Abstract:

    Symbol Helper for debugging

Author:

    Steve Wood (stevewo) 11-Mar-1994

Revision History:

--*/


#define _SYMHELP_SOURCE_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <debug.h>
#include <stdio.h>
#include <stdlib.h>
#include "symhelp.h"

//
// Primitives to access symbolic debug information in an image file
//

typedef struct _RTL_SYMBOL_INFORMATION {
    ULONG Type;
    ULONG SectionNumber;
    ULONG Value;
    STRING Name;
} RTL_SYMBOL_INFORMATION, *PRTL_SYMBOL_INFORMATION;

NTSTATUS
RtlLookupSymbolByAddress(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL,
    IN PVOID Address,
    IN ULONG ClosenessLimit,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation,
    OUT PRTL_SYMBOL_INFORMATION NextSymbolInformation OPTIONAL
    );

typedef struct _PROCESS_DEBUG_INFORMATION {
    LIST_ENTRY List;
    HANDLE UniqueProcess;
    DWORD ImageBase;
    DWORD EndOfImage;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    UCHAR ImageFilePath[ MAX_PATH ];
} PROCESS_DEBUG_INFORMATION, *PPROCESS_DEBUG_INFORMATION;


PLOAD_SYMBOLS_FILTER_ROUTINE LoadSymbolsFilterRoutine;

RTL_CRITICAL_SECTION LoadedImageDebugInfoListCritSect;
LIST_ENTRY LoadedImageDebugInfoListHead;
LIST_ENTRY LoadedProcessDebugInfoListHead;

LPSTR SymbolSearchPath;

// This variable tracks how many times InitializeImageDebugInformation has been
//  called. Certain operations are performed only on the first call (as
//  NumInitCalls transitions from -1 to 0).
LONG NumInitCalls = -1;

LPSTR
GetEnvVariable(
    IN LPSTR VariableName
    )
{
    NTSTATUS Status;
    STRING Name, Value;
    UNICODE_STRING UnicodeName, UnicodeValue;

    RtlInitString( &Name, VariableName );
    RtlInitUnicodeString( &UnicodeValue, NULL );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &Name, TRUE );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }

    Status = RtlQueryEnvironmentVariable_U( NULL, &UnicodeName, &UnicodeValue );
    if (Status != STATUS_BUFFER_TOO_SMALL) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
        return NULL;
        }

    UnicodeValue.MaximumLength = UnicodeValue.Length + sizeof( UNICODE_NULL );
    UnicodeValue.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, UnicodeValue.MaximumLength );
    if (UnicodeValue.Buffer == NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
        return NULL;
        }

    Status = RtlQueryEnvironmentVariable_U( NULL, &UnicodeName, &UnicodeValue );
    if (!NT_SUCCESS( Status )) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValue.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
        return NULL;
        }

    Status = RtlUnicodeStringToAnsiString( &Value, &UnicodeValue, TRUE );
    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValue.Buffer );
    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }

    Value.Buffer[ Value.Length ] = '\0';
    return Value.Buffer;
}

LPSTR
SetSymbolSearchPath( )
{
    ULONG Size, i, Attributes, NumberOfSymbolPaths;
    LPSTR s, SymbolPaths[ 4 ];

    if (SymbolSearchPath != NULL) {
        return SymbolSearchPath;
        }

    Size = 0;
    NumberOfSymbolPaths = 0;
    if (s = GetEnvVariable( "_NT_SYMBOL_PATH" )) {
        SymbolPaths[ NumberOfSymbolPaths++ ] = s;
        }

    if (s = GetEnvVariable( "_NT_ALT_SYMBOL_PATH" )) {
        SymbolPaths[ NumberOfSymbolPaths++ ] = s;
        }

    if (s = GetEnvVariable( "SystemRoot" )) {
        SymbolPaths[ NumberOfSymbolPaths++ ] = s;
        }

    SymbolPaths[ NumberOfSymbolPaths++ ] = ".";

    Size = 1;
    for (i=0; i<NumberOfSymbolPaths; i++) {
        Attributes = GetFileAttributesA( SymbolPaths[ i ] );
        if ( Attributes != 0xffffffff && (Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
            Size += 1 + strlen( SymbolPaths[ i ] );
            }
        else {
            SymbolPaths[ i ] = NULL;
            }
        }

    SymbolSearchPath = RtlAllocateHeap( RtlProcessHeap(), 0, Size );
    if (SymbolSearchPath == NULL) {
        return NULL;
        }
    *SymbolSearchPath = '\0';
    for (i=0; i<NumberOfSymbolPaths; i++) {
        if (s = SymbolPaths[ i ]) {
            if (*SymbolSearchPath != '\0') {
                strcat( SymbolSearchPath, ";" );
                }
            strcat( SymbolSearchPath, s );
            }
        }

    return SymbolSearchPath;
}

BOOL
InitializeImageDebugInformation(
    IN PLOAD_SYMBOLS_FILTER_ROUTINE LoadSymbolsFilter,
    IN HANDLE TargetProcess,
    IN BOOL NewProcess,
    IN BOOL GetKernelSymbols
    )
{
    PPEB Peb;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION ProcessInformation;
    PLDR_DATA_TABLE_ENTRY LdrEntry;
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    PLIST_ENTRY LdrHead, LdrNext;
    PPEB_LDR_DATA Ldr;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    LPSTR ImageFilePath;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    RTL_PROCESS_MODULES ModuleInfoBuffer;
    PRTL_PROCESS_MODULES ModuleInfo;
    PRTL_PROCESS_MODULE_INFORMATION ModuleInfo1;
    ULONG RequiredLength, ModuleNumber;

    // Is this the first call?
    if ( InterlockedIncrement ( &NumInitCalls ) == 0 )
    {
        // Yes
        SetSymbolSearchPath();
        InitializeListHead( &LoadedImageDebugInfoListHead );
        InitializeListHead( &LoadedProcessDebugInfoListHead );
        Status = RtlInitializeCriticalSection( &LoadedImageDebugInfoListCritSect );
        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }
    }

    // The filter routine can be superceded at any time.
    LoadSymbolsFilterRoutine = LoadSymbolsFilter;

    if (GetKernelSymbols) {
        ModuleInfo = &ModuleInfoBuffer;
        RequiredLength = sizeof( *ModuleInfo );
        Status = NtQuerySystemInformation( SystemModuleInformation,
                                           ModuleInfo,
                                           RequiredLength,
                                           &RequiredLength
                                         );
        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            ModuleInfo = NULL;
            Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                              &ModuleInfo,
                                              0,
                                              &RequiredLength,
                                              MEM_COMMIT,
                                              PAGE_READWRITE
                                            );
            if (NT_SUCCESS( Status )) {
                Status = NtQuerySystemInformation( SystemModuleInformation,
                                                   ModuleInfo,
                                                   RequiredLength,
                                                   &RequiredLength
                                                 );
                if (NT_SUCCESS( Status )) {
                    ModuleInfo1 = &ModuleInfo->Modules[ 0 ];
                    for (ModuleNumber=0; ModuleNumber<ModuleInfo->NumberOfModules; ModuleNumber++) {
                        if ((DWORD)(ModuleInfo1->ImageBase) & 0x80000000) {
                            if (ImageFilePath = strchr( ModuleInfo1->FullPathName, ':')) {
                                ImageFilePath -= 1;
                                }
                            else {
                                ImageFilePath = ModuleInfo1->FullPathName +
                                                strlen( ModuleInfo1->FullPathName );
                                while (ImageFilePath > ModuleInfo1->FullPathName) {
                                    if (ImageFilePath[ -1 ] == '\\') {
                                        break;
                                        }
                                    else {
                                        ImageFilePath -= 1;
                                        }
                                    }
                                }

                            AddImageDebugInformation( NULL,
                                                      ImageFilePath,
                                                      (DWORD)ModuleInfo1->ImageBase,
                                                      ModuleInfo1->ImageSize
                                                    );
                            }

                        ModuleInfo1++;
                        }
                    }

                NtFreeVirtualMemory( NtCurrentProcess(),
                                     &ModuleInfo,
                                     &RequiredLength,
                                     MEM_RELEASE
                                   );
                }
            }
        }

    if (TargetProcess == NULL) {

        // Load module information for this process.

        TargetProcess = GetCurrentProcess();
        }

    Status = NtQueryInformationProcess( TargetProcess,
                                        ProcessBasicInformation,
                                        &ProcessInformation,
                                        sizeof( ProcessInformation ),
                                        NULL
                                      );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Peb = ProcessInformation.PebBaseAddress;

    if (NewProcess) {
        return TRUE;
        }

    //
    // Ldr = Peb->Ldr
    //

    Status = NtReadVirtualMemory( TargetProcess,
                                  &Peb->Ldr,
                                  &Ldr,
                                  sizeof( Ldr ),
                                  NULL
                                );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    Status = NtReadVirtualMemory( TargetProcess,
                                  &LdrHead->Flink,
                                  &LdrNext,
                                  sizeof( LdrNext ),
                                  NULL
                                );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    while (LdrNext != LdrHead) {
        LdrEntry = CONTAINING_RECORD( LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks );
        Status = NtReadVirtualMemory( TargetProcess,
                                      LdrEntry,
                                      &LdrEntryData,
                                      sizeof( LdrEntryData ),
                                      NULL
                                    );
        if (!NT_SUCCESS( Status )) {
            return FALSE;
            }

        UnicodeString.Length = LdrEntryData.FullDllName.Length;
        UnicodeString.MaximumLength = LdrEntryData.FullDllName.MaximumLength;
        UnicodeString.Buffer = RtlAllocateHeap( RtlProcessHeap(),
                                                0,
                                                UnicodeString.MaximumLength
                                              );
        if (!UnicodeString.Buffer) {
            return FALSE;
            }
        Status = NtReadVirtualMemory( TargetProcess,
                                      LdrEntryData.FullDllName.Buffer,
                                      UnicodeString.Buffer,
                                      UnicodeString.MaximumLength,
                                      NULL
                                    );
        if (!NT_SUCCESS( Status )) {
            RtlFreeHeap( RtlProcessHeap(), 0, UnicodeString.Buffer );
            return FALSE;
            }

        RtlUnicodeStringToAnsiString( &AnsiString,
                                      &UnicodeString,
                                      TRUE
                                    );
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeString.Buffer );
        if (ImageFilePath = strchr( AnsiString.Buffer, ':')) {
            ImageFilePath -= 1;
            }
        else {
            ImageFilePath = AnsiString.Buffer;
            }

        AddImageDebugInformation( (HANDLE)ProcessInformation.UniqueProcessId,
                                  ImageFilePath,
                                  (DWORD)LdrEntryData.DllBase,
                                  LdrEntryData.SizeOfImage
                                );

        RtlFreeAnsiString( &AnsiString );

        LdrNext = LdrEntryData.InMemoryOrderLinks.Flink;
        }

    return TRUE;
}


BOOL
AddImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase,
    IN DWORD ImageSize
    )
{
    NTSTATUS Status;
    PLIST_ENTRY Head, Next;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    PPROCESS_DEBUG_INFORMATION ProcessInfo;
    HANDLE FileHandle;
    UCHAR PathBuffer[ MAX_PATH ];

    FileHandle = FindExecutableImage( ImageFilePath, SymbolSearchPath, PathBuffer );
    if (FileHandle == NULL) {
        if (LoadSymbolsFilterRoutine != NULL) {
            (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                         ImageFilePath,
                                         ImageBase,
                                         ImageSize,
                                         LoadSymbolsPathNotFound
                                       );
            }

        return FALSE;
        }
    CloseHandle( FileHandle );
    if (LoadSymbolsFilterRoutine != NULL) {
        (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                     PathBuffer,
                                     ImageBase,
                                     ImageSize,
                                     LoadSymbolsDeferredLoad
                                   );
        }

    Status = RtlEnterCriticalSection( &LoadedImageDebugInfoListCritSect );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Head = &LoadedImageDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        DebugInfo = CONTAINING_RECORD( Next, IMAGE_DEBUG_INFORMATION, List );
        if (DebugInfo->ImageBase == ImageBase &&
            !_stricmp( PathBuffer, DebugInfo->ImageFilePath )
           ) {
            break;
            }

        Next = Next->Flink;
        }

    if (Next == Head) {
        DebugInfo = NULL;
        }

    Head = &LoadedProcessDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessInfo = CONTAINING_RECORD( Next, PROCESS_DEBUG_INFORMATION, List );
        if (ProcessInfo->UniqueProcess == UniqueProcess &&
            !_stricmp( PathBuffer, ProcessInfo->ImageFilePath )
           ) {
            return TRUE;
            }

        Next = Next->Flink;
        }

    ProcessInfo = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( *ProcessInfo ) );
    if (ProcessInfo == NULL) {
        return FALSE;
        }
    ProcessInfo->ImageBase = ImageBase;
    ProcessInfo->EndOfImage = ImageBase + ImageSize;
    ProcessInfo->UniqueProcess = UniqueProcess;
    ProcessInfo->DebugInfo = DebugInfo;
    strcpy( ProcessInfo->ImageFilePath, PathBuffer );
    InsertTailList( &LoadedProcessDebugInfoListHead, &ProcessInfo->List );

    RtlLeaveCriticalSection( &LoadedImageDebugInfoListCritSect );
    return TRUE;
}


BOOL
RemoveImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase
    )
{
    PLIST_ENTRY Head, Next;
    PPROCESS_DEBUG_INFORMATION ProcessInfo;

    Head = &LoadedProcessDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessInfo = CONTAINING_RECORD( Next, PROCESS_DEBUG_INFORMATION, List );
        if (ProcessInfo->UniqueProcess == UniqueProcess &&
            (!ARGUMENT_PRESENT( ImageFilePath ) ||
             !_stricmp( ImageFilePath, ProcessInfo->ImageFilePath )
            )
           ) {
            if (LoadSymbolsFilterRoutine != NULL) {
                (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                             ProcessInfo->ImageFilePath,
                                             ProcessInfo->ImageBase,
                                             ProcessInfo->EndOfImage - ProcessInfo->ImageBase,
                                             LoadSymbolsUnload
                                           );
                }

            Next = Next->Blink;
            RemoveEntryList( &ProcessInfo->List );
            RtlFreeHeap( RtlProcessHeap(), 0, ProcessInfo );
            if (ARGUMENT_PRESENT( ImageFilePath )) {
                break;
                }
            }

        Next = Next->Flink;
        }

    return TRUE;
}

PIMAGE_DEBUG_INFORMATION
FindImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN DWORD Address
    )
{
    NTSTATUS Status;
    PLIST_ENTRY Head, Next;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    PPROCESS_DEBUG_INFORMATION ProcessInfo;

    Status = RtlEnterCriticalSection( &LoadedImageDebugInfoListCritSect );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }

    if (Address & 0x80000000) {
        UniqueProcess = NULL;
        }

    Head = &LoadedProcessDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessInfo = CONTAINING_RECORD( Next, PROCESS_DEBUG_INFORMATION, List );
        if (ProcessInfo->UniqueProcess == UniqueProcess &&
            Address >= ProcessInfo->ImageBase &&
            Address < ProcessInfo->EndOfImage
           ) {
            break;
            }

        Next = Next->Flink;
        }

    if (Next == Head) {
        RtlLeaveCriticalSection( &LoadedImageDebugInfoListCritSect );
        return NULL;
        }

    DebugInfo = ProcessInfo->DebugInfo;
    if (DebugInfo == NULL) {
        DebugInfo = MapDebugInformation( NULL, ProcessInfo->ImageFilePath, SymbolSearchPath, ProcessInfo->ImageBase );
        if (DebugInfo != NULL) {
            DebugInfo->ImageBase = ProcessInfo->ImageBase;
            ProcessInfo->DebugInfo = DebugInfo;
            if (LoadSymbolsFilterRoutine != NULL) {
                (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                             ProcessInfo->ImageFilePath,
                                             ProcessInfo->ImageBase,
                                             ProcessInfo->EndOfImage - ProcessInfo->ImageBase,
                                             LoadSymbolsLoad
                                           );
                }

            InsertTailList( &LoadedImageDebugInfoListHead, &DebugInfo->List );
            }
        else {
            if (LoadSymbolsFilterRoutine != NULL) {
                (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                             ProcessInfo->ImageFilePath,
                                             ProcessInfo->ImageBase,
                                             ProcessInfo->EndOfImage - ProcessInfo->ImageBase,
                                             LoadSymbolsUnableToLoad
                                           );
                }
            }
        }

    RtlLeaveCriticalSection( &LoadedImageDebugInfoListCritSect );
    return DebugInfo;
}


ULONG
GetSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    )
{
    NTSTATUS Status;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    RTL_SYMBOL_INFORMATION SymbolInformation;
    ULONG i, ModuleNameLength, Result, Offset;
    LPSTR s;

    DebugInfo = FindImageDebugInformation( UniqueProcess,
                                           Address
                                         );
    if (DebugInfo != NULL) {
        if (s = strchr( DebugInfo->ImageFileName, '.' )) {
            ModuleNameLength = s - DebugInfo->ImageFileName;
            }
        else {
            ModuleNameLength = strlen( DebugInfo->ImageFileName );
            }

        // [mikese] RtlLookupSymbolByAddress will fault if there is
        //  no COFF symbol information.
        if ( DebugInfo->CoffSymbols != NULL ) {
            Status = RtlLookupSymbolByAddress( (PVOID)DebugInfo->ImageBase,
                                       DebugInfo->CoffSymbols,
                                       (PVOID)Address,
                                       0x4000,
                                       &SymbolInformation,
                                       NULL
                                     );

            }
        else {
            Status = STATUS_UNSUCCESSFUL;
             }
        }
    else {
        ModuleNameLength = 0;
        Status = STATUS_UNSUCCESSFUL;
        }

    if (NT_SUCCESS( Status )) {
        s = SymbolInformation.Name.Buffer;
        i = 1;
        while (SymbolInformation.Name.Length > i &&
               isdigit( s[ SymbolInformation.Name.Length - i ] )
              ) {
            i += 1;
            }

        if (s[ SymbolInformation.Name.Length - i ] == '@') {
            SymbolInformation.Name.Length = (USHORT)(SymbolInformation.Name.Length - i);
            }

        s = Name;
        Result = _snprintf( s, MaxNameLength,
                            "%.*s!%Z",
                            ModuleNameLength,
                            DebugInfo->ImageFileName,
                            &SymbolInformation.Name
                          );
        Offset = Address - DebugInfo->ImageBase - SymbolInformation.Value;
        if (Offset != 0) {
            Result += _snprintf( s + Result, MaxNameLength - Result, "+0x%x", Offset );
            }
        }
    else {
        if (ModuleNameLength != 0) {
            Result = _snprintf( Name, MaxNameLength,
                                "%.*s!0x%08x",
                                ModuleNameLength,
                                DebugInfo->ImageFileName,
                                Address
                              );
            }
        else {
            Result = _snprintf( Name, MaxNameLength, "0x%08x", Address );
            }
        }

    return Result;
}

ULONG
TranslateAddress (
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength )
{
    PRTL_DEBUG_INFORMATION p;
    NTSTATUS Status;
    DWORD ProcessId;
    ULONG Result = 0;
    ULONG Attempts = 0;

    // We need to call Initialize once to ensure that GetSymbolicNameForAddress
    //  does not fault.
    if ( NumInitCalls == -1 )
    {
        InitializeImageDebugInformation( LoadSymbolsFilterRoutine,
                                         NULL, FALSE, FALSE );
    }

    ProcessId = GetCurrentProcessId();

    while ( Result == 0 )
    {
        Result = GetSymbolicNameForAddress ( (HANDLE)ProcessId, Address,
                                             Name, MaxNameLength );
        if ( Result == 0 )
        {
            if ( ++Attempts < 2 )
            {
                // Try reintialising, to load any modules we missed on a previous
                //  occasion (or if we haven't initialised yet).
                // I don't need a load-symbols-filter, so just use whatever is
                //  already there, if any
                InitializeImageDebugInformation( LoadSymbolsFilterRoutine,
                                                 NULL, FALSE, FALSE );
            }
            else
            {
                // Apparently we are unable to do the right thing, so just return
                //  the address as hex.
                Result = _snprintf( Name, MaxNameLength, "0x%08x", Address );
            }
        }
    }

    return Result;
}


NTSTATUS
RtlpCaptureSymbolInformation(
    IN PIMAGE_SYMBOL SymbolEntry,
    IN PCHAR StringTable,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation
    );

PIMAGE_COFF_SYMBOLS_HEADER
RtlpGetCoffDebugInfo(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL
    );

NTSTATUS
RtlLookupSymbolByAddress(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL,
    IN PVOID Address,
    IN ULONG ClosenessLimit,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation,
    OUT PRTL_SYMBOL_INFORMATION NextSymbolInformation OPTIONAL
    )
/*++

Routine Description:

    Given a code address, this routine returns the nearest symbol
    name and the offset from the symbol to that name.  If the
    nearest symbol is not within ClosenessLimit of the location,
    STATUS_ENTRYPOINT_NOT_FOUND is returned.

Arguments:

    ImageBase - Supplies the base address of the image containing
                Address

    MappedBase - Optional parameter, that if specified means the image
                 was mapped as a data file and the MappedBase gives the
                 location it was mapped.  If this parameter does not
                 point to an image file base, then it is assumed that
                 this is a pointer to the coff debug info.

    ClosenessLimit - Specifies the maximum distance that Address can be
                     from the value of a symbol to be considered
                     "found".  Symbol's whose value is further away then
                     this are not "found".

    SymbolInformation - Points to a structure that is filled in by
                        this routine if a symbol table entry is found.

    NextSymbolInformation - Optional parameter, that if specified, is
                            filled in with information about these
                            symbol whose value is the next address above
                            Address


Return Value:

    Status of operation.

--*/

{
    NTSTATUS Status;
    ULONG AddressOffset, i;
    PIMAGE_SYMBOL PreviousSymbolEntry;
    PIMAGE_SYMBOL SymbolEntry;
    IMAGE_SYMBOL Symbol;
    PUCHAR StringTable;
    BOOLEAN SymbolFound;
    PIMAGE_COFF_SYMBOLS_HEADER DebugInfo;

    DebugInfo = RtlpGetCoffDebugInfo( ImageBase, MappedBase );
    if (DebugInfo == NULL) {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    //
    // Crack the symbol table.
    //

    SymbolEntry = (PIMAGE_SYMBOL)
        ((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol);

    StringTable = (PUCHAR)
        ((ULONG)SymbolEntry + DebugInfo->NumberOfSymbols * (ULONG)IMAGE_SIZEOF_SYMBOL);


    //
    // Find the "header" symbol (skipping all the section names)
    //

    for (i = 0; i < DebugInfo->NumberOfSymbols; i++) {
        if (!strcmp( &SymbolEntry->N.ShortName[ 0 ], "header" )) {
            break;
            }

        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)SymbolEntry +
                        IMAGE_SIZEOF_SYMBOL);
        }

    //
    // If no "header" symbol found, just start at the first symbol.
    //

    if (i >= DebugInfo->NumberOfSymbols) {
        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol);
        i = 0;
        }

    //
    // Loop through all symbols in the symbol table.  For each symbol,
    // if it is within the code section, subtract off the bias and
    // see if there are any hits within the profile buffer for
    // that symbol.
    //

    AddressOffset = (ULONG)Address - (ULONG)ImageBase;
    SymbolFound = FALSE;
    for (; i < DebugInfo->NumberOfSymbols; i++) {

        //
        // Skip over any Auxilliary entries.
        //
        try {
            while (SymbolEntry->NumberOfAuxSymbols) {
                i = i + 1 + SymbolEntry->NumberOfAuxSymbols;
                SymbolEntry = (PIMAGE_SYMBOL)
                    ((ULONG)SymbolEntry + IMAGE_SIZEOF_SYMBOL +
                     SymbolEntry->NumberOfAuxSymbols * IMAGE_SIZEOF_SYMBOL
                    );

                }

            RtlMoveMemory( &Symbol, SymbolEntry, IMAGE_SIZEOF_SYMBOL );
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
            }

        //
        // If this symbol value is less than the value we are looking for.
        //

        if (Symbol.Value <= AddressOffset) {
            //
            // Then remember this symbol entry.
            //

            PreviousSymbolEntry = SymbolEntry;
            SymbolFound = TRUE;
            }
        else {
            //
            // All done looking if value of symbol is greater than
            // what we are looking for, as symbols are in address order
            //

            break;
            }

        SymbolEntry = (PIMAGE_SYMBOL)
            ((ULONG)SymbolEntry + IMAGE_SIZEOF_SYMBOL);

        }

    if (!SymbolFound || (AddressOffset - PreviousSymbolEntry->Value) > ClosenessLimit) {
        return STATUS_ENTRYPOINT_NOT_FOUND;
        }

    Status = RtlpCaptureSymbolInformation( PreviousSymbolEntry, StringTable, SymbolInformation );
    if (NT_SUCCESS( Status ) && ARGUMENT_PRESENT( NextSymbolInformation )) {
        Status = RtlpCaptureSymbolInformation( SymbolEntry, StringTable, NextSymbolInformation );
        }

    return Status;
}


NTSTATUS
RtlpCaptureSymbolInformation(
    IN PIMAGE_SYMBOL SymbolEntry,
    IN PCHAR StringTable,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation
    )
{
    USHORT MaximumLength;
    PCHAR s;

    SymbolInformation->SectionNumber = SymbolEntry->SectionNumber;
    SymbolInformation->Type = SymbolEntry->Type;
    SymbolInformation->Value = SymbolEntry->Value;

    if (SymbolEntry->N.Name.Short) {
        MaximumLength = 8;
        s = &SymbolEntry->N.ShortName[ 0 ];
        }

    else {
        MaximumLength = 64;
        s = &StringTable[ SymbolEntry->N.Name.Long ];
        }

#if i386
    if (*s == '_') {
        s++;
        MaximumLength--;
        }
#endif

    SymbolInformation->Name.Buffer = s;
    SymbolInformation->Name.Length = 0;
    while (*s && MaximumLength--) {
        SymbolInformation->Name.Length++;
        s++;
        }

    SymbolInformation->Name.MaximumLength = SymbolInformation->Name.Length;
    return( STATUS_SUCCESS );
}


PIMAGE_COFF_SYMBOLS_HEADER
RtlpGetCoffDebugInfo(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL
    )
{
    PIMAGE_COFF_SYMBOLS_HEADER DebugInfo;
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    ULONG DebugSize;
    ULONG NumberOfDebugDirectories;

    DosHeader = (PIMAGE_DOS_HEADER)MappedBase;
    if ( !DosHeader || DosHeader->e_magic == IMAGE_DOS_SIGNATURE ) {
        //
        // Locate debug section.
        //

        DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
            RtlImageDirectoryEntryToData( (PVOID)(MappedBase == NULL ? ImageBase : MappedBase),
                                          (BOOLEAN)(MappedBase == NULL ? TRUE : FALSE),
                                          IMAGE_DIRECTORY_ENTRY_DEBUG,
                                          &DebugSize
                                        );

        if (!DebugDirectory ||
            (DebugSize < sizeof(IMAGE_DEBUG_DIRECTORY)) ||
            ((DebugSize % sizeof(IMAGE_DEBUG_DIRECTORY)) != 0)) {
            return NULL;
        }
        //
        // point debug directory at coff debug directory
        //
        NumberOfDebugDirectories = DebugSize / sizeof(*DebugDirectory);

        while ( NumberOfDebugDirectories-- ) {
            if ( DebugDirectory->Type == IMAGE_DEBUG_TYPE_COFF ) {
                break;
            }
            DebugDirectory++;
        }

        if (DebugDirectory->Type != IMAGE_DEBUG_TYPE_COFF ) {
            return NULL;
        }

        if (MappedBase == NULL) {
            if (DebugDirectory->AddressOfRawData == 0) {
                return(NULL);
            }
            DebugInfo = (PIMAGE_COFF_SYMBOLS_HEADER)
                        ((ULONG) ImageBase + DebugDirectory->AddressOfRawData);
        } else {
            DebugInfo = (PIMAGE_COFF_SYMBOLS_HEADER)
                        ((ULONG) MappedBase + DebugDirectory->PointerToRawData);
        }
    } else {
        DebugInfo = (PIMAGE_COFF_SYMBOLS_HEADER)MappedBase;
    }
    return DebugInfo;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nocairo\otrack.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       otrack.cxx
//
//  Contents:   Object tracking system
//
//  Classes:    ObjectTracker
//
//  History:    06-Apr-92 MikeSe         Created
//              30-Sep-93 KyleP          DEVL obsolete
//              15-Jul-94 DonCl          grabbed from common put in forms.
//                                       absolutely minimal changes to
//                                       get it working.
//
//--------------------------------------------------------------------------

#include "dswarn.h"
#include <ADs.hxx>

#include "symtrans.h"
#include "otrackp.hxx"

// This is all unused in the retail build
#if DBG == 1
CRITICAL_SECTION g_csOT;

// this is a dummy item used as the head of the doubly-linked list
// of TrackLinks, and a mutex to protect it
static TrackLink tlHead = { &tlHead, &tlHead };

// this is a dummy item used as the head of the doubly-linked list
// of NameEntrys
static NameEntry neHead = { &neHead, &neHead };

static char * apszTypes[] = {"Create", "AddRef", "Release"};

//  initialize class static data
int ObjectTracker::_TrackAll = GetProfileInt(L"Object Track",L"DEFAULT",1);

// standard debugging stuff
DECLARE_INFOLEVEL(Ot)

extern void RecordAction ( TrackLink *tl, FrameType ft, ULONG cRefCount );
extern void _cdecl EstablishHistory ( FrameRecord * fr, int nSkip );
extern void DumpHistory ( unsigned long fDebugMask, TrackLink *tl );


//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::ObjectTracker, protected
//
//  Synopsis:   Contructor
//
//  Effects:    Allocates TrackLink structure and initialises it.
//
//  Arguments:  None
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
ObjectTracker::ObjectTracker ()
    :_ulRefs(1)
{
    // Allocate the structure which maintains the tracking history.
    // We also make space for the first FrameRecord.
    HRESULT hr = MemAlloc ( sizeof(TrackLink) + sizeof(FrameRecord),
                          (void**)&_tl);
    if ( FAILED(hr) )
    {
        OtDebugOut ((DEB_OT_ERRORS,
                     "Unable to establish tracking for %lx\n",
                     this ));
    }
    else
    {
        _tl->potr = this;
        _tl->ulSig = TRACK_LINK_SIGNATURE;
        _tl->pszName = NULL;

        FrameRecord * fr = (FrameRecord*) ( _tl + 1 );
        if ( OtInfoLevel & DEB_OT_CALLERS )
        {
            EstablishHistory ( fr, 1 );
        }
        fr->ft = FT_CREATE;
        fr->cRefCount = 1;
        fr->frNext = NULL;
        _tl->frFirst = _tl->frLast = fr;

        // insert at end of list, with concurrency control
        EnterCriticalSection(&g_csOT);
        TrackLink * tll = tlHead.tlPrev;
        tll->tlNext = tlHead.tlPrev = _tl;
        _tl->tlNext = &tlHead;
        _tl->tlPrev = tll;
        LeaveCriticalSection(&g_csOT);

        OtDebugOut ((DEB_OT_ACTIONS, "New object at %lx\n", this ));
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::TrackClassName, protected
//
//  Synopsis:   Records class name for tracked object
//
//  Arguments:  [pszName]       -- class name
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP void
ObjectTracker::TrackClassName (
    char * pszName )
{
    if ( _tl != NULL )
    {
        OtAssert (( _tl->ulSig == TRACK_LINK_SIGNATURE ));

    // Copy the class name so we don't lose it if the class DLL is
    //  unloaded.
    ULONG cBytes = strlen ( pszName ) + 1;
    HRESULT hr = MemAlloc ( cBytes, (void**)&(_tl->pszName) );
    if ( SUCCEEDED(hr) )
    {
        memcpy ( _tl->pszName, pszName, cBytes );
    }
        else
    {
        OtDebugOut((DEB_OT_ERRORS,"Memory allocation failure %lx\n",hr));
        _tl->pszName = "Name lost";
    }

        _tl->fTrack = IsClassTracking(pszName);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::StdAddRef, public
//
//  Synopsis:   Standard implementation of AddRef for tracked objects
//
//  Effects:    Increments ref count, records history
//
//  Returns:    S_OK
//
//  Modifies:   _ulRefs
//
//  Derivation: Never
//
//  History:    31-Jul-92 MikeSe        Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP ULONG
ObjectTracker::StdAddRef()
{
    InterlockedIncrement ( (LONG*)&_ulRefs );

    if (_tl->fTrack)
    {
        OtDebugOut ((DEB_OT_ACTIONS, "AddRef [%d] of object at %lx (%s)\n",
                        _ulRefs, this, _tl->pszName ));

        RecordAction ( _tl, FT_ADDREF, _ulRefs );
    }

    return _ulRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::StdRelease, public
//
//  Synopsis:   Helper function for standard implementation of Release()
//
//  Effects:    Decrements ref count, records history
//
//  Returns:    SUCCESS_NO_MORE iff ref count reached zero.
//              Otherwise S_OK or an error.
//
//  History:    31-Jul-92 MikeSe        Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP ULONG
ObjectTracker::StdRelease ()
{
    LONG lResult = InterlockedDecrement((LONG*)&_ulRefs);

    if (_tl->fTrack)
    {
        OtDebugOut ((DEB_OT_ACTIONS, "Release [%d] of object at %lx (%s)\n",
                        _ulRefs, this, _tl->pszName ));

        RecordAction ( _tl, FT_RELEASE, _ulRefs );
    }

    return (lResult==0)?0:_ulRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::~ObjectTracker, protected
//
//  Synopsis:   Destructor
//
//  Effects:    Remove this item, along with all history, from the
//              tracking list
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
ObjectTracker::~ObjectTracker()
{
    if ( _tl != NULL )
    {
        OtDebugOut ((DEB_OT_ACTIONS, "Delete of object at %lx [%s]\n",
                        this, _tl->pszName ));
        OtAssert (( _tl->ulSig == TRACK_LINK_SIGNATURE ));
        // OtAssert ( _ulRefs == 0 );

        // unlink, with concurrency control
        EnterCriticalSection(&g_csOT);
        TrackLink * tlp = _tl->tlPrev;
        TrackLink * tln = _tl->tlNext;
        tln->tlPrev = tlp;
        tlp->tlNext = tln;
        LeaveCriticalSection(&g_csOT);

        if ((_tl->fTrack) && (OtInfoLevel & DEB_OT_DELETE))
        {
            DumpHistory ( DEB_OT_DELETE, _tl );
        }
		if (_tl->pszName) {
			MemFree(_tl->pszName);
		}
        MemFree ( _tl );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::DumpTrackingInfo, public
//
//  Synopsis:   Dumps out the tracking list
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP void
ObjectTracker::DumpTrackingInfo (
    int fDeleteNode)
{
    TrackLink * tl = tlHead.tlNext;
    BOOL fHeader = FALSE;

    while ( tl != &tlHead )
    {
        // This is an unreleased item. Print out the history info

        if ( !fHeader )
        {
            OtDebugOut((DEB_OT_OBJECTS, "****************************\n"));
            OtDebugOut((DEB_OT_OBJECTS, "* Unreleased objects found *\n"));
            OtDebugOut((DEB_OT_OBJECTS, "****************************\n"));
            fHeader = TRUE;
        }

        OtDebugOut ((DEB_OT_OBJECTS,
                     "Object at %lx (%s)\n",
                     tl->potr,
                     tl->pszName ));
        OtDebugOut ((DEB_OT_OBJECTS,
                     "  Reference count = %d\n",
                     tl->potr->GetRefCount() ));
        DumpHistory ( DEB_OT_CALLERS, tl );

        if (fDeleteNode)
        {
            // unlink, with concurrency control
            EnterCriticalSection(&g_csOT);
            tl->potr->_tl = NULL;
            TrackLink * tlp = tl->tlPrev;
            TrackLink * tln = tl->tlNext;
            tln->tlPrev = tlp;
            tlp->tlNext = tln;
            LeaveCriticalSection(&g_csOT);
            MemFree ( tl );
            tl = tln;
        }
        else
        {
            tl = tl->tlNext;
        }
    }

    //  delete all the name entries
    if (fDeleteNode)
    {
        EnterCriticalSection(&g_csOT);

        //  find the entry if there is one
        NameEntry *ne =  neHead.neNext;
        while (ne != &neHead)
        {
            // unlink, with concurrency control
            NameEntry * nep = ne->nePrev;
            NameEntry * nen = ne->neNext;
            nen->nePrev = nep;
            nep->neNext = nen;
            MemFree ( ne );
            ne = nen;
        }
        LeaveCriticalSection(&g_csOT);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     TrackClass
//
//  Synopsis:   Tells the object tracker to start/stop tracking the specified
//              class of objects.
//
//  Arguments:  [fTrack   -- debug mask controlling the output
//              [pszName] -- TrackLink record
//
//  History:    14-Apr-93 Rickhi          Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
void ObjectTracker::TrackClass(int fTrack, char * pszClassName)
{
    if (pszClassName == NULL)
    {
        //  set default for ALL classes
        _TrackAll = fTrack;
        return;
    }


    //  find the entry if there is one
    NameEntry *ne =  neHead.neNext;

    while (ne != &neHead)
    {
        if (!strcmp(ne->pszName, pszClassName))
        {
            //  found our entry, update the flag
            ne->fTrack = fTrack;
            return;
        }

        ne = ne->neNext;
    }

    //  its not in the list
    HRESULT hr = MemAlloc( sizeof(NameEntry), (void **)&ne);
    if ( FAILED(hr) )
    {
        OtDebugOut((DEB_OT_ERRORS,
                    "Unable to record class for tracking %s\n",
                    pszClassName));
    }
    else
    {
        ne->pszName = pszClassName;
        ne->fTrack = fTrack;

        // insert at end of list, with concurrency control
        EnterCriticalSection(&g_csOT);
        NameEntry *neH = neHead.nePrev;
        neH->neNext = neHead.nePrev = ne;
        ne->neNext = &neHead;
        ne->nePrev = ne;
        LeaveCriticalSection(&g_csOT);
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     IhrlassTracking, private
//
//  Synopsis:   returns TRUE if the object is currently tracked
//
//  Arguments:  [pszClassName] -- class name
//
//  History:    14-Apr-93 Rickhi          Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
int ObjectTracker::IsClassTracking(char * pszClassName)
{
    //  find the entry if there is one
    NameEntry *ne =  neHead.neNext;
    while (ne != &neHead)
    {
        if (!strcmp(ne->pszName, pszClassName))
        {
            return ne->fTrack;
        }
        ne = ne->neNext;
    }

    return GetProfileIntA("Object Track",pszClassName,_TrackAll);
}

//+-------------------------------------------------------------------------
//
//  Function:   DumpHistory
//
//  Synopsis:   Dumps the call history represented by a particular TrackLink
//
//  Arguments:  [fDebugMask]    -- debug mask controlling the output
//              [tl]            -- TrackLink record
//
//  History:    28-Jul-92 MikeSe        Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void DumpHistory ( unsigned long fDebugMask, TrackLink * tl )
{
// we can't call TranslateAddress without access to NT header files
#ifndef MSVC
#ifndef WIN95
    //
    // Only do all of this work if it will output anything!
    //
    if (OtInfoLevel & fDebugMask)
    {
        OtDebugOut ((fDebugMask, "  Call history follows:\n" ));
        FrameRecord * fr = tl->frFirst;
        while ( fr != NULL )
        {
            char achBuffer[MAX_TRANSLATED_LEN];

            OtDebugOut ((fDebugMask,
                         "\t%s [%d]\n",
                         apszTypes[fr->ft],
                         fr->cRefCount ));

            for ( int I=0; (I < MAX_CALLERS) && (fr->callers[I]); I++ )
            {
                TranslateAddress ( fr->callers[I], achBuffer );
                OtDebugOut ((fDebugMask, "\t    %s\n", achBuffer));
            }

            fr = fr->frNext;
        }
    }
#endif
#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   RecordAction
//
//  Synopsis:   Record an AddRef/Release
//
//  Effects:    Allocates and fills in a new frame record
//
//  Arguments:  [tl]            -- TrackLink for object being tracked
//              [ft]            -- Frame type (FT_ADDREF, FT_RELEASE)
//              [cRefCount]     -- current ref count
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void RecordAction ( TrackLink * tl, FrameType ft, ULONG cRefCount )
{
    // Record the activity only if DEB_OT_CALLERS is set

    if ( tl != NULL && (OtInfoLevel & DEB_OT_CALLERS))
    {
        OtAssert(tl->ulSig == TRACK_LINK_SIGNATURE );
        FrameRecord * fr;
        HRESULT hr;

        hr = MemAlloc(sizeof(FrameRecord), (void **)&fr);

        if ( FAILED(hr) )
        {
            OtDebugOut((DEB_OT_ERRORS,
                        "Unable to record history for %lx\n",
                        tl->potr));
        }
        else
        {
            // Save call history
            EstablishHistory ( fr, 2 );
            fr->ft = ft;
            fr->cRefCount = cRefCount;
            fr->frNext = NULL;

            // Add to list, with concurrency control
            EnterCriticalSection(&g_csOT);
            FrameRecord * frl = tl->frLast;
            frl->frNext = tl->frLast = fr;
            LeaveCriticalSection(&g_csOT);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   EstablishHistory
//
//  Synopsis:   Records calling history for an operation
//
//  Effects:    Walks back through call frames recording caller addresses.
//
//  Arguments:  [fr]            -- FrameRecord in which to save history
//              [nFramesSkip]   -- number of frames to skip before
//                                 recording.
//
//  History:    6-Apr-92 MikeSe         Created [from PaulC's imalloc code]
//      19-Apr-94 MikeSe    Converted to use RtlCaptureStackBacktrace
//
//  Notes:
//
//--------------------------------------------------------------------------

void _cdecl
EstablishHistory (
    FrameRecord * fr,
    int nFramesSkip
    )
{

#if (defined(i386) && !defined(WIN95))

    memset ( fr->callers, 0, MAX_CALLERS * sizeof(void*) );

    ULONG ulHash;
    RtlCaptureStackBackTrace ( nFramesSkip, MAX_CALLERS,
                    fr->callers, &ulHash );
#endif // i386
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nocairo\printf.h ===
/**
*printf.h - print formatted
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines w4*printf() - print formatted data
*       defines w4v*printf() - print formatted output, get data from an
*                              argument ptr instead of explicit args.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*       14-Mar-94 DonCl stolen from common project for use with Forms so
*                       we can build on Daytona without linking to commnot.
*
*******************************************************************************/

#include <wchar.h>
#include <stdarg.h>
#include <limits.h>
#include <sys\types.h>

#define _W4DPRINTF_
#include <w4io.h>

#define pwcbuf        buf.wc._pwcbuf
#define pwcstart    buf.wc._pwcstart
#define pchbuf        buf.ch._pchbuf
#define pchstart    buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
#ifdef __cplusplus
extern "C" {
#endif
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
#ifdef __cplusplus
}
#endif



#if defined(_W4PRINTF_)
    static long fh;
//    extern long GetStdHandle(long);
//    extern void WriteFile(long fh, char *s, long cch, long * pcchret, long);
#   define _PRINTF_
#elif defined(_W4DPRINTF_)
#   define _pwritechar  _dwritechar
#   define _pflushbuf   _dflushbuf
#   define w4printf     w4dprintf
#   define w4vprintf    w4vdprintf
#   define _PRINTF_
#elif defined(_W4SPRINTF_)
#   define _pwritechar  _swritechar
#   define w4printf     w4sprintf
#   define w4vprintf    w4vsprintf
#elif defined(_W4WCSPRINTF_)
#   define _TCHAR_      wchar_t
#   define _PBUF_       pwcbuf
#   define _PSTART_     pwcstart
#   define w4printf     w4wcsprintf
#   define w4vprintf    w4vwcsprintf
#   define _pwritechar  _wwritechar
#else
#   error configuration problem
#endif

#ifndef _TCHAR_
#  define _TCHAR_       char
#  define _PBUF_        pchbuf
#  define _PSTART_      pchstart
#endif


#ifdef _PRINTF_
#   ifdef WIN32
#     undef  OutputDebugString
#     define OutputDebugString OutputDebugStringA
#   else
      extern void _pascal OutputDebugString(char *);
#   endif
    int _cdecl _pflushbuf(struct w4io *f);
#   define SPR(a)
#   define MAXSTR       128
#else
#   define SPR(a)       a,
#   define MAXSTR       INT_MAX
#endif

void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten);
int _cdecl w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist);


/***
*int w4printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data using the format string to
*       format data and getting as many arguments as called for
*       Sets up a w4io so file i/o operations can be used.
*       w4iooutput does the real work here
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/


int _cdecl
w4printf(SPR(_TCHAR_ *string) const char *format, ...)
/*
 * 'PRINT', 'F'ormatted
 */
{
    va_list arglist;

    va_start(arglist, format);
    return(w4vprintf(SPR(string) format, arglist));
}


/***
*int w4vprintf(format, arglist) - print formatted data from arg ptr
*
*Purpose:
*       Prints formatted data, but gets data from an argument pointer.
*       Sets up a w4io so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *format    - format string, describes format of data
*       va_list arglist - varargs argument pointer
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int _cdecl
w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist)
/*
 * 'V'ariable argument 'PRINT', 'F'ormatted
 */
{
    struct w4io outfile;
    register int retval;
#ifdef _PRINTF_
    char string[MAXSTR + 1];            // leave room for null termination
#else
    int dummy;
#endif

#ifdef _W4PRINTF_
    long ldummy;

    if (fh == 0 || fh == -1)
    {
        ldummy = -11;                   // C7 bug workaround
        if ((fh = (long)GetStdHandle(ldummy)) == 0 || fh == -1)
        {
            OutputDebugString("GetStdHandle in " __FILE__ " failed\n");
            return(-1);
        }
    }
#endif

    outfile._PBUF_ = outfile._PSTART_ = string;
    outfile.cchleft = MAXSTR;
    outfile.writechar = _pwritechar;

    retval = w4iooutput(&outfile, format, arglist);

#ifdef _PRINTF_
    if (_pflushbuf(&outfile) == -1) {
        return(-1);
    }
#else
    _pwritechar('\0', 1, &outfile, &dummy);
#endif
    return(retval);
}


void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten)
{
    //printf("  char: ch=%c, cnt=%d, cch=%d\n", ch, num, *pcchwritten);
    while (num-- > 0) {
#ifdef _PRINTF_
        if (f->cchleft < 2 && _pflushbuf(f) == -1) {
            *pcchwritten = -1;
            return;
        }
#endif
#ifdef _W4DPRINTF_
#  ifndef FLAT
        if (ch == '\n')
        {
            *f->_PBUF_++ = '\r';
            f->cchleft--;
            (*pcchwritten)++;
        }
#  endif
#endif
        *f->_PBUF_++ = (char) ch;
        f->cchleft--;
        (*pcchwritten)++;
    }
}


#ifdef _PRINTF_
int _cdecl _pflushbuf(struct w4io *f)
{
    int cch;

    if ((cch = (int)(f->pchbuf - f->pchstart)))
    {
#ifdef _W4DPRINTF_
        *f->pchbuf = '\0';              // null terminate
        OutputDebugString(f->pchstart);
#else
        long cchret;

        //*f->pchbuf = '\0';            // null terminate
        //printf("%d chars: \"%s\"\n", cch, f->pchstart);
        WriteFile((HANDLE)fh, f->pchstart, cch, &cchret, 0);
        if (cch != cchret)
        {
            OutputDebugString("WriteFile in " __FILE__ " failed\n");
            return(-1);
        }
#endif
        f->pchbuf -= cch;               // reset pointer
        f->cchleft += cch;              // reset count
    }
    return(0);
}
#endif // _PRINTF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nocairo\alocdbg.cxx ===
/*
 * This file implements an arena that tracks memory allocations and frees.
 *      Isaache
 */

#include <ADs.hxx>

#if     DBG && !defined(MSVC) // we don't have access to nt hdrs with MSVC

// #include <except.hxx>
#include <caiheap.h>
#include <symtrans.h>

#pragma optimize( "y", off )

DECLARE_INFOLEVEL( heap );
DECLARE_DEBUG( heap );
#define heapDebugOut(x) heapInlineDebugOut x

/*
 * The maximum number of AllocArenaCreate's we expect
 */
static const    MAXARENAS       = 5;

/*
 * When printing leak dumps, the max number we will print out.  Note, we keep
 * track of all of them, we just don't want to take forever to terminate a
 * process
 */
static const    MAXDUMP         = 50;

/*
 * The maximum size we'll let any single debug arena get
 */
static const ULONG ARENASIZE    = 1024*1024;

/*
 * The unit of growth for the arena holding the AllocArena data.
 * Must be a power of 2
 */
static const ALLOCRECINCR       = 128;


static AllocArena *AllocArenas[ MAXARENAS + 1 ];

//+---------------------------------------------------------------------------
//
//  Function:   RecordStack functions(s) below...per processor type
//
//  Synopsis:   Record a stack backtrace into fTrace
//
//  Arguments:  [cFrameSkipped] --  How many stack frames to skip over and
//                      not record
//              [fTrace] -- The recorded frames are put in here
//
//  Returns:    A checksum of the stack frames for fast initial lookups
//
//  Notes:      If we can do stack backtracing for whatever processor we're
//              compiling for, the #define CANDOSTACK
//
//----------------------------------------------------------------------------
#if defined (i386) && !defined(WIN95)


static inline DWORD
RecordStack( int cFrameSkipped, void *fTrace[ DEPTHTRACE ] )
{

#define CANDOSTACK

        ULONG sum;
        USHORT cStack;

        // This routine is found in src/ntos/rtl/i386
        // extern "C" USHORT NTAPI
        // RtlCaptureStackBackTrace(ULONG, ULONG, PVOID *, PULONG);

        cStack = RtlCaptureStackBackTrace(cFrameSkipped + 1,
                DEPTHTRACE, fTrace, &sum );

        return sum;
}

#else // ! i386

static inline DWORD
RecordStack( int cFrameSkipped, void *fTrace[ DEPTHTRACE ] )
{
#if defined(CANDOSTACK)
#undef CANDOSTACK
#endif
    return 0;
}
#endif // ! i386

//
// This allows external monitoring of heap activity by caiheap.exe
//
STDAPI_( AllocArena ** )
AllocArenaAddr( void )
{
        return AllocArenas;
}

//
// Create an arena for recording allocation statistics.  Return the arena
// pointer to the caller
//
STDAPI_( AllocArena * )
AllocArenaCreate( DWORD memctx, char FAR *comment )
{
        struct AllocArena *paa = NULL;

        if( memctx == MEMCTX_TASK ) {
#if     defined( CANDOSTACK )
                if( heapInfoLevel & DEB_WARN ) {

                        paa = (struct AllocArena *)VirtualAlloc(
                                NULL, ARENASIZE, MEM_RESERVE, PAGE_NOACCESS );
                        if( paa == NULL )
                                return NULL;

                        paa = (AllocArena *)VirtualAlloc( paa,
                           sizeof(*paa)+(ALLOCRECINCR-1)*sizeof(HeapAllocRec),
                           MEM_COMMIT, PAGE_READWRITE );

                }
                else
#endif
                {
                        paa = (struct AllocArena *)calloc( 1, sizeof(*paa) );
                }
        }

        if( paa == NULL )
                return NULL;

        memcpy( paa->Signature,HEAPSIG,sizeof(HEAPSIG));
        if( comment )
                strncpy(paa->comment, comment, sizeof(paa->comment) );

        InitializeCriticalSection( &paa->csExclusive );

        for( int i=0; i < MAXARENAS; i++ )
                if( AllocArenas[i] == 0 ) {
                        AllocArenas[i] = paa;
                        break;
                }

#if     defined( CANDOSTACK )
        if( (heapInfoLevel & DEB_WARN) == 0 )
#endif
        {
                paa->flags.KeepStackTrace = 0;
                paa->AllocRec[0].paa = paa;
                return paa;
        }

#if     defined( CANDOSTACK )
        paa->cRecords = ALLOCRECINCR;
        paa->cTotalRecords = ALLOCRECINCR;
        paa->flags.KeepStackTrace = 1;

        return paa;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordAlloc
//
//  Synopsis:   Keep a hash table of the stack backtraces of the allocations
//              we've done.
//
//  Arguments:  [paa] -- Return value from AllocArenaCreate() above
//              [bytes] -- the number of bytes being allocated by the caller.
//                      This value is recorded in the stack backtrace entry.
//
//  Algorithm:  The arena for the AllocArena is created with VirtualAlloc.
//                      pAllocArena->cRecords is the index of the next
//                      free record.  The first ALLOCRECINCR records are heads
//                      of separate lists of the records.
//
//  Returns:    A pointer to the AllocRec structure recording the entry.
//              Can return NULL if we can't record the allocation.
//
//----------------------------------------------------------------------------
STDAPI_( HeapAllocRec FAR * )
AllocArenaRecordAlloc( AllocArena *paa, size_t bytes )
{
        if( paa == NULL )
                return NULL;

        EnterCriticalSection( &paa->csExclusive );

        if( bytes ) {
                paa->cAllocs++;
                paa->cBytesNow += bytes;
                paa->cBytesTotal += bytes;
        } else {
                paa->czAllocs++;
        }

        //
        // Record 'size' in the histogram of requests
        //
        for( int i=31; i>=0; i-- )
                if( bytes & (1<<i) ) {
                        ++(paa->Histogram.total[i]);
                        if( paa->Histogram.simul[i] < ++(paa->Histogram.now[i]))
                                paa->Histogram.simul[i] = paa->Histogram.now[i];
                        break;
                }

        LeaveCriticalSection( &paa->csExclusive );

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace == 0 )
#endif
                return &paa->AllocRec[0];

#if     defined( CANDOSTACK )

        DWORD sum;
        struct HeapAllocRec *phar,*hp;
        void *fTrace[ DEPTHTRACE ];

        //
        // See if we find an existing record of this stack backtrace
        //
        memset( fTrace, '\0', sizeof( fTrace ) );
        sum = RecordStack( 2, fTrace );

        hp = &paa->AllocRec[ sum & (ALLOCRECINCR-1) ];

        EnterCriticalSection( &paa->csExclusive );

        for( phar = hp; phar != NULL; phar = phar->u.next )
                if( phar->sum == sum &&
                    !memcmp(phar->fTrace,fTrace,sizeof(fTrace)))
                {
                        phar->count++;
                        phar->bytes += bytes;
                        phar->total.bytes += bytes;
                        phar->total.count++;
                        phar->paa = paa;
                        LeaveCriticalSection( &paa->csExclusive );
                        return phar;
                }
        //
        // We have no record of this allocation.  Make one!
        //
        if( hp->total.count && paa->cRecords == paa->cTotalRecords ) {
                //
                // The arena is currently full.  Grow it by ALLOCRECINCR
                //
                AllocArena *npHeap;

                npHeap = (AllocArena *)VirtualAlloc(
                        paa,
                        sizeof(AllocArena)+
                        ((paa->cTotalRecords + ALLOCRECINCR) *
                                sizeof(HeapAllocRec) ),
                        MEM_COMMIT, PAGE_READWRITE );

                if( npHeap != paa ) {
                        paa->cMissed++;
                        LeaveCriticalSection( &paa->csExclusive );
                        return NULL;
                }

                paa->cTotalRecords += ALLOCRECINCR;
        }

        if( hp->total.count == 0 ) {
                phar = hp;
        } else {
                phar = &paa->AllocRec[ paa->cRecords++ ];
                phar->u.next = hp->u.next;
                hp->u.next = phar;
        }

        paa->cPaths++;

        memcpy( phar->fTrace, fTrace, sizeof( fTrace ) );
        phar->count = phar->total.count = 1;
        phar->bytes = phar->total.bytes = bytes;
        phar->sum = sum;
        phar->paa = paa;
        LeaveCriticalSection( &paa->csExclusive );
        return phar;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordReAlloc
//
//  Synopsis:   Update the record to reflect the fact that we've ReAlloc'd
//              the memory chunk.
//
//  Arguments:  [vp] -- Return value from AllocArenaRecordAlloc() above
//              [oldbytes] -- size of the memory before ReAllocation
//              [newbytes] -- new size of the memory
//
//----------------------------------------------------------------------------
STDAPI_( void )
AllocArenaRecordReAlloc( HeapAllocRec FAR *vp, size_t oldbytes, size_t newbytes)
{
        if( vp == NULL )
                return;

        struct AllocArena *paa = vp->paa;

        EnterCriticalSection( &paa->csExclusive );

        paa->cReAllocs++;
        paa->cBytesNow -= oldbytes;
        paa->cBytesNow += newbytes;

        if( newbytes > oldbytes )
                paa->cBytesTotal += newbytes - oldbytes;

        //
        // Take 'oldbytes' out of the histogram of requests
        //
        for( int i=31; i>=0; i-- )
                if( oldbytes & (1<<i) ) {
                        --(paa->Histogram.now[i]);
                        break;
                }

        //
        // Record 'newbytes' in the histogram of requests
        //
        for( i=31; i>=0; i-- )
                if( newbytes & (1<<i) ) {
                        ++(paa->Histogram.total[i]);
                        if( paa->Histogram.simul[i] < ++(paa->Histogram.now[i]))
                                paa->Histogram.simul[i] = paa->Histogram.now[i];
                        break;
                }

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace ) {
                vp->bytes -= oldbytes;
                vp->bytes += newbytes;
                vp->total.count++;
                if( newbytes > oldbytes )
                        vp->total.bytes += newbytes;
        }
#endif

        LeaveCriticalSection( &paa->csExclusive );
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordFree
//
//  Synopsis:   Caller has freed memory -- keep accounting up to date
//
//  Arguments:  [vp] -- Value returned by AllocArenaRecordAlloc() above
//              [bytes] -- The number of bytes being freed
//
//  Algorithm:  AllocRec structures, once allocated, are never actually
//                      freed back to the Hash memory arena.  This helps us
//                      understand historical use of the heap.
//
//----------------------------------------------------------------------------
STDAPI_( void )
AllocArenaRecordFree( HeapAllocRec FAR *vp, size_t bytes )
{
        if( vp == NULL )
                return;

        struct AllocArena *paa = vp->paa;

        EnterCriticalSection( &paa->csExclusive );

        //
        // Record this free in the histogram
        //
        for( int i=31; i>=0; i-- )
                if( bytes & (1<<i) ) {
                        --(paa->Histogram.now[i]);
                        break;
                }

        paa->cFrees++;
        paa->cBytesNow -= bytes;

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace ) {
                vp->count--;
                vp->bytes -= bytes;
        }
#endif

        LeaveCriticalSection( &paa->csExclusive );
}

STDAPI_( void )
AllocArenaDumpRecord( HeapAllocRec FAR *bp )
{
#if     defined( CANDOSTACK )
        char achBuffer[ MAX_TRANSLATED_LEN ], *p;

        heapDebugOut((DEB_WARN, "*** %d allocs, %u bytes:\n",
                         bp->count, bp->bytes ));

        for( int j=0; j<DEPTHTRACE && bp->fTrace[j]; j++ )
        {
                TranslateAddress(bp->fTrace[j], achBuffer );
                if( p = strchr( achBuffer, '\n' ) )
                        *p = '\0';
                heapDebugOut((DEB_WARN, "       %s\n", achBuffer));
        }
#endif
}

extern "C" ULONG DbgPrint( PCH Format, ... );

STDAPI_( void )
AllocArenaDump( AllocArena *paa )
{
        if( paa == NULL ) {
                for( int i = 0; i < MAXARENAS && AllocArenas[i]; i++ )
                        AllocArenaDump( AllocArenas[i] );
                return;
        }

        char *cmdline = GetCommandLineA();

        if( cmdline == NULL )
                cmdline = "???";

        HeapAllocRec *bp = paa->AllocRec;
        HeapAllocRec *ep = bp + paa->cRecords;

        if( paa->cBytesNow )
                heapDebugOut((DEB_WARN,
                              "***** %u bytes leaked mem for %s in '%s'\n",
                              paa->cBytesNow,
                              paa->comment,
                              cmdline ));

#if     defined( CANDOSTACK )
        if( paa->cBytesNow && paa->flags.KeepStackTrace )
        {
                int cleaks = 0;

                for( ; bp < ep; bp++) {
                        if( bp->count )
                                ++cleaks;
                }

                if( cleaks ) {
                        heapDebugOut((DEB_WARN, "***** %s %u MEM LEAKS\n",
                                paa->comment, cleaks ));

                        if( heapInfoLevel & DEB_TRACE ) {
                                HeapAllocRec *bp;
                                UINT maxdump = MAXDUMP;
                                for( bp = paa->AllocRec; maxdump && bp<ep; bp++)
                                        if( bp->count ) {
                                                heapDebugOut((DEB_TRACE, "\n"));
                                                AllocArenaDumpRecord( bp );
                                                maxdump--;
                                        }
                        } else if( cleaks )
                                heapDebugOut((DEB_WARN, "** Set formidbl!heapInfoLevel to x707 for leak backtrace\n"));

                }
        }
#endif

        if( (heapInfoLevel & DEB_TRACE) && paa->cBytesTotal )
        {
                heapDebugOut((DEB_TRACE,"\n"));
                heapDebugOut((DEB_TRACE,
                        "'%s' Memory Stats: %u allocations, %u frees\n",
                        cmdline, paa->cAllocs, paa->cFrees ));

                if( paa->czAllocs )
                        heapDebugOut((DEB_TRACE,
                                "\t%u zero allocs\n", paa->czAllocs ));

                heapDebugOut((DEB_TRACE,
                                "\t%u bytes allocated\n", paa->cBytesTotal ));

                heapDebugOut((DEB_TRACE,
                                "*** Histogram of Allocated Mem Sizes ***\n"));

                heapDebugOut((DEB_TRACE, "  Min    Max\t  Tot\t Simul\n" ));
                for( int i=0; i < 32; i++ )
                        if( paa->Histogram.total[i] )
                        {
                                heapDebugOut((DEB_TRACE,
                                        "%6u -> %6u\t%6u\t%6u\n",
                                        1<<i, (1<<(i+1))-1,
                                        paa->Histogram.total[i],
                                        paa->Histogram.simul[i]
                                ));
                        }
        }
}

#endif  // DBG && !defined(MSVC)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nocairo\output.c ===
/***
*output.c - printf style output to a struct w4io
*
*   Copyright (c) 1989-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the code that does all the work for the
*   printf family of functions.  It should not be called directly, only
*   by the *printf functions.  We don't make any assumtions about the
*   sizes of ints, longs, shorts, or long doubles, but if types do overlap, we
*   also try to be efficient.  We do assume that pointers are the same size
*   as either ints or longs.
*
*Revision History:
*   06-01-89  PHG   Module created
*   08-28-89  JCR   Added cast to get rid of warning (no object changes)
*   02-15-90  GJF   Fixed copyright
*   10-03-90  WHB   Defined LOCAL(x) to "static x" for local procedures
*   14-Mar-94 DonCl stolen from Cairo common project to use with Forms so
*                   Forms can build and run on Daytona without commnot.dll
*
*******************************************************************************/

#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include "wchar.h"
#include "w4io.h"


/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type>. */
#define LOCAL(x) static x            // 100390--WHB

#define NOFLOATS                        // Win 4 doesn't need floating point

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
// FLAT or LARGE model is assumed
#ifdef FLAT
#  define LONG_IS_INT        1       /* 1 means long is same size as int */
#  define SHORT_IS_INT       0       /* 1 means short is same size as int */
#  define PTR_IS_INT         1       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        0       /* 1 means ptr is same size as long */
#else // LARGE model
#  define LONG_IS_INT        0       /* 1 means long is same size as int */
#  define SHORT_IS_INT       1       /* 1 means short is same size as int */
#  define PTR_IS_INT         0       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        1       /* 1 means ptr is same size as long */
#endif
#define LONGDOUBLE_IS_DOUBLE 0       /* 1 means long double is same as double */

#if LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#ifndef _WIN64
    #if PTR_IS_INT
        #define get_ptr_arg(x) (void *)get_int_arg(x)
    #elif PTR_IS_LONG
        #define get_ptr_arg(x) (void *)get_long_arg(x)
    #else
        #error Size of pointer must be same as size of int or long
    #endif
#else
    #define get_ptr_arg(x) (void *)get_ptr64_arg(x)
#endif

#ifndef NOFLOATS
/* These are "fake" double and long doubles to fool the compiler,
   so we don't drag in floating point. */
typedef struct {
    char x[sizeof(double)];
} DOUBLE;
typedef struct {
    char x[sizeof(long double)];
} LONGDOUBLE;
#endif


/* CONSTANTS */

//#define BUFFERSIZE CVTBUFSIZE     /* buffer size for maximum double conv */
#define BUFFERSIZE 20

/* flag definitions */
#define FL_SIGN       0x0001      /* put plus or minus in front */
#define FL_SIGNSP     0x0002      /* put space or minus in front */
#define FL_LEFT       0x0004      /* left justify */
#define FL_LEADZERO   0x0008      /* pad with leading zeros */
#define FL_LONG       0x0010      /* long value given */
#define FL_SHORT      0x0020      /* short value given */
#define FL_SIGNED     0x0040      /* signed data given */
#define FL_ALTERNATE  0x0080      /* alternate form requested */
#define FL_NEGATIVE   0x0100      /* value is negative */
#define FL_FORCEOCTAL 0x0200      /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x0400      /* long double value given */
#define FL_WIDE       0x0800      /* wide character/string given */

/* state definitions */
enum STATE {
    ST_NORMAL,              /* normal state; outputting literal chars */
    ST_PERCENT,             /* just read '%' */
    ST_FLAG,                /* just read flag character */
    ST_WIDTH,               /* just read width specifier */
    ST_DOT,                 /* just read '.' */
    ST_PRECIS,              /* just read precision specifier */
    ST_SIZE,                /* just read size specifier */
    ST_TYPE                 /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,               /* character with no special meaning */
    CH_PERCENT,             /* '%' */
    CH_DOT,                 /* '.' */
    CH_STAR,                /* '*' */
    CH_ZERO,                /* '0' */
    CH_DIGIT,               /* '1'..'9' */
    CH_FLAG,                /* ' ', '+', '-', '#' */
    CH_SIZE,                /* 'h', 'l', 'L', 'N', 'F' */
    CH_TYPE                 /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
char *nullstring = "(null)";    /* string to print on null ptr */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any         */
/* character; while the uper nybble of the byte gives the next state      */
/* to enter.  See the macros below the table for details.                 */
/*                                                                        */
/* The table is generated by maketab.c -- use the maketab program to make */
/* changes.                                                               */

static char lookuptable[] = {
    0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00,
    0x10, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x10,
    0x04, 0x45, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x35, 0x30, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x28, 0x38, 0x50, 0x58, 0x07, 0x08,
    0x00, 0x30, 0x30, 0x30, 0x57, 0x50, 0x07, 0x00,
    0x00, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00,
    0x00, 0x70, 0x70, 0x78, 0x78, 0x78, 0x78, 0x08,
    0x07, 0x08, 0x00, 0x00, 0x07, 0x00, 0x08, 0x08,
    0x08, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x07,
    0x08
};

#define find_char_class(c)              \
        ((c) < ' ' || (c) > 'x' ?       \
            CH_OTHER                    \
        :                               \
            lookuptable[(c)-' '] & 0xF)

#define find_next_state(class, state)   \
        (lookuptable[(class) * NUMSTATES + (state)] >> 4)

#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr);
#endif
LOCAL(int) get_int_arg(va_list *pargptr);
#ifdef _WIN64
LOCAL(void*) get_ptr64_arg(va_list *pargptr);
#endif
LOCAL(void) writestring(char *string,
                        int len,
                        struct w4io *f,
                        int *pcchwritten,
                        int fwide);

#ifndef NOFLOATS
/* extern float convert routines */
typedef int (* PFI)();
extern PFI _cfltcvt_tab[5];
#define _cfltcvt(a,b,c,d,e) (*_cfltcvt_tab[0])(a,b,c,d,e)
#define _cropzeros(a)       (*_cfltcvt_tab[1])(a)
#define _fassign(a,b,c)     (*_cfltcvt_tab[2])(a,b,c)
#define _forcdecpt(a)       (*_cfltcvt_tab[3])(a)
#define _positive(a)        (*_cfltcvt_tab[4])(a)
#define _cldcvt(a,b,c,d,e)  (*_cfltcvt_tab[5])(a,b,c,d,e)
#endif


/***
*int w4iooutput(f, format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.  It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, w4iooutput assumes that the given
*   stream is already locked.
*
*   Algorithm:
*       The format string is parsed by using a finite state automaton
*       based on the current state and the current character read from
*       the format string.  Thus, looping is on a per-character basis,
*       not a per conversion specifier basis.  Once the format specififying
*       character is read, output is performed.
*
*Entry:
*   struct w4io *f   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*
*Exceptions:
*
*******************************************************************************/

int _cdecl w4iooutput(struct w4io *f, const char *format, va_list argptr)
{
    int hexadd=0;       /* offset to add to number to get 'a'..'f' */
    char ch;            /* character just read */
    wchar_t wc;         /* wide character temp */
    wchar_t *pwc;       /* wide character temp pointer */
    int flags = 0;      /* flag word -- see #defines above for flag values */
    enum STATE state;   /* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;          /* current conversion radix */
    int charsout;       /* characters currently written so far, -1 = IO error */
    int fldwidth=0;     /* selected field with -- 0 means default */
    int fwide;
    int precision=0;    /* selected precision -- -1 means default */
    char prefix[2];     /* numeric prefix -- up to two characters */
    int prefixlen=0;    /* length of prefix -- 0 means no prefix */
    int capexp;         /* non-zero = 'E' exponent signifiet, zero = 'e' */
    int no_output=0;    /* non-zero = prodcue no output for this specifier */
    char *text=NULL;    /* pointer text to be printed, not zero terminated */
    int textlen=0;      /* length of the text to be printed */
    char buffer[BUFFERSIZE];    /* buffer for conversions */

    charsout = 0;               /* no characters written yet */
    state = ST_NORMAL;          /* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != '\0' && charsout >= 0) {
        chclass = find_char_class(ch);  /* find character class */
        state = find_next_state(chclass, state); /* find next state */

        /* execute code for each state */
        switch (state) {

        case ST_NORMAL:
            /* normal state -- just write character */
            f->writechar(ch, 1, f, &charsout);
            break;

        case ST_PERCENT:
            /* set default value of conversion parameters */
            prefixlen = fldwidth = no_output = capexp = 0;
            flags = 0;
            precision = -1;
            fwide = 0;
            break;

        case ST_FLAG:
            /* set flag based on which flag character */
            switch (ch) {
            case '-':
                flags |= FL_LEFT;       /* '-' => left justify */
                break;
            case '+':
                flags |= FL_SIGN;       /* '+' => force sign indicator */
                break;
            case ' ':
                flags |= FL_SIGNSP;     /* ' ' => force sign or space */
                break;
            case '#':
                flags |= FL_ALTERNATE;  /* '#' => alternate form */
                break;
            case '0':
                flags |= FL_LEADZERO;   /* '0' => pad with leading zeros */
                break;
            }
            break;

        case ST_WIDTH:
            /* update width value */
            if (ch == '*') {
                /* get width from arg list */
                fldwidth = get_int_arg(&argptr);
                if (fldwidth < 0) {
                    /* ANSI says neg fld width means '-' flag and pos width */
                    flags |= FL_LEFT;
                    fldwidth = -fldwidth;
                }
            }
            else {
                /* add digit to current field width */
                fldwidth = fldwidth * 10 + (ch - '0');
            }
            break;

        case ST_DOT:
            /* zero the precision, since dot with no number means 0
               not default, according to ANSI */
            precision = 0;
            break;

        case ST_PRECIS:
            /* update precison value */
            if (ch == '*') {
                /* get precision from arg list */
                precision = get_int_arg(&argptr);
                if (precision < 0)
                    precision = -1;     /* neg precision means default */
            }
            else {
                /* add digit to current precision */
                precision = precision * 10 + (ch - '0');
            }
            break;

        case ST_SIZE:
            /* just read a size specifier, set the flags based on it */
            switch (ch) {
#if !LONG_IS_INT
            case 'l':
                flags |= FL_LONG;   /* 'l' => long int */
                break;
#endif

#if !LONGDOUBLE_IS_DOUBLE
            case 'L':
                flags |= FL_LONGDOUBLE; /* 'L' => long double */
                break;
#endif

#if !SHORT_IS_INT
            case 'h':
                flags |= FL_SHORT;  /* 'h' => short int */
                break;
#endif
            case 'w':
                flags |= FL_WIDE;   /* 'w' => wide character */
                break;
            }
            break;

        case ST_TYPE:
            /* we have finally read the actual type character, so we       */
            /* now format and "print" the output.  We use a big switch     */
            /* statement that sets 'text' to point to the text that should */
            /* be printed, and 'textlen' to the length of this text.       */
            /* Common code later on takes care of justifying it and        */
            /* other miscellaneous chores.  Note that cases share code,    */
            /* in particular, all integer formatting is doen in one place. */
            /* Look at those funky goto statements!                        */

            switch (ch) {

            case 'c': {
                /* print a single character specified by int argument */
                wc = (wchar_t) get_int_arg(&argptr);    /* get char to print */
                * (wchar_t *) buffer = wc;
                text = buffer;
                textlen = 1;        /* print just a single character */
            }
            break;

            case 'S': {
                /* print a Counted String   */

                struct string {
                    short Length;
                    short MaximumLength;
                    char *Buffer;
                } *pstr;

                pstr = get_ptr_arg(&argptr);
                if (pstr == NULL || pstr->Buffer == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    /* 64-bit: we assume length of string is <= 4 GB */
                    textlen = (int)strlen(text);
                    flags &= ~FL_WIDE;
                } else {
                    text = pstr->Buffer;
                    /* The length field is a count of bytes, not characters. */
                    if (flags & FL_WIDE)
                        textlen = pstr->Length / sizeof( wchar_t );
                    else
                        textlen = pstr->Length;
                    if (precision != -1)
                        textlen = min( textlen, precision );
                }

            }
            break;

            case 's': {
                /* print a string --                            */
                /* ANSI rules on how much of string to print:   */
                /*   all if precision is default,               */
                /*   min(precision, length) if precision given. */
                /* prints '(null)' if a null string is passed   */

                int i;
                char *p;       /* temps */

                text = get_ptr_arg(&argptr);
                if (text == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    flags &= ~FL_WIDE;
                }

                /* At this point it is tempting to use strlen(), but */
                /* if a precision is specified, we're not allowed to */
                /* scan past there, because there might be no null   */
                /* at all.  Thus, we must do our own scan.           */

                i = (precision == -1) ? INT_MAX : precision;

                /* scan for null upto i characters */
                if (flags & FL_WIDE) {
                    pwc = (wchar_t *) text;
                    while (i-- && (wc = *pwc) != 0 && (wc & 0x00ff)) {
                        ++pwc;
                        if (wc & 0xff00) {      // if high byte set,
                            break;              // error will be indicated
                        }
                    }
                    textlen = (int)(pwc - (wchar_t *) text);  /* length of string */
                } else {
                    p = text;
                    while (i-- && *p) {
                        ++p;
                    }
                    textlen = (int)(p - text);    /* length of the string */
                }
            }
            break;

            case 'n': {
                /* write count of characters seen so far into */
                /* short/int/long thru ptr read from args */

                void *p;            /* temp */

                p = get_ptr_arg(&argptr);

                /* store chars out into short/long/int depending on flags */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    *(long *)p = charsout;
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT)
                    *(short *)p = (short) charsout;
                else
#endif
                    *(int *)p = charsout;

                no_output = 1;              /* force no output */
            }
            break;


#ifndef NOFLOATS
            case 'E':
            case 'G':
                capexp = 1;                 /* capitalize exponent */
                ch += 'a' - 'A';            /* convert format char to lower */
                /* DROP THROUGH */
            case 'e':
            case 'f':
            case 'g':   {
                /* floating point conversion -- we call cfltcvt routines */
                /* to do the work for us.                                */
                flags |= FL_SIGNED;         /* floating point is signed conversion */
                text = buffer;              /* put result in buffer */
                flags &= ~FL_WIDE;          /* 8 bit string */

                /* compute the precision value */
                if (precision < 0)
                    precision = 6;      /* default precision: 6 */
                else if (precision == 0 && ch == 'g')
                    precision = 1;      /* ANSI specified */

#if !LONGDOUBLE_IS_DOUBLE
                /* do the conversion */
                if (flags & FL_LONGDOUBLE) {
                    _cldcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, LONGDOUBLE);
                }
                else
#endif
                {
                    _cfltcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, DOUBLE);
                }

                /* '#' and precision == 0 means force a decimal point */
                if ((flags & FL_ALTERNATE) && precision == 0)
                    _forcdecpt(text);

                /* 'g' format means crop zero unless '#' given */
                if (ch == 'g' && !(flags & FL_ALTERNATE))
                    _cropzeros(text);

                /* check if result was negative, save '-' for later */
                /* and point to positive part (this is for '0' padding) */
                if (*text == '-') {
                    flags |= FL_NEGATIVE;
                    ++text;
                }

                textlen = strlen(text);     /* compute length of text */
            }
            break;
#endif // NOFLOATS

            case 'd':
            case 'i':
                /* signed decimal output */
                flags |= FL_SIGNED;
                radix = 10;
                goto COMMON_INT;

            case 'u':
                radix = 10;
                goto COMMON_INT;

            case 'p':
                /* write a pointer -- this is like an integer or long */
                /* except we force precision to pad with zeros and */
                /* output in big hex. */

                precision = 2 * sizeof(void *);     /* number of hex digits needed */
#if !PTR_IS_INT
                flags |= FL_LONG;       /* assume we're converting a long */
#endif
                /* DROP THROUGH to hex formatting */

            case 'C':
            case 'X':
                /* unsigned upper hex output */
                hexadd = 'A' - '9' - 1;     /* set hexadd for uppercase hex */
                goto COMMON_HEX;

            case 'x':
                /* unsigned lower hex output */
                hexadd = 'a' - '9' - 1;     /* set hexadd for lowercase hex */
                /* DROP THROUGH TO COMMON_HEX */

            COMMON_HEX:
                radix = 16;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means '0x' prefix */
                    prefix[0] = '0';
                    prefix[1] = (char)('x' - 'a' + '9' + 1 + hexadd);   /* 'x' or 'X' */
                    prefixlen = 2;
                }
                goto COMMON_INT;

            case 'o':
                /* unsigned octal output */
                radix = 8;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means force a leading 0 */
                    flags |= FL_FORCEOCTAL;
                }
                /* DROP THROUGH to COMMON_INT */

            COMMON_INT: {
                /* This is the general integer formatting routine. */
                /* Basically, we get an argument, make it positive */
                /* if necessary, and convert it according to the */
                /* correct radix, setting text and textlen */
                /* appropriately. */

                unsigned long number;   /* number to convert */
                int digit;              /* ascii value of digit */
                long l;                 /* temp long value */

                /* 1. read argument into l, sign extend as needed */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    l = get_long_arg(&argptr);
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT) {
                    if (flags & FL_SIGNED)
                        l = (short) get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
                }
                else
#endif
                {
                    if (flags & FL_SIGNED)
                        l = get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
                }

                /* 2. check for negative; copy into number */
                if ( (flags & FL_SIGNED) && l < 0) {
                    number = -l;
                    flags |= FL_NEGATIVE;   /* remember negative sign */
                }
                else {
                    number = l;
                }

                /* 3. check precision value for default; non-default */
                /*    turns off 0 flag, according to ANSI. */
                if (precision < 0)
                    precision = 1;              /* default precision */
                else
                    flags &= ~FL_LEADZERO;

                /* 4. Check if data is 0; if so, turn off hex prefix */
                if (number == 0)
                    prefixlen = 0;

                /* 5. Convert data to ASCII -- note if precision is zero */
                /*    and number is zero, we get no digits at all.       */

                text = &buffer[BUFFERSIZE-1];   // last digit at end of buffer
                flags &= ~FL_WIDE;              // 8 bit characters

                while (precision-- > 0 || number != 0) {
                    digit = (int)(number % radix) + '0';
                    number /= radix;            /* reduce number */
                    if (digit > '9') {
                        /* a hex digit, make it a letter */
                        digit += hexadd;
                    }
                    *text-- = (char)digit;      /* store the digit */
                }

                textlen = (int)((char *)&buffer[BUFFERSIZE-1] - text); /* compute length of number */
                ++text;         /* text points to first digit now */


                /* 6. Force a leading zero if FORCEOCTAL flag set */
                if ((flags & FL_FORCEOCTAL) && (text[0] != '0' || textlen == 0)) {
                    *--text = '0';
                    ++textlen;          /* add a zero */
                }
            }
            break;
            }

            /* At this point, we have done the specific conversion, and */
            /* 'text' points to text to print; 'textlen' is length.  Now we */
            /* justify it, put on prefixes, leading zeros, and then */
            /* print it. */

            if (!no_output) {
                int padding;    /* amount of padding, negative means zero */

                if (flags & FL_SIGNED) {
                    if (flags & FL_NEGATIVE) {
                        /* prefix is a '-' */
                        prefix[0] = '-';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGN) {
                        /* prefix is '+' */
                        prefix[0] = '+';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGNSP) {
                        /* prefix is ' ' */
                        prefix[0] = ' ';
                        prefixlen = 1;
                    }
                }

                /* calculate amount of padding -- might be negative, */
                /* but this will just mean zero */
                padding = fldwidth - textlen - prefixlen;

                /* put out the padding, prefix, and text, in the correct order */

                if (!(flags & (FL_LEFT | FL_LEADZERO))) {
                    /* pad on left with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* write prefix */
                writestring(prefix, prefixlen, f, &charsout, 0);

                if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
                    /* write leading zeros */
                    f->writechar('0', padding, f, &charsout);
                }

                /* write text */
                writestring(text, textlen, f, &charsout, flags & FL_WIDE);

                if (flags & FL_LEFT) {
                    /* pad on right with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* we're done! */
            }
            break;
        }
    }

    return charsout;        /* return value = number of characters written */
}


/***
*int get_int_arg(va_list pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(int) get_int_arg(va_list *pargptr)
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr)
{
    return va_arg(*pargptr, long);
}
#endif


/***
void * get_ptr64_arg(va_list pargptr)
*
*Purpose:
*   Gets an 64-bit pointer argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the ptr64 argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#ifdef _WIN64
LOCAL(void *) get_ptr64_arg(va_list *pargptr)
{
    return va_arg(*pargptr, void *__ptr64);
}
#endif  // _WIN64


/***
*void writestring(char *string, int len, struct w4io *f, int *pcchwritten, int fwide)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pcchwritten is incremented by len; otherwise, *pcchwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   char *string     - string to write (NOT null-terminated)
*   int len          - length of string
*   struct w4io *f   - file to write to
*   int *pcchwritten - pointer to integer to update with total chars written
*   int fwide        - wide character flag
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(void) writestring(
        char *string,
        int len,
        struct w4io *f,
        int *pcchwritten,
        int fwide)
{
    wchar_t *pwc;

    //printf("string: str=%.*s, len=%d, cch=%d, f=%d\n", len, string, len, *pcchwritten, fwide);
    if (fwide) {
        pwc = (wchar_t *) string;
        while (len-- > 0) {
            if (*pwc & 0xff00) {
                f->writechar('^', 1, f, pcchwritten);
            }
            f->writechar((char) *pwc++, 1, f, pcchwritten);
        }
    } else {
        while (len-- > 0) {
            f->writechar(*string++, 1, f, pcchwritten);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nocairo\symtrans.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       symtrans.c
//
//  Contents:   Address->symbolic name translation code
//
//  Functions:  TranslateAddress
//
//  History:     8-Mar-93 PeterWi   Re-ssynced to module list so that
//                                  symbol translation worked.
//              16-Jul-92 MikeSe    Created
//
//  Notes:      This is debug only code, extracted from a piece of NT.
//              (private\windows\base\client\debugint.c).
//
//              Warning: most of this stuff is black magic. You are strongly
//              advised to refer to the original code (as above) before
//              making any changes.
//
//--------------------------------------------------------------------------

#include "dswarn.h"

void
TranslateAddress(
    void * pvAddress,
    char * pchBuffer )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nocairo\w4io.h ===
/***
*w4io.h - fake FILE structure for Win 4 printf/sprintf/debug printf support
*
*  History: ??-???-??  ?????     Created
*           14-Mar-94  DonCl     stolen from Cairo common project for use
*                                with Forms - allows us to have our own
*                                debug print facility exclusive of commnot.dll
*                                enabling us to build and run on Daytona.
*
*/

struct w4io
{
    union
    {
    struct
    {
        wchar_t *_pwcbuf;    // wchar_t output buffer
        wchar_t *_pwcstart;
    } wc;
    struct
    {
        char *_pchbuf;    // char output buffer
        char *_pchstart;
    } ch;
    } buf ;
    unsigned int cchleft;    // output buffer character count
    void (_cdecl *writechar)(int ch,
                 int num,
                 struct w4io *f,
                 int *pcchwritten);
};

#define pwcbuf        buf.wc._pwcbuf
#define pwcstart    buf.wc._pwcstart
#define pchbuf        buf.ch._pchbuf
#define pchstart    buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
#ifdef __cplusplus
extern "C" {
#endif
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nocairo\symtrans.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       symtrans.h
//
//  Contents:   Definitions associated with address->symbol translation
//
//  History:    17-Jul-92       MikeSe  Created
//              22-Jun-93  BryanT  Increased MAX_TRANS value to account for
//                                  Line/File information.
//
//----------------------------------------------------------------------------

#ifndef __SYMTRANS_H__
#define __SYMTRANS_H__

//
// The following function provides translation of function addresses into
// symbolic (NTSD-style) names. It is only available if ANYSTRICT is defined.
// (see common\src\commnot\symtrans.c)

# ifdef __cplusplus
extern "C" {
# endif

EXPORTDEF void APINOT
TranslateAddress (
    void * pvAddress,               // address to translate
    char * pchBuffer );             // output buffer

// The output buffer should allocated by the caller, and be at least
// the following size:

#define NT_SYM_ENV              "_NT_SYMBOL_PATH"
#define NT_ALT_SYM_ENV          "_NT_ALT_SYMBOL_PATH"
#define SYS_ENV                 "SystemRoot"

#define IMAGEHLP_DLL            "imagehlp.dll"
#define MAP_DBG_INFO_CALL       "MapDebugInformation"

#define MAX_TRANSLATED_LEN      600

# ifdef __cplusplus
}
# endif

#endif  // of ifndef __SYMTRANS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\ccache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ccache.cxx
//
//  Contents:     Class Cache functionality for the NwCompat Provider
//
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"


HRESULT
SetLPTSTRPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR pszValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)pszValue,
                    1,
                    NT_SYNTAX_ID_LPTSTR,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetDWORDPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    DWORD  dwValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&dwValue,
                    1,
                    NT_SYNTAX_ID_DWORD,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetDATEPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    DWORD  dwValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&dwValue,
                    1,
                    NT_SYNTAX_ID_DATE,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetBOOLPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    BOOL  fValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&fValue,
                    1,
                    NT_SYNTAX_ID_BOOL,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetOctetPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    BYTE *pByte,
    DWORD dwLength,
    BOOL fExplicit
    )
{
    HRESULT hr;
    OctetString octString;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    octString.pByte = pByte;
    octString.dwSize = dwLength;

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&octString,
                    1,
                    NT_SYNTAX_ID_OCTETSTRING,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetSYSTEMTIMEPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    SYSTEMTIME stValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&stValue,
                    1,
                    NT_SYNTAX_ID_SYSTEMTIME,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetDelimitedStringPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR pszValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)pszValue,
                    1,
                    NT_SYNTAX_ID_DelimitedString,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetNulledStringPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR pszValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)pszValue,
                    1,
                    NT_SYNTAX_ID_NulledString,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);

}


HRESULT
GetPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPBYTE pValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);

    hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    pValue
                    );
    BAIL_ON_FAILURE(hr);

error:
    if (pNTObject)
        NTTypeFreeNTObjects(pNTObject, dwNumValues);
    RRETURN (hr);
}


HRESULT
GetLPTSTRPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR * ppszValue
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)ppszValue);
    RRETURN(hr);
}


HRESULT
GetDelimitedStringPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR * ppszValue
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)ppszValue);
    RRETURN (hr);
}


HRESULT
GetNulledStringPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR * ppszValue
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)ppszValue);
    RRETURN(hr);
}


HRESULT
GetBOOLPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    PBOOL pBool
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)pBool);
    RRETURN(hr);
}


HRESULT
GetOctetPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    OctetString *pOctet)
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)pOctet);
    RRETURN(hr);
}


HRESULT
GetDWORDPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPDWORD pdwDWORD
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)pdwDWORD);
    RRETURN(hr);
}


HRESULT
GetDATEPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    PDWORD pdwDate
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)pdwDate);
    RRETURN(hr);
}


HRESULT
GetNw312DATEPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    BYTE byDateTime[]
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);

    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)byDateTime
                    );
    }

error:
    if (pNTObject)
        NTTypeFreeNTObjects(pNTObject, dwNumValues);
    RRETURN (hr);
}


HRESULT
SetNw312DATEPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    BYTE byDateTime[],
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)byDateTime,
                    1,
                    NT_SYNTAX_ID_NW312DATE,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nocairo\sysmem.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:          SysMem.CXX
//
//  Contents:   System Memory Management routines
//
//  Functions:  MemAlloc, MemFree, MemAllocLinked
//
//  History:    10-Feb-92   AlexT   Created
//        07-May-92   MikeSe  Converted to using Win32 Heap functions.
//        14-Jul-92   randyd  Added MemSwitchRoot, see memmgmt.doc.
//        5-Oct-93    isaache Slight reorganization, conversion to 'new'
//        13-Jul-94   doncl   stole from ole32, put in ADs proj, deleted
//                            MemSwitchRoot, switched to naked
//                            Win32 CRITICAL_SECTION usage
//
//  Notes:        For additional information, see win4adm\standrds\memmgmt.doc.
//
//                This memory management package is multithread capable - the
//                only place it makes a difference is in MemAllocLinked and
//                MemSwitchRoot, where we use a critical section t
//                protect adding link blocks to the list. We rely on the fact
//                that LocalAlloc is multi-thread safe.
//
//--------------------------------------------------------------------------

#include "dswarn.h"
#include <ADs.hxx>

#if 0
#include <excpt.h>
#include <except.hxx>
#include <dllsem.hxx>
#endif

CRITICAL_SECTION g_csMem;

//  Memory block prefix (for signature and link)

typedef struct _smheader
{
    unsigned long      ulSignature;
    struct _smheader   *psmNext;
} SMHEADER, *PSMHEADER;


//  Memory block signatures (for strict checks)

const ULONG ROOT_BLOCK          = 0x726f6f74;     // 'root'
const ULONG LINKED_BLOCK        = 0x6c696e6b;     // 'link'

static BOOL
VerifySignature(PSMHEADER psm, ULONG ulSig )
{
    BOOL fReturn;

    __try
    {
        fReturn = (ulSig == psm->ulSignature );
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        fReturn = FALSE;
    }

    return fReturn;
}

// This module acts as the declarer of debug support symbols for COMMNOT
DECLARE_INFOLEVEL(Cn);



//+-------------------------------------------------------------------------
//
//  Function:   MemAlloc
//
//  Synopsis:   allocates memory block
//
//  Arguments:  [ulSize]                -- size of block in bytes
//                        [ppv]            -- output pointer
//
//  Returns:    status code
//
//  Algorithm:  call new, adding space for header
//
//  History:    10-Feb-92 AlexT  Created
//
//--------------------------------------------------------------------------

HRESULT
MemAlloc ( unsigned long ulSize, void ** ppv )
{
    PSMHEADER psm;

    *ppv = NULL;

    psm = (PSMHEADER) LocalAlloc(LMEM_FIXED, ulSize + sizeof(SMHEADER));
    if ( psm != NULL )
    {
        psm->ulSignature = ROOT_BLOCK;
        psm->psmNext = NULL;

        *ppv = psm + 1;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------------
//
//  Function:   MemFree
//
//  Synopsis:   release system memory block
//
//  Arguments:  [pvBlockToFree] -- memory block to release
//
//  Algorithm:  Walk list of linked blocks, deleting each one
//
//  History:    10-Feb-92 AlexT  Created
//
//--------------------------------------------------------------------------

HRESULT
MemFree( void *pvBlockToFree )
{
    PSMHEADER psm = ((PSMHEADER) pvBlockToFree) - 1;

    if( pvBlockToFree == NULL || psm == NULL )
        return S_OK;

    if( !VerifySignature( psm, ROOT_BLOCK ) )
    {
        Win4Assert( !"MemFree -- not a root block!\n" );
        return MEM_E_INVALID_ROOT;
    }

    do {
        PSMHEADER psmNext = psm->psmNext;

        psm->ulSignature = 0;
        LocalFree(psm);
        psm = psmNext;
        if( psm && !VerifySignature( psm, LINKED_BLOCK ) )
        {
            Win4Assert( !"MemFree -- invalid linked block!\n" );
            return MEM_E_INVALID_LINK;
        }
    } while( psm != NULL );

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   MemAllocLinked
//
//  Synopsis:   allocates linked memory block
//
//
//  Arguments:  [pvRootBlock]   -- root memory block
//                        [ulSize]              -- size of new memory block
//                        [ppv]            -- output pointer
//
//  Returns:   status code
//
//
//  History:    10-Feb-92 AlexT  Created
//
//  Notes:        pvRootBlock can specify either a root block, or another
//                        linked block.
//
//--------------------------------------------------------------------------

HRESULT
MemAllocLinked ( void *pvRootBlock, unsigned long ulSize, void ** ppv )
{
    PSMHEADER psm = NULL;
    PSMHEADER psmRoot = ((PSMHEADER) pvRootBlock) - 1;

    *ppv = NULL;

    if ( pvRootBlock == NULL || psmRoot == NULL )
    {
        Win4Assert( !"MemAllocLinked - null root block\n" );
        return MEM_E_INVALID_ROOT;
    }


    if ( !VerifySignature(psmRoot, ROOT_BLOCK)
       && !VerifySignature(psmRoot,LINKED_BLOCK) )
    {
        Win4Assert( !"MemAllocLinked - invalid root block\n" );
        return MEM_E_INVALID_ROOT;
    }

    psm = (PSMHEADER) LocalAlloc(LMEM_FIXED, ulSize + sizeof(SMHEADER));
    if ( psm == NULL )
        return E_OUTOFMEMORY;

    psm->ulSignature = LINKED_BLOCK;

    EnterCriticalSection(&g_csMem);
    psm->psmNext = psmRoot->psmNext;
    psmRoot->psmNext = psm;
    LeaveCriticalSection(&g_csMem);

    //  move psm past header
    *ppv = psm+1;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\noole\misc.cxx ===
//+---------------------------------------------------------------------
//
//  File:       misc.cxx
//
//  Contents:   Useful OLE helper and debugging functions
//
//----------------------------------------------------------------------

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <basetyps.h>

#include "dswarn.h"
#include "oledsdbg.h"
}

#if (defined(BUILD_FOR_NT40))
typedef unsigned long HRESULT;
#endif



static HRESULT ADsDebugOutHRESULT(DWORD dwFlags, HRESULT r);

#if DBG == 1

//+---------------------------------------------------------------
//
//  Function:   PrintHRESULT
//
//  Synopsis:   Outputs the name of the SCODE and a carriage return
//              to the debugging device.
//
//  Arguments:  [dwFlags] -- Flags to ADsDebugOut.
//              [scode]   -- The status code to report.
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

STDAPI
PrintHRESULT(DWORD dwFlags, HRESULT hr)
{
    ADsDebugOut((dwFlags | DEB_NOCOMPNAME, " "));
    ADsDebugOutHRESULT(dwFlags | DEB_NOCOMPNAME, hr);
    ADsDebugOut((dwFlags | DEB_NOCOMPNAME, "\n"));

    return hr;
}



//+---------------------------------------------------------------
//
//  Function:   ADsDebugOutHRESULT
//
//  Synopsis:   Outputs the name of the SCODE to the debugging device.
//
//  Arguments:  [dwFlags] -- Flags to ADsDebugOut.
//              [scode]   -- The status code to report.
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

static HRESULT
ADsDebugOutHRESULT(DWORD dwFlags, HRESULT r)
{
    LPWSTR lpstr;

#define CASE_SCODE(sc)  \
        case sc: lpstr = (LPWSTR)L#sc; break;

    switch (r) {
        /* SCODE's defined in SCODE.H */
        CASE_SCODE(S_OK)
        CASE_SCODE(S_FALSE)
        CASE_SCODE(OLE_S_USEREG)
        CASE_SCODE(OLE_S_STATIC)
        CASE_SCODE(OLE_S_MAC_CLIPFORMAT)
        CASE_SCODE(DRAGDROP_S_DROP)
        CASE_SCODE(DRAGDROP_S_USEDEFAULTCURSORS)
        CASE_SCODE(DRAGDROP_S_CANCEL)
        CASE_SCODE(DATA_S_SAMEFORMATETC)
        CASE_SCODE(VIEW_S_ALREADY_FROZEN)
        CASE_SCODE(CACHE_S_FORMATETC_NOTSUPPORTED)
        CASE_SCODE(CACHE_S_SAMECACHE)
        CASE_SCODE(CACHE_S_SOMECACHES_NOTUPDATED)
        CASE_SCODE(OLEOBJ_S_INVALIDVERB)
        CASE_SCODE(OLEOBJ_S_CANNOT_DOVERB_NOW)
        CASE_SCODE(OLEOBJ_S_INVALIDHWND)
        CASE_SCODE(INPLACE_S_TRUNCATED)
        CASE_SCODE(CONVERT10_S_NO_PRESENTATION)
        CASE_SCODE(MK_S_REDUCED_TO_SELF)
        CASE_SCODE(MK_S_ME)
        CASE_SCODE(MK_S_HIM)
        CASE_SCODE(MK_S_US)
        CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)
        CASE_SCODE(STG_S_CONVERTED)

        CASE_SCODE(E_UNEXPECTED)
        CASE_SCODE(E_NOTIMPL)
        CASE_SCODE(E_OUTOFMEMORY)
        CASE_SCODE(E_INVALIDARG)
        CASE_SCODE(E_NOINTERFACE)
        CASE_SCODE(E_POINTER)
        CASE_SCODE(E_HANDLE)
        CASE_SCODE(E_ABORT)
        CASE_SCODE(E_FAIL)
        CASE_SCODE(E_ACCESSDENIED)

        /* SCODE's defined in DVOBJ.H */
        // CASE_SCODE(DATA_E_FORMATETC)
// same as DATA_E_FORMATETC     CASE_SCODE(DV_E_FORMATETC)
        CASE_SCODE(VIEW_E_DRAW)
//  same as VIEW_E_DRAW         CASE_SCODE(E_DRAW)
        CASE_SCODE(CACHE_E_NOCACHE_UPDATED)

        /* SCODE's defined in OLE2.H */
        CASE_SCODE(OLE_E_OLEVERB)
        CASE_SCODE(OLE_E_ADVF)
        CASE_SCODE(OLE_E_ENUM_NOMORE)
        CASE_SCODE(OLE_E_ADVISENOTSUPPORTED)
        CASE_SCODE(OLE_E_NOCONNECTION)
        CASE_SCODE(OLE_E_NOTRUNNING)
        CASE_SCODE(OLE_E_NOCACHE)
        CASE_SCODE(OLE_E_BLANK)
        CASE_SCODE(OLE_E_CLASSDIFF)
        CASE_SCODE(OLE_E_CANT_GETMONIKER)
        CASE_SCODE(OLE_E_CANT_BINDTOSOURCE)
        CASE_SCODE(OLE_E_STATIC)
        CASE_SCODE(OLE_E_PROMPTSAVECANCELLED)
        CASE_SCODE(OLE_E_INVALIDRECT)
        CASE_SCODE(OLE_E_WRONGCOMPOBJ)
        CASE_SCODE(OLE_E_INVALIDHWND)
        CASE_SCODE(DV_E_DVTARGETDEVICE)
        CASE_SCODE(DV_E_STGMEDIUM)
        CASE_SCODE(DV_E_STATDATA)
        CASE_SCODE(DV_E_LINDEX)
        CASE_SCODE(DV_E_TYMED)
        CASE_SCODE(DV_E_CLIPFORMAT)
        CASE_SCODE(DV_E_DVASPECT)
        CASE_SCODE(DV_E_DVTARGETDEVICE_SIZE)
        CASE_SCODE(DV_E_NOIVIEWOBJECT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_GET)
        CASE_SCODE(CONVERT10_E_OLESTREAM_PUT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_FMT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB)
        CASE_SCODE(CONVERT10_E_STG_FMT)
        CASE_SCODE(CONVERT10_E_STG_NO_STD_STREAM)
        CASE_SCODE(CONVERT10_E_STG_DIB_TO_BITMAP)
        CASE_SCODE(CLIPBRD_E_CANT_OPEN)
        CASE_SCODE(CLIPBRD_E_CANT_EMPTY)
        CASE_SCODE(CLIPBRD_E_CANT_SET)
        CASE_SCODE(CLIPBRD_E_BAD_DATA)
        CASE_SCODE(CLIPBRD_E_CANT_CLOSE)
        CASE_SCODE(DRAGDROP_E_NOTREGISTERED)
        CASE_SCODE(DRAGDROP_E_ALREADYREGISTERED)
        CASE_SCODE(DRAGDROP_E_INVALIDHWND)
        CASE_SCODE(OLEOBJ_E_NOVERBS)
        CASE_SCODE(INPLACE_E_NOTUNDOABLE)
        CASE_SCODE(INPLACE_E_NOTOOLSPACE)

        /* SCODE's defined in STORAGE.H */
        CASE_SCODE(STG_E_INVALIDFUNCTION)
        CASE_SCODE(STG_E_FILENOTFOUND)
        CASE_SCODE(STG_E_PATHNOTFOUND)
        CASE_SCODE(STG_E_TOOMANYOPENFILES)
        CASE_SCODE(STG_E_ACCESSDENIED)
        CASE_SCODE(STG_E_INVALIDHANDLE)
        CASE_SCODE(STG_E_INSUFFICIENTMEMORY)
        CASE_SCODE(STG_E_INVALIDPOINTER)
        CASE_SCODE(STG_E_NOMOREFILES)
        CASE_SCODE(STG_E_DISKISWRITEPROTECTED)
        CASE_SCODE(STG_E_SEEKERROR)
        CASE_SCODE(STG_E_WRITEFAULT)
        CASE_SCODE(STG_E_READFAULT)
        CASE_SCODE(STG_E_LOCKVIOLATION)
        CASE_SCODE(STG_E_FILEALREADYEXISTS)
        CASE_SCODE(STG_E_INVALIDPARAMETER)
        CASE_SCODE(STG_E_MEDIUMFULL)
        CASE_SCODE(STG_E_ABNORMALAPIEXIT)
        CASE_SCODE(STG_E_INVALIDHEADER)
        CASE_SCODE(STG_E_INVALIDNAME)
        CASE_SCODE(STG_E_UNKNOWN)
        CASE_SCODE(STG_E_UNIMPLEMENTEDFUNCTION)
        CASE_SCODE(STG_E_INVALIDFLAG)
        CASE_SCODE(STG_E_INUSE)
        CASE_SCODE(STG_E_NOTCURRENT)
        CASE_SCODE(STG_E_REVERTED)
        CASE_SCODE(STG_E_CANTSAVE)
        CASE_SCODE(STG_E_OLDFORMAT)
        CASE_SCODE(STG_E_OLDDLL)
        CASE_SCODE(STG_E_SHAREREQUIRED)

        /* SCODE's defined in COMPOBJ.H */
        CASE_SCODE(CO_E_NOTINITIALIZED)
        CASE_SCODE(CO_E_ALREADYINITIALIZED)
        CASE_SCODE(CO_E_CANTDETERMINECLASS)
        CASE_SCODE(CO_E_CLASSSTRING)
        CASE_SCODE(CO_E_IIDSTRING)
        CASE_SCODE(CO_E_APPNOTFOUND)
        CASE_SCODE(CO_E_APPSINGLEUSE)
        CASE_SCODE(CO_E_ERRORINAPP)
        CASE_SCODE(CO_E_DLLNOTFOUND)
        CASE_SCODE(CO_E_ERRORINDLL)
        CASE_SCODE(CO_E_WRONGOSFORAPP)
        CASE_SCODE(CO_E_OBJNOTREG)
        CASE_SCODE(CO_E_OBJISREG)
        CASE_SCODE(CO_E_OBJNOTCONNECTED)
        CASE_SCODE(CO_E_APPDIDNTREG)
        CASE_SCODE(CLASS_E_NOAGGREGATION)
        CASE_SCODE(REGDB_E_READREGDB)
        CASE_SCODE(REGDB_E_WRITEREGDB)
        CASE_SCODE(REGDB_E_KEYMISSING)
        CASE_SCODE(REGDB_E_INVALIDVALUE)
        CASE_SCODE(REGDB_E_CLASSNOTREG)
        CASE_SCODE(REGDB_E_IIDNOTREG)
        CASE_SCODE(RPC_E_CALL_REJECTED)
        CASE_SCODE(RPC_E_CALL_CANCELED)
        CASE_SCODE(RPC_E_CANTPOST_INSENDCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INASYNCCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INEXTERNALCALL)
        CASE_SCODE(RPC_E_CONNECTION_TERMINATED)
#if defined(NO_NTOLEBUGS)
        CASE_SCODE(RPC_E_SERVER_DIED)
#endif // NO_NTOLEBUGS
        CASE_SCODE(RPC_E_CLIENT_DIED)
        CASE_SCODE(RPC_E_INVALID_DATAPACKET)
        CASE_SCODE(RPC_E_CANTTRANSMIT_CALL)
        CASE_SCODE(RPC_E_CLIENT_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_CLIENT_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_INVALID_DATA)
        CASE_SCODE(RPC_E_INVALID_PARAMETER)
        CASE_SCODE(RPC_E_UNEXPECTED)

        /* SCODE's defined in MONIKER.H */
        CASE_SCODE(MK_E_CONNECTMANUALLY)
        CASE_SCODE(MK_E_EXCEEDEDDEADLINE)
        CASE_SCODE(MK_E_NEEDGENERIC)
        CASE_SCODE(MK_E_UNAVAILABLE)
        CASE_SCODE(MK_E_SYNTAX)
        CASE_SCODE(MK_E_NOOBJECT)
        CASE_SCODE(MK_E_INVALIDEXTENSION)
        CASE_SCODE(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED)
        CASE_SCODE(MK_E_NOTBINDABLE)
        CASE_SCODE(MK_E_NOTBOUND)
        CASE_SCODE(MK_E_CANTOPENFILE)
        CASE_SCODE(MK_E_MUSTBOTHERUSER)
        CASE_SCODE(MK_E_NOINVERSE)
        CASE_SCODE(MK_E_NOSTORAGE)
#if defined(NO_NTOLEBUGS)
        CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)
#endif //NO_NTOLEBUGS


        // Dispatch error codes
        CASE_SCODE(DISP_E_MEMBERNOTFOUND)

        default:
            ADsDebugOut((dwFlags, "<UNKNOWN SCODE  0x%lx>", r));
            return r;
    }

#undef CASE_SCODE

    ADsDebugOut((dwFlags, "<%ws (0x%lx)>", lpstr, r));
    return r;
}



//+---------------------------------------------------------------------------
//
//  Function:   BreakOnFailed
//
//  Synopsis:   Function called when CheckAndReturnResult or CheckResult
//              examines a failure code.  Set a breakpoint on this function
//              to break on failures.
//
//  History:    5-18-94   adams   Created
//
//----------------------------------------------------------------------------

static void
BreakOnFailed(void)
{
    int x;
    x = 1;
}


//+---------------------------------------------------------------
//
//  Function:   CheckAndReturnResult
//
//  Synopsis:   Issues a warning if the HRESULT indicates failure,
//              and asserts if the HRESULT is not a permitted success code.
//
//  Arguments:  [hr]        -- the HRESULT to be checked.
//              [lpstrFile] -- the file where the HRESULT is being checked.
//              [line]      -- the line in the file where the HRESULT is
//                              being checked.
//              [cSuccess]  -- the number of permitted non-zero success codes.
//              [...]       -- list of success codes.
//
//  Returns:    The return value is exactly the HRESULT passed in.
//
//  History:    1-06-94   adams   Created.
//              5-24-94   adams   Added call to BreakOnFailed.
//
//  Notes:      This function should not be used directly.  Use
//              the SRETURN and RRETURN macros instead.
//
//----------------------------------------------------------------

STDAPI
CheckAndReturnResult(
        HRESULT hr,
        LPSTR   lpstrFile,
        UINT    line,
        int     cSuccess,
        ...)
{
    BOOL    fOKReturnCode;
    va_list va;
    int     i;
    HRESULT hrSuccess;

    //
    // Check if code is an error or permitted success.
    //

    fOKReturnCode = (FAILED(hr) || hr == S_OK || hr == S_FALSE ||
                     cSuccess == -1);
    if (!fOKReturnCode && cSuccess > 0)
    {
        va_start(va, cSuccess);
        for (i = 0; i < cSuccess; i++)
        {
            hrSuccess = va_arg(va, HRESULT);
            ADsAssert(SUCCEEDED(hrSuccess));
            if (hr == hrSuccess)
            {
                fOKReturnCode = TRUE;
                break;
            }
        }

        va_end(va);
    }

    //
    // Assert on non-permitted success code.
    //

    if (!fOKReturnCode)
    {
/* ADsDebugOut((
                DEB_ERROR,
                "ERROR: %s:%d returned bad success code",
                lpstrFile,
                line)); */

        // (void) PrintHRESULT(DEB_ERROR | DEB_NOCOMPNAME, hr);

        //
        // I've removed the Assert but we should enable this
        // to monitor all functions that are returning S_FALSE
        // As far as possible, functions should not return
        // S_FALSE except for the Next function of an Enumerator
        // object.

        // ADsAssert(0 && "An unpermitted success code was returned.");
    }

    //
    // Warn on error result.
    //

    if (FAILED(hr))
    {
        ADsDebugOut((
                DEB_IWARN,
                "WARNING: %s:%d returning",
                lpstrFile,
                line));

        PrintHRESULT(DEB_IWARN | DEB_NOCOMPNAME, hr);

        BreakOnFailed();
    }

    return hr;
}



//+---------------------------------------------------------------
//
//  Function:   CheckResult
//
//  Synopsis:   Issues a warning if the HRESULT indicates failure
//
//  Arguments:  [hr] -- the HRESULT to be checked
//              [lpstrFile] -- the file where the HRESULT is being checked
//              [line] -- the line in the file where the HRESULT is being checked
//
//
//  History:    1-06-94   adams   Error printed only on FAILURE, not also
//                                  on non-zero success.
//              5-24-94   adams   Added call to BreakOnFailed.
//
//  Notes:      This function should not be used directly.  The RRETURN
//              macro is provided for convenience.
//
//----------------------------------------------------------------

STDAPI_(void)
CheckResult(HRESULT hr, LPSTR lpstrFile, UINT line)
{
    if (FAILED(hr))
    {
        ADsDebugOut((DEB_IWARN, "WARNING: "));
        ADsDebugOutHRESULT(DEB_IWARN | DEB_NOCOMPNAME, hr);
        ADsDebugOut((
                DEB_IWARN | DEB_NOCOMPNAME,
                " occurred at %s:%d.\n",
                lpstrFile,
                line));

        BreakOnFailed();
    }
}


#endif  // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\noole\creden.cxx ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    creden.cxx

Abstract:

    This module abstracts user credentials for the multiple credential support.

Author:

    Krishna Ganugapati (KrishnaG) 03-Aug-1996

Revision History:

--*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
#include "memory.h"
}


#include <basetyps.h>
#include <des.h>
#include <crypt.h>

typedef  long HRESULT;


#include "misc.hxx"
#include "creden.hxx"
#include "macro.h"


//
// This routine allocates and stores the password in the 
// passed in pointer. The assumption here is that pszString
// is valid, it can be an empty string but not NULL.
// Note that this code cannot be used as is on Win2k and below
// as they do not support the newer functions.
//
HRESULT
EncryptString(
    LPWSTR pszString,
    LPWSTR *ppszSafeString,
    PDWORD pdwLen
    )
{
    HRESULT hr = S_OK;
    DWORD dwLenStr = 0;
    DWORD dwPwdLen = 0;
    LPWSTR pszTempStr = NULL;
    NTSTATUS errStatus = STATUS_SUCCESS;

    *ppszSafeString = NULL;
    *pdwLen = 0;

    //
    // If the string is valid, then we need to get the length
    // and initialize the unicode string.
    //
    if (pszString) {
        UNICODE_STRING Password;

        //
        // Determine the length of buffer taking padding into account.
        //
        dwLenStr = wcslen(pszString);

        dwPwdLen = (dwLenStr + 1) * sizeof(WCHAR) + (DES_BLOCKLEN -1);

        pszTempStr = (LPWSTR) AllocADsMem(dwPwdLen);
        
        if (!pszTempStr) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        wcscpy(pszTempStr, pszString);

        RtlInitUnicodeString(&Password, pszTempStr);


        USHORT usExtra = 0;

        if (usExtra = (Password.MaximumLength % DES_BLOCKLEN)) {
            Password.MaximumLength += (DES_BLOCKLEN - usExtra);
        }

        errStatus = RtlEncryptMemory(
                        Password.Buffer,
                        Password.MaximumLength,
                        0
                        );

        if (errStatus != STATUS_SUCCESS) {

            BAIL_ON_FAILURE(hr = HRESULT_FROM_NT(errStatus));
        }

        *pdwLen = Password.MaximumLength;
        *ppszSafeString = pszTempStr;
    }

error:

    if (FAILED(hr) && pszTempStr) {
        FreeADsMem(pszTempStr);
    }

    RRETURN(hr);
}

HRESULT
DecryptString(
    LPWSTR pszEncodedString,
    LPWSTR *ppszString,
    DWORD  dwLen
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszTempStr = NULL;
    UNICODE_STRING Password;
    NTSTATUS errStatus;
    
    if (!dwLen || !ppszString) {
        RRETURN(E_FAIL);
    }

    *ppszString = NULL;

    if (dwLen) {
        pszTempStr = (LPWSTR) AllocADsMem(dwLen);
        if (!pszTempStr) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        memcpy(pszTempStr, pszEncodedString, dwLen);


        errStatus = RtlDecryptMemory(pszTempStr, dwLen, 0);
        if (errStatus != STATUS_SUCCESS) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_NT(errStatus));
        }
        *ppszString = pszTempStr;
    }

error:

    if (FAILED(hr)) {
        FreeADsStr(pszTempStr);
    }

    RRETURN(hr);
}

//
// Static member of the class
//
CCredentials::CCredentials():
    _lpszUserName(NULL),
    _lpszPassword(NULL),
    _dwAuthFlags(0),
    _dwPasswordLen(0)
{
}

CCredentials::CCredentials(
    LPWSTR lpszUserName,
    LPWSTR lpszPassword,
    DWORD dwAuthFlags
    ):
    _lpszUserName(NULL),
    _lpszPassword(NULL),
    _dwAuthFlags(0),
    _dwPasswordLen(0)
{

    //
    // AjayR 10-04-99 we need a way to bail if the
    // alloc's fail. Since it is in the constructor this is
    // not very easy to do.
    //

    if (lpszUserName) {
        _lpszUserName = AllocADsStr(lpszUserName);
    }
    else {
        _lpszUserName = NULL;
    }

    if (lpszPassword) {
        //
        // The call can fail but we cannot recover from this.
        //
        EncryptString(
            lpszPassword,
            &_lpszPassword,
            &_dwPasswordLen
            );
        
    }else {

        _lpszPassword = NULL;

    }

    _dwAuthFlags = dwAuthFlags;

}

CCredentials::~CCredentials()
{
    if (_lpszUserName) {
        FreeADsStr(_lpszUserName);
    }

    if (_lpszPassword) {
        FreeADsStr(_lpszPassword);
    }

}



HRESULT
CCredentials::GetUserName(
    LPWSTR *lppszUserName
    )
{
    if (!lppszUserName) {
        RRETURN(E_FAIL);
    }


    if (!_lpszUserName) {
        *lppszUserName = NULL;
    }else {

        *lppszUserName = AllocADsStr(_lpszUserName);

        if (!*lppszUserName) {

            RRETURN(E_OUTOFMEMORY);
        }
    }

    RRETURN(S_OK);
}


HRESULT
CCredentials::GetPassword(
    LPWSTR * lppszPassword
    )
{
    UNICODE_STRING Password;
    LPWSTR lpTempPassword = NULL;

    Password.Length = 0;

    if (!lppszPassword) {
        RRETURN(E_FAIL);
    }

    if (!_lpszPassword) {
        *lppszPassword = NULL;
    }else {

        RRETURN(
            DecryptString(
                _lpszPassword,
                lppszPassword,
                _dwPasswordLen
                )
            );

    }

    RRETURN(S_OK);
}


HRESULT
CCredentials::SetUserName(
    LPWSTR lpszUserName
    )
{
    if (_lpszUserName) {
        FreeADsStr(_lpszUserName);
    }

    if (!lpszUserName) {

        _lpszUserName = NULL;
        RRETURN(S_OK);
    }

    _lpszUserName = AllocADsStr(
                        lpszUserName
                        );
    if(!_lpszUserName) {
        RRETURN(E_FAIL);
    }

    RRETURN(S_OK);
}


HRESULT
CCredentials::SetPassword(
    LPWSTR lpszPassword
    )
{

    if (_lpszPassword) {
        FreeADsStr(_lpszPassword);
    }

    if (!lpszPassword) {

        _lpszPassword = NULL;
        RRETURN(S_OK);
    }

    RRETURN(
        EncryptString(
            lpszPassword,
            &_lpszPassword,
            &_dwPasswordLen
            )
        );
}

CCredentials::CCredentials(
    const CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszTmpPwd = NULL;

    _lpszUserName = NULL;
    _lpszPassword = NULL;

    _lpszUserName = AllocADsStr(
                        Credentials._lpszUserName
                        );


    if (Credentials._lpszPassword) {
        hr = DecryptString(
                 Credentials._lpszPassword,
                 &pszTmpPwd,
                 Credentials._dwPasswordLen
                 );
    }

    if (SUCCEEDED(hr) && pszTmpPwd) {
        hr = EncryptString(
                 pszTmpPwd,
                 &_lpszPassword,
                 &_dwPasswordLen
                 );
    }

    if (pszTmpPwd) {
        FreeADsStr(pszTmpPwd);
    }
    
    _dwAuthFlags = Credentials._dwAuthFlags;


}


void
CCredentials::operator=(
    const CCredentials& other
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszTmpPwd = NULL;

    if ( &other == this) {
        return;
    }

    if (_lpszUserName) {
        FreeADsStr(_lpszUserName);
    }

    if (_lpszPassword) {
        FreeADsStr(_lpszPassword);
    }

    _lpszUserName = AllocADsStr(
                        other._lpszUserName
                        );


    if (other._lpszPassword) {
        hr = DecryptString(
                 other._lpszPassword,
                 &pszTmpPwd,
                 other._dwPasswordLen
                 );
    }

    if (SUCCEEDED(hr) && pszTmpPwd) {
        hr = EncryptString(
                 pszTmpPwd,
                 &_lpszPassword,
                 &_dwPasswordLen
                 );
    }

    if (pszTmpPwd) {
        FreeADsStr(pszTmpPwd);
    }
    
    _dwAuthFlags = other._dwAuthFlags;

    return;
}


BOOL
operator==(
    CCredentials& x,
    CCredentials& y
    )
{
    BOOL bEqualUser = FALSE;
    BOOL bEqualPassword = FALSE;
    BOOL bEqualFlags = FALSE;

    LPWSTR lpszXPassword = NULL;
    LPWSTR lpszYPassword = NULL;
    BOOL bReturnCode = FALSE;
    HRESULT hr = S_OK;


    if (x._lpszUserName &&  y._lpszUserName) {
        bEqualUser = !(wcscmp(x._lpszUserName, y._lpszUserName));
    }else  if (!x._lpszUserName && !y._lpszUserName){
        bEqualUser = TRUE;
    }

    hr = x.GetPassword(&lpszXPassword);
    if (FAILED(hr)) {
        goto error;
    }

    hr = y.GetPassword(&lpszYPassword);
    if (FAILED(hr)) {
        goto error;
    }


    if ((lpszXPassword && lpszYPassword)) {
        bEqualPassword = !(wcscmp(lpszXPassword, lpszYPassword));
    }else if (!lpszXPassword && !lpszYPassword) {
        bEqualPassword = TRUE;
    }


    if (x._dwAuthFlags == y._dwAuthFlags) {
        bEqualFlags = TRUE;
    }


    if (bEqualUser && bEqualPassword && bEqualFlags) {

       bReturnCode = TRUE;
    }


error:

    if (lpszXPassword) {
        FreeADsStr(lpszXPassword);
    }

    if (lpszYPassword) {
        FreeADsStr(lpszYPassword);
    }

    return(bReturnCode);

}


BOOL
CCredentials::IsNullCredentials(
    )
{
    // The function will return true even if the flags are set
    // this is because we want to try and get the default credentials
    // even if the flags were set
     if (!_lpszUserName && !_lpszPassword) {
         return(TRUE);
     }else {
         return(FALSE);
     }

}


DWORD
CCredentials::GetAuthFlags()
{
    return(_dwAuthFlags);
}


void
CCredentials::SetAuthFlags(
    DWORD dwAuthFlags
    )
{
    _dwAuthFlags = dwAuthFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cenumsch.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumsch.cxx
//
//  Contents:  Windows NT 3.5 Schema Enumeration Code
//
//             CNWCOMPATSchemaEnum::CNWCOMPATSchemaEnum()
//             CNWCOMPATSchemaEnum::CNWCOMPATSchemaEnum
//             CNWCOMPATSchemaEnum::EnumObjects
//             CNWCOMPATSchemaEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATSchemaEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATSchemaEnum::Create(
    CNWCOMPATSchemaEnum FAR* FAR* ppenumvariant,
    BSTR bstrADsPath,
    BSTR bstrName,
    VARIANT vFilter
    )
{
    HRESULT hr = S_OK;
    CNWCOMPATSchemaEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CNWCOMPATSchemaEnum();
    if (!penumvariant)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( bstrADsPath, &penumvariant->_bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrName, &penumvariant->_bstrName);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
            vFilter,
            &penumvariant->_pObjList );
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    delete penumvariant;

    NW_RRETURN_EXP_IF_ERR(hr);
}

CNWCOMPATSchemaEnum::CNWCOMPATSchemaEnum()
    : _bstrADsPath( NULL ),
      _bstrName( NULL ),
      _pObjList( NULL ),
      _dwCurrentEntry( 0 ),
      _dwPropCurrentEntry( 0 )
{
}

CNWCOMPATSchemaEnum::~CNWCOMPATSchemaEnum()
{
   ADsFreeString( _bstrName );
   ADsFreeString( _bstrADsPath );

   if ( _pObjList != NULL )
   {
       delete _pObjList;
       _pObjList = NULL;
   }
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATSchemaEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   yihsins     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATSchemaEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects( cElements,
                      pvar,
                      &cElementFetched );

    if ( pcElementFetched )
        *pcElementFetched = cElementFetched;

    NW_RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNWCOMPATSchemaEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    switch (ObjectType)
    {
        case NWCOMPAT_CLASS_ID:
            RRETURN (EnumClasses(cElements, pvar, pcElementFetched));


        case NWCOMPAT_PROPERTY_ID:
            RRETURN (EnumProperties(cElements, pvar, pcElementFetched));

        case NWCOMPAT_SYNTAX_ID:
            RRETURN(EnumSyntaxObjects(cElements, pvar, pcElementFetched));

        default:
            RRETURN(S_FALSE);
    }
}

HRESULT
CNWCOMPATSchemaEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)
        VariantInit(&pvar[i]);

    cRequested = cElements;

    while (  SUCCEEDED( _pObjList->GetCurrentObject(&ObjectType))
          && ((hr = EnumObjects( ObjectType,
                                 cRequested,
                                 pPathvar,
                                 &cFetchedByPath)) == S_FALSE )
          )
    {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if ( FAILED(_pObjList->Next()) )
        {
            if ( pcElementFetched )
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

        _dwCurrentEntry = 0;
    }

    if ( pcElementFetched )
        *pcElementFetched = cTotalFetched + cFetchedByPath;

    RRETURN(hr);
}

HRESULT
CNWCOMPATSchemaEnum::EnumClasses(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetClassObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNWCOMPATSchemaEnum::GetClassObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current ovbject
    //
    if ( _dwCurrentEntry >= g_cNWCOMPATClasses )
        goto error;

    hr = CNWCOMPATClass::CreateClass(
                        _bstrADsPath,
                        &g_aNWCOMPATClasses[_dwCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}

HRESULT
CNWCOMPATSchemaEnum::EnumSyntaxObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetSyntaxObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNWCOMPATSchemaEnum::GetSyntaxObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current object
    //
    if ( _dwCurrentEntry >= g_cNWCOMPATSyntax )
        goto error;

    hr = CNWCOMPATSyntax::CreateSyntax(
                        _bstrADsPath,
                        &g_aNWCOMPATSyntax[_dwCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}


HRESULT
CNWCOMPATSchemaEnum::EnumProperties(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetPropertyObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNWCOMPATSchemaEnum::GetPropertyObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current ovbject
    //
    if ( _dwPropCurrentEntry >= g_cNWCOMPATProperties )
        goto error;

    hr = CNWCOMPATProperty::CreateProperty(
                        _bstrADsPath,
                        &g_aNWCOMPATProperties[_dwPropCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwPropCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cenumjob.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      cenumjob.cxx
//
//  Contents:  NetWare 3.12 JobCollection Enumeration Code
//
//              CNWCOMPATJobCollectionEnum::Create
//              CNWCOMPATJobCollectionEnum::GetJobObject
//              CNWCOMPATJobCollectionEnum::EnumJobMembers
//              CNWCOMPATJobCollectionEnum::Next
//
//  History:   08-May-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    08-Mag-96   t-ptam (Patrick Tam)     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATJobCollectionEnum::Create(
    CNWCOMPATJobCollectionEnum FAR* FAR* ppEnumVariant,
    BSTR PrinterName,
    CCredentials &Credentials
    )
{
    HRESULT hr = S_OK;
    CNWCOMPATJobCollectionEnum FAR* pEnumVariant = NULL;
    POBJECTINFO pPrinterObjectInfo = NULL;
    WCHAR szUncPrinterName[MAX_PATH];

    //
    // Validate input parameters.
    //

    if (!(ppEnumVariant) || !(PrinterName)) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    *ppEnumVariant = NULL;

    //
    // Allocate a Collection Enumerator object.
    //

    pEnumVariant = new CNWCOMPATJobCollectionEnum();
    if (!pEnumVariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString(PrinterName, &pEnumVariant->_PrinterName);
    BAIL_ON_FAILURE(hr);

    //
    // Make Unc Name to open a printer.
    //

    hr = BuildObjectInfo(
             PrinterName,
             &pPrinterObjectInfo 
             );

    BAIL_ON_FAILURE(hr);

    pEnumVariant->_Credentials = Credentials;

    //
    // Get a handle to the bindery this object resides on.
    //

    hr = NWApiGetBinderyHandle(
             &pEnumVariant->_hConn,
             pPrinterObjectInfo->ComponentArray[0],
             pEnumVariant->_Credentials
             );
    BAIL_ON_FAILURE(hr);


    ADsAssert(pPrinterObjectInfo->NumComponents == 2);

    wcscpy(PrinterName,
           pPrinterObjectInfo->ComponentArray[0]);

    MakeUncName (PrinterName,
                 szUncPrinterName);

    wcscat(szUncPrinterName,TEXT("\\"));
    wcscat(szUncPrinterName, pPrinterObjectInfo->ComponentArray[1]);

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &pEnumVariant->_hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    *ppEnumVariant = pEnumVariant;

    if(pPrinterObjectInfo){
        FreeObjectInfo(pPrinterObjectInfo);
    }
    RRETURN(hr);

error:
    if(pPrinterObjectInfo){
        FreeObjectInfo(pPrinterObjectInfo);
    }

    delete pEnumVariant;

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollectionEnum::CNWCOMPATJobCollectionEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATJobCollectionEnum::CNWCOMPATJobCollectionEnum():
        _PrinterName(NULL),
        _hPrinter(NULL),
        _pBuffer(NULL),
        _dwReturned(0),
        _dwCurrentObject(0),
        _hConn(NULL)
{
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollectionEnum::~CNWCOMPATJobCollectionEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATJobCollectionEnum::~CNWCOMPATJobCollectionEnum()
{
    if (_PrinterName) {
        SysFreeString(_PrinterName);
    }

    if (_hPrinter) {
        NWApiClosePrinter(_hPrinter);
    }

    if (_pBuffer) {
        FreeADsMem(_pBuffer);
    }

    if (_hConn)
        NWApiReleaseBinderyHandle(_hConn);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollectionEnum::EnumJobMembers
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATJobCollectionEnum::EnumJobMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetJobObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollectionEnum::GetJobObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATJobCollectionEnum::GetJobObject(
    IDispatch ** ppDispatch
    )
{
    DWORD        dwBuf = 0;
    DWORD        dwJobInQueue = 0;
    HRESULT      hr = S_OK;
    LPBYTE       lpbPrinterInfo = NULL;
    LPJOB_INFO_1 lpJobInfo = NULL;

    //
    // Fill _pBuffer with JobID.  Win32 API returns all jobs in one shot.
    //

    if (!_pBuffer) {

        //
        // Get the number of print jobs that have been queued for the printer.
        //

        hr = NWApiGetPrinter(
                 _hPrinter,
                 WIN32_API_LEVEL_2,
                 &lpbPrinterInfo
                 );
        BAIL_ON_FAILURE(hr);

        dwJobInQueue = ((LPPRINTER_INFO_2)lpbPrinterInfo)->cJobs;

        //
        // Enumerate for all the jobs.
        //

        hr = NWApiEnumJobs(
                 _hPrinter,
                 FIRST_PRINTJOB,
                 dwJobInQueue,
                 WIN32_API_LEVEL_1,
                 &_pBuffer,
                 &dwBuf,
                 &_dwReturned
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Traverse the buffer and return a PrintJob object.
    //

    if (_dwCurrentObject < _dwReturned) {

        //
        // Go to the next structure in the buffer.
        //

        lpJobInfo = (LPJOB_INFO_1)_pBuffer + _dwCurrentObject;

        //
        // Create a print job object.
        //

        hr = CNWCOMPATPrintJob::CreatePrintJob(
                 _PrinterName,
                 lpJobInfo->JobId,
                 _Credentials,
                 ADS_OBJECT_BOUND,
                 IID_IDispatch,
                 (void **)ppDispatch
                 );
        BAIL_ON_FAILURE(hr);

        //
        // Return.
        //

        _dwCurrentObject++;
        
        if(lpbPrinterInfo){
            FreeADsMem(lpbPrinterInfo);
        }
        RRETURN(S_OK);
    }

error:
       
    if(lpbPrinterInfo){
        FreeADsMem(lpbPrinterInfo);
    }

    *ppDispatch = NULL;

    RRETURN(S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATJobCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumJobMembers(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    NW_RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cenumcom.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cenumcom.cxx
//
//  Contents:  NetWare 3.12 Path Object code
//
//              CNWCOMPATComputerEnum::
//              CNWCOMPATComputerEnum::
//              CNWCOMPATComputerEnum::
//              CNWCOMPATComputerEnum::
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   t-ptam     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::Create(
    CNWCOMPATComputerEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    BSTR ComputerName,
    CCredentials &Credentials,
    VARIANT var
    )
{
    HRESULT hr = NOERROR;
    CNWCOMPATComputerEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    //
    // Allocate memory for an enumerator.
    //

    penumvariant = new CNWCOMPATComputerEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Save protected values.
    //

    hr = ADsAllocString(ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ComputerName,  &penumvariant->_ComputerName);
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    hr = NWApiGetBinderyHandle(
             &penumvariant->_hConn,
             ComputerName,
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Make object list.
    //

    hr = ObjectTypeList::CreateObjectTypeList(
             var,
             &penumvariant->_pObjList
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::CNWCOMPATComputerEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATComputerEnum::CNWCOMPATComputerEnum():
                        _ComputerName(NULL),
                        _ADsPath(NULL)
{
    _hConn = NULL;
    _pObjList = NULL;

    _dwUserResumeObjectID = 0xffffffff;
    _dwGroupResumeObjectID = 0xffffffff;
    _dwPrinterResumeObjectID = 0xffffffff;
    _fFileServiceOnce = FALSE;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::~CNWCOMPATComputerEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATComputerEnum::~CNWCOMPATComputerEnum()
{
    if (_ComputerName)
        SysFreeString(_ComputerName);
    if (_ADsPath)
        SysFreeString(_ADsPath);
    if (_pObjList)
        delete _pObjList;
    if (_hConn)
        NWApiReleaseBinderyHandle(_hConn);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumObjects
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    switch (ObjectType) {

    case NWCOMPAT_USER_ID:
        return(EnumUsers( cElements, pvar, pcElementFetched));

    case NWCOMPAT_GROUP_ID:
        return(EnumGroups( cElements, pvar, pcElementFetched));

    case NWCOMPAT_SERVICE_ID:
        return(EnumFileServices(cElements, pvar, pcElementFetched));

    case NWCOMPAT_PRINTER_ID:
        return(EnumPrinters(cElements, pvar, pcElementFetched));

    default:
        return(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumObjects
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while (SUCCEEDED(_pObjList->GetCurrentObject(&ObjectType)) &&
          ((hr = EnumObjects(
                     ObjectType,
                     cRequested,
                     pPathvar,
                     &cFetchedByPath)) == S_FALSE )) {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (FAILED(_pObjList->Next())){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            return(ResultFromScode(S_FALSE));
        }
    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumUsers
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumUsers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetUserObject(&pDispatch);

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::GetUserObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::GetUserObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT    hr = S_OK;
    LPTSTR     pszObjectName = NULL;

    *ppDispatch = NULL;

    hr = NWApiObjectEnum(
             _hConn,
             OT_USER,
             &pszObjectName,
             &_dwUserResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now send back the current object
    //

    hr = CNWCOMPATUser::CreateUser(
             _ADsPath,
             NWCOMPAT_COMPUTER_ID,
             _ComputerName,
             pszObjectName,
             _Credentials,
             ADS_OBJECT_BOUND,
             IID_IDispatch,
             (void **)ppDispatch
             );
    BAIL_ON_FAILURE(hr);

error:
    if (pszObjectName) {
        FreeADsStr(pszObjectName);
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumGroups
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetGroupObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::GetGroupObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::GetGroupObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPTSTR  pszObjectName = NULL;

    *ppDispatch = NULL;

    hr = NWApiObjectEnum(
             _hConn,
             OT_USER_GROUP,
             &pszObjectName,
             &_dwGroupResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now send back the current ovbject
    //

    hr = CNWCOMPATGroup::CreateGroup(
             _ADsPath,
             NWCOMPAT_COMPUTER_ID,
             _ComputerName,
             pszObjectName,
             _Credentials,
             ADS_OBJECT_BOUND,
             IID_IDispatch,
             (void **)ppDispatch
             );
    BAIL_ON_FAILURE(hr);

error:
    if (pszObjectName) {
        FreeADsStr(pszObjectName);
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumFileServices
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumFileServices(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetFileServiceObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::GetFileServiceObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::GetFileServiceObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // This is a NetWare provider specific condition.  Since a FileService
    // object on a bindery (computer) is the bindery itself, therefore there is
    // always one FileService object only.  And therefore this function is
    // called only once.
    //

    if (!_fFileServiceOnce) {

        _fFileServiceOnce = TRUE;

        //
        // Create a file service object with the Hard coded name.
        //

        hr = CNWCOMPATFileService::CreateFileService(
                 _ADsPath,
                 _ComputerName,
                 bstrNWFileServiceName,
                 _Credentials,
                 ADS_OBJECT_BOUND,
                 IID_IDispatch,
                 (void **)ppDispatch
                 );

        RRETURN_ENUM_STATUS(hr);
    }
    else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumPrinters
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumPrinters(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetPrinterObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::GetPrinterObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::GetPrinterObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPTSTR    pszObjectName;

    *ppDispatch = NULL;

    hr = NWApiObjectEnum(
             _hConn,
             OT_PRINT_QUEUE,
             &pszObjectName,
             &_dwPrinterResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now send back the current ovbject
    //

    hr = CNWCOMPATPrintQueue::CreatePrintQueue(
             _ADsPath,
             pszObjectName,
             _Credentials,
             ADS_OBJECT_BOUND,
             IID_IDispatch,
             (void **)ppDispatch
             );
    BAIL_ON_FAILURE(hr);

error:
    if (pszObjectName) {
        FreeADsStr(pszObjectName);
    }

    RRETURN_ENUM_STATUS(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATComputerEnum::Next
//
//  Synopsis:   Returns cElements number of requested ADs objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputerEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects(
             cElements,
             pvar,
             &cElementFetched
             );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    NW_RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cenumfs.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumfs.cxx
//
//  Contents:  NetWare 3.X Enumerator Code
//
//             CNWCOMPATFileServiceEnum::Create
//             CNWCOMPATFileServiceEnum::CNWCOMPATFileServiceEnum
//             CNWCOMPATFileServiceEnum::~CNWCOMPATFileServiceEnum
//             CNWCOMPATFileServiceEnum::Next
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileServiceEnum::Create
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileServiceEnum::Create(
    CNWCOMPATFileServiceEnum FAR* FAR* ppEnumVariant,
    BSTR ADsPath,
    BSTR bstrServerName,
    CCredentials &Credentials
    )
{
    HRESULT hr = S_OK;
    CNWCOMPATFileServiceEnum FAR* pEnumVariant = NULL;

    pEnumVariant = new CNWCOMPATFileServiceEnum();
    if (pEnumVariant == NULL){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Get a handle to the bindery (FileServer) that is going to be enumerated
    // on.
    //

    hr = NWApiGetBinderyHandle(
             &pEnumVariant->_hConn,
             bstrServerName,
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get FileServer VersionInfo.  The Version Info structure has the maximum
    // number of volumes.
    //

    hr = NWApiGetFileServerVersionInfo(
             pEnumVariant->_hConn,
             &pEnumVariant->_FileServerInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Save ADsPath.
    //

    hr = ADsAllocString(ADsPath, &pEnumVariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Save Credentials
    //
    pEnumVariant->_Credentials = Credentials;

    //
    // Return.
    //

    *ppEnumVariant = pEnumVariant;

    RRETURN(hr);

error:
    delete pEnumVariant;

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileServiceEnum::CNWCOMPATFileServiceEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileServiceEnum::CNWCOMPATFileServiceEnum():

    _ADsPath(NULL),
    _bResumeVolumeID(0),
    _hConn(NULL)
{
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileServiceEnum::~CNWCOMPATFileServiceEnum()
{
    if (_ADsPath)
        SysFreeString(_ADsPath);
    if (_hConn)
        NWApiReleaseBinderyHandle(_hConn);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileServiceEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumFileShares(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileServiceEnum::EnumFileShares
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileServiceEnum::EnumFileShares(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetFileShareObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    return(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileServiceEnum::GetFileShareObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileServiceEnum::GetFileShareObject(
    IDispatch ** ppDispatch
    )
{
    LPTSTR    pszObjectName = NULL;
    HRESULT hr = S_OK;

    *ppDispatch = NULL;

    //
    // Since Volume Number of defined Volume doesn't necessarily exist in
    // consecutive chunk, a loop is needed to skip all the "holes".
    //

    while (_bResumeVolumeID < _FileServerInfo.maxVolumes) {

        //
        // Get the name of the next Volume.
        //

        hr = NWApiGetVolumeName(
                 _hConn,
                 _bResumeVolumeID,
                 &pszObjectName
                 );
        BAIL_ON_FAILURE(hr);

        if (wcscmp(pszObjectName, L"")) {

            break;
        }
        else {

            _bResumeVolumeID++;
        }

        if (pszObjectName){
            FreeADsStr(pszObjectName);
            pszObjectName = NULL;
        }
    }


    //
    // Check if the last volume was reached already.
    //

    if (_bResumeVolumeID >= _FileServerInfo.maxVolumes) {
        RRETURN(S_FALSE);
    }

    //
    // Create a FileShare object.
    //

    hr = CNWCOMPATFileShare::CreateFileShare(
             _ADsPath,
             pszObjectName,
             _Credentials,
             ADS_OBJECT_BOUND,
             IID_IDispatch,
             (void **)ppDispatch
             );
    BAIL_ON_FAILURE(hr);

    //
    // Increase the current volume number.
    //

    _bResumeVolumeID++;

    //
    // Return.
    //

error:
    if (pszObjectName) {
       FreeADsStr(pszObjectName);
    }

    RRETURN_ENUM_STATUS(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cenumns.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumvar.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//             CNWCOMPATNamespaceEnum::Create
//             CNWCOMPATNamespaceEnum::CNWCOMPATNamespaceEnum
//             CNWCOMPATNamespaceEnum::~CNWCOMPATNamespaceEnum
//             CNWCOMPATNamespaceEnum::QueryInterface
//             CNWCOMPATNamespaceEnum::AddRef
//             CNWCOMPATNamespaceEnum::Release
//             CNWCOMPATNamespaceEnum::Next
//             CNWCOMPATNamespaceEnum::Skip
//             CNWCOMPATNamespaceEnum::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATNamespaceEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATNamespaceEnum::Create(
    CCredentials &Credentials,
    CNWCOMPATNamespaceEnum FAR* FAR* ppenumvariant
    )
{
    HRESULT hr = S_OK;
    CNWCOMPATNamespaceEnum FAR* penumvariant = NULL;

    penumvariant = new CNWCOMPATNamespaceEnum();

    if (penumvariant == NULL){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = NWApiGetAnyBinderyHandle(
             &penumvariant->_hConn
             );

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    if (penumvariant) {
        delete penumvariant;
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATNamespaceEnum::CNWCOMPATNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNWCOMPATNamespaceEnum::CNWCOMPATNamespaceEnum()
{
    _dwResumeObjectID = 0xffffffff;
    _hConn = NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATNamespaceEnum::~CNWCOMPATNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNWCOMPATNamespaceEnum::~CNWCOMPATNamespaceEnum()
{
    if (_hConn) {
        NWApiReleaseBinderyHandle(_hConn);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATNamespaceEnum::Next
//
//  Synopsis:   Returns cElements number of requested ADs objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATNamespaceEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumComputers(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATNamespaceEnum::EnumComputers
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CNWCOMPATNamespaceEnum::EnumComputers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetComputerObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATNamespaceEnum::GetComputerObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CNWCOMPATNamespaceEnum::GetComputerObject(
    IDispatch ** ppDispatch
    )
{
    LPWSTR    pszObjectName = NULL;
    HRESULT hr = S_OK;

    *ppDispatch = NULL;

    hr = NWApiObjectEnum(
             _hConn,
             OT_FILE_SERVER,
             &pszObjectName,
             &_dwResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now send back the current object
    //

    hr = CNWCOMPATComputer::CreateComputer(
                                L"NWCOMPAT:",  // BUGBUG - 1) Hardcoded.  2) Not NW312
                                pszObjectName,
                                _Credentials,
                                ADS_OBJECT_BOUND,
                                IID_IDispatch,
                                (void **)ppDispatch
                                );
    BAIL_ON_FAILURE(hr);

error:
    if (pszObjectName) {
       FreeADsStr(pszObjectName);
    }

    RRETURN_ENUM_STATUS(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\ccgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  ccgi.cxx
//
//  Contents:  This file contains the Computer Object's
//             GeneralInformation Functional Set.
//
//  History:   18-Jan-96     t-tpam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//
// Properties Get & Set
//

STDMETHODIMP CNWCOMPATComputer::get_ComputerID(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Site(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Description(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Description(THIS_ BSTR bstrDescription)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Location(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Location(THIS_ BSTR bstrLocation)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_PrimaryUser(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_PrimaryUser(THIS_ BSTR bstrPrimaryUser)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Owner(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Owner(THIS_ BSTR bstrOwner)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Division(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Division(THIS_ BSTR bstrDivision)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Department(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Department(THIS_ BSTR bstrDepartment)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Role(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Role(THIS_ BSTR bstrRole)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_OperatingSystem(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, OperatingSystem);
}

STDMETHODIMP CNWCOMPATComputer::put_OperatingSystem(THIS_ BSTR bstrOperatingSystem)
{
    //
    // BUGBUG - this should be changed to E_ADS_PROPERTY_NOT_SUPPORTED once it
    // is verified to be a read-only property.
    //

    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNWCOMPATComputer::get_OperatingSystemVersion(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, OperatingSystemVersion);
}

STDMETHODIMP CNWCOMPATComputer::put_OperatingSystemVersion(THIS_ BSTR bstrOperatingSystemVersion)
{
    //
    // BUGBUG - this should be changed to E_ADS_PROPERTY_NOT_SUPPORTED once it
    // is verified to be a read-only property.
    //

    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNWCOMPATComputer::get_Model(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Model(THIS_ BSTR bstrModel)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Processor(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Processor(THIS_ BSTR bstrProcessor)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_ProcessorCount(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_ProcessorCount(THIS_ BSTR bstrProcessorCount)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_MemorySize(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_MemorySize(THIS_ BSTR bstrMemorySize)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_StorageCapacity(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_StorageCapacity(THIS_ BSTR bstrStorageCapacity)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_NetAddresses(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsComputer *)this, Addresses);
}

STDMETHODIMP CNWCOMPATComputer::put_NetAddresses(THIS_ VARIANT vNetAddresses)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cenumgrp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  NetWare 3.12 GroupCollection Enumeration Code
//
//              CNWCOMPATGroupCollectionEnum::
//              CNWCOMPATGroupCollectionEnum::
//              CNWCOMPATGroupCollectionEnum::
//              CNWCOMPATGroupCollectionEnum::
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroupCollectionEnum::Create(
    CNWCOMPATGroupCollectionEnum FAR* FAR* ppenumvariant,
    BSTR Parent,
    ULONG ParentType,
    BSTR ADsPath,
    BSTR ServerName,
    BSTR GroupName,
    CCredentials &Credentials,
    VARIANT var
    )
{
    HRESULT hr = NOERROR;
    CNWCOMPATGroupCollectionEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CNWCOMPATGroupCollectionEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString(Parent, &penumvariant->_Parent);
    BAIL_ON_FAILURE(hr);

    penumvariant->_ParentType = ParentType;

    penumvariant->_Credentials = Credentials;

    hr = ADsAllocString( ServerName, &penumvariant->_ServerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( GroupName, &penumvariant->_GroupName);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
                    var,
                    &penumvariant->_pObjList
                    );
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroupCollectionEnum::CNWCOMPATGroupCollectionEnum():
        _Parent(NULL),
        _ParentType(0),
        _ADsPath(NULL),
        _ServerName(NULL),
        _GroupName(NULL),
        _hGroup(NULL)
{
    _pObjList = NULL;
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroupCollectionEnum::~CNWCOMPATGroupCollectionEnum()
{
    if (_pObjList)
        delete _pObjList;
    if (_Parent)
        SysFreeString(_Parent);
    if (_ADsPath)
        SysFreeString(_ADsPath);
    if (_ServerName)
        SysFreeString(_ServerName);
    if (_GroupName)
        SysFreeString(_GroupName);
    if (_hGroup)
        NWCOMPATComputerGroupClose(_hGroup);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroupCollectionEnum::EnumGroupMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetUserMemberObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroupCollectionEnum::GetUserMemberObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPCOMPUTER_GROUP_MEMBER pComputerGrpMember = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;


    if (!_hGroup) {
        dwRet = NWCOMPATComputerGroupOpen(
                    _ServerName,
                    _GroupName,
                    _Credentials,
                    &_hGroup
                    );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = NWCOMPATComputerGroupEnum(
                _hGroup,
                1,
                &pBuffer,
                &dwReturned
                );
    if (!dwRet) {
        goto error;
    }

    pComputerGrpMember = (LPCOMPUTER_GROUP_MEMBER)pBuffer;

    hr = CNWCOMPATUser::CreateUser(
                            pComputerGrpMember->Parent,
                            NWCOMPAT_COMPUTER_ID,
                            pComputerGrpMember->Computer,
                            pComputerGrpMember->Name,
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
    BAIL_ON_FAILURE(hr);

    hr = S_OK;

cleanup:

    if (pBuffer) {
        FreeADsMem(pBuffer);
    }

    RRETURN(hr);

error:
    *ppDispatch = NULL;

    hr = S_FALSE;

    goto cleanup;

}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATGroupCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGroupMembers(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    NW_RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\ccomp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  ccomp.cxx
//
//  Contents:
//
//  History:   11-1-96     t-ptam    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

DEFINE_IDispatch_Implementation(CNWCOMPATComputer)
DEFINE_IADs_TempImplementation(CNWCOMPATComputer)

DEFINE_IADs_PutGetImplementation(CNWCOMPATComputer, ComputerClass,gdwComputerTableSize)

DEFINE_IADsPropertyList_Implementation(CNWCOMPATComputer, ComputerClass, gdwComputerTableSize)


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::CNWCOMPATComputer
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATComputer::CNWCOMPATComputer():
                _pDispMgr(NULL),
                _pPropertyCache(NULL),
                _hConn(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CNWCOMPATComputer);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::~CNWCOMPATComputer
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATComputer::~CNWCOMPATComputer( )
{
    if (_pDispMgr)
       delete _pDispMgr;
    if (_pPropertyCache)
        delete _pPropertyCache;
    if (_hConn) {
       NWApiReleaseBinderyHandle(_hConn);
    }
    VariantClear(&_vFilter);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::CreateComputer
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::CreateComputer(
    BSTR bstrParent,
    BSTR bstrComputerName,
    CCredentials &Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATComputer FAR * pComputer = NULL;
    HRESULT hr = S_OK;

    hr = AllocateComputerObject(
             &pComputer
             );
    BAIL_ON_FAILURE(hr);

    hr = pComputer->InitializeCoreObject(
                        bstrParent,
                        bstrComputerName,
                        L"computer",
                        COMPUTER_SCHEMA_NAME,
                        CLSID_NWCOMPATComputer,
                        dwObjectState
                        );
    BAIL_ON_FAILURE(hr);

    pComputer->_Credentials = Credentials;

    hr = pComputer->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pComputer->Release();
    RRETURN(hr);

error:
    delete pComputer;
    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (!ppv) {
        RRETURN(E_POINTER);
    }

    //
    // Query.
    //

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsComputer))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
       *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsComputerOperations))
    {
        *ppv = (IADsComputerOperations FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CNWCOMPATComputer::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsComputer) ||
        IsEqualIID(riid, IID_IADsComputerOperations) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//
// IADsContainer methods
//

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::get_Count
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::get_Count(long FAR* retval)
{
    //
    // Too expensive to implement in term of computer execution time.
    //

    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::get_Filter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::put_Filter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    NW_RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNWCOMPATComputer::put_Hints(THIS_ VARIANT Var)
{
    NW_RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATComputer::get_Hints(THIS_ VARIANT FAR* pVar)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    WCHAR szBuffer[MAX_PATH];
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        NW_RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"/");
    wcscat(szBuffer, RelativeName);

    if (ClassName && *ClassName) {
        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                _Credentials,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::get__NewEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IEnumVARIANT * penum = NULL;

    if (!retval) {
        NW_RRETURN_EXP_IF_ERR(E_POINTER);
    }

    *retval = NULL;

    hr = CNWCOMPATComputerEnum::Create(
             (CNWCOMPATComputerEnum **)&penum,
             _ADsPath,
             _Name,
             _Credentials,
             _vFilter
             );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::Create
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    ULONG ObjectType = 0;
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;

    //
    // Translate ClassName into object type.
    //

    hr = GetObjectType(
              gpFilters,
              gdwMaxFilters,
              ClassName,
              (PDWORD)&ObjectType
              );
    BAIL_ON_FAILURE(hr);

    //
    // Build object info structure.
    //

    hr = BuildObjectInfo(
             _ADsPath,
             RelativeName,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);


    //
    // Create the object.
    //

    switch (ObjectType) {

    case NWCOMPAT_USER_ID:

         hr = CNWCOMPATUser::CreateUser(
                  _ADsPath,
                  NWCOMPAT_COMPUTER_ID,
                  _Name,
                  RelativeName,
                  _Credentials,
                  ADS_OBJECT_UNBOUND,
                  IID_IDispatch,
                  (void **)ppObject
                  );
         BAIL_ON_FAILURE(hr);

         break;

    case NWCOMPAT_GROUP_ID:

         hr = CNWCOMPATGroup::CreateGroup(
                  _ADsPath,
                  NWCOMPAT_COMPUTER_ID,
                  _Name,
                  RelativeName,
                  _Credentials,
                  ADS_OBJECT_UNBOUND,
                  IID_IDispatch,
                  (void **)ppObject
                  );
         BAIL_ON_FAILURE(hr);

         break;

    case NWCOMPAT_PRINTER_ID:

         hr = NWApiCreatePrinter(
                  pObjectInfo,
                  _Credentials
                  );
         BAIL_ON_FAILURE(hr);

         hr = CNWCOMPATPrintQueue::CreatePrintQueue(
                  _ADsPath,
                  pObjectInfo->ComponentArray[1],
                  _Credentials,
                  ADS_OBJECT_BOUND,
                  IID_IDispatch,
                  (void **)ppObject
                  );
         BAIL_ON_FAILURE(hr);

         break;

    default:

         hr = E_ADS_UNKNOWN_OBJECT;
         BAIL_ON_FAILURE(hr);
    }

error:
    FreeObjectInfo(pObjectInfo);
    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::Delete
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName)
{
    ULONG ObjectType = 0;

    POBJECTINFO pObjectInfo = NULL;
    HRESULT hr = S_OK;

    //
    // Translate ClassName into object type.
    //

    hr = GetObjectType(
             gpFilters,
             gdwMaxFilters,
             bstrClassName,
             (PDWORD)&ObjectType
             );
    BAIL_ON_FAILURE(hr);

    //
    // Build object info structure.
    //

    hr = BuildObjectInfo(
             _ADsPath,
             bstrRelativeName,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Delete the object.
    //

    switch (ObjectType) {

    case NWCOMPAT_USER_ID:

         hr = NWApiDeleteUser(
                  pObjectInfo,
                  _Credentials
                  );
         BAIL_ON_FAILURE(hr);

         break;

    case NWCOMPAT_GROUP_ID:

         hr = NWApiDeleteGroup(
                  pObjectInfo,
                  _Credentials
                  );
         BAIL_ON_FAILURE(hr);

         break;

    case NWCOMPAT_PRINTER_ID:

         hr = NWApiDeletePrinter(
                  pObjectInfo,
                  _Credentials
                  );
         BAIL_ON_FAILURE(hr);
         break;
  
    default:
  
         hr = E_ADS_UNKNOWN_OBJECT;
         BAIL_ON_FAILURE(hr);
    }

error:

    FreeObjectInfo(pObjectInfo);
    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::CopyHere
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::MoveHere
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{

    POBJECTINFO pObjectInfoSource = NULL;
    POBJECTINFO pObjectInfoTarget = NULL;

    NWCONN_HANDLE hConn = NULL;
    DWORD dwResumeId = 0xffffffff;
    BSTR pADsPathTarget = NULL;

    HRESULT hr = S_OK;

    // Bindery only supports renames, not moves
    if (!NewName)
        BAIL_ON_FAILURE(hr = E_NOTIMPL);

    //
    // Build object info structure.
    //

    hr = BuildObjectInfo(
             SourceName,
             &pObjectInfoSource
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildObjectInfo(
             _ADsPath,
             NewName,
             &pObjectInfoTarget
             );
    BAIL_ON_FAILURE(hr);

    // Can't rename to a child or parent, or to a different bindery
    if ( (pObjectInfoSource->NumComponents != 2) || (pObjectInfoTarget->NumComponents != 2) )
        BAIL_ON_FAILURE(hr = E_INVALIDARG);

    if (_wcsicmp(pObjectInfoSource->ComponentArray[0], pObjectInfoTarget->ComponentArray[0]))
        BAIL_ON_FAILURE(hr = E_INVALIDARG);

    //
    // Rename the object.  We need to know the object type, but this unfortunately isn't
    // passed to us, unlike Delete.  So we try to validate the object as each type until
    // we hit one that works.
    //

    hr = NWApiGetBinderyHandle(
                &hConn,
                pObjectInfoSource->ComponentArray[0],
                _Credentials);
    BAIL_ON_FAILURE(hr);

    // Netware wants the names uppercase
    _wcsupr(pObjectInfoSource->ComponentArray[1]);
    _wcsupr(pObjectInfoTarget->ComponentArray[1]);

    // Is object a User?
    hr = NWApiValidateObject(
            hConn,
            OT_USER,
            pObjectInfoSource->ComponentArray[1],
            &dwResumeId
            );
    
    if (SUCCEEDED(hr)) {
        
        hr = NWApiRenameObject(
                pObjectInfoSource,
                pObjectInfoTarget,
                OT_USER,
                _Credentials
                );
        BAIL_ON_FAILURE(hr);
    }
    else {
        
        // Is object a Group?
        hr = NWApiValidateObject(
                hConn,
                OT_USER_GROUP,
                pObjectInfoSource->ComponentArray[1],
                &dwResumeId
                );
        
        if (SUCCEEDED(hr)) {
            
            hr = NWApiRenameObject(
                    pObjectInfoSource,
                    pObjectInfoTarget,
                    OT_USER_GROUP,
                    _Credentials
                    );
            BAIL_ON_FAILURE(hr);
        }
        else {
            
            // Is object a Print Queue?
            hr = NWApiValidateObject(
                    hConn,
                    OT_PRINT_QUEUE,
                    pObjectInfoSource->ComponentArray[1],
                    &dwResumeId
                    );
                
            if (SUCCEEDED(hr)) {
                
                hr = NWApiRenameObject(
                        pObjectInfoSource,
                        pObjectInfoTarget,
                        OT_PRINT_QUEUE,
                        _Credentials
                        );
                BAIL_ON_FAILURE(hr);
            }
            else {

                // No such object, or not a type that we support
                hr = E_ADS_UNKNOWN_OBJECT;
                BAIL_ON_FAILURE(hr);
            }
        }
    }

    // get the IDispatch pointer
    if (ppObject) {
        hr = BuildADsPath(
                _ADsPath,
                NewName,
                &pADsPathTarget
                );
        BAIL_ON_FAILURE(hr);

        hr = ::GetObject(
                pADsPathTarget,
                _Credentials,
                (LPVOID *)ppObject
                );
        BAIL_ON_FAILURE(hr);
    }

error:

    if (pADsPathTarget)
        ADsFreeString(pADsPathTarget);

    NWApiReleaseBinderyHandle(hConn);

    FreeObjectInfo(pObjectInfoSource);
    FreeObjectInfo(pObjectInfoTarget);

    NW_RRETURN_EXP_IF_ERR(hr);
}

//
// IADs methods
//

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::SetInfo(THIS)
{
    //
    // BUGBUG - should this be changed to E_NOTSUPPORTED if it is verified that
    // no properties on this object can be set.
    //

    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::GetInfo(THIS)
{
    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(
                TRUE,
                COMP_WILD_CARD_ID
                ));
}


//
// IADsComputer methods
//


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::AllocateComputerObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::AllocateComputerObject(
    CNWCOMPATComputer ** ppComputer
    )
{
    CNWCOMPATComputer FAR * pComputer = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a computer object.
    //

    pComputer = new CNWCOMPATComputer();
    if (pComputer == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsComputer,
             (IADsComputer *)pComputer,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsContainer,
             (IADsContainer *)pComputer,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPropertyList,
             (IADsPropertyList *)pComputer,
             DISPID_VALUE
             );
    BAIL_ON_FAILURE(hr);


    //
    // Create property cache
    //

    hr = CPropertyCache::createpropertycache(
             ComputerClass,
             gdwComputerTableSize,
             (CCoreADsObject *)pComputer,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);

    pComputer->_pPropertyCache = pPropertyCache;
    pComputer->_pDispMgr = pDispMgr;
    *ppComputer = pComputer;

    RRETURN(hr);

error:

    //
    // Note: pComputer->_pPropertyCache & pComputer->_pDispMgr are NULL
    //

    if (pComputer)
        delete pComputer;
    if (pPropertyCache)
        delete pPropertyCache;
    if (pDispMgr)
        delete pDispMgr;
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::CreateObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::CreateObject(
    )
{
    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::GetInfo(
    BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    HRESULT       hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        NW_RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // Get a handle to the bindery this computer object represents,
    // if we haven't previously obtained one
    //

    if (!_hConn)
    {
        hr = NWApiGetBinderyHandle(
            &_hConn,
            _Name,
            _Credentials
            );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Fill in all property caches with values - explicit, or return the
    // indicated property - implicit.
    //

    if (fExplicit) {
       hr = ExplicitGetInfo(_hConn, fExplicit);
       BAIL_ON_FAILURE(hr);
    }
    else {
       hr = ImplicitGetInfo(_hConn, dwPropertyID, fExplicit);
       BAIL_ON_FAILURE(hr);
    }

error:

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::ExplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::ExplicitGetInfo(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    hr = GetProperty_Addresses(hConn, fExplicit);
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        // not a real failure, we ignore it and treat it as a missing attrib
        hr = S_OK;
    }
    BAIL_ON_FAILURE(hr);

    hr = GetProperty_OperatingSystem(fExplicit);
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        // not a real failure, we ignore it and treat it as a missing attrib
        hr = S_OK;
    }
    BAIL_ON_FAILURE(hr);

    hr = GetProperty_OperatingSystemVersion(hConn, fExplicit);
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        // not a real failure, we ignore it and treat it as a missing attrib
        hr = S_OK;
    }
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::ImplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::ImplicitGetInfo(
    NWCONN_HANDLE hConn,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    switch (dwPropertyID) {

    case COMP_ADDRESSES_ID:
         hr = GetProperty_Addresses(hConn, fExplicit);
         break;

    case COMP_OPERATINGSYSTEM_ID:
         hr = GetProperty_OperatingSystem(fExplicit);
         break;

    case COMP_OPERATINGSYSTEMVERSION_ID:
         hr = GetProperty_OperatingSystemVersion(hConn, fExplicit);
         break;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetProperty_Addresses
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::GetProperty_Addresses(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    BSTR             bstrBuffer = NULL;
    DWORD            dwNumSegment;
    HRESULT          hr = S_OK;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL; // Used by DELETE_LIST macro below
    LPWSTR           lpszBuffer = NULL;
    VARIANT          vData;

    //
    // Get ADDRESSES.
    //

    hr = NWApiGetProperty(
             _Name,
             NW_PROP_NET_ADDRESS,
             OT_FILE_SERVER,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );
    BAIL_ON_FAILURE(hr);

    //
    // Put the addresses obtained in the format described in spec.
    //

    hr = NWApiConvertToAddressFormat(
             lpReplySegment,
             &lpszBuffer
             );
    BAIL_ON_FAILURE(hr);

    bstrBuffer = SysAllocString(lpszBuffer);
    if (!bstrBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // BUGBUG - for now, Addresses is treated as a BSTR Variant instead of a
    //          variant array of bstr, as described in the spec.
    //

    VariantInit(&vData);
    V_VT(&vData) = VT_BSTR;
    V_BSTR(&vData) = bstrBuffer;

    //
    // Unmarshall.
    //

    //
    // BugBug - KrishnaG figure out how we're going to map this property
    //


    //
    // UM_PUT_VARIANT_PROPERTY(vData, _pGenInfo, Addresses, FALSE);
    //

    VariantClear(&vData);

error:
    if (lpReplySegment) {
       DELETE_LIST(lpReplySegment);
    }
    if (lpszBuffer) {
       FreeADsMem(lpszBuffer);
    }
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetProperty_OperatingSystem
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::GetProperty_OperatingSystem(
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    //
    // BUGBUG - bstrComputerOperatingSystem is HARDCODED.
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("OperatingSystem"),
                bstrComputerOperatingSystem,
                fExplicit
                );
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetProperty_OperatingSystemVersion
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::GetProperty_OperatingSystemVersion(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    LPWSTR      pszBuffer = NULL;
    CHAR         ch;
    HRESULT      hr = S_OK;
    NW_VERSION_INFO VersionInfo;

    //
    // Get Version Information of a bindery.
    //

    hr = NWApiGetFileServerVersionInfo(
                hConn,
                &VersionInfo
                );
    BAIL_ON_FAILURE(hr);

    //
    // Put Version & SubVersion in X.X format.
    //

    pszBuffer = (LPWSTR) AllocADsMem(
                              (OS_VERSION_NUM_CHAR+1) * sizeof(WCHAR)
                              );
    if (!pszBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    wsprintf(
        pszBuffer,
        L"%i.%02i",
        (WORD) VersionInfo.Version,
        (WORD) VersionInfo.SubVersion
        );

    //
    // Unmarshall.
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("OperatingSystemVersion"),
                pszBuffer,
                fExplicit
                );

error:
    if (pszBuffer) {
        FreeADsMem(pszBuffer);
    }

    RRETURN(hr);
}



STDMETHODIMP
CNWCOMPATComputer::Status(
    IDispatch * FAR * ppObject
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATComputer::Shutdown(
    VARIANT_BOOL bReboot
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cfshgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cfshgi.cxx
//
//  Contents:  This file contains the FileShare Object's GeneralInformation
//             Functional Set.
//
//  History:   25-Apr-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
// Macro-ized implementation.
//


STDMETHODIMP
CNWCOMPATFileShare::get_CurrentUserCount(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileShare *)this, CurrentUserCount);
}

STDMETHODIMP
CNWCOMPATFileShare::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileShare *)this, Description);
}

STDMETHODIMP
CNWCOMPATFileShare::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsFileShare *)this, Description);
}

STDMETHODIMP
CNWCOMPATFileShare::get_HostComputer(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileShare *)this, HostComputer);
}

STDMETHODIMP
CNWCOMPATFileShare::put_HostComputer(THIS_ BSTR bstrHostComputer)
{
    PUT_PROPERTY_BSTR((IADsFileShare *)this, HostComputer);
}

STDMETHODIMP
CNWCOMPATFileShare::get_Path(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileShare *)this, Path);
}

STDMETHODIMP
CNWCOMPATFileShare::put_Path(THIS_ BSTR bstrPath)
{
    PUT_PROPERTY_BSTR((IADsFileShare *)this, Path);
}

STDMETHODIMP
CNWCOMPATFileShare::get_MaxUserCount(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileShare *)this, MaxUserCount);
}

STDMETHODIMP
CNWCOMPATFileShare::put_MaxUserCount(THIS_ LONG lMaxUserCount)
{
    PUT_PROPERTY_LONG((IADsFileShare *)this, MaxUserCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cenumvar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumvar.cxx
//
//  Contents:  NetWare 3.12 Enumerator Code
//
//             CNWCOMPATEnumVariant::Create
//             CNWCOMPATEnumVariant::CNWCOMPATEnumVariant
//             CNWCOMPATEnumVariant::~CNWCOMPATEnumVariant
//             CNWCOMPATEnumVariant::QueryInterface
//             CNWCOMPATEnumVariant::AddRef
//             CNWCOMPATEnumVariant::Release
//             CNWCOMPATEnumVariant::Next
//             CNWCOMPATEnumVariant::Skip
//             CNWCOMPATEnumVariant::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::CNWCOMPATEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNWCOMPATEnumVariant::CNWCOMPATEnumVariant()
{
    //
    // Set the reference count on the enumerator.
    //
    m_cRef = 1;

}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::~CNWCOMPATEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNWCOMPATEnumVariant::~CNWCOMPATEnumVariant()
{
    //
    // Bump down the reference count on the Collection object
    //
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CNWCOMPATEnumVariant::AddRef(void)
{

    return ++m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Release
//
//  Synopsis:
//
//
//  Arguments:  [void]
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CNWCOMPATEnumVariant::Release(void)
{


    if(--m_cRef == 0){

        delete this;
        return 0;
    }

    return m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATEnumVariant::Skip(ULONG cElements)
{

    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATEnumVariant::Reset()
{

    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cfserv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfserv.cxx
//
//  Contents:
//
//  History:   April 19, 1996     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma hdrstop

//
// Marco-ized Implementation.
//

DEFINE_IDispatch_Implementation(CNWCOMPATFileService);

DEFINE_IADs_TempImplementation(CNWCOMPATFileService);

DEFINE_IADs_PutGetImplementation(CNWCOMPATFileService, FileServiceClass,gdwFileServiceTableSize);

DEFINE_IADsPropertyList_Implementation(CNWCOMPATFileService, FileServiceClass, gdwFileServiceTableSize);

//
// class CNWCOMPATFileService methods
//

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::CNWCOMPATFileService
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileService::CNWCOMPATFileService():
    _pDispMgr(NULL),
    _ServerName(NULL),
    _pPropertyCache(NULL),
    _hConn(NULL)
{
    ENLIST_TRACKING(CNWCOMPATFileService);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::~CNWCOMPATFileService
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileService::~CNWCOMPATFileService()
{
    delete _pDispMgr;

    ADSFREESTRING(_ServerName);

    delete _pPropertyCache;

    if (_hConn)
        NWApiReleaseBinderyHandle(_hConn);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::CreateFileService
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::CreateFileService(
    LPTSTR pszADsParent,
    LPTSTR pszServerName,
    LPTSTR pszFileServiceName,
    CCredentials &Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )

{
    CNWCOMPATFileService FAR * pFileService = NULL;
    HRESULT hr = S_OK;

    hr = AllocateFileServiceObject(
             &pFileService
             );
    BAIL_ON_FAILURE(hr);

    hr = pFileService->InitializeCoreObject(
                           pszADsParent,
                           pszFileServiceName,
                           TEXT("FileService"),
                           FILESERVICE_SCHEMA_NAME,
                           CLSID_NWCOMPATFileService,
                           dwObjectState
                           );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pszServerName , &pFileService->_ServerName);
    BAIL_ON_FAILURE(hr);

    pFileService->_Credentials = Credentials;

    //
    // Get a handle to the bindery this computer object represents.
    //

    hr = NWApiGetBinderyHandle(
             &pFileService->_hConn,
             pFileService->_ServerName,
             pFileService->_Credentials
             );
    BAIL_ON_FAILURE(hr);


    hr = pFileService->QueryInterface(
                           riid,
                           ppvObj
                           );
    BAIL_ON_FAILURE(hr);

    pFileService->Release();

    RRETURN(hr);

error:

    delete pFileService;
    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::AllocateFileServiceObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::AllocateFileServiceObject(
    CNWCOMPATFileService ** ppFileService
    )
{
    CDispatchMgr FAR *pDispMgr = NULL;
    CNWCOMPATFileService FAR *pFileService = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a FileService object.
    //

    pFileService = new CNWCOMPATFileService();
    if (pFileService == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsFileService,
             (IADsFileService *)pFileService,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsFileServiceOperations,
             (IADsFileServiceOperations *)pFileService,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsContainer,
             (IADsContainer *)pFileService,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPropertyList,
             (IADsPropertyList *)pFileService,
             DISPID_VALUE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    hr = CPropertyCache::createpropertycache(
             FileServiceClass,
             gdwFileServiceTableSize,
             (CCoreADsObject *)pFileService,
             &(pFileService->_pPropertyCache)
             );

    BAIL_ON_FAILURE(hr);


    pFileService->_pDispMgr = pDispMgr;
    *ppFileService = pFileService;

    RRETURN(hr);

error:
    delete pDispMgr;
    delete pFileService;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::QueryInterface(
    REFIID riid,
    LPVOID FAR* ppvObj
    )
{
    if (ppvObj == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsService)) {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsFileService))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsServiceOperations))
    {
        *ppvObj = (IADsFileServiceOperations FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IADsFileServiceOperations))
    {
        *ppvObj = (IADsFileServiceOperations FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IADsContainer))
    {
        *ppvObj = (IADsContainer FAR *) this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

//
// ISupportErrorInfo method 
//
STDMETHODIMP
CNWCOMPATFileService::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsService) ||
        IsEqualIID(riid, IID_IADsServiceOperations) ||
        IsEqualIID(riid, IID_IADsFileService) ||
        IsEqualIID(riid, IID_IADsFileServiceOperations) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::get_Count
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::get_Count(long FAR* retval)
{
    //
    // Too expensive to implement in term of computer execution time.
    //

    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::get_Filter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::get_Filter(THIS_ VARIANT FAR* pVar)
{
    //
    // BUGBUG - Filter doesn't make sense on a FileService container.  Since it
    //          can only contain FileShares.  Am I right?
    //

    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::put_Filter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::put_Filter(THIS_ VARIANT Var)
{
    //
    // BUGBUG - Filter doesn't make sense on a FileService container.  Since it
    //          can only contain FileShares.  Am I right?
    //

    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATFileService::put_Hints(THIS_ VARIANT Var)
{
    NW_RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATFileService::get_Hints(THIS_ VARIANT FAR* pVar)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::GetObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    //
    // Will be implemented by Krishna on the WinNT side and be cloned
    // by me afterward.
    //

    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::get__NewEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr = S_OK;
    IEnumVARIANT * pEnum = NULL;

    *retval = NULL;

    hr = CNWCOMPATFileServiceEnum::Create(
             (CNWCOMPATFileServiceEnum **) &pEnum,
             _ADsPath,
             _ServerName,
             _Credentials
             );
    BAIL_ON_FAILURE(hr);

    hr = pEnum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*) retval
                    );
    BAIL_ON_FAILURE(hr);

    if (pEnum) {
        pEnum->Release();
    }

    RRETURN(NOERROR);

error:

    delete pEnum;

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Create
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Delete
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::CopyHere
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::MoveHere
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::SetInfo(THIS)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::GetInfo(THIS)
{

    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(
                TRUE,
                FSERV_WILD_CARD_ID
                ));
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::GetInfo(
    THIS_ BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    HRESULT       hr = S_OK;
    POBJECTINFO   pObjectInfo = NULL;

    //
    // Make sure the object is bound to a tangible resource.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        NW_RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // Componentize ADs name.
    //

    hr = BuildObjectInfo(
             _Parent,
             _Name,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);


    //
    // Fill in all property caches with values - explicit, or return the
    // indicated property - implicit.
    //

    if (fExplicit) {
       hr = ExplicitGetInfo(
                _hConn,
                pObjectInfo,
                fExplicit
                );
       BAIL_ON_FAILURE(hr);
    }
    else {
       hr = ImplicitGetInfo(
                _hConn,
                pObjectInfo,
                dwPropertyID,
                fExplicit
                );
       BAIL_ON_FAILURE(hr);
    }

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::ExplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::ExplicitGetInfo(
    NWCONN_HANDLE hConn,
    POBJECTINFO pObjectInfo,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    //
    // Get GeneralInfo.
    //

    hr = GetProperty_MaxUserCount(
             hConn,
             fExplicit
             );
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        // not a real failure, we ignore it and treat it as a missing attrib
        hr = S_OK;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Get Configuration.
    //

    hr = GetProperty_HostComputer(
             pObjectInfo,
             fExplicit
             );
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        // not a real failure, we ignore it and treat it as a missing attrib
        hr = S_OK;
    }
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::ImplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::ImplicitGetInfo(
    NWCONN_HANDLE hConn,
    POBJECTINFO pObjectInfo,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    switch (dwPropertyID) {

    case FSERV_MAXUSERCOUNT_ID:
         hr = GetProperty_MaxUserCount(
                  hConn,
                  fExplicit
                  );
         break;

    case FSERV_HOSTCOMPUTER_ID:
         hr = GetProperty_HostComputer(
                  pObjectInfo,
                  fExplicit
                  );
         break;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::GetProperty_MaxUserCount
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::GetProperty_MaxUserCount(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    DWORD    dwTemp = 0;
    NW_VERSION_INFO VersionInfo;

    //
    // Get the Maximum number of connections supported from the Version
    // Information of the FileServer.
    //

    hr = NWApiGetFileServerVersionInfo(
             hConn,
             &VersionInfo
             );
    BAIL_ON_FAILURE(hr);

    dwTemp = VersionInfo.ConnsSupported;

    //
    // Unmarshall.
    //

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("MaxUserCount"),
                                 (DWORD)dwTemp,
                                 fExplicit
                                 );


    //
    // Return.
    //

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::GetProperty_HostComputer
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::GetProperty_HostComputer(
    POBJECTINFO pObjectInfo,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    WCHAR szBuffer[MAX_PATH];

    //
    // Build ADs path of Host computer from ObjectInfo.
    //

    wsprintf(
        szBuffer,
        L"%s://%s",
        pObjectInfo->ProviderName,
        pObjectInfo->ComponentArray[0]
        );

    //
    // Unmarshall
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("HostComputer"),
                szBuffer,
                fExplicit
                );

    //
    // Return.
    //

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cfsctrl.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfsvctrl.cxx
//
//  Contents:
//
//  History:   April 19, 1996     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Start
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Start(THIS)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Stop
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Stop(THIS)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Pause
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Pause(THIS)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Continue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Continue(THIS)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Status
//
//  Synopsis:
//
//----------------------------------------------------------------------------
/*STDMETHODIMP
CNWCOMPATFileService::get_Status(
    THIS_ long FAR* plStatus
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
} */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cfsconf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfsvconf.cxx
//
//  Contents:
//
//  History:   April 19, 1996     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::SetPassword
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::SetPassword(
    THIS_ BSTR bstrNewPassword
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//
// Properties Get & Set.
//

STDMETHODIMP
CNWCOMPATFileService::get_HostComputer(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, HostComputer);
}

STDMETHODIMP
CNWCOMPATFileService::put_HostComputer(THIS_ BSTR bstrHostComputer)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, HostComputer);
}

STDMETHODIMP
CNWCOMPATFileService::get_DisplayName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, DisplayName);
}

STDMETHODIMP
CNWCOMPATFileService::put_DisplayName(THIS_ BSTR bstrDisplayName)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, DisplayName);
}

STDMETHODIMP
CNWCOMPATFileService::get_Version(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, Version);
}

STDMETHODIMP
CNWCOMPATFileService::put_Version(THIS_ BSTR bstrVersion)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, Version);
}

STDMETHODIMP
CNWCOMPATFileService::get_ServiceType(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileService *)this, ServiceType);
}

STDMETHODIMP
CNWCOMPATFileService::put_ServiceType(THIS_ long lServiceType)
{
    PUT_PROPERTY_LONG((IADsFileService *)this, ServiceType);
}

STDMETHODIMP
CNWCOMPATFileService::get_StartType(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileService *)this, StartType);
}

STDMETHODIMP
CNWCOMPATFileService::put_StartType(THIS_ LONG lStartType)
{
    PUT_PROPERTY_LONG((IADsFileService *)this, StartType);
}

STDMETHODIMP
CNWCOMPATFileService::get_Path(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, Path);
}

STDMETHODIMP
CNWCOMPATFileService::put_Path(THIS_ BSTR bstrPath)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, Path);
}

STDMETHODIMP
CNWCOMPATFileService::get_StartupParameters(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, StartupParameters);
}

STDMETHODIMP
CNWCOMPATFileService::put_StartupParameters(THIS_ BSTR bstrStartupParameters)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, StartupParameters);
}

STDMETHODIMP
CNWCOMPATFileService::get_ErrorControl(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileService *)this, ErrorControl);
}

STDMETHODIMP
CNWCOMPATFileService::put_ErrorControl(THIS_ LONG lErrorControl)
{
    PUT_PROPERTY_LONG((IADsFileService *)this, ErrorControl);
}

STDMETHODIMP
CNWCOMPATFileService::get_LoadOrderGroup(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, LoadOrderGroup);
}

STDMETHODIMP
CNWCOMPATFileService::put_LoadOrderGroup(THIS_ BSTR bstrLoadOrderGroup)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, LoadOrderGroup);
}

STDMETHODIMP
CNWCOMPATFileService::get_ServiceAccountName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, ServiceAccountName);
}

STDMETHODIMP
CNWCOMPATFileService::put_ServiceAccountName(THIS_ BSTR bstrServiceAccountName)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, ServiceAccountName);
}

STDMETHODIMP
CNWCOMPATFileService::get_ServiceAccountPath(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, ServiceAccountPath);
}

STDMETHODIMP
CNWCOMPATFileService::put_ServiceAccountPath(THIS_ BSTR bstrServiceAccountPath)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, ServiceAccountPath);
}

STDMETHODIMP
CNWCOMPATFileService::get_Dependencies(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsFileService *)this, Dependencies);
}

STDMETHODIMP
CNWCOMPATFileService::put_Dependencies(THIS_ VARIANT vDependencies)
{
    PUT_PROPERTY_VARIANT((IADsFileService *)this, Dependencies);
}

STDMETHODIMP
CNWCOMPATFileService::get_Status(THIS_ long FAR* plStatusCode)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cfsgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfsvgeni.cxx
//
//  Contents:
//
//  History:   April 19, 1996     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop

//
// Properties Get & Set.
//

STDMETHODIMP
CNWCOMPATFileService::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, Description);
}

STDMETHODIMP
CNWCOMPATFileService::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, Description);
}

STDMETHODIMP
CNWCOMPATFileService::get_MaxUserCount(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileService *)this, MaxUserCount);
}

STDMETHODIMP
CNWCOMPATFileService::put_MaxUserCount(THIS_ long lMaxUserCount)
{
    PUT_PROPERTY_LONG((IADsFileService *)this, MaxUserCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cenumusr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  NetWare 3.12 GroupCollection Enumeration Code
//
//              CNWCOMPATUserCollectionEnum::
//              CNWCOMPATUserCollectionEnum::
//              CNWCOMPATUserCollectionEnum::
//              CNWCOMPATUserCollectionEnum::
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUserCollectionEnum::Create(
    CNWCOMPATUserCollectionEnum FAR* FAR* ppenumvariant,
    BSTR Parent,
    ULONG ParentType,
    BSTR ADsPath,
    BSTR ServerName,
    BSTR UserName,
    CCredentials &Credentials,
    VARIANT var
    )
{
    HRESULT hr = NOERROR;
    CNWCOMPATUserCollectionEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CNWCOMPATUserCollectionEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( Parent , &penumvariant->_Parent);
    BAIL_ON_FAILURE(hr);

    penumvariant->_ParentType = ParentType;
    penumvariant->_Credentials = Credentials;

    hr = ADsAllocString(ServerName , &penumvariant->_ServerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( UserName , &penumvariant->_UserName);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( ADsPath , &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
                    var,
                    &penumvariant->_pObjList
                    );
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUserCollectionEnum::CNWCOMPATUserCollectionEnum():
        _Parent(NULL),
        _ParentType(0),
        _ADsPath(NULL),
        _ServerName(NULL),
        _UserName(NULL),
        _hUser(NULL)
{
    _pObjList = NULL;
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUserCollectionEnum::~CNWCOMPATUserCollectionEnum()
{
    if (_pObjList)
        delete _pObjList;
    if (_Parent)
        SysFreeString(_Parent);
    if (_ADsPath)
        SysFreeString(_ADsPath);
    if (_ServerName)
        SysFreeString(_ServerName);
    if (_UserName)
        SysFreeString(_UserName);
    if (_hUser)
        NWCOMPATComputerUserClose(_hUser);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUserCollectionEnum::EnumGroupMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetUserMemberObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUserCollectionEnum::GetUserMemberObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPUSER_GROUP_ENTRY pComputerGrpMember = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;


    if (!_hUser) {
        dwRet = NWCOMPATComputerUserOpen(
                    _ServerName,
                    _UserName,
                    _Credentials,
                    &_hUser
                    );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = NWCOMPATComputerUserEnum(
                _hUser,
                1,
                &pBuffer,
                &dwReturned
                );
    if (!dwRet) {
        goto error;
    }

    pComputerGrpMember = (LPUSER_GROUP_ENTRY)pBuffer;

    hr = CNWCOMPATGroup::CreateGroup(
                            pComputerGrpMember->Parent,
                            NWCOMPAT_COMPUTER_ID,
                            pComputerGrpMember->Computer,
                            pComputerGrpMember->Name,
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
    BAIL_ON_FAILURE(hr);

    RRETURN(S_OK);

error:
    *ppDispatch = NULL;

    RRETURN(S_FALSE);

}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATUserCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGroupMembers(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    NW_RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cfshare.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:  cfshare.cxx
//
//  Contents:  CNWCOMPATFileShare
//
//
//  History:   25-Apr-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

//
// Macro-ized implementation.
//

DEFINE_IDispatch_Implementation(CNWCOMPATFileShare);

DEFINE_IADs_TempImplementation(CNWCOMPATFileShare);

DEFINE_IADs_PutGetImplementation(CNWCOMPATFileShare, FileShareClass, gdwFileShareTableSize)

DEFINE_IADsPropertyList_Implementation(CNWCOMPATFileShare, FileShareClass, gdwFileShareTableSize)



//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::CNWCOMPATFileShare
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileShare::CNWCOMPATFileShare():
    _pDispMgr(NULL),
    _pPropertyCache(NULL),
    _hConn(NULL)
{
    ENLIST_TRACKING(CNWCOMPATFileShare);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileShare::~CNWCOMPATFileShare()
{
    delete _pDispMgr;

    delete _pPropertyCache;

    if (_hConn)
        NWApiReleaseBinderyHandle(_hConn);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::CreateFileShare
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::CreateFileShare(
    LPTSTR pszADsParent,
    LPTSTR pszShareName,
    CCredentials &Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    LPVOID * ppvoid
    )
{
    CNWCOMPATFileShare FAR * pFileShare = NULL;
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;

    //
    // Allocate memory for a FileShare object.
    //

    hr = AllocateFileShareObject(
             &pFileShare
             );
    BAIL_ON_FAILURE(hr);

    //
    // Initialize its core object.
    //

    hr = pFileShare->InitializeCoreObject(
                         pszADsParent,
                         pszShareName,
                         FILESHARE_CLASS_NAME,
                         FILESHARE_SCHEMA_NAME,
                         CLSID_NWCOMPATFileShare,
                         dwObjectState
                         );
    BAIL_ON_FAILURE(hr);

    //
    // Credentials
    //
    pFileShare->_Credentials = Credentials;

    //
    // Componentize ADs name.
    //

    hr = BuildObjectInfo(
             pFileShare->_Parent,
             pFileShare->_Name,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get a handle to the bindery this computer object represents.
    //

    hr = NWApiGetBinderyHandle(
             &pFileShare->_hConn,
             pObjectInfo->ComponentArray[0],
             pFileShare->_Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get interface pointer.
    //

    hr = pFileShare->QueryInterface(
                         riid,
                         (void **)ppvoid
                         );
    BAIL_ON_FAILURE(hr);

    pFileShare->Release();

    FreeObjectInfo(pObjectInfo);

    //
    // Return.
    //

    RRETURN(hr);

error:

    if (pObjectInfo)
        FreeObjectInfo(pObjectInfo);

    delete pFileShare;
    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileShare::QueryInterface(
    REFIID riid,
    LPVOID FAR* ppvObj
    )
{
    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsFileShare *) this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADs FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsFileShare))
    {
        *ppvObj = (IADsFileShare FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CNWCOMPATFileShare::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsFileShare) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileShare::SetInfo(THIS)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileShare::GetInfo(THIS)
{
    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(
                TRUE,
                FSHARE_WILD_CARD_ID
                ));
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::AllocateFileShareObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::AllocateFileShareObject(
    CNWCOMPATFileShare **ppFileShare
    )
{
    CNWCOMPATFileShare FAR * pFileShare = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a FileShare object.
    //

    pFileShare = new CNWCOMPATFileShare();
    if (pFileShare == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CDispatchMgr;
    if(pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // Load type info.
    //

    hr =  LoadTypeInfoEntry(
              pDispMgr,
              LIBID_ADs,
              IID_IADsFileShare,
              (IADsFileShare *)pFileShare,
              DISPID_REGULAR
              );
    BAIL_ON_FAILURE(hr);

    hr =  LoadTypeInfoEntry(
              pDispMgr,
              LIBID_ADs,
              IID_IADsPropertyList,
              (IADsPropertyList *)pFileShare,
              DISPID_VALUE
              );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             FileShareClass,
             gdwFileShareTableSize,
             (CCoreADsObject *)pFileShare,
             &(pFileShare ->_pPropertyCache)
             );

    BAIL_ON_FAILURE(hr);

    pFileShare->_pDispMgr = pDispMgr;
    *ppFileShare = pFileShare;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pFileShare;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileShare::GetInfo(
    BOOL fExplicit,
    THIS_ DWORD dwPropertyID
    )
{
    HRESULT       hr = S_OK;
    POBJECTINFO   pObjectInfo = NULL;

    //
    // Make sure the object is bound to a tangible resource.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        NW_RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // Componentize ADs name.
    //

    hr = BuildObjectInfo(
             _Parent,
             _Name,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);


    //
    // Fill in all property caches with values - explicit, or return the
    // indicated property - implicit.
    //

    if (fExplicit) {
       hr = ExplicitGetInfo(
                _hConn,
                pObjectInfo,
                fExplicit
                );
       BAIL_ON_FAILURE(hr);
    }
    else {
       hr = ImplicitGetInfo(
                _hConn,
                pObjectInfo,
                dwPropertyID,
                fExplicit
                );
       BAIL_ON_FAILURE(hr);
    }

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::ExplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::ExplicitGetInfo(
    NWCONN_HANDLE hConn,
    POBJECTINFO pObjectInfo,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    hr = GetProperty_Description(
            fExplicit
            );
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        // not a real failure, we ignore it and treat it as a missing attrib
        hr = S_OK;
    }
    BAIL_ON_FAILURE(hr);

    hr = GetProperty_HostComputer(
             pObjectInfo,
             fExplicit
             );
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        // not a real failure, we ignore it and treat it as a missing attrib
        hr = S_OK;
    }
    BAIL_ON_FAILURE(hr);

    hr = GetProperty_MaxUserCount(
             hConn,
             fExplicit
             );
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        // not a real failure, we ignore it and treat it as a missing attrib
        hr = S_OK;
    }
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::ImplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::ImplicitGetInfo(
    NWCONN_HANDLE hConn,
    POBJECTINFO pObjectInfo,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    switch (dwPropertyID) {

    case FSHARE_DESCRIPTION_ID:
         hr = GetProperty_Description(
                    fExplicit
                    );
         break;

    case FSHARE_HOSTCOMPUTER_ID:
         hr = GetProperty_HostComputer(
                  pObjectInfo,
                  fExplicit
                  );
         break;

    case FSHARE_MAXUSERCOUNT_ID:
         hr = GetProperty_MaxUserCount(
                  hConn,
                  fExplicit
                  );
         break;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::GetProperty_Description
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::GetProperty_Description(
    BOOL fExplicit
)
{
    HRESULT hr = S_OK;

    //
    // BUGBUG - bstrFileShareDescription is HARDCODED.
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Description"),
                bstrFileShareDescription,
                fExplicit
                );


    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::GetProperty_HostComputer
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::GetProperty_HostComputer(
    POBJECTINFO pObjectInfo,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    WCHAR szBuffer[MAX_PATH];

    //
    // Build ADs path of Host computer from ObjectInfo.
    //

    wsprintf(
        szBuffer,
        L"%s://%s",
        pObjectInfo->ProviderName,
        pObjectInfo->ComponentArray[0]
        );

    //
    // Unmarshall
    //

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("HostComputer"),
                                  szBuffer,
                                  fExplicit
                                  );

    //
    // Return.
    //

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::GetProperty_MaxUserCount
//
//  Synopsis: Note that the Max Number of Connections Supported of the
//            FileServer is used.  In NetWare, there isn't a per share max valu.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::GetProperty_MaxUserCount(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    DWORD     dwTemp = 0;
    NW_VERSION_INFO VersionInfo;

    //
    // Get the Maximum number of connections supported from the Version
    // Information of the FileServer.
    //

    hr = NWApiGetFileServerVersionInfo(
             hConn,
             &VersionInfo
             );
    BAIL_ON_FAILURE(hr);

    dwTemp =  VersionInfo.ConnsSupported;

    //
    // Unmarshall.
    //

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("MaxUserCount"),
                                 dwTemp,
                                 fExplicit
                                 );

    //
    // Return.
    //

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cfsop.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfsvopr.cxx
//
//  Contents:
//
//  History:   April 19, 1996     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Sessions
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Sessions(
    THIS_ IADsCollection FAR* FAR* ppSessions
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Resources
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Resources(
    THIS_ IADsCollection FAR* FAR* ppResources
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cjobgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cjobgi.cxx
//
//  Contents:
//
//  History:   1-May-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
// Macro-ized implementation.
//

//
// Properties Get & Set.
//

STDMETHODIMP
CNWCOMPATPrintJob::get_HostPrintQueue(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, HostPrintQueue);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_User(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, User);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_TimeSubmitted(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintJob *)this, TimeSubmitted);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_TotalPages(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, TotalPages);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_Size(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, Size);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_Description(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_Description(THIS_ BSTR bstrDescription)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_Priority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, Priority);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_Priority(THIS_ LONG lPriority)
{
    PUT_PROPERTY_LONG((IADsPrintJob *)this, Priority);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_StartTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintJob *)this, StartTime);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_StartTime(THIS_ DATE daStartTime)
{
    PUT_PROPERTY_DATE((IADsPrintJob *)this, StartTime);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_UntilTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintJob *)this, UntilTime);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_UntilTime(THIS_ DATE daUntilTime)
{
    PUT_PROPERTY_DATE((IADsPrintJob *)this, UntilTime);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_Notify(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, Notify);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_Notify(THIS_ BSTR bstrNotify)
{
    PUT_PROPERTY_BSTR((IADsPrintJob *)this, Notify);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_NotifyPath(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, NotifyPath);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_NotifyPath(THIS_ BSTR bstrNotifyPath)
{
    PUT_PROPERTY_BSTR((IADsPrintJob *)this, NotifyPath);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_UserPath(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, UserPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cgroup.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   Jan-29-1996     t-ptam(PatrickT)    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Class CNWCOMPATGroup
//

DEFINE_IDispatch_Implementation(CNWCOMPATGroup)
DEFINE_IADs_TempImplementation(CNWCOMPATGroup)

DEFINE_IADs_PutGetImplementation(CNWCOMPATGroup, GroupClass, gdwGroupTableSize)

DEFINE_IADsPropertyList_Implementation(CNWCOMPATGroup, GroupClass, gdwGroupTableSize)




//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::CNWCOMPATGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroup::CNWCOMPATGroup():
        _pDispMgr(NULL),
        _pPropertyCache(NULL),
        _ParentType(0),
        _ServerName(NULL),
        _hConn(NULL)
{
    ENLIST_TRACKING(CNWCOMPATGroup);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::CreateGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroup::CreateGroup(
    BSTR Parent,
    ULONG ParentType,
    BSTR ServerName,
    BSTR GroupName,
    CCredentials &Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATGroup FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a Group object.
    //

    hr = AllocateGroupObject(&pGroup);
    BAIL_ON_FAILURE(hr);

    //
    // Initialize group's core object.
    //

    hr = pGroup->InitializeCoreObject(
                     Parent,
                     GroupName,
                     GROUP_CLASS_NAME,
                     GROUP_SCHEMA_NAME,
                     CLSID_NWCOMPATGroup,
                     dwObjectState
                     );
    BAIL_ON_FAILURE(hr);

    //
    // Save protected values.
    //

    hr = ADsAllocString( ServerName ,  &pGroup->_ServerName);
    BAIL_ON_FAILURE(hr);

    pGroup->_Credentials = Credentials;

    //
    // Get a handle to the bindery this object resides on.
    //

    hr = NWApiGetBinderyHandle(
             &pGroup->_hConn,
             pGroup->_ServerName,
             pGroup->_Credentials
             );
    BAIL_ON_FAILURE(hr);


    //
    // QueryInterface.
    //
    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();

    //
    // Return.
    //

    RRETURN(hr);

error:
    delete pGroup;

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::~CNWCOMPATGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroup::~CNWCOMPATGroup( )
{
    ADsFreeString(_ServerName);

    delete _pDispMgr;

    delete _pPropertyCache;

    if (_hConn)
        NWApiReleaseBinderyHandle(_hConn);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsGroup))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATGroup::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{

    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsGroup) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }

}

/* IADs methods */

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;

    //
    // Bind an object to a real life resource if it is not bounded already.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = BuildObjectInfo(
                _Parent,
                _Name,
                &pObjectInfo
                );
        BAIL_ON_FAILURE(hr);

        hr = NWApiCreateGroup(
                 pObjectInfo,
                 _Credentials
                 );
        BAIL_ON_FAILURE(hr);


        SetObjectState(ADS_OBJECT_BOUND);
    }

    //
    // Persist changes.
    //

    hr = SetInfo(GROUP_WILD_CARD_ID);
    BAIL_ON_FAILURE(hr);


error:

    if (pObjectInfo) {

        FreeObjectInfo(pObjectInfo);
    }
    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::GetInfo(THIS)
{
    HRESULT hr = S_OK;

    _pPropertyCache->flushpropcache();

    hr = GetInfo(
             TRUE,
             GROUP_WILD_CARD_ID
             );

    NW_RRETURN_EXP_IF_ERR(hr);
}


/* IADsGroup methods */


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::AllocateGroupObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroup::AllocateGroupObject(
    CNWCOMPATGroup ** ppGroup
    )
{
    CNWCOMPATGroup FAR * pGroup = NULL;
    CNWCOMPATGroupGenInfo FAR * pGenInfo = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pGroup = new CNWCOMPATGroup();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create dispatch manager.
    //

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsGroup,
             (IADsGroup *)pGroup,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsContainer,
             (IADsContainer *)pGroup,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPropertyList,
             (IADsPropertyList *)pGroup,
             DISPID_VALUE
             );
    BAIL_ON_FAILURE(hr);


    hr = CPropertyCache::createpropertycache(
             GroupClass,
             gdwGroupTableSize,
             (CCoreADsObject *)pGroup,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);


    pGroup->_pPropertyCache = pPropertyCache;
    pGroup->_pDispMgr = pDispMgr;
    pGroup->_pGenInfo = pGenInfo;
    *ppGroup = pGroup;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);
}
//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::SetInfo(THIS_ DWORD dwPropertyID)
{
    HRESULT       hr = S_OK;


    //
    // Persist changes in cache.
    //

    hr = SetDescription(_hConn);

    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        // not a real failure, but a missing attrib
        // BUGBUG: should create if missing
        hr = S_OK;
    }

    BAIL_ON_FAILURE(hr);

error:

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::SetDescription
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroup::SetDescription(
    NWCONN_HANDLE hConn
    )
{
    LPWSTR  pszDescription = NULL;
    WCHAR   szwData[MAX_FULLNAME_LEN +1];
    CHAR    szData[MAX_FULLNAME_LEN + 1];
    HRESULT hr = S_OK;

    memset(szwData, 0, sizeof(WCHAR)*(MAX_FULLNAME_LEN +1));
    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );

    if (SUCCEEDED(hr)) {

        //
        // Convert bstr in ANSI string.
        //

        wcsncpy(szwData, pszDescription, MAX_FULLNAME_LEN);


        UnicodeToAnsiString(
            szwData,
            szData,
            0
            );

        //
        // Commit change.
        //

        hr = NWApiWriteProperty(
                 hConn,
                 _Name,
                 OT_USER_GROUP,
                 NW_PROP_IDENTIFICATION,
                 (LPBYTE) szData
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Not is modified, that's ok.
    // reset hr to  S_OK

    hr = S_OK;

error:

    if (pszDescription ) {

        FreeADsStr(pszDescription);
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::GetInfo(
    BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    HRESULT       hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        NW_RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }


    //
    // Get property.
    //

    hr = GetProperty_Description(_hConn, fExplicit);

    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        // not a real failure, we ignore it and treat it as a missing attrib
        hr = S_OK;
    }

    BAIL_ON_FAILURE(hr);

error:

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::GetProperty_Description
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroup::GetProperty_Description(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    LPWSTR           lpszFullName = NULL;
    CHAR             szFullName[MAX_FULLNAME_LEN + 1];
    DWORD            dwNumSegment = 0;
    HRESULT          hr = S_OK;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL; // Used by DELETE_LIST macro below

    //
    // Get IDENTIFICATIOIN.  This property contains the full name of an object.
    // It is often used in place of "Description".
    //

    hr = NWApiGetProperty(
             _Name,
             NW_PROP_IDENTIFICATION,
             OT_USER_GROUP,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );

    //
    // There was a bug marked on this code because NWApiGetProperty would fail with
    // an error if the property didn't exist (raid #34833), and the temp patch was
    // simply to hide all errors and always return S_OK when GetProperty_Description
    // returned.  Now NWApiGetProperty will return E_ADS_PROPERTY_NOT_FOUND.
    //

    BAIL_ON_FAILURE(hr);

    //
    // Convert result into a UNICODE string.
    //

    strcpy(szFullName, lpReplySegment->Segment);

    lpszFullName = (LPWSTR) AllocADsMem(
                                (strlen(szFullName) + 1) * sizeof(WCHAR)
                                );

    AnsiToUnicodeString(
        szFullName,
        lpszFullName,
        0
        );

    //
    // Unmarshall.
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Description"),
                lpszFullName,
                fExplicit
                );
    BAIL_ON_FAILURE(hr);

error:

    if (lpszFullName) {
        FreeADsMem(lpszFullName);
    }

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cjobop.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cjobop.cxx
//
//  Contents:
//
//  History:   1-May-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::Pause
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::Pause(THIS)
{
    BSTR    bstrName = NULL;
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    DWORD   dwJobId = 0;
    WCHAR   szUncPrinterName[MAX_PATH];

    hr = NWApiUncFromADsPath(
             _pszPrinterPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get JobId from name.
    //

    hr = get_CoreName(&bstrName);
    BAIL_ON_FAILURE(hr);

    dwJobId = (DWORD)_wtol(bstrName);

    //
    // Open a handle to the printer with USE access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Pause job.
    //

    hr = NWApiSetJob(
             hPrinter,
             dwJobId,
             0,
             NULL,
             JOB_CONTROL_PAUSE
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    ADSFREESTRING(bstrName);

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::Resume
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::Resume(THIS)
{
    BSTR    bstrName = NULL;
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    DWORD   dwJobId = 0;
    WCHAR   szUncPrinterName[MAX_PATH];

    hr = NWApiUncFromADsPath(
             _pszPrinterPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get JobId from name.
    //

    hr = get_CoreName(&bstrName);
    BAIL_ON_FAILURE(hr);

    dwJobId = (DWORD)_wtol(bstrName);

    //
    // Open a handle to the printer with USE access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Resume job.
    //

    hr = NWApiSetJob(
             hPrinter,
             dwJobId,
             0,
             NULL,
             JOB_CONTROL_RESUME
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    ADSFREESTRING(bstrName);

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::Remove
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::Remove(THIS)
{
    BSTR    bstrName = NULL;
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    DWORD   dwJobId = 0;
    WCHAR   szUncPrinterName[MAX_PATH];


    hr = NWApiUncFromADsPath(
             _pszPrinterPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get JobId from name.
    //

    hr = get_CoreName(&bstrName);
    BAIL_ON_FAILURE(hr);

    dwJobId = (DWORD)_wtol(bstrName);

    //
    // Open a handle to the printer with USE access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Remove job.
    //

    hr = NWApiSetJob(
             hPrinter,
             dwJobId,
             0,
             NULL,
             JOB_CONTROL_CANCEL
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    ADSFREESTRING(bstrName);

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::get_Status
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::get_Status(
    THIS_ LONG FAR* retval
    )
{
    *retval = _lStatus;

    RRETURN(S_OK);
}

//
// Properties Get & Set.
//

STDMETHODIMP
CNWCOMPATPrintJob::put_Position(THIS_ LONG lPosition)
{
    PUT_PROPERTY_LONG((IADsPrintJob *)this, Position);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_Position(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, Position);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_PagesPrinted(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, PagesPrinted);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_TimeElapsed(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, TimeElapsed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cggi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cggi.cxx
//
//  Contents:  This file contains the Group Object's
//             GeneralInformation Functional Set.
//
//  History:   Jan-29-1996     t-ptam(PatrickT)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    );

//
//  Class CNWCOMPATGroup
//

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::get_Description
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP CNWCOMPATGroup::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsGroup *)this, Description);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::put_Description
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP CNWCOMPATGroup::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsGroup *)this, Description);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::Members
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::Members(
    THIS_ IADsMembers FAR* FAR* ppMembers
    )
{
    HRESULT hr;

    hr = CNWCOMPATGroupCollection::CreateGroupCollection(
             _Parent,
             _ParentType,
             _ServerName,
             _Name,
             _Credentials,
             IID_IADsMembers,
             (void **)ppMembers
             );
    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::IsMember
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::IsMember(
    THIS_ BSTR bstrMember,
    VARIANT_BOOL FAR* bMember
    )
{
    IADsMembers FAR * pMembers = NULL;
    IUnknown FAR * pUnknown = NULL;
    IEnumVARIANT FAR * pEnumVar = NULL;
    DWORD i = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL fMember = FALSE;
    VARIANT VariantArray[10];
    BOOL fContinue = TRUE;
    ULONG cElementFetched = 0;

    hr = Members(
            &pMembers
            );
    BAIL_ON_FAILURE(hr);

    hr = pMembers->get__NewEnum(
                &pUnknown
                );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                IID_IEnumVARIANT,
                (void **)&pEnumVar
                );
    BAIL_ON_FAILURE(hr);


    while (fContinue) {

        IADs *pObject ;

        hr = pEnumVar->Next(
                    10,
                    VariantArray,
                    &cElementFetched
                    );

        if (hr == S_FALSE) {
            fContinue = FALSE;

            //
            // Reset hr to S_OK, we want to return success
            //

            hr = S_OK;
        }


        fMember = (VARIANT_BOOL)VerifyIfMember(
                        bstrMember,
                        VariantArray,
                        cElementFetched
                        );

        if (fMember) {

            fContinue = FALSE;
        }


        for (i = 0; i < cElementFetched; i++ ) {

            IDispatch *pDispatch = NULL;

            pDispatch = VariantArray[i].pdispVal;
            pDispatch->Release();

        }

        memset(VariantArray, 0, sizeof(VARIANT)*10);

    }

error:

    *bMember = fMember? VARIANT_TRUE : VARIANT_FALSE;

    if (pEnumVar) {
        pEnumVar->Release();
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pMembers) {
        pMembers->Release();
    }


    NW_RRETURN_EXP_IF_ERR(hr);
}


BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    )
{
    DWORD i = 0;
    HRESULT hr = S_OK;
    IADs FAR * pObject = NULL;
    IDispatch FAR * pDispatch = NULL;

    for (i = 0; i < cElementFetched; i++ ) {

        IDispatch *pDispatch = NULL;
        BSTR       bstrName = NULL;

        pDispatch = VariantArray[i].pdispVal;

        hr = pDispatch->QueryInterface(
                    IID_IADs,
                    (VOID **) &pObject
                    );
        BAIL_ON_FAILURE(hr);

        hr = pObject->get_ADsPath(&bstrName);
        BAIL_ON_FAILURE(hr);

        if (!_wcsicmp(bstrName, bstrMember)) {

            SysFreeString(bstrName);
            bstrName = NULL;

            pObject->Release();

           return(TRUE);

        }

        SysFreeString(bstrName);
        bstrName = NULL;

        pObject->Release();

    }

error:

    return(FALSE);

}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::Add
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::Add(
    THIS_ BSTR bstrNewItem
    )
{
    HRESULT       hr = S_OK;
    POBJECTINFO   pObjectInfo = NULL;

    //
    // Fill in pObjectInfo with appropriate data.
    //

    hr = BuildObjectInfo(
             bstrNewItem,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Validate input name is a user.
    //
    if (pObjectInfo->NumComponents != 2) {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Make sure that the user that we're attempting to
    // add resides on the server of this group
    //

    if (_wcsicmp(pObjectInfo->ComponentArray[0], _ServerName)) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Add the member to the group.
    //

    hr = NWApiAddGroupMember(
             _hConn,
             _Name,
             pObjectInfo->ComponentArray[1]
             );
    BAIL_ON_FAILURE(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::Remove
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::Remove(
    THIS_ BSTR bstrItemToBeRemoved
    )
{
    HRESULT       hr = S_OK;
    POBJECTINFO   pObjectInfo = NULL;

    //
    // Fill in pObjectInfo with appropriate data.
    //

    hr = BuildObjectInfo(
             bstrItemToBeRemoved,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Validate input name is a user.
    //
    if (pObjectInfo->NumComponents != 2) {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Make sure that the user that we're attempting to
    // delete resides on the server of this group
    //

    if (_wcsicmp(pObjectInfo->ComponentArray[0], _ServerName)) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }



    //
    // Remove the member from the group.
    //

    hr = NWApiRemoveGroupMember(
             _hConn,
             _Name,
             pObjectInfo->ComponentArray[1]
             );
    BAIL_ON_FAILURE(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cjob.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:  cjob.cxx
//
//  Contents:  CNWCOMPATPrintJob
//
//
//  History:   1-May-96     t-ptam (Patrick Tam)    Created.
//             1-Jul-96    ramv   (Ram Viswanathan) Modified to use propcache
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

//
// Macro-ized implementation.
//

DEFINE_IDispatch_Implementation(CNWCOMPATPrintJob);

DEFINE_IADs_TempImplementation(CNWCOMPATPrintJob);

DEFINE_IADs_PutGetImplementation(CNWCOMPATPrintJob, PrintJobClass, gdwJobTableSize);

DEFINE_IADsPropertyList_Implementation(CNWCOMPATPrintJob, PrintJobClass, gdwJobTableSize);


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::CNWCOMPATPrintJob
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATPrintJob::CNWCOMPATPrintJob():

    _pDispMgr(NULL),
    _lJobId(0),
    _lStatus(0),
    _pPropertyCache(NULL),
    _pszPrinterPath(NULL),
    _hConn(NULL)
{
    ENLIST_TRACKING(CNWCOMPATPrintJob);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::~CNWCOMPATPrintJob
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATPrintJob::~CNWCOMPATPrintJob()
{
    delete _pDispMgr;
    delete _pPropertyCache;
    if(_pszPrinterPath){
        FreeADsStr(_pszPrinterPath);
    }

    if (_hConn)
        NWApiReleaseBinderyHandle(_hConn);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::CreatePrintJob
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintJob::CreatePrintJob(
    LPTSTR pszPrinterPath,
    LONG   lJobId,
    CCredentials &Credentials,
    DWORD dwObjectState,
    REFIID riid,
    LPVOID *ppvoid
    )
{
    CNWCOMPATPrintJob *pPrintJob =  NULL;
    HRESULT hr = S_OK;
    TCHAR szJobName[MAX_LONG_LENGTH];
    POBJECTINFO pObjectInfo = NULL;
    TCHAR szUncPrinterName[MAX_PATH];

    //
    // Allocate memory for a print job object.
    //

    hr = AllocatePrintJobObject(
             &pPrintJob
             );
    BAIL_ON_FAILURE(hr);

    //
    // Convert the JobId that we have into a string that we move
    // into the Name field
    //

    _ltow(
        lJobId,
        szJobName,
        10
        );

    //
    // Initialize its core object.
    //

    hr = pPrintJob->InitializeCoreObject(
                        pszPrinterPath,
                        szJobName,
                        PRINTJOB_CLASS_NAME,
                        PRINTJOB_SCHEMA_NAME,
                        CLSID_NWCOMPATPrintJob,
                        dwObjectState
                        );
    BAIL_ON_FAILURE(hr);

    //
    // Job ID.
    //

    pPrintJob->_lJobId = lJobId;
    pPrintJob->_pszPrinterPath = AllocADsStr(pszPrinterPath);

    if(! pPrintJob->_pszPrinterPath) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    // Credentials
    pPrintJob->_Credentials = Credentials;

    //
    // Componentize ADs name.
    //

    hr = BuildObjectInfo(
             pPrintJob->_Parent,
             pPrintJob->_Name,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get a handle to the bindery this object resides on.
    //

    hr = NWApiGetBinderyHandle(
             &pPrintJob->_hConn,
             pObjectInfo->ComponentArray[0],
             pPrintJob->_Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get interface pointer.
    //

    hr = pPrintJob->QueryInterface(
                        riid,
                        (void **)ppvoid
                        );
    BAIL_ON_FAILURE(hr);

    pPrintJob->Release();

    //
    // Return.
    //

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    delete pPrintJob;

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::AllocatePrintJobObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintJob::AllocatePrintJobObject(
    CNWCOMPATPrintJob ** ppPrintJob
    )
{
    CDispatchMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    CNWCOMPATPrintJob FAR * pPrintJob = NULL;
    CNWCOMPATFSPrintJobGeneralInfo FAR * pGenInfo = NULL;
    CNWCOMPATFSPrintJobOperation FAR * pOperation = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a PrintJob object.
    //

    pPrintJob = new CNWCOMPATPrintJob();
    if (pPrintJob == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPrintJob,
             (IADsPrintJob *) pPrintJob,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPrintJobOperations,
                (IADsPrintJobOperations *)pPrintJob,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pPrintJob,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //
    hr = CPropertyCache::createpropertycache(
            PrintJobClass,
            gdwJobTableSize,
            (CCoreADsObject *)pPrintJob,
             &pPropertyCache
            );

    BAIL_ON_FAILURE(hr);

    pPrintJob->_pPropertyCache = pPropertyCache;
    pPrintJob->_pDispMgr = pDispMgr;
    *ppPrintJob = pPrintJob;

    RRETURN(hr);

error:

    delete  pPropertyCache;
    delete  pDispMgr;

    delete  pPrintJob;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::QueryInterface(
    REFIID riid,
    LPVOID FAR* ppvObj
    )
{
    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsPrintJob FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsPrintJob *)this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsPrintJob FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintJob))
    {
        *ppvObj = (IADsPrintJob FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintJobOperations))
    {
        *ppvObj = (IADsPrintJobOperations FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }

    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::InterfaceSupportsErrorInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsPropertyList) ||
        IsEqualIID(riid, IID_IADsPrintJob) ||
        IsEqualIID(riid, IID_IADsPrintJobOperations)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::SetInfo(THIS)
{
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    LPBYTE  lpbBuffer = NULL;
    WCHAR   szUncPrinterName[MAX_PATH];

    //
    // Make sure object is bound to a tangible resource.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = CreateObject();
        BAIL_ON_FAILURE(hr);

        SetObjectState(ADS_OBJECT_BOUND);
    }

    //
    // Make Unc printer name.
    //

    hr = NWApiUncFromADsPath(
             _pszPrinterPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Open a handle to a printer.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ALL_ACCESS
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get job Info structure.
    //

    hr = NWApiGetJob(
             hPrinter,
             (DWORD) _lJobId,
             WIN32_API_LEVEL_2,
             &lpbBuffer
             );
    BAIL_ON_FAILURE(hr);

    //
    // Set info.
    //

    hr = MarshallAndSet(
             hPrinter,
             (LPJOB_INFO_2) lpbBuffer
             );
error:

    //
    // Close Printer handle.
    //

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::GetInfo(THIS)
{
    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(
                TRUE,
                JOB_API_LEVEL
                ));
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::CreateObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::CreateObject()
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::GetInfo
//
//  Synopsis: Please note that only Level 2 is used, unlike the WinNT side.
//            Since Level 1 is simply a subset of Level 2 in this case, its just
//            a matter of style which one to use.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::GetInfo(
    THIS_ BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    //
    // Please note that the input DWORD is treated as dwApiLevel, unlike ohter
    // NWCompat objects that treat it as dwPropertyID.  The reason is that Win32
    // APIs are used for retrieving information of the object.
    //

    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    LPBYTE  lpbJobInfo = NULL;
    WCHAR szUncPrinterName[MAX_PATH];

    //
    // Make Unc printer name.
    //

    hr = NWApiUncFromADsPath(
             _pszPrinterPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Open a handle to a printer.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ALL_ACCESS
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get job's info.
    //

    hr = NWApiGetJob(
             hPrinter,
             (DWORD) _lJobId,
             WIN32_API_LEVEL_2,
             &lpbJobInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Unmarshall.
    //

    hr = UnMarshall_GeneralInfo(
             (LPJOB_INFO_2) lpbJobInfo,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

    hr = UnMarshall_Operation(
             (LPJOB_INFO_2) lpbJobInfo,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if(lpbJobInfo){
        FreeADsMem(lpbJobInfo);
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::UnMarshall_GeneralInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintJob::UnMarshall_GeneralInfo(
    LPJOB_INFO_2 lpJobInfo2,
    BOOL fExplicit
    )
{
    DATE    daTemp = 0;
    HRESULT hr = S_OK;
    LPWSTR  lpszTemp = NULL;
    WCHAR   szTemp[MAX_PATH];


    hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("HostPrintQueue"),
                    _pszPrinterPath,
                    fExplicit
                    );


    hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("User"),
                    lpJobInfo2->pUserName,
                    fExplicit
                    );

    hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    lpJobInfo2->pDocument,
                    fExplicit
                    );

    hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("Notify"),
                    lpJobInfo2->pNotifyName,
                    fExplicit
                    );

    hr = SetSYSTEMTIMEPropertyInCache(
                    _pPropertyCache,
                    TEXT("TimeSubmitted"),
                    lpJobInfo2->Submitted,
                    fExplicit
                    );

    hr = SetDWORDPropertyInCache(
                    _pPropertyCache,
                    TEXT("Priority"),
                    lpJobInfo2->Priority,
                    fExplicit
                    );

    hr = SetDWORDPropertyInCache(
                    _pPropertyCache,
                    TEXT("TotalPages"),
                    lpJobInfo2-> TotalPages,
                    fExplicit
                    );


    hr = SetDATEPropertyInCache(
                    _pPropertyCache,
                    TEXT("StartTime"),
                    lpJobInfo2->StartTime,
                    fExplicit
                    );


    hr = SetDATEPropertyInCache(
                    _pPropertyCache,
                    TEXT("UntilTime"),
                    lpJobInfo2->UntilTime,
                    fExplicit
                    );

    hr = SetDWORDPropertyInCache(
                    _pPropertyCache,
                    TEXT("Size"),
                    lpJobInfo2->Size,
                    fExplicit
                    );

    hr = S_OK;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::UnMarshall_Operation
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintJob::UnMarshall_Operation(
    LPJOB_INFO_2 lpJobInfo2,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("Position"),
                lpJobInfo2->Position,
                fExplicit
                );
    BAIL_ON_FAILURE(hr);

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("PagesPrinted"),
                lpJobInfo2->PagesPrinted,
                fExplicit
                );

    BAIL_ON_FAILURE(hr);

    hr = SetDATEPropertyInCache(
                _pPropertyCache,
                TEXT("TimeElapsed"),
                lpJobInfo2->Time,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("Status"),
                lpJobInfo2->Status,
                fExplicit
                );

    BAIL_ON_FAILURE(hr);

    _lStatus = lpJobInfo2->Status;

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::MarshallAndSet
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintJob::MarshallAndSet(
    HANDLE hPrinter,
    LPJOB_INFO_2 lpJobInfo2
    )
{
    LPTSTR pszDescription = NULL;
    LPTSTR pszNotify = NULL;
    DWORD  dwValue;
    HRESULT hr = S_OK;

    //
    // Set Description.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->pDocument = pszDescription;
    }

    //
    // Set Notify.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Notify"),
                    &pszNotify
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->pNotifyName = pszNotify;
    }

    //
    // Set Priority.
    //

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Priority"),
                    &dwValue
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->Priority = dwValue;
    }

    //
    // Set StartTime.
    //

   hr = GetDATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("StartTime"),
                    &dwValue
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->StartTime = dwValue;
    }

    //
    // Set UntilTime
    //

   hr = GetDATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("UntilTime"),
                    &dwValue
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->UntilTime = dwValue;
    }


/*  Clarify the precedence between Notify & NotifyPath

    hr = UM_GET_BSTR_PROPERTY(_pGenInfo, NotifyPath, fExplicit);
    BAIL_ON_FAILURE(hr);
*/

    //
    // Set Position.
    //

   hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Position"),
                    &dwValue
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->Position = dwValue;
    }

    //
    // Commit changes.
    //

    hr = NWApiSetJob(
             hPrinter,
             (DWORD) _lJobId,
             WIN32_API_LEVEL_2,
             (LPBYTE) lpJobInfo2,
             0
             );
    BAIL_ON_FAILURE(hr);

error:
    if(pszDescription)
        FreeADsStr(pszDescription);
    if(pszNotify)
        FreeADsStr(pszNotify);

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cgroups.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroups.cxx
//
//  Contents:  Group object
//
//  History:   Mar-18-965     t-ptam (PatrickT)    Migrated.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Class CNWCOMPATGroupCollection
//

DEFINE_IDispatch_Implementation(CNWCOMPATGroupCollection)

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroupCollection::CNWCOMPATGroupCollection():
        _ParentType(0),
        _ServerName(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CNWCOMPATGroupCollection);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroupCollection::~CNWCOMPATGroupCollection( )
{
    if (_ServerName)
        ADsFreeString(_ServerName);
    delete _pDispMgr;
    VariantClear(&_vFilter);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroupCollection::CreateGroupCollection(
    BSTR Parent,
    ULONG ParentType,
    BSTR ServerName,
    BSTR GroupName,
    CCredentials &Credentials,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATGroupCollection FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGroupCollectionObject(&pGroup);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->InitializeCoreObject(
                     Parent,
                     GroupName,
                     L"group",
                     NO_SCHEMA,
                     CLSID_NWCOMPATGroup,
                     ADS_OBJECT_UNBOUND
                     );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName , &pGroup->_ServerName);
    BAIL_ON_FAILURE(hr);

    pGroup->_ParentType = ParentType;
    pGroup->_Credentials = Credentials;

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();
    RRETURN(hr);

error:
    delete pGroup;

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATGroupCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollection::get_Count(
    long FAR* retval
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollection::get_Filter(
    THIS_ VARIANT FAR* pVar
    )
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollection::put_Filter(
    THIS_ VARIANT Var
    )
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNWCOMPATGroupCollectionEnum::Create(
             (CNWCOMPATGroupCollectionEnum **)&penum,
             _Parent,
             _ParentType,
             _ADsPath,
             _ServerName,
             _Name,
             _Credentials,
             _vFilter
             );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroupCollection::AllocateGroupCollectionObject(
    CNWCOMPATGroupCollection ** ppGroup
    )
{
    CNWCOMPATGroupCollection FAR * pGroup = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pGroup = new CNWCOMPATGroupCollection();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsMembers,
             (IADsMembers *)pGroup,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:
    if (pGroup) {
        delete pGroup;
    }

    if (pDispMgr) {
        delete  pDispMgr;
    }

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cjobs.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cjobs.cxx
//
//  Contents:  Job collection object
//
//  History:   May-08-96     t-ptam (PatrickT)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Macro-iszed implementation.
//

DEFINE_IDispatch_Implementation(CNWCOMPATJobCollection)

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::CNWCOMPATJobCollection
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATJobCollection::CNWCOMPATJobCollection():
    _pDispMgr(NULL),
    _hConn(NULL)
{
    ENLIST_TRACKING(CNWCOMPATJobCollection);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::CreateJobCollection
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATJobCollection::CreateJobCollection(
    BSTR bstrParent,
    BSTR bstrPrinterName,
    CCredentials &Credentials,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATJobCollection FAR * pJobs = NULL;
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;

    hr = AllocateJobCollectionObject(&pJobs);
    BAIL_ON_FAILURE(hr);

    hr = pJobs->InitializeCoreObject(
                    bstrParent,
                    bstrPrinterName,
                    PRINTER_CLASS_NAME,
                    NO_SCHEMA,
                    CLSID_NWCOMPATPrintQueue,
                    ADS_OBJECT_UNBOUND
                    );
    BAIL_ON_FAILURE(hr);

    pJobs->_Credentials = Credentials;

    //
    // Componentize ADs name.
    //

    hr = BuildObjectInfo(
             pJobs->_Parent,
             pJobs->_Name,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get a handle to the bindery this object resides on.
    //

    hr = NWApiGetBinderyHandle(
             &pJobs->_hConn,
             pObjectInfo->ComponentArray[0],
             pJobs->_Credentials
             );
    BAIL_ON_FAILURE(hr);

    hr = pJobs->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pJobs->Release();

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);

error:
    if (pObjectInfo)
        FreeObjectInfo(pObjectInfo);
    
    delete pJobs;

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::~CNWCOMPATJobCollection
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATJobCollection::~CNWCOMPATJobCollection( )
{
    delete _pDispMgr;

    if (_hConn)
        NWApiReleaseBinderyHandle(_hConn);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsCollection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsCollection))
    {
        *ppv = (IADsCollection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsCollection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::InterfaceSupportsErrorInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsCollection)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::get__NewEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::get__NewEnum(
    THIS_ IUnknown FAR* FAR* retval
    )
{
    HRESULT hr = S_OK;
    IEnumVARIANT * pEnum = NULL;
    WCHAR szPrinterName[MAX_PATH];

    //
    // Validate input parameter.
    //

    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    *retval = NULL;

    //
    // Express printer name as an ADsPath.
    //

    wsprintf(szPrinterName,
             L"%s/%s",
             _Parent,
             _Name );

    //
    // Create enumerator.
    //

    hr = CNWCOMPATJobCollectionEnum::Create(
             (CNWCOMPATJobCollectionEnum **)&pEnum,
             szPrinterName,
             _Credentials
             );
    BAIL_ON_FAILURE(hr);

    hr = pEnum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (pEnum) {
        pEnum->Release();
    }

    //
    // Return.
    //

    RRETURN(NOERROR);

error:
    if (pEnum) {
        delete pEnum;
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::GetObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::GetObject(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvItem
    )
{
    HRESULT hr = S_OK;
    DWORD dwJobId = 0;
    IDispatch *pDispatch = NULL;

    //
    // Validate input parameters.
    //

    if(!bstrName || !pvItem){
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    //
    // Convert bstrName, which is a JobId, into DWORD.
    //

    dwJobId = (DWORD)_wtol(bstrName);

    //
    // Create the desire print job object.
    //

    hr = CNWCOMPATPrintJob::CreatePrintJob(
             _ADsPath,
             dwJobId,
             _Credentials,
             ADS_OBJECT_BOUND,
             IID_IDispatch,
             (void **)&pDispatch
             );
    BAIL_ON_FAILURE(hr);

    //
    // stick this IDispatch pointer into a caller provided variant
    //

    VariantInit(pvItem);
    V_VT(pvItem) = VT_DISPATCH;
    V_DISPATCH(pvItem) = pDispatch;

error:
    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::Add
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::Add(
    THIS_ BSTR bstrNewItem,
    VARIANT vItem
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::Remove
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::Remove(
    THIS_ BSTR bstrItemToBeRemoved
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::AllocateJobCollectionObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATJobCollection::AllocateJobCollectionObject(
    CNWCOMPATJobCollection ** ppJob
    )
{
    CNWCOMPATJobCollection FAR * pJob = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a JobCollection object.
    //

    pJob = new CNWCOMPATJobCollection();
    if (pJob == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsCollection,
             (IADsCollection *)pJob,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    pJob->_pDispMgr = pDispMgr;
    *ppJob = pJob;

    RRETURN(hr);

error:

    delete pJob;
    delete  pDispMgr;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\core.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  core.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

HRESULT
CCoreADsObject::InitializeCoreObject(
        BSTR Parent,
        BSTR Name,
        BSTR ClassName,
        BSTR Schema,
        REFCLSID rclsid,
        DWORD dwObjectState
        )
{
    HRESULT hr = S_OK;
    ADsAssert(Parent);
    ADsAssert(Name);
    ADsAssert(ClassName);


    if (  ( _tcsicmp( ClassName, PRINTJOB_CLASS_NAME ) == 0 )
       || ( _tcsicmp( ClassName, SESSION_CLASS_NAME ) == 0 )
       || ( _tcsicmp( ClassName, RESOURCE_CLASS_NAME ) == 0 )
       )
    {
        //
        // This three classes are not really DS objects so they don't
        // really have a parent. Hence, we set the parent string to empty
        // string.
        //
        hr = ADsAllocString( TEXT(""), &_ADsPath);

        BAIL_ON_FAILURE(hr);

        hr = ADsAllocString( TEXT(""), &_Parent);
    }
    else
    {
        hr = BuildADsPath(
                 Parent,
                 Name,
                 &_ADsPath
                 );

        BAIL_ON_FAILURE(hr);

        hr = ADsAllocString( Parent, &_Parent);
    }

    BAIL_ON_FAILURE(hr);

    hr = BuildADsGuid(
            rclsid,
            &_ADsGuid
        );
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( Name, &_Name);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ClassName, &_ADsClass);
    BAIL_ON_FAILURE(hr);

    hr = BuildSchemaPath(
        Parent,
        Name,
        Schema,
        &_Schema
        );
    BAIL_ON_FAILURE(hr);

    _dwObjectState = dwObjectState;

error:
    RRETURN(hr);
}

CCoreADsObject::CCoreADsObject():
                        _Name(NULL),
                        _ADsPath(NULL),
                        _Parent(NULL),
                        _ADsClass(NULL),
                        _Schema(NULL),
                        _ADsGuid(NULL),
                        _dwObjectState(0)
{
}


CCoreADsObject::~CCoreADsObject()
{
    if (_Name) {
        ADsFreeString(_Name);
    }

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_Parent) {
        ADsFreeString(_Parent);
    }

    if (_ADsClass) {
        ADsFreeString(_ADsClass);
    }

    if (_Schema) {
        ADsFreeString(_Schema);
    }

    if (_ADsGuid) {
        ADsFreeString(_ADsGuid);
    }
}


HRESULT
CCoreADsObject::get_CoreName(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        NW_RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Name, retval);
    NW_RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CCoreADsObject::get_CoreADsPath(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        NW_RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsPath, retval);
    NW_RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CCoreADsObject::get_CoreADsClass(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        NW_RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsClass, retval);
    NW_RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CCoreADsObject::get_CoreParent(BSTR * retval)
{

    HRESULT hr;

   if (FAILED(hr = ValidateOutParameter(retval))){
        NW_RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Parent, retval);
    NW_RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreSchema(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        NW_RRETURN_EXP_IF_ERR(hr);
    }

    if ( _Schema == NULL || *_Schema == 0 )
        NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);

    hr = ADsAllocString(_Schema, retval);
    NW_RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreGUID(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        NW_RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsGuid, retval);
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CCoreADsObject::GetInfo(THIS_ BOOL fExplicit, DWORD dwPropertyID)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\common.cxx ===
#include "nwcompat.hxx"
#pragma hdrstop


FILTERS Filters[] = {
                    {L"computer", NWCOMPAT_COMPUTER_ID},
                    {L"user", NWCOMPAT_USER_ID},
                    {L"group", NWCOMPAT_GROUP_ID},
                    {L"service", NWCOMPAT_SERVICE_ID},
                    {L"printqueue", NWCOMPAT_PRINTER_ID},
                    {L"fileshare", NWCOMPAT_FILESHARE_ID},
                    {L"class", NWCOMPAT_CLASS_ID},
                    {L"syntax", NWCOMPAT_SYNTAX_ID},
                    {L"property", NWCOMPAT_PROPERTY_ID}
                  };

#define MAX_FILTERS  (sizeof(Filters)/sizeof(FILTERS))


HRESULT
CreatePropEntry(
    LPWSTR szPropName,
    ADSTYPE dwADsType,
    VARIANT varData,
    REFIID riid,
    LPVOID * ppDispatch
    );



PFILTERS  gpFilters = Filters;
DWORD gdwMaxFilters = MAX_FILTERS;
extern WCHAR * szProviderName;

//+------------------------------------------------------------------------
//
//  Class:      Common
//
//  Purpose:    Contains NWCOMPAT routines and properties that are common to
//              all NWCOMPAT objects. NWCOMPAT objects get the routines and
//              properties through C++ inheritance.
//
//-------------------------------------------------------------------------

HRESULT
MakeUncName(
    LPWSTR szSrcBuffer,
    LPWSTR szTargBuffer
    )
{
    ADsAssert(szSrcBuffer && *szSrcBuffer);
    wcscpy(szTargBuffer, L"\\\\");
    wcscat(szTargBuffer, szSrcBuffer);
    RRETURN(S_OK);
}

HRESULT
ValidateOutParameter(
    BSTR * retval
    )
{
    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    RRETURN(S_OK);
}

HRESULT
BuildADsPath(
    BSTR Parent,
    BSTR Name,
    BSTR *pADsPath
    )
{
    WCHAR ADsPath[MAX_PATH];
    WCHAR ProviderName[MAX_PATH];
    HRESULT hr = S_OK;
    LPWSTR pszDisplayName = NULL;

    //
    // We will assert if bad parameters are passed to us.
    // This is because this should never be the case. This
    // is an internal call
    //

    ADsAssert(Parent && Name);
    ADsAssert(pADsPath);

    hr = GetDisplayName(
             Name,
             &pszDisplayName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Special case the Namespace object; if
    // the parent is L"ADs:", then Name = ADsPath
    //

    if (!_wcsicmp(Parent, L"ADs:")) {
        hr = ADsAllocString(Name, pADsPath);
        BAIL_ON_FAILURE(hr);
        goto cleanup;
    }

    //
    // The rest of the cases we expect valid data,
    // Path, Parent and Name are read-only, the end-user
    // cannot modify this data
    //

    //
    // For the first object, the domain object we do not add
    // the first backslash; so we examine that the parent is
    // L"NWCOMPAT:" and skip the slash otherwise we start with
    // the slash
    //

    wsprintf(ProviderName, L"%s:", szProviderName);

    wcscpy(ADsPath, Parent);

    if (_wcsicmp(ADsPath, ProviderName)) {
        wcscat(ADsPath, L"/");
    }
    else {
       wcscat(ADsPath, L"//");
    }
    wcscat(ADsPath, Name);

    hr = ADsAllocString(ADsPath, pADsPath);

cleanup:
error:

    if (pszDisplayName) {
        FreeADsMem(pszDisplayName);
    }

    RRETURN(hr);
}

HRESULT
BuildSchemaPath(
    BSTR Parent,
    BSTR Name,
    BSTR Schema,
    BSTR *pSchemaPath
    )
{
    WCHAR SchemaPath[MAX_PATH];
    WCHAR ProviderName[MAX_PATH];
    HRESULT hr = S_OK;
    long i;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(Parent);


    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    //
    // We will assert if bad parameters are passed to us.
    // This is because this should never be the case. This
    // is an internal call
    //

    ADsAssert(Parent);
    ADsAssert(pSchemaPath);

    //
    // If no schema name is passed in, then there is no schema path
    //
    if ( Schema == NULL || *Schema == 0 ){

        RRETURN(ADsAllocString(L"", pSchemaPath));
    }

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);


    wsprintf(SchemaPath, L"%s://", szProviderName);

    if (!pObjectInfo->NumComponents) {
        wcscat(SchemaPath, Name);
    }else{
        wcscat(SchemaPath, pObjectInfo->DisplayComponentArray[0]);
    }

    wcscat( SchemaPath, L"/");
    wcscat( SchemaPath, SCHEMA_NAME );
    wcscat( SchemaPath, L"/");
    wcscat( SchemaPath, Schema );

    hr = ADsAllocString(SchemaPath, pSchemaPath);

error:

    FreeObjectInfo( &ObjectInfo, TRUE );

    RRETURN(hr);
}

HRESULT
BuildADsGuid(
    REFCLSID clsid,
    BSTR *pADsClass
    )
{
    WCHAR ADsClass[MAX_PATH];

    if (!StringFromGUID2(clsid, ADsClass, MAX_PATH)) {
        //
        // MAX_PATH should be more than enough for the GUID.
        //
        ADsAssert(!"GUID too big !!!");
        RRETURN(E_FAIL);
    }

    RRETURN(ADsAllocString(ADsClass, pADsClass));
}

HRESULT
BuildObjectInfo(
    BSTR ADsParent,
    BSTR Name,
    POBJECTINFO * ppObjectInfo
    )
{
    WCHAR szBuffer[MAX_PATH];
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;


    wcscpy(szBuffer, ADsParent);
    wcscat(szBuffer, L"/");
    wcscat(szBuffer, Name);

    CLexer Lexer(szBuffer);

    pObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));
    if (!pObjectInfo) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    *ppObjectInfo = pObjectInfo;

    RRETURN(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    *ppObjectInfo = NULL;

    RRETURN(hr);
}

HRESULT
BuildObjectInfo(
    BSTR ADsPath,
    POBJECTINFO * ppObjectInfo
    )
{
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;
    CLexer Lexer(ADsPath);

    pObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));
    if (!pObjectInfo) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    *ppObjectInfo = pObjectInfo;

    RRETURN(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    *ppObjectInfo = NULL;

    RRETURN(hr);
}

VOID
FreeObjectInfo(
    POBJECTINFO pObjectInfo,
    BOOL fStatic
    )
{
    DWORD i = 0;

    if (!pObjectInfo) {
        return;
    }

    FreeADsStr(pObjectInfo->ProviderName);

    for (i = 0; i < pObjectInfo->NumComponents; i++ ) {
        FreeADsStr(pObjectInfo->ComponentArray[i]);
        FreeADsStr(pObjectInfo->DisplayComponentArray[i]);
    }

    if ( !fStatic ) {
        FreeADsMem(pObjectInfo);
    }
}

HRESULT
ValidateObject(
    DWORD dwObjectType,
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials
    )
{
    switch (dwObjectType) {
    case NWCOMPAT_USER_ID:
        RRETURN(ValidateUserObject(pObjectInfo, Credentials));

    case NWCOMPAT_GROUP_ID:
        RRETURN(ValidateGroupObject(pObjectInfo, Credentials));

    case NWCOMPAT_PRINTER_ID:
        RRETURN(ValidatePrinterObject(pObjectInfo));

    default:
        RRETURN(E_FAIL);
    }
}

HRESULT
GetObjectType(
    PFILTERS pFilters,
    DWORD dwMaxFilters,
    BSTR ClassName,
    PDWORD pdwObjectType
    )
{
    DWORD i = 0;

    ADsAssert(pdwObjectType);

    for (i = 0; i < dwMaxFilters; i++) {
        if (!_wcsicmp(ClassName, (pFilters + i)->szObjectName)) {
            *pdwObjectType = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }
    }
    *pdwObjectType = 0;
    RRETURN(E_FAIL);
}

HRESULT
ValidateProvider(
    POBJECTINFO pObjectInfo
    )
{
    //
    // The provider name is case-sensitive.  This is a restriction that OLE
    // has put on us.
    //
    if (!(wcscmp(pObjectInfo->ProviderName, szProviderName))) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}

HRESULT
ConvertSystemTimeToDATE(
    SYSTEMTIME Time,
    DATE *     pdaTime
    )
{
    FILETIME ft;
    BOOL fRetval = FALSE;
    USHORT wDosDate;
    USHORT wDosTime;
    SYSTEMTIME LocalTime;

    //
    // Get Time-zone specific local time.
    //

    fRetval = SystemTimeToTzSpecificLocalTime(
                  NULL,
                  &Time,
                  &LocalTime
                  );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // System Time To File Time.
    //

    fRetval = SystemTimeToFileTime(&LocalTime,
                                   &ft);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // File Time to DosDateTime.
    //

    fRetval = FileTimeToDosDateTime(&ft,
                                    &wDosDate,
                                    &wDosTime);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // DosDateTime to VariantTime.
    //

    fRetval = DosDateTimeToVariantTime(wDosDate,
                                       wDosTime,
                                       pdaTime );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    RRETURN(S_OK);
}

HRESULT
ConvertDATEToSYSTEMTIME(
    DATE  daDate,
    SYSTEMTIME *pSysTime
    )
{
    HRESULT hr;
    FILETIME ft;
    FILETIME lft; //local file time
    BOOL fRetval = FALSE;
    SYSTEMTIME LocalTime;
    USHORT wDosDate;
    USHORT wDosTime;

    fRetval = VariantTimeToDosDateTime(daDate,
                                       &wDosDate,
                                       &wDosTime );

    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    fRetval = DosDateTimeToFileTime(wDosDate,
                                    wDosTime,
                                    &lft);



    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    //
    // convert local file time to filetime
    //

    fRetval = LocalFileTimeToFileTime(&lft,
                                      &ft );

    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    fRetval = FileTimeToSystemTime(&ft,
                                   pSysTime );


    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    RRETURN(S_OK);
}

HRESULT
ConvertDATEToDWORD(
    DATE  daDate,
    DWORD *pdwDate
    )
{
    BOOL fBool = TRUE;
    WORD wDOSDate = 0;
    WORD wDOSTime = 0;
    WORD wHour = 0;
    WORD wMinute = 0;

    //
    // Break up Variant date.
    //

    fBool = VariantTimeToDosDateTime(
                (DOUBLE) daDate,
                &wDOSDate,
                &wDOSTime
                );
    if (fBool == FALSE) {
        goto error;
    }

    //
    // Convert DOS time into DWORD time which expresses time as the number of
    // minutes elapsed since mid-night.
    //

    wHour = wDOSTime >> 11;
    wMinute = (wDOSTime >> 5) - (wHour << 6);

    //
    // Return.
    //

    *pdwDate = wHour * 60 + wMinute;

error:

    RRETURN(S_OK);
}

HRESULT
ConvertDWORDToDATE(
    DWORD  dwTime,
    DATE * pdaTime
    )
{
    BOOL       fBool = TRUE;
    DOUBLE     vTime = 0;
    SYSTEMTIME SysTime = {1980,1,0,1,0,0,0,0};
    SYSTEMTIME LocalTime = {1980,1,0,1,0,0,0,0};
    WORD       wDOSDate = 0;
    WORD       wDOSTime = 0;
    WORD       wHour = 0;
    WORD       wMinute = 0;
    WORD       wSecond = 0;

    //
    // Get Hour and Minute from DWORD.
    //

    SysTime.wHour = (WORD) (dwTime / 60);
    SysTime.wMinute = (WORD) (dwTime % 60);

    //
    // Get Time-zone specific local time.
    //

    fBool = SystemTimeToTzSpecificLocalTime(
                NULL,
                &SysTime,
                &LocalTime
                );
    if (fBool == FALSE) {
        RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    wHour = LocalTime.wHour;
    wMinute = LocalTime.wMinute;
    wSecond = LocalTime.wSecond;

    //
    // Set a dummy date.
    //

    wDOSDate = DATE_1980_JAN_1;

    //
    // Shift data to correct bit as required by the DOS date & time format.
    //

    wHour = wHour << 11;
    wMinute = wMinute << 5;

    //
    // Put them in DOS format.
    //

    wDOSTime = wHour | wMinute | wSecond;

    //
    // Convert into VariantTime.
    //

    fBool = DosDateTimeToVariantTime(
                wDOSDate,
                wDOSTime,
                &vTime
                );
    //
    // Return.
    //

    if (fBool == TRUE) {

        *pdaTime = vTime;

        RRETURN(S_OK);
    }
    else {
        RRETURN(E_FAIL);
    }
}

HRESULT
ConvertNW312DateToSYSTEMTIME(
    BYTE byDateTime[],
    SYSTEMTIME *pSysTime
    )
{
    HRESULT hr = S_OK;
    WORD wYear;

    //
    // Subtract 80 from wYear for NWApiMakeSYSTEMTIME.
    //

    wYear = (WORD)byDateTime[0];

    if (wYear != 0) {
        wYear -= 80;
    }

    //
    // Convert into SYSTEMTIME.
    //

    hr = NWApiMakeSYSTEMTIME(
                pSysTime,
                (WORD)byDateTime[2],
                (WORD)byDateTime[1],
                wYear,
                0,0,0
                );
    RRETURN(hr);
}

HRESULT
DelimitedStringToVariant(
    LPTSTR pszString,
    VARIANT *pvar,
    TCHAR Delimiter
    )
{
    SAFEARRAYBOUND sabound[1];
    DWORD dwElements;
    LPTSTR pszCurrPos = pszString;
    LPTSTR *rgszStrings = NULL;
    SAFEARRAY *psa = NULL;
    VARIANT v;
    HRESULT hr = S_OK;
    LONG i;

    //
    // This function converts a delimited string into a VARIANT of
    // safe arrays.
    //
    // Assumption: a valid string are passed to this function
    // note that the input string gets destroyed in the process
    //

    //
    // scan the delimited string once to find out the dimension
    //

    //
    // in order to filter for NULL input values do a sanity check for
    // length of input string.
    //


    //
    // take care of null case first for sanity's sake
    //

    if (!pszString){
        sabound[0].cElements = 0;
        sabound[0].lLbound = 0;

        psa = SafeArrayCreate(VT_VARIANT, 1, sabound);

        if (psa == NULL){
            hr = E_OUTOFMEMORY;
            goto error;
        }

        VariantInit(pvar);
        V_VT(pvar) = VT_ARRAY|VT_VARIANT;
        V_ARRAY(pvar) = psa;
        goto error;
    }

    dwElements = (wcslen(pszString) == 0) ? 0: 1 ;

    while(!(*pszCurrPos == TEXT('\0'))){
        if(*pszCurrPos == Delimiter){
            dwElements++;
            *pszCurrPos = TEXT('\0');
        }
        pszCurrPos++;
    }

    rgszStrings = (LPTSTR *)AllocADsMem(sizeof(LPTSTR)*dwElements);

    if(!rgszStrings){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // scan string again and put the appropriate pointers
    //

    pszCurrPos = pszString;
    if(rgszStrings != NULL){
        (*rgszStrings) = pszCurrPos;
    }
    i = 1;

    while(i < (LONG)dwElements){

        if(*pszCurrPos == TEXT('\0')){
            *(rgszStrings+i) = ++pszCurrPos;
            i++;
        }
        pszCurrPos++;
    }


    //
    // create the safearray
    //

    sabound[0].cElements = dwElements;
    sabound[0].lLbound = 0;

    psa = SafeArrayCreate(VT_VARIANT, 1, sabound);

    if (psa == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    for(i=0; i<(LONG)dwElements; i++){

        VariantInit(&v);
        V_VT(&v) = VT_BSTR;

        hr = ADsAllocString(*(rgszStrings+i), &(V_BSTR(&v)));
        BAIL_ON_FAILURE(hr);

        //
        // Stick the caller provided data into the end of the SafeArray
        //

        hr = SafeArrayPutElement(psa, &i, &v);
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

    }

    //
    // convert this safearray into a VARIANT
    //

    VariantInit(pvar);
    V_VT(pvar) = VT_ARRAY|VT_VARIANT;
    V_ARRAY(pvar) = psa;

error:
    if(rgszStrings && dwElements != 0){
        FreeADsMem(rgszStrings);
    }
    RRETURN(hr);
}

HRESULT
VariantToDelimitedString(
    VARIANT var,
    LPTSTR *ppszString,
    TCHAR  Delimiter
    )
{

    LONG lIndices;
    ULONG cElements;
    ULONG  ulRequiredLength=0;
    SAFEARRAY  *psa = NULL;
    BSTR bstrElement = NULL;
    VARIANT vElement;
    LPTSTR  pszCurrPos = NULL;
    HRESULT hr = S_OK;
    ULONG i;

    //
    // converts the safearray in a variant to a delimited string
    //

    *ppszString = NULL;

    if(!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    psa = V_ARRAY(&var);

    //
    // Check that there is only one dimension in this array
    //

    if (psa->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is atleast one element in this array
    //

    cElements = psa->rgsabound[0].cElements;

    if (cElements == 0){
        hr = E_FAIL;
        goto error;
    }

    //
    // We know that this is a valid single dimension array
    //

    lIndices= 0;
    for(i=0; i< cElements; i++){
        lIndices = i;
        hr = SafeArrayGetElement(psa, &lIndices, &vElement);
        BAIL_ON_FAILURE(hr);

        if(!(V_VT(&vElement) == VT_BSTR)){
            RRETURN(E_FAIL);
        }

        //
        // unpack the BSTR in the VARIANT
        //

        hr = ADsAllocString( vElement.bstrVal, &bstrElement);
        BAIL_ON_FAILURE(hr);

        ulRequiredLength+= wcslen(bstrElement)+1;
    }

    ulRequiredLength +=2;

    *ppszString = (LPTSTR)AllocADsMem( ulRequiredLength*sizeof(TCHAR));
    if(*ppszString == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }
    lIndices= 0;

    pszCurrPos = *ppszString;

    for(i=0; i< cElements; i++){
        lIndices = i;
        hr = SafeArrayGetElement(psa, &lIndices, &vElement);
        BAIL_ON_FAILURE(hr);

        if(!(V_VT(&vElement) == VT_BSTR)){
            RRETURN(E_FAIL);
        }

        //
        // unpack the BSTR in the VARIANT
        //

        hr = ADsAllocString( vElement.bstrVal, &bstrElement);

        wcscpy(pszCurrPos, (LPTSTR)bstrElement);
        pszCurrPos += wcslen(bstrElement);

        if(i < cElements-1){
            *pszCurrPos = Delimiter;
        }
        pszCurrPos++;
        ADsFreeString(bstrElement);
    }

    *pszCurrPos = L'\0';
    RRETURN(S_OK);

 error:

    RRETURN(hr);
}
HRESULT
VariantToNulledString(
    VARIANT var,
    LPTSTR *ppszString
    )

{

    LONG lIndices;
    ULONG cElements;
    ULONG  ulRequiredLength=0;
    SAFEARRAY  *psa = NULL;
    BSTR bstrElement = NULL;
    VARIANT vElement;
    LPTSTR  szCurrPos = NULL;
    HRESULT hr = S_OK;
    ULONG i;
    //
    //converts the safearray in a variant to a double nulled string
    //

    *ppszString = NULL;

    if (!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    psa = V_ARRAY(&var);

    //
    // Check that there is only one dimension in this array
    //

    if (psa->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    cElements = psa->rgsabound[0].cElements;

    if (cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    lIndices= 0;
    for(i=0; i< cElements; i++){
        lIndices = i;
        hr = SafeArrayGetElement(psa, &lIndices, &vElement);
        BAIL_ON_FAILURE(hr);

        if(!(V_VT(&vElement) == VT_BSTR)){
            RRETURN(E_FAIL);
        }

        //
        // unpack the BSTR in the VARIANT
        //

        hr = ADsAllocString( vElement.bstrVal, &bstrElement);
        BAIL_ON_FAILURE(hr);

        ulRequiredLength+= wcslen(bstrElement)+1;
        ADsFreeString(bstrElement);
    }

    ulRequiredLength +=2;

    *ppszString = (LPTSTR)AllocADsMem( ulRequiredLength*sizeof(TCHAR));
    if(*ppszString == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }
    lIndices= 0;

    szCurrPos = *ppszString;

    for(i=0; i< cElements; i++){
        lIndices = i;
        hr = SafeArrayGetElement(psa, &lIndices, &vElement);
        BAIL_ON_FAILURE(hr);

        if(!(V_VT(&vElement) == VT_BSTR)){
            RRETURN(E_FAIL);
        }

        //
        // unpack the BSTR in the VARIANT
        //

        hr = ADsAllocString( vElement.bstrVal, &bstrElement);

        wcscpy(szCurrPos, (LPTSTR)bstrElement);
        szCurrPos += wcslen(bstrElement)+1;
        ADsFreeString(bstrElement);
    }

    *szCurrPos = L'\0';
    RRETURN(S_OK);

 error:

    RRETURN(hr);
}


HRESULT
NulledStringToVariant(
    LPTSTR pszString,
    VARIANT *pvar
    )
{
    SAFEARRAYBOUND sabound[1];
    DWORD dwElements = 0;
    LPTSTR pszCurrPos = pszString;
    BOOL foundNULL = FALSE;
    LPTSTR *rgszStrings = NULL;
    SAFEARRAY *psa = NULL;
    VARIANT v;
    HRESULT hr = S_OK;
    LONG i;

    //
    // This function converts a double nulled string into a VARIANT of
    // safe arrays.
    //
    // Assumption: Valid double nulled strings are passed to this function
    //


    //
    // scan the double nulled string once to find out the dimension
    //

    while(!(*pszCurrPos == L'\0' && foundNULL)){
        if(*pszCurrPos == L'\0'){
            dwElements++;
            foundNULL = TRUE;
        }
        else{
            foundNULL = FALSE;
        }
        pszCurrPos++;
    }

    if(dwElements){
        rgszStrings = (LPTSTR *)AllocADsMem(sizeof(LPTSTR)*dwElements);
    }

    //
    // scan string again and put the appropriate pointers
    //

    pszCurrPos = pszString;
    if(rgszStrings != NULL){
        (*rgszStrings) = pszCurrPos;
    }
    foundNULL = FALSE;
    i = 1;

    while(i < (LONG)dwElements){
        if(foundNULL){
            *(rgszStrings+i) = pszCurrPos;
            i++;
        }
        if(*pszCurrPos == L'\0'){
            foundNULL = TRUE;
        }
        else{
            foundNULL = FALSE;
        }
        pszCurrPos++;
    }


    //
    // create the safearray
    //

    sabound[0].cElements = dwElements;
    sabound[0].lLbound = 0;

    psa = SafeArrayCreate(VT_VARIANT, 1, sabound);

    if (psa == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    for(i=0; i<(LONG)dwElements; i++){

        VariantInit(&v);
        V_VT(&v) = VT_BSTR;

        hr = ADsAllocString(*(rgszStrings+i), &(V_BSTR(&v)));
        BAIL_ON_FAILURE(hr);

        //
        // Stick the caller provided data into the end of the SafeArray
        //

        hr = SafeArrayPutElement(psa, &i, &v);
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

    }

    //
    // convert this safearray into a VARIANT
    //

    VariantInit(pvar);
    V_VT(pvar) = VT_ARRAY|VT_VARIANT;
    V_ARRAY(pvar) = psa;

error:
    if(rgszStrings){
        FreeADsMem(rgszStrings);
    }
    RRETURN(hr);
}



STDMETHODIMP
GenericGetPropertyManager(
    CPropertyCache * pPropertyCache,
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    DWORD dwInfoLevel;
    LPNTOBJECT pNtSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exists

    hr = pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pNtSrcObjects
                );

    BAIL_ON_FAILURE(hr);

    //
    // translate the Nt objects to variants
    //

    if (dwNumValues == 1) {

        hr = NtTypeToVarTypeCopy(
                    pNtSrcObjects,
                    pvProp
                    );

    }else {

        hr = NtTypeToVarTypeCopyConstruct(
                pNtSrcObjects,
                dwNumValues,
                pvProp
                );
    }

    BAIL_ON_FAILURE(hr);

error:

    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}

STDMETHODIMP
GenericPutPropertyManager(
    CPropertyCache * pPropertyCache,
    PPROPERTYINFO  pSchemaProps,
    DWORD dwSchemaPropSize,
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNTOBJECT pNtDestObjects = NULL;

    //
    // Issue: How do we handle multi-valued support
    //
    DWORD dwNumValues = 1;

    //
    // check if this is a legal property for this object,
    //
    //

    hr = ValidatePropertyinSchemaClass(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);


    //
    // check if this is a writeable property
    //

    hr = ValidateIfWriteableProperty(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName
                );
    BAIL_ON_FAILURE(hr);


    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNtTypeCopyConstruct(
                    dwSyntaxId,
                    &vProp,
                    1,
                    &pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    // Should use putproperty, not updateproperty -> unmarshalling from svr only
    //

    hr = pPropertyCache->putproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNtDestObjects) {
        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumValues
                );

    }

    RRETURN(hr);
}



HRESULT
BuildPrinterNameFromADsPath(
    LPWSTR pszADsParent,
    LPWSTR pszPrinterName,
    LPWSTR pszUncPrinterName
    )
{
    POBJECTINFO pObjectInfo = NULL;
    CLexer Lexer(pszADsParent);
    HRESULT hr;

        pObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    wsprintf(
        pszUncPrinterName,
        L"\\\\%s\\%s",
        pObjectInfo->ComponentArray[0],
        pszPrinterName
        );

error:
    if(pObjectInfo){
        FreeObjectInfo(pObjectInfo);
    }
    RRETURN(hr);

}

STDMETHODIMP
GenericGetExPropertyManager(
    DWORD dwObjectState,
    CPropertyCache * pPropertyCache,
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNTOBJECT pNtSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exis
    //

    if (dwObjectState == ADS_OBJECT_UNBOUND) {

        hr = pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // translate the Nds objects to variants
    //

    hr = NtTypeToVarTypeCopyConstruct(
                pNtSrcObjects,
                dwNumValues,
                pvProp
                );

    BAIL_ON_FAILURE(hr);

error:
    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}


STDMETHODIMP
GenericPutExPropertyManager(
    CPropertyCache * pPropertyCache,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    DWORD dwNumValues = 0;
    LPNTOBJECT pNtDestObjects = NULL;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;


    //
    // Issue: How do we handle multi-valued support
    //
    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY. 
    // We should dereference a VT_BYREF|VT_VARIANT once and see 
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }


    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY)) ||
        (V_VT(&vProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF))) {

        hr  = ConvertByRefSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    }else {

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    //
    // check if this is a legal property for this object,
    //
    //

    hr = ValidatePropertyinSchemaClass(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if this is a writeable property
    //


    hr = ValidateIfWriteableProperty(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName
                );
    BAIL_ON_FAILURE(hr);


    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNtTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = pPropertyCache->putproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNtDestObjects) {
        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumValues
                );

    }

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }


    RRETURN(hr);
}

HRESULT
GenericPropCountPropertyManager(
    CPropertyCache * pPropertyCache,
    PLONG plCount
    )
{
    HRESULT hr = E_FAIL;

    if (pPropertyCache) {
        hr = pPropertyCache->get_PropertyCount((PDWORD)plCount);
    }
    RRETURN(hr);
}


HRESULT
GenericNextPropertyManager(
    CPropertyCache * pPropertyCache,
    VARIANT FAR *pVariant
    )
{
    HRESULT hr = E_FAIL;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    LPNTOBJECT pNtSrcObjects = NULL;
    VARIANT varData;
    IDispatch * pDispatch = NULL;

    VariantInit(&varData);

    hr = pPropertyCache->unboundgetproperty(
                pPropertyCache->get_CurrentIndex(),
                &dwSyntaxId,
                &dwNumValues,
                &pNtSrcObjects
                );
    BAIL_ON_FAILURE(hr);

    //
    // translate the Nt objects to variants
    //

    hr = ConvertNtValuesToVariant(
                pPropertyCache->get_CurrentPropName(),
                pNtSrcObjects,
                dwNumValues,
                pVariant
                );
    BAIL_ON_FAILURE(hr);


    //
    // We're successful so far, now skip by 1
    //

    pPropertyCache->skip_propindex(
                1
                );

error:

    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
                pNtSrcObjects,
                dwNumValues
                );
    }

    RRETURN(hr);
}


HRESULT
GenericSkipPropertyManager(
    CPropertyCache * pPropertyCache,
    ULONG cElements
    )
{
    pPropertyCache->skip_propindex(
                cElements
                );
    RRETURN(S_OK);
}

HRESULT
GenericResetPropertyManager(
    CPropertyCache * pPropertyCache
    )
{
    pPropertyCache->reset_propindex();

    RRETURN(S_OK);
}


HRESULT
GenericDeletePropertyManager(
    CPropertyCache * pPropertyCache,
    VARIANT varEntry
    )
{
   HRESULT hr = S_OK;
   DWORD dwIndex = 0;

   switch (V_VT(&varEntry)) {

   case VT_BSTR:

       hr = pPropertyCache->findproperty(
                           V_BSTR(&varEntry),
                           &dwIndex
                           );
       BAIL_ON_FAILURE(hr);
       break;

   case VT_I4:
       dwIndex = V_I4(&varEntry);
       break;


   case VT_I2:
       dwIndex = V_I2(&varEntry);
       break;


   default:
       hr = E_FAIL;
       BAIL_ON_FAILURE(hr);
   }

   hr = pPropertyCache->deleteproperty(
                       dwIndex
                       );
error:
   RRETURN(hr);
}

HRESULT
GenericPutPropItemPropertyManager(
    CPropertyCache * pPropertyCache,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    VARIANT varData
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    WCHAR szPropertyName[MAX_PATH];
    LPNTOBJECT pNtDestObjects = NULL;
    DWORD dwNumValues = 0;
    DWORD dwControlCode = 0;

    hr = ConvertVariantToNtValues(
                varData,
                pSchemaProps,
                dwSchemaPropSize,
                szPropertyName,
                &pNtDestObjects,
                &dwNumValues,
                &dwSyntaxId,
                &dwControlCode
                );
    BAIL_ON_FAILURE(hr);

    if (dwControlCode != ADS_PROPERTY_UPDATE) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    //
    // Find this property in the cache
    //

    hr = pPropertyCache->findproperty(
                        szPropertyName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = pPropertyCache->addproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = pPropertyCache->putproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNtDestObjects) {
        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumValues
                );

    }

    RRETURN(hr);
}


HRESULT
GenericGetPropItemPropertyManager(
    CPropertyCache * pPropertyCache,
    DWORD dwObjectState,
    BSTR bstrName,
    LONG lnADsType,
    VARIANT * pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNTOBJECT pNtSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exis
    //

    if (dwObjectState == ADS_OBJECT_UNBOUND) {

        hr = pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // translate the Nds objects to variants
    //

    hr = ConvertNtValuesToVariant(
                bstrName,
                pNtSrcObjects,
                dwNumValues,
                pVariant
                );
    BAIL_ON_FAILURE(hr);

error:
    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}


HRESULT
GenericItemPropertyManager(
    CPropertyCache * pPropertyCache,
    DWORD dwObjectState,
    VARIANT varIndex,
    VARIANT *pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNTOBJECT pNtSrcObjects = NULL;
    LPWSTR szPropName = NULL;

    //
    // retrieve data object from cache; if one exis
    //

    switch (V_VT(&varIndex)) {

    case VT_BSTR:
        if (dwObjectState == ADS_OBJECT_UNBOUND) {

            hr = pPropertyCache->unboundgetproperty(
                        V_BSTR(&varIndex),
                        &dwSyntaxId,
                        &dwNumValues,
                        &pNtSrcObjects
                        );
            BAIL_ON_FAILURE(hr);

        }else {

            hr = pPropertyCache->getproperty(
                        V_BSTR(&varIndex),
                        &dwSyntaxId,
                        &dwNumValues,
                        &pNtSrcObjects
                        );
            BAIL_ON_FAILURE(hr);
        }

        hr = ConvertNtValuesToVariant(
                    V_BSTR(&varIndex),
                    pNtSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);
        break;


    case VT_I4:

        hr = pPropertyCache->unboundgetproperty(
                    V_I4(&varIndex),
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = pPropertyCache->get_PropName(V_I4(&varIndex));

        hr = ConvertNtValuesToVariant(
                    szPropName,
                    pNtSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);
        break;


    case VT_I2:

        hr = pPropertyCache->unboundgetproperty(
                    (DWORD)V_I2(&varIndex),
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = pPropertyCache->get_PropName(V_I2(&varIndex));

        hr = ConvertNtValuesToVariant(
                    szPropName,
                    pNtSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);

        break;





    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }

error:
    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);

}


HRESULT
GenericPurgePropertyManager(
    CPropertyCache * pPropertyCache
    )
{
    pPropertyCache->flushpropcache();
    RRETURN(S_OK);
}


HRESULT
CreatePropEntry(
    LPWSTR szPropName,
    ADSTYPE dwADsType,
    VARIANT varData,
    REFIID riid,
    LPVOID * ppDispatch
    )

{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;

    hr = CoCreateInstance(
                CLSID_PropertyEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsPropertyEntry,
                (void **)&pPropEntry
                );
    BAIL_ON_FAILURE(hr);


    hr = pPropEntry->put_Name(szPropName);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_Values(varData);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_ADsType(dwADsType);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->QueryInterface(
                        riid,
                        ppDispatch
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pPropEntry) {
        pPropEntry->Release();
    }

    RRETURN(hr);

}



HRESULT
ConvertNtValuesToVariant(
    LPWSTR szPropertyName,
    PNTOBJECT pNtSrcObject,
    DWORD dwNumValues,
    PVARIANT pVariant
    )
{
    HRESULT hr = S_OK;
    VARIANT varData;
    IDispatch * pDispatch = NULL;
    PADSVALUE pAdsValues = NULL;
    ADSTYPE dwADsType = ADSTYPE_INVALID;

    VariantInit(&varData);
    VariantInit(pVariant);

    if (dwNumValues>0) {

        hr = NTTypeToAdsTypeCopyConstruct(
                pNtSrcObject,
                dwNumValues,
                &pAdsValues 
                );

        if (SUCCEEDED(hr)){
        
            hr = AdsTypeToPropVariant(
                    pAdsValues,
                    dwNumValues,
                    &varData
                    );
            BAIL_ON_FAILURE(hr);
    
            dwADsType = pAdsValues->dwType;
        }

        else if (hr==E_OUTOFMEMORY) {
            
            BAIL_ON_FAILURE(hr);
        }

        // failed because of NTType is not supported yet (e.g. NulledString) 
        // in NTTypeToAdsTypeCopyConstruct() conversion yet
        // -> use empty variant now.
        else {

            VariantInit(&varData);
        }
    }
    
    hr = CreatePropEntry(
            szPropertyName,
            dwADsType,
            varData,
            IID_IDispatch,
            (void **)&pDispatch
            );
    BAIL_ON_FAILURE(hr);


    V_DISPATCH(pVariant) = pDispatch;
    V_VT(pVariant) = VT_DISPATCH;

error:

    VariantClear(&varData);

    if (pAdsValues) {
        AdsFreeAdsValues(
            pAdsValues,
            dwNumValues
            );
        FreeADsMem( pAdsValues);
    }

    RRETURN(hr);
}



HRESULT
ConvertVariantToVariantArray(
    VARIANT varData,
    VARIANT ** ppVarArray,
    DWORD * pdwNumValues
    )
{
    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    HRESULT hr = S_OK;
    VARIANT * pVarData = NULL;
    
    *ppVarArray = NULL;
    *pdwNumValues = 0;

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY. 
    // We should dereference a VT_BYREF|VT_VARIANT once and see 
    // what's inside.
    //
    pVarData = &varData;
    if (V_VT(pVarData) == (VT_BYREF|VT_VARIANT)) {
        pVarData = V_VARIANTREF(&varData);
    }

    if ((V_VT(pVarData) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
        (V_VT(pVarData) == (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertSafeArrayToVariantArray(
                  varData,
                  &pVarArray,
                  &dwNumValues
                  );
        BAIL_ON_FAILURE(hr);

    } else {

        pVarArray = NULL;
        dwNumValues = 0;
    }

    *ppVarArray = pVarArray;
    *pdwNumValues = dwNumValues;

error:
    RRETURN(hr);
}

void
FreeVariantArray(
    VARIANT * pVarArray,
    DWORD dwNumValues
    )
{
    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }
}

HRESULT
ConvertVariantToNtValues(
    VARIANT varData,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    LPWSTR szPropertyName,
    PNTOBJECT *ppNtDestObjects,
    PDWORD pdwNumValues,
    PDWORD pdwSyntaxId,
    PDWORD pdwControlCode
    )
{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;
    IDispatch * pDispatch = NULL;
    BSTR bstrPropName = NULL;
    DWORD dwControlCode = 0;
    DWORD dwAdsType = 0;
    VARIANT varValues;
    VARIANT * pVarArray = NULL;
    DWORD dwNumValues = 0;
    PADSVALUE pAdsValues = NULL;
    DWORD dwAdsValues  = 0;

    PNTOBJECT pNtDestObjects = 0;
    DWORD dwNumNtObjects = 0;
    DWORD dwNtSyntaxId = 0;

    if (V_VT(&varData) != VT_DISPATCH) {
        RRETURN (hr = DISP_E_TYPEMISMATCH);
    }

    pDispatch = V_DISPATCH(&varData);

    hr = pDispatch->QueryInterface(
                        IID_IADsPropertyEntry,
                        (void **)&pPropEntry
                        );
    BAIL_ON_FAILURE(hr);

    VariantInit(&varValues);
    VariantClear(&varValues);


    hr = pPropEntry->get_Name(&bstrPropName);
    BAIL_ON_FAILURE(hr);
    wcscpy(szPropertyName, bstrPropName);

    hr = pPropEntry->get_ControlCode((long *)&dwControlCode);
    BAIL_ON_FAILURE(hr);
    *pdwControlCode = dwControlCode;

    hr = pPropEntry->get_ADsType((long *)&dwAdsType);
    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->get_Values(&varValues);
    BAIL_ON_FAILURE(hr);

    hr = ConvertVariantToVariantArray(
            varValues,
            &pVarArray,
            &dwNumValues
            );
    BAIL_ON_FAILURE(hr);

    if (dwNumValues) {
        hr = PropVariantToAdsType(
                    pVarArray,
                    dwNumValues,
                    &pAdsValues,
                    &dwAdsValues
                    );
        BAIL_ON_FAILURE(hr);

        hr = AdsTypeToNTTypeCopyConstruct(
                    pAdsValues,
                    dwAdsValues,
                    &pNtDestObjects,
                    &dwNumNtObjects,
                    &dwNtSyntaxId
                    );
        BAIL_ON_FAILURE(hr);

    }

    *pdwNumValues = dwNumValues;
    *ppNtDestObjects = pNtDestObjects;
    *pdwSyntaxId = dwNtSyntaxId;

error:

    if (pVarArray) {
        FreeVariantArray(
                pVarArray,
                dwNumValues
                );
    }

    RRETURN(hr);
}

HRESULT
ConvertNtValuesToVariant(
    BSTR bstrName,
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumValues,
    VARIANT * pVariant
    );


HRESULT
ConvertVariantToVariantArray(
    VARIANT varData,
    VARIANT ** ppVarArray,
    DWORD * pdwNumValues
    );

void
FreeVariantArray(
    VARIANT * pVarArray,
    DWORD dwNumValues
    );

HRESULT
ConvertVariantToNtValues(
    VARIANT varData,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    LPWSTR szPropertyName,
    PNTOBJECT *ppNtDestObjects,
    PDWORD pdwNumValues,
    PDWORD pdwSyntaxId
    );


HRESULT
CheckAndSetExtendedError(
    DWORD dwRetval
    )

{
    DWORD dwLastError;
    WCHAR pszError[MAX_PATH];
    WCHAR pszProviderName[MAX_PATH];
    INT   numChars;
    HRESULT hr =S_OK;

    wcscpy(pszError, L"");
    wcscpy(pszProviderName, L"");

    if (NWCCODE_SUCCESS(dwRetval)){
        hr = S_OK;

    } else {

        hr = HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR);

        numChars = LoadString( g_hInst,
                               NW_PROVIDER_ID,
                               pszProviderName,
                               MAX_PATH -1);

        //
        // Set the default error string

        wsprintf (pszError, L"NW ccode = %x", dwRetval);

        ADsSetLastError(
            dwRetval,
            pszError,
            pszProviderName
            );
    }

    RRETURN(hr);
}


HRESULT
InitializeNWLibrary(
    void
    )
{
    NWDSCCODE ccode;
    HRESULT hr = S_OK;
    LCONV lConvInfo;

    ccode = NWCallsInit(NULL, NULL);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    ccode = NWCLXInit(NULL, NULL);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

error:

    RRETURN(hr);
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cnamesp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cnamesp.cxx
//
//  Contents:  Windows NT 3.5 Namespace Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


DEFINE_IDispatch_Implementation(CNWCOMPATNamespace)
DEFINE_IADs_Implementation(CNWCOMPATNamespace)

//  Class CNWCOMPATNamespace

CNWCOMPATNamespace::CNWCOMPATNamespace()
{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CNWCOMPATNamespace);
}

HRESULT
CNWCOMPATNamespace::CreateNamespace(
    BSTR Parent,
    BSTR NamespaceName,
    CCredentials &Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATNamespace FAR * pNamespace = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNamespaceObject(&pNamespace);
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->InitializeCoreObject(
                         Parent,
                         NamespaceName,
                         NAMESPACE_CLASS_NAME,
                         NO_SCHEMA,
                         CLSID_NWCOMPATNamespace,
                         dwObjectState
                         );
    BAIL_ON_FAILURE(hr);

    pNamespace->_Credentials = Credentials;

    hr = pNamespace->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNamespace->Release();  // <- WHY?

    RRETURN(hr);

error:

    delete pNamespace;
    NW_RRETURN_EXP_IF_ERR(hr);
}


CNWCOMPATNamespace::~CNWCOMPATNamespace( )
{
    delete _pDispMgr;
    VariantClear(&_vFilter);
}

STDMETHODIMP
CNWCOMPATNamespace::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *)this;
    }else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsOpenDSObject))
    {
        *ppv = (IADsOpenDSObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPathnameProvider)) 
    {
        *ppv = (IADsPathnameProvider FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CNWCOMPATNamespace::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CNWCOMPATNamespace::SetInfo(
    THIS
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::GetInfo(
    THIS
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CNWCOMPATNamespace::get_Count(
    long FAR* retval
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::get_Filter(
    THIS_ VARIANT FAR* pVar
    )
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATNamespace::put_Filter(
    THIS_ VARIANT Var
    )
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATNamespace::put_Hints(THIS_ VARIANT Var)
{
    NW_RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATNamespace::get_Hints(THIS_ VARIANT FAR* pVar)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    WCHAR szBuffer[MAX_PATH];
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        NW_RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"//");
    wcscat(szBuffer, RelativeName);

    if (ClassName && *ClassName) {
        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                _Credentials,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:

    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATNamespace::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CNWCOMPATNamespaceEnum::Create(
                                     _Credentials,
                                     (CNWCOMPATNamespaceEnum **)&penum
                                     );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    return NOERROR;

error:

    if (penum) {
        delete penum;
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATNamespace::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::Delete(
    THIS_ BSTR SourceName,
    BSTR Type
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CNWCOMPATNamespace::AllocateNamespaceObject(
    CNWCOMPATNamespace ** ppNamespace
    )
{
    CNWCOMPATNamespace FAR * pNamespace = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNamespace = new CNWCOMPATNamespace();
    if (pNamespace == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADs,
             (IADs *)pNamespace,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsOpenDSObject,
                           (IADsOpenDSObject *)pNamespace,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsContainer,
             (IADsContainer *)pNamespace,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    pNamespace->_pDispMgr = pDispMgr;
    *ppNamespace = pNamespace;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CNWCOMPATNamespace::OpenDSObject(
    BSTR lpszDNName,
    BSTR lpszUserName,
    BSTR lpszPassword,
    LONG lnReserved,
    IDispatch FAR * * ppADsObj
    )
{

    HRESULT hr = S_OK;
    IUnknown * pObject = NULL;
    CCredentials Credentials(lpszUserName, lpszPassword, 0L);

    hr = ::GetObject(
                lpszDNName,
                Credentials,
                (LPVOID *)&pObject
                );
    BAIL_ON_FAILURE(hr);



    hr = pObject->QueryInterface(
                        IID_IDispatch,
                        (void **)ppADsObj
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pObject) {
        pObject->Release();
    }

    RRETURN(hr);
}



HRESULT
CNWCOMPATNamespace::ParsePath(
    BSTR bstrADsPath, 
    DWORD dwType, 
    PPATH_OBJECTINFO pObjectInfo
    )

/*++

Routine Description:

    Parse a path based on the type and return the information in pObjectInfo

Arguments:

    bstrADsPath - ads path to be parsed
    dwType - the type of path to be parsed:
                   ADS_PARSE_FULL
                   ADS_PARSE_DN
                   ADS_PARSE_COMPONENT
    pObjectInfo - the place where the parsed object is stored
    
Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;
    OBJECTINFO ObjInfo;
    POBJECTINFO pObjInfo = &ObjInfo;
    PWSTR szPath = NULL;

    memset(pObjInfo, 0, sizeof(OBJECTINFO));

    switch (dwType) {
        case ADS_PARSE_FULL:
        {
            CLexer Lexer(bstrADsPath);

            hr = Object(&Lexer, pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        case ADS_PARSE_DN:
        {
            WCHAR szToken[MAX_TOKEN_LENGTH];
            DWORD dwToken;

            //
            // Collecting new information
            //
            CLexer Lexer(bstrADsPath);

            Lexer.SetAtDisabler(TRUE);

            hr = PathName(&Lexer,
                          pObjInfo);
            BAIL_ON_FAILURE(hr);

            hr = Lexer.GetNextToken(szToken,
                                    &dwToken);
            BAIL_ON_FAILURE(hr);

            if (dwToken != TOKEN_END) {
                hr = E_ADS_BAD_PATHNAME;
            }
            break;
        }

        case ADS_PARSE_COMPONENT:
        {
            CLexer Lexer(bstrADsPath);
        
            Lexer.SetAtDisabler(TRUE);
        
            hr = Component(&Lexer,
                           pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        default:
            break;
    }

    //
    // Setting new info
    //
    if (pObjInfo->ProviderName) {
        pObjectInfo->ProviderName = AllocADsStr(pObjInfo->ProviderName);
        if (!pObjectInfo->ProviderName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = SetObjInfoComponents(pObjInfo,
                              pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pObjectInfo->NumComponents = pObjInfo->NumComponents;
    pObjectInfo->dwPathType = ADS_PATHTYPE_ROOTFIRST;

error:
    FreeObjectInfo(pObjInfo,TRUE);
    if (szPath != NULL) {
        FreeADsStr(szPath);
    }
    return (hr);
}

HRESULT
CNWCOMPATNamespace::SetObjInfoComponents(
                        OBJECTINFO *pObjectInfo,
                        PATH_OBJECTINFO *pObjectInfoTarget
                        )

/*++

Routine Description:

    Set all the compoents in an objinfo from another objinfo. Assumes that the 
    components in the target objinfo is empty. Users of this function can call 
    FreeObjInfo to free that data prior to this function call.

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;
    HRESULT hr = S_OK;

    NumComponents = 0;
    while (NumComponents < pObjectInfo->NumComponents) {
        if (pObjectInfo->ComponentArray[NumComponents]) {
            pObjectInfoTarget->ComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents]);
            if (pObjectInfoTarget->ComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents]) {
            pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->DisplayComponentArray[NumComponents]);
            if (pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        NumComponents++;
    }
    pObjectInfoTarget->NumComponents = pObjectInfo->NumComponents;
    return hr;

error:
    FreeObjInfoComponents(pObjectInfoTarget);

    RRETURN_EXP_IF_ERR(hr);
}

void
CNWCOMPATNamespace::FreeObjInfoComponents(
                    PATH_OBJECTINFO *pObjectInfo
                    )

/*++

Routine Description:

    Free all the compoents in an objinfo

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;

    while (pObjectInfo->NumComponents > 0) {
        pObjectInfo->NumComponents--;
        NumComponents = pObjectInfo->NumComponents;

        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szComponent);
            pObjectInfo->ComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szValue);
            pObjectInfo->ComponentArray[NumComponents].szValue = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            pObjectInfo->DisplayComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            pObjectInfo->DisplayComponentArray[NumComponents].szValue = NULL;
        }
    }
}

void 
CNWCOMPATNamespace::SetComponent(
                    LPWSTR szReturn,
                    DWORD cComponents,
                    BOOL fEscaped
                    )

/*++

Routine Description:

    Set an individual component in the pathname. For internal use only. 
    Not exposed.

Arguments:
    
    szReturn - the buffer to store the return value
    cComponents - the component number to be set

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    PATH_COMPONENT* pComponent = NULL;
    if (fEscaped) {
        pComponent = _pObjectInfo->DisplayComponentArray;
    }
    else {
        pComponent = _pObjectInfo->ComponentArray;
    }

    if (pComponent[cComponents].szValue) {
        //
        // If value exist, only show display value
        //
        wcscat(szReturn,
               pComponent[cComponents].szValue);
    }
    else {
        //
        // else value is only stored in Component
        //
        wcscat(szReturn,
               pComponent[cComponents].szComponent);
    }
}


HRESULT 
CNWCOMPATNamespace::SetComponents(
                            LPWSTR szReturn,
                            LPWSTR chSeparator,
                            DWORD dwType,
                            BOOL fEscaped
                            )
/*++

Routine Description:

    Set components in the pathname. For internal use only. Not exposed.

Arguments:

    szReturn - the buffer to store the return value
    chSeparator - separator to be used
    dwType - the type to be set
        ADS_COMPONENT_LEAF
        ADS_COMPONENT_DN
        ADS_COMPONENT_PARENT


Return Value:

    S_OK on success, error code otherwise.

--*/
{
    HRESULT hr = S_OK;
    long cComponents;
    long dwLimit;
    long dwOtherLimit = 0;

    if (dwType == ADS_COMPONENT_LEAF) {
        //
        // Only returns the leaf component
        //
        if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
            if (_pObjectInfo->NumComponents > 0) {
                SetComponent(szReturn,
                             _pObjectInfo->NumComponents - 1,
                             fEscaped);
            } 
            else {
                hr = E_ADS_BAD_PATHNAME;
            }
        }
        else {
            if (_pObjectInfo->NumComponents != 0) {
                SetComponent(szReturn,
                             0,
                             fEscaped);
            } 
            else {
                hr = E_ADS_BAD_PATHNAME;
            }

        }
        RRETURN(hr);
    }

    dwLimit = _pObjectInfo->NumComponents;
    if (dwType == ADS_COMPONENT_PARENT) {
        dwLimit--;
    }
    if (dwOtherLimit >= dwLimit) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }
    for (cComponents = dwOtherLimit; cComponents < dwLimit; cComponents++) {
        SetComponent(szReturn,
                     cComponents,
                     fEscaped);
        if (cComponents != dwLimit - 1) {
            wcscat(szReturn,
                   chSeparator);
        }
    }
error:
    RRETURN(S_OK);
}

DWORD CountPath(
    PPATH_OBJECTINFO pObjectInfo
)
{
    DWORD dwPath = 4;   // Basic needs '://' and '/' for servername
    DWORD i;

    if (pObjectInfo->ProviderName) {
        dwPath += wcslen(pObjectInfo->ProviderName);
    }
    if (pObjectInfo->DisplayServerName) {
        dwPath += wcslen(pObjectInfo->DisplayServerName);
    }
    for (i=0;i<pObjectInfo->NumComponents;i++) {
        if (pObjectInfo->DisplayComponentArray[i].szComponent) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szComponent);
        }
        if (pObjectInfo->DisplayComponentArray[i].szValue) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szValue);
        }

        //
        // Add one for comma separator, one for equal sign
        //
        dwPath+=2; 
    }
    return dwPath;
}


STDMETHODIMP
CNWCOMPATNamespace::ConstructPath(
    PPATH_OBJECTINFO pObjectInfo,
    DWORD dwFormatType,
    DWORD dwFlag,
    DWORD dwEscapedMode,
    BSTR *pbstrADsPath
    )
{
    HRESULT hr = S_OK;
    PWSTR szReturn = NULL;
    long cComponents;
    DWORD dwPath = 0;
    BOOL fEscaped = FALSE;

    switch (dwEscapedMode) {
        case ADS_ESCAPEDMODE_OFF:
        case ADS_ESCAPEDMODE_DEFAULT:
        case ADS_ESCAPEDMODE_OFF_EX:
            fEscaped = FALSE;
            break;
        case ADS_ESCAPEDMODE_ON:
            fEscaped = TRUE;
            break;
        default:
            hr = E_INVALIDARG;
            goto error;
    }

    if (!pbstrADsPath) {
        hr = E_INVALIDARG;
        goto error;
    }

    dwPath = CountPath(pObjectInfo);
    szReturn = (PWSTR)AllocADsMem((dwPath + 1)* sizeof(WCHAR));
    if (szReturn == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    _pObjectInfo = pObjectInfo;

    wcscpy(szReturn,TEXT(""));

    switch (dwFormatType) {
        case ADS_FORMAT_WINDOWS:
        case ADS_FORMAT_WINDOWS_NO_SERVER:
            if (dwEscapedMode == ADS_ESCAPEDMODE_DEFAULT) {
                fEscaped = TRUE;
            }
            if (!pObjectInfo->ProviderName) {
                hr = E_FAIL;        // Need Error Code
                goto error;
            }
            wcscat(szReturn,pObjectInfo->ProviderName);
            wcscat(szReturn,TEXT("://"));

            if (dwFormatType == ADS_FORMAT_WINDOWS) {
                if (pObjectInfo->DisplayServerName && (*(pObjectInfo->DisplayServerName))) {
                    wcscat(szReturn,pObjectInfo->DisplayServerName);
                    if (pObjectInfo->NumComponents>0) {
                        wcscat(szReturn,TEXT("/"));
                    }
                }
            }
            hr = SetComponents(szReturn,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_DN:
            hr = SetComponents(szReturn,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_PARENT:
            hr = SetComponents(szReturn,
                               TEXT("/"),
                               ADS_COMPONENT_PARENT,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_X500:
        case ADS_FORMAT_X500_NO_SERVER:
        case ADS_FORMAT_X500_DN:
        case ADS_FORMAT_X500_PARENT:
            hr = E_NOTIMPL;
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_LEAF:
            //
            // Reverse only if pathtype is X500. In that case, we need to get
            // the first element but not the last
            //
            hr = SetComponents(szReturn,
                               NULL,
                               ADS_COMPONENT_LEAF,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        default:
            hr = E_INVALIDARG;
            goto error;
    }
    hr = ADsAllocString(szReturn, pbstrADsPath);
error:
    if (szReturn) {
        FreeADsMem(szReturn);
    }
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNWCOMPATNamespace::GetEscapedElement(
    LONG lnReserved,
    BSTR bstrInStr,
    BSTR* pbstrOutStr
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cpgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cpgi.cxx
//
//  Contents:
//
//  History:   30-Apr-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//
// Properties Get & Set.
//

STDMETHODIMP
CNWCOMPATPrintQueue::get_Model(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_Model(THIS_ BSTR bstrModel)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_Datatype(THIS_ BSTR *retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_Datatype(THIS_ BSTR bstrDatatype)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_Location(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_Location(THIS_ BSTR bstrLocation)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_Priority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_Priority(THIS_ LONG lPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_StartTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_StartTime(THIS_ DATE daStartTime)
{
    //
    // BUGBUG: long assigned a date(double) value. NT INFO structures
    // handle long only. ADS specs say double.
    //

    PUT_PROPERTY_DATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_UntilTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_UntilTime(THIS_ DATE daUntilTime)
{
    //
    // BUGBUG: long assigned a date(double) value. NT INFO structures
    // handle long only. ADS specs say double.
    //

    PUT_PROPERTY_DATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_DefaultJobPriority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, DefaultJobPriority);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_DefaultJobPriority(THIS_ LONG lDefaultJobPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, DefaultJobPriority);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_BannerPage(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_BannerPage(THIS_ BSTR bstrBannerPage)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_PrinterPath(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, PrinterPath);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_PrinterPath(THIS_ BSTR bstrPrinterPath)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, PrinterPath);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_PrintProcessor(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, PrintProcessor);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_PrintProcessor(THIS_ BSTR bstrPrintProcessor)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_PrintDevices(THIS_ VARIANT FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_PrintDevices(THIS_ VARIANT vPorts)
{
    PUT_PROPERTY_VARIANT((IADsPrintQueue *)this, Ports);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_NetAddresses(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsPrintQueue *)this, NetAddresses );
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_NetAddresses(THIS_ VARIANT vNetAddresses )
{
    PUT_PROPERTY_VARIANT((IADsPrintQueue *)this, NetAddresses );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cnamcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  NetWare compatible Namespace Object Class Factory Code
//
//             CNWCOMPATNamespaceCF::CreateInstance
//
//  History:   Mar-04-96     t-ptam    Migrated.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATNamespaceCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    Mar-04-96   t-ptam     Migrated.
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATNamespaceCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;
    CCredentials Credentials;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CNWCOMPATNamespace::CreateNamespace(
                                 L"ADs:",
                                 L"NWCOMPAT:",
                                 Credentials,
                                 ADS_OBJECT_BOUND,
                                 iid,
                                 ppv
                                 );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cpop.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cpop.cxx
//
//  Contents:
//
//  History:   30-Apr-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::PrintJobs
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::PrintJobs(
    THIS_ IADsCollection FAR* FAR* ppCollection
    )
{
    HRESULT hr = S_OK;

    //
    // Get Job collection object.
    //

    hr = CNWCOMPATJobCollection::CreateJobCollection(
             _Parent,
             _Name,
             _Credentials,
             IID_IADsCollection,
             (void **)ppCollection
             );

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::Pause
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::Pause(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;
    WCHAR szUncPrinterName[MAX_PATH];

    //
    // Make Unc printer name.
    //

    hr = get_CoreADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = NWApiUncFromADsPath(
             bstrADsPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Pause printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_PAUSE
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    ADSFREESTRING(bstrADsPath);

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::Resume
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::Resume(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;
    WCHAR szUncPrinterName[MAX_PATH];

    //
    // Make Unc printer name.
    //

    hr = get_CoreADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = NWApiUncFromADsPath(
             bstrADsPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Resume printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_RESUME
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::Purge
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::Purge(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;
    WCHAR szUncPrinterName[MAX_PATH];

    //
    // Make Unc printer name.
    //

    hr = get_CoreADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = NWApiUncFromADsPath(
             bstrADsPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Purge printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_PURGE
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::get_Status
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::get_Status(
    THIS_ long FAR* retval
    )
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cprinter.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:  cprinter.cxx
//
//  Contents:  CNWCOMPATPrinter
//
//
//  History:   30-Apr-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop


//
// Printer Class
//


//
// Macro-ized implementation.
//

DEFINE_IDispatch_Implementation(CNWCOMPATPrintQueue)

DEFINE_IADs_TempImplementation(CNWCOMPATPrintQueue)

DEFINE_IADs_PutGetImplementation(CNWCOMPATPrintQueue, PrintQueueClass, gdwPrinterTableSize)

DEFINE_IADsPropertyList_Implementation(CNWCOMPATPrintQueue, PrintQueueClass, gdwPrinterTableSize)



//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::CNWCOMPATPrintQueue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATPrintQueue::CNWCOMPATPrintQueue():
    _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNWCOMPATPrintQueue);
    _pPropertyCache = NULL;
    _hConn = NULL;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::~CNWCOMPATPrintQueue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATPrintQueue::~CNWCOMPATPrintQueue()
{
    delete _pDispMgr;
    delete _pPropertyCache;

    if (_hConn)
        NWApiReleaseBinderyHandle(_hConn);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue:: CreatePrintQueue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintQueue:: CreatePrintQueue(
    LPTSTR pszADsParent,
    LPTSTR pszPrinterName,
    CCredentials &Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    LPVOID * ppvoid
    )
{
    CNWCOMPATPrintQueue *pPrintQueue =  NULL;
    HRESULT hr = S_OK;
    LPWSTR lpszTempName = NULL;
    POBJECTINFO pObjectInfo = NULL;

    //
    // Create the printer object
    //

    hr = AllocatePrintQueueObject(
             &pPrintQueue
             );
    BAIL_ON_FAILURE(hr);

    //
    // Initialize the core object
    //

    hr = pPrintQueue->InitializeCoreObject(
                          pszADsParent,
                          pszPrinterName,
                          PRINTER_CLASS_NAME,
                          PRINTER_SCHEMA_NAME,
                          CLSID_NWCOMPATPrintQueue,
                          dwObjectState
                          );
    BAIL_ON_FAILURE(hr);

    //
    // Credentials
    //
    pPrintQueue->_Credentials = Credentials;

    //
    // Componentize ADs name.
    //

    hr = BuildObjectInfo(
             pPrintQueue->_Parent,
             pPrintQueue->_Name,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get a handle to the bindery this object resides on.
    //

    hr = NWApiGetBinderyHandle(
             &pPrintQueue->_hConn,
             pObjectInfo->ComponentArray[0],
             pPrintQueue->_Credentials
             );
    BAIL_ON_FAILURE(hr);


    //
    // Query for the specified interface.
    //

    hr = pPrintQueue->QueryInterface(
                          riid,
                          (void **)ppvoid
                          );
    BAIL_ON_FAILURE(hr);

    //
    // Make Unc Printer name for Win32 API.
    //

    hr = BuildPrinterNameFromADsPath(
                pszADsParent,
                pszPrinterName,
                pPrintQueue->_szUncPrinterName
                );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    pPrintQueue->Release();

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);

error:
    if (pObjectInfo)
        FreeObjectInfo(pObjectInfo);

    delete pPrintQueue;
    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::QueryInterface(
    REFIID riid,
    LPVOID FAR* ppvObj
    )
{
    if(!ppvObj)
    {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsPrintQueue FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsPrintQueue FAR *)this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsPrintQueue FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintQueue))
    {
        *ppvObj = (IADsPrintQueue FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintQueueOperations))
    {
        *ppvObj = (IADsPrintQueueOperations FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::InterfaceSupportsErrorInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsPrintQueue) ||
        IsEqualIID(riid, IID_IADsPrintQueueOperations) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::SetInfo(THIS)
{
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    LPBYTE  lpbBuffer = NULL;

    //
    // Make sure object is bound to a tangible resource.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
       /*
        hr = NWApiAddPrinter();
        BAIL_ON_FAILURE(hr);
       */
        SetObjectState(ADS_OBJECT_BOUND);
    }

    //
    // Open a handle to a printer.
    //

    hr = NWApiOpenPrinter(
             _szUncPrinterName,
             &hPrinter,
             PRINTER_ALL_ACCESS
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get Printer Info structure.
    //

    hr = NWApiGetPrinter(
             hPrinter,
             WIN32_API_LEVEL_2,
             &lpbBuffer
             );
    BAIL_ON_FAILURE(hr);

    //
    // Set info.
    //

    hr = MarshallAndSet(
             hPrinter,
             (LPPRINTER_INFO_2) lpbBuffer
             );
error:

    //
    // Close Printer handle.
    //

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (lpbBuffer) {
        FreeADsMem((void*)lpbBuffer);
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::GetInfo(THIS)
{

    _pPropertyCache->flushpropcache();

    RRETURN (GetInfo(
                 TRUE,
                 PRINTER_API_LEVEL
                 ));
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::AllocatePrintQueueObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintQueue::AllocatePrintQueueObject(
    CNWCOMPATPrintQueue FAR * FAR * ppPrintQueue
    )
{
    CNWCOMPATPrintQueue FAR * pPrintQueue = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a PrintQueue object.
    //

    pPrintQueue = new CNWCOMPATPrintQueue();
    if (pPrintQueue == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPrintQueue,
             (IADsPrintQueue *) pPrintQueue,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPrintQueueOperations,
             (IADsPrintQueueOperations *) pPrintQueue,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPropertyList,
             (IADsPropertyList *) pPrintQueue,
             DISPID_VALUE
             );
    BAIL_ON_FAILURE(hr);



    //
    // Return.
    //

    hr = CPropertyCache::createpropertycache(
             PrintQueueClass,
             gdwPrinterTableSize,
             (CCoreADsObject *)pPrintQueue,
             &(pPrintQueue->_pPropertyCache)
             );
    BAIL_ON_FAILURE(hr);

    pPrintQueue->_pDispMgr = pDispMgr;
    *ppPrintQueue = pPrintQueue;

    RRETURN(hr);

error:
    delete  pDispMgr;
    delete  pPrintQueue;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::GetInfo(
    THIS_ BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    LPBYTE  lpbPrinterInfo = NULL;

    //
    // Open a handle to a printer.
    //

    hr = NWApiOpenPrinter(
             _szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get printer's info.
    //

    hr = NWApiGetPrinter(
             hPrinter,
             WIN32_API_LEVEL_2,
             &lpbPrinterInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Unmarshall.
    //

    hr = UnMarshall_GeneralInfo(
             (LPPRINTER_INFO_2) lpbPrinterInfo,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

    hr = UnMarshall_Operation(
             (LPPRINTER_INFO_2) lpbPrinterInfo,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

error:

    if(lpbPrinterInfo){
        FreeADsMem(lpbPrinterInfo);
    }
    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::UnMarshall_GeneralInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintQueue::UnMarshall_GeneralInfo(
    LPPRINTER_INFO_2 lpPrinterInfo2,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    DATE daStartTime = 0;
    DATE daUntilTime = 0;
    VARIANT vPortNames;

   hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("PrinterPath"),
                                  _szUncPrinterName,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Model"),
                                  lpPrinterInfo2->pDriverName,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Datatype"),
                                  lpPrinterInfo2->pDatatype,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("PrintProcessor"),
                                  lpPrinterInfo2->pPrintProcessor,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Description"),
                                  lpPrinterInfo2->pComment,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Location"),
                                  lpPrinterInfo2->pLocation,
                                  fExplicit
                                  );

    hr = SetDATEPropertyInCache(_pPropertyCache,
                                TEXT("StartTime"),
                                lpPrinterInfo2->StartTime,
                                fExplicit
                                );

    hr = SetDATEPropertyInCache(_pPropertyCache,
                                  TEXT("UntilTime"),
                                  lpPrinterInfo2->UntilTime,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("DefaultJobPriority"),
                                 lpPrinterInfo2->DefaultPriority,
                                 fExplicit
                                 );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("Priority"),
                                  lpPrinterInfo2->Priority,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("BannerPage"),
                                  lpPrinterInfo2->pSepFile,
                                  fExplicit
                                  );

    hr = SetDelimitedStringPropertyInCache(_pPropertyCache,
                                           TEXT("PrintDevices"),
                                           lpPrinterInfo2->pPortName,
                                           fExplicit
                                           );

    hr = S_OK;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::UnMarshall_Operation
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintQueue::UnMarshall_Operation(
    LPPRINTER_INFO_2 lpPrinterInfo2,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("Status"),
                                  lpPrinterInfo2->Status,
                                  fExplicit
                                  );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue:: MarshallAndSet
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintQueue::MarshallAndSet(
    HANDLE hPrinter,
    LPPRINTER_INFO_2 lpPrinterInfo2
    )
{
    LPTSTR              pszDriverName = NULL;
    LPTSTR              pszDatatype = NULL;
    LPTSTR              pszDescription = NULL;
    LPTSTR              pszLocation = NULL;
    LPTSTR              pszBannerPage = NULL;
    LPTSTR              pszHostComputer = NULL;
    LPTSTR              pszPrintProcessor = NULL;
    HRESULT           hr = S_OK;
    LPTSTR            pszPorts = NULL;
    VARIANT           vTemp;
    DWORD             dwTimeValue;
    DWORD             dwPriority;

    //
    // Set Model.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Model"),
                    &pszDriverName
                    );
    if (SUCCEEDED(hr)){
        lpPrinterInfo2->pDriverName = (LPTSTR)pszDriverName;
    }

    //
    // Set Datatype.
    //
    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Datatype"),
                    &pszDatatype
                    );
    if (SUCCEEDED(hr)){
        lpPrinterInfo2->pDatatype = (LPTSTR)pszDatatype;
    }

    //
    // Set Description.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );
    if (SUCCEEDED(hr)){
        lpPrinterInfo2->pComment = (LPTSTR)pszDescription;
    }

    //
    // Set Location.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Location"),
                    &pszLocation
                    );
    if (SUCCEEDED(hr)){
        lpPrinterInfo2->pLocation = (LPTSTR)pszLocation;
    }

    //
    // Set Priority.
    //

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Priority"),
                    &dwPriority
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->Priority = dwPriority;
    }

    //
    // Set StartTime.
    //

    hr = GetDATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("StartTime"),
                    &dwTimeValue
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->StartTime = dwTimeValue;
    }


    //
    // Set UntilTime.
    //
    hr = GetDATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("UntilTime"),
                    &dwTimeValue
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->UntilTime = dwTimeValue;
    }


    //
    // Set DefaultJobPriority.
    //

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("DefaultJobPriority"),
                    &dwPriority
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->DefaultPriority = dwPriority;
    }


    //
    // Set BannerPage.
    //
    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("BannerPage"),
                    &pszBannerPage
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->pSepFile = pszBannerPage;
    }


    //
    // Set PrintProcessor.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PrintProcessor"),
                    &pszPrintProcessor
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->pPrintProcessor = pszPrintProcessor;
    }

    //
    // Set Ports.
    //


    hr = GetDelimitedStringPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PrintDevices"),
                    &pszPorts
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->pPortName = pszPorts;
    }


    //
    // Commit changes.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             WIN32_API_LEVEL_2,
             (LPBYTE) lpPrinterInfo2,
             0
             );
    BAIL_ON_FAILURE(hr);

error:
    if(pszDriverName)
        FreeADsStr(pszDriverName);
    if(pszDatatype)
        FreeADsStr(pszDatatype);
    if(pszDescription)
        FreeADsStr(pszDescription);
    if(pszLocation)
        FreeADsStr(pszLocation);
    if(pszBannerPage)
        FreeADsStr(pszBannerPage);
    if(pszPrintProcessor)
        FreeADsStr(pszPrintProcessor);
    if(pszPorts)
        FreeADsStr(pszPorts);


    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cprops.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cprops.cxx
//
//  Contents:   Property Cache functionality for NW
//
//  Functions:
//                CPropertyCache::addproperty
//                CPropertyCache::updateproperty
//                CPropertyCache::findproperty
//                CPropertyCache::getproperty
//                CPropertyCache::putproperty
//                CProperyCache::CPropertyCache
//                CPropertyCache::~CPropertyCache
//                CPropertyCache::createpropertycache
//
//  History:      17-June-1996   KrishnaG   Created.
//                cloned off NDS property cache code
//
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma  hdrstop




//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::addproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vt]                --
//              [vaData]            --
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
addproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNTOBJECT pNtObject
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pNewProperty = NULL;
    LPWSTR tempString = NULL;

    //
    // Allocate the string first
    //
    tempString = AllocADsStr(szPropertyName);

    if (!tempString)
       BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);


    //
    //  extend the property cache by adding a new property entry
    //

    _pProperties = (PPROPERTY)ReallocADsMem(
                                _pProperties,
                                _cb,
                                _cb + sizeof(PROPERTY)
                                );
    if (!_pProperties) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    pNewProperty = (PPROPERTY)((LPBYTE)_pProperties + _cb);

    if (pNewProperty->szPropertyName) {
       FreeADsStr(pNewProperty->szPropertyName);
       pNewProperty->szPropertyName = NULL;
    }

    //
    // Since the memory has already been allocated in tempString
    // just set the value/pointer now.
    //
    pNewProperty->szPropertyName = tempString;

    //
    // BugBug - add in the NDSOBJECT code
    //


    //
    // Update the index
    //

    _dwMaxProperties++;
    _cb += sizeof(PROPERTY);

    RRETURN(hr);

error:

    if (tempString)
       FreeADsStr(tempString);

    NW_RRETURN_EXP_IF_ERR(hr);
}






//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::updateproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vaData]    --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::updateproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNTOBJECT pNtObject,
    BOOL fExplicit
    )
{
    HRESULT hr;
    DWORD dwIndex;
    PNTOBJECT pNtTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;


    if (!fExplicit) {
        if (PROPERTY_IS_MODIFIED(pThisProperty)) {
            hr = S_OK;
            goto error;
        }
    }

    //
    //   Factor in cases where object state is necessary to
    //   decide on update.
    //

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        NTTypeFreeNTObjects(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_NTOBJECT(pThisProperty) = NULL;
    }

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

    hr = NtTypeCopyConstruct(
            pNtObject,
            dwNumValues,
            &pNtTempObject
            );
    BAIL_ON_FAILURE(hr);

    PROPERTY_NTOBJECT(pThisProperty) = pNtTempObject;

    PROPERTY_FLAGS(pThisProperty)  &= ~CACHE_PROPERTY_MODIFIED;

error:

    NW_RRETURN_EXP_IF_ERR(hr);

}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::findproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::findproperty(
    LPWSTR szPropertyName,
    PDWORD pdwIndex
    )

{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    for (i = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        if (!_wcsicmp(pThisProperty->szPropertyName, szPropertyName)) {
            *pdwIndex = i;
            RRETURN(S_OK);
        }
    }
    *pdwIndex = 0;
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_FOUND);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
getproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;
    DWORD dwResult;
    DWORD dwInfoLevel = 0;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {

        hr = GetPropertyInfoLevel(
                    szPropertyName,
                    _pSchemaClassProps,
                    _dwNumProperties,
                    &dwInfoLevel
                    );
        BAIL_ON_FAILURE(hr);

        //
        // Now call the GetInfo function
        //

        hr = _pCoreADsObject->GetInfo(
                    dwInfoLevel,
                    FALSE
                    );
        BAIL_ON_FAILURE(hr);

        hr = findproperty(
                    szPropertyName,
                    &dwIndex
                    );

    }
    BAIL_ON_FAILURE(hr);




    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(PROPERTY_NTOBJECT(pThisProperty),
                                 PROPERTY_NUMVALUES(pThisProperty),
                                 ppNtObject );
        BAIL_ON_FAILURE(hr);
    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:
    NW_RRETURN_EXP_IF_ERR(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::marshallgetproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
marshallgetproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;
    DWORD dwResult;
    DWORD dwInfoLevel = 0;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );

    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(PROPERTY_NTOBJECT(pThisProperty),
                                 PROPERTY_NUMVALUES(pThisProperty),
                                 ppNtObject );
        BAIL_ON_FAILURE(hr);
    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:
    NW_RRETURN_EXP_IF_ERR(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Clsid index
//              [vaData]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::putproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNTOBJECT pNtObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PNTOBJECT pNtTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;


    //
    // AccountLocked is "half writable" -> need special care
    //

    if (_wcsicmp(szPropertyName, TEXT("IsAccountLocked"))==0 ) {

        if (pNtObject->NTType != NT_SYNTAX_ID_BOOL) {
            hr = E_ADS_BAD_PARAMETER;
            BAIL_ON_FAILURE(hr);
        }
        
        //
        // canNOT just disallow user to set cache to TRUE since
        // user may have accidentally set cache to FALSE (unlock) and
        // want to set the cache back to TRUE (do not unlock) without
        // GetInfo to affect other changes in cache. It will be a major 
        // mistake if cuser cannot set the cache back to TRUE after
        // changing it to FALSE accidentally and thus unlocking the 
        // account even if the user does not want to. 
        // 
        // If cache value on IsAccountLocked is changed from FALSE to TRUE,
        // cached value will be automatically changed back to FALSE upon
        // SetInfo since user cannot lock an account thru' ADSI. (NW server
        // wont' allow. Ref: SysCon)
        //
        // Should: If new value == value already in cache, do nothing.
        //         That is, do not try to set the cache_property_modified flag. 
        //         This is to prevent 
        //         1) the side effect of setting BadLogins to 0 when a 
        //            user set the cached property IsAccountLocked 
        //            from FALSE to FALSE (no change really) and call SetInfo. 
        //         2) the side effect of changing the cache value to 0 (not
        //            consistent with server or original cached value) when
        //            a user set the cache property IsAccontLocked
        //            from TRUE to TRUE (no change really) and call SetInfo.
        //
        //         If user set IsAccountLocked from FALSE to TRUE and then
        //         back to FALSE, or from TRUE to FALSE and then back to TURE,
        //         side effect 1) or 2) will happen.
        //         Both side effect not critical.
        //
        // We first check whether the object has been set previously, if not,
        // NTOBJECT will be NULL
        //
        if (PROPERTY_NTOBJECT(pThisProperty) &&
            (pNtObject->NTValue.fValue==
                    PROPERTY_NTOBJECT(pThisProperty)->NTValue.fValue)) {
             RRETURN(S_OK);
        }
    }


    if (PROPERTY_NTOBJECT(pThisProperty)) {

        NTTypeFreeNTObjects(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_NTOBJECT(pThisProperty) = NULL;
    }

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

    hr = NtTypeCopyConstruct(
            pNtObject,
            dwNumValues,
            &pNtTempObject
            );
    BAIL_ON_FAILURE(hr);

    PROPERTY_NTOBJECT(pThisProperty) = pNtTempObject;

    PROPERTY_FLAGS(pThisProperty) |= CACHE_PROPERTY_MODIFIED;

error:
    NW_RRETURN_EXP_IF_ERR(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::CPropertyCache():
    _pCoreADsObject(NULL),
    _pSchemaClassProps(NULL),
    _dwMaxProperties(0),
    _pProperties(NULL),
    _dwCurrentIndex(0),
    _cb(0)
{

}

//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
~CPropertyCache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;
        
            if (pThisProperty->szPropertyName) {
               FreeADsStr(pThisProperty->szPropertyName);
               pThisProperty->szPropertyName = NULL;
            }
        
            if (PROPERTY_NTOBJECT(pThisProperty)) {

                NTTypeFreeNTObjects(
                        PROPERTY_NTOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_NTOBJECT(pThisProperty) = NULL;
            }
        }
        FreeADsMem(_pProperties);
    }
}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
createpropertycache(
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    CCoreADsObject FAR * pCoreADsObject,
    CPropertyCache FAR *FAR * ppPropertyCache
    )
{
    CPropertyCache FAR * pPropertyCache = NULL;

    pPropertyCache = new CPropertyCache();

    if (!pPropertyCache) {
        NW_RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    pPropertyCache->_pCoreADsObject = pCoreADsObject;
    pPropertyCache->_pSchemaClassProps = pSchemaClassProps;
    pPropertyCache->_dwNumProperties = dwNumProperties;

    *ppPropertyCache = pPropertyCache;

    RRETURN(S_OK);
}


//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::
unmarshallproperty(
    LPWSTR szPropertyName,
    LPBYTE lpValue,
    DWORD  dwNumValues,
    DWORD  dwSyntaxId,
    BOOL fExplicit
    )
{

    DWORD dwIndex = 0;
    HRESULT hr = S_OK;
    PNTOBJECT pNTObject = NULL;

    hr = UnMarshallNTToNTSynId(
                dwSyntaxId,
                dwNumValues,
                lpValue,
                &pNTObject
                );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = findproperty(
                szPropertyName,
                &dwIndex
                );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = addproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNTObject
                    );

        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = updateproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNTObject,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);


    if (pNTObject) {
        NTTypeFreeNTObjects(
                pNTObject,
                dwNumValues
                );

    }


error:
    NW_RRETURN_EXP_IF_ERR(hr);
}



HRESULT
ValidatePropertyinSchemaClass(
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    LPWSTR pszPropName,
    PDWORD pdwSyntaxId
    )
{
    DWORD i = 0;

    PPROPERTYINFO pThisSchProperty = NULL;

    for (i = 0; i < dwNumProperties; i++) {

         pThisSchProperty =  (pSchemaClassProps + i);

        if (!_wcsicmp(pszPropName, pThisSchProperty->szPropertyName)) {
            *pdwSyntaxId = pThisSchProperty->dwSyntaxId;
            RRETURN (S_OK);
        }
    }

    RRETURN(E_ADS_SCHEMA_VIOLATION);
}



HRESULT
ValidateIfWriteableProperty(
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    LPWSTR pszPropName
    )
{
    DWORD i = 0;

    PPROPERTYINFO pThisSchProperty = NULL;

    for (i = 0; i < dwNumProperties; i++) {

         pThisSchProperty =  (pSchemaClassProps + i);

        if (!_wcsicmp(pszPropName, pThisSchProperty->szPropertyName)) {

             RRETURN((pThisSchProperty->dwFlags & PROPERTY_WRITEABLE)
                        ? S_OK : E_ADS_SCHEMA_VIOLATION);
        }
    }

    RRETURN(E_ADS_SCHEMA_VIOLATION);

    // for winnt & nw312, return E_ADS_SCHEMA_VIOLATION if not ok even 
    // attempt to write to cache only
}



HRESULT
GetPropertyInfoLevel(
    LPWSTR pszPropName,
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    PDWORD pdwInfoLevel
    )
{
    DWORD i = 0;

    PPROPERTYINFO pThisSchProperty = NULL;

    for (i = 0; i < dwNumProperties; i++) {

         pThisSchProperty =  (pSchemaClassProps + i);

        if (!_wcsicmp(pszPropName, pThisSchProperty->szPropertyName)) {

             *pdwInfoLevel = pThisSchProperty->dwInfoLevel;
             RRETURN(S_OK);
        }
    }

    //
    // Returning E_ADS_PROPERTY_NOT_FOUND so that implicit
    // GetInfo fails gracefully
    //
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_FOUND);
}

//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
void
CPropertyCache::
flushpropcache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

            if (pThisProperty->szPropertyName) {
               FreeADsStr(pThisProperty->szPropertyName);
               pThisProperty->szPropertyName = NULL;
            }   

            if (PROPERTY_NTOBJECT(pThisProperty)) {

                NTTypeFreeNTObjects(
                        PROPERTY_NTOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_NTOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }

    //
    // Reset the property cache
    //

    _pProperties = NULL;
    _dwMaxProperties = 0;
    _cb = 0;
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNtObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:

   NW_RRETURN_EXP_IF_ERR(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    DWORD dwIndex,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex)) {
        RRETURN(E_ADS_BAD_PARAMETER);     // better if E_ADS_INDEX or sth
     } 

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNtObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:

   NW_RRETURN_EXP_IF_ERR(hr);
}

BOOL
CPropertyCache::
index_valid(
   )
{
   // _dwMaxProperties =0 -> dwMaxProperties -1 = -1 -> converted to 
   // unsigned during comparision with unsigned _dwCurrentIndex ->
   // comparision does not work. So need to check if _dwMaxProperties==0 1st 
   if (_dwMaxProperties ==0) 
        return (FALSE);

   if (_dwCurrentIndex < 0 || _dwCurrentIndex > _dwMaxProperties - 1)
        return(FALSE);
   else
        return(TRUE);
}


BOOL
CPropertyCache::
index_valid(
   DWORD dwIndex
   )
{
   // _dwMaxProperties =0 -> dwMaxProperties -1 = -1 -> converted to 
   // unsigned during comparision with unsigned _dwCurrentIndex ->
   // comparision does not work. So need to check if _dwMaxProperties==0 1st 
   if (_dwMaxProperties ==0) 
        return (FALSE);

   if (dwIndex < 0 || dwIndex > _dwMaxProperties - 1)
      return(FALSE);
   else
      return(TRUE);
}


void
CPropertyCache::
reset_propindex(
    )
{
  _dwCurrentIndex = 0;

}


HRESULT
CPropertyCache::
skip_propindex(
    DWORD dwElements
    )
{
   DWORD newIndex = _dwCurrentIndex + dwElements;

   if (!index_valid() || !_dwMaxProperties)
      NW_RRETURN_EXP_IF_ERR(E_FAIL);

   //
   // BugBug it will be better to return IndexOutOfRange or something like that
   //

   if (_dwCurrentIndex < 0 || _dwCurrentIndex > _dwMaxProperties-1)
      NW_RRETURN_EXP_IF_ERR(E_FAIL);

   if ( newIndex < 0 || newIndex > _dwMaxProperties )
      NW_RRETURN_EXP_IF_ERR(E_FAIL);


   _dwCurrentIndex = newIndex;
   RRETURN(S_OK);

}


HRESULT
CPropertyCache::
get_PropertyCount(
    PDWORD pdwMaxProperties
    )
{
    *pdwMaxProperties = _dwMaxProperties;

    RRETURN(S_OK);
}

DWORD
CPropertyCache::
get_CurrentIndex(
    )
{
    return(_dwCurrentIndex);
}

LPWSTR
CPropertyCache::
get_CurrentPropName(
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid())
        return(PROPERTY_NAME(pThisProperty));

    pThisProperty = _pProperties + _dwCurrentIndex;

    return(PROPERTY_NAME(pThisProperty));
}

LPWSTR
CPropertyCache::
get_PropName(
    DWORD dwIndex
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex))
       return(NULL);

    pThisProperty = _pProperties + dwIndex;

    return(PROPERTY_NAME(pThisProperty));
}

HRESULT
CPropertyCache::
deleteproperty(
    DWORD dwIndex
    )
{
   HRESULT hr = S_OK;
   PPROPERTY pNewProperties = NULL;
   PPROPERTY pThisProperty = _pProperties + dwIndex;

   if (!index_valid(dwIndex)) {
      RRETURN(E_ADS_BAD_PARAMETER);
   }

   if (_dwMaxProperties == 1) {
      //
      // Deleting everything
      //
      if (PROPERTY_NTOBJECT(pThisProperty)) {
          NTTypeFreeNTObjects(
                  PROPERTY_NTOBJECT(pThisProperty),
                  PROPERTY_NUMVALUES(pThisProperty)
                  );
          PROPERTY_NTOBJECT(pThisProperty) = NULL;
      }

      FreeADsMem(_pProperties);
      _pProperties = NULL;
      _dwMaxProperties = 0;
      _cb = 0;
      RRETURN(hr);
   }

   pNewProperties = (PPROPERTY)AllocADsMem(
                               _cb - sizeof(PROPERTY)
                               );
   if (!pNewProperties) {
       hr = E_OUTOFMEMORY;
       BAIL_ON_FAILURE(hr);
   }

   //
   // Copying the memory before the deleted item
   //
   if (dwIndex != 0) {
      memcpy( pNewProperties,
              _pProperties,
              dwIndex * sizeof(PROPERTY));
   }

   //
   // Copying the memory following the deleted item
   //
   if (dwIndex != (_dwMaxProperties-1)) {
      memcpy( pNewProperties + dwIndex,
              _pProperties + dwIndex + 1,
              (_dwMaxProperties - dwIndex - 1) * sizeof(PROPERTY));
   }

   if (PROPERTY_NTOBJECT(pThisProperty)) {
       NTTypeFreeNTObjects(
               PROPERTY_NTOBJECT(pThisProperty),
               PROPERTY_NUMVALUES(pThisProperty)
               );
       PROPERTY_NTOBJECT(pThisProperty) = NULL;
   }
   FreeADsMem(_pProperties);
   _pProperties = pNewProperties;
   _dwMaxProperties--;
   _cb -= sizeof(PROPERTY);
error:

   NW_RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CPropertyCache::
propertyismodified(
    LPWSTR szPropertyName, 
    BOOL * pfModified
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;

    if (!szPropertyName || !pfModified) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    *pfModified=PROPERTY_IS_MODIFIED(pThisProperty);

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cprovcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  NetWare 3.12 Provider Object Class Factory Code
//
//             CNWCOMPATProviderCF::CreateInstance
//
//  History:   10-Jan-96     t-ptam    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATProviderCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    10-Jan-96     t-ptam    Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATProviderCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr;
    CNWCOMPATProvider *     pProvider;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CNWCOMPATProvider::Create(&pProvider);

    if (FAILED(hr)) {
        RRETURN (hr);
    }

    if (pProvider)
    {
        hr = pProvider->QueryInterface(iid, ppv);
        pProvider->Release();
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cschema.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cschema.cxx
//
//  Contents:  Windows NT 3.51
//
//
//  History:   01-09-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


/******************************************************************/
/*  Class CNWCOMPATSchema
/******************************************************************/

DEFINE_IDispatch_Implementation(CNWCOMPATSchema)
DEFINE_IADs_Implementation(CNWCOMPATSchema)

CNWCOMPATSchema::CNWCOMPATSchema()
{
    VariantInit( &_vFilter );

    ENLIST_TRACKING(CNWCOMPATSchema);
}

CNWCOMPATSchema::~CNWCOMPATSchema()
{
    VariantClear( &_vFilter );
    delete _pDispMgr;
}

HRESULT
CNWCOMPATSchema::CreateSchema(
    BSTR   bstrParent,
    BSTR   bstrName,
    CCredentials &Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATSchema FAR *pSchema = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSchemaObject( &pSchema );
    BAIL_ON_FAILURE(hr);

    hr = pSchema->InitializeCoreObject(
             bstrParent,
             bstrName,
             SCHEMA_CLASS_NAME,
             NO_SCHEMA,
             CLSID_NWCOMPATSchema,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pSchema->_Credentials = Credentials;

    hr = pSchema->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSchema->Release();

    RRETURN(hr);

error:

    delete pSchema;
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSchema::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATSchema::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CNWCOMPATSchema::SetInfo(THIS)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSchema::GetInfo(THIS)
{
    RRETURN(S_OK);
}

/* IADsContainer methods */

STDMETHODIMP
CNWCOMPATSchema::get_Count(long FAR* retval)
{
    HRESULT hr;

    if ( !retval )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *retval = g_cNWCOMPATClasses + g_cNWCOMPATSyntax;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATSchema::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    if ( !pVar )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    VariantInit( pVar );
    hr = VariantCopy( pVar, &_vFilter );
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSchema::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy( &_vFilter, &Var );
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSchema::put_Hints(THIS_ VARIANT Var)
{
    NW_RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATSchema::get_Hints(THIS_ VARIANT FAR* pVar)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSchema::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject)
{
    TCHAR szBuffer[MAX_PATH];
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        NW_RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"/");
    wcscat(szBuffer, RelativeName);

    if (ClassName && *ClassName) {
        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                _Credentials,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:

    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSchema::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IEnumVARIANT *penum = NULL;

    if ( !retval )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CNWCOMPATSchemaEnum::Create( (CNWCOMPATSchemaEnum **)&penum,
                                   _ADsPath,
                                   _Name,
                                   _vFilter );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface( IID_IUnknown, (VOID FAR* FAR*)retval );
    BAIL_ON_FAILURE(hr);

    if ( penum )
        penum->Release();

    RRETURN(hr);

error:

    if ( penum )
        delete penum;

    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSchema::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSchema::Delete(THIS_ BSTR SourceName, BSTR Type)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSchema::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSchema::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CNWCOMPATSchema::AllocateSchemaObject(CNWCOMPATSchema FAR * FAR * ppSchema)
{
    CNWCOMPATSchema FAR *pSchema = NULL;
    CDispatchMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSchema = new CNWCOMPATSchema();
    if ( pSchema == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pSchema,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsContainer,
                            (IADsContainer *) pSchema,
                            DISPID_NEWENUM );
    BAIL_ON_FAILURE(hr);

    pSchema->_pDispMgr = pDispMgr;
    *ppSchema = pSchema;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSchema;

    RRETURN(hr);

}


/******************************************************************/
/*  Class CNWCOMPATClass
/******************************************************************/

DEFINE_IDispatch_Implementation(CNWCOMPATClass)
DEFINE_IADs_Implementation(CNWCOMPATClass)

CNWCOMPATClass::CNWCOMPATClass()
    : _pDispMgr( NULL ),
      _aPropertyInfo( NULL ),
      _cPropertyInfo( 0 ),
      _bstrCLSID( NULL ),
      _bstrOID( NULL ),
      _bstrPrimaryInterface( NULL ),
      _fAbstract( FALSE ),
      _fContainer( FALSE ),
      _bstrHelpFileName( NULL ),
      _lHelpFileContext( 0 )
{
    VariantInit( &_vMandatoryProperties );
    VariantInit( &_vOptionalProperties );
    VariantInit( &_vPossSuperiors );
    VariantInit( &_vContainment );
    VariantInit( &_vFilter );

    ENLIST_TRACKING(CNWCOMPATClass);
}

CNWCOMPATClass::~CNWCOMPATClass()
{
    if ( _bstrCLSID ) {
        ADsFreeString( _bstrCLSID );
    }

    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrPrimaryInterface ) {
        ADsFreeString( _bstrPrimaryInterface );
    }

    if ( _bstrHelpFileName ) {
        ADsFreeString( _bstrHelpFileName );
    }

    VariantClear( &_vMandatoryProperties );
    VariantClear( &_vOptionalProperties );
    VariantClear( &_vPossSuperiors );
    VariantClear( &_vContainment );
    VariantClear( &_vFilter );

    delete _pDispMgr;
}

HRESULT
CNWCOMPATClass::CreateClass(
    BSTR   bstrParent,
    CLASSINFO *pClassInfo,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATClass FAR *pClass = NULL;
    HRESULT hr = S_OK;
    BSTR bstrTmp = NULL;

    hr = AllocateClassObject( &pClass );
    BAIL_ON_FAILURE(hr);

    pClass->_aPropertyInfo = pClassInfo->aPropertyInfo;
    pClass->_cPropertyInfo = pClassInfo->cPropertyInfo;
    pClass->_lHelpFileContext = pClassInfo->lHelpFileContext;
    pClass->_fContainer = pClassInfo->fContainer;
    pClass->_fAbstract = pClassInfo->fAbstract;

    hr = StringFromCLSID( (REFCLSID) *(pClassInfo->pPrimaryInterfaceGUID),
                          &bstrTmp );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrTmp,
                           &pClass->_bstrPrimaryInterface );
    BAIL_ON_FAILURE(hr);

    CoTaskMemFree( bstrTmp );
    bstrTmp = NULL;

    hr = StringFromCLSID( (REFCLSID) *(pClassInfo->pCLSID),
                          &bstrTmp );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrTmp,
                           &pClass->_bstrCLSID );
    BAIL_ON_FAILURE(hr);

    CoTaskMemFree( bstrTmp );
    bstrTmp = NULL;

    hr = ADsAllocString( pClassInfo->bstrOID, &pClass->_bstrOID);
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringList( pClassInfo->bstrMandatoryProperties,
                                    &(pClass->_vMandatoryProperties));
    BAIL_ON_FAILURE(hr);


    hr = MakeVariantFromStringList( pClassInfo->bstrOptionalProperties,
                                    &(pClass->_vOptionalProperties));
    BAIL_ON_FAILURE(hr);


    hr = MakeVariantFromStringList( pClassInfo->bstrPossSuperiors,
                                    &(pClass->_vPossSuperiors));
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringList( pClassInfo->bstrContainment,
                                    &(pClass->_vContainment));
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pClassInfo->bstrHelpFileName,
                           &pClass->_bstrHelpFileName);
    BAIL_ON_FAILURE(hr);

    hr = pClass->InitializeCoreObject(
             bstrParent,
             pClassInfo->bstrName,
             CLASS_CLASS_NAME,
             NO_SCHEMA,
             CLSID_NWCOMPATClass,
             dwObjectState );

    BAIL_ON_FAILURE(hr);

    hr = pClass->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pClass->Release();

    RRETURN(hr);

error:
    if ( bstrTmp != NULL )
        CoTaskMemFree( bstrTmp );

    delete pClass;
    NW_RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNWCOMPATClass::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsClass FAR * ) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsClass))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATClass::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid 
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsClass)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CNWCOMPATClass::SetInfo(THIS)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATClass::GetInfo(THIS)
{
    RRETURN(S_OK);
}

/* IADsClass methods */

STDMETHODIMP
CNWCOMPATClass::get_PrimaryInterface( THIS_ BSTR FAR *pbstrGUID )
{
    HRESULT hr;
    if ( !pbstrGUID )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrPrimaryInterface, pbstrGUID );
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::get_CLSID( THIS_ BSTR FAR *pbstrCLSID )
{
    HRESULT hr;
    if ( !pbstrCLSID )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrCLSID, pbstrCLSID );
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_CLSID( THIS_ BSTR bstrCLSID )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    HRESULT hr;
    if ( !pbstrOID )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrOID, pbstrOID );
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_OID( THIS_ BSTR bstrOID )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_Abstract( THIS_ VARIANT_BOOL FAR *pfAbstract )
{
    if ( !pfAbstract )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfAbstract = _fAbstract? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATClass::put_Abstract( THIS_ VARIANT_BOOL fAbstract )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_Auxiliary( THIS_ VARIANT_BOOL FAR *pfAuxiliary )
{
    if ( !pfAuxiliary )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfAuxiliary = VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATClass::put_Auxiliary( THIS_ VARIANT_BOOL fAuxiliary )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_MandatoryProperties( THIS_ VARIANT FAR *pvMandatoryProperties )
{
    HRESULT hr;
    VariantInit( pvMandatoryProperties );
    hr = VariantCopy( pvMandatoryProperties, &_vMandatoryProperties );
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_MandatoryProperties( THIS_ VARIANT vMandatoryProperties )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_DerivedFrom( THIS_ VARIANT FAR *pvDerivedFrom )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::put_DerivedFrom( THIS_ VARIANT vDerivedFrom )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_AuxDerivedFrom( THIS_ VARIANT FAR *pvAuxDerivedFrom )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::put_AuxDerivedFrom( THIS_ VARIANT vAuxDerivedFrom )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_PossibleSuperiors( THIS_ VARIANT FAR *pvPossSuperiors )
{
    HRESULT hr;
    VariantInit( pvPossSuperiors );
    hr = VariantCopy( pvPossSuperiors, &_vPossSuperiors );
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_PossibleSuperiors( THIS_ VARIANT vPossSuperiors )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_Containment( THIS_ VARIANT FAR *pvContainment )
{
    HRESULT hr;
    VariantInit( pvContainment );
    hr = VariantCopy( pvContainment, &_vContainment );
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_Containment( THIS_ VARIANT vContainment )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_Container( THIS_ VARIANT_BOOL FAR *pfContainer )
{
    if ( !pfContainer )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfContainer = _fContainer? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATClass::put_Container( THIS_ VARIANT_BOOL fContainer )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_HelpFileName( THIS_ BSTR FAR *pbstrHelpFileName )
{
    HRESULT hr;
    if ( !pbstrHelpFileName )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrHelpFileName, pbstrHelpFileName );
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_HelpFileName( THIS_ BSTR bstrHelpFile )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_HelpFileContext( THIS_ long FAR *plHelpContext )
{
    if ( !plHelpContext )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plHelpContext = _lHelpFileContext;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATClass::put_HelpFileContext( THIS_ long lHelpContext )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CNWCOMPATClass::AllocateClassObject(CNWCOMPATClass FAR * FAR * ppClass)
{

    CNWCOMPATClass FAR  *pClass = NULL;
    CDispatchMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pClass = new CNWCOMPATClass();
    if ( pClass == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsClass,
                            (IADsClass *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pClass->_pDispMgr = pDispMgr;
    *ppClass = pClass;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pClass;

    RRETURN(hr);

}


/******************************************************************/
/*  Class CNWCOMPATProperty
/******************************************************************/

DEFINE_IDispatch_Implementation(CNWCOMPATProperty)
DEFINE_IADs_Implementation(CNWCOMPATProperty)

CNWCOMPATProperty::CNWCOMPATProperty()
    : _pDispMgr( NULL ),
      _bstrOID( NULL ),
      _bstrSyntax( NULL ),
      _lMaxRange( 0 ),
      _lMinRange( 0 ),
      _fMultiValued( FALSE )
{

    ENLIST_TRACKING(CNWCOMPATProperty);
}

CNWCOMPATProperty::~CNWCOMPATProperty()
{
    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrSyntax ) {
        ADsFreeString( _bstrSyntax );
    }

    delete _pDispMgr;
}

HRESULT
CNWCOMPATProperty::CreateProperty(
    BSTR   bstrParent,
    PROPERTYINFO *pPropertyInfo,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATProperty FAR * pProperty = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePropertyObject( &pProperty );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pPropertyInfo->bstrOID, &pProperty->_bstrOID);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pPropertyInfo->bstrSyntax, &pProperty->_bstrSyntax);
    BAIL_ON_FAILURE(hr);

    pProperty->_lMaxRange = pPropertyInfo->lMaxRange;
    pProperty->_lMinRange = pPropertyInfo->lMinRange;
    pProperty->_fMultiValued  = pPropertyInfo->fMultiValued;

    hr = pProperty->InitializeCoreObject(
             bstrParent,
             pPropertyInfo->szPropertyName,
             PROPERTY_CLASS_NAME,
             NO_SCHEMA,
             CLSID_NWCOMPATProperty,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    hr = pProperty->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pProperty->Release();

    RRETURN(hr);

error:

    delete pProperty;
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATProperty::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsProperty))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATProperty::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsProperty)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CNWCOMPATProperty::SetInfo(THIS)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATProperty::GetInfo(THIS)
{
    RRETURN(S_OK);
}

/* IADsProperty methods */


STDMETHODIMP
CNWCOMPATProperty::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    HRESULT hr;
    if ( !pbstrOID )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrOID, pbstrOID );
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATProperty::put_OID( THIS_ BSTR bstrOID )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATProperty::get_Syntax( THIS_ BSTR FAR *pbstrSyntax )
{
    HRESULT hr;
    if ( !pbstrSyntax )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrSyntax, pbstrSyntax );
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATProperty::put_Syntax( THIS_ BSTR bstrSyntax )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATProperty::get_MaxRange( THIS_ long FAR *plMaxRange )
{
    if ( !plMaxRange )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plMaxRange = _lMaxRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATProperty::put_MaxRange( THIS_ long lMaxRange )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATProperty::get_MinRange( THIS_ long FAR *plMinRange )
{
    if ( !plMinRange )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plMinRange = _lMinRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATProperty::put_MinRange( THIS_ long lMinRange )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATProperty::get_MultiValued( THIS_ VARIANT_BOOL FAR *pfMultiValued )
{
    if ( !pfMultiValued )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfMultiValued = _fMultiValued? VARIANT_TRUE: VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATProperty::put_MultiValued( THIS_ VARIANT_BOOL fMultiValued )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATProperty::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CNWCOMPATProperty::AllocatePropertyObject(CNWCOMPATProperty FAR * FAR * ppProperty)
{
    CNWCOMPATProperty FAR *pProperty = NULL;
    CDispatchMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pProperty = new CNWCOMPATProperty();
    if ( pProperty == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsProperty,
                            (IADsProperty *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pProperty->_pDispMgr = pDispMgr;
    *ppProperty = pProperty;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pProperty;

    RRETURN(hr);

}


/******************************************************************/
/*  Class CNWCOMPATSyntax
/******************************************************************/

DEFINE_IDispatch_Implementation(CNWCOMPATSyntax)
DEFINE_IADs_Implementation(CNWCOMPATSyntax)

CNWCOMPATSyntax::CNWCOMPATSyntax()
{
    ENLIST_TRACKING(CNWCOMPATSyntax);
}

CNWCOMPATSyntax::~CNWCOMPATSyntax()
{
    delete _pDispMgr;
}

HRESULT
CNWCOMPATSyntax::CreateSyntax(
    BSTR   bstrParent,
    SYNTAXINFO *pSyntaxInfo,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATSyntax FAR *pSyntax = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSyntaxObject( &pSyntax );
    BAIL_ON_FAILURE(hr);

    hr = pSyntax->InitializeCoreObject(
             bstrParent,
             pSyntaxInfo->bstrName,
             SYNTAX_CLASS_NAME,
             NO_SCHEMA,
             CLSID_NWCOMPATSyntax,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pSyntax->_lOleAutoDataType = pSyntaxInfo->lOleAutoDataType;

    hr = pSyntax->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSyntax->Release();

    RRETURN(hr);

error:

    delete pSyntax;
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSyntax::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsSyntax))
    {
        *ppv = (IADsSyntax FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATSyntax::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsSyntax)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CNWCOMPATSyntax::SetInfo(THIS)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSyntax::GetInfo(THIS)
{
    RRETURN(S_OK);
}

HRESULT
CNWCOMPATSyntax::AllocateSyntaxObject(CNWCOMPATSyntax FAR * FAR * ppSyntax)
{
    CNWCOMPATSyntax FAR *pSyntax = NULL;
    CDispatchMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSyntax = new CNWCOMPATSyntax();
    if ( pSyntax == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsSyntax,
                            (IADsSyntax *) pSyntax,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pSyntax->_pDispMgr = pDispMgr;
    *ppSyntax = pSyntax;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSyntax;

    RRETURN(hr);

}

STDMETHODIMP
CNWCOMPATSyntax::get_OleAutoDataType( THIS_ long FAR *plOleAutoDataType )
{
    if ( !plOleAutoDataType )
        NW_RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plOleAutoDataType = _lOleAutoDataType;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATSyntax::put_OleAutoDataType( THIS_ long lOleAutoDataType )
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}


/******************************************************************/
/*  Misc Helpers
/******************************************************************/

HRESULT
MakeVariantFromStringList(
    BSTR bstrList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    BSTR pszTempList = NULL;

    if ( bstrList != NULL )
    {
        long i = 0;
        long nCount = 1;
        TCHAR c;
        BSTR pszSrc;

        hr = ADsAllocString( bstrList, &pszTempList );
        BAIL_ON_FAILURE(hr);

        while ( c = pszTempList[i] )
        {
            if ( c == TEXT(','))
            {
                pszTempList[i] = 0;
                nCount++;
            }

            i++;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pszSrc = pszTempList;

        for ( i = 0; i < nCount; i++ )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;
            hr = ADsAllocString( pszSrc, &(V_BSTR(&v)));
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList,
                                      &i,
                                      &v );
            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszSrc += _tcslen( pszSrc ) + 1;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

        ADsFreeString( pszTempList );
        pszTempList = NULL;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    RRETURN(S_OK);

error:

    if ( pszTempList )
        ADsFreeString( pszTempList );

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}


STDMETHODIMP
CNWCOMPATClass::get_OptionalProperties( THIS_ VARIANT FAR *retval )
{
    HRESULT hr;
    VariantInit( retval);
    hr = VariantCopy( retval, &_vOptionalProperties );
    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_OptionalProperties( THIS_ VARIANT vOptionalProperties )
{

    HRESULT hr = E_NOTIMPL;

    NW_RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::get_NamingProperties( THIS_ VARIANT FAR *retval )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATClass::put_NamingProperties( THIS_ VARIANT vNamingProperties )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cuar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuar.cxx
//
//  Contents:  Account Restrictions Propset for the User object
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//
//        PROPERTY_RW(AccountDisabled, boolean, 1)              NI
//        PROPERTY_RW(AccountExpirationDate, DATE, 2)           NI
//        PROPERTY_RO(AccountCanExpire, boolean, 3)             NI
//        PROPERTY_RO(PasswordCanExpire, boolean, 4)            NI
//        PROPERTY_RW(GraceLoginsAllowed, long, 5)              NI
//        PROPERTY_RW(GraceLoginsRemaining, long, 6)            NI
//        PROPERTY_RW(IsAccountLocked, boolean, 7)              NI
//        PROPERTY_RW(IsAdmin, boolean, 8)                      NI
//        PROPERTY_RW(LoginHours, VARIANT, 9)                   NI
//        PROPERTY_RW(LoginWorkstations, VARIANT, 10)           NI
//        PROPERTY_RW(MaxLogins, long, 11)                      NI
//        PROPERTY_RW(MaxStorage, long, 12)                     NI
//        PROPERTY_RW(PasswordExpirationDate, DATE, 13)         NI
//        PROPERTY_RW(PasswordRequired, boolean, 14)            NI
//        PROPERTY_RW(RequireUniquePassword,boolean, 15)        NI
//
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//  Class CNWCOMPATUser


/* IADsFSUserAccountRestrictions methods */

STDMETHODIMP
CNWCOMPATUser::get_AccountDisabled(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, AccountDisabled);
}

STDMETHODIMP
CNWCOMPATUser::put_AccountDisabled(THIS_ VARIANT_BOOL fAccountDisabled)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, AccountDisabled);
}

STDMETHODIMP
CNWCOMPATUser::get_AccountExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CNWCOMPATUser::put_AccountExpirationDate(THIS_ DATE daAccountExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CNWCOMPATUser::get_GraceLoginsAllowed(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, GraceLoginsAllowed);
}

STDMETHODIMP
CNWCOMPATUser::put_GraceLoginsAllowed(THIS_ long lGraceLoginsAllowed)
{
    PUT_PROPERTY_LONG((IADsUser *)this, GraceLoginsAllowed);
}

STDMETHODIMP
CNWCOMPATUser::get_GraceLoginsRemaining(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, GraceLoginsRemaining);
}

STDMETHODIMP
CNWCOMPATUser::put_GraceLoginsRemaining(THIS_ long lGraceLoginsRemaining)
{
    PUT_PROPERTY_LONG((IADsUser *)this, GraceLoginsRemaining);
}

STDMETHODIMP
CNWCOMPATUser::get_IsAccountLocked(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, IsAccountLocked);
}

STDMETHODIMP
CNWCOMPATUser::put_IsAccountLocked(THIS_ VARIANT_BOOL fIsAccountLocked)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, IsAccountLocked);
}

STDMETHODIMP
CNWCOMPATUser::get_LoginHours(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, LoginHours);
}

STDMETHODIMP
CNWCOMPATUser::put_LoginHours(THIS_ VARIANT vLoginHours)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, LoginHours);
}

STDMETHODIMP
CNWCOMPATUser::get_LoginWorkstations(THIS_ VARIANT FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATUser::put_LoginWorkstations(THIS_ VARIANT vLoginWorkstations)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATUser::get_MaxLogins(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, MaxLogins);
}

STDMETHODIMP
CNWCOMPATUser::put_MaxLogins(THIS_ long lMaxLogins)
{
    PUT_PROPERTY_LONG((IADsUser *)this, MaxLogins);
}

STDMETHODIMP
CNWCOMPATUser::get_MaxStorage(THIS_ long FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATUser::put_MaxStorage(THIS_ long lMaxStorage)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATUser::get_PasswordExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CNWCOMPATUser::put_PasswordExpirationDate(THIS_ DATE daPasswordExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CNWCOMPATUser::get_PasswordMinimumLength(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, PasswordMinimumLength);
}

STDMETHODIMP
CNWCOMPATUser::put_PasswordMinimumLength(THIS_ long lPasswordMinimumLength)
{
    PUT_PROPERTY_LONG((IADsUser *)this, PasswordMinimumLength);
}

STDMETHODIMP
CNWCOMPATUser::get_PasswordRequired(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, PasswordRequired);
}

STDMETHODIMP
CNWCOMPATUser::put_PasswordRequired(THIS_ VARIANT_BOOL fPasswordRequired)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, PasswordRequired);
}

STDMETHODIMP
CNWCOMPATUser::get_RequireUniquePassword(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

STDMETHODIMP
CNWCOMPATUser::put_RequireUniquePassword(THIS_ VARIANT_BOOL fRequireUniquePassword)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

STDMETHODIMP
CNWCOMPATUser::SetPassword(THIS_ BSTR NewPassword)
{
    HRESULT hr = S_OK ;
    NWOBJ_ID      ObjectID;
    NW_USER_INFO NwUserInfo = {NULL, NULL, NULL, NULL};

    //
    // We dont care what state the object is in, since all we need is
    // already there from core init.
    //


    hr = NWApiMakeUserInfo(
                 _ServerName,  
                 _Name,
                 NewPassword,
                 _Credentials,
                 &NwUserInfo
                 );
    BAIL_ON_FAILURE(hr);

    hr = NWApiSetUserPassword(
             &NwUserInfo,
             &ObjectID,
             NULL
             ) ;
    
error:

    (void) NWApiFreeUserInfo(
               &NwUserInfo
               );

    NW_RRETURN_EXP_IF_ERR(hr) ;
}

STDMETHODIMP
CNWCOMPATUser::ChangePassword(THIS_ BSTR bstrOldPassword, BSTR bstrNewPassword)
{
    HRESULT hr = S_OK ;
    NWOBJ_ID      ObjectID;
    NW_USER_INFO NwUserInfo = {NULL, NULL, NULL, NULL};

    //
    // We dont care what state the object is in, since all we need is
    // already there from core init.
    //

    hr = NWApiMakeUserInfo(
                 _ServerName,  
                 _Name,
                 bstrNewPassword,
                 _Credentials,
                 &NwUserInfo
                 );
    BAIL_ON_FAILURE(hr);

    hr = NWApiSetUserPassword(
             &NwUserInfo,
             &ObjectID,
             (LPWSTR) bstrOldPassword
             ) ;
    
error:

    (void) NWApiFreeUserInfo(
               &NwUserInfo
               );

    NW_RRETURN_EXP_IF_ERR(hr) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cprov.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  NetWare 3.12 Provider Object Class Factory Code
//
//             CNWCOMPATProviderCF::CreateInstance
//
//  History:   10-Jan-96     t-ptam    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


HRESULT
GetObject(
   LPWSTR szBuffer,
   LPVOID * ppObject
   );

//  Class CNWCOMPATProvider

CNWCOMPATProvider::CNWCOMPATProvider()
{
    ENLIST_TRACKING(CNWCOMPATProvider);
}

HRESULT
CNWCOMPATProvider::Create(CNWCOMPATProvider FAR * FAR * ppProvider)
{
    CNWCOMPATProvider FAR * pProvider = NULL;
    HRESULT hr = S_OK;

    //
    //Create the Provider Object
    ///

    pProvider = new CNWCOMPATProvider();
    if (pProvider == NULL) {
        RRETURN(ResultFromScode(E_OUTOFMEMORY));
    }

    if (FAILED(hr)) {
        delete pProvider;
        RRETURN(hr);
    }

    *ppProvider = pProvider;
    RRETURN(hr);
}

CNWCOMPATProvider::~CNWCOMPATProvider( )
{

}

STDMETHODIMP
CNWCOMPATProvider::QueryInterface(REFIID iid,LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = this;
    }
    else if (IsEqualIID(iid, IID_IParseDisplayName))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CNWCOMPATProvider::ParseDisplayName(
                    IBindCtx* pbc,
                    WCHAR* szDisplayName,
                    ULONG* pchEaten,
                    IMoniker** ppmk
                    )
{
    HRESULT hr;

    // clear out-parameters
    *ppmk = NULL;
    if (pchEaten != NULL)
        *pchEaten = 0;

    hr = ResolvePathName(pbc, szDisplayName, pchEaten, ppmk);

    RRETURN(hr);
}


HRESULT
CNWCOMPATProvider::ResolvePathName(
                    IBindCtx* pbc,
                    WCHAR* szDisplayName,
                    ULONG* pchEaten,
                    IMoniker** ppmk
                    )
{
    HRESULT hr;
    LPUNKNOWN pUnknown = NULL;
    CCredentials Credentials;

    *pchEaten = 0;
    hr = GetObject(szDisplayName, Credentials, (LPVOID *)&pUnknown);
    BAIL_IF_ERROR(hr);

    hr = CreatePointerMoniker(pUnknown, ppmk);
    BAIL_IF_ERROR(hr);

    *pchEaten += wcslen(szDisplayName);

cleanup:

    if (pUnknown) {
        pUnknown->Release();
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cubi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cubi.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//
//      PROPERTY_RW(Address, VARIANT, 1)                NI
//      PROPERTY_RW(Department, BSTR, 3)                NI
//      PROPERTY_RW(Division, BSTR, 5)                  NI
//      PROPERTY_RW(EmployeeID, BSTR, 6)                NI
//      PROPERTY_RW(FirstName, BSTR, 8)                 Implemented
//      PROPERTY_RW(FullName, BSTR, 9)                  NI
//      PROPERTY_RW(Initials, BSTR, 10)                 NI
//      PROPERTY_RW(LastName, BSTR, 11)                 NI
//      PROPERTY_RW(Manager, BSTR, 12)                  NI
//      PROPERTY_RW(NickName, BSTR, 13)                 NI
//      PROPERTY_RW(OfficeLocation, BSTR, 14)           NI
//      PROPERTY_RW(Picture, VARIANT, 15)               NI
//      PROPERTY_RW(TelephoneNumber, BSTR, 18)          NI
//      PROPERTY_RW(Title, BSTR, 19)
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//  Class CNWCOMPATUser




/* IADsFSUserBusinessInformation methods */

STDMETHODIMP
CNWCOMPATUser::get_Department(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}


STDMETHODIMP
CNWCOMPATUser::put_Department(THIS_ BSTR bstrDepartment)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_Description(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_Description(THIS_ BSTR bstrDescription)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_Division(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_Division(THIS_ BSTR bstrDivision)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_EmployeeID(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_EmployeeID(THIS_ BSTR bstrEmployeeID)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_FirstName(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_FirstName(THIS_ BSTR bstrFirstName)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_FullName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CNWCOMPATUser::put_FullName(THIS_ BSTR bstrFullName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CNWCOMPATUser::get_LastName(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_LastName(THIS_ BSTR bstrLastName)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_Manager(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_Manager(THIS_ BSTR bstrManager)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_OfficeLocations(THIS_ VARIANT FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_OfficeLocations(THIS_ VARIANT vOfficeLocation)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_Picture(THIS_ VARIANT FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_Picture(THIS_ VARIANT vPicture)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_PostalAddresses(THIS_ VARIANT FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_PostalAddresses(THIS_ VARIANT vPostalAddresses)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_PostalCodes(THIS_ VARIANT FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_PostalCodes(THIS_ VARIANT vPostalCodes)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_TelephoneNumber(THIS_ VARIANT FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_TelephoneNumber(THIS_ VARIANT vTelephoneNumber)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_TelephoneHome(THIS_ VARIANT FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_TelephoneHome(THIS_ VARIANT vTelephoneHome)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_TelephoneMobile(THIS_ VARIANT FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_TelephoneMobile(THIS_ VARIANT vTelephoneMobile)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_TelephonePager(THIS_ VARIANT FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_TelephonePager(THIS_ VARIANT vTelephonePager)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_FaxNumber(THIS_ VARIANT FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_FaxNumber(THIS_ VARIANT vFaxNumber)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_Title(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_Title(THIS_ BSTR bstrTitle)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::Groups(THIS_ IADsMembers FAR*  FAR * ppGroups)
{
    HRESULT hr = S_OK;

    hr = CNWCOMPATUserCollection::CreateUserCollection(
             _Parent,
             _ParentType,
             _ServerName,
             _Name,
             _Credentials,
             IID_IADsMembers,
             (void **)ppGroups
             );
    NW_RRETURN_EXP_IF_ERR(hr);
}
STDMETHODIMP CNWCOMPATUser::get_HomePage(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNWCOMPATUser::put_HomePage(THIS_ BSTR bstrHomePage)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNWCOMPATUser::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNWCOMPATUser::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNWCOMPATUser::get_NamePrefix(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNWCOMPATUser::put_NamePrefix(THIS_ BSTR bstrNamePrefix)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNWCOMPATUser::get_NameSuffix(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNWCOMPATUser::put_NameSuffix(THIS_ BSTR bstrNamePrefix)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNWCOMPATUser::get_OtherName(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNWCOMPATUser::put_OtherName(THIS_ BSTR bstrOtherName)
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cuas.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(BadPasswordAttempts, long, 4)     Implemented
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//  Class CNWCOMPATUser


/* IADsFSUserAccountStatistics methods */

STDMETHODIMP CNWCOMPATUser::get_BadLoginAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, BadLoginAddress);
}

STDMETHODIMP CNWCOMPATUser::get_BadLoginCount(THIS_ long FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_LastLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastLogin);
}

STDMETHODIMP CNWCOMPATUser::get_LastLogoff(THIS_ DATE FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_LastFailedLogin(THIS_ DATE FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_PasswordLastChanged(THIS_ DATE FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cuoi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cuoi.cxx
//
//  Contents:  User Object Other Information FunctionalSet
//
//  History:   Feb-14-96     t-ptam    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Class CNWCOMPATUser
//


STDMETHODIMP CNWCOMPATUser::get_EmailAddress(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::put_EmailAddress(THIS_ BSTR bstrEmailAddress)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_HomeDirectory(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::put_HomeDirectory(THIS_ BSTR bstrHomeDirectory)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_Languages(THIS_ VARIANT FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::put_Languages(THIS_ VARIANT vLanguages)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_Profile(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::put_Profile(THIS_ BSTR bstrProfile)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_LoginScript(THIS_ BSTR FAR* retval)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::put_LoginScript(THIS_ BSTR bstrLoginScript)
{
    NW_RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cuser.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cuser.cxx
//
//  Contents:  Host user object code
//
//  History:   Feb-14-96     t-ptam    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Macro-ized implementation.
//

DEFINE_IDispatch_Implementation(CNWCOMPATUser)

DEFINE_IADs_TempImplementation(CNWCOMPATUser)

DEFINE_IADs_PutGetImplementation(CNWCOMPATUser, UserClass, gdwUserTableSize)

DEFINE_IADsPropertyList_Implementation(CNWCOMPATUser, UserClass, gdwUserTableSize)

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::CNWCOMPATUser()
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUser::CNWCOMPATUser():
        _pDispMgr(NULL),
        _pPropertyCache(NULL),
        _ParentType(0),
        _ServerName(NULL),
        _szHostServerName(NULL),
        _hConn(NULL)
{
    ENLIST_TRACKING(CNWCOMPATUser);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::CreateUser
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::CreateUser(
    BSTR Parent,
    ULONG ParentType,
    BSTR ServerName,
    BSTR UserName,
    CCredentials &Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATUser FAR * pUser = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserObject(&pUser);
    BAIL_ON_FAILURE(hr);

    hr = pUser->InitializeCoreObject(
                    Parent,
                    UserName,
                    USER_CLASS_NAME,
                    USER_SCHEMA_NAME,
                    CLSID_NWCOMPATUser,
                    dwObjectState
                    );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName , &pUser->_ServerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName,  &pUser->_szHostServerName);
    BAIL_ON_FAILURE(hr);

    pUser->_Credentials = Credentials;

    //
    // Get a handle to the bindery this object resides on.
    //

    hr = NWApiGetBinderyHandle(
             &pUser->_hConn,
             pUser->_ServerName,
             pUser->_Credentials
             );
    BAIL_ON_FAILURE(hr);


    hr = pUser->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUser->Release();
    RRETURN(hr);

error:
    delete pUser;

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::~CNWCOMPATUser
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUser::~CNWCOMPATUser( )
{
    ADsFreeString(_ServerName);
    ADsFreeString(_szHostServerName);

    delete _pDispMgr;

    delete _pPropertyCache;

    if (_hConn)
        NWApiReleaseBinderyHandle(_hConn);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsUser))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::InterfaceSupportsErrorInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsUser) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;
    NW_USER_INFO NwUserInfo = {NULL, NULL, NULL, NULL};

    //
    // Bind an object to a real tangible resource if it is not bounded already.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = BuildObjectInfo(
                _Parent,
                _Name,
                &pObjectInfo
                );
        BAIL_ON_FAILURE(hr);

        hr = NWApiMakeUserInfo(
                 pObjectInfo->ComponentArray[0],
                 pObjectInfo->ComponentArray[1],
                 L"",                              // empty password initially,
                 _Credentials,
                 &NwUserInfo
                 );
        BAIL_ON_FAILURE(hr);

        hr = NWApiCreateUser(
                 &NwUserInfo
                 );
        BAIL_ON_FAILURE(hr);

        SetObjectState(ADS_OBJECT_BOUND);
    }

    //
    // Persist changes.
    //

    hr = SetInfo(USER_WILD_CARD_ID);
    BAIL_ON_FAILURE(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    (void) NWApiFreeUserInfo(&NwUserInfo) ;

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::GetInfo(THIS)
{

   _pPropertyCache->flushpropcache();

   RRETURN(GetInfo(
               TRUE,
               USER_WILD_CARD_ID
               ));
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::AllocateUserObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::AllocateUserObject(
    CNWCOMPATUser ** ppUser
    )
{
    CNWCOMPATUser FAR * pUser = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a  User object.
    //

    pUser = new CNWCOMPATUser();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create dispatch manager.
    //

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsUser,
             (IADsUser *)pUser,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPropertyList,
             (IADsPropertyList *)pUser,
             DISPID_VALUE
             );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             UserClass,
             gdwUserTableSize,
             (CCoreADsObject *)pUser,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //
    pUser->_pPropertyCache = pPropertyCache;

    pUser->_pDispMgr = pDispMgr;
    *ppUser = pUser;

    RRETURN(hr);

error:
    delete pDispMgr;
    delete pPropertyCache;
    delete pUser;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::SetInfo(THIS_ DWORD dwPropertyID)
{
    HRESULT       hr = S_OK;


    //
    // Persist changes in cache.
    //

    hr = SetBusinessInfo(_hConn);
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        // not a real failure, but a missing attrib
        // BUGBUG: should create if missing
        hr = S_OK;
    }

    BAIL_ON_FAILURE(hr);


    hr = SetAccountRestrictions(_hConn);
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        // not a real failure, but a missing attrib
        // BUGBUG: should create if missing
        hr = S_OK;
    }
    BAIL_ON_FAILURE(hr);

error:

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::SetBusinessInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::SetBusinessInfo(
    NWCONN_HANDLE hConn
    )
{
    LPWSTR  lpszRightSize = NULL;
    LPWSTR  pszFullName = NULL;
    CHAR    szData[MAX_FULLNAME_LEN + 1];
    HRESULT hr = S_OK;

    //
    // Set FullName.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("FullName"),
                    &pszFullName
                    );

    if (SUCCEEDED(hr)) {

        //
        // Cut the FullName down to no more than MAX_FULLNAME_LEN of characters.
        //

        lpszRightSize = (LPWSTR) AllocADsMem(
                                     sizeof(WCHAR) * (MAX_FULLNAME_LEN + 1)
                                     );
        if (!lpszRightSize) {
            NW_RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
        }

        lpszRightSize[MAX_FULLNAME_LEN] = 0;

        wcsncpy(
            lpszRightSize,
            pszFullName,
            MAX_FULLNAME_LEN
            );

        //
        // Convert bstr in ANSI string.
        //

        UnicodeToAnsiString(
            lpszRightSize,
            szData,
            0
            );

        //
        // Commit change.
        //

        hr = NWApiWriteProperty(
                 hConn,
                 _Name,
                 OT_USER,
                 NW_PROP_IDENTIFICATION,
                 (LPBYTE) szData
                 );
        BAIL_ON_FAILURE(hr);

        FreeADsMem(lpszRightSize);
    }

error:

    if (pszFullName) {
        FreeADsStr(pszFullName);
    }

    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::SetAccountRestrictions
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::SetAccountRestrictions(
    NWCONN_HANDLE hConn
    )
{
    BOOL             fModified = FALSE;
    DATE             daDate  = 0;
    DWORD            dwNumSegment;
    HRESULT          hr = S_OK;
    LC_STRUCTURE     LoginCtrl;
    LONG             lData = 0;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL;
    SYSTEMTIME       SysTime;
    USER_DEFAULT     UserDefault;
    BOOL             fBool;
    WORD             wDay = 0;
    WORD             wMonth = 0;
    WORD             wYear = 0;
    WCHAR            szTemp[MAX_PATH];
    BYTE             byDateTime[6];
    BOOL             fAccntLckModified;

    hr = NWApiGetLOGIN_CONTROL(
             hConn,
             _Name,
             &LoginCtrl
             );
    BAIL_ON_FAILURE(hr);

    //
    // SET AccountDisabled.
    //

    hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("AccountDisabled"),
                &fBool
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byAccountDisabled = (BYTE) fBool;

        fModified = TRUE;
    }

    //
    // SET AccountExpirationDate.
    //

    memset(byDateTime, 0, 6);
    hr = GetNw312DATEPropertyFromCache(
                _pPropertyCache,
                TEXT("AccountExpirationDate"),
                byDateTime
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byAccountExpires[0] = (BYTE) byDateTime[0];
        LoginCtrl.byAccountExpires[1] = (BYTE) byDateTime[1];
        LoginCtrl.byAccountExpires[2] = (BYTE) byDateTime[2];

        fModified = TRUE;
    }

    //
    // SET AccountCanExpire.
    //

    hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("AccountCanExpire"),
                &fBool
                );

    if (SUCCEEDED(hr)) {

        if (fBool == FALSE) {

            LoginCtrl.byAccountExpires[0] = 0;
            LoginCtrl.byAccountExpires[1] = 0;
            LoginCtrl.byAccountExpires[2] = 0;

            fModified = TRUE;

        }
    }

    //
    // SET GraceLoginsAllowed.
    //

    hr = GetDWORDPropertyFromCache(
                _pPropertyCache,
                TEXT("GraceLoginsAllowed"),
                (PDWORD)&lData
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byGraceLoginReset = (BYTE) lData;

        fModified = TRUE;
    }

    //
    // SET GraceLoginsRemaining.
    //

    hr = GetDWORDPropertyFromCache(
                _pPropertyCache,
                TEXT("GraceLoginsRemaining"),
                (PDWORD)&lData
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byGraceLogins = (BYTE) lData;

        fModified = TRUE;
    }

    //
    // SET IsAccountLocked.
    //

    //
    // if this property not modified in cache, no need to set on svr
    //
    hr =  _pPropertyCache->propertyismodified(
                TEXT("IsAccountLocked"),
                &fAccntLckModified
                );

    if ( SUCCEEDED(hr) && fAccntLckModified==TRUE ) {

        hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("IsAccountLocked"),
                &fBool
                );

        if (SUCCEEDED(hr)) {

            //
            // If fBool is changed from TRUE to FALSE, set wBadLogins 
            // back to 0  -> this will unlock account on nw svr
            //

            if (fBool == FALSE) {

                LoginCtrl.wBadLogins = 0;
                fModified = TRUE;

            }else {

                //
                // Reset it to FALSE if it is changed to TRUE.
                // -> cannot lock an account on nwsvr thru' adsi
                //

                fBool = FALSE;

                hr = SetBOOLPropertyInCache(
                        _pPropertyCache,
                        TEXT("IsAccountLocked"),
                        fBool,
                        TRUE
                        );
                BAIL_ON_FAILURE(hr);
            }
        }
    }

    //
    // SET IsAdmin.
    //

    hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("IsAdmin"),
                &fBool
                );

    if (SUCCEEDED(hr)) {

        hr = NWApiUserAsSupervisor(
                 hConn,
                 _Name,
                 fBool
                 );

        //
        // For beta, disabling the bail. It does not work in the user not
        // supervisor mode.
        //

        // BAIL_ON_FAILURE(hr);
    }

    //
    // SET MaxLogins.
    //

    hr = GetDWORDPropertyFromCache(
                _pPropertyCache,
                TEXT("MaxLogins"),
                (PDWORD)&lData
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.wMaxConnections = NWApiReverseWORD(
                                        (WORD) lData
                                        );

        fModified = TRUE;
    }

    //
    // SET PasswordExpirationDate.
    //

    memset(byDateTime, 0, 6);
    hr = GetNw312DATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PasswordExpirationDate"),
                    byDateTime
                    );

    if (SUCCEEDED(hr)) {


        LoginCtrl.byPasswordExpires[0] = (BYTE) byDateTime[0];
        LoginCtrl.byPasswordExpires[1] = (BYTE) byDateTime[1];
        LoginCtrl.byPasswordExpires[2] = (BYTE) byDateTime[2];

        fModified = TRUE;
    }

    //
    // SET PasswordCanExpire.
    //

    hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("PasswordCanExpire"),
                &fBool
                );

    if (SUCCEEDED(hr)) {

        if (fBool == FALSE) {

            //
            // If passowrd cannot expire, set password expiration date to zero.
            // This is what SysCon does.
            //

            LoginCtrl.byPasswordExpires[0] = 0;
            LoginCtrl.byPasswordExpires[1] = 0;
            LoginCtrl.byPasswordExpires[2] = 0;

            fModified = TRUE;

        }
    }

    //
    // SET PasswordMinimumLength.
    //

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PasswordMinimumLength"),
                    (PDWORD)&lData
                    );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byMinPasswordLength = (BYTE) lData;

        fModified = TRUE;
    }

    //
    // SET PasswordRequired.  The section below must goes before "Set
    // PasswordMinimumLength" for it to make sense.
    //

    hr = GetBOOLPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PasswordRequired"),
                    &fBool
                    );


    if (SUCCEEDED(hr)) {

        //
        // If Password is required, set PasswordMinimumLength to default value.
        //

        //
        // If Password is not required, set PasswordMinimumLength to 0.  Again,
        // this is what SysCon does.
        //

        if (fBool) {
            if (!LoginCtrl.byMinPasswordLength) {
                LoginCtrl.byMinPasswordLength = DEFAULT_MIN_PSWD_LEN;
            }
        }else{
            LoginCtrl.byMinPasswordLength = 0;
        }

        fModified = TRUE;
    }

    //
    // Set LoginHours
    //
	OctetString octString;

    hr = GetOctetPropertyFromCache(
                _pPropertyCache,
                TEXT("LoginHours"),
                &octString
                );

    if (SUCCEEDED(hr)) {
        memcpy(LoginCtrl.byLoginTimes, octString.pByte, octString.dwSize);
		FreeADsMem(octString.pByte);
        fModified = TRUE;
    }

    //
    // Set RequireUniquePassword.
    //

    hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("RequireUniquePassword"),
                &fBool
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byRestrictions =  fBool ? REQUIRE_UNIQUE_PSWD : 0;

        fModified = TRUE;

    }

    //
    // Commit changes of the properties associated with LOGIN_CONTROL.
    //

    if (fModified == TRUE) {

        hr = NWApiWriteProperty(
                 hConn,
                 _Name,
                 OT_USER,
                 NW_PROP_LOGIN_CONTROL,
                 (LPBYTE) &LoginCtrl
                 );
    }
    else {

        hr = S_OK;
    }

error:

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::GetInfo(
    BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    HRESULT       hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        NW_RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // Fill in all property caches with values - explicit, or return the
    // indicated property - implicit.
    //

    if (fExplicit) {
       hr = ExplicitGetInfo(_hConn, fExplicit);
       BAIL_ON_FAILURE(hr);
    }
    else {
       hr = ImplicitGetInfo(_hConn, dwPropertyID, fExplicit);
       BAIL_ON_FAILURE(hr);
    }

error:
    //
    // Release handle.
    //

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::ExplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::ExplicitGetInfo(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    LC_STRUCTURE LoginCtrlStruct;

    //
    // Get BusinessInfo functional set.
    //

    hr = GetProperty_FullName(
             hConn,
             fExplicit
             );

    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        // not a real failure, we ignore it and treat it as a missing attrib
        hr = S_OK;
    }

    BAIL_ON_FAILURE(hr);


    // Is it an admin?  This is part of the AccountRestriction functional set, but is
    // independent of LOGIN_CONTROL, so it needs to go here.
    hr = GetProperty_IsAdmin(
             hConn,
             fExplicit
             );

    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        // not a real failure, we ignore it and treat it as a missing attrib
        hr = S_OK;
    }

    BAIL_ON_FAILURE(hr);

    //
    // Get LOGIN_CONTROL, which is used in AccountRestriction functional set &
    // AccountStatistics functional set.
    //

    hr = NWApiGetLOGIN_CONTROL(
             hConn,
             _Name,
             &LoginCtrlStruct
             );

    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        // not a real failure, we ignore it and treat it as a missing attrib,
        // and skip the LOGIN_CONTROL-dependent code
        hr = S_OK;
    }
    else
    {
        BAIL_ON_FAILURE(hr);

        //
        // Get AccountRestriction functional set.
        //

        hr = GetProperty_LoginHours(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_AccountDisabled(

                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_AccountExpirationDate(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_CanAccountExpire(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_GraceLoginsAllowed(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_GraceLoginsRemaining(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_IsAccountLocked(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_MaxLogins(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_CanPasswordExpire(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_PasswordExpirationDate(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_PasswordMinimumLength(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_PasswordRequired(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_RequireUniquePassword(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);

        //
        // Get AccountStatistics functional set.
        //

        hr = GetProperty_BadLoginAddress(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_LastLogin(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);
    }

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::ImplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::ImplicitGetInfo(
    NWCONN_HANDLE hConn,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    if (dwPropertyID < 100) {
        hr = GetBusinessInfo(
                 hConn,
                 dwPropertyID,
                 fExplicit
                 );
    }
    else if (dwPropertyID < 200) {
        hr = GetAccountRestrictions(
                 hConn,
                 dwPropertyID,
                 fExplicit
                 );
    }
    else if (dwPropertyID < 300) {
        hr = GetAccountStatistics(
                 hConn,
                 dwPropertyID,
                 fExplicit
                 );
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetBusinessInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetBusinessInfo(
    NWCONN_HANDLE hConn,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    switch (dwPropertyID) {

    case USER_FULLNAME_ID:
         hr = GetProperty_FullName(
                  hConn,
                  fExplicit
                  );
         break;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetAccountRestrictions
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetAccountRestrictions(
    NWCONN_HANDLE hConn,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    LC_STRUCTURE LoginCtrlStruct;

    //
    // Get LOGIN_CONTROL.
    //

    hr = NWApiGetLOGIN_CONTROL(
             hConn,
             _Name,
             &LoginCtrlStruct
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get property.
    //

    switch (dwPropertyID) {

    case USER_ACCOUNTDISABLED_ID:
         hr = GetProperty_AccountDisabled(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
         break;

    case USER_ACCOUNTEXPIRATIONDATE_ID:
         hr = GetProperty_AccountExpirationDate(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
         break;

    case USER_CANACCOUNTEXPIRE_ID:
         hr = GetProperty_CanAccountExpire(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
         break;

    case USER_GRACELOGINSALLOWED_ID:
         hr = GetProperty_GraceLoginsAllowed(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
                  break;

    case USER_GRACELOGINSREMAINING_ID:
         hr = GetProperty_GraceLoginsRemaining(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
         break;

    case USER_ISACCOUNTLOCKED_ID:
         hr = GetProperty_IsAccountLocked(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
         break;

    case USER_ISADMIN_ID:
         hr = GetProperty_IsAdmin(
                  hConn,
                  fExplicit
                  );
         break;

    case USER_MAXLOGINS_ID:
         hr = GetProperty_MaxLogins(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
         break;

    case USER_CANPASSWORDEXPIRE_ID:
         hr = GetProperty_CanPasswordExpire(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
         break;

    case USER_PASSWORDEXPIRATIONDATE_ID:
         hr = GetProperty_PasswordExpirationDate(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
         break;

    case USER_PASSWORDMINIMUMLENGTH_ID:
         hr = GetProperty_PasswordMinimumLength(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
         break;

    case USER_PASSWORDREQUIRED_ID:
         hr = GetProperty_PasswordRequired(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
         break;

    case USER_REQUIREUNIQUEPASSWORD_ID:
         hr = GetProperty_RequireUniquePassword(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
         break;

     case USER_LOGINHOURS_ID:
         hr = GetProperty_LoginHours(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
         break;

    }

error:

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetAccountStatistics
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetAccountStatistics(
    NWCONN_HANDLE hConn,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    LC_STRUCTURE LoginCtrlStruct;

    //
    // Get LOGIN_CONTROL.
    //

    hr = NWApiGetLOGIN_CONTROL(
             hConn,
             _Name,
             &LoginCtrlStruct
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get property.
    //

    switch (dwPropertyID) {

    case USER_BADLOGINADDRESS_ID:
         hr = GetProperty_BadLoginAddress(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
         break;

    case USER_LASTLOGIN_ID:
         hr = GetProperty_LastLogin(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
         break;
    }

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_FullName
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_FullName(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    LPWSTR           lpszFullName = NULL;
    CHAR             szFullName[MAX_FULLNAME_LEN + 1];
    DWORD            dwNumSegment = 0;
    HRESULT          hr = S_OK;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL; // Used by DELETE_LIST macro below

    //
    // Get IDENTIFICATIOIN.  This property contains the full name of an object.
    //

    hr = NWApiGetProperty(
             _Name,
             NW_PROP_IDENTIFICATION,
             OT_USER,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );

    //
    // There was a bug marked on this code because NWApiGetProperty would fail with
    // an error if the property didn't exist (raid #34833), and the temp patch was
    // simply to hide all errors and always return S_OK when GetProperty_FullName
    // returned.  Now NWApiGetProperty will return E_ADS_PROPERTY_NOT_FOUND.
    //


    BAIL_ON_FAILURE(hr);

    //
    // Convert result into a UNICODE string.
    //

    strcpy(szFullName, lpReplySegment->Segment);

    lpszFullName = (LPWSTR) AllocADsMem(
                                (strlen(szFullName)+1) * sizeof(WCHAR)
                                );

    AnsiToUnicodeString(
        szFullName,
        lpszFullName,
        0
        );

    //
    // Unmarshall.
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("FullName"),
                (LPWSTR)lpszFullName,
                fExplicit
                );
    BAIL_ON_FAILURE(hr);

error:

    if (lpszFullName) {

        FreeADsMem(lpszFullName);
    }
    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }



    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_AccountDisabled
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_AccountDisabled(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // Put value into a variant.
    //

    dwBool = (BOOL) LoginCtrlStruct.byAccountDisabled;

    //
    // Unmarshall.
    //

    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("AccountDisabled"),
             dwBool,
             fExplicit
             );


    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_AccountExpirationDate
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_AccountExpirationDate(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    BYTE byDateTime[6];
    BYTE byNoDateTime[6];

    memset(byNoDateTime, 0, 6);
    memset(byDateTime, 0, 6);
    memcpy(byDateTime, LoginCtrlStruct.byAccountExpires, 3);

    //
    // LoginCtrlSturct.byAccountExpires == 000 indicates no expired date
    //
    if (memcmp(byDateTime, byNoDateTime, 3)!=0) {

        hr = SetNw312DATEPropertyInCache(
                    _pPropertyCache,
                    TEXT("AccountExpirationDate"),
                    byDateTime,
                    fExplicit
                    );

        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_CanAccountExpire
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_CanAccountExpire(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // Account cannot expire if there is no expiration date.
    //

    if ((LoginCtrlStruct.byAccountExpires[0] == 0) &&
        (LoginCtrlStruct.byAccountExpires[1] == 0) &&
        (LoginCtrlStruct.byAccountExpires[2] == 0)) {

        dwBool = FALSE;
    }

    //
    // Unmarshall.
    //

    hr = SetBOOLPropertyInCache(
            _pPropertyCache,
            TEXT("AccountCanExpire"),
            dwBool,
            fExplicit
            );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_GraceLoginsAllowed
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_GraceLoginsAllowed(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    LONG         lGraceLoginsAllowed = 0;

    //
    // Get "byGraceLoginReset".  The property is not meaningful when it equals
    // to 0xff.
    //

    if (LoginCtrlStruct.byGraceLoginReset != 0xff) {

        lGraceLoginsAllowed = (LONG) LoginCtrlStruct.byGraceLoginReset;
    }

    //
    // Unmarshall.
    //

    hr = SetDWORDPropertyInCache(
             _pPropertyCache,
             TEXT("GraceLoginsAllowed"),
             (DWORD)lGraceLoginsAllowed,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_GraceLoginsRemaining
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_GraceLoginsRemaining(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    LONG         lGraceLoginsRemaining = 0;

    //
    // Get "byGraceLogins".  The property is not meaningful when it equals to
    // 0xff.
    //

    if (LoginCtrlStruct.byGraceLogins != 0xff) {

        lGraceLoginsRemaining = (LONG) LoginCtrlStruct.byGraceLogins;
    }

    //
    // Unmarshall.
    //

    hr = SetDWORDPropertyInCache(
             _pPropertyCache,
             TEXT("GraceLoginsRemaining"),
             (DWORD)lGraceLoginsRemaining,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_IsAccountLocked
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_IsAccountLocked(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = FALSE;
    HRESULT      hr = S_OK;

    //
    // Account is locked when wBadLogins = 0xffff.
    //

    if (LoginCtrlStruct.wBadLogins == 0xffff) {

        dwBool = TRUE;
    }

    //
    // Unmarshall.
    //

    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("IsAccountLocked"),
             dwBool,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_IsAdmin
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_IsAdmin(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    BOOL    dwBool = TRUE;
    HRESULT hr = S_OK;

    //
    // Check if this user has the same security as the supervisor.  If it does,
    // then it is an admin.
    //

    hr = NWApiIsObjectInSet(
             hConn,
             _Name,
             OT_USER,
             NW_PROP_SECURITY_EQUALS,
             NW_PROP_SUPERVISOR,
             OT_USER
             );

    //
    // BUGBUG - for now, any failure is assumed to be "No such object.".  Fix
    // this after bug #33322 is fixed.
    //

    if (FAILED(hr)) {
        dwBool = FALSE;
    }

    //
    // Unmarshall.
    //

    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("IsAdmin"),
             dwBool,
             fExplicit
             );

    //
    // BUGBUG - replace S_OK with hr (see above).
    //

    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_MaxLogins
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_MaxLogins(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    LONG         lMaxLogins = 0;

    //
    // Get "wMaxConnections".
    //

    lMaxLogins = (LONG) NWApiReverseWORD(
                            LoginCtrlStruct.wMaxConnections
                            );

    //
    // Unmarshall.
    //

    hr = SetDWORDPropertyInCache(
             _pPropertyCache,
             TEXT("MaxLogins"),
             (DWORD)lMaxLogins,
             fExplicit
             );


    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_CanPasswordExpire
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_CanPasswordExpire(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // Password cannot expire if there is no expiration date.
    //

    if ((LoginCtrlStruct.byPasswordExpires[0] == 0) &&
        (LoginCtrlStruct.byPasswordExpires[1] == 0) &&
        (LoginCtrlStruct.byPasswordExpires[2] == 0)) {

        dwBool = FALSE;
    }

    //
    // Unmarshall.
    //
    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("PasswordCanExpire"),
             dwBool,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_PasswordExpirationDate
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_PasswordExpirationDate(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    BYTE byDateTime[6];

    memset(byDateTime, 0, 6);
    memcpy(byDateTime, LoginCtrlStruct.byPasswordExpires, 3);

    hr = SetNw312DATEPropertyInCache(
                _pPropertyCache,
                TEXT("PasswordExpirationDate"),
                byDateTime,
                fExplicit
                );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_PasswordMinimumLength
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_PasswordMinimumLength(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    LONG         lMinimumLength = 0;

    //
    // Get "byMinPasswordLength".
    //

    lMinimumLength = (LONG) LoginCtrlStruct.byMinPasswordLength;

    //
    // Unmarshall.
    //

    hr = SetDWORDPropertyInCache(
             _pPropertyCache,
             TEXT("PasswordMinimumLength"),
             (DWORD)lMinimumLength,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_PasswordRequired
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_PasswordRequired(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // Password is not required if "byMinPasswordLength" is 0.
    //

    if (LoginCtrlStruct.byMinPasswordLength == 0) {

        dwBool = FALSE;
    }

    //
    // Unmarshall.
    //

    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("PasswordRequired"),
             dwBool,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_RequireUniquePassword
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_RequireUniquePassword(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // If byRestrictions = 0, "RequireUniquePassword" = FALSE.
    //

    if (LoginCtrlStruct.byRestrictions == 0) {

        dwBool = FALSE;
    }

    //
    // Unmarshall.
    //
    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("RequireUniquePassword"),
             dwBool,
             fExplicit
             );

    RRETURN(hr);
}

HRESULT
CNWCOMPATUser::GetProperty_LoginHours(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // Unmarshall.
    //
    hr = SetOctetPropertyInCache(
             _pPropertyCache,
             TEXT("LoginHours"),
             (BYTE*)LoginCtrlStruct.byLoginTimes,
             42,
             fExplicit
             );

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_BadLoginAddress
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_BadLoginAddress(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    LPWSTR  lpszTemp = NULL;

    //
    // Put address together in the format described in spec.
    //

    lpszTemp = (LPWSTR) AllocADsMem((NET_ADDRESS_NUM_CHAR+1)*sizeof(WCHAR));
    if (!lpszTemp) {
        RRETURN(E_OUTOFMEMORY);
    }

    wsprintf(
        lpszTemp,
        L"%s:%02X%02X%02X%02X.%02X%02X%02X%02X%02X%02X.%02X%02X",
        bstrAddressTypeString,
        LoginCtrlStruct.byBadLoginAddr[10],
        LoginCtrlStruct.byBadLoginAddr[11],
        LoginCtrlStruct.byBadLoginAddr[0],
        LoginCtrlStruct.byBadLoginAddr[1],
        LoginCtrlStruct.byBadLoginAddr[2],
        LoginCtrlStruct.byBadLoginAddr[3],
        LoginCtrlStruct.byBadLoginAddr[4],
        LoginCtrlStruct.byBadLoginAddr[5],
        LoginCtrlStruct.byBadLoginAddr[6],
        LoginCtrlStruct.byBadLoginAddr[7],
        LoginCtrlStruct.byBadLoginAddr[8],
        LoginCtrlStruct.byBadLoginAddr[9]
        );

    //
    // Unmarshall.
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("BadLoginAddress"),
                (LPWSTR)lpszTemp,
                fExplicit
                );
    BAIL_ON_FAILURE(hr);

error:

    if (lpszTemp) {

        FreeADsMem(lpszTemp);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_LastLogin
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_LastLogin(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{

    HRESULT hr = S_OK;
    BYTE byNoDateTime[6];
    
    memset(byNoDateTime, 0, 6);
    
    //
    // LastLogin==000000 indicates no or unknown LastLogin
    //
    if (memcmp(LoginCtrlStruct.byLastLogin, byNoDateTime, 6) != 0)  {

        hr =  SetNw312DATEPropertyInCache(
                _pPropertyCache,
                TEXT("LastLogin"),
                LoginCtrlStruct.byLastLogin,
                fExplicit
                );
    }

    RRETURN(hr);
}



HRESULT
ConvertNW312DateToVariant(
    BYTE byDateTime[],
    PDATE pDate
    )
{
    HRESULT hr = S_OK;
    WORD wYear;

    //
    // Subtract 80 from wYear for NWApiMakeVariantTime.
    //

    wYear = (WORD)byDateTime[0];

    if (wYear != 0) {
        wYear -= 80;
    }

    //
    // Convert into Variant Time.
    //

    hr = NWApiMakeVariantTime(
                pDate,
                (WORD)byDateTime[2],
                (WORD)byDateTime[1],
                wYear,
                0,0,0
                );
    RRETURN(hr);
}


HRESULT
ConvertVariantToNW312Date(
    DATE daDate,
    BYTE byDateTime[]
    )
{
    WORD wDay;
    WORD wYear;
    WORD wMonth;
    HRESULT hr = S_OK;

    hr = NWApiBreakVariantTime(
                daDate,
                &wDay,
                &wMonth,
                &wYear
                );
    BAIL_ON_FAILURE(hr);

    byDateTime[0] = (BYTE)wYear;
    byDateTime[1] = (BYTE)wMonth;
    byDateTime[2] = (BYTE)wDay;

    byDateTime[3] = 0;
    byDateTime[4] = 0;
    byDateTime[5] = 0;

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\getobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  getobj.cxx
//
//  Contents:  NetWare 3.12 GetObject functionality
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//  Function:  GetObject
//
//  Synopsis:  Called by ResolvePathName to return an object
//
//  Arguments:  [LPWSTR szBuffer]
//              [CCredentials &Credentials]
//              [LPVOID *ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    11-Jan-96   t-ptam     Created.
//
//----------------------------------------------------------------------------

HRESULT
GetObject(
    LPWSTR szBuffer,
    CCredentials &Credentials,
    LPVOID * ppObject
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);
    HRESULT hr = S_OK;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = ValidateProvider(pObjectInfo);
    BAIL_ON_FAILURE(hr);

    switch (pObjectInfo->ObjectType) {
    case TOKEN_COMPUTER:
        hr = GetComputerObject(pObjectInfo, Credentials, ppObject);
        break;

    case TOKEN_USER:
        hr = GetUserObject(pObjectInfo, Credentials, ppObject);
        break;

    case TOKEN_GROUP:
        hr = GetGroupObject(pObjectInfo, Credentials, ppObject);
        break;

    case TOKEN_SCHEMA:
        hr = GetSchemaObject(pObjectInfo, Credentials, ppObject);
        break;

    case TOKEN_CLASS:
        hr = GetClassObject(pObjectInfo, ppObject);
        break;

    case TOKEN_PROPERTY:
        hr = GetPropertyObject(pObjectInfo, ppObject);
        break;

    case TOKEN_SYNTAX:
        hr = GetSyntaxObject(pObjectInfo, ppObject);
        break;

    case TOKEN_FILESERVICE:
        hr = GetFileServiceObject(pObjectInfo, Credentials, ppObject);
        break;

    case TOKEN_FILESHARE:
        hr = GetFileShareObject(pObjectInfo, Credentials, ppObject);
        break;

    case TOKEN_PRINTER:
        hr = GetPrinterObject(pObjectInfo, Credentials, ppObject);
        break;

    default:
        hr = HeuristicGetObject(pObjectInfo, Credentials, ppObject);
        break;
    }

error:

    FreeObjectInfo( &ObjectInfo, TRUE );
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HeuristicGetObject
//
// Synopsis:   Get object of yet undetermined type.
//
// Arguments:  [POBJECTINFO pObjectInfo]
//             [CCredentials &Credentials]
//             [LPVOID *ppObject]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    11-Jan-96   t-ptam     Created.
//
//----------------------------------------------------------------------------

HRESULT
HeuristicGetObject(
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;

    //
    // Case 0: No componenet - Namespace object.
    //

    if (pObjectInfo->NumComponents == 0) {
        RRETURN(GetNamespaceObject(pObjectInfo, Credentials, ppObject));
    }

    //
    // Case 1: Single component - Computer object.
    //

    if (pObjectInfo->NumComponents == 1) {

        RRETURN(GetComputerObject(pObjectInfo, Credentials, ppObject));
    }

    //
    // Case 2: Two components - FileService object
    //                          Group object
    //                          Schema object
    //                          User object
    //                          Printer object
    //

    if (pObjectInfo->NumComponents == 2) {

        hr = GetSchemaObject(pObjectInfo, Credentials, ppObject);

        if (FAILED(hr)) {

            hr = GetUserObject(pObjectInfo, Credentials, ppObject);

            if (FAILED(hr)) {

                hr = GetGroupObject(pObjectInfo, Credentials, ppObject);

                if (FAILED(hr)) {

                    hr = GetFileServiceObject(pObjectInfo, Credentials, ppObject);

                    if (FAILED(hr)) {

                        hr = GetPrinterObject(pObjectInfo, Credentials, ppObject);
                    }
                }
            }
        }

        if (FAILED(hr)) {
           hr = E_ADS_UNKNOWN_OBJECT;
        }
        else {
           RRETURN(S_OK);
        }
    }

    //
    // Case 3: Three components - FileShare object
    //                            Schema Class object
    //                            Schema FunctionSet object
    //                            Schema Syntax object
    //

    if (pObjectInfo->NumComponents == 3) {

        hr = GetFileShareObject(pObjectInfo, Credentials, ppObject);

        if (FAILED(hr)) {

            if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) == 0 ){

                hr = GetClassObject(pObjectInfo, ppObject);

                if (FAILED(hr)) {
                    hr = GetPropertyObject(pObjectInfo, ppObject);
                }

                if (FAILED(hr)) {

                    hr = GetSyntaxObject(pObjectInfo, ppObject);
                }
            }
        }

        if (FAILED(hr)) {
           hr = E_ADS_UNKNOWN_OBJECT;
        }
        else {
           RRETURN(S_OK);
        }
    }

    //
    // Case 4: Four components - Schema FunctionSetAlias object
    //                           Schema Property object
    //

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetNamespaceObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             CCredentials &Credentials
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    04-Mar-96   t-ptam     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetNamespaceObject(
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ValidateNamespaceObject(
             pObjectInfo,
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATNamespace::CreateNamespace(
                L"ADs:",
                L"NWCOMPAT:",
                Credentials,
                ADS_OBJECT_BOUND,
                IID_IUnknown,
                ppObject
                );
    BAIL_ON_FAILURE(hr);
             

    RRETURN(hr);

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetComputerObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             CCredentials &Credentials
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    11-Jan-96   t-ptam     Created.
//
//----------------------------------------------------------------------------

HRESULT
GetComputerObject(
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidateComputerObject(
             pObjectInfo,
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATComputer::CreateComputer(
             ADsParent,
             pObjectInfo->ComponentArray[0],
             Credentials,
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetUserObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             CCredentials &Credentials
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    29-Feb-96   t-ptam     Created.
//
//----------------------------------------------------------------------------

HRESULT
GetUserObject(
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidateUserObject(
             pObjectInfo,
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATUser::CreateUser(
             ADsParent,
             NWCOMPAT_COMPUTER_ID,
             pObjectInfo->ComponentArray[0],
             pObjectInfo->ComponentArray[1],
             Credentials,
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetGroupObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             CCredentials &Credentials
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    29-Feb-96   t-ptam     Created.
//
//----------------------------------------------------------------------------

HRESULT
GetGroupObject(
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidateGroupObject(
             pObjectInfo,
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATGroup::CreateGroup(
             ADsParent,
             NWCOMPAT_COMPUTER_ID,
             pObjectInfo->ComponentArray[0],
             pObjectInfo->ComponentArray[1],
             Credentials,
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetSchemaObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetSchemaObject(
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;

    if (pObjectInfo->NumComponents != 2)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATSchema::CreateSchema(
             ADsParent,
             pObjectInfo->ComponentArray[1],
             Credentials,
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             (void **)&pUnknown
             );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetClassObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetClassObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    DWORD i;

    if (pObjectInfo->NumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Look for the given class name
    //

    for ( i = 0; i < g_cNWCOMPATClasses; i++ )
    {
         if ( _wcsicmp( g_aNWCOMPATClasses[i].bstrName,
                        pObjectInfo->ComponentArray[2] ) == 0 )
             break;
    }

    if ( i == g_cNWCOMPATClasses )
    {
        //
        // Class name not found, return error
        //

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Class name found, create and return the object
    //

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATClass::CreateClass(
             ADsParent,
             &g_aNWCOMPATClasses[i],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             (void **)&pUnknown
             );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetSyntaxObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetSyntaxObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    DWORD i;

    if (pObjectInfo->NumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Look for the given syntax name
    //

    for ( i = 0; i < g_cNWCOMPATSyntax; i++ )
    {
         if ( _wcsicmp( g_aNWCOMPATSyntax[i].bstrName,
                        pObjectInfo->ComponentArray[2] ) == 0 )
             break;
    }

    if ( i == g_cNWCOMPATSyntax )
    {
        //
        // Syntax name not found, return error
        //

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Syntax name found, create and return the object
    //

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATSyntax::CreateSyntax(
             ADsParent,
             &g_aNWCOMPATSyntax[i],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             (void **)&pUnknown
             );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetPropertyObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetPropertyObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    WCHAR ADsGrandParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    DWORD nClass, nProp;

    if (pObjectInfo->NumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We found the specified functional set, now see if we can locate
    // the given property name
    //

    for ( nProp = 0; nProp < g_cNWCOMPATProperties; nProp++ )
    {
         if ( _wcsicmp(g_aNWCOMPATProperties[nProp].szPropertyName,
                        pObjectInfo->ComponentArray[2] ) == 0 )
             break;
    }

    if ( nProp == g_cNWCOMPATProperties )
    {
        // Return error because the given property name is not found

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Property name is found, so create and return the object
    //

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = BuildGrandParent(pObjectInfo, ADsGrandParent);
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATProperty::CreateProperty(
             ADsParent,
             &(g_aNWCOMPATProperties[nProp]),
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             (void **)&pUnknown
             );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetFileServiceObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             CCredentials &Credentials
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    22-Apr-96   t-ptam     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetFileServiceObject(
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidateFileServiceObject(
             pObjectInfo,
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATFileService::CreateFileService(
             ADsParent,
             pObjectInfo->ComponentArray[0],
             pObjectInfo->ComponentArray[1],
             Credentials,
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetFileShareObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             CCredentials &Credentials
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    22-Apr-96   t-ptam     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetFileShareObject(
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidateFileShareObject(
             pObjectInfo,
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATFileShare::CreateFileShare(
             ADsParent,
             pObjectInfo->ComponentArray[2],
             Credentials,
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetPrinterObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             CCredentials &Credentials
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    2-May-96   t-ptam     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetPrinterObject(
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidatePrinterObject(
             pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATPrintQueue::CreatePrintQueue(
             ADsParent,
             pObjectInfo->ComponentArray[1],
             Credentials,
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidateNamespaceObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             CCredentials &Credentials
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    16-Jan-96   t-ptam (Patrick)     Created.
//
//----------------------------------------------------------------------------
HRESULT
ValidateNamespaceObject(
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials
    )
{

    //
    // BugBug -- KrishnaG  move this to a global string.
    //
    if (!_wcsicmp(pObjectInfo->ProviderName, bstrProviderName)) {
    }
    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   ValidateComputerObject
//
// Synopsis:   Validate the existence of a computer object by obtaining
//             a handle to it.  A computer object must exist if a handle
//             to it can be obtained.
//
// Arguments:  [LPWSTR szComputerName]
//             CCredentials &Credentials
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    16-Jan-96   t-ptam (Patrick)     Created.
//
//----------------------------------------------------------------------------

HRESULT
ValidateComputerObject(
     POBJECTINFO pObjectInfo,
     CCredentials &Credentials
     )
{
    //
    // A handle of a certain bindery can only be obtained if the bindery
    // exist.  Therefore we used this fact to validate the existence of
    // a computer object.
    //

    NWCONN_HANDLE hConn = NULL;
    HRESULT hr = S_OK;

    if (pObjectInfo->NumComponents != 1) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Try to obtain a handle to a NWCOMPAT Server.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0],
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Detach handle.
    //

    hr = NWApiReleaseBinderyHandle(
             hConn
             );

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidateUserObject
//
// Synopsis:   Validate the existence of a computer object by obtaining
//             a handle to it.  A computer object must exist if a handle
//             to it can be obtained.
//
// Arguments:  [LPWSTR szComputerName]
//             CCredentials &Credentials
//
// Returns:    HRESULT
//
// Modifies:   pObjectInfo->ComponentArray[1] is upper-cased
//
// History:    29-Feb-96   t-ptam (Patrick)     Created.
//             29-Jul-96   t-danal              Uppercase fix.
//
// Note:       Netware will let you create a lowercase user name but will
//             internally store only uppercase.  However, it will not
//             return the uppercase user name on a lowercase request.
//
//----------------------------------------------------------------------------

HRESULT
ValidateUserObject(
     POBJECTINFO pObjectInfo,
     CCredentials &Credentials
     )
{
    NWCONN_HANDLE hConn = NULL;
    HRESULT hr = S_OK;
    DWORD dwResumeObjectID = 0xffffffff;

    if (pObjectInfo->NumComponents != 2) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Obtain a handle to a NetWare Server.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0],
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get the specified (uppercased) user object.
    //

    hr = NWApiValidateObject(
             hConn,
             OT_USER,
             _wcsupr(pObjectInfo->ComponentArray[1]),
             &dwResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

error:
    if (hConn) {
        NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidateGroupObject
//
// Synopsis:   Validate the existence of a group object by scanning
//             for it in the bindery.
//
// Arguments:  [POBJECTINFO pObjectInfo]
//             CCredentials &Credentials
//
// Returns:    HRESULT
//
// Modifies:   pObjectInfo->ComponentArray[1] is upper-cased
//
// History:    29-Feb-96   t-ptam (Patrick)     Created.
//             29-Jul-96   t-danal              Uppercase fix.
//
// Note:       Netware will let you create a lowercase user name but will
//             internally store only uppercase.  However, it will not
//             return the uppercase user name on a lowercase request.
//
//----------------------------------------------------------------------------

HRESULT
ValidateGroupObject(
     POBJECTINFO pObjectInfo,
     CCredentials &Credentials
     )
{
    NWCONN_HANDLE hConn = NULL;
    HRESULT hr = S_OK;
    DWORD dwResumeObjectID = 0xffffffff;

    if (pObjectInfo->NumComponents != 2) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Obtain a handle to a NetWare Server.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0],
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get the specified (uppercased) group object.
    //

    hr = NWApiValidateObject(
             hConn,
             OT_USER_GROUP,
             _wcsupr(pObjectInfo->ComponentArray[1]),
             &dwResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

error:
    if (hConn) {
        NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidateFileServiceObject
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//             CCredentials &Credentials
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    22-Apr-96   t-ptam (Patrick)     Created.
//
//----------------------------------------------------------------------------
HRESULT
ValidateFileServiceObject(
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials
    )
{
    //
    // In NetWare, a FileService object represents a bindery, which is also
    // represented as a computer object.  Therefore validation of file service
    // object can be done the same way as the computer object.
    //

    //
    // A handle of a certain bindery can only be obtained if the bindery exist.
    // Therefore we used this fact to validate the existence of a computer
    // object.
    //

    NWCONN_HANDLE hConn = NULL;
    HRESULT hr = S_OK;

    if (pObjectInfo->NumComponents != 2) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Check for valid NetWare File Server name.
    //

    if (_wcsicmp(pObjectInfo->ComponentArray[1], bstrNWFileServiceName)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Try to obtain a handle to a NWCOMPAT Server.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0],
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Detach handle.
    //

    hr = NWApiReleaseBinderyHandle(
             hConn
             );

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidateFileShareObject
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//             CCredentials &Credentials
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    29-Apr-96   t-ptam (Patrick)     Created.
//
//----------------------------------------------------------------------------
HRESULT
ValidateFileShareObject(
     POBJECTINFO pObjectInfo,
     CCredentials &Credentials
     )
{
    HRESULT hr = S_OK;
    DWORD dwResumeObjectID = 0xffffffff;
    NWCONN_HANDLE hConn = NULL;
    NWVOL_NUM VolumeNumber = 0;

    if (pObjectInfo->NumComponents != 3) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Obtain a handle to a NetWare Server.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0],
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Try to get the Volume ID that correspond to the Volume name.  If it
    // succeeds, the FileShare is valid.
    //

    hr = NWApiGetVolumeNumber(
             hConn,
             pObjectInfo->ComponentArray[2],
             &VolumeNumber
             );
    BAIL_ON_FAILURE(hr);

error:
    if (hConn) {
        NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidatePrinterObject
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    2-May-96   t-ptam (Patrick)     Created.
//
//----------------------------------------------------------------------------
HRESULT
ValidatePrinterObject(
     POBJECTINFO pObjectInfo
     )
{
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    WCHAR szUncName[MAX_PATH];

    if (pObjectInfo->NumComponents != 2) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Build UNC name from ObjectInfo.
    //

    wsprintf(
        szUncName,
        L"\\\\%s\\%s",
        pObjectInfo->ComponentArray[0],
        pObjectInfo->ComponentArray[1]
        );

    //
    // Get a handle of the printer.
    //

    hr = NWApiOpenPrinter(
             szUncName,
             &hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Release it.
    //

    hr = NWApiClosePrinter(
             hPrinter
             );
error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   BuildParent
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//             [LPWSTR szBuffer]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------

HRESULT
BuildParent(
    POBJECTINFO pObjectInfo,
    LPWSTR szBuffer
    )
{
    DWORD i = 0;


    if (!pObjectInfo->ProviderName) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    wsprintf(szBuffer,L"%s:", pObjectInfo->ProviderName);

    if (pObjectInfo->NumComponents - 1) {

        wcscat(szBuffer, L"//");
        wcscat(szBuffer, pObjectInfo->DisplayComponentArray[0]);

        for (i = 1; i < (pObjectInfo->NumComponents - 1); i++) {
            wcscat(szBuffer, L"/");
            wcscat(szBuffer, pObjectInfo->DisplayComponentArray[i]);
        }
    }
    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   BuildGrandParent
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//             [LPWSTR szBuffer]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------

HRESULT
BuildGrandParent(POBJECTINFO pObjectInfo, LPWSTR szBuffer)
{
    DWORD i = 0;

    if (!pObjectInfo->ProviderName) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    wsprintf(szBuffer,L"%s:", pObjectInfo->ProviderName);

    if (pObjectInfo->NumComponents - 2) {

        wcscat(szBuffer, L"//");
        wcscat(szBuffer, pObjectInfo->DisplayComponentArray[0]);

        for (i = 1; i < (pObjectInfo->NumComponents - 2); i++) {
            wcscat(szBuffer, L"/");
            wcscat(szBuffer, pObjectInfo->DisplayComponentArray[i]);
        }
    }

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   BuildADsPath
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//             [LPWSTR szBuffer]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------

HRESULT
BuildADsPath(
    POBJECTINFO pObjectInfo,
    LPWSTR szBuffer
    )
{
    DWORD i = 0;

    if (!pObjectInfo->ProviderName) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    wsprintf(szBuffer,L"%s:", pObjectInfo->ProviderName);

    if (pObjectInfo->NumComponents) {


        wcscat(szBuffer, L"//");
        wcscat(szBuffer, pObjectInfo->DisplayComponentArray[0]);

        for (i = 1; i < (pObjectInfo->NumComponents); i++) {
            wcscat(szBuffer, L"/");
            wcscat(szBuffer, pObjectInfo->DisplayComponentArray[i]);
        }
    }
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\encrypt.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    encrypt.h

Abstract:

    Contains API to encrypt password.

Author:

    Yi-Hsin Sung (yihsins)  30-Aug-1994

Revision History:

--*/

#ifndef _ENCRYPT_H_
#define _ENCRYPT_H_

VOID
EncryptChangePassword(
    IN  PUCHAR pOldPassword,
    IN  PUCHAR pNewPassword,
    IN  ULONG  ObjectId,
    IN  PUCHAR pKey,
    OUT PUCHAR pValidationKey,
    OUT PUCHAR pEncryptNewPassword
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\guid.c ===
#define INITGUID

#include <ole2.h>

//--------------------------------------------------------------------------
//
//  NWCOMPAT CLSIDs
//
//--------------------------------------------------------------------------

DEFINE_GUID(CLSID_NWCOMPATProvider,0x0df68130L,0x4b62,0x11CF,0xAE,0x2C,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATNamespace,0x0fb32cc0L,0x4b62,0x11CF,0xAE,0x2C,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATComputer,0xcad1bde0L,0x4cf0,0x11cf,0xae,0x2d,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATUser,0x5c250b00L,0x5863,0x11cf,0xae,0x32,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATGroup,0x3c5662e0L,0x5a74,0x11cf,0xae,0x32,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATDomain,0x9f6616f0L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATService,0x9f02c3c0L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATPrintQueue,0x9e7dd270L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATPrintJob,0x9e09b030L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATFileService,0x9d9eb910L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATSession,0x9d2a96d0L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATResource,0x9cb36630L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATFileShare,0x9c486f10L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATSchema,0x9bcfb740L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATClass,0x9b602a90L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATSyntax,0x9af53370L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATProperty,0x44687d30L,0x7937,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

//------------------------------------------------------------------------
//  GUIDS that come out of NWCOMPAT.tlb.
//------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\fsmacro.h ===
#define PUT_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ); \
                NW_RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                NW_RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ); \
                NW_RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                NW_RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ); \
                NW_RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                NW_RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ); \
                NW_RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                NW_RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ); \
                NW_RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                NW_RRETURN_EXP_IF_ERR(tmphr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\globals.cxx ===
#include "NWCOMPAT.hxx"
#pragma hdrstop

const BSTR bstrAddressTypeString = L"IPX";
const BSTR bstrComputerOperatingSystem = L"NW3Compat";
const BSTR bstrFileShareDescription = L"Disk";
const BSTR bstrNWFileServiceName = L"NetWareFileServer";
const BSTR bstrProviderName = L"NWCOMPAT";

CRITICAL_SECTION  BindCacheCritSect;

#define MAX_LONG    (0x7FFFFFFF)
#define MIN_LONG    (0x80000000)
#define MAX_BOOLEAN 1
#define MAX_STRLEN  256
#define MAX_UCHAR   255
#define MAX_USHORT  65535


PROPERTYINFO ComputerClass[] =
    { { TEXT("OperatingSystem"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, COMP_OPERATINGSYSTEM_ID, NT_SYNTAX_ID_LPTSTR},
      { TEXT("OperatingSystemVersion"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, COMP_OPERATINGSYSTEMVERSION_ID, NT_SYNTAX_ID_LPTSTR}
    };


DWORD gdwComputerTableSize = sizeof(ComputerClass)/sizeof(PROPERTYINFO);


PROPERTYINFO UserClass[] =
    { { TEXT("FullName"),
        TEXT(""), TEXT("String"), NW_DATA_SIZE, 0, FALSE,   //  max 128 bytes
        PROPERTY_RW, USER_FULLNAME_ID, NT_SYNTAX_ID_LPTSTR },
      { TEXT("AccountDisabled"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ACCOUNTDISABLED_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("AccountExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, USER_ACCOUNTEXPIRATIONDATE_ID, NT_SYNTAX_ID_NW312DATE },
      { TEXT("AccountCanExpire"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_CANACCOUNTEXPIRE_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("GraceLoginsAllowed"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_GRACELOGINSALLOWED_ID, NT_SYNTAX_ID_DWORD },
      { TEXT("GraceLoginsRemaining"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_GRACELOGINSREMAINING_ID, NT_SYNTAX_ID_DWORD },
      { TEXT("IsAccountLocked"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ISACCOUNTLOCKED_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("IsAdmin"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ISADMIN_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("MaxLogins"),
        TEXT(""), TEXT("Integer"), MAX_USHORT, 0, FALSE,
        PROPERTY_RW, USER_MAXLOGINS_ID, NT_SYNTAX_ID_DWORD},
      { TEXT("PasswordExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDEXPIRATIONDATE_ID, NT_SYNTAX_ID_NW312DATE},
      { TEXT("PasswordCanExpire"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_CANPASSWORDEXPIRE_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("PasswordMinimumLength"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDMINIMUMLENGTH_ID, NT_SYNTAX_ID_DWORD},
      { TEXT("PasswordRequired"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDREQUIRED_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("RequireUniquePassword"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_REQUIREUNIQUEPASSWORD_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("BadLoginAddress"),    // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, USER_BADLOGINADDRESS_ID, NT_SYNTAX_ID_LPTSTR},
      { TEXT("LastLogin"),          // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, USER_LASTLOGIN_ID, NT_SYNTAX_ID_NW312DATE},
      { TEXT("LoginHours"),          
        TEXT(""), TEXT("OctetString"), 0, 0, FALSE,
        PROPERTY_RW, USER_LOGINHOURS_ID, NT_SYNTAX_ID_OCTETSTRING}
    };

DWORD gdwUserTableSize = sizeof(UserClass)/sizeof(PROPERTYINFO);


PROPERTYINFO GroupClass[] =
    { { TEXT("Description"),            // FSGroupGeneralInfo
        TEXT(""), TEXT("String"), NW_DATA_SIZE, 0, FALSE,   // max 128 bytes
        PROPERTY_RW, GROUP_DESCRIPTION_ID, NT_SYNTAX_ID_LPTSTR }
    };


DWORD gdwGroupTableSize = sizeof(GroupClass)/sizeof(PROPERTYINFO);

PROPERTYINFO FileServiceClass[] =
    { { TEXT("HostComputer"),          // FSServiceConfiguration
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_USHORT, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD }
    };

DWORD gdwFileServiceTableSize = sizeof(FileServiceClass)/sizeof(PROPERTYINFO);

PROPERTYINFO FileShareClass[] =
    { { TEXT("Description"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("HostComputer"),
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_USHORT, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD }
    };

DWORD gdwFileShareTableSize = sizeof(FileShareClass)/sizeof(PROPERTYINFO);

PROPERTYINFO PrintQueueClass[] =
    { { TEXT("PrinterPath"), // FSPrintQueueGeneralInfo
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Model"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Datatype"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintProcessor"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Description"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Location"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("StartTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("UntilTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("DefaultJobPriority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Priority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("BannerPage"),
        TEXT(""), TEXT("Path"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintDevices"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DelimitedString }
    };

DWORD gdwPrinterTableSize = sizeof(PrintQueueClass)/sizeof(PROPERTYINFO);


PROPERTYINFO PrintJobClass[] =
    { { TEXT("HostPrintQueue"),     // ro, FSPrintJobGeneralInfo
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("User"),               // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeSubmitted"),      // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_SYSTEMTIME },
      { TEXT("TotalPages"),         // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_DWORD },
      { TEXT("Size"),               // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("Description"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("Priority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 1,  NT_SYNTAX_ID_DWORD },
      { TEXT("StartTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_DATE },
      { TEXT("UntilTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_DATE },
      { TEXT("Notify"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeElapsed"),        // ro
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("PagesPrinted"),       // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("Position"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_DWORD }
    };


DWORD gdwJobTableSize = sizeof(PrintJobClass)/sizeof(PROPERTYINFO);

CLASSINFO g_aNWCOMPATClasses[] =
{

//
//  Computer Class
//



  { COMPUTER_SCHEMA_NAME, &CLSID_NWCOMPATComputer, &IID_IADsComputer,
    TEXT(""), FALSE,

    NULL,


    TEXT("OperatingSystemVersion"),


    NULL, TEXT("User,Group,FileService,PrintQueue"), TRUE,
    TEXT(""), 0,
    ComputerClass, sizeof(ComputerClass)/sizeof(PROPERTYINFO) },


  { USER_SCHEMA_NAME, &CLSID_NWCOMPATUser, &IID_IADsUser,
    TEXT(""), FALSE,


    NULL,


    TEXT("FullName,AccountDisabled,AccountExpirationDate,")
    TEXT("AccountCanExpire,GraceLoginsAllowed,GraceLoginsRemaining,")
    TEXT("IsAccountLocked,IsAdmin,MaxLogins,PasswordExpirationDate,")
    TEXT("PasswordCanExpire,PasswordMinimumLength,PasswordRequired,")
    TEXT("RequireUniquePassword,BadLoginAddress,LastLogin"),


    TEXT("Computer"), NULL, FALSE,
    TEXT(""), 0,
    UserClass, sizeof(UserClass)/sizeof(PROPERTYINFO) },


  { GROUP_SCHEMA_NAME, &CLSID_NWCOMPATGroup, &IID_IADsGroup,
    TEXT(""), FALSE,


    NULL,


    TEXT("Description"),


    TEXT("Computer"), NULL, FALSE,
    TEXT(""), 0,
    GroupClass, sizeof(GroupClass)/sizeof(PROPERTYINFO) },

  { FILESERVICE_SCHEMA_NAME, &CLSID_NWCOMPATFileService, &IID_IADsFileService,
    TEXT(""), FALSE,


    NULL,


    TEXT("HostComputer,MaxUserCount,"),

    TEXT("Computer"), TEXT("FileShare"), TRUE,
    TEXT(""), 0,
    FileServiceClass, sizeof(FileServiceClass)/sizeof(PROPERTYINFO) },

  { FILESHARE_SCHEMA_NAME,  &CLSID_NWCOMPATFileShare,  &IID_IADsFileShare,
    TEXT(""), FALSE,

    NULL,

    TEXT("Description,HostComputer,MaxUserCount"),

    TEXT("FileService"), NULL, FALSE,
    TEXT(""), 0,
    FileShareClass, sizeof(FileShareClass)/sizeof(PROPERTYINFO) },


  { PRINTER_SCHEMA_NAME, &CLSID_NWCOMPATPrintQueue, &IID_IADsPrintQueue,
    TEXT(""), FALSE,

    NULL,


    TEXT("PrinterPath,Model,Datatype,PrintProcessor,")
    TEXT("Description,Location,StartTime,UntilTime,DefaultJobPriority,")
    TEXT("Priority,BannerPage,PrintDevices"),


    TEXT("Computer"), NULL, FALSE,
    TEXT(""), 0,
    PrintQueueClass, sizeof(PrintQueueClass)/sizeof(PROPERTYINFO) },

  { PRINTJOB_SCHEMA_NAME, &CLSID_NWCOMPATPrintJob, &IID_IADsPrintJob,
    TEXT(""), FALSE,


    NULL,


    TEXT("HostPrintQueue,User,TimeSubmitted,TotalPages,")
    TEXT("Size,Priority,StartTime,UntilTime,Notify,TimeElapsed,")
    TEXT("PagesPrinted,Position"),


    NULL, NULL, FALSE,
    TEXT(""), 0,
    PrintJobClass, sizeof(PrintJobClass)/sizeof(PROPERTYINFO) }

};

SYNTAXINFO g_aNWCOMPATSyntax[] =
{ {  TEXT("Boolean"),       VT_BOOL },
  {  TEXT("Counter"),       VT_I4 },
  {  TEXT("ADsPath"),     VT_BSTR },
  {  TEXT("EmailAddress"),  VT_BSTR },
  {  TEXT("FaxNumber"),     VT_BSTR },
  {  TEXT("Integer"),       VT_I4 },
  {  TEXT("Interval"),      VT_I4 },
  {  TEXT("List"),          VT_VARIANT },  // VT_BSTR | VT_ARRAY
  {  TEXT("NetAddress"),    VT_BSTR },
  {  TEXT("OctetString"),   VT_VARIANT },  // VT_UI1| VT_ARRAY
  {  TEXT("Path"),          VT_BSTR },
  {  TEXT("PhoneNumber"),   VT_BSTR },
  {  TEXT("PostalAddress"), VT_BSTR },
  {  TEXT("SmallInterval"), VT_I4 },
  {  TEXT("String"),        VT_BSTR },
  {  TEXT("Time"),          VT_DATE }
};

DWORD g_cNWCOMPATClasses = (sizeof(g_aNWCOMPATClasses)/sizeof(g_aNWCOMPATClasses[0]));
DWORD g_cNWCOMPATSyntax = (sizeof(g_aNWCOMPATSyntax)/sizeof(g_aNWCOMPATSyntax[0]));

PROPERTYINFO g_aNWCOMPATProperties[] =
    { { TEXT("OperatingSystem"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, COMP_OPERATINGSYSTEM_ID, NT_SYNTAX_ID_LPTSTR},
      { TEXT("OperatingSystemVersion"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, COMP_OPERATINGSYSTEMVERSION_ID, NT_SYNTAX_ID_LPTSTR},

      // User Properties

      { TEXT("FullName"),
        TEXT(""), TEXT("String"), NW_DATA_SIZE, 0, FALSE,   //  max 128 bytes
        PROPERTY_RW, USER_FULLNAME_ID, NT_SYNTAX_ID_LPTSTR },
      { TEXT("AccountDisabled"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ACCOUNTDISABLED_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("AccountExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, USER_ACCOUNTEXPIRATIONDATE_ID, NT_SYNTAX_ID_NW312DATE },
      { TEXT("AccountCanExpire"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_CANACCOUNTEXPIRE_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("GraceLoginsAllowed"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_GRACELOGINSALLOWED_ID, NT_SYNTAX_ID_DWORD },
      { TEXT("GraceLoginsRemaining"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_GRACELOGINSREMAINING_ID, NT_SYNTAX_ID_DWORD },
      { TEXT("IsAccountLocked"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ISACCOUNTLOCKED_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("IsAdmin"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ISADMIN_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("MaxLogins"),
        TEXT(""), TEXT("Integer"), MAX_USHORT, 0, FALSE,
        PROPERTY_RW, USER_MAXLOGINS_ID, NT_SYNTAX_ID_DWORD},
      { TEXT("PasswordExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDEXPIRATIONDATE_ID, NT_SYNTAX_ID_NW312DATE},
      { TEXT("PasswordCanExpire"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_CANPASSWORDEXPIRE_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("PasswordMinimumLength"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDMINIMUMLENGTH_ID, NT_SYNTAX_ID_DWORD},
      { TEXT("PasswordRequired"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDREQUIRED_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("RequireUniquePassword"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_REQUIREUNIQUEPASSWORD_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("BadLoginAddress"),    // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, USER_BADLOGINADDRESS_ID, NT_SYNTAX_ID_LPTSTR},
      { TEXT("LastLogin"),          // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, USER_LASTLOGIN_ID, NT_SYNTAX_ID_NW312DATE},

      // Group Properties

      { TEXT("Description"),            // FSGroupGeneralInfo
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,   // max 128 bytes
        PROPERTY_RW, GROUP_DESCRIPTION_ID, NT_SYNTAX_ID_LPTSTR },

      // FileService Properties

      { TEXT("HostComputer"),          // FSServiceConfiguration
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_USHORT, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD },

      // FileShare Properties

      //
      // Description (Group)
      //
      // HostComputer (FileService)
      //
      // MaxUserCount(FileService)
      //

      // PrintQueue Properties

      //
      // HostComputer (FileService)
      //
      { TEXT("Model"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Datatype"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintProcessor"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      //
      // Description (Group)
      //
      { TEXT("Location"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("StartTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("UntilTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("DefaultJobPriority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Priority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("BannerPage"),
        TEXT(""), TEXT("Path"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintDevices"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DelimitedString },

      // PrintJob Properties

      { TEXT("HostPrintQueue"),     // ro, FSPrintJobGeneralInfo
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("User"),               // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeSubmitted"),      // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_SYSTEMTIME },
      { TEXT("TotalPages"),         // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_DWORD },
      { TEXT("Size"),               // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      //
      //  Description (Group)
      //
      // Priority (PrintQueue)
      //
      //
      // StartTime (PrintQueue)
      //
      // UntilTime(PrintQueue)
      //
      { TEXT("Notify"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeElapsed"),        // ro
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("PagesPrinted"),       // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("Position"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_DWORD }

    };


DWORD g_cNWCOMPATProperties = (sizeof(g_aNWCOMPATProperties)/sizeof(g_aNWCOMPATProperties[0]));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\cusers.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroups.cxx
//
//  Contents:  Group object
//
//  History:   Mar-18-965     t-ptam (PatrickT)    Migrated.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Class CNWCOMPATUserCollection
//

DEFINE_IDispatch_Implementation(CNWCOMPATUserCollection)

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUserCollection::CNWCOMPATUserCollection():
        _ParentType(0),
        _ServerName(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CNWCOMPATUserCollection);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUserCollection::~CNWCOMPATUserCollection( )
{
    if (_ServerName)
        ADsFreeString(_ServerName);
    delete _pDispMgr;
    VariantClear(&_vFilter);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUserCollection::CreateUserCollection(
    BSTR Parent,
    ULONG ParentType,
    BSTR ServerName,
    BSTR UserName,
    CCredentials &Credentials,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATUserCollection FAR * pUser = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserCollectionObject(&pUser);
    BAIL_ON_FAILURE(hr);

    hr = pUser->InitializeCoreObject(
                     Parent,
                     UserName,
                     L"users",
                     NO_SCHEMA,
                     CLSID_NWCOMPATUser,
                     ADS_OBJECT_UNBOUND
                     );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(ServerName, &pUser->_ServerName);
    BAIL_ON_FAILURE(hr);

    pUser->_ParentType = ParentType;
    pUser->_Credentials = Credentials;

    hr = pUser->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUser->Release();
    RRETURN(hr);

error:
    delete pUser;

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

//----------------------------------------------------------------------------
//
//  Function:CNWCOMPATUserCollection::InterfaceSupportsErrorInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::get_Count(
    long FAR* retval
    )
{
    NW_RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::get_Filter(
    THIS_ VARIANT FAR* pVar
    )
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::put_Filter(
    THIS_ VARIANT Var
    )
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNWCOMPATUserCollectionEnum::Create(
             (CNWCOMPATUserCollectionEnum **)&penum,
             _Parent,
             _ParentType,
             _ADsPath,
             _ServerName,
             _Name,
             _Credentials,
             _vFilter
             );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    NW_RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUserCollection::AllocateUserCollectionObject(
    CNWCOMPATUserCollection ** ppUser
    )
{
    CNWCOMPATUserCollection FAR * pUser = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pUser = new CNWCOMPATUserCollection();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsMembers,
             (IADsMembers *)pUser,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    pUser->_pDispMgr = pDispMgr;
    *ppUser = pUser;

    RRETURN(hr);

error:
    if (pUser) {
        delete pUser;
    }

    if (pDispMgr) {
        delete  pDispMgr;
    }

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\grputils.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      grputils.cxx
//
//  Contents:  NetWare compatible GroupCollection Enumeration Code
//
//  History:   22-Mar-96    t-ptam (PatrickT) migrated from KrishnaG for NetWare
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop

COMPUTER_GROUP_MEMBER CompMember;

//
// This assumes that addr is an LPBYTE type.
//

#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((DWORD)addr & ~1))

DWORD ComputerGrpMemberStrings[]=
                             {
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Parent),
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Computer),
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Name),
                             0xFFFFFFFF
                             };

DECLARE_INFOLEVEL(GrpUt)
DECLARE_DEBUG(GrpUt)
#define GrpUtDebugOut(x) GrpUtInlineDebugOut x

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerGroupOpen
//
//  Synopsis: This function opens a handle to a INI_COMP_GROUP structure.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerGroupOpen(
    LPWSTR szComputerName,
    LPWSTR szGroupName,
    CCredentials &Credentials,
    PHANDLE phGroup
    )
{
    WCHAR szTempBuffer[MAX_PATH];
    PINI_COMP_GROUP pIniCompGrp;
    HRESULT hr = S_OK;

    if (!phGroup) {
        return(FALSE);
    }

    pIniCompGrp = (PINI_COMP_GROUP)AllocADsMem(
                                       sizeof(INI_COMP_GROUP)
                                       );
    if (!pIniCompGrp) {
        return(FALSE);
    }

    //
    // Fill structure's fields.
    //

    if (!(pIniCompGrp->szComputerName =  AllocADsStr(szComputerName))){
        goto error;
    }

    if (!(pIniCompGrp->szGroupName = AllocADsStr(szGroupName))){
        goto error;
    }

    hr = NWApiGetBinderyHandle(
             &pIniCompGrp->_hConn,
             szComputerName,
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return
    //

    *phGroup =  (HANDLE)pIniCompGrp;

    return(TRUE);


error:
    if (pIniCompGrp) {
        FreeIniCompGroup(pIniCompGrp);
    }

    *phGroup = NULL;

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerGroupEnum
//
//  Synopsis: This function returns a buffer which contains all the binding
//            informations for the requested number of objects without any
//            references.
//            It returns TRUE iff dwReturned = dwRequested.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerGroupEnum(
    HANDLE hGroup,
    DWORD  dwRequested,
    LPBYTE * ppBuffer,
    PDWORD pdwReturned
    )
{
    LPCOMPUTER_GROUP_MEMBER * ppGroupMembers = NULL;
    DWORD i = 0;
    BOOL dwRet = FALSE;
    DWORD dwReturned = 0;
    DWORD dwSize = 0;
    LPCOMPUTER_GROUP_MEMBER pBuffer = NULL;
    LPBYTE pEnd = NULL;

    //
    // Allocate buffer for the number of requested members.
    //

    ppGroupMembers = (LPCOMPUTER_GROUP_MEMBER *)AllocADsMem(
                                                    sizeof(LPCOMPUTER_GROUP_MEMBER)* dwRequested
                                                    );
    if (!ppGroupMembers) {
        return(FALSE);
    }

    //
    // Fill in ppGroupMembers one by one.
    //

    for (i = 0; i < dwRequested; i++) {

        dwRet = NWCOMPATComputerGroupGetObject(
                    hGroup,
                    &ppGroupMembers[i]
                    );
        if (!dwRet) {
            break;
        }
    }
        
    dwReturned = i;

    if (!dwRet) {
        goto error;
    }
    else {

        //
        // Determine actual size of ppGroupMembers[], ie. since each string in
        // COMPUTER_GROUP_MEMBER have a different length, a buffer that is going
        // to contain all the data without any references is unknown.
        //

        dwRet = ComputeComputerGroupDataSize(
                    ppGroupMembers,
                    dwReturned,
                    &dwSize
                    );

        pBuffer = (LPCOMPUTER_GROUP_MEMBER)AllocADsMem(
                                               dwSize
                                               );
        if (!pBuffer) {
            goto error;
        }

        pEnd = (LPBYTE)((LPBYTE)(pBuffer) + dwSize);

        //
        // Put data into pBuffer, starting from the end.
        //

        for (i = 0; i < dwReturned; i++) {

            pEnd = CopyIniCompGroupToCompGroup(
                       ppGroupMembers[i],
                       (LPBYTE)(pBuffer + i),
                       pEnd
                       );
        }

        //
        // Clean up.
        //

        for (i = 0; i < dwReturned; i++ ) {
            FreeIntCompGroup(*(ppGroupMembers + i));
        }

        //
        // Return values.
        //

        *ppBuffer = (LPBYTE)pBuffer;
        *pdwReturned  = dwReturned;
    }

    FreeADsMem(ppGroupMembers);

    if (dwReturned == dwRequested){
        return(TRUE);
    }else {
        return(FALSE);
    }

error:
    
    for (i = 0; i < dwReturned; i++ ) {
        FreeIntCompGroup(*(ppGroupMembers + i));
    }
    
    FreeADsMem(ppGroupMembers);
    
    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerGroupGetObject
//
//  Synopsis: This function returns binding information of a user (group member)
//            object one by one.  In its first call, it builds a buffer that
//            contains all the UserID of the group members.  Then, and in
//            subsequent calls, this UserID is translated into a user name.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerGroupGetObject(
    HANDLE hGroup,
    LPCOMPUTER_GROUP_MEMBER * ppGroupMember
    )
{
    BOOL            dwRet = FALSE;
    DWORD           dwUserID = 0;
    HRESULT         hr = S_OK;
    PINI_COMP_GROUP pIniCompGrp = (PINI_COMP_GROUP)hGroup;

    //
    // Fill buffer with User ID.  NetWare returns all UserID in one call.
    //

    if (!pIniCompGrp->_pBuffer) {

        pIniCompGrp->_dwCurrentObject = 0;

        hr = NWApiGroupGetMembers(
                 pIniCompGrp->_hConn,
                 pIniCompGrp->szGroupName,
                 &(pIniCompGrp->_pBuffer)
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Build one group member.
    //

    dwUserID = *((LPDWORD)pIniCompGrp->_pBuffer + pIniCompGrp->_dwCurrentObject);

    if (dwUserID != 0x0000) {

        dwRet = BuildComputerGroupMember(
                    hGroup,
                    dwUserID,
                    ppGroupMember
                    );
        if (!dwRet) {
            goto error;
        }

        pIniCompGrp->_dwCurrentObject++;

        return(TRUE);
    }

error:

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerGroupClose
//
//  Synopsis: Wrapper of FreeIniCompGroup.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerGroupClose(
    HANDLE hGroup
    )
{
    PINI_COMP_GROUP pIniCompGrp = (PINI_COMP_GROUP)hGroup;

    if (pIniCompGrp) {
        FreeIniCompGroup(pIniCompGrp);
    }
    return(TRUE);
}

//----------------------------------------------------------------------------
//
//  Function: FreeIniCompGroup
//
//  Synopsis: Free an INI_COMP_GROUP structure.
//
//----------------------------------------------------------------------------
void
FreeIniCompGroup(
    PINI_COMP_GROUP pIniCompGrp
    )
{
    HRESULT hr = S_OK;

    if (pIniCompGrp) {

        if (pIniCompGrp->szComputerName) {
            FreeADsStr(pIniCompGrp->szComputerName);
        }

        if (pIniCompGrp->szGroupName) {
            FreeADsStr(pIniCompGrp->szGroupName);
        }

        if (pIniCompGrp->_pBuffer) {
            FreeADsMem(pIniCompGrp->_pBuffer);
        }

        if (pIniCompGrp->_hConn) {
            hr = NWApiReleaseBinderyHandle(pIniCompGrp->_hConn);
        }

        FreeADsMem(pIniCompGrp);
    }

    return;
}

//----------------------------------------------------------------------------
//
//  Function: FreeIntCompGroup
//
//  Synopsis: Free a COMPUTER_GROUP_MEMBER structure.
//
//----------------------------------------------------------------------------
void
FreeIntCompGroup(
    LPCOMPUTER_GROUP_MEMBER pCompGroupMember
    )
{
    if (pCompGroupMember) {

        if (pCompGroupMember->Parent) {
            FreeADsStr(pCompGroupMember->Parent);
        }

        if (pCompGroupMember->Computer) {
            FreeADsStr(pCompGroupMember->Computer);
        }

        if (pCompGroupMember->Name) {
            FreeADsStr(pCompGroupMember->Name);
        }

        FreeADsMem(pCompGroupMember);
    }

    return;
}

//----------------------------------------------------------------------------
//
//  Function: ComputeComputerGroupDataSize
//
//  Synopsis: Calculate the size of a buffer that is going to store the data in
//            ppGroupMembers without any references.
//
//----------------------------------------------------------------------------
BOOL
ComputeComputerGroupDataSize(
        LPCOMPUTER_GROUP_MEMBER * ppGroupMembers,
        DWORD  dwReturned,
        PDWORD pdwSize
        )
{

    DWORD i = 0;
    DWORD cb = 0;
    LPCOMPUTER_GROUP_MEMBER pMember = NULL;

    for (i = 0; i < dwReturned; i++) {

        pMember = *(ppGroupMembers + i);

        cb += sizeof(COMPUTER_GROUP_MEMBER);

        if (pMember->Parent) {
            cb += wcslen(pMember->Parent)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Computer) {
            cb += wcslen(pMember->Computer)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Name) {
            cb += wcslen(pMember->Name)*sizeof(WCHAR) + sizeof(WCHAR);
        }
    }

    *pdwSize = cb;
    return(TRUE);
}

//------------------------------------------------------------------------------
//
//  Function: CopyIniCompGroupToCompGroup
//
//  Synopsis: Pack referenced data (string) into a buffer without any reference.
//
//------------------------------------------------------------------------------
LPBYTE
CopyIniCompGroupToCompGroup(
    LPCOMPUTER_GROUP_MEMBER  pIntCompGrp,
    LPBYTE  pExtCompGrp,
    LPBYTE  pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(COMPUTER_GROUP_MEMBER)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings =  SourceStrings;
    LPCOMPUTER_GROUP_MEMBER pCompGrpMember = (LPCOMPUTER_GROUP_MEMBER)pExtCompGrp;

    memset(SourceStrings, 0, sizeof(COMPUTER_GROUP_MEMBER));
    *pSourceStrings++ = pIntCompGrp->Parent;
    *pSourceStrings++ = pIntCompGrp->Computer;
    *pSourceStrings++ = pIntCompGrp->Name;

    pEnd = PackStrings(
                SourceStrings,
                pExtCompGrp,
                ComputerGrpMemberStrings,
                pEnd
                );

    pCompGrpMember->Type = pIntCompGrp->Type;

    return pEnd;
}

//----------------------------------------------------------------------------
//
//  Function: BuildComputerGroupMember
//
//  Synopsis: Put binding information of a group member into ppGroupMember.
//
//----------------------------------------------------------------------------
BOOL
BuildComputerGroupMember(
    HANDLE hGroup,
    DWORD  dwUserID,
    LPCOMPUTER_GROUP_MEMBER * ppGroupMember
    )
{
    DWORD                   dwTempUserID = dwUserID;
    HRESULT                 hr = S_OK;
    LPCOMPUTER_GROUP_MEMBER pGroupMember = NULL;
    LPINI_COMP_GROUP        pGroup = (LPINI_COMP_GROUP)hGroup;
    WCHAR                   szADsParent[MAX_PATH];

    //
    // Allocate one COMPUTER_GROUP_MEMBER.
    //

    pGroupMember = (LPCOMPUTER_GROUP_MEMBER)AllocADsMem(
                                                sizeof(COMPUTER_GROUP_MEMBER)
                                                );
    if (!pGroupMember) {
        return(FALSE);
    }

    //
    // Fill structure's fields.
    //

    pGroupMember->Parent = NULL;
    pGroupMember->Computer = NULL;

    pGroupMember->Type = NWCOMPAT_USER_ID;

    wsprintf(
        szADsParent,
        L"%s://%s",
        szProviderName,
        pGroup->szComputerName
        );
    pGroupMember->Parent = AllocADsStr(szADsParent);
    if (!pGroupMember->Parent) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pGroupMember->Computer = AllocADsStr(pGroup->szComputerName);
    if (!pGroupMember->Computer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = NWApiGetObjectName(
             pGroup->_hConn,
             dwTempUserID,
             &pGroupMember->Name
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    *ppGroupMember = pGroupMember;
    return(TRUE);

error:
    if (pGroupMember) {

        if (pGroupMember->Parent)
            FreeADsStr(pGroupMember->Parent);

        if (pGroupMember->Computer)
            FreeADsStr(pGroupMember->Computer);

        FreeADsMem(pGroupMember);
    }

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: PackStrings
//
//  Synopsis:
//
//----------------------------------------------------------------------------
LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD *DestOffsets,
    LPBYTE pEnd
    )
{
    DWORD cbStr;
    WORD_ALIGN_DOWN(pEnd);

    while (*DestOffsets != -1) {
        if (*pSource) {
            cbStr = wcslen(*pSource)*sizeof(WCHAR) + sizeof(WCHAR);
            pEnd -= cbStr;
            CopyMemory( pEnd, *pSource, cbStr);
            *(LPWSTR *)(pDest+*DestOffsets) = (LPWSTR)pEnd;
        } else {
            *(LPWSTR *)(pDest+*DestOffsets)=0;
        }
        pSource++;
        DestOffsets++;
    }
    return pEnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guid.h
//
//  Contents:   extern references for NWCOMPAT guids
//
//  History:    10-Jan-06  t-ptam
//
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// NWCOMPATOle CLSIDs
//
//-------------------------------------------

// uuids from NWCOMPAT.tlb

extern const CLSID CLSID_NWCOMPATProvider;

extern const CLSID CLSID_NWCOMPATNamespace;

extern const CLSID CLSID_NWCOMPATComputer;

extern const CLSID CLSID_NWCOMPATUser;

extern const CLSID CLSID_NWCOMPATGroup;

extern const CLSID CLSID_NWCOMPATProvider;

extern const CLSID CLSID_NWCOMPATNamespace;

extern const CLSID CLSID_NWCOMPATComputer;

extern const CLSID CLSID_NWCOMPATUser;

extern const CLSID CLSID_NWCOMPATGroup;

extern const CLSID CLSID_NWCOMPATDomain;

extern const CLSID CLSID_NWCOMPATService;

extern const CLSID CLSID_NWCOMPATPrintQueue;

extern const CLSID CLSID_NWCOMPATPrintJob;

extern const CLSID CLSID_NWCOMPATFileService;

extern const CLSID CLSID_NWCOMPATSession;

extern const CLSID CLSID_NWCOMPATResource;

extern const CLSID CLSID_NWCOMPATFileShare;

extern const CLSID CLSID_NWCOMPATSchema;

extern const CLSID CLSID_NWCOMPATClass;

extern const CLSID CLSID_NWCOMPATSyntax;

extern const CLSID CLSID_NWCOMPATProperty;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\nw2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nw2var.cxx
//
//  Contents:   Nw312 Object to Variant Copy Routines
//
//  Functions:
//
//  History:      06/12/96   KrishnaG created.
//                cloned off NDS conversion code.
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------

//
// NTType objects copy code
//

#include "nwcompat.hxx"
#pragma  hdrstop

void
VarTypeFreeVarObjects(
    PVARIANT pVarObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    if( !pVarObject){
        return;
    }

    for (i = 0; i < dwNumValues; i++ ) {
         VariantClear(pVarObject + i);
    }

    FreeADsMem(pVarObject);

    return;
}


HRESULT
NTTypeToVarTypeCopyBOOL(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_BOOL;

    if((pNTSrcValue->NTValue).fValue){
        lpVarDestObject->boolVal = VARIANT_TRUE;  // notation for TRUE in V_BOOL
    } else {
        lpVarDestObject->boolVal = VARIANT_FALSE;
    }

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopySYSTEMTIME(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

 lpVarDestObject->vt = VT_DATE;

    hr = ConvertSystemTimeToDATE (pNTSrcValue->NTValue.stSystemTimeValue,
                                  &lpVarDestObject->date );


    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyDWORD(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    //
    // we cast the DWORD  to a LONG
    //

    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_I4;

    lpVarDestObject->lVal = (LONG)(pNTSrcValue->NTValue).dwValue;

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyDATE(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{

    HRESULT hr = S_OK;
    SYSTEMTIME stSystemTime;
    SYSTEMTIME LocalTime;
    DATE       date ;
    BOOL       fRetval;

    GetSystemTime( &stSystemTime);

    fRetval = SystemTimeToTzSpecificLocalTime(
                  NULL,
                  &stSystemTime,
                  &LocalTime
                  );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    stSystemTime.wHour = (WORD)(pNTSrcValue->NTValue.dwValue)/60;
    stSystemTime.wMinute = (WORD)(pNTSrcValue->NTValue.dwValue)%60;
    stSystemTime.wSecond =0;
    stSystemTime.wMilliseconds = 0;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_DATE;

    hr = ConvertSystemTimeToDATE (stSystemTime,
                                  &date );

    lpVarDestObject->date = date - (DWORD)date;


    BAIL_ON_FAILURE(hr);


error:

    RRETURN(hr);
}


HRESULT
NTTypeToVarTypeCopyNW312DATE(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{

    HRESULT hr = S_OK;
    SYSTEMTIME stSystemTime;
    SYSTEMTIME LocalTime;
    DATE       date ;
    BOOL       fRetval;


    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_DATE;


    hr = ConvertNW312DateToVariant(
              pNTSrcValue->NTValue.Nw312Date,
              &lpVarDestObject->date
              );
    BAIL_ON_FAILURE(hr);


error:

    RRETURN(hr);
}


HRESULT
NTTypeToVarTypeCopyOctetString(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

	hr = BinaryToVariant(
		(pNTSrcValue->NTValue).octetstring.dwSize,
		(pNTSrcValue->NTValue).octetstring.pByte,
		lpVarDestObject
    );

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyLPTSTR(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_BSTR;

    if(!(pNTSrcValue->NTValue).pszValue){
        lpVarDestObject->bstrVal = NULL;
        hr = S_OK;
        goto error;
    }


    if(!pNTSrcValue){
        lpVarDestObject->bstrVal = NULL;
    } else {
        hr =  ADsAllocString((pNTSrcValue->NTValue).pszValue,
                               &(lpVarDestObject->bstrVal));
    }

error:
    RRETURN(hr);
}



HRESULT
NTTypeToVarTypeCopyDelimitedString(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
   HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    } else {
        hr = DelimitedStringToVariant((pNTSrcValue->NTValue).pszValue,
                                      lpVarDestObject,
                                      TEXT(',') );
    }
    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyNulledString(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!(pNTSrcValue->NTValue).pszValue){
        RRETURN(E_POINTER);
    }

    hr = NulledStringToVariant((pNTSrcValue->NTValue).pszValue,
                               lpVarDestObject );

    RRETURN(hr);
}


HRESULT
NtTypeToVarTypeCopy(
    PNTOBJECT lpNtSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNtSrcObject->NTType) {
    case NT_SYNTAX_ID_BOOL:
        hr = NTTypeToVarTypeCopyBOOL(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = NTTypeToVarTypeCopySYSTEMTIME(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;


    case NT_SYNTAX_ID_DWORD:
        hr = NTTypeToVarTypeCopyDWORD(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = NTTypeToVarTypeCopyDATE(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;


    case NT_SYNTAX_ID_NW312DATE:
        hr = NTTypeToVarTypeCopyNW312DATE(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;


    case NT_SYNTAX_ID_LPTSTR:
        hr = NTTypeToVarTypeCopyLPTSTR(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_DelimitedString:

        hr = NTTypeToVarTypeCopyDelimitedString(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_NulledString :
        hr = NTTypeToVarTypeCopyNulledString(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_OCTETSTRING :
        hr = NTTypeToVarTypeCopyOctetString(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
NtTypeToVarTypeCopyConstruct(
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumObjects,
    PVARIANT pVarDestObjects
    )
{

    long i = 0;
    HRESULT hr = S_OK;

    VariantInit(pVarDestObjects);

    //
    // The following are for handling are multi-value properties
    //

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = dwNumObjects;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) dwNumObjects; i++ )
    {
        VARIANT v;

        VariantInit(&v);
        hr = NtTypeToVarTypeCopy( pNtSrcObjects + i,
                                  &v );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarDestObjects) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\macro.h ===
//
// This is a macro which is ONLY used in CNWCOMPATUser::SetAccountRestrictions.
//

#define GET_LOGIN_CONTROL()             \
        if (fUmOK == FALSE) {           \
                                        \
            hr = NWApiGetLOGIN_CONTROL( \
                     hConn,             \
                     _Name,             \
                     &LoginCtrl         \
                     );                 \
            BAIL_ON_FAILURE(hr);        \
                                        \
            fUmOK = TRUE;               \
        }

//
// NCP Reply buffer macro.
//

#define INIT_RPLY_SGMT(RS)          \
        RS## = new RPLY_SGMT_LST;   \
        if (!##RS##) {              \
            RRETURN(E_OUTOFMEMORY); \
        }                           \
        RS##->lpNext = NULL;

#define DELETE_LIST(ptr)                    \
        if (##ptr##) {                      \
            do {                            \
                lpTemp = (##ptr##)->lpNext; \
                delete (##ptr##);           \
                (##ptr##) = lpTemp;         \
            } while (##ptr##);              \
        }

//
// Misc Macro.
//

#define ADSFREESTRING(str)          \
        if (##str##) {                \
            ADsFreeString(##str##); \
        }

//
// Error flow control macro.
//

#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);

#define BAIL_IF_ERROR(hr)     \
        if (FAILED(hr)) {     \
                goto cleanup; \
        }                     \

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {   \
                goto error; \
        }                   \

//
// DEFINE_IDispatch_Implementation_Unimplemented
//

#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                               \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)           \
{                                                          \
    RRETURN(E_NOTIMPL);                                    \
}                                                          \
                                                           \
STDMETHODIMP                                               \
cls::GetTypeInfo(                                          \
         unsigned int itinfo,                              \
         LCID lcid,                                        \
         ITypeInfo FAR* FAR* pptinfo                       \
         )                                                 \
{                                                          \
    RRETURN(E_NOTIMPL);                                    \
}                                                          \
                                                           \
STDMETHODIMP                                               \
cls::GetIDsOfNames(                                        \
         REFIID iid,                                       \
         LPWSTR FAR* rgszNames,                            \
         unsigned int cNames,                              \
         LCID lcid,                                        \
         DISPID FAR* rgdispid                              \
         )                                                 \
{                                                          \
    RRETURN(E_NOTIMPL);                                    \
}                                                          \
                                                           \
STDMETHODIMP                                               \
cls::Invoke(                                               \
         DISPID dispidMember,                              \
         REFIID iid, LCID lcid,                            \
         unsigned short wFlags,                            \
         DISPPARAMS FAR* pdispparams,                      \
         VARIANT FAR* pvarResult,                          \
         EXCEPINFO FAR* pexcepinfo,                        \
         unsigned int FAR* puArgErr                        \
         )                                                 \
{                                                          \
    RRETURN(E_NOTIMPL);                                    \
}

//
// DEFINE_IDispatch_Implementation
//

#define DEFINE_IDispatch_Implementation(cls)       \
STDMETHODIMP                                       \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)   \
{                                                  \
    RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo)); \
}                                                  \
                                                   \
STDMETHODIMP                                       \
cls::GetTypeInfo(                                  \
         unsigned int itinfo,                      \
         LCID lcid,                                \
         ITypeInfo FAR* FAR* pptinfo)              \
{                                                  \
    RRETURN(_pDispMgr->GetTypeInfo(                \
                           itinfo,                 \
                           lcid,                   \
                           pptinfo                 \
                           ));                     \
}                                                  \
                                                   \
STDMETHODIMP                                       \
cls::GetIDsOfNames(                                \
         REFIID iid,                               \
         LPWSTR FAR* rgszNames,                    \
         unsigned int cNames,                      \
         LCID lcid,                                \
         DISPID FAR* rgdispid                      \
         )                                         \
{                                                  \
    RRETURN(_pDispMgr->GetIDsOfNames(              \
                           iid,                    \
                           rgszNames,              \
                           cNames,                 \
                           lcid,                   \
                           rgdispid                \
                           ));                     \
}                                                  \
                                                   \
STDMETHODIMP                                       \
cls::Invoke(                                       \
         DISPID dispidMember,                      \
         REFIID iid,                               \
         LCID lcid,                                \
         unsigned short wFlags,                    \
         DISPPARAMS FAR* pdispparams,              \
         VARIANT FAR* pvarResult,                  \
         EXCEPINFO FAR* pexcepinfo,                \
         unsigned int FAR* puArgErr                \
         )                                         \
{                                                  \
    RRETURN (_pDispMgr->Invoke(                    \
                            dispidMember,          \
                            iid,                   \
                            lcid,                  \
                            wFlags,                \
                            pdispparams,           \
                            pvarResult,            \
                            pexcepinfo,            \
                            puArgErr               \
                            ));                    \
}                                                  \

//
// DEFINE_IADs_Implementation
//

#define DEFINE_IADs_Implementation(cls)  \
STDMETHODIMP                               \
cls::get_Name(THIS_ BSTR FAR* retval)      \
{                                          \
    RRETURN(get_CoreName(retval));         \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_ADsPath(THIS_ BSTR FAR* retval) \
{                                          \
    RRETURN(get_CoreADsPath(retval));    \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Class(THIS_ BSTR FAR* retval)     \
{                                          \
    RRETURN(get_CoreADsClass(retval));   \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Parent(THIS_ BSTR FAR* retval)    \
{                                          \
    RRETURN(get_CoreParent(retval));       \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Schema(THIS_ BSTR FAR* retval)    \
{                                          \
    RRETURN(get_CoreSchema(retval));       \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_GUID(THIS_ BSTR FAR* retval)      \
{                                          \
    RRETURN(get_CoreGUID(retval));         \
}                                          \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(GetInfo());                                               \
}

//
// DEFINE_IADs_Implementation
//

#define DEFINE_IADs_TempImplementation(cls)  \
STDMETHODIMP                               \
cls::get_Name(THIS_ BSTR FAR* retval)      \
{                                          \
    RRETURN(get_CoreName(retval));         \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_ADsPath(THIS_ BSTR FAR* retval) \
{                                          \
    RRETURN(get_CoreADsPath(retval));    \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Class(THIS_ BSTR FAR* retval)     \
{                                          \
    RRETURN(get_CoreADsClass(retval));   \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Parent(THIS_ BSTR FAR* retval)    \
{                                          \
    RRETURN(get_CoreParent(retval));       \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Schema(THIS_ BSTR FAR* retval)    \
{                                          \
    RRETURN(get_CoreSchema(retval));       \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_GUID(THIS_ BSTR FAR* retval)      \
{                                          \
    RRETURN(get_CoreGUID(retval));         \
}                                          \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(GetInfo());                                               \
}










#define DEFINE_IADs_PutGetImplementation(cls, SchemaClassTable, dwTableSize)                   \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericGetPropertyManager(                                   \
                _pPropertyCache,                                      \
                bstrName,                                             \
                pvProp                                                \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericPutPropertyManager(                                   \
                _pPropertyCache,                                      \
                SchemaClassTable,                                     \
                dwTableSize,                                          \
                bstrName,                                             \
                vProp                                                 \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericGetExPropertyManager(                                 \
                GetObjectState(),                                     \
                _pPropertyCache,                                      \
                bstrName,                                             \
                pvProp                                                \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericPutExPropertyManager(                                 \
                _pPropertyCache,                                      \
                SchemaClassTable,                                     \
                dwTableSize,                                          \
                bstrName,                                             \
                vProp                                                 \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}


#define DEFINE_IADsPropertyList_Implementation(cls, SchemaClassTable, dwTableSize)                 \
STDMETHODIMP                                                                                       \
cls::get_PropertyCount(THIS_ long  FAR * plCount)                                                  \
{                                                                                                  \
    HRESULT hr = E_FAIL;                                                                           \
                                                                                                   \
    hr = GenericPropCountPropertyManager(                                                          \
                _pPropertyCache,                                                                   \
                plCount                                                                            \
                );                                                                                 \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::Next(THIS_ VARIANT FAR *pVariant)                                                             \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericNextPropertyManager(                                                               \
                    _pPropertyCache,                                                               \
                    pVariant                                                                       \
                    );                                                                             \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::Skip(THIS_ long cElements)                                                                   \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
                                                                                                   \
    hr = GenericSkipPropertyManager(                                                               \
                    _pPropertyCache,                                                               \
                    cElements                                                                      \
                    );                                                                             \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
                                                                                                   \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::Reset()                                                                                       \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericResetPropertyManager(                                                              \
                _pPropertyCache                                                                    \
                );                                                                                 \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::ResetPropertyItem(THIS_ VARIANT varEntry)                                                    \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericDeletePropertyManager(                                                             \
                    _pPropertyCache,                                                               \
                    varEntry                                                                       \
                    );                                                                             \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::GetPropertyItem(THIS_ BSTR bstrName, LONG lnADsType, VARIANT * pVariant)                      \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericGetPropItemPropertyManager(                                                        \
                _pPropertyCache,                                                                   \
                GetObjectState(),                                                                  \
                bstrName,                                                                          \
                lnADsType,                                                                         \
                pVariant                                                                           \
                );                                                                                 \
                                                                                                   \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
STDMETHODIMP                                                                                       \
cls::PutPropertyItem(THIS_ VARIANT varData)                                                        \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericPutPropItemPropertyManager(                                                        \
                _pPropertyCache,                                                                   \
                SchemaClassTable,                                                                  \
                dwTableSize,                                                                       \
                varData                                                                            \
                );                                                                                 \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::PurgePropertyList(THIS_)                                                                      \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericPurgePropertyManager(                                                              \
                _pPropertyCache                                                                    \
                );                                                                                 \
                                                                                                   \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
STDMETHODIMP                                                                                       \
cls::Item(THIS_ VARIANT varIndex, VARIANT * pVariant)                                              \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericItemPropertyManager(                                                               \
                _pPropertyCache,                                                                   \
                GetObjectState(),                                                                  \
                varIndex,                                                                          \
                pVariant                                                                           \
                );                                                                                 \
                                                                                                   \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \


#define CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr)                    \
    if (dwStatus) {                                                   \
        hr = CheckAndSetExtendedError(dwStatus);                      \
        BAIL_ON_FAILURE(hr);                                          \
    }

                                                                                                   \
#define NW_DECLARE_ISupportErrorInfo_METHODS \
        STDMETHOD(InterfaceSupportsErrorInfo)(THIS_ REFIID riid);


#define NW_RRETURN_EXP_IF_ERR(hr)    \
      RRETURN(hr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\nw312_2.h ===
#define NWCOMPAT_LIBIID_NWCOMPATOle        09d69aa0-4b62-11cf-ae2c-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATProvider    0df68130-4b62-11cf-ae2c-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATNamespace   0fb32cc0-4b62-11cf-ae2c-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATComputer    cad1bde0-4cf0-11cf-ae2d-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATUser        5c250b00-5863-11cf-ae32-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATGroup       3c5662e0-5a74-11cf-ae32-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATDomain             9f6616f0-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATService            9f02c3c0-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATPrintQueue         9e7dd270-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATPrintJob           9e09b030-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATFileService        9d9eb910-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATSession            9d2a96d0-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATResource           9cb36630-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATFileShare          9c486f10-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATSchema             9bcfb740-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATClass              9b602a90-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATSyntax             9af53370-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATProperty           44687d30-7937-11cf-ae3b-00aa006ebfb9
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\nw2ods.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nw2ods.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma  hdrstop



HRESULT
NTTypeToAdsTypeCopyString(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )

{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNtSrcObject->NTValue.pszValue
                                );
    RRETURN(hr);
}



HRESULT
NTTypeToAdsTypeCopyBoolean(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    lpAdsDestValue->Boolean =
                        lpNtSrcObject->NTValue.fValue;

    RRETURN(hr);
}


HRESULT
NTTypeToAdsTypeCopyInteger(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                        lpNtSrcObject->NTValue.dwValue;

    RRETURN(hr);

}

HRESULT
NTTypeToAdsTypeCopyOctetString(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwLength = 0;
    LPBYTE lpByte = NULL;

    // sanity check the pointers
    if(!lpAdsDestValue){
        RRETURN(E_POINTER);
    }

    if(!lpNtSrcObject){
        RRETURN(E_POINTER);
    }

    lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    dwLength = lpNtSrcObject->NTValue.octetstring.dwSize;

    if (dwLength) {

        lpByte = (LPBYTE)AllocADsMem(dwLength);
        if (!lpByte) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        if (lpNtSrcObject->NTValue.octetstring.pByte) {
            memcpy(lpByte, lpNtSrcObject->NTValue.octetstring.pByte, dwLength);
        }

        lpAdsDestValue->OctetString.dwLength = dwLength;
        lpAdsDestValue->OctetString.lpValue = lpByte;

    }
    else
    {
        lpAdsDestValue->OctetString.dwLength = 0;
        lpAdsDestValue->OctetString.lpValue = NULL;
    }

error:
    RRETURN(hr);
}


HRESULT
NTTypeToAdsTypeCopyNW312Date(
    PNTOBJECT     pNTSrcValue,
    PADSVALUE lpAdsDestValue
    )
{

    HRESULT hr = S_OK;

    // sanity check the pointers
    if(!lpAdsDestValue){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpAdsDestValue->dwType = ADSTYPE_UTC_TIME;


    hr = ConvertNW312DateToSYSTEMTIME(
              pNTSrcValue->NTValue.Nw312Date,
              static_cast<SYSTEMTIME*>(&lpAdsDestValue->UTCTime)
              );
    BAIL_ON_FAILURE(hr);


error:

    RRETURN(hr);
}

HRESULT
NTTypeToAdsTypeCopyDATE(
    PNTOBJECT     pNTSrcValue,
    PADSVALUE lpAdsDestValue
    )
{

    HRESULT hr = S_OK;
    SYSTEMTIME stSystemTime;

    // sanity check the pointers
    if(!lpAdsDestValue){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    GetSystemTime( &stSystemTime);

    // The date is a DWORD containing the number of minutes elapsed
    // since 12:00 AM GMT.  We get the current system time for the
    // current date.  Current date + DWORD time = the date relative
    // to today.
    stSystemTime.wHour = (WORD)(pNTSrcValue->NTValue.dwValue)/60;
    stSystemTime.wMinute = (WORD)(pNTSrcValue->NTValue.dwValue)%60;
    stSystemTime.wSecond =0;
    stSystemTime.wMilliseconds = 0;

    lpAdsDestValue->dwType = ADSTYPE_UTC_TIME;
    lpAdsDestValue->UTCTime = static_cast<ADS_UTC_TIME>(stSystemTime);

    RRETURN(hr);
}

#if 0
// We never seem to actually get a NT_SYNTAX_ID_SYSTEMTIME.
// This code is untested as a result.

HRESULT
NTTypeToAdsTypeCopySYSTEMTIME(
    PNTOBJECT     pNTSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpAdsDestValue){
        RRETURN(E_POINTER);
    }

    lpAdsDestValue->dwType = ADSTYPE_UTC_TIME;
    lpAdsDestValue->UTCTime = static_cast<ADS_UTC_TIME>
        (pNTSrcValue->NTValue.stSystemTimeValue);

    RRETURN(hr);
}
#endif

HRESULT
NTTypeToAdsTypeCopy(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    switch (lpNtSrcObject->NTType) {

    case NT_SYNTAX_ID_BOOL:
        hr = NTTypeToAdsTypeCopyBoolean(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_DWORD:
        hr = NTTypeToAdsTypeCopyInteger(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = NTTypeToAdsTypeCopyString(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;
    /*
    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = NTTypeToAdsTypeCopySYSTEMTIME(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = NTTypeToAdsTypeCopyNDSSynId5(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_DelimitedString:
        hr = NTTypeToAdsTypeCopyNDSSynId6(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;
    */

    case NT_SYNTAX_ID_DATE:
        hr = NTTypeToAdsTypeCopyDATE(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;


    case NT_SYNTAX_ID_NW312DATE:
        hr = NTTypeToAdsTypeCopyNW312Date(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = NTTypeToAdsTypeCopyOctetString(

                lpNtSrcObject,
                lpAdsDestValue
                );
        break;


    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
NTTypeToAdsTypeCopyConstruct(
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumObjects,
    LPADSVALUE * ppAdsDestValues
    )
{

    DWORD i = 0;
    LPADSVALUE pAdsDestValues = NULL;
    HRESULT hr = S_OK;

    if (!dwNumObjects) {
        *ppAdsDestValues =0;
        RRETURN(S_OK);
    }

    pAdsDestValues = (LPADSVALUE)AllocADsMem(
                                    dwNumObjects * sizeof(ADSVALUE)
                                    );

    if (!pAdsDestValues) {
        RRETURN(E_OUTOFMEMORY);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = NTTypeToAdsTypeCopy(
                    pNtSrcObjects + i,
                    pAdsDestValues + i
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppAdsDestValues = pAdsDestValues;

     RRETURN(S_OK);

error:

     if (pAdsDestValues) {
        AdsFreeAdsValues(
            pAdsDestValues,
            dwNumObjects
            );
       FreeADsMem(pAdsDestValues); 
     }

     *ppAdsDestValues = NULL;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\nwcmacro.h ===
// #include "nwapi32.h"

//
// Return Code macro
//
#define NWCCODE_FAILED(Status) ((NWCCODE)(Status) != SUCCESSFUL)

#define NWCCODE_SUCCESS(Status) ((NWCCODE)(Status) == SUCCESSFUL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for oleds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//              09-Jan-96   PatrickT   Migrated to the Netware 3.12 Provider.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


HINSTANCE          g_hInst = NULL;
WCHAR             *szNWCOMPATPrefix = L"@NWCOMPAT!";


//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     AllocArenaDump( NULL );
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;
extern CRITICAL_SECTION g_DispTypeInfoCritSect;

//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    WCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(L"NWCOMPAT",L"heapInfoLevel", L"00000003", awcs,MAXINFOLEN))
        heapInfoLevel = wcstoul(awcs, NULL, 16);

    if (GetProfileString(L"NWCOMPAT",L"Ot", L"00000003", awcs, MAXINFOLEN))
        OtInfoLevel = wcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(L"NWCOMPAT",L"ADsInfoLevel", L"00000003", awcs,MAXINFOLEN))
        ADsInfoLevel = wcstoul(awcs, NULL, 16);
#endif
}

//  Globals


ULONG  g_ulObjCount = 0;  // Number of objects alive in oleds.dll


//+------------------------------------------------------------------------
//
//  Macro that calculates the number of elements in a statically-defined
//  array.
//
//  Note - I swiped this from ADsary.cxx - A type-safe array class. Remember
//  to swipe the whole thing as required.
//-------------------------------------------------------------------------
#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))

CNWCOMPATProviderCF g_cfProvider;
CNWCOMPATNamespaceCF g_cfNamespace;


//+------------------------------------------------------------------------
//
//  oleds class factories
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};



CLSCACHE g_aclscache[] =
{
    &CLSID_NWCOMPATProvider,                        &g_cfProvider,
    &CLSID_NWCOMPATNamespace,                       &g_cfNamespace
};


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    //
    // Add Debugging Code to indicate that the oleds.DllGetClassObject has been
    // called with an unknown CLSID.
    //

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    //
    // BugBug - Fix this Pronto!!
    //
    /*
    if (GET_OBJECT_COUNT() > 0)
        hr = S_FALSE;
    else
        hr = S_OK;
    */
    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Catch init crit sect failing.
        //
        __try {

            DisableThreadLibraryCalls(hInst);

            g_hInst = hInst;

#if DBG==1
#ifndef MSVC
            InitializeCriticalSection(&g_csOT);
            InitializeCriticalSection(&g_csMem);
#endif
            InitializeCriticalSection(&g_csDP);
#endif

            InitializeCriticalSection(&g_DispTypeInfoCritSect);

            BindCacheInit();

            InitializeNWLibrary();

        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Critical Failure
            //
            return FALSE;
        }
        break;


    case DLL_PROCESS_DETACH:

        FreeTypeInfoTable();
        DeleteCriticalSection(&g_DispTypeInfoCritSect);

        BindCacheCleanup();

        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}


//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsidIndex
//
//  Synopsis:   Returns the index of the given CLSID in the cache, or
//              -1 if the CLSID is not present in the cache
//
//  Arguments:  [clsid]
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
GetCachedClsidIndex(REFCLSID clsid)
{
    int             i;
    CLSCACHE *      pclscache;

    for (i = 0, pclscache = g_aclscache;
         i < ARRAY_SIZE(g_aclscache);
         i ++, pclscache++)
    {
        if (IsEqualCLSID(*pclscache->pclsid, clsid))
            return i;
    }

    return -1;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClassFactory
//
//  Synopsis:   Returns the cached class factory with the given index.
//              The pointer returned has been AddRef'd.
//
//  Arguments:  [iclsid]
//
//  Returns:    IClassFactory *
//
//-------------------------------------------------------------------------

IClassFactory *
GetCachedClassFactory(int iclsid)
{
    IClassFactory * pCF;

    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    pCF = g_aclscache[iclsid].pCF;
    pCF->AddRef();

    return pCF;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsid
//
//  Synopsis:   Returns the CLSID corresponding to the given index.
//              Normally, code should call GetCachedClassFactory to get
//              the class factory directly.
//
//  Arguments:  [iclsid]    --  Clsid index
//              [pclsid]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

void
GetCachedClsid(int iclsid, CLSID * pclsid)
{
    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    *pclsid = *g_aclscache[iclsid].pclsid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\nwcache.cxx ===
#include "nwcompat.hxx"
#pragma hdrstop

NWC_CONTEXT       BindCache ;
DWORD             BindCacheCount = 0 ;

//
// Initializes a cache entry
//
HRESULT BindCacheAllocEntry(NWC_CONTEXT **ppCacheEntry)
{

    NWC_CONTEXT *pCacheEntry ;

    *ppCacheEntry = NULL ;

    if (!(pCacheEntry = (PNWC_CONTEXT)AllocADsMem(sizeof(NWC_CONTEXT)))) {

        RRETURN(E_OUTOFMEMORY);

    }

    pCacheEntry->RefCount = 0;
    pCacheEntry->Flags = 0;
    pCacheEntry->List.Flink = NULL ;
    pCacheEntry->List.Blink = NULL ;
    pCacheEntry->pCredentials = NULL;
    pCacheEntry->pszBinderyName = NULL;

    *ppCacheEntry =  pCacheEntry ;

    RRETURN(S_OK);
}

//
// Frees a cache entry.
//
// This is not a way to remove entries from the cache --- use BindCacheDef
// for that.  It is a way to either free a entry alloc'ed with
// BindCacheAllocEntry that was never added to the cache, or to dealloc
// the entry after it has been removed from the cache (BindCacheDefer
// returned 0).

HRESULT BindCacheFreeEntry(NWC_CONTEXT *pCacheEntry)
{
    if (pCacheEntry)
    {
        if (pCacheEntry->pszBinderyName)
            FreeADsMem(pCacheEntry->pszBinderyName) ;

        delete pCacheEntry->pCredentials;

        FreeADsMem(pCacheEntry);
    }

    RRETURN(S_OK);
}

//
// Invalidates a cache entry so it will not be used.
//
VOID BindCacheInvalidateEntry(NWC_CONTEXT *pCacheEntry)
{
    pCacheEntry->Flags |= NWC_CACHE_INVALID ;
}

//
// Lookup an entry in the cache. Does not take into account timeouts.
// Increments ref count if found.
//
PNWC_CONTEXT
BindCacheLookupByConn(
    NWCONN_HANDLE hConn
    )
{
    DWORD i ;

    PNWC_CONTEXT pEntry = (PNWC_CONTEXT) BindCache.List.Flink ;

    //
    // Loop thru looking for match. A match is defined as:
    //     hConn, and it is NOT invalid.
    //
    while (pEntry != &BindCache) {

        if (!(pEntry->Flags & NWC_CACHE_INVALID) &&
            (pEntry->hConn == hConn)) {

            ++pEntry->RefCount ;

            return(pEntry) ;
        }

        pEntry = (PNWC_CONTEXT)pEntry->List.Flink ;
    }

    return NULL ;
}

//
// Lookup an entry in the cache. Does not take into account timeouts.
// Increments ref count if found.
//
PNWC_CONTEXT
BindCacheLookup(
    LPWSTR pszBinderyName,
    CCredentials& Credentials
    )
{
    DWORD i ;

    PNWC_CONTEXT pEntry = (PNWC_CONTEXT) BindCache.List.Flink ;

    //
    // Loop thru looking for match. A match is defined as:
    //     tree name and credentials, and it is NOT invalid.
    //
    while (pEntry != &BindCache) {

        if (!(pEntry->Flags & NWC_CACHE_INVALID) &&
            (((pszBinderyName != NULL) && (pEntry->pszBinderyName != NULL) &&
             (_wcsicmp(pEntry->pszBinderyName, pszBinderyName) == 0)) ||
            (pEntry->pszBinderyName == NULL && pszBinderyName == NULL)) &&
             (*(pEntry->pCredentials) == Credentials)) {

            ++pEntry->RefCount ;

            return(pEntry) ;
        }

        pEntry = (PNWC_CONTEXT)pEntry->List.Flink ;
    }

    return NULL ;
}


//
// Add entry to cache.  Returns S_FALSE if there are too many
// entries already in the cache.
//
HRESULT
BindCacheAdd(
    LPWSTR pszBinderyName,
    CCredentials& Credentials,
    BOOL fLoggedIn,
    PNWC_CONTEXT pCacheEntry)
{

    LPWSTR pszBindery = (LPWSTR) AllocADsMem(
                                   (wcslen(pszBinderyName)+1)*sizeof(WCHAR)) ;

    if (!pszBindery) {

        RRETURN(E_OUTOFMEMORY);
    }

    CCredentials * pCredentials = new CCredentials(Credentials);

    if (!pCredentials) {

        FreeADsMem(pszBindery);

        RRETURN(E_OUTOFMEMORY);
    }

    //
    // setup the data
    //
    wcscpy(pszBindery,pszBinderyName) ;
    pCacheEntry->pszBinderyName = pszBindery;
    pCacheEntry->pCredentials = pCredentials;
    pCacheEntry->RefCount  = 1 ;
    pCacheEntry->fLoggedIn = fLoggedIn;

    //
    // insert into list
    //
    InsertHeadList(&BindCache.List, &pCacheEntry->List) ;
    ++BindCacheCount ;

    RRETURN(S_OK);
}

//
// Dereference an entry in the cache. Removes if ref count is zero.
// Returns the final ref count or zero if not there. If zero, caller
// should close the handle.
//
DWORD BindCacheDeref(NWC_CONTEXT *pCacheEntry)
{

    DWORD i=0;

    ENTER_BIND_CRITSECT() ;

    if ((pCacheEntry->List.Flink == NULL) &&
        (pCacheEntry->List.Blink == NULL) &&
        (pCacheEntry->RefCount == NULL)) {

        //
        // this is one of the entries that never got into the cache.
        //
        LEAVE_BIND_CRITSECT() ;
        return(0) ;
    }

    ADsAssert(pCacheEntry->List.Flink) ;
    ADsAssert(pCacheEntry->RefCount > 0) ;

    //
    // Dereference by one. If result is non zero, just return.
    //
    --pCacheEntry->RefCount ;

    if (pCacheEntry->RefCount) {

        LEAVE_BIND_CRITSECT() ;
        return(pCacheEntry->RefCount) ;
    }

    //
    // This entry can be cleaned up. 
    //

    --BindCacheCount ;

    RemoveEntryList(&pCacheEntry->List) ;

    LEAVE_BIND_CRITSECT() ;
    return 0 ;
}


VOID
BindCacheInit(
    VOID
    )
{
    InitializeCriticalSection(&BindCacheCritSect) ;
    InitializeListHead(&BindCache.List) ;
}

VOID
BindCacheCleanup(
    VOID
    )
{
    PNWC_CONTEXT pEntry = (PNWC_CONTEXT) BindCache.List.Flink ;

    while (pEntry != &BindCache) {

        PNWC_CONTEXT pNext = (PNWC_CONTEXT) pEntry->List.Flink;

        if (pEntry->pszBinderyName)
            FreeADsMem(pEntry->pszBinderyName) ;
        pEntry->pszBinderyName = NULL ;

        delete pEntry->pCredentials;
        pEntry->pCredentials = NULL;

        RemoveEntryList(&pEntry->List) ;

        BindCacheFreeEntry(pEntry);

        pEntry = pNext;
    }

    DeleteCriticalSection(&BindCacheCritSect);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\nw3utils.cxx ===
#include "NWCOMPAT.hxx"
#pragma hdrstop

//----------------------------------------------------------------------------
//
//  Function: NWApiGetProperty
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetProperty(
    BSTR bstrObjectName,
    LPSTR lpszPropertyName,
    NWOBJ_TYPE dwOT_ID,
    NWCONN_HANDLE hConn,
    LPP_RPLY_SGMT_LST lppReplySegment,
    LPDWORD pdwNumSegment
    )
{
    CHAR             szObjectName[OBJ_NAME_SIZE + 1];
    CHAR             szPropertyName[OBJ_NAME_SIZE + 1];
    NWFLAGS          pucMoreFlag = 0;
    NWFLAGS          pucPropFlag = 0;
    unsigned char    ucSegment = 1;
    LP_RPLY_SGMT_LST lpHeadReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTempReplySegment = NULL;
    HRESULT          hr = S_OK;
    NWCCODE          ccode = 0;

    //
    // lppReplySegment is assumed to be NULL.
    //

    ADsAssert((*lppReplySegment) == NULL);

    //
    // Convert BSTR into an ANSI representation required by NW APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        bstrObjectName,
        szObjectName,
        0
        );

    //
    // Initialize first node of the list and set up temp traversal pointer.
    //

    INIT_RPLY_SGMT(lpTempReplySegment);
    lpHeadReplySegment = lpTempReplySegment;

    //
    // Read & dump property values into linked-list.
    //

    strcpy(szPropertyName, lpszPropertyName);

    do {

       ccode = NWReadPropertyValue(
                   hConn,
                   szObjectName,
                   dwOT_ID,
                   szPropertyName,
                   ucSegment,
                   (pnuint8) lpTempReplySegment->Segment,
                   &pucMoreFlag,
                   &pucPropFlag
                   );
       hr = HRESULT_FROM_NWCCODE(ccode);
       BAIL_ON_FAILURE(hr);

       if (pucMoreFlag) {

           INIT_RPLY_SGMT(lpTempReplySegment->lpNext);
           lpTempReplySegment = lpTempReplySegment->lpNext;

          ucSegment++;
       }

    } while(pucMoreFlag);

    //
    // Return the resulting linked-list.
    //

    *lppReplySegment = lpHeadReplySegment;
    *pdwNumSegment = ucSegment;

error:
    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGetFileServerVersionInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetFileServerVersionInfo(
    NWCONN_HANDLE hConn,
    NW_VERSION_INFO  *pVersionInfo
    )
{
    NWCCODE ccode = SUCCESSFUL;
    HRESULT hr = S_OK;

    ccode = NWGetFileServerVersionInfo(
                hConn,
                (VERSION_INFO *) pVersionInfo
                );
    hr = HRESULT_FROM_NWCCODE(ccode);

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiIsObjectInSet
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiIsObjectInSet(
    NWCONN_HANDLE hConn,
    LPWSTR lpszObjectName,
    NWOBJ_TYPE wObjType,
    LPSTR lpszPropertyName,
    LPSTR lpszMemberName,
    NWOBJ_TYPE wMemberType
    )
{
    CHAR szAnsiObjectName[OBJ_NAME_SIZE + 1];
    CHAR szPropertyName[OBJ_NAME_SIZE + 1];
    CHAR szMemberName[OBJ_NAME_SIZE + 1];
    HRESULT hr = S_OK;
    NWCCODE ccode = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NW APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    strcpy(szPropertyName, lpszPropertyName);
    strcpy(szMemberName, lpszMemberName);

    //
    // Call NWIsObjectInSet.
    //

    ccode = NWIsObjectInSet(
                hConn,
                szAnsiObjectName,
                wObjType,
                szPropertyName,
                szMemberName,
                wMemberType
                );
    hr = HRESULT_FROM_NWCCODE(ccode);

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGetObjectID
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetObjectID(
    NWCONN_HANDLE hConn,
    LPWSTR lpszObjectName,
    NWOBJ_TYPE wObjType,
    NWOBJ_ID *pObjectID
    )
{
    CHAR szAnsiObjectName[OBJ_NAME_SIZE + 1];
    HRESULT hr = S_OK;
    NWCCODE ccode = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NW APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    //
    // Get Object's ID.
    //

    ccode = NWGetObjectID(
                hConn,
                szAnsiObjectName,
                wObjType,
                pObjectID
                );
    hr = HRESULT_FROM_NWCCODE(ccode);

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGroupGetMembers
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGroupGetMembers(
    NWCONN_HANDLE hConn,
    LPWSTR szGroupName,
    LPBYTE *lppBuffer
    )
{
    DWORD   dwNumSegment = 0;
    HRESULT hr = S_OK;
    DWORD   i;
    LP_RPLY_SGMT_LST lpTemp = NULL;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;

    //
    // Assert
    //

    ADsAssert(*lppBuffer == NULL);

    //
    // Get GROUP_MEMBERS.
    //

    hr = NWApiGetProperty(
             szGroupName,
             NW_PROP_GROUP_MEMBERS,
             OT_USER_GROUP,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );
    BAIL_ON_FAILURE(hr);

    //
    // Pack returned linked list into buffer.
    //

    *lppBuffer = (LPBYTE) AllocADsMem(
                           dwNumSegment * REPLY_VALUE_SIZE
                           );
    if (!(*lppBuffer)) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpTemp = lpReplySegment;

    for (i = 0; i < dwNumSegment; i++) {
        memcpy(
            *lppBuffer + i * REPLY_VALUE_SIZE,
            lpTemp->Segment,
            REPLY_VALUE_SIZE
            );
        lpTemp = lpTemp->lpNext;
    }

error:

    //
    // Clean up.
    //

    lpTemp = NULL;

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN(hr);
}
//----------------------------------------------------------------------------
//
//  Function: NWApiAddGroupMember
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiAddGroupMember(
    NWCONN_HANDLE hConn,
    LPWSTR pszGroupName,
    LPWSTR pszMemberName
    )
{
    CHAR    szGroupName[OBJ_NAME_SIZE + 1];
    CHAR    szMemberName[OBJ_NAME_SIZE + 1];
    HRESULT hr = S_OK;
    NWCCODE ccode = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        pszGroupName,
        szGroupName,
        0
        );

    UnicodeToAnsiString(
        pszMemberName,
        szMemberName,
        0
        );

    //
    // Modify GROUP_MEMBERS property of the group to include the new member.
    //

    ccode = NWAddObjectToSet(
                hConn,
                szGroupName,
                OT_USER_GROUP,
                "GROUP_MEMBERS",
                szMemberName,
                OT_USER
                );
    hr = HRESULT_FROM_NWCCODE(ccode);
    BAIL_ON_FAILURE(hr);

    //
    // Modify GROUPS_I'M_IN property of the new member to reflect its included
    // in the new group.
    //

    ccode = NWAddObjectToSet(
                hConn,
                szMemberName,
                OT_USER,
                "GROUPS_I'M_IN",
                szGroupName,
                OT_USER_GROUP
                );
    hr = HRESULT_FROM_NWCCODE(ccode);
    BAIL_ON_FAILURE(hr);

    //
    // Modify SECURITY_EQUALS property of the new member to equate its security
    // to that of the new group it just joined.
    //

    ccode = NWAddObjectToSet(
                hConn,
                szMemberName,
                OT_USER,
                "SECURITY_EQUALS",
                szGroupName,
                OT_USER_GROUP
                );
    hr = HRESULT_FROM_NWCCODE(ccode);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiRemoveGroupMember
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiRemoveGroupMember(
    NWCONN_HANDLE hConn,
    LPWSTR pszGroupName,
    LPWSTR pszMemberName
    )
{
    CHAR    szGroupName[OBJ_NAME_SIZE + 1];
    CHAR    szMemberName[OBJ_NAME_SIZE + 1];
    HRESULT hr = S_OK;
    NWCCODE ccode = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NW APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        pszGroupName,
        szGroupName,
        0
        );

    UnicodeToAnsiString(
        pszMemberName,
        szMemberName,
        0
        );

    //
    // Modify SECURITY_EQUALS property of the removed member to break its
    // security tie with the group it joined.
    //

    ccode = NWDeleteObjectFromSet(
                hConn,
                szMemberName,
                OT_USER,
                "SECURITY_EQUALS",
                szGroupName,
                OT_USER_GROUP
                );
    hr = HRESULT_FROM_NWCCODE(ccode);
    BAIL_ON_FAILURE(hr);

    //
    // Modify GROUPS_I'M_IN property of the new member to reflect it is not
    // included in the group anymore.
    //

    ccode = NWDeleteObjectFromSet(
                hConn,
                szMemberName,
                OT_USER,
                "GROUPS_I'M_IN",
                szGroupName,
                OT_USER_GROUP
                );
    hr = HRESULT_FROM_NWCCODE(ccode);
    BAIL_ON_FAILURE(hr);

    //
    // Modify GROUP_MEMBERS property of the group to remove the member.
    //

    ccode = NWDeleteObjectFromSet(
                hConn,
                szGroupName,
                OT_USER_GROUP,
                "GROUP_MEMBERS",
                szMemberName,
                OT_USER
                );
    hr = HRESULT_FROM_NWCCODE(ccode);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);

}
//----------------------------------------------------------------------------
//
//  Function: NWApiGetLOGIN_CONTROL
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetLOGIN_CONTROL(
    NWCONN_HANDLE hConn,
    LPWSTR lpszUserName,
    LPLC_STRUCTURE lpLoginCtrlStruct
    )
{
    DWORD            dwNumSegment = 0;
    HRESULT          hr = S_OK;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL;

    hr = NWApiGetProperty(
             lpszUserName,
             NW_PROP_LOGIN_CONTROL,
             OT_USER,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );
    BAIL_ON_FAILURE(hr);

    *lpLoginCtrlStruct = *((LPLC_STRUCTURE) lpReplySegment->Segment);

error:

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiSetDefaultAcctExpDate
//
//  Synopsis: This function looks at the local time and returns a default value
//            for an account expiration date in a variant date.
//
//----------------------------------------------------------------------------
HRESULT
NWApiSetDefaultAcctExpDate(
    DOUBLE * pdTime,
    SYSTEMTIME SysTime
    )
{
    DOUBLE  vTime;
    HRESULT hr = S_OK;

    //
    // According to SysCon, the default account expiration date is the first day
    // of the following month.
    //

    if (SysTime.wMonth == 12) {
        SysTime.wMonth = 1;
    }
    else {
        SysTime.wMonth++;
    }

    SysTime.wDay = 1;

    //
    // Subtract 1980 from wYear for NWApiMakeVariantTime.
    //

    SysTime.wYear -= 1980;

    hr = NWApiMakeVariantTime(
             &vTime,
             SysTime.wDay,
             SysTime.wMonth,
             SysTime.wYear,
             0,0,0
             );
    BAIL_ON_FAILURE(hr);

    *pdTime = vTime;

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiUserAsSupervisor
//
//  Synopsis: This functions turns the user into one of the supervisors if TRUE
//            is passed.  User's supervisor privilege is removed otherwise.
//
//----------------------------------------------------------------------------
HRESULT
NWApiUserAsSupervisor(
    NWCONN_HANDLE hConn,
    LPWSTR lpszUserName,
    BOOL fSupervisor
    )
{
    CHAR    szUserName[OBJ_NAME_SIZE + 1];
    HRESULT hr = S_OK;
    NWCCODE ccode = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        lpszUserName,
        szUserName,
        0
        );

    //
    // Make it a supervisor.
    //

    if (fSupervisor == TRUE) {
        ccode = NWAddObjectToSet(
                    hConn,
                    szUserName,
                    OT_USER,
                    "SECURITY_EQUALS",
                    "SUPERVISOR",
                    OT_USER
                    );
    }

    //
    // Remove supervisor privilege.
    //

    else {
        ccode = NWDeleteObjectFromSet(
                    hConn,
                    szUserName,
                    OT_USER,
                    "SECURITY_EQUALS",
                    "SUPERVISOR",
                    OT_USER
                    );
    }

    hr = HRESULT_FROM_NWCCODE(ccode);

    RRETURN(hr);                                              
}

//----------------------------------------------------------------------------
//
//  Function: NWApiGetVolumeNumber
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetVolumeNumber(
    NWCONN_HANDLE hConn,
    LPWSTR lpszVolumeName,
    NWVOL_NUM *pVolumeNumber
    )
{
    CHAR    szVolumeName[OBJ_NAME_SIZE + 1];
    HRESULT hr = S_OK;
    NWCCODE ccode = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        lpszVolumeName,
        szVolumeName,
        0
        );

   //
   // there can't be a volume longer than VOL_NAME_SIZE. Check because client
   // may AV otherwise. 
   //
   if (wcslen(lpszVolumeName) > VOL_NAME_SIZE) {
    
       // Don't bother trying
       //
       BAIL_ON_FAILURE(hr = HRESULT_FROM_NWCCODE(NWE_VOL_INVALID));
   }
    //
    // Get Volume's number.
    //

    ccode = NWGetVolumeNumber(
                hConn,
                szVolumeName,
                pVolumeNumber
                );
    hr = HRESULT_FROM_NWCCODE(ccode);

    //
    // Return.
    //

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiGetVolumeName
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetVolumeName(
    NWCONN_HANDLE hConn,
    NWVOL_NUM bVolNum,
    LPWSTR *lppszVolName
    )
{
    CHAR    szVolumeName[OBJ_NAME_SIZE + 1];
    HRESULT hr = S_OK;
    LPWSTR  lpszTemp = NULL;
    NWCCODE ccode = SUCCESSFUL;

    //
    // Get Volume's name.
    //

    ccode = NWGetVolumeName(
                hConn,
                bVolNum,
                szVolumeName
                );
    hr = HRESULT_FROM_NWCCODE(ccode);
    BAIL_ON_FAILURE(hr);

    //
    // Convert result into Unicode.
    //

    lpszTemp = AllocateUnicodeString(szVolumeName);
    if (!lpszTemp) {
       RRETURN(S_FALSE);
    }

    *lppszVolName = AllocADsStr(lpszTemp);
    if (!(*lppszVolName)) {
        RRETURN(S_FALSE);
    }

    FreeUnicodeString(lpszTemp);

    //
    // Return.
    //

    RRETURN(hr);

error:

    *lppszVolName = NULL;

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiEnumJobs
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiEnumJobs(
    HANDLE hPrinter,
    DWORD dwFirstJob,
    DWORD dwNoJobs,
    DWORD dwLevel,
    LPBYTE *lplpbJobs,
    DWORD *pcbBuf,
    LPDWORD lpdwReturned
    )
{
    BOOL    fStatus = TRUE;
    HRESULT hr = S_OK;

    fStatus = WinNTEnumJobs(
                  hPrinter,
                  dwFirstJob,
                  dwNoJobs,
                  dwLevel,
                  lplpbJobs,
                  pcbBuf,
                  lpdwReturned
                  );

    if (fStatus == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiGetPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE *lplpbPrinters
    )
{
    BOOL    fStatus = TRUE;
    HRESULT hr = S_OK;

    fStatus = WinNTGetPrinter(
                  hPrinter,
                  dwLevel,
                  lplpbPrinters
                  );

    if (fStatus == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiUncFromADsPath
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiUncFromADsPath(
    LPWSTR lpszADsPath,
    LPWSTR lpszUncName
    )
{
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;

    hr = BuildObjectInfo(lpszADsPath,
                         &pObjectInfo );

    BAIL_ON_FAILURE(hr);

   wsprintf(
        lpszUncName,
        L"\\\\%s\\%s",
        pObjectInfo->ComponentArray[0],
        pObjectInfo->ComponentArray[1]
        );

error:
    if(pObjectInfo){
        FreeObjectInfo(pObjectInfo);
    }
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiMakeUserInfo
//
//  Synopsis: This function is very provider specific.
//
//----------------------------------------------------------------------------
HRESULT
NWApiMakeUserInfo(
    LPWSTR lpszBinderyName,
    LPWSTR lpszUserName,
    LPWSTR lpszPassword,
    CCredentials &Credentials,  // of the user doing the MakeUserInfo
    PNW_USER_INFO pNwUserInfo
    )
{
    HRESULT hr = S_OK;
    NW_USER_INFO NwUserInfo = {NULL, NULL, NULL, NULL};

    hr = NWApiGetBinderyHandle(
             &NwUserInfo.hConn,
             lpszBinderyName,
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(lpszBinderyName, &NwUserInfo.lpszBinderyName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(lpszUserName, &NwUserInfo.lpszUserName);
    BAIL_ON_FAILURE(hr);

    if (lpszPassword) {

        hr = ADsAllocString(lpszPassword, &NwUserInfo.lpszPassword);
        BAIL_ON_FAILURE(hr);
    }

    //
    // Return.
    //

    *pNwUserInfo = NwUserInfo;
    RRETURN(hr);

error:
    if (NwUserInfo.lpszBinderyName)
        ADsFreeString(NwUserInfo.lpszBinderyName);

    if (NwUserInfo.lpszUserName)
        ADsFreeString(NwUserInfo.lpszUserName);

    if (NwUserInfo.lpszPassword)
        ADsFreeString(NwUserInfo.lpszPassword);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiFreeUserInfo
//
//  Synopsis: This function is very provider specific.
//
//----------------------------------------------------------------------------
HRESULT
NWApiFreeUserInfo(
    PNW_USER_INFO pNwUserInfo
    )
{
    HRESULT hr = S_OK;

    if (pNwUserInfo->lpszBinderyName) {
        ADsFreeString(pNwUserInfo->lpszBinderyName);
        pNwUserInfo->lpszBinderyName = NULL ;
    }

    if (pNwUserInfo->lpszUserName) {
        ADsFreeString(pNwUserInfo->lpszUserName);
        pNwUserInfo->lpszUserName = NULL;
    }

    if (pNwUserInfo->lpszPassword) {
        ADsFreeString(pNwUserInfo->lpszPassword);
        pNwUserInfo->lpszPassword = NULL;
    }

    if (pNwUserInfo->hConn) {
        hr = NWApiReleaseBinderyHandle(
            pNwUserInfo->hConn
            );
        BAIL_ON_FAILURE(hr);
    }
    
error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreateUser
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreateUser(
    PNW_USER_INFO pNwUserInfo
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NTSTATUS      Status = STATUS_SUCCESS;
    NWCCODE       ccode = SUCCESSFUL;
    NWCONN_HANDLE hConn = NULL;
    NWOBJ_ID      UserObjectID;
    UCHAR         ChallengeKey[8];
    UCHAR         NewKeyedPassword[17];
    UCHAR         ValidationKey[8];
    WCHAR         szTemp[MAX_PATH];

    //
    // "Create Bindery Object" - user object.  This user object is going to be
    // static, with access equals to logged read, supervisor write.
    //

    hr = NWApiCreateBinderyObject(
             pNwUserInfo->hConn,
             pNwUserInfo->lpszUserName,
             OT_USER,
             BF_STATIC,
             BS_LOGGED_READ | BS_SUPER_WRITE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Add user password.
    //

    hr = NWApiSetUserPassword(
             pNwUserInfo,
             &UserObjectID,
             NULL                 // no old passwd - this is a SET
             );
    BAIL_ON_FAILURE(hr);

    //
    // Create necessary bindery property to facilitate the addition of this user
    // to the group EVERYONE.
    //

    hr = NWApiCreateProperty(
             pNwUserInfo->hConn,
             pNwUserInfo->lpszUserName,
             OT_USER,
             "GROUPS_I'M_IN",
             BF_SET
             );
    BAIL_ON_FAILURE(hr);

    hr = NWApiCreateProperty(
             pNwUserInfo->hConn,
             pNwUserInfo->lpszUserName,
             OT_USER,
             "SECURITY_EQUALS",
             BF_SET
             );
    BAIL_ON_FAILURE(hr);

    //
    // Add this user to the group EVERYONE.
    //

    wcscpy(szTemp, L"EVERYONE");

    hr = NWApiAddGroupMember(
             pNwUserInfo->hConn,
             szTemp,
             pNwUserInfo->lpszUserName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Create mail directory and login files.
    //

    hr = NWApiCreateMailDirectory(
             pNwUserInfo,
             UserObjectID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Create LOGIN_CONTROL & ACCOUNT_BALANCE property for the user.  Values
    // from USER_DEFAULTS are used as default.
    //

    hr = NWApiSetLoginCtrlAndAcctBalance(
             pNwUserInfo
             );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiDeleteUser
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiDeleteUser(
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials
    )
{
    BOOL          err = TRUE;
    DWORD         dwErr = 0;
    HRESULT       hr = S_OK;
    NWCONN_HANDLE hConn = NULL;
    NWOBJ_ID      ObjectID;
    WCHAR         szPath[MAX_PATH];

    //
    // Open a handle to the bindery.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0],
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get the user's ObjectID which is needed to compose the path name of LOGIN
    // and LOGIN.OS2.
    //

    hr = NWApiGetObjectID(
             hConn,
             pObjectInfo->ComponentArray[1],
             OT_USER,
             &ObjectID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Delete SYS:MAIL\<JOBID>\LOGIN.  If the file is not found, that's OK, as
    // long as it is not there.
    //

    wsprintf(
        szPath,
        L"\\\\%s\\SYS\\MAIL\\%X\\LOGIN",
        pObjectInfo->ComponentArray[0],
        dwSWAP(ObjectID)
        );

    err = DeleteFile(szPath);

    //
    // Remove any error checking for the cleanup of
    // files. If they do exist, and we do clean them up
    // great. But otherwise Win95 chokes on us.
    //

    //
    // Delete SYS:MAIL\<JOBID>\LOGIN.OS2.  If the file is not found, that's OK,
    // as long as it is not there.
    //

    wsprintf(
        szPath,
        L"\\\\%s\\SYS\\MAIL\\%X\\LOGIN.OS2",
        pObjectInfo->ComponentArray[0],
        dwSWAP(ObjectID)
        );

    err = DeleteFile(szPath);

    //
    // Remove any error checking for the cleanup of
    // files. If they do exist, and we do clean them up
    // great. But otherwise Win95 chokes on us.
    //

    //
    // Delete SYS:MAIL\<JOBID>.
    //

    wsprintf(
        szPath,
        L"\\\\%s\\SYS\\MAIL\\%X",
        pObjectInfo->ComponentArray[0],
        dwSWAP(ObjectID)
        );

    err = RemoveDirectory(szPath);

    //
    // Remove any error checking for the cleanup of
    // files. If they do exist, and we do clean them up
    // great. But otherwise Win95 chokes on us.
    //


    //
    // Delete the user object.
    //

    hr = NWApiDeleteBinderyObject(
             hConn,
             pObjectInfo->ComponentArray[1],
             OT_USER
             );
    BAIL_ON_FAILURE(hr);

error:

    NWApiReleaseBinderyHandle(hConn);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreateBinderyObject
//
//  Synopsis: This function create the specified object in the specified NetWare
//            bindery.  It returns S_OK if the object alread exist.
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreateBinderyObject(
    NWCONN_HANDLE hConn,
    LPWSTR lpszObjectName,
    NWOBJ_TYPE wObjType,
    NWFLAGS ucObjectFlags,
    NWFLAGS usObjSecurity
    )
{
    CHAR szAnsiObjectName[OBJ_NAME_SIZE + 1];
    HRESULT hr = S_OK;
    NWCCODE ccode = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    //
    // Create a Static object with LOGGED_READ & SUPERVISOR_WRITE.
    //

    ccode = NWCreateObject(
                hConn,
                szAnsiObjectName,
                wObjType,
                BF_STATIC,
                BS_LOGGED_READ | BS_SUPER_WRITE
                );
    //
    // If an error occured, check if it is OBJECT_ALREADY_EXISTS.  If it is,
    // treat it as no error.
    //

    if (ccode) {
        if (ccode == OBJECT_ALREADY_EXISTS) {
            ccode = SUCCESSFUL;
        }
    }

    //
    // Return.
    //

    hr = HRESULT_FROM_NWCCODE(ccode);
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiDeleteBinderyObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiDeleteBinderyObject(
    NWCONN_HANDLE hConn,
    LPWSTR lpszObjectName,
    NWOBJ_TYPE wObjType
    )
{
    CHAR szAnsiObjectName[OBJ_NAME_SIZE + 1];
    HRESULT hr = S_OK;
    NWCCODE ccode = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    //
    // Delete the object from the bindery.
    //

    ccode = NWDeleteObject(
                hConn,
                szAnsiObjectName,
                wObjType
                );
    //
    // Return.
    //

    hr = HRESULT_FROM_NWCCODE(ccode);
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiRenameObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiRenameObject(
    POBJECTINFO pObjectInfoSource,
    POBJECTINFO pObjectInfoTarget,
    NWOBJ_TYPE wObjType,
    CCredentials &Credentials
    )
{
    HRESULT       hr = S_OK;
    NWCCODE ccode = SUCCESSFUL;

    CHAR szAnsiSourceName[OBJ_NAME_SIZE + 1];
    CHAR szAnsiTargetName[OBJ_NAME_SIZE + 1];

    NWCONN_HANDLE hConn = NULL;

    //
    // Open a handle to the bindery.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfoSource->ComponentArray[0],
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        pObjectInfoSource->ComponentArray[1],
        szAnsiSourceName,
        0
        );

    UnicodeToAnsiString(
        pObjectInfoTarget->ComponentArray[1],
        szAnsiTargetName,
        0
        );

    // Rename the object
    ccode = NWRenameObject(
                hConn,
                szAnsiSourceName,
                szAnsiTargetName,
                wObjType);
    
    hr = HRESULT_FROM_NWCCODE(ccode);

error:
    NWApiReleaseBinderyHandle(hConn);
    RRETURN(hr);
}


#define            NW_MAX_PASSWORD_LEN    256

//----------------------------------------------------------------------------
//
//  Function: NWApiSetUserPassword
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiSetUserPassword(
    PNW_USER_INFO pNwUserInfo,
    DWORD *pdwUserObjID,
    LPWSTR pszOldPassword
    )
{
    CHAR           szAnsiUserName[OBJ_NAME_SIZE + 1];
    CHAR           szAnsiPassword[NW_MAX_PASSWORD_LEN + 1];
    CHAR           szAnsiOldPassword[NW_MAX_PASSWORD_LEN + 1];
    WCHAR          szOldPasswordCopy[NW_MAX_PASSWORD_LEN + 1];
    HRESULT        hr = S_OK;
    NWCCODE        ccode=0;
    
    if ( !pNwUserInfo || 
         !(pNwUserInfo->lpszUserName) || 
         !(pNwUserInfo->lpszPassword) ) {

        hr = E_INVALIDARG ;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Convert UNICODE into ANSI representation required by NW APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        pNwUserInfo->lpszUserName,
        szAnsiUserName,
        0
        );

    _wcsupr(pNwUserInfo->lpszPassword) ;
    UnicodeToAnsiString(
        pNwUserInfo->lpszPassword,
        szAnsiPassword,
        0
        );

    if (pszOldPassword) {
        wcscpy(szOldPasswordCopy, pszOldPassword);
        _wcsupr(szOldPasswordCopy) ;
        UnicodeToAnsiString(
            szOldPasswordCopy,
            szAnsiOldPassword,
            0
            );
    }
    else {

        szAnsiOldPassword[0] = 0 ;
    }

    ccode = NWChangeObjectPassword(
                 pNwUserInfo->hConn,
                 szAnsiUserName,
                 OT_USER,
                 szAnsiOldPassword,
                 szAnsiPassword
                 );
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    NWGetObjectID(
        pNwUserInfo->hConn,
        szAnsiUserName,
        OT_USER,
        pdwUserObjID
        );
    hr = HRESULT_FROM_NWCCODE(ccode);


error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreateMailDirectory
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreateMailDirectory(
    PNW_USER_INFO pNwUserInfo,
    NWOBJ_ID UserObjID
    )
{
    DWORD          err = 0;
    BYTE    szPath[(MAX_PATH + 1) * sizeof(WCHAR)];
    CHAR    szUserObjID[255];
    NWCCODE ccode = 0;
    HRESULT hr = S_OK;

    //
    // Make path.
    //

    _ltoa(
        dwSWAP(UserObjID),
        szUserObjID,
        16
        );

    strcpy((char *) szPath, "SYS:\\MAIL\\");
    strcat((char *) szPath, szUserObjID);

    //
    // Create a directory with Maximum rights mask.
    //

    ccode = NWCreateDirectory(
                pNwUserInfo->hConn,
                0,
                (char *) szPath,
                0xFF
                );  

    if (ccode == NWE_HARD_FAILURE) {
        //
        // The directory already exists, OK
        //
        ccode = 0;
    }

    BAIL_ON_FAILURE(hr = HRESULT_FROM_NWCCODE(ccode));

    if ( !ccode ) {
        //
        // Add a trustee with all rights except PARENTAL right.
        //
        ccode = NWAddTrustee(
                   pNwUserInfo->hConn,
                   0,
                   (char *) szPath,
                   UserObjID,
                   0xDF
                   );   // BUGBUG - 0xDF is used in SysCon, but don't
                       //          know why.
        BAIL_ON_FAILURE(hr = HRESULT_FROM_NWCCODE(ccode));

        //
        // Create a Login file.
        //

        if ( !ccode ) {
            HANDLE hFile;

            wsprintfW(
                (LPWSTR) szPath,
                L"\\\\%ws\\SYS\\MAIL\\%X\\LOGIN",
                pNwUserInfo->lpszBinderyName,
                dwSWAP(UserObjID)
                );

            hFile = CreateFile(
                        (LPWSTR) szPath,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        0
                        );

            if ( hFile == INVALID_HANDLE_VALUE ) {
                err = GetLastError();
            }

            if ( !err )
                CloseHandle( hFile );

            //
            // Create a Login.os2 file.
            //

            wsprintfW(
                (LPWSTR) szPath,
                L"\\\\%ws\\SYS\\MAIL\\%X\\LOGIN.OS2",
                pNwUserInfo->lpszBinderyName,
                dwSWAP(UserObjID)
                );

            hFile = CreateFile(
                        (LPWSTR) szPath,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        0
                        );

            if ( hFile == INVALID_HANDLE_VALUE ) {
                err = GetLastError();
            }

            if ( !err )
                CloseHandle( hFile );
        }
    }

    //
    // BUGBUG: Does 255 means path already exists?
    //         Or ignore the error?
    // if ( err == 255 )   // 0xC00100FF
    //

    // err = NO_ERROR;

    hr = HRESULT_FROM_WIN32(err);

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiSetLoginCtrlAndAcctBalance
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiSetLoginCtrlAndAcctBalance(
    PNW_USER_INFO pNwUserInfo
    )
{
    ACCT_BALANCE     AccountBalance;
    DWORD            dwNumSegment;
    HRESULT          hr = S_OK;
    int              i = 0;
    LC_STRUCTURE     LoginCtrl;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL;
    USER_DEFAULT     UserDefault;
    WCHAR            szTemp[MAX_PATH];

    //
    // Get Supervisor's USER_DEFAULTS.
    //

    wcscpy(szTemp, NW_PROP_SUPERVISORW);

    hr = NWApiGetProperty(
             szTemp,
             NW_PROP_USER_DEFAULTS,
             OT_USER,
             pNwUserInfo->hConn,
             &lpReplySegment,
             &dwNumSegment
             );
    BAIL_ON_FAILURE(hr);

    UserDefault = *((LPUSER_DEFAULT) lpReplySegment->Segment);

    //
    // Put default values into LoginCtrl.
    //

    LoginCtrl.byAccountExpires[0] = UserDefault.byAccountExpiresYear;
    LoginCtrl.byAccountExpires[1] = UserDefault.byAccountExpiresMonth;
    LoginCtrl.byAccountExpires[2] = UserDefault.byAccountExpiresDay;
    LoginCtrl.byAccountDisabled = 0;
    LoginCtrl.byPasswordExpires[0] = 85;
    LoginCtrl.byPasswordExpires[1] = 01;
    LoginCtrl.byPasswordExpires[2] = 01;
    LoginCtrl.byGraceLogins = UserDefault.byGraceLoginReset;
    LoginCtrl.wPasswordInterval = UserDefault.wPasswordInterval;
    LoginCtrl.byGraceLoginReset = UserDefault.byGraceLoginReset;
    LoginCtrl.byMinPasswordLength = UserDefault.byMinPasswordLength;
    LoginCtrl.wMaxConnections = UserDefault.wMaxConnections;
    LoginCtrl.byRestrictions = UserDefault.byRestrictions;
    LoginCtrl.byUnused = 0;
    LoginCtrl.lMaxDiskBlocks = UserDefault.lMaxDiskBlocks;
    LoginCtrl.wBadLogins = 0;
    LoginCtrl.lNextResetTime = 0;

    for (i = 0; i < 42; i++) {
        LoginCtrl.byLoginTimes[i] = UserDefault.byLoginTimes[i];
    }

    for (i = 0; i < 6; i++) {
        LoginCtrl.byLastLogin[i] = 0;
    }

    for (i = 0; i < 12; i++) {
        LoginCtrl.byBadLoginAddr[i] = 0;
    }


    LoginCtrl.byGraceLogins = LoginCtrl.byGraceLoginReset;

    //
    // Put default values into AccountBalance.
    //

    AccountBalance.lBalance = UserDefault.lBalance;
    AccountBalance.lCreditLimit = UserDefault.lCreditLimit;

    //
    // Write LOGIN_CONTROL property.
    //

    // BUGBUG

    hr = NWApiWriteProperty(
             pNwUserInfo->hConn,
             pNwUserInfo->lpszUserName,
             OT_USER,
             NW_PROP_LOGIN_CONTROL,
             (LPBYTE) &LoginCtrl
             );
    BAIL_ON_FAILURE(hr);

    //
    // Write ACCOUNT_BALANCE property.
    //

    hr = NWApiWriteProperty(
             pNwUserInfo->hConn,
             pNwUserInfo->lpszUserName,
             OT_USER,
             NW_PROP_ACCOUNT_BALANCE,
             (LPBYTE) &AccountBalance
             );
    BAIL_ON_FAILURE(hr);

error:

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreateGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreateGroup(
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials
    )
{
    HRESULT       hr = S_OK;
    NWCONN_HANDLE hConn = NULL;

    //
    // Open a handle to the bindery.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0],
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Create a group bindery object.
    //

    hr = NWApiCreateBinderyObject(
             hConn,
             pObjectInfo->ComponentArray[1],
             OT_USER_GROUP,
             BF_STATIC,
             BS_LOGGED_READ | BS_SUPER_WRITE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Create GROUP_MEMBERS property.
    //

    hr = NWApiCreateProperty(
             hConn,
             pObjectInfo->ComponentArray[1],
             OT_USER_GROUP,
             NW_PROP_GROUP_MEMBERS,
             BF_SET
             );
    BAIL_ON_FAILURE(hr);

error:

    NWApiReleaseBinderyHandle(hConn);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiDeleteGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiDeleteGroup(
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials
    )
{
    HRESULT       hr = S_OK;
    NWCONN_HANDLE hConn = NULL;

    //
    // Open a handle to the bindery.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0],
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Delete the group object.
    //

    hr = NWApiDeleteBinderyObject(
             hConn,
             pObjectInfo->ComponentArray[1],
             OT_USER_GROUP
             );
    BAIL_ON_FAILURE(hr);

error:

    NWApiReleaseBinderyHandle(hConn);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreatePrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreatePrinter(
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials
    )
{
    CHAR          szQueueName[OBJ_NAME_SIZE + 1];
    CHAR          szBuff1[OBJ_NAME_SIZE + 1];
    CHAR          szBuff2[OBJ_NAME_SIZE + 1];
    HRESULT       hr = S_OK;
    NWCCODE       ccode = SUCCESSFUL;
    NWCONN_HANDLE hConn = NULL;
    WCHAR         szTemp[MAX_PATH];

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        pObjectInfo->ComponentArray[1],
        szQueueName,
        0
        );

    strcpy(szBuff1, NW_PROP_Q_OPERATORS);
    strcpy(szBuff2, NW_PROP_SUPERVISOR);

    //
    // Open a handle to the bindery.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0],
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Create a print queue object.
    //

    hr = NWApiCreatePrintQueue(
             hConn,
             pObjectInfo->ComponentArray[1]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Change property security.
    //

    ccode = NWChangePropertySecurity(
                hConn,
                szQueueName,
                OT_PRINT_QUEUE,
                szBuff1,
                BS_LOGGED_READ | BS_SUPER_WRITE
                );
    hr = HRESULT_FROM_NWCCODE(ccode);
    BAIL_ON_FAILURE(hr);

    //
    // Add SUPERVISOR to Q_OPERATORS.
    //

      ccode = NWAddObjectToSet(
                  hConn,
                  szQueueName,
                  OT_PRINT_QUEUE,
                  szBuff1,
                  szBuff2,
                  OT_USER
                  );
    hr = HRESULT_FROM_NWCCODE(ccode);
    BAIL_ON_FAILURE(hr);

    //
    // Add EVERYONE to Q_USERS.
    //

    strcpy(szBuff1, NW_PROP_Q_USERS);
    strcpy(szBuff2, NW_PROP_EVERYONE);

      ccode = NWAddObjectToSet(
                  hConn,
                  szQueueName,
                  OT_PRINT_QUEUE,
                  szBuff1,
                  szBuff2,
                  OT_USER_GROUP
                  );
    hr = HRESULT_FROM_NWCCODE(ccode);
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

error:

    NWApiReleaseBinderyHandle(hConn);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiDeleteGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiDeletePrinter(
    POBJECTINFO pObjectInfo,
    CCredentials &Credentials
    )
{
    HRESULT       hr = S_OK;
    NWCONN_HANDLE hConn = NULL;
    NWOBJ_ID      dwQueueID = 0;

    //
    // Open a handle to the bindery.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0],
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get Queue ID.
    //

    hr = NWApiDestroyPrintQueue(
             hConn,
             pObjectInfo->ComponentArray[1]
             );
    BAIL_ON_FAILURE(hr);

error:

    NWApiReleaseBinderyHandle(hConn);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreatePrintQueue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreatePrintQueue(
    NWCONN_HANDLE hConn,
    LPWSTR lpszQueueName
    )
{
    CHAR    szQueueName[OBJ_NAME_SIZE + 1];
    CHAR    szPrinterPath[OBJ_NAME_SIZE + 1];
    DWORD   dwQueueID = 0;
    HRESULT hr = S_OK;
    NWCCODE ccode = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NW APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        lpszQueueName,
        szQueueName,
        0
        );

    strcpy(szPrinterPath, NW_PRINTER_PATH);

    //
    // Create a print queue object.
    //

      ccode = NWCreateQueue(
                  hConn,
                  szQueueName,
                  OT_PRINT_QUEUE,
                  NULL,
                  szPrinterPath,
                  &dwQueueID
                  );
    hr = HRESULT_FROM_NWCCODE(ccode);

    //
    // Return.
    //

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiDestroyPrintQueue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiDestroyPrintQueue(
    NWCONN_HANDLE hConn,
    LPWSTR lpszQueueName
    )
{
    DWORD   dwQueueID = 0;
    HRESULT hr = S_OK;
    NWCCODE ccode = SUCCESSFUL;

    //
    // Get Queue ID.
    //

    hr = NWApiGetObjectID(
             hConn,
             lpszQueueName,
             OT_PRINT_QUEUE,
             &dwQueueID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Destroy print queue.
    //

      ccode = NWDestroyQueue(
                  hConn,
                  dwSWAP(dwQueueID)
                  );
    hr = HRESULT_FROM_NWCCODE(ccode);

    //
    // Return.
    //

error:

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiMapNtStatusToDosError
//
//  Synopsis: This function maps the ntstatus that was returned from the NetWare
//            redirector to window errors. Similar to RtlNtStatusToDosError
//            except that the special handling is done to ntstatus with netware
//            facility codes.
//
//  Argument: NtStatus - The ntstatus returned from NetWare rdr
//
//  Return Value: WinError
//
//----------------------------------------------------------------------------
DWORD
NWApiMapNtStatusToDosError(
    IN NTSTATUS NtStatus
    )
{
    if ( (HIWORD( NtStatus) & FACILITY_NWRDR ) == FACILITY_NWRDR )
    {
        if ( NtStatus == NWRDR_PASSWORD_HAS_EXPIRED )
            return ERROR_PASSWORD_EXPIRED;
        else
            return NETWARE_GENERAL_ERROR;
    }
    else if ( HIWORD( NtStatus) == 0xC001 )
    {
        return LOWORD( NtStatus ) + NETWARE_ERROR_BASE;
    }

    return RtlNtStatusToDosError( NtStatus );
}

//----------------------------------------------------------------------------
//
//  Function: NWApiConvertToAddressFormat
//
//  Synopsis: Convert an IPX address obtain from NWApiGetProperty into the
//            format specified in spec.
//
//----------------------------------------------------------------------------
HRESULT
NWApiConvertToAddressFormat(
    LP_RPLY_SGMT_LST lpReplySegment,
    LPWSTR *lppszAddresses
    )
{
    int    i = 0;
    LPBYTE lpBuffer = NULL;
    LPWSTR lpszTemp = NULL;
    WORD   wSegment[NET_ADDRESS_WORD_SIZE];

    //
    // Put values from szReply into the wSegment array
    //

    lpBuffer = (LPBYTE) lpReplySegment->Segment;

    for (i = 0; i < NET_ADDRESS_WORD_SIZE; i++) {

        wSegment[i] = NWApiReverseWORD(*((LPWORD)lpBuffer + i));
    }

    //
    // Put address together in the format described in spec.
    //

    lpszTemp = (LPWSTR) AllocADsMem((NET_ADDRESS_NUM_CHAR+1)*sizeof(WCHAR));
    if (!lpszTemp) {
        RRETURN(E_OUTOFMEMORY);
    }

    wsprintf(
        lpszTemp,
        L"%s:%04X%04X.%04X%04X%04X.%04X",
        bstrAddressTypeString,
        wSegment[0],
        wSegment[1],
        wSegment[2],
        wSegment[3],
        wSegment[4],
        wSegment[5]
        );

    //
    // Return.
    //
    *lppszAddresses = lpszTemp;

    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiMakeSYSTEMTIME
//
//  Synopsis: This function creates a SYSTEMTIME.
//
//----------------------------------------------------------------------------
HRESULT
NWApiMakeSYSTEMTIME(
    LPSYSTEMTIME pTime,
    WORD wDay,         // Day = 1..31
    WORD wMonth,       // Month = 1..12
    WORD wYear,        // Year = (19XX or 20XX) - 1980, ie. 2019 -> 39
    WORD wSecond,      // Second = 0..30, Second divided by 2
    WORD wMinute,      // Minute = 0..59
    WORD wHour         // Hour = 0..23
    )
{
    BOOL       fBool = TRUE;
    WORD       wDOSDate = 0;
    WORD       wDOSTime = 0;
    FILETIME   FileTime;
    SYSTEMTIME SystemTime;


    //
    // Fix up parameters.
    // If wDay and wMonth are 0, turn them into one.
    //

    if (wDay == 0) {
        wDay++;
    }

    if (wMonth == 0) {
        wMonth++;
    }

    //
    // Shift data to correct bit as required by the DOS date & time format.
    //

    wMonth = wMonth << 5;
    wYear =  wYear << 9;
    wMinute = wMinute << 5;
    wHour = wHour << 11;

    //
    // Put them in DOS format.
    //

    wDOSDate = wYear | wMonth | wDay;
    wDOSTime = wHour | wMinute | wSecond;

    //
    // Convert into FileTime.
    //

    fBool = DosDateTimeToFileTime(
                wDOSDate,
                wDOSTime,
                &FileTime
                );

    if (fBool == TRUE)
    {
        //
        // Convert into SYSTEMTIME
        //

        fBool = FileTimeToSystemTime(&FileTime, &SystemTime);
    }

    //
    // Return.
    //

    if (fBool == TRUE) {

        *pTime = SystemTime;

        RRETURN(S_OK);
    }
    else {
        RRETURN(E_FAIL);
    }
}

//----------------------------------------------------------------------------
//
//  Function: NWApiMakeVariantTime
//
//  Synopsis: This function creates a double precision variant time.
//
//----------------------------------------------------------------------------
HRESULT
NWApiMakeVariantTime(
    DOUBLE * pdTime,
    WORD wDay,         // Day = 1..31
    WORD wMonth,       // Month = 1..12
    WORD wYear,        // Year = (19XX or 20XX) - 1980, ie. 2019 -> 39
    WORD wSecond,      // Second = 0..30, Second divided by 2
    WORD wMinute,      // Minute = 0..59
    WORD wHour         // Hour = 0..23
    )
{
    BOOL   fBool = TRUE;
    DOUBLE vTime = 0;
    WORD   wDOSDate = 0;
    WORD   wDOSTime = 0;

    //
    // Fix up parameters.
    // If wDay and wMonth are 0, turn them into one.
    //

    if (wDay == 0) {
        wDay++;
    }

    if (wMonth == 0) {
        wMonth++;
    }

    //
    // Shift data to correct bit as required by the DOS date & time format.
    //

    wMonth = wMonth << 5;
    wYear =  wYear << 9;
    wMinute = wMinute << 5;
    wHour = wHour << 11;

    //
    // Put them in DOS format.
    //

    wDOSDate = wYear | wMonth | wDay;
    wDOSTime = wHour | wMinute | wSecond;

    //
    // Convert into VariantTime.
    //

    fBool = DosDateTimeToVariantTime(
                wDOSDate,
                wDOSTime,
                &vTime
                );

    //
    // Return.
    //

    if (fBool == TRUE) {

        *pdTime = vTime;

        RRETURN(S_OK);
    }
    else {
        RRETURN(E_FAIL);
    }
}

//----------------------------------------------------------------------------
//
//  Function: NWApiBreakVariantTime
//
//  Synopsis: This function interprets a double precision variant time and
//            returns the day, month and year individually.
//
//----------------------------------------------------------------------------
HRESULT
NWApiBreakVariantTime(
    DOUBLE daDate,
    PWORD pwDay,
    PWORD pwMonth,
    PWORD pwYear
    )
{
    BOOL   fBool;
    DOUBLE vTime;
    WORD   wDOSDate = 0;
    WORD   wDOSTime = 0;
    WORD   wDay = 0;
    WORD   wMonth = 0;
    WORD   wYear = 0;

    //
    // Convert variant time into DOS format.
    //

    fBool = VariantTimeToDosDateTime(
                daDate,
                &wDOSDate,
                &wDOSTime
                );
    if (fBool == FALSE) {
        goto error;
    }

    //
    // Year: bits 9-15, add 80 to wYear because 80 was subtracted from it to
    // call VariantTimeToDosDateTime.
    //

    wYear = wDOSDate >> 9;
    wYear += 80;

    //
    // Month: bits 5-8.
    //

    wMonth = (wDOSDate >> 5) - (wYear << 4);

    //
    // Day: bits 0-4.
    //

    wDay = wDOSDate - (wMonth << 5) - (wYear << 9);

    //
    // Return.
    //

    *pwDay = wDay;
    *pwMonth = wMonth;
    *pwYear = wYear;

    RRETURN(S_OK);

error:

    RRETURN(E_FAIL);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiReverseWORD
//
//  Synopsis: This function reverse a WORD.
//
//----------------------------------------------------------------------------
WORD
NWApiReverseWORD(
    WORD wWORD
    )
{

    LPBYTE lpbTemp = (LPBYTE) &wWORD;
    BYTE bTemp;

    bTemp = *lpbTemp;
    *lpbTemp = *(lpbTemp + 1);
    *(lpbTemp + 1) = bTemp;

    return(*((LPWORD) lpbTemp));
}


//----------------------------------------------------------------------------
//
//  Function: NWApiUserGetGroups
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiUserGetGroups(
    NWCONN_HANDLE hConn,
    LPWSTR szUserName,
    LPBYTE *lppBuffer
    )
{
    DWORD   dwNumSegment = 0;
    HRESULT hr = S_OK;
    DWORD   i;
    LP_RPLY_SGMT_LST lpTemp = NULL;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;

    //
    // Assert
    //

    ADsAssert(*lppBuffer == NULL);

    //
    // Get GROUP_MEMBERS.
    //

    hr = NWApiGetProperty(
             szUserName,
             NW_PROP_USER_GROUPS,
             OT_USER,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );
    BAIL_ON_FAILURE(hr);

    //
    // Pack returned linked list into buffer.
    //

    *lppBuffer = (LPBYTE) AllocADsMem(
                           dwNumSegment * REPLY_VALUE_SIZE
                           );
    if (!(*lppBuffer)) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpTemp = lpReplySegment;

    for (i = 0; i < dwNumSegment; i++) {
        memcpy(
            *lppBuffer + i * REPLY_VALUE_SIZE,
            lpTemp->Segment,
            REPLY_VALUE_SIZE
            );
        lpTemp = lpTemp->lpNext;
    }

error:

    //
    // Clean up.
    //

    lpTemp = NULL;

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\nwres.h ===
#define NW_PROVIDER_ID    3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\nwmrshl.cxx ===
/+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       nwmrshl.cxx
//
//  Contents:
//
//  Functions:
//
//  History:      23-June-1996   KrishnaG Created.
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma  hdrstop

HRESULT
CopyNTOBJECTToDWORD(
    PNTOBJECT pNtSrcObject,
    PDWORD   pdwRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }
    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DWORD)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pdwRetval = (pNtSrcObject->NTValue).dwValue;

    RRETURN(S_OK);

}

HRESULT
CopyNTOBJECTToDATE(
    PNTOBJECT pNtSrcObject,
    PDWORD   pdwRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }
    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DATE)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pdwRetval = (pNtSrcObject->NTValue).dwValue;

    RRETURN(S_OK);

}



HRESULT
CopyNTOBJECTToNw312DATE(
    PNTOBJECT pNtSrcObject,
    PBYTE   pbyRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }
    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_NW312DATE)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }


    memcpy(pbyRetval,(pNtSrcObject->NTValue).Nw312Date, 6);

    RRETURN(S_OK);

}


HRESULT
CopyNTOBJECTToBOOL(
    PNTOBJECT pNtSrcObject,
    PBOOL   pfRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_BOOL)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pfRetval = (pNtSrcObject->NTValue).fValue;

    RRETURN(S_OK);

}


HRESULT
CopyNTOBJECTToSYSTEMTIME(
    PNTOBJECT pNtSrcObject,
    SYSTEMTIME *pstRetVal
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_SYSTEMTIME)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pstRetVal = (pNtSrcObject->NTValue).stSystemTimeValue;

    RRETURN(S_OK);

}

HRESULT
CopyNTOBJECTToLPTSTR(
    PNTOBJECT pNtSrcObject,
    LPTSTR  *ppszRetval
    )
{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_LPTSTR)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *ppszRetval = AllocADsStr((pNtSrcObject->NTValue).pszValue);

    if (! *ppszRetval && ((pNtSrcObject->NTValue).pszValue)) {
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(S_OK);

}


HRESULT
CopyNTOBJECTToOctet(
    PNTOBJECT pNtSrcObject,
    OctetString *pOctet
    )
{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_OCTETSTRING)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    pOctet->dwSize = (pNtSrcObject->NTValue).octetstring.dwSize;
    pOctet->pByte = (BYTE*)AllocADsMem(sizeof(BYTE) * (pNtSrcObject->NTValue).octetstring.dwSize);
    if (!pOctet->pByte) {
        RRETURN(E_OUTOFMEMORY);
    }
    memcpy(pOctet->pByte, 
           (pNtSrcObject->NTValue).octetstring.pByte, 
           (pNtSrcObject->NTValue).octetstring.dwSize);
    RRETURN(S_OK);

}


HRESULT
CopyNTOBJECTToDelimitedString(
    PNTOBJECT pNtSrcObject,
    LPTSTR  *ppszRetval
    )
{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DelimitedString)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    if ((pNtSrcObject->NTValue).pszValue == NULL){
        *ppszRetval = NULL;
    } else {
        *ppszRetval = AllocADsStr((pNtSrcObject->NTValue).pszValue);
    }

    if (! *ppszRetval && ((pNtSrcObject->NTValue).pszValue)) {
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(S_OK);
}


HRESULT
CopyNTOBJECTToNulledString(
    PNTOBJECT pNtSrcObject,
    LPTSTR  *ppszRetval
    )
{
    HRESULT hr = S_OK;

    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_NulledString)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = CopyNulledString((pNtSrcObject->NTValue).pszValue,
                          ppszRetval );

    if ( FAILED (hr)){
        RRETURN(hr);
    }
    RRETURN(S_OK);
}

HRESULT
CopyNTOBJECTToNT(
    DWORD dwSyntaxId,
    PNTOBJECT lpNTObject,
    LPBYTE lpByte
    )
{

    HRESULT hr = S_OK;

    switch (dwSyntaxId) {
    case NT_SYNTAX_ID_BOOL:
        hr = CopyNTOBJECTToBOOL(
                         lpNTObject,
                         (PBOOL)lpByte
                         );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = CopyNTOBJECTToSYSTEMTIME(
                         lpNTObject,
                         (PSYSTEMTIME)lpByte
                         );
        break;

    case NT_SYNTAX_ID_DWORD:
        hr = CopyNTOBJECTToDWORD(
                         lpNTObject,
                         (PDWORD)lpByte
                         );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = CopyNTOBJECTToDATE(
                         lpNTObject,
                         (PDWORD)lpByte
                         );
        break;

    case NT_SYNTAX_ID_NW312DATE:
        hr = CopyNTOBJECTToNw312DATE(
                         lpNTObject,
                         (LPBYTE)lpByte
                         );
        break;

    case NT_SYNTAX_ID_DelimitedString:
        hr = CopyNTOBJECTToDelimitedString(
                         lpNTObject,
                         (LPTSTR *)lpByte
                         );
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = CopyNTOBJECTToNulledString(
                         lpNTObject,
                         (LPTSTR *)lpByte
                         );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = CopyNTOBJECTToLPTSTR(
                         lpNTObject,
                         (LPTSTR *)lpByte
                         );
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = CopyNTOBJECTToOctet(
                         lpNTObject,
                         (OctetString *)lpByte
                         );
        break;

    default:
        break;

    }

    RRETURN(hr);
}


HRESULT
MarshallNTSynIdToNT(
    DWORD dwSyntaxId,
    PNTOBJECT pNTObject,
    DWORD dwNumValues,
    LPBYTE lpValue
    )
{

    HRESULT hr = S_OK;
    DWORD  i = 0;

    //
    // Loop below does not really handle case other than 1 value
    //

    for (i = 0; i < dwNumValues; i++) {

        hr  = CopyNTOBJECTToNT(
                         dwSyntaxId,
                         (pNTObject + i) ,
                         lpValue
                         );

    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\nwtypes.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nttypes.h
//
//  Contents:    Types for generic Get and Put
//
//  Functions:
//
//
//  History:      14-June-1996   RamV   Cloned off nds code.
//
//----------------------------------------------------------------------------

//
// various values of NT types
//

#define NT_SYNTAX_ID_BOOL                     1
#define NT_SYNTAX_ID_SYSTEMTIME               2
#define NT_SYNTAX_ID_DWORD                    3
#define NT_SYNTAX_ID_LPTSTR                   4
#define NT_SYNTAX_ID_DelimitedString          5
#define NT_SYNTAX_ID_NulledString             6
#define NT_SYNTAX_ID_DATE                     7 // internally treated as DWORD
#define NT_SYNTAX_ID_NW312DATE                8
#define NT_SYNTAX_ID_OCTETSTRING              9

typedef struct _octetstring {
    DWORD dwSize;
    BYTE *pByte;
} OctetString;

typedef struct _nttype{
    DWORD NTType;
    union {
        DWORD dwValue;
        LPTSTR pszValue;
        SYSTEMTIME stSystemTimeValue;
        BOOL       fValue;
        BYTE       Nw312Date[6];
        OctetString octetstring;
    }NTValue;

    //
    // for both Delimited and Nulled Strings we use pszValue
    //
}NTOBJECT, *PNTOBJECT, *LPNTOBJECT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\nwcopy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nwcopy.cxx
//
//  Contents:   Nw312 Object Copy Routines
//
//  Functions:
//
//  History:      17-June-96   KrishnaG   Created.
//                cloned off NDS copy code.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//
//
//----------------------------------------------------------------------------

//
// NtType objects copy code
//

#include "nwcompat.hxx"
#pragma  hdrstop


HRESULT
NtTypeCopy(
    PNTOBJECT lpNtSrcObject,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNtSrcObject->NTType) {

    case NT_SYNTAX_ID_BOOL:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_BOOL;
        (lpNtDestObject->NTValue).fValue =  (lpNtSrcObject->NTValue).fValue;
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_SYSTEMTIME;
        (lpNtDestObject->NTValue).stSystemTimeValue =
            (lpNtSrcObject->NTValue).stSystemTimeValue;
        break;

    case NT_SYNTAX_ID_DWORD:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DWORD;
        (lpNtDestObject->NTValue).dwValue =
            (lpNtSrcObject->NTValue).dwValue;
        break;

    case NT_SYNTAX_ID_DATE:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DATE;
        (lpNtDestObject->NTValue).dwValue =
            (lpNtSrcObject->NTValue).dwValue;
        break;

    case NT_SYNTAX_ID_NW312DATE:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_NW312DATE;
        memcpy(
            (lpNtDestObject->NTValue).Nw312Date,
            (lpNtSrcObject->NTValue).Nw312Date,
            6
            );
        break;


    case NT_SYNTAX_ID_LPTSTR:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_LPTSTR;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }

        (lpNtDestObject->NTValue).pszValue =
            AllocADsStr((lpNtSrcObject->NTValue).pszValue);

        hr =((lpNtDestObject->NTValue).pszValue == NULL)
            ? E_OUTOFMEMORY :S_OK;

        break;

    case NT_SYNTAX_ID_OCTETSTRING:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_OCTETSTRING;
        (lpNtDestObject->NTValue).octetstring.dwSize = 
			(lpNtSrcObject->NTValue).octetstring.dwSize;
		if ((lpNtSrcObject->NTValue).octetstring.dwSize == 0) {
			(lpNtDestObject->NTValue).octetstring.pByte = NULL;
		}
		else {
			(lpNtDestObject->NTValue).octetstring.pByte = 
					(BYTE*)AllocADsMem(sizeof(BYTE)*(lpNtSrcObject->NTValue).octetstring.dwSize);
			if (!(lpNtDestObject->NTValue).octetstring.pByte) {
				RRETURN(E_OUTOFMEMORY);
			}
			memcpy((lpNtDestObject->NTValue).octetstring.pByte, 
				   (lpNtSrcObject->NTValue).octetstring.pByte,
				   (lpNtSrcObject->NTValue).octetstring.dwSize);
		}

        break;

    case NT_SYNTAX_ID_DelimitedString:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DelimitedString;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }

        (lpNtDestObject->NTValue).pszValue =
            AllocADsStr((lpNtSrcObject->NTValue).pszValue);

        hr =((lpNtDestObject->NTValue).pszValue == NULL)
            ? E_OUTOFMEMORY :S_OK;

        break;

    case NT_SYNTAX_ID_NulledString:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_NulledString;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }

        hr = CopyNulledString((lpNtSrcObject->NTValue).pszValue,
                              &(lpNtDestObject->NTValue).pszValue );

        BAIL_ON_FAILURE(hr);

        break;

    default:
        hr = E_FAIL;
        break;
    }

error:
    RRETURN(hr);
}



HRESULT
NtTypeCopyConstruct(
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumObjects,
    LPNTOBJECT * ppNtDestObjects
    )
{

    DWORD i = 0;
    LPNTOBJECT pNtDestObjects = NULL;
    HRESULT hr = S_OK;

    pNtDestObjects = (LPNTOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NTOBJECT)
                                    );

    if (!pNtDestObjects) {
        RRETURN(E_FAIL);
    }

    //
    // Zero out so we can clear the memory on an error
    //

    memset(pNtDestObjects, 0, dwNumObjects * sizeof(NTOBJECT));

    for (i = 0; i < dwNumObjects; i++ ) {
        hr = NtTypeCopy(pNtSrcObjects + i, pNtDestObjects + i);
        BAIL_ON_FAILURE(hr);
    }

    *ppNtDestObjects = pNtDestObjects;

    RRETURN(S_OK);

error:
    //
    // pNtDestObjects is assumed to be non-NULL
    //
    NTTypeFreeNTObjects(pNtDestObjects, dwNumObjects);
    RRETURN(hr);
}


HRESULT
CopyNulledString(
    LPTSTR pszSrcString,
    LPTSTR *ppszDestString
    )

{
    HRESULT hr = S_OK;
    LPTSTR pszPosition = pszSrcString;
    DWORD dwLength = 0 ;
    DWORD dwCurrLen = 0;
    BOOL foundNULL  = FALSE;
    DWORD i;

    ADsAssert(ppszDestString);
    *ppszDestString = NULL;

    if (!pszSrcString)
        RRETURN(S_OK);

    //
    // scan source string looking for 2 successive NULLS
    //

    if(*pszPosition == TEXT('\0')) {
        pszPosition++;
        dwLength++;
    }

    while(*pszPosition != TEXT('\0')){
        dwCurrLen = wcslen(pszPosition) +1;
        dwLength += dwCurrLen;
        pszPosition += dwCurrLen;
    }
    dwLength++;

    *ppszDestString = (LPTSTR)AllocADsMem (dwLength * sizeof(TCHAR));

    if ( !*ppszDestString){
        RRETURN(E_OUTOFMEMORY);
    }

    // copy one character at a time

    for ( i=0; i<dwLength; i++){
        (*ppszDestString)[i] = pszSrcString[i] ;
    }

    RRETURN (hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\nwutils.cxx ===
#include "nwcompat.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: NWApiGetBinderyHandle
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetBinderyHandle(
    NWCONN_HANDLE *phConnReturned,
    BSTR bstrBinderyName,
    CCredentials &Credentials
    )
{
    CHAR    szBinderyName[OBJ_NAME_SIZE + 1];
    NWLOCAL_SCOPE ScopeFlag = 0;
    NWCONN_HANDLE hConn = NULL;
    NWCCODE       ccode = SUCCESSFUL;
    HRESULT       hr = S_OK;

    PNWC_CONTEXT pNWCContext = NULL;
    LPWSTR       pszUserName = NULL, pszPassword = NULL;
    BOOL         fLoggedIn = FALSE;

    //
    // Try the cache for the passed in credentials.
    //

    ENTER_BIND_CRITSECT() ;
    if (pNWCContext = BindCacheLookup(bstrBinderyName, Credentials)) {
         *phConnReturned = pNWCContext->hConn;
         LEAVE_BIND_CRITSECT() ;
         return S_OK;
    }

    //
    // Entry not found in the cache, need to allocate a new one.
    //

    hr = BindCacheAllocEntry(&pNWCContext);
    if (FAILED(hr)) {
        LEAVE_BIND_CRITSECT() ;
        RRETURN(hr);
    }

    UnicodeToAnsiString(
        bstrBinderyName,
        szBinderyName,
        0
        );


    hr = Credentials.GetUserName(&pszUserName);
    BAIL_ON_FAILURE(hr);
    hr = Credentials.GetPassword(&pszPassword);
    BAIL_ON_FAILURE(hr);

    if (pszUserName)
    {
        hr = NWApiCheckUserLoggedInToServer(bstrBinderyName, pszUserName);
        BAIL_ON_FAILURE(hr);

        if (hr == S_FALSE)
        {
            // Log in the user
            NETRESOURCE netResource;
            DWORD dwStatus;

            netResource.dwType = RESOURCETYPE_ANY;
            netResource.lpLocalName = NULL;
            netResource.lpRemoteName = (PWSTR) bstrBinderyName;
            netResource.lpProvider = NULL;
                        
            dwStatus = WNetAddConnection2(
                &netResource,
                pszPassword ? pszPassword : L"",
                pszUserName,
                0   // don't make a persistent connection
                );


            hr = HRESULT_FROM_WIN32(dwStatus);
            BAIL_ON_FAILURE(hr);
            
            fLoggedIn = TRUE;
        }
    }

    ccode = NWCCOpenConnByName(      
                0,
                szBinderyName, 
                NWCC_NAME_FORMAT_BIND,
                NWCC_OPEN_UNLICENSED, 
                NWCC_TRAN_TYPE_WILD,
                &hConn
                );
    hr = HRESULT_FROM_NWCCODE(ccode);
    BAIL_ON_FAILURE(hr);

    pNWCContext->hConn = hConn;

    hr = BindCacheAdd(bstrBinderyName, Credentials, fLoggedIn, pNWCContext) ;
    BAIL_ON_FAILURE(hr);

    *phConnReturned = hConn;

    FreeADsStr(pszUserName);
    FreeADsStr(pszPassword);

    LEAVE_BIND_CRITSECT();

    RRETURN(hr);

error:
    *phConnReturned = NULL;

    if (hConn) {
        NWCCCloseConn(hConn);
    }

    if (fLoggedIn) {
        // log out
        WNetCancelConnection2((LPWSTR)szBinderyName, 0, FALSE);
    }

    if (pNWCContext) {
        BindCacheFreeEntry(pNWCContext);
    }

    FreeADsStr(pszUserName);
    FreeADsStr(pszPassword);

    LEAVE_BIND_CRITSECT();
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiReleaseBinderyHandle
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiReleaseBinderyHandle(
    NWCONN_HANDLE hConn
    )
{
    HRESULT hr = S_OK;
    NWCCODE ccode = SUCCESSFUL;
    PNWC_CONTEXT pNWCContext = NULL;
    DWORD dwStatus;

    // note that if lookup succeeds, it add-refs the context, so we have
    // to deref twice below: once for the ref we just added, and once
    // for our caller's ref that they're trying to release
    pNWCContext = BindCacheLookupByConn(hConn);

    if (!pNWCContext)
        RRETURN(E_FAIL);

    if (BindCacheDeref(pNWCContext) && (BindCacheDeref(pNWCContext) == 0)) {

        // ref count has dropped to zero and it's gone from cache

        ccode = NWCCCloseConn(hConn);
        hr = HRESULT_FROM_NWCCODE(ccode);
        BAIL_ON_FAILURE(hr);

        if (pNWCContext->fLoggedIn) {
            // logout
            dwStatus = WNetCancelConnection2(
                pNWCContext->pszBinderyName,
                0,
                FALSE);

            hr = HRESULT_FROM_WIN32(dwStatus);
            BAIL_ON_FAILURE(hr);
        }

        BindCacheFreeEntry(pNWCContext);
    }

    RRETURN(hr);

error:
    // N.B.: If we're here, we must have bailed from inside of
    // the BindCacheDeref block, and so pNWCContext must have
    // been removed from the cache.  Thus, it's safe to free
    // it (and not to do so would cause a leak).
    BindCacheFreeEntry(pNWCContext);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiIsUserLoggedInToServer
//
//  Synopsis: Returns S_OK if pszUserName is logged in to bstrBinderyName,
//            S_FALSE if she isn't
//
//----------------------------------------------------------------------------
HRESULT
NWApiCheckUserLoggedInToServer(
    BSTR   bstrBinderyName,
    LPWSTR pszUserName
    )
{
    DWORD err;
    HRESULT hr;

    WCHAR pszUser[NW_USER_SIZE+1];
    DWORD dwUserLength = NW_USER_SIZE+1;
    
    err = WNetGetUser(bstrBinderyName, pszUser, &dwUserLength);
    
    switch(err)
    {
    case NO_ERROR:
        if (_wcsicmp(pszUser, pszUserName) == 0)
            hr = S_OK;
        else
            hr = S_FALSE;

        break;

    case ERROR_NOT_CONNECTED:
        hr = S_FALSE;
        break;

    default:
        hr = HRESULT_FROM_WIN32(err);
    }

    return hr;

}


//----------------------------------------------------------------------------
//
//  Function: NWApiWriteProperty
//
//  Synopsis: This function modifies values of a bindery property.  For now, it
//            only accept one buffer segment.  However, one segment is enough
//            for most practical purpose.  If the bindery property does not
//            exist, the function will attempt to create the property.
//
//----------------------------------------------------------------------------
HRESULT
NWApiWriteProperty(
    NWCONN_HANDLE hConn,
    BSTR bstrObjectName,
    NWOBJ_TYPE wObjType,
    LPSTR lpszPropertyName,
    LPBYTE SegmentData
    )
{
    CHAR    szObjectName[OBJ_NAME_SIZE + 1];
    CHAR    szPropertyName[OBJ_NAME_SIZE + 1];
    HRESULT hr = S_OK;
    NWCCODE ccode;

    //
    // Convert BSTR into an ANSI representation required by NW APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        bstrObjectName,
        szObjectName,
        0
        );

    strcpy(szPropertyName, lpszPropertyName);

    ccode = NWWritePropertyValue(
                hConn,
                szObjectName,
                wObjType,
                szPropertyName,
                1,                   // "1" for one segment.
                SegmentData,
                0                    // "0" for no more segment.
                );
    //
    // Create the property if it doesn't exist and attempt to write again.
    //

    if (ccode == NO_SUCH_PROPERTY) {

        hr = NWApiCreateProperty(
                 hConn,
                 bstrObjectName,
                 wObjType,
                 lpszPropertyName,
                 BF_ITEM
                 );
        BAIL_ON_FAILURE(hr);

        ccode = NWWritePropertyValue(
                    hConn,
                    szObjectName,
                    wObjType,
                    szPropertyName,
                    1,                   // "1" for one segment.
                    SegmentData,
                    0                    // "0" for no more segment.
                    );
    }

    hr = HRESULT_FROM_NWCCODE(ccode);

error:

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiObjectEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiObjectEnum(
    NWCONN_HANDLE hConn,
    NWOBJ_TYPE dwObjType,
    LPWSTR *lppszObjectName,
    DWORD  *pdwResumeObjectID
    )
{
    HRESULT       hr = S_OK;
    LPWSTR        lpszTemp = NULL;
    NWCCODE       ccode = SUCCESSFUL;
    NWOBJ_TYPE    pdwObjType = 0xFFFF;
    NWFLAGS       pucHasProperties;
    NWFLAGS       pucObjectFlags;
    NWFLAGS       pucObjSecurity;
    CHAR          szObjectName[OBJ_NAME_SIZE + 1];

    nstr8         searchObjectName[48] = "*";

    //
    // This call will fail and return 0xffff if the user is not authenticated
    // on the server to which the hConn handle is attached to.
    //

    ccode = NWScanObject(
                hConn,
                searchObjectName,    
                dwObjType,
                pdwResumeObjectID,
                szObjectName,
                &pdwObjType,
                &pucHasProperties,
                &pucObjectFlags,
                &pucObjSecurity
                );
    hr = HRESULT_FROM_NWCCODE(ccode);
    BAIL_ON_FAILURE(hr);

    lpszTemp = AllocateUnicodeString(szObjectName);
    if (!lpszTemp) {
       RRETURN(S_FALSE);
    }

    *lppszObjectName = AllocADsStr(lpszTemp);
    if (!(*lppszObjectName)) {
        RRETURN(S_FALSE);
    }

    if(lpszTemp){
        FreeUnicodeString(lpszTemp);
    }

    RRETURN(hr);

error:
    *lppszObjectName = NULL;
    pdwResumeObjectID = NULL;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiValidateObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiValidateObject(
    NWCONN_HANDLE hConn,
    NWOBJ_TYPE dwObjType,
    LPWSTR lpszObjectName,
    DWORD  *pdwResumeObjectID
    )
{
    HRESULT       hr = S_OK;
    NWCCODE       ccode = SUCCESSFUL;
    CHAR          szAnsiObjectName[OBJ_NAME_SIZE + 1];
    CHAR          szObjectName[OBJ_NAME_SIZE + 1];
    NWOBJ_TYPE    pdwObjType = 0xFFFF;
    NWFLAGS       pucHasProperties;
    NWFLAGS       pucObjectFlags;
    NWFLAGS       pucObjSecurity;

    //
    // Convert BSTR into an ANSI representation required by NW APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    //
    // This call will fail and return 0xffff if the user is not authenticated
    // on the server to which the hConn handle is attached to.
    //

    ccode = NWScanObject(
                hConn,
                szAnsiObjectName,
                dwObjType,
                pdwResumeObjectID,
                szObjectName,
                &pdwObjType,
                &pucHasProperties,
                &pucObjectFlags,
                &pucObjSecurity
                );

    hr = HRESULT_FROM_NWCCODE(ccode);

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGetAnyBinderyHandle
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetAnyBinderyHandle(
    NWCONN_HANDLE *phConn
    )
{
    HRESULT hr = S_OK;
    NWCCODE ccode = 0;
    nchar aServerName[OBJ_NAME_SIZE+1]; 

    nuint32       connRef = 0;

    ccode = NWCCGetPrimConnRef(
                &connRef
                );
    hr = HRESULT_FROM_NWCCODE(ccode);
    BAIL_ON_FAILURE(hr);
 
    ccode = NWCCOpenConnByRef(
                connRef,
                NWCC_OPEN_UNLICENSED,
                NWCC_RESERVED,
                phConn
                );
    hr = HRESULT_FROM_NWCCODE(ccode);

error: 

    RRETURN(hr);

}


//----------------------------------------------------------------------------
//
//  Function: NWApiGetObjectName
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetObjectName(
    NWCONN_HANDLE hConn,
    DWORD dwObjectID,
    LPWSTR *lppszObjectName
    )
{
    CHAR       szObjectName[OBJ_NAME_SIZE + 1];
    HRESULT    hr = S_OK;
    LPWSTR     lpszTemp = NULL;
    NWCCODE    ccode = SUCCESSFUL;
    NWOBJ_TYPE dwObjType;

    ccode = NWGetObjectName(
                hConn,
                dwObjectID,
                szObjectName,
                &dwObjType
                );
    hr = HRESULT_FROM_NWCCODE(ccode);
    BAIL_ON_FAILURE(hr);


    lpszTemp = AllocateUnicodeString(szObjectName);
    if (!lpszTemp) {
       RRETURN(S_FALSE);
    }

    *lppszObjectName = AllocADsStr(lpszTemp);
    if (!(*lppszObjectName)) {
        RRETURN(S_FALSE);
    }

    FreeUnicodeString(lpszTemp);

    RRETURN(hr);

error:
    *lppszObjectName = NULL;

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: HRESULT_FROM_NWCCODE
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
HRESULT_FROM_NWCCODE(
    NWCCODE ccode
    )
{
    HRESULT hr = S_OK;

    if (ccode == NO_SUCH_PROPERTY)
    {
        hr = E_ADS_PROPERTY_NOT_FOUND;
    }
    else if (ccode != SUCCESSFUL) {

        hr = HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR);
    }

    RRETURN(hr);
}



//----------------------------------------------------------------------------
//
//  Function: NWApiOpenPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiOpenPrinter(
    LPWSTR lpszUncPrinterName,
    HANDLE *phPrinter,
    DWORD  dwAccess
    )
{
    BOOL    fStatus = TRUE;
    HANDLE  hPrinter;
    HRESULT hr = S_OK;
    PRINTER_DEFAULTS PrinterDefault = {0, 0, dwAccess};

    //
    // Set desired access right.
    //

    PrinterDefault.DesiredAccess = dwAccess;

    //
    // Get a handle to the speccified printer using Win32 API.
    //

    fStatus = OpenPrinter(
                  lpszUncPrinterName,
                  &hPrinter,
                  &PrinterDefault
                  );

    //
    // Convert error code into HRESULT.
    //

    if (fStatus == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Return.
    //

    else {
        *phPrinter = hPrinter;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiClosePrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiClosePrinter(
    HANDLE hPrinter
    )
{
    BOOL fStatus = TRUE;
    HRESULT hr = S_OK;

    //
    // Close a printer using Win32 API.
    //

    fStatus = ClosePrinter(hPrinter);

    //
    // Convert error code into HRESULT.
    //

    if (fStatus == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Return.
    //

    RRETURN(hr);
}

/* BUGBUG
//----------------------------------------------------------------------------
//
//  Function: NWApiEnumJobs
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiEnumJobs(
    HANDLE hPrinter,
    DWORD dwFirstJob,
    DWORD dwNoJobs,
    DWORD dwLevel,
    LPBYTE *lplpbJobs,
    DWORD *pcbBuf,
    LPDWORD lpdwReturned
    )
{
    BOOL    fStatus = TRUE;
    HRESULT hr = S_OK;

    fStatus = WinNTEnumJobs(
                  hPrinter,
                  dwFirstJob,
                  dwNoJobs,
                  dwLevel,
                  lplpbJobs,
                  pcbBuf,
                  lpdwReturned
                  );

    if (fStatus == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiGetPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE *lplpbPrinters
    )
{
    BOOL    fStatus = TRUE;
    HRESULT hr = S_OK;

    fStatus = WinNTGetPrinter(
                  hPrinter,
                  dwLevel,
                  lplpbPrinters
                  );

    if (fStatus == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

*/


//----------------------------------------------------------------------------
//
//  Function: NWApiSetPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiSetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE lpbPrinters,
    DWORD  dwAccess
    )
{
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;

    fStatus = SetPrinter(
                  hPrinter,
                  dwLevel,
                  lpbPrinters,
                  dwAccess
                  );
    if (!fStatus) {
        goto error;
    }

    RRETURN(S_OK);

error:

    hr = HRESULT_FROM_WIN32(GetLastError());

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGetJob
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetJob(
    HANDLE hPrinter,
    DWORD dwJobId,
    DWORD dwLevel,
    LPBYTE *lplpbJobs
    )
{
    BOOL  fStatus = FALSE;
    DWORD dwError = 0;
    DWORD dwNeeded = 0;
    DWORD dwPassed = 1024;
    LPBYTE pMem = NULL;

    //
    // Allocate memory for return buffer.
    //

    pMem = (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        RRETURN(E_OUTOFMEMORY);
    }

    //
    // Get Job's information.
    //

    fStatus = GetJob(
                  hPrinter,
                  dwJobId,
                  dwLevel,
                  pMem,
                  dwPassed,
                  &dwNeeded
                  );

    //
    // Get job's information again with a bigger buffer if a bigger buffer is
    // needed for the result.
    //

    if (!fStatus) {

        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            RRETURN(HRESULT_FROM_WIN32(dwError));
        }

        if (pMem){
            FreeADsMem(pMem);
        }

        pMem = (LPBYTE)AllocADsMem(
                           dwNeeded
                           );

        if (!pMem) {
            RRETURN(E_OUTOFMEMORY);
        }

        dwPassed = dwNeeded;

        fStatus = GetJob(
                      hPrinter,
                      dwJobId,
                      dwLevel,
                      pMem,
                      dwPassed,
                      &dwNeeded
                      );

        if (!fStatus) {
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    //
    // Return.
    //

    *lplpbJobs = pMem;

    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiSetJob
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiSetJob(
    HANDLE hPrinter,
    DWORD  dwJobId,
    DWORD  dwLevel,
    LPBYTE lpbJobs,
    DWORD  dwCommand
    )
{
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;

    fStatus = SetJob(
                  hPrinter,
                  dwJobId,
                  dwLevel,
                  lpbJobs,
                  dwCommand
                  );
    if (!fStatus) {
        goto error;
    }

    RRETURN(S_OK);

error:

    hr = HRESULT_FROM_WIN32(GetLastError());

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiCreateProperty
//
//  Synopsis: This function creates a bindery property.  Access is logged read,
//            supervisor write.
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreateProperty(
    NWCONN_HANDLE hConn,
    LPWSTR lpszObjectName,
    NWOBJ_TYPE wObjType,
    LPSTR lpszPropertyName,
    NWFLAGS ucObjectFlags
    )
{
    CHAR    szAnsiObjectName[OBJ_NAME_SIZE + 1];
    CHAR    szPropertyName[OBJ_NAME_SIZE + 1];
    HRESULT hr = S_OK;
    NWCCODE ccode = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NW APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    strcpy(szPropertyName, lpszPropertyName);

    //
    // Create property.
    //

    ccode = NWCreateProperty(
                hConn,
                szAnsiObjectName,
                wObjType,
                szPropertyName,
                ucObjectFlags,
                BS_LOGGED_READ | BS_SUPER_WRITE
                );
    //
    // Return.
    //

    hr = HRESULT_FROM_NWCCODE(ccode);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\ods2nw.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ods2nw.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop



HRESULT
AdsTypeToNTTypeCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNtDestObject->NTType = NT_SYNTAX_ID_LPTSTR;

    lpNtDestObject->NTValue.pszValue =
                        AllocADsStr(
                            lpAdsSrcValue->CaseIgnoreString
                        );

    RRETURN(hr);

}


HRESULT
AdsTypeToNTTypeCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNtDestObject->NTType = NT_SYNTAX_ID_BOOL;

    lpNtDestObject->NTValue.fValue =
                        lpAdsSrcValue->Boolean;

    RRETURN(hr);
}


HRESULT
AdsTypeToNTTypeCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNtDestObject->NTType = NT_SYNTAX_ID_DWORD;

    lpNtDestObject->NTValue.dwValue =
                                lpAdsSrcValue->Integer;

    RRETURN(hr);
}

HRESULT
AdsTypeToNTTypeCopy(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_CASE_IGNORE_STRING:
        hr = AdsTypeToNTTypeCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpNtDestObject
                );
        break;

    case ADSTYPE_BOOLEAN:
        hr = AdsTypeToNTTypeCopyBoolean(
                lpAdsSrcValue,
                lpNtDestObject
                );
        break;

    case ADSTYPE_INTEGER:
        hr = AdsTypeToNTTypeCopyInteger(
                lpAdsSrcValue,
                lpNtDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
AdsTypeToNTTypeCopyConstruct(
    LPADSVALUE pAdsSrcValues,
    DWORD dwNumObjects,
    LPNTOBJECT * ppNtDestObjects,
    PDWORD pdwNumNdsObjects,
    PDWORD pdwNdsSyntaxId
    )
{

    DWORD i = 0;
    LPNTOBJECT pNtDestObjects = NULL;
    HRESULT hr = S_OK;

    pNtDestObjects = (LPNTOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NTOBJECT)
                                    );

    if (!pNtDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = AdsTypeToNTTypeCopy(
                    pAdsSrcValues + i,
                    pNtDestObjects + i
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppNtDestObjects = pNtDestObjects;
     *pdwNumNdsObjects = dwNumObjects;
     *pdwNdsSyntaxId = pNtDestObjects->NTType;
     RRETURN(S_OK);

error:

     if (pNtDestObjects) {

        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumObjects
                );
     }

     *ppNtDestObjects = NULL;
     *pdwNumNdsObjects = 0;

     RRETURN(hr);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\object.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  object.cxx
//
//  Contents:
//
//  History:
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma hdrstop

HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    );

HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    );


ObjectTypeList::ObjectTypeList()
{
    _pObjList = NULL;
    _dwCurrentIndex = 0;
    _dwMaxElements = 0;
    _dwUBound  = 0;
    _dwLBound = 0;

}


HRESULT
ObjectTypeList::CreateObjectTypeList(
    VARIANT vFilter,
    ObjectTypeList ** ppObjectTypeList
    )
{
    ObjectTypeList * pObjectTypeList = NULL;
    HRESULT hr = S_OK;

    pObjectTypeList = new ObjectTypeList;

    if (!pObjectTypeList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildObjectArray(
            vFilter,
            &pObjectTypeList->_pObjList,
            &pObjectTypeList->_dwMaxElements
            );

    if (FAILED(hr)) {

        hr = BuildDefaultObjectArray(
                gpFilters,
                gdwMaxFilters,
                &pObjectTypeList->_pObjList,
                &pObjectTypeList->_dwMaxElements
                );

        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetUBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetLBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwLBound
                );
    BAIL_ON_FAILURE(hr);

    pObjectTypeList->_dwCurrentIndex = pObjectTypeList->_dwLBound;

    *ppObjectTypeList = pObjectTypeList;

    RRETURN(S_OK);


error:
    if (pObjectTypeList) {
        delete pObjectTypeList;
    }
    RRETURN(hr);

}


ObjectTypeList::~ObjectTypeList()
{
    HRESULT hr = S_OK;
    if (_pObjList) {
        hr = SafeArrayDestroy(_pObjList);
    }
}


HRESULT
ObjectTypeList::GetCurrentObject(
    PDWORD pdwObject
    )
{
    HRESULT hr = S_OK;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    hr = SafeArrayGetElement(
                    _pObjList,
                    (long FAR *)&_dwCurrentIndex,
                    (void *)pdwObject
                    );
    RRETURN(hr);
}

HRESULT
ObjectTypeList::Next()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex++;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    return(hr);
}



HRESULT
ObjectTypeList::Reset()
{
    HRESULT hr = S_OK;

    return(hr);

}


HRESULT
IsValidFilter(
    LPWSTR ObjectName,
    DWORD *pdwFilterId,
    PFILTERS pFilters,
    DWORD dwMaxFilters
    )
{

    DWORD i = 0;

    for (i = 0; i < dwMaxFilters; i++) {

        if (!_wcsicmp(ObjectName, (pFilters + i)->szObjectName)) {
            *pdwFilterId = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }

    }
    *pdwFilterId = 0;
    RRETURN(E_FAIL);
}



HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    DWORD i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;

    sabNewArray.cElements = dwMaxFilters;
    sabNewArray.lLbound =  0;

    pFilter =   SafeArrayCreate(
                        VT_I4,
                        1,
                        &sabNewArray
                        );
    if (!pFilter){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwMaxFilters; i++) {

        hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&((pFilters + i)->dwFilterId)
            );
        BAIL_ON_FAILURE(hr);
    }

    *ppFilter = pFilter;
    *pdwNumElements = dwMaxFilters;

    RRETURN(S_OK);

error:
    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}



HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    VARIANT varDest;
    LONG i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    DWORD dwFilterId;
    SAFEARRAY * pFilter = NULL;

    if (!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    sabNewArray.cElements = dwSUBound - dwSLBound + 1;
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_I4,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }


        hr = IsValidFilter(
                V_BSTR(&v),
                &dwFilterId,
                gpFilters,
                gdwMaxFilters
                );

        if (FAILED(hr)) {

            VariantClear(&v);
            continue;
        }

        VariantClear(&v);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&uDestCount,
                (void *)&dwFilterId
                );

        if(FAILED(hr)){
            continue;
        }

        uDestCount++;

    }

    //
    // There was nothing of value that could be retrieved from the
    // filter and vFilter do not contain entries, that means no filter is
    // being set. Hence, we return err in this case so that we build the
    // default array.
    //

    if ( !uDestCount && (( dwSUBound - dwSLBound + 1 ) == 0 )) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    *pdwNumElements  = uDestCount;
    *ppFilter = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {

        SafeArrayDestroy(pFilter);
    }
    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\nwumrshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nwumrshl.cxx
//
//  Contents:
//
//  Functions:
//
//
//  History:      17-June-1996   KrishnaG   Cloned off NDS.
//
//
//  Notes :
//
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma  hdrstop

HRESULT
NTTypeInit(
    PNTOBJECT pNtType
    )
{
    memset(pNtType, 0, sizeof(NTOBJECT));

    RRETURN(S_OK);
}


HRESULT
NTTypeClear(
    PNTOBJECT pNtObject
    )
{
    if(!pNtObject)
        RRETURN(S_OK);

    switch (pNtObject->NTType) {
    case NT_SYNTAX_ID_LPTSTR:
    case NT_SYNTAX_ID_DelimitedString:
        FreeADsStr((pNtObject->NTValue).pszValue);
        break;
    case NT_SYNTAX_ID_NulledString:
        FreeADsMem((pNtObject->NTValue).pszValue);
        break;
    case NT_SYNTAX_ID_OCTETSTRING:
        FreeADsMem((pNtObject->NTValue).octetstring.pByte);
        break;
    default:
        break;
    }
    RRETURN(S_OK);
}


void
NTTypeFreeNTObjects(
    PNTOBJECT pNtObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumValues; i++ ) {
         NTTypeClear(pNtObject + i);
    }

    FreeADsMem(pNtObject);

    return;
}


HRESULT
CopyDWORDToNTOBJECT(
    PDWORD pdwSrcValue,
    PNTOBJECT lpNtDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpNtDestValue){
        RRETURN(E_POINTER);
    }

    lpNtDestValue->NTType = NT_SYNTAX_ID_DWORD;
    (lpNtDestValue->NTValue).dwValue = *pdwSrcValue;

    RRETURN(hr);

}

HRESULT
CopyDATEToNTOBJECT(
    PDWORD pdwSrcValue,
    PNTOBJECT lpNtDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpNtDestValue){
        RRETURN(E_POINTER);
    }

    lpNtDestValue->NTType = NT_SYNTAX_ID_DATE;
    (lpNtDestValue->NTValue).dwValue = *pdwSrcValue;

    RRETURN(hr);

}


HRESULT
CopyNw312DATEToNTOBJECT(
    PBYTE pbyDateTime,
    PNTOBJECT lpNtDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpNtDestValue){
        RRETURN(E_POINTER);
    }

    lpNtDestValue->NTType = NT_SYNTAX_ID_NW312DATE;
    memcpy((lpNtDestValue->NTValue).Nw312Date, pbyDateTime, 6);

    RRETURN(hr);

}






HRESULT
CopyBOOLToNTOBJECT(
    PBOOL pfSrcValue,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }


    lpNtObject->NTType = NT_SYNTAX_ID_BOOL;

    (lpNtObject->NTValue).fValue = *pfSrcValue;

    RRETURN(S_OK);

}


HRESULT
CopySYSTEMTIMEToNTOBJECT(
    PSYSTEMTIME pSysTime,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    (lpNtObject->NTValue).stSystemTimeValue = *pSysTime;
    lpNtObject->NTType = NT_SYNTAX_ID_SYSTEMTIME;

    RRETURN(S_OK);
}

HRESULT
CopyLPTSTRToNTOBJECT(
    LPTSTR   pszSrcValue,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    lpNtObject->NTType = NT_SYNTAX_ID_LPTSTR;

    if(!pszSrcValue){
        (lpNtObject->NTValue). pszValue = NULL;
    } else {

        (lpNtObject->NTValue). pszValue = AllocADsStr(pszSrcValue);
        if (!((lpNtObject->NTValue). pszValue)){
            RRETURN(E_OUTOFMEMORY);
        }
    }

    RRETURN(S_OK);
}

HRESULT
CopyOctetToNTOBJECT(
    PBYTE   pOctetString,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    lpNtObject->NTType = NT_SYNTAX_ID_OCTETSTRING;

    if(!pOctetString){
        (lpNtObject->NTValue).octetstring.dwSize = 0;
        (lpNtObject->NTValue).octetstring.pByte = NULL;
    } else {
        OctetString *pOctString = (OctetString*)pOctetString;
        (lpNtObject->NTValue).octetstring.dwSize = pOctString->dwSize;
        (lpNtObject->NTValue).octetstring.pByte = (BYTE*)AllocADsMem(sizeof(BYTE)*pOctString->dwSize);
        if (!(lpNtObject->NTValue).octetstring.pByte) {
            RRETURN(E_OUTOFMEMORY);
        }
        memcpy((lpNtObject->NTValue).octetstring.pByte, pOctString->pByte,pOctString->dwSize);
    }

    RRETURN(S_OK);
}


//
// BUGBUG Need to add conversion routines for Nulled and Delimited Strings
//

HRESULT
CopyDelimitedStringToNTOBJECT(
    LPTSTR   pszSrcValue,
    PNTOBJECT lpNtObject
    )
{
    if(!pszSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    lpNtObject->NTType = NT_SYNTAX_ID_DelimitedString;
    (lpNtObject->NTValue). pszValue = AllocADsStr(pszSrcValue);

    if (!((lpNtObject->NTValue). pszValue)){
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(S_OK);
}

// BugBug the following is somewhat buggy

HRESULT
CopyNulledStringToNTOBJECT(
    LPTSTR   pszSrcValue,
    PNTOBJECT lpNtObject
    )
{
    HRESULT hr = S_OK;

    if(!pszSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    lpNtObject->NTType = NT_SYNTAX_ID_NulledString;

    hr = CopyNulledString (pszSrcValue,
                           &((lpNtObject->NTValue). pszValue) );

    if (FAILED(hr)){
        RRETURN(hr);
    }
    RRETURN(S_OK);
}


HRESULT
CopyNTToNTSynId(
    DWORD dwSyntaxId,
    LPBYTE lpByte,
    PNTOBJECT lpNTObject
    )
{
    HRESULT hr = S_OK;

    switch (dwSyntaxId) {
    case NT_SYNTAX_ID_BOOL:

        hr = CopyBOOLToNTOBJECT(
                         (PBOOL)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = CopySYSTEMTIMEToNTOBJECT(
                         (PSYSTEMTIME)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DWORD:
        hr = CopyDWORDToNTOBJECT(
                         (PDWORD)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = CopyDATEToNTOBJECT(
                         (PDWORD)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_NW312DATE:
        hr = CopyNw312DATEToNTOBJECT(
                         lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DelimitedString:
        hr = CopyDelimitedStringToNTOBJECT(
                         (LPTSTR)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = CopyNulledStringToNTOBJECT(
                         (LPTSTR)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = CopyLPTSTRToNTOBJECT(
                         (LPTSTR)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = CopyOctetToNTOBJECT(
                         lpByte,
                         lpNTObject
                         );
        break;

    default:
        break;

    }

    RRETURN(hr);
}



//
//  NT is always single-valued!!
//

HRESULT
UnMarshallNTToNTSynId(
    DWORD dwSyntaxId,
    DWORD dwNumValues,
    LPBYTE lpValue,
    PNTOBJECT * ppNTObject
    )
{
    LPBYTE lpByte = lpValue;
    DWORD  i = 0;
    PNTOBJECT pNTObject = NULL;
    HRESULT hr = S_OK;

    pNTObject = (PNTOBJECT)AllocADsMem(
                            sizeof(NTOBJECT)
                            );

    if (!pNTObject) {
        RRETURN(E_FAIL);
    }

    hr = CopyNTToNTSynId(
                     dwSyntaxId,
                     lpByte,
                     pNTObject
                     );
    BAIL_ON_FAILURE(hr);


    *ppNTObject = pNTObject;
    RRETURN(hr);

error:
    if (pNTObject) {
        FreeADsMem(pNTObject);
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\parse.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  parse.cxx
//
//  Contents:  Windows NT 3.5 GetObject functionality
//
//  History:
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop

KWDLIST KeywordList[MAX_KEYWORDS] =
{
    { TOKEN_DOMAIN, L"domain"},
    { TOKEN_USER, L"user"},
    { TOKEN_GROUP, L"group"},
    { TOKEN_COMPUTER, L"computer"},
    { TOKEN_PRINTER, L"printqueue"},
    { TOKEN_SERVICE, L"service"},
    { TOKEN_FILESERVICE, L"fileservice"},
    { TOKEN_FILESHARE, L"fileshare"},
    { TOKEN_NAMESPACE, L"namespace"},
    { TOKEN_SCHEMA, L"schema"},
    { TOKEN_CLASS,  L"class"},
    { TOKEN_PROPERTY, L"property"},
    { TOKEN_SYNTAX, L"syntax" }
};

WCHAR *  szProviderName  = L"NWCOMPAT";


// Object -> PathName, Type, eos
// Object -> PathName, eos

//+---------------------------------------------------------------------------
//  Function:
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Object(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = ProviderName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);


    switch (dwToken) {
    case TOKEN_END:
        RRETURN(S_OK);

    case TOKEN_COMMA:
        hr = Type(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);
        if (dwToken == TOKEN_END) {
            RRETURN(S_OK);
        }else {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    default:
        hr = pTokenizer->PushBackToken();

        hr = DsPathName(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        switch (dwToken) {
        case TOKEN_END:
            RRETURN(S_OK);

        case TOKEN_COMMA:
            hr = Type(pTokenizer, pObjectInfo);
            BAIL_IF_ERROR(hr);
            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);
            if (dwToken == TOKEN_END) {
                RRETURN(S_OK);
            }else {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

        default:
            RRETURN(E_FAIL);

        }

    }

cleanup:
    RRETURN(hr);
}



HRESULT
ProviderName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_ATSIGN) {

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_EXCLAMATION) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else if (dwToken == TOKEN_IDENTIFIER) {

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_COLON) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // You can now disable the processing for "@" and "!" treat them
    // as ordinary characters.
    //

    pTokenizer->SetAtDisabler(TRUE);


    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}


// PathName -> Component \\ PathName
// PathName -> Component

HRESULT
DsPathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
PathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    HRESULT hr;
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;

    hr = Component(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);

    if (dwToken == TOKEN_FSLASH) {
        RRETURN (PathName(pTokenizer, pObjectInfo));
    }else {
        hr = pTokenizer->PushBackToken();
        RRETURN (S_OK);
    }
cleanup:
    RRETURN(hr);
}

// Component -> <identifier>





//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Component(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    WCHAR szDisplayToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, szDisplayToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = AddComponent(pObjectInfo, szToken, szDisplayToken);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);
cleanup:
    RRETURN(hr);
}

// Type -> "user", "group","printer","service"

//+---------------------------------------------------------------------------
// Function:    Type
//
// Synopsis:    Parses Type-> "user" | "group" etc
//
// Arguments:   [CLexer * pTokenizer]
//              [POBJECTINFo pObjectInfo]
//
// Returns:     HRESULT
//
// Modifies:    -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------


HRESULT
Type(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_PATH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_IDENTIFIER ) {
        if (pTokenizer->IsKeyword(szToken, &dwToken)) {
            hr = SetType(pObjectInfo, dwToken);
            RRETURN(hr);
        }
    }

    RRETURN(E_FAIL);

cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLexer::CLexer(LPWSTR szBuffer):
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _bAtDisabled(FALSE)
{
    if (!szBuffer || !*szBuffer) {
        return;
    }
    _Buffer = AllocADsStr(szBuffer);
    _ptr = _Buffer;
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    08-12-96   t-danal     Created.
//
//----------------------------------------------------------------------------
CLexer::~CLexer()
{
    FreeADsStr(_Buffer);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPWSTR szDisplayToken, LPDWORD pdwToken)
{
    WCHAR c;
    DWORD state = 0;
    LPWSTR pch = szToken;
    LPWSTR pDisplayCh = szDisplayToken;
    BOOL fEscapeOn = FALSE, fQuotingOn = FALSE;

    memset(szToken, 0, sizeof(WCHAR) * MAX_TOKEN_LENGTH);

    if (szDisplayToken) {
        memset(szDisplayToken, 0, sizeof(TCHAR) * MAX_TOKEN_LENGTH);
    }

    _dwLastTokenLength = 0;
    while (1) {
        c = NextChar();
        switch (state) {
        case  0:
            *pch++ = c;
            _dwLastTokenLength++;

            if (c == TEXT('"')) {
                //
                // Quoting; 
                //

                fQuotingOn = TRUE;

                pch--;
                state = 1;
                
            }else if (c == TEXT('\\')) {
                //
                // Escaping; Ignore the '\' in the token and check to make 
                // sure that the next character exists
                //
                pch--;

                fEscapeOn = TRUE;

                state = 1;

            }else if (c == L'/') {
                *pdwToken = TOKEN_FSLASH;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L',') {
                *pdwToken = TOKEN_COMMA;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L':'){
                if (!_bAtDisabled) {
                    *pdwToken = TOKEN_COLON;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }else {
                    state = 1;
                }
            }else if (c == TEXT('<')) {
                RRETURN(E_FAIL);
            }else if (c == TEXT('>')) {
                RRETURN(E_FAIL);
            }else if (c == L'\0'){
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'@') {

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_ATSIGN;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else if (c == L'!'){

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_EXCLAMATION;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else {

                state = 1;
            }
            break;


        case 1:
            if ((fEscapeOn || fQuotingOn) && c == TEXT('\0') ) {
                RRETURN(E_FAIL);
            }
            else if (fEscapeOn) {
                fEscapeOn = FALSE;
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
            else if (fQuotingOn) {
                if (c == TEXT('"')) {
                    fQuotingOn = FALSE;
                }
                *pch++ = c;
                _dwLastTokenLength++;
                break;
            }
            else if (c == TEXT('\\') ) {
                fEscapeOn = TRUE;
                _dwLastTokenLength++;

                break;

            }
            else if (c == TEXT('"')) {
                fQuotingOn = TRUE;
                _dwLastTokenLength++;
                break;
            }
            if (c == L'\0' || c == L',' || c == L'/') {
                PushbackChar();

                *pdwToken = TOKEN_IDENTIFIER;
                _dwLastToken = *pdwToken;
                RRETURN (S_OK);
            }else if (c == L'@' || c == L'!' || c == L':') {

                if (!_bAtDisabled) {

                    PushbackChar();

                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {

                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                    break;

                }
            }else {
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
        default:
            RRETURN(E_FAIL);
        }

        if (pDisplayCh) {
            *pDisplayCh++ = c;
        }

    }
}

HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPDWORD pdwToken)
{
    RRETURN (GetNextToken(szToken, NULL, pdwToken));
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
WCHAR
CLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::PushBackToken()
{
    if (_dwLastToken == TOKEN_END) {
        RRETURN(S_OK);
    }
    _ptr -= _dwLastTokenLength;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
BOOL
CLexer::IsKeyword(LPWSTR szToken, LPDWORD pdwToken)
{
    DWORD i = 0;

    for (i = 0; i < MAX_KEYWORDS; i++) {
        if (!_wcsicmp(szToken, KeywordList[i].Keyword)) {
            *pdwToken = KeywordList[i].dwTokenId;
            return(TRUE);
        }
    }
    *pdwToken = 0;
    return(FALSE);
}


//+---------------------------------------------------------------------------
//Function:
//
//Synopsis:
//
//Arguments:
//
//Returns:
//
//Modifies:
//
//History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
AddComponent(POBJECTINFO pObjectInfo, LPWSTR szToken, LPWSTR szDisplayToken)
{
    if (!szToken || !*szToken) {
    }
    pObjectInfo->ComponentArray[pObjectInfo->NumComponents] =
                    AllocADsStr(szToken);

    pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents] =
                    AllocADsStr(szToken);
                
    pObjectInfo->NumComponents++;

    RRETURN(S_OK);

}

HRESULT
AddProviderName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->ProviderName = AllocADsStr(szToken);

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
SetType(POBJECTINFO pObjectInfo, DWORD dwToken)
{
    pObjectInfo->ObjectType = dwToken;
    RRETURN(S_OK);
}


void
CLexer::SetAtDisabler(
    BOOL bFlag
    )
{
    _bAtDisabled = bFlag;
}

BOOL
CLexer::GetAtDisabler()
{
    return(_bAtDisabled);
}

HRESULT
GetDisplayName(
    LPWSTR szName,
    LPWSTR *ppszDisplayName
    )
{

    HRESULT hr = S_OK;
    DWORD len = 0;
    LPWSTR pch = szName;
    LPWSTR pszDisplayCh = NULL, pszDisplay = NULL;
    BOOL fQuotingOn = FALSE;

    if (!ppszDisplayName ) {
        RRETURN (E_INVALIDARG);
    }

    *ppszDisplayName = NULL;

    if (!szName) {
        RRETURN (S_OK);
    }

    pch = szName;
    fQuotingOn = FALSE;

    for (len=0; *pch; pch++, len++) {
        if ((!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'"') ) {
            fQuotingOn = ~fQuotingOn;
        }
        else if (!fQuotingOn && (!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'/' || *pch == L'<' || *pch == L'>') ) {
            len++;
        }
    }

    pszDisplay = (LPWSTR) AllocADsMem((len+1) * sizeof(WCHAR));

    if (!pszDisplay) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pch = szName; 
    pszDisplayCh = pszDisplay;
    fQuotingOn = FALSE;

    for (; *pch; pch++, pszDisplayCh++) {
        if ((!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'"') ) {
            fQuotingOn = ~fQuotingOn;
        }
        else if (!fQuotingOn && (!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'/' || *pch == L'<' || *pch == L'>') ) {
            *pszDisplayCh++ = L'\\';
        }
        *pszDisplayCh = *pch;
    }

    *pszDisplayCh = L'\0';

    *ppszDisplayName = pszDisplay;

error:

    RRETURN(hr);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\printhlp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      printhlp.cxx
//
//  Contents:  Helper functions for printer object.
//
//  History:   08-May-96    t-ptam (PatrickT) migrated
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma hdrstop

//----------------------------------------------------------------------------
//
//  Function: WinNTEnumJobs
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL
WinNTEnumJobs(
    HANDLE hPrinter,
    DWORD dwFirstJob,
    DWORD dwNoJobs,
    DWORD dwLevel,
    LPBYTE *lplpbJobs,
    DWORD *pcbBuf,
    LPDWORD lpdwReturned
    )
{
    BOOL  fStatus = FALSE;
    DWORD dwNeeded = 0;
    DWORD dwError = 0;

    //
    // Enumerate Jobs using Win32 API.
    //

    fStatus = EnumJobs(
                  hPrinter,
                  dwFirstJob,
                  dwNoJobs,
                  dwLevel,
                  *lplpbJobs,
                  *pcbBuf,
                  &dwNeeded,
                  lpdwReturned
                  );

    //
    // Enumerate for Jobs again with a bigger buffer if a bigger one is needed
    // for the result.
    //

    if (!fStatus) {

        if ((dwError = GetLastError()) == ERROR_INSUFFICIENT_BUFFER) {

            if (*lplpbJobs) {
                FreeADsMem( *lplpbJobs );
            }

            *lplpbJobs = (LPBYTE)AllocADsMem(dwNeeded);

            if (!*lplpbJobs) {
                *pcbBuf = 0;
                return(FALSE);
            }

            *pcbBuf = dwNeeded;

            fStatus = EnumJobs(
                          hPrinter,
                          dwFirstJob,
                          dwNoJobs,
                          dwLevel,
                          *lplpbJobs,
                          *pcbBuf,
                          &dwNeeded,
                          lpdwReturned
                          );

            if (!fStatus) {
                return(FALSE);
            }
            else {
                return(TRUE);
            }
        }
        else {
            return(FALSE);
        }
    }
    else {
        return(TRUE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: WinNTEnumPrinters
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL
WinNTEnumPrinters(
    DWORD  dwType,
    LPTSTR lpszName,
    DWORD  dwLevel,
    LPBYTE *lplpbPrinters,
    LPDWORD lpdwReturned
    )
{
    BOOL   fStatus = FALSE;
    DWORD  dwPassed = 1024;
    DWORD  dwNeeded = 0;
    DWORD  dwError = 0;
    LPBYTE pMem = NULL;

    //
    // Allocate memory for return buffer.
    //

    pMem =  (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        goto error;
    }

    //
    // Enumerate Printers using Win32 API.
    //

    fStatus = EnumPrinters(
                  dwType,
                  lpszName,
                  dwLevel,
                  pMem,
                  dwPassed,
                  &dwNeeded,
                  lpdwReturned
                  );

    //
    // Enumerate for Printers again with a bigger buffer if a bigger one is
    // needed for the result.
    //

    if (!fStatus) {

        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            goto error;
        }

        if (pMem) {
            FreeADsMem(pMem);
        }

        pMem = (LPBYTE)AllocADsMem(
                           dwNeeded
                           );

        if (!pMem) {
            goto error;
        }

        dwPassed = dwNeeded;

        fStatus = EnumPrinters(
                      dwType,
                      lpszName,
                      dwLevel,
                      pMem,
                      dwPassed,
                      &dwNeeded,
                      lpdwReturned
                      );

        if (!fStatus) {
            goto error;
        }
    }

    //
    // Return.
    //

    *lplpbPrinters = pMem;

    return(TRUE);

error:

    if (pMem) {
        FreeADsMem(pMem);
    }

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: WinNTGetPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL
WinNTGetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE *lplpbPrinters
    )
{

    BOOL    fStatus = FALSE;
    DWORD   dwPassed = 1024;
    DWORD   dwNeeded = 0;
    DWORD   dwError = 0;
    LPBYTE  pMem = NULL;

    //
    // Allocate memory for return buffer.
    //

    pMem =  (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        goto error;
    }

    //
    // Get printer's information.
    //

    fStatus = GetPrinter(
                  hPrinter,
                  dwLevel,
                  pMem,
                  dwPassed,
                  &dwNeeded
                  );

    //
    // Get printer's information again with a bigger buffer if a bigger buffer
    // is needed for the result.
    //

    if (!fStatus) {

        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            goto error;
        }

        if (pMem) {
            FreeADsMem(pMem);
        }

        pMem = (LPBYTE)AllocADsMem(
                           dwNeeded
                           );

        if (!pMem) {
            goto error;
        }

        dwPassed = dwNeeded;

        fStatus = GetPrinter(
                      hPrinter,
                      dwLevel,
                      pMem,
                      dwPassed,
                      &dwNeeded
                      );

        if (!fStatus) {
            goto error;
        }
    }

    //
    // Return.
    //

    *lplpbPrinters = pMem;

    return(TRUE);


error:
    if (pMem) {
        FreeADsMem(pMem);
    }

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: GetPrinterInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
GetPrinterInfo(
     THIS_ LPPRINTER_INFO_2 *lplpPrinterInfo2,
     BSTR  bstrPrinterName
     )
{
    //
    // Do a GetPrinter call to bstrPrinterName
    //

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE |
                                              READ_CONTROL};
    DWORD LastError = 0;
    HANDLE hPrinter = NULL;
    LPBYTE pMem = NULL;
    HRESULT hr = S_OK;

    ADsAssert(bstrPrinterName);

    //
    // Open a printer handle.
    //

    fStatus = OpenPrinter(
                  (LPTSTR)bstrPrinterName,
                  &hPrinter,
                  &PrinterDefaults
                  );

    //
    // If access is denied, do it again with a different access right.
    //

    if (!fStatus) {
        LastError = GetLastError();
        switch (LastError) {

        case ERROR_ACCESS_DENIED:
            {
                PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
                fStatus = OpenPrinter(
                              (LPTSTR)bstrPrinterName,
                              &hPrinter,
                              &PrinterDefaults
                              );
                if (fStatus) {
                    break;
                }
            }

        default:
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    //
    // Get printer's info.
    //

    fStatus = WinNTGetPrinter(
                  hPrinter,
                  2,
                  (LPBYTE *)&pMem
                  );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    //
    // Return.
    //

    *lplpPrinterInfo2 = (LPPRINTER_INFO_2)pMem;

cleanup:

    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: Set
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
Set(
    LPPRINTER_INFO_2 lpPrinterInfo2,
    LPTSTR   pszPrinterName
    )
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ALL_ACCESS};
    HANDLE hPrinter = NULL;
    HRESULT hr;

    ADsAssert(pszPrinterName);

    //
    // Open a printer handle.
    //

    fStatus = OpenPrinter(
                  pszPrinterName,
                  &hPrinter,
                  &PrinterDefaults
                  );

    if (!fStatus) {
        goto error;
    }

    //
    // Set printer's data.
    //

    fStatus = SetPrinter(
                  hPrinter,
                  2,
                  (LPBYTE)lpPrinterInfo2,
                  0
                  );

    if (!fStatus) {
        goto error;
    }

    //
    // Return.
    //

    fStatus = ClosePrinter(hPrinter);

    RRETURN(S_OK);

error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);

}

//----------------------------------------------------------------------------
//
//  Function: WinNTDeletePrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
WinNTDeletePrinter(
    POBJECTINFO pObjectInfo
    )
{
    WCHAR szUncServerName[MAX_PATH];
    WCHAR szUncPrinterName[MAX_PATH];
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;

    //
    // Make Unc Name for OpenPrinter.
    //

    MakeUncName(pObjectInfo->ComponentArray[1],
                szUncServerName
                );

    wcscpy(szUncPrinterName, szUncServerName);
    wcscat(szUncPrinterName, L"\\");
    wcscat(szUncPrinterName, (LPTSTR)pObjectInfo->ComponentArray[2]);

    //
    // Open a printer handle.
    //

    fStatus = OpenPrinter(
                  (LPTSTR)szUncPrinterName,
                  &hPrinter,
                  &PrinterDefaults
                  );

    if (!fStatus) {
        goto error;
    }

    //
    // Delete the given printer.
    //

    fStatus = DeletePrinter(hPrinter);

    //
    // Return.
    //

    if (!fStatus) {

        hr = GetLastError();

        fStatus = ClosePrinter(hPrinter);

        goto error;
    }


error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\sconv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  sconv.cxx
//
//  Contents:  Ansi to Unicode conversions
//
//  History:    KrishnaG        Jan 22 1996
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop

#define NULL_TERMINATED 0

int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
{
    int iReturn;

    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}


int
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength
    )
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( StringLength == NULL_TERMINATED ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if( pAnsi == (LPSTR)pUnicode )
    {
        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength+1 );
        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength,
                                  NULL,
                                  NULL );
    }

    //
    // Null terminate
    //

    pAnsi[StringLength] = '\0';


    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        strcpy( pAnsi, pTempBuf );
        LocalFree( pTempBuf );
    }

    return rc;
}


LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    )
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)LocalAlloc(
                        LPTR,
                        strlen(pAnsiString)*sizeof(WCHAR) +sizeof(WCHAR)
                        );

    if (pUnicodeString) {

        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            NULL_TERMINATED
            );
    }

    return pUnicodeString;
}


void
FreeUnicodeString(
    LPWSTR  pUnicodeString
    )
{
    if (!pUnicodeString)
        return;

    LocalFree(pUnicodeString);

    return;
}


DWORD
ComputeMaxStrlenW(
    LPWSTR pString,
    DWORD  cchBufMax
    )
{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //

    cchBufMax--;

    cchLen = wcslen(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}


DWORD
ComputeMaxStrlenA(
    LPSTR pString,
    DWORD  cchBufMax
    )
{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //
    cchBufMax--;

    cchLen = lstrlenA(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\property.cxx ===
#include "nwcompat.hxx"
#pragma hdrstop


#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);




HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackStringinVariant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varOutputData);
    RRETURN(hr);

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDATEfromVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT_BOOL pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_VARIANT_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANTinVariant(
            vSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varOutputData);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\usrutils.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      usrutils.cxx
//
//  Contents:  NetWare compatible UserCollection Enumeration Code
//
//  History:   22-Mar-96    t-ptam (PatrickT) migrated from KrishnaG for NetWare
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop

USER_GROUP_ENTRY UserGroupEntry;

//
// This assumes that addr is an LPBYTE type.
//

#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((DWORD)addr & ~1))

DWORD UserGrpEntryStrings[]=
                             {
                             FIELD_OFFSET(USER_GROUP_ENTRY, Parent),
                             FIELD_OFFSET(USER_GROUP_ENTRY, Computer),
                             FIELD_OFFSET(USER_GROUP_ENTRY, Name),
                             0xFFFFFFFF
                             };

DECLARE_INFOLEVEL(UsrUt)
DECLARE_DEBUG(UsrUt)
#define UsrUtDebugOut(x) UsrUtInlineDebugOut x

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerUserOpen
//
//  Synopsis: This function opens a handle to a INI_COMP_USER structure.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerUserOpen(
    LPWSTR szComputerName,
    LPWSTR szGroupName,
    CCredentials &Credentials,
    PHANDLE phUser
    )
{
    WCHAR szTempBuffer[MAX_PATH];
    PINI_COMP_USER pIniCompUsr;
    HRESULT hr = S_OK;

    if (!phUser) {
        return(FALSE);
    }

    pIniCompUsr = (PINI_COMP_USER)AllocADsMem(
                                       sizeof(INI_COMP_USER)
                                       );
    if (!pIniCompUsr) {
        return(FALSE);
    }

    //
    // Fill structure's fields.
    //

    if (!(pIniCompUsr->szComputerName =  AllocADsStr(szComputerName))){
        goto error;
    }

    if (!(pIniCompUsr->szGroupName = AllocADsStr(szGroupName))){
        goto error;
    }

    hr = NWApiGetBinderyHandle(
             &pIniCompUsr->_hConn,
             szComputerName,
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return
    //

    *phUser =  (HANDLE)pIniCompUsr;

    return(TRUE);


error:
    if (pIniCompUsr) {
        FreeIniCompUser(pIniCompUsr);
    }

    *phUser = NULL;

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerUserEnum
//
//  Synopsis: This function returns a buffer which contains all the binding
//            informations for the requested number of objects without any
//            references.
//            It returns TRUE iff dwReturned = dwRequested.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerUserEnum(
    HANDLE hUser,
    DWORD  dwRequested,
    LPBYTE * ppBuffer,
    PDWORD pdwReturned
    )
{
    LPUSER_GROUP_ENTRY * ppUserMembers = NULL;
    DWORD i = 0;
    BOOL dwRet = FALSE;
    DWORD dwReturned = 0;
    DWORD dwSize = 0;
    LPUSER_GROUP_ENTRY pBuffer = NULL;
    LPBYTE pEnd = NULL;

    //
    // Allocate buffer for the number of requested members.
    //

    ppUserMembers = (LPUSER_GROUP_ENTRY *)AllocADsMem(
                                                    sizeof(LPUSER_GROUP_ENTRY)* dwRequested
                                                    );
    if (!ppUserMembers) {
        return(FALSE);
    }

    //
    // Fill in ppUserMembers one by one.
    //

    for (i = 0; i < dwRequested; i++) {

        dwRet = NWCOMPATComputerUserGetObject(
                    hUser,
                    &ppUserMembers[i]
                    );
        if (!dwRet) {
            break;
        }
    }

    dwReturned = i;

    if (!dwRet) {
        goto error;
    }
    else {

        //
        // Determine actual size of ppUserMembers[], ie. since each string in
        // USER_GROUP_ENTRY have a different length, a buffer that is going
        // to contain all the data without any references is unknown.
        //

        dwRet = ComputeComputerUserDataSize(
                    ppUserMembers,
                    dwReturned,
                    &dwSize
                    );

        pBuffer = (LPUSER_GROUP_ENTRY)AllocADsMem(
                                               dwSize
                                               );
        if (!pBuffer) {
            goto error;
        }

        pEnd = (LPBYTE)((LPBYTE)(pBuffer) + dwSize);

        //
        // Put data into pBuffer, starting from the end.
        //

        for (i = 0; i < dwReturned; i++) {

            pEnd = CopyIniCompUserToCompUser(
                       ppUserMembers[i],
                       (LPBYTE)(pBuffer + i),
                       pEnd
                       );
        }

        //
        // Clean up.
        //

        for (i = 0; i < dwReturned; i++ ) {
            FreeIntCompUser(*(ppUserMembers + i));
        }

        //
        // Return values.
        //

        *ppBuffer = (LPBYTE)pBuffer;
        *pdwReturned  = dwReturned;
    }

    FreeADsMem(ppUserMembers);

    if (dwReturned == dwRequested){
        return(TRUE);
    }else {
        return(FALSE);
    }
error:

    for (i = 0; i < dwReturned; i++ ) {
        FreeIntCompUser(*(ppUserMembers + i));
    }
    
    FreeADsMem(ppUserMembers);
    
    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerUserGetObject
//
//  Synopsis: This function returns binding information of a user (group member)
//            object one by one.  In its first call, it builds a buffer that
//            contains all the UserID of the group members.  Then, and in
//            subsequent calls, this UserID is translated into a user name.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerUserGetObject(
    HANDLE hUser,
    LPUSER_GROUP_ENTRY * ppUserMember
    )
{
    BOOL            dwRet = FALSE;
    DWORD           dwGroupId = 0;
    HRESULT         hr = S_OK;
    PINI_COMP_USER pIniCompUsr = (PINI_COMP_USER)hUser;

    //
    // Fill buffer with User ID.  NetWare returns all UserID in one call.
    //

    if (!pIniCompUsr->_pBuffer) {

        pIniCompUsr->_dwCurrentObject = 0;

        hr = NWApiUserGetGroups(
                 pIniCompUsr->_hConn,
                 pIniCompUsr->szGroupName,
                 &(pIniCompUsr->_pBuffer)
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Build one group member.
    //

    dwGroupId = *((LPDWORD)pIniCompUsr->_pBuffer + pIniCompUsr->_dwCurrentObject);

    if (dwGroupId != 0x0000) {

        dwRet = BuildComputerUserMember(
                    hUser,
                    dwGroupId,
                    ppUserMember
                    );
        if (!dwRet) {
            goto error;
        }

        pIniCompUsr->_dwCurrentObject++;

        return(TRUE);
    }

error:

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerUserClose
//
//  Synopsis: Wrapper of FreeIniCompUser.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerUserClose(
    HANDLE hUser
    )
{
    PINI_COMP_USER pIniCompUsr = (PINI_COMP_USER)hUser;

    if (pIniCompUsr) {
        FreeIniCompUser(pIniCompUsr);
    }
    return(TRUE);
}

//----------------------------------------------------------------------------
//
//  Function: FreeIniCompUser
//
//  Synopsis: Free an INI_COMP_USER structure.
//
//----------------------------------------------------------------------------
void
FreeIniCompUser(
    PINI_COMP_USER pIniCompUsr
    )
{
    HRESULT hr = S_OK;

    if (pIniCompUsr) {

        if (pIniCompUsr->szComputerName) {
            FreeADsStr(pIniCompUsr->szComputerName);
        }

        if (pIniCompUsr->szGroupName) {
            FreeADsStr(pIniCompUsr->szGroupName);
        }

        if (pIniCompUsr->_pBuffer) {
            FreeADsMem(pIniCompUsr->_pBuffer);
        }

        if (pIniCompUsr->_hConn) {
            hr = NWApiReleaseBinderyHandle(pIniCompUsr->_hConn);
        }

        FreeADsMem(pIniCompUsr);
    }

    return;
}

//----------------------------------------------------------------------------
//
//  Function: FreeIntCompUser
//
//  Synopsis: Free a USER_GROUP_ENTRY structure.
//
//----------------------------------------------------------------------------
void
FreeIntCompUser(
    LPUSER_GROUP_ENTRY pCompUserMember
    )
{
    if (pCompUserMember) {

        if (pCompUserMember->Parent) {
            FreeADsStr(pCompUserMember->Parent);
        }

        if (pCompUserMember->Computer) {
            FreeADsStr(pCompUserMember->Computer);
        }

        if (pCompUserMember->Name) {
            FreeADsStr(pCompUserMember->Name);
        }

        FreeADsMem(pCompUserMember);
    }

    return;
}

//----------------------------------------------------------------------------
//
//  Function: ComputeComputerUserDataSize
//
//  Synopsis: Calculate the size of a buffer that is going to store the data in
//            ppUserMembers without any references.
//
//----------------------------------------------------------------------------
BOOL
ComputeComputerUserDataSize(
        LPUSER_GROUP_ENTRY * ppUserMembers,
        DWORD  dwReturned,
        PDWORD pdwSize
        )
{

    DWORD i = 0;
    DWORD cb = 0;
    LPUSER_GROUP_ENTRY pMember = NULL;

    for (i = 0; i < dwReturned; i++) {

        pMember = *(ppUserMembers + i);

        cb += sizeof(USER_GROUP_ENTRY);

        if (pMember->Parent) {
            cb += wcslen(pMember->Parent)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Computer) {
            cb += wcslen(pMember->Computer)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Name) {
            cb += wcslen(pMember->Name)*sizeof(WCHAR) + sizeof(WCHAR);
        }
    }

    *pdwSize = cb;
    return(TRUE);
}

//------------------------------------------------------------------------------
//
//  Function: CopyIniCompUserToCompUser
//
//  Synopsis: Pack referenced data (string) into a buffer without any reference.
//
//------------------------------------------------------------------------------
LPBYTE
CopyIniCompUserToCompUser(
    LPUSER_GROUP_ENTRY  pIntCompGrp,
    LPBYTE  pExtCompGrp,
    LPBYTE  pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(USER_GROUP_ENTRY)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings =  SourceStrings;
    LPUSER_GROUP_ENTRY pCompGrpMember = (LPUSER_GROUP_ENTRY)pExtCompGrp;

    memset(SourceStrings, 0, sizeof(USER_GROUP_ENTRY));
    *pSourceStrings++ = pIntCompGrp->Parent;
    *pSourceStrings++ = pIntCompGrp->Computer;
    *pSourceStrings++ = pIntCompGrp->Name;

    pEnd = PackStrings(
                SourceStrings,
                pExtCompGrp,
                UserGrpEntryStrings,
                pEnd
                );

    pCompGrpMember->Type = pIntCompGrp->Type;

    return pEnd;
}

//----------------------------------------------------------------------------
//
//  Function: BuildComputerUserMember
//
//  Synopsis: Put binding information of a group member into ppUserMember.
//
//----------------------------------------------------------------------------
BOOL
BuildComputerUserMember(
    HANDLE hUser,
    DWORD  dwGroupId,
    LPUSER_GROUP_ENTRY * ppUserMember
    )
{
    DWORD                   dwTempUserId = dwGroupId;
    HRESULT                 hr = S_OK;
    LPUSER_GROUP_ENTRY pUserMember = NULL;
    LPINI_COMP_USER        pUser = (LPINI_COMP_USER)hUser;
    WCHAR                   szADsParent[MAX_PATH];

    //
    // Allocate one USER_GROUP_ENTRY.
    //

    pUserMember = (LPUSER_GROUP_ENTRY)AllocADsMem(
                                                sizeof(USER_GROUP_ENTRY)
                                                );
    if (!pUserMember) {
        return(FALSE);
    }

    //
    // Fill structure's fields.
    //

    pUserMember->Parent = NULL;
    pUserMember->Computer = NULL;

    pUserMember->Type = NWCOMPAT_USER_ID;

    wsprintf(
        szADsParent,
        L"%s://%s",
        szProviderName,
        pUser->szComputerName
        );
    pUserMember->Parent = AllocADsStr(szADsParent);
    if (!pUserMember->Parent) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pUserMember->Computer = AllocADsStr(pUser->szComputerName);
    if (!pUserMember->Computer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = NWApiGetObjectName(
             pUser->_hConn,
             dwTempUserId,
             &pUserMember->Name
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    *ppUserMember = pUserMember;
    return(TRUE);

error:
    if (pUserMember) {

        if (pUserMember->Parent)
            FreeADsStr(pUserMember->Parent);

        if (pUserMember->Computer)
            FreeADsStr(pUserMember->Computer);

        FreeADsMem(pUserMember);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\var2nw.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       var2nw.cxx
//
//  Contents:
//
//  Functions:
//
//  History:      13-June-1996   KrishnaG Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma  hdrstop


//
// WinNT objects copy code
//

HRESULT
VarTypeToWinNTTypeCopyBOOL(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpVarSrcObject){
        RRETURN(E_POINTER);
    }

    if(lpVarSrcObject->vt != VT_BOOL){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_BOOL;

    if(lpVarSrcObject->boolVal){
        (pNTDestValue->NTValue).fValue = TRUE;

    } else {
        (pNTDestValue->NTValue).fValue = FALSE;
    }

    RRETURN(hr);
}

HRESULT
VarTypeToWinNTTypeCopySYSTEMTIME(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpVarSrcObject){
        RRETURN(E_POINTER);
    }

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = ConvertDATEToSYSTEMTIME(lpVarSrcObject->date,
                                 &(pNTDestValue->NTValue.stSystemTimeValue) );


    RRETURN( hr );
}


HRESULT
VarTypeToWinNTTypeCopyDWORD(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_I4){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_DWORD;

    (pNTDestValue->NTValue).dwValue = (DWORD)lpVarSrcObject->lVal;
    RRETURN(hr);

}

HRESULT
VarTypeToWinNTTypeCopyDATE(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME stTime;

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_DATE;

    //
    // Note carefully! date is supplied as a value which is < 1 however
    // VariantTimeToDosDateTime complains when given a value < 30000.
    // (Number of days between 1900 and 1980). So
    // we add 35000 to make it a legal value.
    //

    hr = ConvertDATEToSYSTEMTIME(lpVarSrcObject->date+ 35000,
                                 &stTime);

    BAIL_ON_FAILURE(hr);

    (pNTDestValue->NTValue).dwValue = stTime.wHour*60 + stTime.wMinute ;


error:
    RRETURN(hr);

}

HRESULT
VarTypeToWinNTTypeCopyNW312DATE(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME stTime;

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_NW312DATE;

    hr = ConvertVariantToNW312Date(
                lpVarSrcObject->date,
                pNTDestValue->NTValue.Nw312Date
                );
    BAIL_ON_FAILURE(hr);


error:
    RRETURN(hr);

}

HRESULT
VarTypeToWinNTTypeCopyLPTSTR(
    PVARIANT lpVarSrcObject,
    PNTOBJECT   pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_LPTSTR;

    (pNTDestValue->NTValue).pszValue =
        AllocADsStr(lpVarSrcObject->bstrVal);

    if(!(pNTDestValue->NTValue).pszValue){
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
VarTypeToWinNTTypeCopyDelimitedString(
    PVARIANT lpVarSrcObject,
    PNTOBJECT   pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if (!(V_VT(lpVarSrcObject) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }


    pNTDestValue->NTType = NT_SYNTAX_ID_DelimitedString;

    hr = VariantToDelimitedString(*lpVarSrcObject,
                                  &((pNTDestValue->NTValue).pszValue),
                                  TEXT(','));

    RRETURN(hr);
}

HRESULT
VarTypeToWinNTTypeCopyOctetString(
    PVARIANT lpVarSrcObject,
    PNTOBJECT   pNTDestValue
    )
{
    HRESULT hr = S_OK;

    pNTDestValue->NTType = NT_SYNTAX_ID_OCTETSTRING;
    hr = VariantToBinary(
            lpVarSrcObject,
            &(pNTDestValue->NTValue).octetstring.dwSize,
            &(pNTDestValue->NTValue).octetstring.pByte);

    RRETURN(hr);
}


HRESULT
VarTypeToWinNTTypeCopyNulledString(
    PVARIANT lpVarSrcObject,
    PNTOBJECT   pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(!(V_VT(lpVarSrcObject) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_NulledString;

    hr = VariantToNulledString(*lpVarSrcObject,
                                  &((pNTDestValue->NTValue).pszValue) );

    RRETURN(hr);
}

HRESULT
VarTypeToNtTypeCopy(
    DWORD dwNtType,
    PVARIANT lpVarSrcObject,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;
    switch (dwNtType){
    case NT_SYNTAX_ID_BOOL:
        hr = VarTypeToWinNTTypeCopyBOOL(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = VarTypeToWinNTTypeCopySYSTEMTIME(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;


    case NT_SYNTAX_ID_DWORD:
        hr = VarTypeToWinNTTypeCopyDWORD(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = VarTypeToWinNTTypeCopyDATE(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;


    case NT_SYNTAX_ID_NW312DATE:
        hr = VarTypeToWinNTTypeCopyNW312DATE(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;



    case NT_SYNTAX_ID_LPTSTR:
        hr = VarTypeToWinNTTypeCopyLPTSTR(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;

    case NT_SYNTAX_ID_DelimitedString:
        hr = VarTypeToWinNTTypeCopyDelimitedString(
                 lpVarSrcObject,
                 lpNtDestObject
                 );
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = VarTypeToWinNTTypeCopyNulledString(
                 lpVarSrcObject,
                 lpNtDestObject
                 );
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = VarTypeToWinNTTypeCopyOctetString(
                 lpVarSrcObject,
                 lpNtDestObject
                 );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
VarTypeToNtTypeCopyConstruct(
    DWORD dwNtType,
    LPVARIANT pVarSrcObjects,
    DWORD dwNumObjects,
    LPNTOBJECT * ppNtDestObjects
    )
{

    DWORD i = 0;
    LPNTOBJECT pNtDestObjects = NULL;
    HRESULT hr = S_OK;

    pNtDestObjects = (LPNTOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NTOBJECT)
                                    );

    if (!pNtDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {

         hr = VarTypeToNtTypeCopy(
                    dwNtType,
                    pVarSrcObjects + i,
                    pNtDestObjects + i
                    );

         BAIL_ON_FAILURE(hr);
     }

     *ppNtDestObjects = pNtDestObjects;

     RRETURN(S_OK);

error:

    if (pNtDestObjects) {

        FreeADsMem(pNtDestObjects);
    }

    *ppNtDestObjects = NULL;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\win95\nw3login.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       nw3login.cxx
//
//  Description:
//          Spinned off from nw3utils.cxx because of differences in Win95
//          Contains routines to login and logoff from servers.
//
//  Functions:
//
//  History:      18-Sept-1996   t-felixw Created.
//
//
//  Issues:     
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

DWORD
WideToSz( 
    LPSTR lpszC, 
        LPCWSTR lpszW, 
    INT nSize 
    )
{
    if (!WideCharToMultiByte(CP_ACP,
                             WC_COMPOSITECHECK | WC_SEPCHARS,
                             lpszW,
                             -1,
                             lpszC,
                             nSize,
                             NULL,
                             NULL)) {
        return (GetLastError()) ;
    }
    
    return NO_ERROR ;
};


//
// BUGBUG - post beta cleanup. This code need to be crit sect protected 
// to be multi-thread safe. 
//


HRESULT 
NWApiLoginToServer(
    LPWSTR pszServerName,
    LPWSTR pszUserName,
    LPWSTR pszPassword
    )
{
    PNW_CACHED_SERVER pNwServer = pNwCachedServers ;
    DWORD Status ;
    NETRESOURCEA netResource ;
    DWORD nSize;
    LPSTR lpszServerName = NULL;
    LPSTR lpszUserName = NULL;
    LPSTR lpszPassword = NULL;
    HRESULT hrResult = NO_ERROR;    

    if (!pszServerName)
        return NOERROR ;

    
    // Is the code below necessary?
    while (pNwServer) {
        if (_wcsicmp(pszServerName,pNwServer->pszServerName)==0)
            break ;
    } 

    if (pNwServer == NULL) {

        //
        // not in list. add connection 
        //

        memset(&netResource, 
            0, 
            sizeof(netResource)
            );
        
        if (pszServerName) {
            nSize = wcslen(pszServerName) + 1;
            
            if(!(lpszServerName = (LPSTR) AllocADsMem(nSize * sizeof(CHAR) ))) {
                hrResult = E_OUTOFMEMORY;
                goto Exit;
            }
            if (WideToSz(lpszServerName, 
                         pszServerName, 
                         nSize ) != NO_ERROR) {
                hrResult = E_FAIL;
                goto Exit;
            }
        }

        if (pszUserName) {
            nSize = wcslen(pszUserName) + 1;
            
            if(!(lpszUserName = (LPSTR) AllocADsMem(nSize * sizeof(CHAR) ))) {
                hrResult = E_OUTOFMEMORY;
                goto Exit;
            }
            if (WideToSz( lpszUserName, 
                          pszUserName, 
                          nSize ) != NO_ERROR) {
                hrResult = E_FAIL;
                goto Exit;
            }
        }
                                           
        if (pszPassword) {
            nSize = wcslen(pszPassword) + 1;
            
            if(!(lpszPassword = (LPSTR) AllocADsMem(nSize * sizeof(CHAR) ))) {
                hrResult = E_OUTOFMEMORY;
                goto Exit;
                }
            if (WideToSz( lpszPassword, 
                          pszPassword, 
                          nSize ) != NO_ERROR) {
                hrResult = E_FAIL;
                goto Exit;
            }
        }
                                           
                
        netResource.lpRemoteName = (LPSTR)lpszServerName;

        Status = WNetAddConnection2A( &netResource,
                                      lpszUserName,
                                      lpszPassword,
                                      0 );

        if (Status) {   
            // FAILURE
            hrResult = HRESULT_FROM_WIN32(Status);
            goto Exit;
        }

        if (!(pNwServer = (PNW_CACHED_SERVER)
                        AllocADsMem(sizeof(NW_CACHED_SERVER)))) {
            NWApiLogoffServer(pszServerName) ;
            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }

        LPWSTR pszTmp ;
        
        if (!(pszTmp = AllocADsStr(pszServerName))) {
            NWApiLogoffServer(pszServerName) ;
            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }

        pNwServer->pszServerName = pszTmp ;
        pNwServer->pNextEntry = pNwCachedServers ;
        pNwCachedServers = pNwServer ;
Exit:
    if (lpszServerName)
        FreeADsMem(lpszServerName);
    if (lpszUserName)
        FreeADsMem(lpszUserName);
    if (lpszPassword)
        FreeADsMem(lpszPassword);
    // Not necessary to free pszTmp cuz it is the last one
    if (hrResult != NO_ERROR) {
        if (pNwServer)
            FreeADsMem(pNwServer);
    }
  }
  return hrResult;
}

HRESULT 
NWApiLogoffServer(
    LPWSTR pszServerName
    )
{
    LPSTR lpszServerName;
    HRESULT hrResult = NOERROR;
    DWORD nSize = wcslen(pszServerName) + 1;
    
    //BUGBUG: When we logout, don't we have to clear entries off cacheserver?
    //        It does not do it in the original WINNT source where this
    //        is ported from...
    if(!(lpszServerName = (LPSTR) AllocADsMem(nSize * sizeof(CHAR) ))) {
        return(E_FAIL);
    }
    if (WideToSz( lpszServerName, 
                  pszServerName, 
                  nSize ) != NO_ERROR) {
        hrResult = E_FAIL;
        goto Exit;
    }
    
    hrResult = HRESULT_FROM_WIN32(WNetCancelConnectionA(lpszServerName,FALSE));
Exit:
    FreeADsMem(lpszServerName);
    return hrResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\novellnw\winnt\nw3login.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nw3login.cxx
//
//  Description:
//          Spin off from nw3utils.cxx because of differences in Win95
//
//  Functions:
//
//  History:      18-Sept-1996   t-felixw Created.
//
//
//  Issues:     
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

//
// BUGBUG - post beta cleanup. This code need to be crit sect protected 
// to be multi-thread safe. 
//


HRESULT 
NWApiLoginToServer(
    LPWSTR pszServerName,
    LPWSTR pszUserName,
    LPWSTR pszPassword
    )
{
    PNW_CACHED_SERVER pNwServer = pNwCachedServers ;
    DWORD Status ;
    NETRESOURCE netResource ;

    if (!pszServerName)
        return NOERROR ;

    
    while (pNwServer) {
 
        if (_wcsicmp(pszServerName,pNwServer->pszServerName)==0) {
            break ;
        }

        pNwServer = pNwServer->pNextEntry;   
    } 

    if (pNwServer == NULL) {

        //
        // not in list. add connection 
        //

        memset(&netResource, 
            0, 
            sizeof(netResource)
            );

        netResource.lpRemoteName = pszServerName;

        Status = WNetAddConnection2(&netResource,
                     pszUserName,
                     pszPassword,
                     0
                     );

        if (Status) {

            return(HRESULT_FROM_WIN32(Status));
        }

        if (!(pNwServer = (PNW_CACHED_SERVER)
                  AllocADsMem(sizeof(NW_CACHED_SERVER)))) {

            NWApiLogoffServer(pszServerName) ;
            return(E_OUTOFMEMORY);
        }

        LPWSTR pszTmp ;
        
        if (!(pszTmp = AllocADsStr(pszServerName))) {

            NWApiLogoffServer(pszServerName) ;
            (void) FreeADsMem(pNwServer) ;
            return(E_OUTOFMEMORY);
        }

        pNwServer->pszServerName = pszTmp ;
        pNwServer->pNextEntry = pNwCachedServers ;
        pNwCachedServers = pNwServer ;
 
    }

    return(NOERROR) ;
}

HRESULT 
NWApiLogoffServer(
    LPWSTR pszServerName
    )
{
    return(HRESULT_FROM_WIN32(WNetCancelConnection(pszServerName,FALSE))) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\ccgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  ccgi.cxx
//
//  Contents:  This file contains the Computer Object's
//             GeneralInformation Functional Set.
//
//  History:   18-Jan-96     t-tpam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//
// Properties Get & Set
//

STDMETHODIMP CNWCOMPATComputer::get_ComputerID(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Site(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Description(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Description(THIS_ BSTR bstrDescription)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Location(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Location(THIS_ BSTR bstrLocation)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_PrimaryUser(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_PrimaryUser(THIS_ BSTR bstrPrimaryUser)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Owner(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Owner(THIS_ BSTR bstrOwner)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Division(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Division(THIS_ BSTR bstrDivision)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Department(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Department(THIS_ BSTR bstrDepartment)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Role(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Role(THIS_ BSTR bstrRole)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_OperatingSystem(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, OperatingSystem);
}

STDMETHODIMP CNWCOMPATComputer::put_OperatingSystem(THIS_ BSTR bstrOperatingSystem)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_OperatingSystemVersion(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, OperatingSystemVersion);
}

STDMETHODIMP CNWCOMPATComputer::put_OperatingSystemVersion(THIS_ BSTR bstrOperatingSystemVersion)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Model(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Model(THIS_ BSTR bstrModel)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Processor(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Processor(THIS_ BSTR bstrProcessor)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_ProcessorCount(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_ProcessorCount(THIS_ BSTR bstrProcessorCount)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_MemorySize(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_MemorySize(THIS_ BSTR bstrMemorySize)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_StorageCapacity(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_StorageCapacity(THIS_ BSTR bstrStorageCapacity)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_NetAddresses(THIS_ VARIANT FAR* retval)
{
    // see comment in ccomp.cxx/CNWCOMPATComputer::GetProperty_Addresses
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
    
}

STDMETHODIMP CNWCOMPATComputer::put_NetAddresses(THIS_ VARIANT vNetAddresses)
{
    // see comment in ccomp.cxx/CNWCOMPATComputer::GetProperty_Addresses
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\ccache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ccache.cxx
//
//  Contents:     Class Cache functionality for the NwCompat Provider
//
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"


HRESULT
SetLPTSTRPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR pszValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)pszValue,
                    1,
                    NT_SYNTAX_ID_LPTSTR,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetDWORDPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    DWORD  dwValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&dwValue,
                    1,
                    NT_SYNTAX_ID_DWORD,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetDATEPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    DWORD  dwValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&dwValue,
                    1,
                    NT_SYNTAX_ID_DATE,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetBOOLPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    BOOL  fValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&fValue,
                    1,
                    NT_SYNTAX_ID_BOOL,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

HRESULT
SetOctetPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    BYTE *pByte,
    DWORD dwLength,
    BOOL fExplicit
    )
{
    HRESULT hr;
    OctetString octString;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    octString.pByte = pByte;
    octString.dwSize = dwLength;

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&octString,
                    1,
                    NT_SYNTAX_ID_OCTETSTRING,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetSYSTEMTIMEPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    SYSTEMTIME stValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&stValue,
                    1,
                    NT_SYNTAX_ID_SYSTEMTIME,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetDelimitedStringPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR pszValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)pszValue,
                    1,
                    NT_SYNTAX_ID_DelimitedString,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetNulledStringPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR pszValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)pszValue,
                    1,
                    NT_SYNTAX_ID_NulledString,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);

}


HRESULT
GetPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPBYTE pValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);

    hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    pValue
                    );
    BAIL_ON_FAILURE(hr);

error:
    if (pNTObject)
        NTTypeFreeNTObjects(pNTObject, dwNumValues);
    RRETURN (hr);
}


HRESULT
GetLPTSTRPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR * ppszValue
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)ppszValue);
    RRETURN(hr);
}


HRESULT
GetDelimitedStringPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR * ppszValue
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)ppszValue);
    RRETURN (hr);
}


HRESULT
GetNulledStringPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR * ppszValue
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)ppszValue);
    RRETURN(hr);
}


HRESULT
GetBOOLPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    PBOOL pBool
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)pBool);
    RRETURN(hr);
}

HRESULT
GetOctetPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    OctetString *pOctet)
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)pOctet);
    RRETURN(hr);
}

HRESULT
GetDWORDPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPDWORD pdwDWORD
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)pdwDWORD);
    RRETURN(hr);
}


HRESULT
GetDATEPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    PDWORD pdwDate
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)pdwDate);
    RRETURN(hr);
}


HRESULT
GetNw312DATEPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    BYTE byDateTime[]
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);

    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)byDateTime
                    );
    }

error:
    if (pNTObject)
        NTTypeFreeNTObjects(pNTObject, dwNumValues);
    RRETURN (hr);
}


HRESULT
SetNw312DATEPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    BYTE byDateTime[],
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)byDateTime,
                    1,
                    NT_SYNTAX_ID_NW312DATE,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\ccomp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  ccomp.cxx
//
//  Contents:
//
//  History:   11-1-96     t-ptam    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

DEFINE_IDispatch_ExtMgr_Implementation(CNWCOMPATComputer)
DEFINE_IADs_TempImplementation(CNWCOMPATComputer)

DEFINE_IADs_PutGetImplementation(CNWCOMPATComputer, ComputerClass,gdwComputerTableSize)

DEFINE_IADsPropertyList_Implementation(CNWCOMPATComputer, ComputerClass, gdwComputerTableSize)


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::CNWCOMPATComputer
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATComputer::CNWCOMPATComputer():
                _pDispMgr(NULL),
                _pExtMgr(NULL),
                _pPropertyCache(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CNWCOMPATComputer);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::~CNWCOMPATComputer
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATComputer::~CNWCOMPATComputer( )
{
    if (_pExtMgr) {
        delete _pExtMgr;            // created last, destroyed first
    }
    if (_pDispMgr)
       delete _pDispMgr;
    if (_pPropertyCache)
        delete _pPropertyCache;
    VariantClear(&_vFilter);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::CreateComputer
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::CreateComputer(
    BSTR bstrParent,
    BSTR bstrComputerName,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATComputer FAR * pComputer = NULL;
    HRESULT hr = S_OK;

    hr = AllocateComputerObject(
             &pComputer
             );
    BAIL_ON_FAILURE(hr);

    hr = pComputer->InitializeCoreObject(
                        bstrParent,
                        bstrComputerName,
                        L"computer",
                        COMPUTER_SCHEMA_NAME,
                        CLSID_NWCOMPATComputer,
                        dwObjectState
                        );
    BAIL_ON_FAILURE(hr);

    hr = pComputer->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pComputer->Release();

    hr = pComputer->_pExtMgr->FinalInitializeExtensions();
    BAIL_ON_FAILURE(hr);

    RRETURN(hr);

error:
    delete pComputer;
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (!ppv) {
        RRETURN(E_POINTER);
    }

    //
    // Query.
    //

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsComputer))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
       *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsComputerOperations))
    {
        *ppv = (IADsComputerOperations FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(iid, ppv));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CNWCOMPATComputer::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsComputer) ||
        IsEqualIID(riid, IID_IADsComputerOperations) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//
// IADsContainer methods
//

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::get_Count
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::get_Count(long FAR* retval)
{
    //
    // Too expensive to implement in term of computer execution time.
    //

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::get_Filter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::put_Filter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNWCOMPATComputer::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATComputer::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    WCHAR szBuffer[MAX_PATH];
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    memset(szBuffer, 0, sizeof(szBuffer));

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"/");
    wcscat(szBuffer, RelativeName);

    if (ClassName && *ClassName) {
        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::get__NewEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IEnumVARIANT * penum = NULL;

    if (!retval) {
        RRETURN_EXP_IF_ERR(E_POINTER);
    }

    *retval = NULL;

    hr = CNWCOMPATComputerEnum::Create(
             (CNWCOMPATComputerEnum **)&penum,
             _ADsPath,
             _Name,
             _vFilter
             );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::Create
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    ULONG ObjectType = 0;
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;

    //
    // Translate ClassName into object type.
    //

    hr = GetObjectType(
              gpFilters,
              gdwMaxFilters,
              ClassName,
              (PDWORD)&ObjectType
              );
    BAIL_ON_FAILURE(hr);

    //
    // Build object info structure.
    //

    hr = BuildObjectInfo(
             _ADsPath,
             RelativeName,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);


    //
    // Create the object.
    //

    switch (ObjectType) {

    case NWCOMPAT_USER_ID:

         hr = CNWCOMPATUser::CreateUser(
                  _ADsPath,
                  NWCOMPAT_COMPUTER_ID,
                  _Name,
                  RelativeName,
                  ADS_OBJECT_UNBOUND,
                  IID_IDispatch,
                  (void **)ppObject
                  );
         BAIL_ON_FAILURE(hr);

         break;

    case NWCOMPAT_GROUP_ID:

         hr = CNWCOMPATGroup::CreateGroup(
                  _ADsPath,
                  NWCOMPAT_COMPUTER_ID,
                  _Name,
                  RelativeName,
                  ADS_OBJECT_UNBOUND,
                  IID_IDispatch,
                  (void **)ppObject
                  );
         BAIL_ON_FAILURE(hr);

         break;

    case NWCOMPAT_PRINTER_ID:

         hr = NWApiCreatePrinter(
                  pObjectInfo
                  );
         BAIL_ON_FAILURE(hr);

         hr = CNWCOMPATPrintQueue::CreatePrintQueue(
                  _ADsPath,
                  pObjectInfo->ComponentArray[1],
                  ADS_OBJECT_BOUND,
                  IID_IDispatch,
                  (void **)ppObject
                  );
         BAIL_ON_FAILURE(hr);

         break;

    default:

         hr = E_ADS_SCHEMA_VIOLATION;
         BAIL_ON_FAILURE(hr);
    }

error:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::Delete
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName)
{
    ULONG ObjectType = 0;

    POBJECTINFO pObjectInfo = NULL;
    HRESULT hr = S_OK;

    //
    // Translate ClassName into object type.
    //

    hr = GetObjectType(
             gpFilters,
             gdwMaxFilters,
             bstrClassName,
             (PDWORD)&ObjectType
             );
    BAIL_ON_FAILURE(hr);

    //
    // Build object info structure.
    //

    hr = BuildObjectInfo(
             _ADsPath,
             bstrRelativeName,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Delete the object.
    //

    switch (ObjectType) {

    case NWCOMPAT_USER_ID:

         hr = NWApiDeleteUser(
                  pObjectInfo
                  );
         BAIL_ON_FAILURE(hr);

         break;

    case NWCOMPAT_GROUP_ID:

         hr = NWApiDeleteGroup(
                  pObjectInfo
                  );
         BAIL_ON_FAILURE(hr);

         break;

    case NWCOMPAT_PRINTER_ID:

         hr = NWApiDeletePrinter(
                  pObjectInfo
                  );
         BAIL_ON_FAILURE(hr);
         break;

    default:

         hr = E_ADS_UNKNOWN_OBJECT;
         BAIL_ON_FAILURE(hr);
    }

error:

    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::CopyHere
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::MoveHere
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//
// IADs methods
//

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::SetInfo(THIS)
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::GetInfo(THIS)
{
    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(
                TRUE,
                COMP_WILD_CARD_ID
                ));
}


//
// IADsComputer methods
//


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::AllocateComputerObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::AllocateComputerObject(
    CNWCOMPATComputer ** ppComputer
    )
{
    CNWCOMPATComputer FAR * pComputer = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CADsExtMgr FAR * pExtensionMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a computer object.
    //

    pComputer = new CNWCOMPATComputer();
    if (pComputer == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsComputer,
             (IADsComputer *)pComputer,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsContainer,
             (IADsContainer *)pComputer,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPropertyList,
             (IADsPropertyList *)pComputer,
             DISPID_VALUE
             );
    BAIL_ON_FAILURE(hr);


    //
    // Create property cache
    //

    hr = CPropertyCache::createpropertycache(
             ComputerClass,
             gdwComputerTableSize,
             (CCoreADsObject *)pComputer,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                pPropertyCache
                );

    hr = ADSILoadExtensionManager(
                COMPUTER_CLASS_NAME,
                (IADsComputer *) pComputer,
                pDispMgr,
                &pExtensionMgr
                );
    BAIL_ON_FAILURE(hr);

    pComputer->_pPropertyCache = pPropertyCache;
    pComputer->_pDispMgr = pDispMgr;
    pComputer->_pExtMgr = pExtensionMgr;
    *ppComputer = pComputer;

    RRETURN(hr);

error:

    //
    // Note: pComputer->_pPropertyCache & pComputer->_pDispMgr are NULL
    //

    if (pComputer)
        delete pComputer;
    if (pPropertyCache)
        delete pPropertyCache;
    if (pDispMgr)
        delete pDispMgr;
    if (pExtensionMgr)
        delete  pExtensionMgr;
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::CreateObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::CreateObject(
    )
{
    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::GetInfo(
    BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // Get a handle to the bindery this computer object represents.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             _Name
             );
    BAIL_ON_FAILURE(hr);

    //
    // Fill in all property caches with values - explicit, or return the
    // indicated property - implicit.
    //

    if (fExplicit) {
       hr = ExplicitGetInfo(hConn, fExplicit);
       BAIL_ON_FAILURE(hr);
    }
    else {
       hr = ImplicitGetInfo(hConn, dwPropertyID, fExplicit);
       BAIL_ON_FAILURE(hr);
    }

error:

    if (hConn) {
       hrTemp = NWApiReleaseBinderyHandle(hConn);
    }
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::ExplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::ExplicitGetInfo(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    hr = GetProperty_Addresses(hConn, fExplicit);
    BAIL_ON_FAILURE(hr);

    hr = GetProperty_OperatingSystem(fExplicit);
    BAIL_ON_FAILURE(hr);

    hr = GetProperty_OperatingSystemVersion(hConn, fExplicit);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::ImplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::ImplicitGetInfo(
    NWCONN_HANDLE hConn,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    switch (dwPropertyID) {

    case COMP_ADDRESSES_ID:
         hr = GetProperty_Addresses(hConn, fExplicit);
         break;

    case COMP_OPERATINGSYSTEM_ID:
         hr = GetProperty_OperatingSystem(fExplicit);
         break;

    case COMP_OPERATINGSYSTEMVERSION_ID:
         hr = GetProperty_OperatingSystemVersion(hConn, fExplicit);
         break;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetProperty_Addresses
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::GetProperty_Addresses(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
//
// We don't (and have never) supported retrieving the NetAddresses property
// under NWCOMPAT, because of limitations in the property cache.  We don't support
// it in the WinNT provider, either.  Since we've never supported it, this is
// really a feature request, not a bug.  Given the general consensus not to add
// new features to the NWCOMPAT provider unless it is customer-requested, I'm
// #ifdef'ing out this code (since it doesn't serve any useful purpose, since it
// never puts anything in the cache), and changing the corresponding
// get_/put_NetAddresses functions in ccgi.cxx to reflect
// E_ADS_PROPERTY_NOT_SUPPORTED.  I'm leaving this code in place in case we do
// get a feature request for this, so we can use it as a start.
//
#if 0
    BSTR             bstrBuffer = NULL;
    DWORD            dwNumSegment;
    HRESULT          hr = S_OK;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL; // Used by DELETE_LIST macro below
    LPWSTR           lpszBuffer = NULL;
    VARIANT          vData;

    //
    // Get ADDRESSES.
    //

    hr = NWApiGetProperty(
             _Name,
             NW_PROP_NET_ADDRESS,
             OT_FILE_SERVER,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );
    BAIL_ON_FAILURE(hr);

    //
    // Put the addresses obtained in the format described in spec.
    //

    hr = NWApiConvertToAddressFormat(
             lpReplySegment,
             &lpszBuffer
             );
    BAIL_ON_FAILURE(hr);

    bstrBuffer = SysAllocString(lpszBuffer);
    if (!bstrBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    //    for now, Addresses is treated as a BSTR Variant instead of a
    //    variant array of bstr, as described in the spec.
    //

    VariantInit(&vData);
    V_VT(&vData) = VT_BSTR;
    V_BSTR(&vData) = bstrBuffer;

    //
    // Unmarshall.
    //

    //
    //  KrishnaG figure out how we're going to map this property
    //


    //
    // UM_PUT_VARIANT_PROPERTY(vData, _pGenInfo, Addresses, FALSE);
    //

    VariantClear(&vData);

error:
    if (lpReplySegment) {
       DELETE_LIST(lpReplySegment);
    }
    if (lpszBuffer) {
       FreeADsMem(lpszBuffer);
    }
    RRETURN(hr);
#else
    RRETURN(S_OK);
#endif
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetProperty_OperatingSystem
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::GetProperty_OperatingSystem(
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    
    //
    // As far as I can determine, Bindery does not provide a means of
    // retrieving the operating system in use on the server, only the OS
    // version (probably because when Bindery was designed, it only
    // ran on one OS, NetWare).  So we just assign the computer an OS
    // name of "NW3Compat".
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("OperatingSystem"),
                bstrComputerOperatingSystem,
                fExplicit
                );
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetProperty_OperatingSystemVersion
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::GetProperty_OperatingSystemVersion(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    LPWSTR      pszBuffer = NULL;
    CHAR         ch;
    HRESULT      hr = S_OK;
    VERSION_INFO VersionInfo;

    //
    // Get Version Information of a bindery.
    //

    hr = NWApiGetFileServerVersionInfo(
                hConn,
                &VersionInfo
                );
    if (SUCCEEDED(hr)) {

        //
        // Put Version & SubVersion in X.X format.
        //

        pszBuffer = (LPWSTR) AllocADsMem(
                                  (OS_VERSION_NUM_CHAR+1) * sizeof(WCHAR)
                                  );
        if (!pszBuffer) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        wsprintf(
            pszBuffer,
            L"%i.%02i",
            (WORD) VersionInfo.Version,
            (WORD) VersionInfo.SubVersion
            );

        //
        // Unmarshall.
        //

        hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("OperatingSystemVersion"),
                    pszBuffer,
                    fExplicit
                    );
        BAIL_ON_FAILURE(hr);
    }

    //
    // not a problem if NWApiGetFileServerVersionInfo failed, we
    // just ignore the property and go on
    //
    hr = S_OK;
    
error:
    if (pszBuffer) {
        FreeADsMem(pszBuffer);
    }

    RRETURN(hr);
}



STDMETHODIMP
CNWCOMPATComputer::Status(
    IDispatch * FAR * ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATComputer::Shutdown(
    VARIANT_BOOL bReboot
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//      multiple IDispatch-callable interfaces.
//
//  Classes:    CAggregatorDispMgr
//
//  Functions:  None external.
//
//  History:    ??-???-??   KrishnaG   created
//      07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//


#include "nwcompat.hxx"
#pragma hdrstop


//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//

#endif  // ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    End Non-ADSI compile stuff

//
// Error recovery.
//

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:    Simplified from Win4AssertEx, to make this dispatch manager
//          not depend on other files.
//
//----------------------------------------------------------------------------
static void
AggregatorAssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[200];
    DWORD dwCount = strlen("File: %s line %u, thread id %d");

    if (szFile) {
        dwCount += strlen(szFile);
    }

    dwCount += 15; // for the line number and thread id

    if (dwCount > 199) {
        sprintf(szAssertCaption, "Error, could not get more infomration");
    } 
    else {
        sprintf(szAssertCaption, "File: %s line %u, thread id %d",
                szFile, iLine, GetCurrentThreadId());
    }

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
        DebugBreak();
    }
}
# define AggregatorDispMgrAssert(x)  (void)((x) || (AggregatorAssertEx(__FILE__, __LINE__, #x),0))
#else
# define AggregatorAssertEx(f,l,m)
# define AggregatorDispMgrAssert(x)
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(LONG TypeInfoId, LONG DispId, DISPID *pResult)
{
    if (DispId == DISPID_UNKNOWN)
    *pResult = DispId;
    else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
    DispId < 0 || DispId >= 0x10000)
    {
    //
    // Might happen if some object has very large dispid's.
    // But we can't handle it if it does.
    //
    *pResult = DISPID_UNKNOWN;
    }
    else
    *pResult = ((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

}

static inline void
IncDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
    if (rgdispid[i] == DISPID_UNKNOWN)
        continue;

    //
    // This is either a stack of DispMgrs >127 high, or
    // a programming error.  More likely the latter.
    //
    AggregatorDispMgrAssert(getDispMgrId(rgdispid[i]) < 0x7f);

    rgdispid[i] =
        (rgdispid[i] & 0x00ffffff) |
        (((getDispMgrId(rgdispid[i]) + 1) & 0x7f) << 24);
    }
}

static inline void
DecDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
    //
    // It should never be less than zero, and the only place
    // this is called from guarantees it is not zero.
    //
    AggregatorDispMgrAssert(getDispMgrId(rgdispid[i]) > 0);

    rgdispid[i] =
        (rgdispid[i] & 0x00ffffff) |
        (((getDispMgrId(rgdispid[i]) - 1) & 0x7f) << 24);
    }
}

static inline void
MakeDISPIDs(LONG TypeInfoId, DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//
// Struct definitions
//
typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;


PTYPEINFO_TABLE gpTypeInfoTable = NULL;

CRITICAL_SECTION g_TypeInfoCritSect;

#define ENTER_TYPEINFO_CRITSECT()  EnterCriticalSection(&g_TypeInfoCritSect)
#define LEAVE_TYPEINFO_CRITSECT()  LeaveCriticalSection(&g_TypeInfoCritSect)

LONG glnObjCount = 0;
LONG glnTypesOfInfo = 0;

//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CAggregatorDispMgr::CAggregatorDispMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
}

CAggregatorDispMgr::~CAggregatorDispMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        InterlockedDecrement(&glnObjCount);

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

    ENTER_TYPEINFO_CRITSECT();

    if (glnObjCount == glnTypesOfInfo) {
        //
        // We need to clean up the list
        //
        FreeTypeInfoTable();

        glnObjCount = glnTypesOfInfo = 0;

    }
    LEAVE_TYPEINFO_CRITSECT();

}

void
CAggregatorDispMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}


STDMETHODIMP
CAggregatorDispMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregatorDispMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

//
// This works only for single names; if multiple names are
// passed we die big time. This is help us get going using VB's _NewEnum
//

STDMETHODIMP
CAggregatorDispMgr::GetIDsOfNames(
    REFIID iid,
    LPWSTR *rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID *rgdispid
    )
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
        hr = S_OK;
        for (DWORD dw = 0; dw < cNames; dw++) {
            if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
                (PDWORD)(rgdispid + dw)))) {
                    hr = DISP_E_UNKNOWNNAME;
                    rgdispid[dw] = DISPID_UNKNOWN;
            }
        }
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(_dwPropCacheID, rgdispid, cNames);
        }
    }

    return hr;
}

STDMETHODIMP
CAggregatorDispMgr::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CAggregatorDispMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CAggregatorDispMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CAggregatorDispMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CAggregatorDispMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CAggregatorDispMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr = S_OK;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

error:

    return hr;
}

STDMETHODIMP
CAggregatorDispMgr::TypeInfoInvoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

        //
        // One of the special DISPIDs.
        //
        // If we have an interface pointer for it, use that.
        // If we don't, and we have a base IDispatch pointer,
        //   pass it to the base pointer's Invoke() method.
        // If we don't, and we don't have a base IDispatch pointer,
        //   return failure.
        //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
        break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

        if (!pInterfacePtr) {

            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

        }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else {

        //                              
        // A regular DISPID of ours.
        //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
            pInterfacePtr = getInterfacePtr(typeinfoid);
            pTypeInfo = getTypeInfo(typeinfoid);
            if (!pTypeInfo)
                //
            // Shouldn't happen.
            //
            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
        }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = DynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

error:
    return hr;
}


HRESULT
DynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        //
        // ADSI property PUTs only take a single argument
        // (even multivalued properties are set with a single
        //  argument, a VARIANT array).  Therefore, if someone
        // is trying to get a multiple argument property PUT,
        // it's a invalid method call that must be disallowed.
        //

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

error:
    return(hr);

}


HRESULT
CAggregatorDispMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CAggregatorDispMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CAggregatorDispMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    AggregatorDispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}

ITypeInfo *
FindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}


PTYPEINFO_TABLE
AddTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid,
    ITypeInfo * pTypeInfo
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = (PTYPEINFO_TABLE)LocalAlloc(LPTR, sizeof(TYPEINFO_TABLE));
    if (!pTemp) {
        return NULL;
    }

    memcpy(&pTemp->iid, &iid, sizeof(GUID));
    pTemp->pTypeInfo = pTypeInfo;
    pTemp->pNext = pTypeInfoTable;

    return pTemp;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
LoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    AggregatorDispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (!SUCCEEDED(hr))
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CAggregatorDispMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    ENTER_TYPEINFO_CRITSECT();

    pTypeInfo = ::FindTypeInfo(gpTypeInfoTable, iid);

    if (!pTypeInfo) {

        LEAVE_TYPEINFO_CRITSECT();
        hr = LoadTypeInfo(libid, iid, &pTypeInfo);
        BAIL_ON_FAILURE(hr);

        ENTER_TYPEINFO_CRITSECT();

        gpTypeInfoTable = ::AddTypeInfo(
                                gpTypeInfoTable,
                                iid,
                                pTypeInfo
                                );

        if (!gpTypeInfoTable) {
            LEAVE_TYPEINFO_CRITSECT();
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        //
        // Increment the global list of the types of type info's.
        //
        InterlockedIncrement(&glnTypesOfInfo);

        InterlockedIncrement(&glnObjCount);

    }
    pTypeInfo->AddRef();


    hr = AddTypeInfo(pTypeInfo, pIntf);

    if (FAILED(hr)) {
        LEAVE_TYPEINFO_CRITSECT();
        BAIL_ON_FAILURE(hr);
    }

    //
    // We have a ref on the object as add was succesful
    //
    InterlockedIncrement(&glnObjCount);

    LEAVE_TYPEINFO_CRITSECT();

    if (SpecialId == -4) {
        hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
        hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

error:
    if (pTypeInfo)
        pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CAggregatorDispMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

void
FreeTypeInfoTable()
{
    PTYPEINFO_TABLE pTypeInfoTable = NULL;
    PTYPEINFO_TABLE pTemp = NULL;
    ITypeInfo * pTypeInfo = NULL;

    pTypeInfoTable = gpTypeInfoTable;

    while (pTypeInfoTable) {

        pTypeInfo = pTypeInfoTable->pTypeInfo;

        pTypeInfo->Release();


        pTemp = pTypeInfoTable;

        pTypeInfoTable = pTypeInfoTable->pNext;

        LocalFree(pTemp);
    }

    gpTypeInfoTable = NULL;
}

BOOL
AggregatorDllCanUnload()
{
    BOOL retVal = FALSE;

    ENTER_TYPEINFO_CRITSECT();
    retVal = (glnObjCount == 0);
    LEAVE_TYPEINFO_CRITSECT();

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cenumjob.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      cenumjob.cxx
//
//  Contents:  NetWare 3.12 JobCollection Enumeration Code
//
//              CNWCOMPATJobCollectionEnum::Create
//              CNWCOMPATJobCollectionEnum::GetJobObject
//              CNWCOMPATJobCollectionEnum::EnumJobMembers
//              CNWCOMPATJobCollectionEnum::Next
//
//  History:   08-May-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    08-Mag-96   t-ptam (Patrick Tam)     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATJobCollectionEnum::Create(
    CNWCOMPATJobCollectionEnum FAR* FAR* ppEnumVariant,
    BSTR PrinterName
    )
{
    HRESULT hr = S_OK;
    CNWCOMPATJobCollectionEnum FAR* pEnumVariant = NULL;
    POBJECTINFO pPrinterObjectInfo = NULL;
    WCHAR szUncPrinterName[MAX_PATH];

    //
    // Validate input parameters.
    //

    if (!(ppEnumVariant) || !(PrinterName)) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    *ppEnumVariant = NULL;

    //
    // Allocate a Collection Enumerator object.
    //

    pEnumVariant = new CNWCOMPATJobCollectionEnum();
    if (!pEnumVariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString(PrinterName, &pEnumVariant->_PrinterName);
    BAIL_ON_FAILURE(hr);

    //
    // Make Unc Name to open a printer.
    //

    hr = BuildObjectInfo(
             PrinterName,
             &pPrinterObjectInfo 
             );

    BAIL_ON_FAILURE(hr);

    ADsAssert(pPrinterObjectInfo->NumComponents == 2);

    wcscpy(PrinterName,
           pPrinterObjectInfo->ComponentArray[0]);

    MakeUncName (PrinterName,
                 szUncPrinterName);

    wcscat(szUncPrinterName,TEXT("\\"));
    wcscat(szUncPrinterName, pPrinterObjectInfo->ComponentArray[1]);

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &pEnumVariant->_hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    *ppEnumVariant = pEnumVariant;

    if(pPrinterObjectInfo){
        FreeObjectInfo(pPrinterObjectInfo);
    }
    RRETURN(hr);

error:
  if(pPrinterObjectInfo){
      FreeObjectInfo(pPrinterObjectInfo);
  }
    delete pEnumVariant;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollectionEnum::CNWCOMPATJobCollectionEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATJobCollectionEnum::CNWCOMPATJobCollectionEnum():
        _PrinterName(NULL),
        _hPrinter(NULL),
        _pBuffer(NULL),
        _dwReturned(0),
        _dwCurrentObject(0)
{
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollectionEnum::~CNWCOMPATJobCollectionEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATJobCollectionEnum::~CNWCOMPATJobCollectionEnum()
{
    if (_PrinterName) {
        SysFreeString(_PrinterName);
    }

    if (_hPrinter) {
        NWApiClosePrinter(_hPrinter);
    }

    if (_pBuffer) {
        FreeADsMem(_pBuffer);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollectionEnum::EnumJobMembers
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATJobCollectionEnum::EnumJobMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetJobObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollectionEnum::GetJobObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATJobCollectionEnum::GetJobObject(
    IDispatch ** ppDispatch
    )
{
    DWORD        dwBuf = 0;
    DWORD        dwJobInQueue = 0;
    HRESULT      hr = S_OK;
    LPBYTE       lpbPrinterInfo = NULL;
    LPJOB_INFO_1 lpJobInfo = NULL;

    //
    // Fill _pBuffer with JobID.  Win32 API returns all jobs in one shot.
    //

    if (!_pBuffer) {

        //
        // Get the number of print jobs that have been queued for the printer.
        //

        hr = NWApiGetPrinter(
                 _hPrinter,
                 WIN32_API_LEVEL_2,
                 &lpbPrinterInfo
                 );
        BAIL_ON_FAILURE(hr);

        dwJobInQueue = ((LPPRINTER_INFO_2)lpbPrinterInfo)->cJobs;

        //
        // Enumerate for all the jobs.
        //

        hr = NWApiEnumJobs(
                 _hPrinter,
                 FIRST_PRINTJOB,
                 dwJobInQueue,
                 WIN32_API_LEVEL_1,
                 &_pBuffer,
                 &dwBuf,
                 &_dwReturned
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Traverse the buffer and return a PrintJob object.
    //

    if (_dwCurrentObject < _dwReturned) {

        //
        // Go to the next structure in the buffer.
        //

        lpJobInfo = (LPJOB_INFO_1)_pBuffer + _dwCurrentObject;

        //
        // Create a print job object.
        //

        hr = CNWCOMPATPrintJob::CreatePrintJob(
                 _PrinterName,
                 lpJobInfo->JobId,
                 ADS_OBJECT_BOUND,
                 IID_IDispatch,
                 (void **)ppDispatch
                 );
        BAIL_ON_FAILURE(hr);

        //
        // Return.
        //

        _dwCurrentObject++;
        
        if(lpbPrinterInfo){
            FreeADsMem(lpbPrinterInfo);
        }
        RRETURN(S_OK);
    }

error:
       
    if(lpbPrinterInfo){
        FreeADsMem(lpbPrinterInfo);
    }

    *ppDispatch = NULL;

    RRETURN(S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATJobCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumJobMembers(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cenumgrp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  NetWare 3.12 GroupCollection Enumeration Code
//
//              CNWCOMPATGroupCollectionEnum::
//              CNWCOMPATGroupCollectionEnum::
//              CNWCOMPATGroupCollectionEnum::
//              CNWCOMPATGroupCollectionEnum::
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroupCollectionEnum::Create(
    CNWCOMPATGroupCollectionEnum FAR* FAR* ppenumvariant,
    BSTR Parent,
    ULONG ParentType,
    BSTR ADsPath,
    BSTR ServerName,
    BSTR GroupName,
    VARIANT var
    )
{
    HRESULT hr = NOERROR;
    CNWCOMPATGroupCollectionEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CNWCOMPATGroupCollectionEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString(Parent, &penumvariant->_Parent);
    BAIL_ON_FAILURE(hr);

    penumvariant->_ParentType = ParentType;

    hr = ADsAllocString( ServerName, &penumvariant->_ServerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( GroupName, &penumvariant->_GroupName);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
                    var,
                    &penumvariant->_pObjList
                    );
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroupCollectionEnum::CNWCOMPATGroupCollectionEnum():
        _Parent(NULL),
        _ParentType(0),
        _ADsPath(NULL),
        _ServerName(NULL),
        _GroupName(NULL),
        _hGroup(NULL)
{
    _pObjList = NULL;
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroupCollectionEnum::~CNWCOMPATGroupCollectionEnum()
{
    if (_pObjList)
        delete _pObjList;
    if (_Parent)
        SysFreeString(_Parent);
    if (_ADsPath)
        SysFreeString(_ADsPath);
    if (_ServerName)
        SysFreeString(_ServerName);
    if (_GroupName)
        SysFreeString(_GroupName);
    if (_hGroup)
        NWCOMPATComputerGroupClose(_hGroup);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroupCollectionEnum::EnumGroupMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetUserMemberObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroupCollectionEnum::GetUserMemberObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPCOMPUTER_GROUP_MEMBER pComputerGrpMember = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;


    if (!_hGroup) {
        dwRet = NWCOMPATComputerGroupOpen(
                    _ServerName,
                    _GroupName,
                    &_hGroup
                    );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = NWCOMPATComputerGroupEnum(
                _hGroup,
                1,
                &pBuffer,
                &dwReturned
                );
    if (!dwRet) {
        goto error;
    }

    pComputerGrpMember = (LPCOMPUTER_GROUP_MEMBER)pBuffer;

    hr = CNWCOMPATUser::CreateUser(
                            pComputerGrpMember->Parent,
                            NWCOMPAT_COMPUTER_ID,
                            pComputerGrpMember->Computer,
                            pComputerGrpMember->Name,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
    BAIL_ON_FAILURE(hr);

    hr = S_OK;

cleanup:

    if (pBuffer) {
        FreeADsMem(pBuffer);
    }

    RRETURN(hr);

error:
    *ppDispatch = NULL;

    hr = S_FALSE;

    goto cleanup;

}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATGroupCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGroupMembers(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cenumcom.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cenumcom.cxx
//
//  Contents:  NetWare 3.12 Path Object code
//
//              CNWCOMPATComputerEnum::
//              CNWCOMPATComputerEnum::
//              CNWCOMPATComputerEnum::
//              CNWCOMPATComputerEnum::
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   t-ptam     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::Create(
    CNWCOMPATComputerEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    BSTR ComputerName,
    VARIANT var
    )
{
    HRESULT hr = NOERROR;
    CNWCOMPATComputerEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    //
    // Allocate memory for an enumerator.
    //

    penumvariant = new CNWCOMPATComputerEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Save protected values.
    //

    hr = ADsAllocString(ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ComputerName,  &penumvariant->_ComputerName);
    BAIL_ON_FAILURE(hr);

    hr = NWApiGetBinderyHandle(
             &penumvariant->_hConn,
             ComputerName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Make object list.
    //

    hr = ObjectTypeList::CreateObjectTypeList(
             var,
             &penumvariant->_pObjList
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::CNWCOMPATComputerEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATComputerEnum::CNWCOMPATComputerEnum():
                        _ComputerName(NULL),
                        _ADsPath(NULL)
{
    _hConn = NULL;
    _pObjList = NULL;

    _dwUserResumeObjectID = 0xffffffff;
    _dwGroupResumeObjectID = 0xffffffff;
    _dwPrinterResumeObjectID = 0xffffffff;
    _fFileServiceOnce = FALSE;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::~CNWCOMPATComputerEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATComputerEnum::~CNWCOMPATComputerEnum()
{
    if (_ComputerName)
        SysFreeString(_ComputerName);
    if (_ADsPath)
        SysFreeString(_ADsPath);
    if (_pObjList)
        delete _pObjList;
    if (_hConn)
        NWApiReleaseBinderyHandle(_hConn);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumObjects
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    switch (ObjectType) {

    case NWCOMPAT_USER_ID:
        return(EnumUsers( cElements, pvar, pcElementFetched));

    case NWCOMPAT_GROUP_ID:
        return(EnumGroups( cElements, pvar, pcElementFetched));

    case NWCOMPAT_SERVICE_ID:
        return(EnumFileServices(cElements, pvar, pcElementFetched));

    case NWCOMPAT_PRINTER_ID:
        return(EnumPrinters(cElements, pvar, pcElementFetched));

    default:
        return(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumObjects
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while (SUCCEEDED(_pObjList->GetCurrentObject(&ObjectType)) &&
          ((hr = EnumObjects(
                     ObjectType,
                     cRequested,
                     pPathvar,
                     &cFetchedByPath)) == S_FALSE )) {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (FAILED(_pObjList->Next())){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            return(ResultFromScode(S_FALSE));
        }
    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumUsers
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumUsers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetUserObject(&pDispatch);

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::GetUserObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::GetUserObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT    hr = S_OK;
    LPTSTR     pszObjectName = NULL;

    *ppDispatch = NULL;

    hr = NWApiObjectEnum(
             _hConn,
             OT_USER,
             &pszObjectName,
             &_dwUserResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now send back the current object
    //

    hr = CNWCOMPATUser::CreateUser(
             _ADsPath,
             NWCOMPAT_COMPUTER_ID,
             _ComputerName,
             pszObjectName,
             ADS_OBJECT_BOUND,
             IID_IDispatch,
             (void **)ppDispatch
             );
    BAIL_ON_FAILURE(hr);

error:
    if (pszObjectName) {
        FreeADsStr(pszObjectName);
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumGroups
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetGroupObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::GetGroupObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::GetGroupObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPTSTR  pszObjectName = NULL;

    *ppDispatch = NULL;

    hr = NWApiObjectEnum(
             _hConn,
             OT_USER_GROUP,
             &pszObjectName,
             &_dwGroupResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now send back the current ovbject
    //

    hr = CNWCOMPATGroup::CreateGroup(
             _ADsPath,
             NWCOMPAT_COMPUTER_ID,
             _ComputerName,
             pszObjectName,
             ADS_OBJECT_BOUND,
             IID_IDispatch,
             (void **)ppDispatch
             );
    BAIL_ON_FAILURE(hr);

error:
    if (pszObjectName) {
        FreeADsStr(pszObjectName);
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumFileServices
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumFileServices(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetFileServiceObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::GetFileServiceObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::GetFileServiceObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // This is a NetWare provider specific condition.  Since a FileService
    // object on a bindery (computer) is the bindery itself, therefore there is
    // always one FileService object only.  And therefore this function is
    // called only once.
    //

    if (!_fFileServiceOnce) {

        _fFileServiceOnce = TRUE;

        //
        // Create a file service object with the Hard coded name.
        //

        hr = CNWCOMPATFileService::CreateFileService(
                 _ADsPath,
                 _ComputerName,
                 bstrNWFileServiceName,
                 ADS_OBJECT_BOUND,
                 IID_IDispatch,
                 (void **)ppDispatch
                 );

        RRETURN_ENUM_STATUS(hr);
    }
    else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumPrinters
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumPrinters(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetPrinterObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::GetPrinterObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::GetPrinterObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPTSTR    pszObjectName = NULL;

    *ppDispatch = NULL;

    hr = NWApiObjectEnum(
             _hConn,
             OT_PRINT_QUEUE,
             &pszObjectName,
             &_dwPrinterResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now send back the current ovbject
    //

    hr = CNWCOMPATPrintQueue::CreatePrintQueue(
             _ADsPath,
             pszObjectName,
             ADS_OBJECT_BOUND,
             IID_IDispatch,
             (void **)ppDispatch
             );
    BAIL_ON_FAILURE(hr);

error:
    if (pszObjectName) {
        FreeADsStr(pszObjectName);
    }

    RRETURN_ENUM_STATUS(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATComputerEnum::Next
//
//  Synopsis:   Returns cElements number of requested ADs objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputerEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects(
             cElements,
             pvar,
             &cElementFetched
             );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cenumfs.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumfs.cxx
//
//  Contents:  NetWare 3.X Enumerator Code
//
//             CNWCOMPATFileServiceEnum::Create
//             CNWCOMPATFileServiceEnum::CNWCOMPATFileServiceEnum
//             CNWCOMPATFileServiceEnum::~CNWCOMPATFileServiceEnum
//             CNWCOMPATFileServiceEnum::Next
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileServiceEnum::Create
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileServiceEnum::Create(
    CNWCOMPATFileServiceEnum FAR* FAR* ppEnumVariant,
    BSTR ADsPath,
    BSTR bstrServerName
    )
{
    HRESULT hr = S_OK;
    CNWCOMPATFileServiceEnum FAR* pEnumVariant = NULL;

    pEnumVariant = new CNWCOMPATFileServiceEnum();
    if (pEnumVariant == NULL){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Get a handle to the bindery (FileServer) that is going to be enumerated
    // on.
    //

    hr = NWApiGetBinderyHandle(
             &pEnumVariant->_hConn,
             bstrServerName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get FileServer VersionInfo.  The Version Info structure has the maximum
    // number of volumes.
    //

    hr = NWApiGetFileServerVersionInfo(
             pEnumVariant->_hConn,
             &pEnumVariant->_FileServerInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Save ADsPath.
    //

    hr = ADsAllocString(ADsPath, &pEnumVariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    *ppEnumVariant = pEnumVariant;

    RRETURN(hr);

error:
    delete pEnumVariant;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileServiceEnum::CNWCOMPATFileServiceEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileServiceEnum::CNWCOMPATFileServiceEnum():

    _ADsPath(NULL),
    _bResumeVolumeID(0),
    _hConn(NULL)
{
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileServiceEnum::~CNWCOMPATFileServiceEnum()
{
    if (_ADsPath)
        SysFreeString(_ADsPath);
    if (_hConn)
        NWApiReleaseBinderyHandle(_hConn);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileServiceEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumFileShares(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileServiceEnum::EnumFileShares
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileServiceEnum::EnumFileShares(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetFileShareObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    return(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileServiceEnum::GetFileShareObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileServiceEnum::GetFileShareObject(
    IDispatch ** ppDispatch
    )
{
    LPTSTR    pszObjectName = NULL;
    HRESULT hr = S_OK;

    *ppDispatch = NULL;

    //
    // Since Volume Number of defined Volume doesn't necessarily exist in
    // consecutive chunk, a loop is needed to skip all the "holes".
    //

    while (_bResumeVolumeID < _FileServerInfo.maxVolumes) {

        //
        // Get the name of the next Volume.
        //

        hr = NWApiGetVolumeName(
                 _hConn,
                 _bResumeVolumeID,
                 &pszObjectName
                 );
        BAIL_ON_FAILURE(hr);

        if (wcscmp(pszObjectName, L"")) {

            break;
        }
        else {

            _bResumeVolumeID++;
        }

        if (pszObjectName){
            FreeADsStr(pszObjectName);
            pszObjectName = NULL;
        }
    }

    //
    // Check if the last volume was reached already.
    //

    if (_bResumeVolumeID >= _FileServerInfo.maxVolumes) {
        RRETURN(S_FALSE);
    }

    //
    // Create a FileShare object.
    //

    hr = CNWCOMPATFileShare::CreateFileShare(
             _ADsPath,
             pszObjectName,
             ADS_OBJECT_BOUND,
             IID_IDispatch,
             (void **)ppDispatch
             );
    BAIL_ON_FAILURE(hr);

    //
    // Increase the current volume number.
    //

    _bResumeVolumeID++;

    //
    // Return.
    //

error:
    if (pszObjectName) {
       FreeADsStr(pszObjectName);
    }

    RRETURN_ENUM_STATUS(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cenumsch.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumsch.cxx
//
//  Contents:  Windows NT 3.5 Schema Enumeration Code
//
//             CNWCOMPATSchemaEnum::CNWCOMPATSchemaEnum()
//             CNWCOMPATSchemaEnum::CNWCOMPATSchemaEnum
//             CNWCOMPATSchemaEnum::EnumObjects
//             CNWCOMPATSchemaEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATSchemaEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATSchemaEnum::Create(
    CNWCOMPATSchemaEnum FAR* FAR* ppenumvariant,
    BSTR bstrADsPath,
    BSTR bstrName,
    VARIANT vFilter
    )
{
    HRESULT hr = S_OK;
    CNWCOMPATSchemaEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CNWCOMPATSchemaEnum();
    if (!penumvariant)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( bstrADsPath, &penumvariant->_bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrName, &penumvariant->_bstrName);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
            vFilter,
            &penumvariant->_pObjList );
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CNWCOMPATSchemaEnum::CNWCOMPATSchemaEnum()
    : _bstrADsPath( NULL ),
      _bstrName( NULL ),
      _pObjList( NULL ),
      _dwCurrentEntry( 0 ),
      _dwPropCurrentEntry( 0 )
{
}

CNWCOMPATSchemaEnum::~CNWCOMPATSchemaEnum()
{
   ADsFreeString( _bstrName );
   ADsFreeString( _bstrADsPath );

   if ( _pObjList != NULL )
   {
       delete _pObjList;
       _pObjList = NULL;
   }
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATSchemaEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   yihsins     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATSchemaEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects( cElements,
                      pvar,
                      &cElementFetched );

    if ( pcElementFetched )
        *pcElementFetched = cElementFetched;

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNWCOMPATSchemaEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    switch (ObjectType)
    {
        case NWCOMPAT_CLASS_ID:
            RRETURN (EnumClasses(cElements, pvar, pcElementFetched));


        case NWCOMPAT_PROPERTY_ID:
            RRETURN (EnumProperties(cElements, pvar, pcElementFetched));

        case NWCOMPAT_SYNTAX_ID:
            RRETURN(EnumSyntaxObjects(cElements, pvar, pcElementFetched));

        default:
            RRETURN(S_FALSE);
    }
}

HRESULT
CNWCOMPATSchemaEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)
        VariantInit(&pvar[i]);

    cRequested = cElements;

    while (  SUCCEEDED( _pObjList->GetCurrentObject(&ObjectType))
          && ((hr = EnumObjects( ObjectType,
                                 cRequested,
                                 pPathvar,
                                 &cFetchedByPath)) == S_FALSE )
          )
    {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if ( FAILED(_pObjList->Next()) )
        {
            if ( pcElementFetched )
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

        _dwCurrentEntry = 0;
    }

    if ( pcElementFetched )
        *pcElementFetched = cTotalFetched + cFetchedByPath;

    RRETURN(hr);
}

HRESULT
CNWCOMPATSchemaEnum::EnumClasses(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetClassObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNWCOMPATSchemaEnum::GetClassObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current ovbject
    //
    if ( _dwCurrentEntry >= g_cNWCOMPATClasses )
        goto error;

    hr = CNWCOMPATClass::CreateClass(
                        _bstrADsPath,
                        &g_aNWCOMPATClasses[_dwCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}

HRESULT
CNWCOMPATSchemaEnum::EnumSyntaxObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetSyntaxObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNWCOMPATSchemaEnum::GetSyntaxObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current object
    //
    if ( _dwCurrentEntry >= g_cNWCOMPATSyntax )
        goto error;

    hr = CNWCOMPATSyntax::CreateSyntax(
                        _bstrADsPath,
                        &g_aNWCOMPATSyntax[_dwCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}


HRESULT
CNWCOMPATSchemaEnum::EnumProperties(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetPropertyObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNWCOMPATSchemaEnum::GetPropertyObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current ovbject
    //
    if ( _dwPropCurrentEntry >= g_cNWCOMPATProperties )
        goto error;

    hr = CNWCOMPATProperty::CreateProperty(
                        _bstrADsPath,
                        &g_aNWCOMPATProperties[_dwPropCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwPropCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cenumusr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  NetWare 3.12 GroupCollection Enumeration Code
//
//              CNWCOMPATUserCollectionEnum::
//              CNWCOMPATUserCollectionEnum::
//              CNWCOMPATUserCollectionEnum::
//              CNWCOMPATUserCollectionEnum::
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUserCollectionEnum::Create(
    CNWCOMPATUserCollectionEnum FAR* FAR* ppenumvariant,
    BSTR Parent,
    ULONG ParentType,
    BSTR ADsPath,
    BSTR ServerName,
    BSTR UserName,
    VARIANT var
    )
{
    HRESULT hr = NOERROR;
    CNWCOMPATUserCollectionEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CNWCOMPATUserCollectionEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( Parent , &penumvariant->_Parent);
    BAIL_ON_FAILURE(hr);

    penumvariant->_ParentType = ParentType;

    hr = ADsAllocString(ServerName , &penumvariant->_ServerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( UserName , &penumvariant->_UserName);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( ADsPath , &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
                    var,
                    &penumvariant->_pObjList
                    );
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUserCollectionEnum::CNWCOMPATUserCollectionEnum():
        _Parent(NULL),
        _ParentType(0),
        _ADsPath(NULL),
        _ServerName(NULL),
        _UserName(NULL),
        _hUser(NULL)
{
    _pObjList = NULL;
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUserCollectionEnum::~CNWCOMPATUserCollectionEnum()
{
    if (_pObjList)
        delete _pObjList;
    if (_Parent)
        SysFreeString(_Parent);
    if (_ADsPath)
        SysFreeString(_ADsPath);
    if (_ServerName)
        SysFreeString(_ServerName);
    if (_UserName)
        SysFreeString(_UserName);
    if (_hUser)
        NWCOMPATComputerUserClose(_hUser);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUserCollectionEnum::EnumGroupMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetUserMemberObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUserCollectionEnum::GetUserMemberObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPUSER_GROUP_ENTRY pComputerGrpMember = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;


    if (!_hUser) {
        dwRet = NWCOMPATComputerUserOpen(
                    _ServerName,
                    _UserName,
                    &_hUser
                    );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = NWCOMPATComputerUserEnum(
                _hUser,
                1,
                &pBuffer,
                &dwReturned
                );
    if (!dwRet) {
        goto error;
    }

    pComputerGrpMember = (LPUSER_GROUP_ENTRY)pBuffer;

    hr = CNWCOMPATGroup::CreateGroup(
                            pComputerGrpMember->Parent,
                            NWCOMPAT_COMPUTER_ID,
                            pComputerGrpMember->Computer,
                            pComputerGrpMember->Name,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
    BAIL_ON_FAILURE(hr);

    RRETURN(S_OK);

error:
    *ppDispatch = NULL;

    RRETURN(S_FALSE);

}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATUserCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGroupMembers(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cenumns.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumvar.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//             CNWCOMPATNamespaceEnum::Create
//             CNWCOMPATNamespaceEnum::CNWCOMPATNamespaceEnum
//             CNWCOMPATNamespaceEnum::~CNWCOMPATNamespaceEnum
//             CNWCOMPATNamespaceEnum::QueryInterface
//             CNWCOMPATNamespaceEnum::AddRef
//             CNWCOMPATNamespaceEnum::Release
//             CNWCOMPATNamespaceEnum::Next
//             CNWCOMPATNamespaceEnum::Skip
//             CNWCOMPATNamespaceEnum::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATNamespaceEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATNamespaceEnum::Create(
    CNWCOMPATNamespaceEnum FAR* FAR* ppenumvariant
    )
{
    HRESULT hr = S_OK;
    CNWCOMPATNamespaceEnum FAR* penumvariant = NULL;

    penumvariant = new CNWCOMPATNamespaceEnum();

    if (penumvariant == NULL){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = NWApiGetAnyBinderyHandle(
             &penumvariant->_hConn
             );

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    if (penumvariant) {
        delete penumvariant;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATNamespaceEnum::CNWCOMPATNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNWCOMPATNamespaceEnum::CNWCOMPATNamespaceEnum()
{
    _dwResumeObjectID = 0xffffffff;
    _hConn = NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATNamespaceEnum::~CNWCOMPATNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNWCOMPATNamespaceEnum::~CNWCOMPATNamespaceEnum()
{
    if (_hConn) {
        NWApiReleaseBinderyHandle(_hConn);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATNamespaceEnum::Next
//
//  Synopsis:   Returns cElements number of requested ADs objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATNamespaceEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumComputers(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATNamespaceEnum::EnumComputers
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CNWCOMPATNamespaceEnum::EnumComputers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetComputerObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATNamespaceEnum::GetComputerObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CNWCOMPATNamespaceEnum::GetComputerObject(
    IDispatch ** ppDispatch
    )
{
    LPWSTR    pszObjectName = NULL;
    HRESULT hr = S_OK;

    *ppDispatch = NULL;

    hr = NWApiObjectEnum(
             _hConn,
             OT_FILE_SERVER,
             &pszObjectName,
             &_dwResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now send back the current object
    //

    hr = CNWCOMPATComputer::CreateComputer(
                                bstrProviderPrefix,
                                pszObjectName,
                                ADS_OBJECT_BOUND,
                                IID_IDispatch,
                                (void **)ppDispatch
                                );
    BAIL_ON_FAILURE(hr);

error:
    if (pszObjectName) {
       FreeADsStr(pszObjectName);
    }

    RRETURN_ENUM_STATUS(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cfsgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfsvgeni.cxx
//
//  Contents:
//
//  History:   April 19, 1996     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop

//
// Properties Get & Set.
//

STDMETHODIMP
CNWCOMPATFileService::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, Description);
}

STDMETHODIMP
CNWCOMPATFileService::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, Description);
}

STDMETHODIMP
CNWCOMPATFileService::get_MaxUserCount(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileService *)this, MaxUserCount);
}

STDMETHODIMP
CNWCOMPATFileService::put_MaxUserCount(THIS_ long lMaxUserCount)
{
    PUT_PROPERTY_LONG((IADsFileService *)this, MaxUserCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cfshgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cfshgi.cxx
//
//  Contents:  This file contains the FileShare Object's GeneralInformation
//             Functional Set.
//
//  History:   25-Apr-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
// Macro-ized implementation.
//


STDMETHODIMP
CNWCOMPATFileShare::get_CurrentUserCount(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileShare *)this, CurrentUserCount);
}

STDMETHODIMP
CNWCOMPATFileShare::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileShare *)this, Description);
}

STDMETHODIMP
CNWCOMPATFileShare::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsFileShare *)this, Description);
}

STDMETHODIMP
CNWCOMPATFileShare::get_HostComputer(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileShare *)this, HostComputer);
}

STDMETHODIMP
CNWCOMPATFileShare::put_HostComputer(THIS_ BSTR bstrHostComputer)
{
    PUT_PROPERTY_BSTR((IADsFileShare *)this, HostComputer);
}

STDMETHODIMP
CNWCOMPATFileShare::get_Path(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileShare *)this, Path);
}

STDMETHODIMP
CNWCOMPATFileShare::put_Path(THIS_ BSTR bstrPath)
{
    PUT_PROPERTY_BSTR((IADsFileShare *)this, Path);
}

STDMETHODIMP
CNWCOMPATFileShare::get_MaxUserCount(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileShare *)this, MaxUserCount);
}

STDMETHODIMP
CNWCOMPATFileShare::put_MaxUserCount(THIS_ LONG lMaxUserCount)
{
    PUT_PROPERTY_LONG((IADsFileShare *)this, MaxUserCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cextmgr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cextmgr.cxx
//
//  Contents:  LDAP ExtMgr Object
//
//
//  History:   06-15-96     yihsins     Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


//  Class CADsExtMgr

CADsExtMgr::CADsExtMgr():
    _pClassEntry(NULL),
    _pDispMgr(NULL)
{

}

HRESULT
CADsExtMgr::CreateExtMgr(
    IUnknown FAR * pUnkOuter,
    CAggregatorDispMgr * pDispMgr,
    LPTSTR pszClassName,
    CADsExtMgr ** ppExtMgr
    )
{
    PCLASS_ENTRY pClassEntry =  NULL;
    CADsExtMgr FAR * pExtMgr = NULL;
    HRESULT hr = S_OK;

    hr = AllocateExtMgrObject(
                &pExtMgr
                );
    BAIL_ON_FAILURE(hr);


    //
    // Now store the DispatchMgr of the Aggregator
    //

    pExtMgr->_pDispMgr = pDispMgr;

    hr = ADSIGetExtensionList(
            pszClassName,
            &(pExtMgr->_pClassEntry)
            );

    if (pExtMgr->_pClassEntry) {

        hr = ADSILoadExtensions(
                    pUnkOuter,
                    pExtMgr->_pClassEntry
                    );
    }

    *ppExtMgr = pExtMgr;

    RRETURN(hr);

error:
    *ppExtMgr = NULL;
    delete pExtMgr;
    RRETURN(hr);
}


CADsExtMgr::~CADsExtMgr( )
{
    //
    // Free the ClassEntry
    //

    if (_pClassEntry) {

        FreeClassEntry(_pClassEntry);
    }

    //
    // And do nothing with the DispMgr - we just keep a pointer
    //

}

STDMETHODIMP
CADsExtMgr::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    PCLASS_ENTRY  pClassEntry = _pClassEntry;
    IUnknown * pUnknown = NULL;
    PINTERFACE_ENTRY pIID = NULL;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    HRESULT hr = S_OK;

    if (!pClassEntry) {

        RRETURN(E_NOINTERFACE);
    }

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        pUnknown = pExtensionEntry->pUnknown;
        pIID = pExtensionEntry->pIID;

        while (pIID) {

            if (IsEqualIID(pIID->iid, iid)) {


                if (!pUnknown) {

                    RRETURN(E_NOINTERFACE);
                }

                hr = pUnknown->QueryInterface(
                            iid,
                            ppv
                            );
                RRETURN(hr);
            }

            pIID = pIID->pNext;

        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    RRETURN(hr = E_NOINTERFACE);
}


HRESULT
CADsExtMgr::AllocateExtMgrObject(
    CADsExtMgr ** ppExtMgr
    )
{
    CADsExtMgr FAR * pExtMgr = NULL;
    HRESULT hr = S_OK;

    pExtMgr = new CADsExtMgr();
    if (pExtMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    *ppExtMgr = pExtMgr;

    RRETURN(hr);

error:

    if (pExtMgr) {
        delete pExtMgr;
    }

    RRETURN(hr);

}


HRESULT
ADSILoadExtensionManager(
    LPWSTR pszClassName,
    IUnknown * pUnkOuter,
    CAggregatorDispMgr * pDispMgr,
    CADsExtMgr ** ppExtMgr
    )
{

    HRESULT hr = S_OK;

    hr = CADsExtMgr::CreateExtMgr(
            pUnkOuter,
            pDispMgr,
            pszClassName,
            ppExtMgr
            );

    RRETURN(hr);
}


STDMETHODIMP
CADsExtMgr::GetTypeInfoCount(
    unsigned int FAR* pctinfo
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CADsExtMgr::GetTypeInfo(
    unsigned int itinfo,
    LCID lcid,
    ITypeInfo FAR* FAR* pptinfo
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CADsExtMgr::GetIDsOfNames(
    REFIID iid,
    LPWSTR FAR* rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID FAR* rgdispid
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;
    IPrivateDispatch FAR * pPrivDisp = NULL;


    hr = _pDispMgr->GetIDsOfNames(
            iid,
            rgszNames,
            cNames,
            lcid,
            rgdispid
            );

    if (FAILED(hr)) {

        if (!_pClassEntry) {
            RRETURN(DISP_E_UNKNOWNNAME);
        }

        pExtension = _pClassEntry->pExtensionHead;

        while (pExtension) {

            if (pExtension->fDisp) {

                //
                // fDisp = TRUE indicates
                //  1)  extension supports pADsExt AND
                //  2)  either
                //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL
                //      OR
                //      b) we don't know if a) is true or not yet
                //

                ASSERT(pExtension->pADsExt);

                hr = (pExtension->pADsExt)->PrivateGetIDsOfNames(
                          iid,
                          rgszNames,
                          cNames,
                          lcid,
                          rgdispid
                          );

                if (SUCCEEDED(hr)) {

                    //
                    // check & prefix extension id to dispid(s) returned
                    // by extension
                    //

                    hr = CheckAndPrefixExtIDArray(
                                pExtension->dwExtensionID,
                                cNames,
                                rgdispid
                                );

                    if (SUCCEEDED(hr) )
                    {
                        RRETURN(hr);
                    }

                    //
                    // if cannot prefix extension id because NOT ALL
                    // dispids returned by PrivateGetIDsOfNames() are
                    // valid, this extension does not support this property
                    // or method -> try next extension
                    //
                    // If the extension returns ANY invalid dispids, then
                    // we treat the extension as invalid.  This way, we can
                    // see if a later extension exists that supports this
                    // property or method, instead of just bailing out.
                    // This is important, since there
                    // can be multiple extensions and we are supposed to
                    // "find the first extension which implements a function"
                    // (per ADSI SDK).
                    //
                }

                else if (hr == E_NOTIMPL) {

                    //
                    // extension object does not support the optional
                    // IADsExtension::PrivateGetIDsOfNames()/PrivateInvoke()
                    // -> remember this in cache & try next extension object
                    //

                    pExtension->fDisp = FALSE;
                }

                else {

                    //
                    // extens'n object supports PrivateGetIDsOfNames()/Invoke()
                    // but does not know about this property or method
                    // -> try next extension object
                    //
                }

            } // end "if (pExtension->pADs && pExtension->fDisp)"

            pExtension = pExtension->pNext;

        } // end while

    }


    //
    // Unify the final error code retuned to ADSI client to DISP_E_UNKNOWNNAME
    //

    if ( FAILED(hr) && hr!=E_OUTOFMEMORY) {

        hr = DISP_E_UNKNOWNNAME;
    }

    RRETURN(hr);
}


STDMETHODIMP
CADsExtMgr::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS FAR* pdispparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    unsigned int FAR* puArgErr
    )
{
    DWORD dwExtensionId = 0;
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;
    IPrivateDispatch * pPrivDisp = NULL;
    DISPID rgExtDispid = DISPID_UNKNOWN;

    //
    // This could be a special dispatch id - pass it to
    // the aggregator
    //

    if (dispidMember <= 0) {

        hr = _pDispMgr->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        RRETURN(hr);

    }

    //
    // It is not a special dispatch id, so compute the extension
    // id and pass it to the appropriate dispatch manager
    //

    dwExtensionId = EXTRACT_EXTENSION_ID(dispidMember);

    if (!dwExtensionId) {

        hr = _pDispMgr->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        RRETURN(hr);

    }

    if (!_pClassEntry) {

        RRETURN(DISP_E_MEMBERNOTFOUND);
    }


    pExtension = _pClassEntry->pExtensionHead;

    rgExtDispid = REMOVE_EXTENSION_ID(dispidMember);

    while (pExtension) {

        if (dwExtensionId == pExtension->dwExtensionID) {

            if (pExtension->fDisp) {

                //
                // fDisp = TRUE indicates
                //  1)  extension supports pADsExt AND
                //  2)  either
                //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL
                //      OR
                //      b) we don't know if a) is true or not yet
                //

                ASSERT(pExtension->pADsExt);

                hr = (pExtension->pADsExt)->PrivateInvoke(
                        rgExtDispid,
                        iid,
                        lcid,
                        wFlags,
                        pdispparams,
                        pvarResult,
                        pexcepinfo,
                        puArgErr
                        );
                RRETURN(hr);

            } else {

                //
                // A dwExtensionId match indicates THIS extens'n has returned
                // a valid dispid to clients thru' pADs->PrivateGetIDsOfNames.
                // Thus, fDisp should be TURE.
                //
                // But since dispid goes thru' clients before passed back to
                // PrivateInovke(), don't ASSERT in case of clients errors.
                //

                RRETURN(DISP_E_MEMBERNOTFOUND);
            }
        }

        pExtension = pExtension->pNext;

    } // end while

    RRETURN(DISP_E_MEMBERNOTFOUND);
}


HRESULT
CADsExtMgr::CheckAndPrefixExtIDArray(
    IN      DWORD dwExtensionID,
    IN      unsigned int cDispids,
    IN OUT  DISPID * rgDispids
    )
{

    HRESULT hrEach = S_OK;
    HRESULT hrAll = S_OK;


    ASSERT_VALID_EXTENSION_ID(dwExtensionID);


    for (unsigned int i = 0; i<cDispids; i++)
    {
        hrEach = CheckAndPrefixExtID(
                    dwExtensionID,
                    rgDispids[i],
                    rgDispids+i
                    );

        if (FAILED(hrEach))
        {
            hrAll = E_FAIL;

            //
            // The entire operation is considered as failure as a whole.
            // But continue to get other dispid s.t. debugger or user knows
            // which dispid in the array is causing problem -> DISPID_UNKOWN
            //
        }
    }

    RRETURN(hrAll);

}


HRESULT
CADsExtMgr::CheckAndPrefixExtID(
    IN      DWORD   dwExtensionID,
    IN      DISPID  dispid,
    IN OUT  DISPID  * pNewDispid
    )
{
    ASSERT(pNewDispid);

    if  ( (dispid>= ADS_EXT_MINEXTDISPID) &&
          (dispid<= ADS_EXT_MAXEXTDISPID) )
    {
        *pNewDispid = PREFIX_EXTENSION_ID(dwExtensionID, dispid) ;

        RRETURN(S_OK);
    }
    else
    {
        *pNewDispid = DISPID_UNKNOWN;

        RRETURN(E_FAIL);
    }

}


//+------------------------------------------------------------------------
//
//  Function:   CADsExtMgr::FinalInitializeExtensions
//
//  Synopsis:   At this point we call Operate on all the extensions
//           so that they can do initialization stuff that
//
//
//
//  Arguments: None
//
//  AjayR - added on 1-30-99.
//-------------------------------------------------------------------------
HRESULT
CADsExtMgr::FinalInitializeExtensions()
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtEntry = NULL;
    VARIANT varDummy;
    VariantInit(&varDummy);

    if (!_pClassEntry || !(pExtEntry=_pClassEntry->pExtensionHead) ) {
        RRETURN(S_OK);
    }

    while (pExtEntry) {

        //
        // Call operate only if the extension supports the interface
        //
        if (pExtEntry->pADsExt) {

            pExtEntry->pADsExt->Operate(
                                ADS_EXT_INITIALIZE_COMPLETE,
                                varDummy,
                                varDummy,
                                varDummy
                                );
        }

        //
        // we cannot really do much if there is a failure here
        //

        pExtEntry = pExtEntry->pNext;

    }   // end while


    //
    // Cannot fail because of one bad extension.
    //
    RRETURN(S_OK);      // "okay" error if any, optional support
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cenumvar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumvar.cxx
//
//  Contents:  NetWare 3.12 Enumerator Code
//
//             CNWCOMPATEnumVariant::Create
//             CNWCOMPATEnumVariant::CNWCOMPATEnumVariant
//             CNWCOMPATEnumVariant::~CNWCOMPATEnumVariant
//             CNWCOMPATEnumVariant::QueryInterface
//             CNWCOMPATEnumVariant::AddRef
//             CNWCOMPATEnumVariant::Release
//             CNWCOMPATEnumVariant::Next
//             CNWCOMPATEnumVariant::Skip
//             CNWCOMPATEnumVariant::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::CNWCOMPATEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNWCOMPATEnumVariant::CNWCOMPATEnumVariant()
{
    //
    // Set the reference count on the enumerator.
    //
    m_cRef = 1;

}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::~CNWCOMPATEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNWCOMPATEnumVariant::~CNWCOMPATEnumVariant()
{
    //
    // Bump down the reference count on the Collection object
    //
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CNWCOMPATEnumVariant::AddRef(void)
{

    return ++m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Release
//
//  Synopsis:
//
//
//  Arguments:  [void]
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CNWCOMPATEnumVariant::Release(void)
{


    if(--m_cRef == 0){

        delete this;
        return 0;
    }

    return m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATEnumVariant::Skip(ULONG cElements)
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATEnumVariant::Reset()
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cfsctrl.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfsvctrl.cxx
//
//  Contents:
//
//  History:   April 19, 1996     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Start
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Start(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Stop
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Stop(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Pause
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Pause(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Continue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Continue(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Status
//
//  Synopsis:
//
//----------------------------------------------------------------------------
/*STDMETHODIMP
CNWCOMPATFileService::get_Status(
    THIS_ long FAR* plStatus
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
} */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cfsconf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfsvconf.cxx
//
//  Contents:
//
//  History:   April 19, 1996     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::SetPassword
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::SetPassword(
    THIS_ BSTR bstrNewPassword
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//
// Properties Get & Set.
//

STDMETHODIMP
CNWCOMPATFileService::get_HostComputer(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, HostComputer);
}

STDMETHODIMP
CNWCOMPATFileService::put_HostComputer(THIS_ BSTR bstrHostComputer)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, HostComputer);
}

STDMETHODIMP
CNWCOMPATFileService::get_DisplayName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, DisplayName);
}

STDMETHODIMP
CNWCOMPATFileService::put_DisplayName(THIS_ BSTR bstrDisplayName)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, DisplayName);
}

STDMETHODIMP
CNWCOMPATFileService::get_Version(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, Version);
}

STDMETHODIMP
CNWCOMPATFileService::put_Version(THIS_ BSTR bstrVersion)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, Version);
}

STDMETHODIMP
CNWCOMPATFileService::get_ServiceType(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileService *)this, ServiceType);
}

STDMETHODIMP
CNWCOMPATFileService::put_ServiceType(THIS_ long lServiceType)
{
    PUT_PROPERTY_LONG((IADsFileService *)this, ServiceType);
}

STDMETHODIMP
CNWCOMPATFileService::get_StartType(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileService *)this, StartType);
}

STDMETHODIMP
CNWCOMPATFileService::put_StartType(THIS_ LONG lStartType)
{
    PUT_PROPERTY_LONG((IADsFileService *)this, StartType);
}

STDMETHODIMP
CNWCOMPATFileService::get_Path(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, Path);
}

STDMETHODIMP
CNWCOMPATFileService::put_Path(THIS_ BSTR bstrPath)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, Path);
}

STDMETHODIMP
CNWCOMPATFileService::get_StartupParameters(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, StartupParameters);
}

STDMETHODIMP
CNWCOMPATFileService::put_StartupParameters(THIS_ BSTR bstrStartupParameters)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, StartupParameters);
}

STDMETHODIMP
CNWCOMPATFileService::get_ErrorControl(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileService *)this, ErrorControl);
}

STDMETHODIMP
CNWCOMPATFileService::put_ErrorControl(THIS_ LONG lErrorControl)
{
    PUT_PROPERTY_LONG((IADsFileService *)this, ErrorControl);
}

STDMETHODIMP
CNWCOMPATFileService::get_LoadOrderGroup(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, LoadOrderGroup);
}

STDMETHODIMP
CNWCOMPATFileService::put_LoadOrderGroup(THIS_ BSTR bstrLoadOrderGroup)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, LoadOrderGroup);
}

STDMETHODIMP
CNWCOMPATFileService::get_ServiceAccountName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, ServiceAccountName);
}

STDMETHODIMP
CNWCOMPATFileService::put_ServiceAccountName(THIS_ BSTR bstrServiceAccountName)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, ServiceAccountName);
}

STDMETHODIMP
CNWCOMPATFileService::get_ServiceAccountPath(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, ServiceAccountPath);
}

STDMETHODIMP
CNWCOMPATFileService::put_ServiceAccountPath(THIS_ BSTR bstrServiceAccountPath)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, ServiceAccountPath);
}

STDMETHODIMP
CNWCOMPATFileService::get_Dependencies(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsFileService *)this, Dependencies);
}

STDMETHODIMP
CNWCOMPATFileService::put_Dependencies(THIS_ VARIANT vDependencies)
{
    PUT_PROPERTY_VARIANT((IADsFileService *)this, Dependencies);
}

STDMETHODIMP
CNWCOMPATFileService::get_Status(THIS_ long FAR* plStatusCode)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cfserv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfserv.cxx
//
//  Contents:
//
//  History:   April 19, 1996     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma hdrstop

//
// Marco-ized Implementation.
//

DEFINE_IDispatch_ExtMgr_Implementation(CNWCOMPATFileService);

DEFINE_IADs_TempImplementation(CNWCOMPATFileService);

DEFINE_IADs_PutGetImplementation(CNWCOMPATFileService, FileServiceClass,gdwFileServiceTableSize);

DEFINE_IADsPropertyList_Implementation(CNWCOMPATFileService, FileServiceClass, gdwFileServiceTableSize);

//
// class CNWCOMPATFileService methods
//

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::CNWCOMPATFileService
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileService::CNWCOMPATFileService():
    _pDispMgr(NULL),
    _pExtMgr(NULL),
    _ServerName(NULL),
    _pPropertyCache(NULL)
{
    ENLIST_TRACKING(CNWCOMPATFileService);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::~CNWCOMPATFileService
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileService::~CNWCOMPATFileService()
{
    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    ADSFREESTRING(_ServerName);

    delete _pPropertyCache;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::CreateFileService
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::CreateFileService(
    LPTSTR pszADsParent,
    LPTSTR pszServerName,
    LPTSTR pszFileServiceName,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )

{
    CNWCOMPATFileService FAR * pFileService = NULL;
    HRESULT hr = S_OK;

    hr = AllocateFileServiceObject(
             &pFileService
             );
    BAIL_ON_FAILURE(hr);

    hr = pFileService->InitializeCoreObject(
                           pszADsParent,
                           pszFileServiceName,
                           TEXT("FileService"),
                           FILESERVICE_SCHEMA_NAME,
                           CLSID_NWCOMPATFileService,
                           dwObjectState
                           );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pszServerName , &pFileService->_ServerName);
    BAIL_ON_FAILURE(hr);

    hr = pFileService->QueryInterface(
                           riid,
                           ppvObj
                           );
    BAIL_ON_FAILURE(hr);

    pFileService->Release();

    hr = pFileService->_pExtMgr->FinalInitializeExtensions();
    BAIL_ON_FAILURE(hr);

    RRETURN(hr);

error:

    delete pFileService;
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::AllocateFileServiceObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::AllocateFileServiceObject(
    CNWCOMPATFileService ** ppFileService
    )
{
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    CADsExtMgr FAR * pExtensionMgr = NULL;
    CNWCOMPATFileService FAR *pFileService = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a FileService object.
    //

    pFileService = new CNWCOMPATFileService();
    if (pFileService == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsFileService,
             (IADsFileService *)pFileService,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsFileServiceOperations,
             (IADsFileServiceOperations *)pFileService,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsContainer,
             (IADsContainer *)pFileService,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPropertyList,
             (IADsPropertyList *)pFileService,
             DISPID_VALUE
             );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             FileServiceClass,
             gdwFileServiceTableSize,
             (CCoreADsObject *)pFileService,
             &(pFileService->_pPropertyCache)
             );

    BAIL_ON_FAILURE(hr);

    (pDispMgr)->RegisterPropertyCache(
                    pFileService->_pPropertyCache
                    );

    hr = ADSILoadExtensionManager(
                FILESERVICE_CLASS_NAME,
                (IADsFileService *)pFileService,
                pDispMgr,
                &pExtensionMgr
                );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    pFileService->_pExtMgr = pExtensionMgr;
    pFileService->_pDispMgr = pDispMgr;
    *ppFileService = pFileService;

    RRETURN(hr);

error:
    delete pDispMgr;
    delete pExtensionMgr;
    delete pFileService;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::QueryInterface(
    REFIID riid,
    LPVOID FAR* ppvObj
    )
{
    if (ppvObj == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsService)) {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsFileService))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsServiceOperations))
    {
        *ppvObj = (IADsFileServiceOperations FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IADsFileServiceOperations))
    {
        *ppvObj = (IADsFileServiceOperations FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IADsContainer))
    {
        *ppvObj = (IADsContainer FAR *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CNWCOMPATFileService::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsService) ||
        IsEqualIID(riid, IID_IADsServiceOperations) ||
        IsEqualIID(riid, IID_IADsFileService) ||
        IsEqualIID(riid, IID_IADsFileServiceOperations) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::get_Count
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::get_Count(long FAR* retval)
{
    //
    // Too expensive to implement in term of computer execution time.
    //

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::get_Filter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::get_Filter(THIS_ VARIANT FAR* pVar)
{
    //
    //  Filter doesn't make sense on a FileService container, since it
    //  can only contain FileShares.
    //

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::put_Filter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::put_Filter(THIS_ VARIANT Var)
{
    //
    // Filter doesn't make sense on a FileService container, since it
    // can only contain FileShares.
    //

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATFileService::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATFileService::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::GetObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    //
    // Will be implemented by Krishna on the WinNT side and be cloned
    // by me afterward.
    //

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::get__NewEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr = S_OK;
    IEnumVARIANT * pEnum = NULL;

    *retval = NULL;

    hr = CNWCOMPATFileServiceEnum::Create(
             (CNWCOMPATFileServiceEnum **) &pEnum,
             _ADsPath,
             _ServerName
             );
    BAIL_ON_FAILURE(hr);

    hr = pEnum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*) retval
                    );
    BAIL_ON_FAILURE(hr);

    if (pEnum) {
        pEnum->Release();
    }

    RRETURN(NOERROR);

error:

    delete pEnum;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Create
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Delete
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::CopyHere
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::MoveHere
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::GetInfo(THIS)
{

    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(
                TRUE,
                FSERV_WILD_CARD_ID
                ));
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::GetInfo(
    THIS_ BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;
    POBJECTINFO   pObjectInfo = NULL;

    //
    // Make sure the object is bound to a tangible resource.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // Componentize ADs name.
    //

    hr = BuildObjectInfo(
             _Parent,
             _Name,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get a handle to the bindery this computer object represents.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Fill in all property caches with values - explicit, or return the
    // indicated property - implicit.
    //

    if (fExplicit) {
       hr = ExplicitGetInfo(
                hConn,
                pObjectInfo,
                fExplicit
                );
       BAIL_ON_FAILURE(hr);
    }
    else {
       hr = ImplicitGetInfo(
                hConn,
                pObjectInfo,
                dwPropertyID,
                fExplicit
                );
       BAIL_ON_FAILURE(hr);
    }

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    if (hConn) {
        hrTemp = NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::ExplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::ExplicitGetInfo(
    NWCONN_HANDLE hConn,
    POBJECTINFO pObjectInfo,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    //
    // Get GeneralInfo.
    //

    hr = GetProperty_MaxUserCount(
             hConn,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get Configuration.
    //

    hr = GetProperty_HostComputer(
             pObjectInfo,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::ImplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::ImplicitGetInfo(
    NWCONN_HANDLE hConn,
    POBJECTINFO pObjectInfo,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    switch (dwPropertyID) {

    case FSERV_MAXUSERCOUNT_ID:
         hr = GetProperty_MaxUserCount(
                  hConn,
                  fExplicit
                  );
         break;

    case FSERV_HOSTCOMPUTER_ID:
         hr = GetProperty_HostComputer(
                  pObjectInfo,
                  fExplicit
                  );
         break;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::GetProperty_MaxUserCount
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::GetProperty_MaxUserCount(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    DWORD    dwTemp = 0;
    VERSION_INFO VersionInfo;

    //
    // Get the Maximum number of connections supported from the Version
    // Information of the FileServer.
    //

    hr = NWApiGetFileServerVersionInfo(
             hConn,
             &VersionInfo
             );

    if (SUCCEEDED(hr)) {

        dwTemp = VersionInfo.ConnsSupported;

        //
        // Unmarshall.
        //

        hr = SetDWORDPropertyInCache(_pPropertyCache,
                                     TEXT("MaxUserCount"),
                                     (DWORD)dwTemp,
                                     fExplicit
                                     );

        BAIL_ON_FAILURE(hr);

    }
    
    //
    // Not a problem if we couldn't get the info, just ignore it and don't
    // put it in the cache.
    //
    hr = S_OK;
    
error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::GetProperty_HostComputer
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::GetProperty_HostComputer(
    POBJECTINFO pObjectInfo,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    WCHAR szBuffer[MAX_PATH];

    //
    // Build ADs path of Host computer from ObjectInfo.
    //

    wsprintf(
        szBuffer,
        L"%s://%s",
        pObjectInfo->ProviderName,
        pObjectInfo->ComponentArray[0]
        );

    //
    // Unmarshall
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("HostComputer"),
                szBuffer,
                fExplicit
                );

    //
    // Return.
    //

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cfsop.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfsvopr.cxx
//
//  Contents:
//
//  History:   April 19, 1996     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Sessions
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Sessions(
    THIS_ IADsCollection FAR* FAR* ppSessions
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Resources
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Resources(
    THIS_ IADsCollection FAR* FAR* ppResources
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cggi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cggi.cxx
//
//  Contents:  This file contains the Group Object's
//             GeneralInformation Functional Set.
//
//  History:   Jan-29-1996     t-ptam(PatrickT)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    );

//
//  Class CNWCOMPATGroup
//

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::get_Description
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP CNWCOMPATGroup::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsGroup *)this, Description);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::put_Description
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP CNWCOMPATGroup::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsGroup *)this, Description);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::Members
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::Members(
    THIS_ IADsMembers FAR* FAR* ppMembers
    )
{
    HRESULT hr;

    hr = CNWCOMPATGroupCollection::CreateGroupCollection(
             _Parent,
             _ParentType,
             _ServerName,
             _Name,
             IID_IADsMembers,
             (void **)ppMembers
             );
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::IsMember
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::IsMember(
    THIS_ BSTR bstrMember,
    VARIANT_BOOL FAR* bMember
    )
{
    IADsMembers FAR * pMembers = NULL;
    IUnknown FAR * pUnknown = NULL;
    IEnumVARIANT FAR * pEnumVar = NULL;
    DWORD i = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL fMember = FALSE;
    VARIANT VariantArray[10];
    BOOL fContinue = TRUE;
    ULONG cElementFetched = 0;

    hr = Members(
            &pMembers
            );
    BAIL_ON_FAILURE(hr);

    hr = pMembers->get__NewEnum(
                &pUnknown
                );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                IID_IEnumVARIANT,
                (void **)&pEnumVar
                );
    BAIL_ON_FAILURE(hr);


    while (fContinue) {

        IADs *pObject ;

        hr = pEnumVar->Next(
                    10,
                    VariantArray,
                    &cElementFetched
                    );

        if (hr == S_FALSE) {
            fContinue = FALSE;

            //
            // Reset hr to S_OK, we want to return success
            //

            hr = S_OK;
        }


        fMember = (VARIANT_BOOL)VerifyIfMember(
                        bstrMember,
                        VariantArray,
                        cElementFetched
                        );

        if (fMember) {

            fContinue = FALSE;
        }


        for (i = 0; i < cElementFetched; i++ ) {

            IDispatch *pDispatch = NULL;

            pDispatch = VariantArray[i].pdispVal;
            pDispatch->Release();

        }

        memset(VariantArray, 0, sizeof(VARIANT)*10);

    }

error:

    *bMember = fMember? VARIANT_TRUE : VARIANT_FALSE;

    if (pEnumVar) {
        pEnumVar->Release();
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pMembers) {
        pMembers->Release();
    }


    RRETURN_EXP_IF_ERR(hr);
}


BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    )
{
    DWORD i = 0;
    HRESULT hr = S_OK;
    IADs FAR * pObject = NULL;
    IDispatch FAR * pDispatch = NULL;

    for (i = 0; i < cElementFetched; i++ ) {

        IDispatch *pDispatch = NULL;
        BSTR       bstrName = NULL;

        pDispatch = VariantArray[i].pdispVal;

        hr = pDispatch->QueryInterface(
                    IID_IADs,
                    (VOID **) &pObject
                    );
        BAIL_ON_FAILURE(hr);

        hr = pObject->get_ADsPath(&bstrName);
        BAIL_ON_FAILURE(hr);

        if (!_wcsicmp(bstrName, bstrMember)) {

            SysFreeString(bstrName);
            bstrName = NULL;

            pObject->Release();

           return(TRUE);

        }

        SysFreeString(bstrName);
        bstrName = NULL;

        pObject->Release();

    }

error:

    return(FALSE);

}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::Add
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::Add(
    THIS_ BSTR bstrNewItem
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;
    POBJECTINFO   pObjectInfo = NULL;

    //
    // Fill in pObjectInfo with appropriate data.
    //

    hr = BuildObjectInfo(
             bstrNewItem,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Validate input name is a user.
    //
    if (pObjectInfo->NumComponents != 2) {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Make sure that the user that we're attempting to
    // add resides on the server of this group
    //

    if (_wcsicmp(pObjectInfo->ComponentArray[0], _ServerName)) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }


    //
    // Obtain a handle to the bindery that bstrNewItem resides on.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Add the member to the group.
    //

    hr = NWApiAddGroupMember(
             hConn,
             _Name,
             pObjectInfo->ComponentArray[1]
             );
    BAIL_ON_FAILURE(hr);

error:
    if (hConn) {
        hrTemp = NWApiReleaseBinderyHandle(hConn);
    }

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::Remove
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::Remove(
    THIS_ BSTR bstrItemToBeRemoved
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;
    POBJECTINFO   pObjectInfo = NULL;

    //
    // Fill in pObjectInfo with appropriate data.
    //

    hr = BuildObjectInfo(
             bstrItemToBeRemoved,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Validate input name is a user.
    //
    if (pObjectInfo->NumComponents != 2) {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Make sure that the user that we're attempting to
    // delete resides on the server of this group
    //

    if (_wcsicmp(pObjectInfo->ComponentArray[0], _ServerName)) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }


    //
    // Obtain a handle to the bindery that bstrNewItem resides on.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Remove the member from the group.
    //

    hr = NWApiRemoveGroupMember(
             hConn,
             _Name,
             pObjectInfo->ComponentArray[1]
             );
    BAIL_ON_FAILURE(hr);

error:
    if (hConn) {
        hrTemp = NWApiReleaseBinderyHandle(hConn);
    }

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cfshare.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:  cfshare.cxx
//
//  Contents:  CNWCOMPATFileShare
//
//
//  History:   25-Apr-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

//
// Macro-ized implementation.
//

DEFINE_IDispatch_ExtMgr_Implementation(CNWCOMPATFileShare);

DEFINE_IADs_TempImplementation(CNWCOMPATFileShare);

DEFINE_IADs_PutGetImplementation(CNWCOMPATFileShare, FileShareClass, gdwFileShareTableSize)

DEFINE_IADsPropertyList_Implementation(CNWCOMPATFileShare, FileShareClass, gdwFileShareTableSize)



//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::CNWCOMPATFileShare
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileShare::CNWCOMPATFileShare():
    _pDispMgr(NULL),
    _pExtMgr(NULL),
    _pPropertyCache(NULL)
{
    ENLIST_TRACKING(CNWCOMPATFileShare);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileShare::~CNWCOMPATFileShare()
{
    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::CreateFileShare
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::CreateFileShare(
    LPTSTR pszADsParent,
    LPTSTR pszShareName,
    DWORD  dwObjectState,
    REFIID riid,
    LPVOID * ppvoid
    )
{
    CNWCOMPATFileShare FAR * pFileShare = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a FileShare object.
    //

    hr = AllocateFileShareObject(
             &pFileShare
             );
    BAIL_ON_FAILURE(hr);

    //
    // Initialize its core object.
    //

    hr = pFileShare->InitializeCoreObject(
                         pszADsParent,
                         pszShareName,
                         FILESHARE_CLASS_NAME,
                         FILESHARE_SCHEMA_NAME,
                         CLSID_NWCOMPATFileShare,
                         dwObjectState
                         );
    BAIL_ON_FAILURE(hr);

    //
    // Get interface pointer.
    //

    hr = pFileShare->QueryInterface(
                         riid,
                         (void **)ppvoid
                         );
    BAIL_ON_FAILURE(hr);

    pFileShare->Release();

    hr = pFileShare->_pExtMgr->FinalInitializeExtensions();
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    RRETURN(hr);

error:

    delete pFileShare;
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileShare::QueryInterface(
    REFIID riid,
    LPVOID FAR* ppvObj
    )
{
    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsFileShare *) this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADs FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsFileShare))
    {
        *ppvObj = (IADsFileShare FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN(_pExtMgr->QueryInterface(riid,ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CNWCOMPATFileShare::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsFileShare) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileShare::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileShare::GetInfo(THIS)
{
    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(
                TRUE,
                FSHARE_WILD_CARD_ID
                ));
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::AllocateFileShareObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::AllocateFileShareObject(
    CNWCOMPATFileShare **ppFileShare
    )
{
    CNWCOMPATFileShare FAR * pFileShare = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CADsExtMgr FAR * pExtensionMgr = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a FileShare object.
    //

    pFileShare = new CNWCOMPATFileShare();
    if (pFileShare == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CAggregatorDispMgr;
    if(pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // Load type info.
    //

    hr =  LoadTypeInfoEntry(
              pDispMgr,
              LIBID_ADs,
              IID_IADsFileShare,
              (IADsFileShare *)pFileShare,
              DISPID_REGULAR
              );
    BAIL_ON_FAILURE(hr);

    hr =  LoadTypeInfoEntry(
              pDispMgr,
              LIBID_ADs,
              IID_IADsPropertyList,
              (IADsPropertyList *)pFileShare,
              DISPID_VALUE
              );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             FileShareClass,
             gdwFileShareTableSize,
             (CCoreADsObject *)pFileShare,
             &(pFileShare ->_pPropertyCache)
             );

    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                pFileShare->_pPropertyCache
                );

    hr = ADSILoadExtensionManager(
                FILESHARE_CLASS_NAME,
                (IADs *) pFileShare,
                pDispMgr,
                &pExtensionMgr
                );
    BAIL_ON_FAILURE(hr);

    pFileShare->_pDispMgr = pDispMgr;
    pFileShare->_pExtMgr = pExtensionMgr;
    *ppFileShare = pFileShare;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pFileShare;
    delete pExtensionMgr;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileShare::GetInfo(
    BOOL fExplicit,
    THIS_ DWORD dwPropertyID
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;
    POBJECTINFO   pObjectInfo = NULL;

    //
    // Make sure the object is bound to a tangible resource.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // Componentize ADs name.
    //

    hr = BuildObjectInfo(
             _Parent,
             _Name,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get a handle to the bindery this computer object represents.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Fill in all property caches with values - explicit, or return the
    // indicated property - implicit.
    //

    if (fExplicit) {
       hr = ExplicitGetInfo(
                hConn,
                pObjectInfo,
                fExplicit
                );
       BAIL_ON_FAILURE(hr);
    }
    else {
       hr = ImplicitGetInfo(
                hConn,
                pObjectInfo,
                dwPropertyID,
                fExplicit
                );
       BAIL_ON_FAILURE(hr);
    }

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    if (hConn) {
        hrTemp = NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::ExplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::ExplicitGetInfo(
    NWCONN_HANDLE hConn,
    POBJECTINFO pObjectInfo,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    hr = GetProperty_Description(
            fExplicit
            );
    BAIL_ON_FAILURE(hr);

    hr = GetProperty_HostComputer(
             pObjectInfo,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

    hr = GetProperty_MaxUserCount(
             hConn,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::ImplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::ImplicitGetInfo(
    NWCONN_HANDLE hConn,
    POBJECTINFO pObjectInfo,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    switch (dwPropertyID) {

    case FSHARE_DESCRIPTION_ID:
         hr = GetProperty_Description(
                    fExplicit
                    );
         break;

    case FSHARE_HOSTCOMPUTER_ID:
         hr = GetProperty_HostComputer(
                  pObjectInfo,
                  fExplicit
                  );
         break;

    case FSHARE_MAXUSERCOUNT_ID:
         hr = GetProperty_MaxUserCount(
                  hConn,
                  fExplicit
                  );
         break;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::GetProperty_Description
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::GetProperty_Description(
    BOOL fExplicit
)
{
    HRESULT hr = S_OK;

    //
    // Bindery volumes don't have descriptions associated
    // with them, only a name.  So just arbitrarily give it
    // a fixed description of "Disk".
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Description"),
                bstrFileShareDescription,
                fExplicit
                );


    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::GetProperty_HostComputer
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::GetProperty_HostComputer(
    POBJECTINFO pObjectInfo,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    WCHAR szBuffer[MAX_PATH];

    //
    // Build ADs path of Host computer from ObjectInfo.
    //

    wsprintf(
        szBuffer,
        L"%s://%s",
        pObjectInfo->ProviderName,
        pObjectInfo->ComponentArray[0]
        );

    //
    // Unmarshall
    //

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("HostComputer"),
                                  szBuffer,
                                  fExplicit
                                  );

    //
    // Return.
    //

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::GetProperty_MaxUserCount
//
//  Synopsis: Note that the Max Number of Connections Supported of the
//            FileServer is used.  In NetWare, there isn't a per share max valu.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::GetProperty_MaxUserCount(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    DWORD     dwTemp = 0;
    VERSION_INFO VersionInfo;

    //
    // Get the Maximum number of connections supported from the Version
    // Information of the FileServer.
    //

    hr = NWApiGetFileServerVersionInfo(
             hConn,
             &VersionInfo
             );

    if (SUCCEEDED(hr)) {
        dwTemp =  VersionInfo.ConnsSupported;

        //
        // Unmarshall.
        //

        hr = SetDWORDPropertyInCache(_pPropertyCache,
                                     TEXT("MaxUserCount"),
                                     dwTemp,
                                     fExplicit
                                     );
        BAIL_ON_FAILURE(hr);
    }

    
    //
    // Okay if NWApiGetFileServerVersionInfo failed, we just ignore it and
    // don't put anything in the cache
    //
    hr = S_OK;

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cjobgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cjobgi.cxx
//
//  Contents:
//
//  History:   1-May-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
// Macro-ized implementation.
//

//
// Properties Get & Set.
//

STDMETHODIMP
CNWCOMPATPrintJob::get_HostPrintQueue(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, HostPrintQueue);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_User(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, User);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_TimeSubmitted(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintJob *)this, TimeSubmitted);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_TotalPages(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, TotalPages);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_Size(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, Size);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, Description);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsPrintJob *)this, Description);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_Priority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, Priority);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_Priority(THIS_ LONG lPriority)
{
    PUT_PROPERTY_LONG((IADsPrintJob *)this, Priority);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_StartTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintJob *)this, StartTime);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_StartTime(THIS_ DATE daStartTime)
{
    PUT_PROPERTY_DATE((IADsPrintJob *)this, StartTime);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_UntilTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintJob *)this, UntilTime);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_UntilTime(THIS_ DATE daUntilTime)
{
    PUT_PROPERTY_DATE((IADsPrintJob *)this, UntilTime);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_Notify(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, Notify);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_Notify(THIS_ BSTR bstrNotify)
{
    PUT_PROPERTY_BSTR((IADsPrintJob *)this, Notify);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_NotifyPath(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, NotifyPath);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_NotifyPath(THIS_ BSTR bstrNotifyPath)
{
    PUT_PROPERTY_BSTR((IADsPrintJob *)this, NotifyPath);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_UserPath(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, UserPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cjobop.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cjobop.cxx
//
//  Contents:
//
//  History:   1-May-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::Pause
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::Pause(THIS)
{
    BSTR    bstrName = NULL;
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    DWORD   dwJobId = 0;
    WCHAR   szUncPrinterName[MAX_PATH];

    hr = NWApiUncFromADsPath(
             _pszPrinterPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get JobId from name.
    //

    hr = get_CoreName(&bstrName);
    BAIL_ON_FAILURE(hr);

    dwJobId = (DWORD)_wtol(bstrName);

    //
    // Open a handle to the printer with USE access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Pause job.
    //

    hr = NWApiSetJob(
             hPrinter,
             dwJobId,
             0,
             NULL,
             JOB_CONTROL_PAUSE
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    ADSFREESTRING(bstrName);

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::Resume
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::Resume(THIS)
{
    BSTR    bstrName = NULL;
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    DWORD   dwJobId = 0;
    WCHAR   szUncPrinterName[MAX_PATH];

    hr = NWApiUncFromADsPath(
             _pszPrinterPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get JobId from name.
    //

    hr = get_CoreName(&bstrName);
    BAIL_ON_FAILURE(hr);

    dwJobId = (DWORD)_wtol(bstrName);

    //
    // Open a handle to the printer with USE access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Resume job.
    //

    hr = NWApiSetJob(
             hPrinter,
             dwJobId,
             0,
             NULL,
             JOB_CONTROL_RESUME
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    ADSFREESTRING(bstrName);

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::Remove
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::Remove(THIS)
{
    BSTR    bstrName = NULL;
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    DWORD   dwJobId = 0;
    WCHAR   szUncPrinterName[MAX_PATH];


    hr = NWApiUncFromADsPath(
             _pszPrinterPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get JobId from name.
    //

    hr = get_CoreName(&bstrName);
    BAIL_ON_FAILURE(hr);

    dwJobId = (DWORD)_wtol(bstrName);

    //
    // Open a handle to the printer with USE access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Remove job.
    //

    hr = NWApiSetJob(
             hPrinter,
             dwJobId,
             0,
             NULL,
             JOB_CONTROL_CANCEL
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    ADSFREESTRING(bstrName);

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::get_Status
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::get_Status(
    THIS_ LONG FAR* retval
    )
{
    *retval = _lStatus;

    RRETURN(S_OK);
}

//
// Properties Get & Set.
//

STDMETHODIMP
CNWCOMPATPrintJob::put_Position(THIS_ LONG lPosition)
{
    PUT_PROPERTY_LONG((IADsPrintJob *)this, Position);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_Position(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, Position);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_PagesPrinted(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, PagesPrinted);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_TimeElapsed(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, TimeElapsed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cjob.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:  cjob.cxx
//
//  Contents:  CNWCOMPATPrintJob
//
//
//  History:   1-May-96     t-ptam (Patrick Tam)    Created.
//             1-Jul-96    ramv   (Ram Viswanathan) Modified to use propcache
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

//
// Macro-ized implementation.
//

DEFINE_IDispatch_ExtMgr_Implementation(CNWCOMPATPrintJob);

DEFINE_IADs_TempImplementation(CNWCOMPATPrintJob);

DEFINE_IADs_PutGetImplementation(CNWCOMPATPrintJob, PrintJobClass, gdwJobTableSize);

DEFINE_IADsPropertyList_Implementation(CNWCOMPATPrintJob, PrintJobClass, gdwJobTableSize);


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::CNWCOMPATPrintJob
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATPrintJob::CNWCOMPATPrintJob():

    _pDispMgr(NULL),
    _pExtMgr(NULL),
    _lJobId(0),
    _lStatus(0),
    _pPropertyCache(NULL),
    _pszPrinterPath(NULL)
{
    ENLIST_TRACKING(CNWCOMPATPrintJob);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::~CNWCOMPATPrintJob
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATPrintJob::~CNWCOMPATPrintJob()
{
    delete _pExtMgr;            // created last, destroyed first
    delete _pDispMgr;
    delete _pPropertyCache;
    if(_pszPrinterPath){
        FreeADsStr(_pszPrinterPath);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::CreatePrintJob
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintJob::CreatePrintJob(
    LPTSTR pszPrinterPath,
    LONG   lJobId,
    DWORD dwObjectState,
    REFIID riid,
    LPVOID *ppvoid
    )
{
    CNWCOMPATPrintJob *pPrintJob =  NULL;
    HRESULT hr = S_OK;
    TCHAR szJobName[MAX_LONG_LENGTH];
    POBJECTINFO pObjectInfo = NULL;
    TCHAR szUncPrinterName[MAX_PATH];

    //
    // Allocate memory for a print job object.
    //

    hr = AllocatePrintJobObject(
             &pPrintJob
             );
    BAIL_ON_FAILURE(hr);

    //
    // Convert the JobId that we have into a string that we move
    // into the Name field
    //

    _ltow(
        lJobId,
        szJobName,
        10
        );

    //
    // Initialize its core object.
    //

    hr = pPrintJob->InitializeCoreObject(
                        pszPrinterPath,
                        szJobName,
                        PRINTJOB_CLASS_NAME,
                        PRINTJOB_SCHEMA_NAME,
                        CLSID_NWCOMPATPrintJob,
                        dwObjectState
                        );
    BAIL_ON_FAILURE(hr);

    //
    // Job ID.
    //

    pPrintJob->_lJobId = lJobId;
    pPrintJob->_pszPrinterPath = AllocADsStr(pszPrinterPath);

    if(! pPrintJob->_pszPrinterPath) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // Get interface pointer.
    //

    hr = pPrintJob->QueryInterface(
                        riid,
                        (void **)ppvoid
                        );
    BAIL_ON_FAILURE(hr);

    pPrintJob->Release();

    hr = pPrintJob->_pExtMgr->FinalInitializeExtensions();
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    delete pPrintJob;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::AllocatePrintJobObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintJob::AllocatePrintJobObject(
    CNWCOMPATPrintJob ** ppPrintJob
    )
{
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CADsExtMgr FAR * pExtensionMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    CNWCOMPATPrintJob FAR * pPrintJob = NULL;
    CNWCOMPATFSPrintJobGeneralInfo FAR * pGenInfo = NULL;
    CNWCOMPATFSPrintJobOperation FAR * pOperation = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a PrintJob object.
    //

    pPrintJob = new CNWCOMPATPrintJob();
    if (pPrintJob == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPrintJob,
             (IADsPrintJob *) pPrintJob,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPrintJobOperations,
                (IADsPrintJobOperations *)pPrintJob,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pPrintJob,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //
    hr = CPropertyCache::createpropertycache(
            PrintJobClass,
            gdwJobTableSize,
            (CCoreADsObject *)pPrintJob,
             &pPropertyCache
            );

    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                    pPropertyCache
                    );

    hr = ADSILoadExtensionManager(
                PRINTJOB_CLASS_NAME,
                (IADsPrintJob *)pPrintJob,
                pDispMgr,
                &pExtensionMgr
                );
    BAIL_ON_FAILURE(hr);

    pPrintJob->_pExtMgr = pExtensionMgr;
    pPrintJob->_pPropertyCache = pPropertyCache;
    pPrintJob->_pDispMgr = pDispMgr;
    *ppPrintJob = pPrintJob;

    RRETURN(hr);

error:

    delete  pPropertyCache;
    delete  pDispMgr;
    delete pExtensionMgr;
    delete  pPrintJob;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::QueryInterface(
    REFIID riid,
    LPVOID FAR* ppvObj
    )
{
    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsPrintJob FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsPrintJob *)this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsPrintJob FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintJob))
    {
        *ppvObj = (IADsPrintJob FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintJobOperations))
    {
        *ppvObj = (IADsPrintJobOperations FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }

    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::InterfaceSupportsErrorInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsPropertyList) ||
        IsEqualIID(riid, IID_IADsPrintJob) ||
        IsEqualIID(riid, IID_IADsPrintJobOperations)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::SetInfo(THIS)
{
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    LPBYTE  lpbBuffer = NULL;
    WCHAR   szUncPrinterName[MAX_PATH];

    //
    // Make sure object is bound to a tangible resource.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = CreateObject();
        BAIL_ON_FAILURE(hr);

        SetObjectState(ADS_OBJECT_BOUND);
    }

    //
    // Make Unc printer name.
    //

    hr = NWApiUncFromADsPath(
             _pszPrinterPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Open a handle to a printer.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ALL_ACCESS
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get job Info structure.
    //

    hr = NWApiGetJob(
             hPrinter,
             (DWORD) _lJobId,
             WIN32_API_LEVEL_2,
             &lpbBuffer
             );
    BAIL_ON_FAILURE(hr);

    //
    // Set info.
    //

    hr = MarshallAndSet(
             hPrinter,
             (LPJOB_INFO_2) lpbBuffer
             );
error:

    //
    // Close Printer handle.
    //

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    RRETURN_EXP_IF_ERR(hr);
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::GetInfo(THIS)
{
    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(
                TRUE,
                JOB_API_LEVEL
                ));
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::CreateObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::CreateObject()
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::GetInfo
//
//  Synopsis: Please note that only Level 2 is used, unlike the WinNT side.
//            Since Level 1 is simply a subset of Level 2 in this case, its just
//            a matter of style which one to use.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::GetInfo(
    THIS_ BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    //
    // Please note that the input DWORD is treated as dwApiLevel, unlike ohter
    // NWCompat objects that treat it as dwPropertyID.  The reason is that Win32
    // APIs are used for retrieving information of the object.
    //

    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    LPBYTE  lpbJobInfo = NULL;
    WCHAR szUncPrinterName[MAX_PATH];

    //
    // Make Unc printer name.
    //

    hr = NWApiUncFromADsPath(
             _pszPrinterPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Open a handle to a printer.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ALL_ACCESS
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get job's info.
    //

    hr = NWApiGetJob(
             hPrinter,
             (DWORD) _lJobId,
             WIN32_API_LEVEL_2,
             &lpbJobInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Unmarshall.
    //

    hr = UnMarshall_GeneralInfo(
             (LPJOB_INFO_2) lpbJobInfo,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

    hr = UnMarshall_Operation(
             (LPJOB_INFO_2) lpbJobInfo,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if(lpbJobInfo){
        FreeADsMem(lpbJobInfo);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::UnMarshall_GeneralInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintJob::UnMarshall_GeneralInfo(
    LPJOB_INFO_2 lpJobInfo2,
    BOOL fExplicit
    )
{
    DATE    daTemp = 0;
    HRESULT hr = S_OK;
    LPWSTR  lpszTemp = NULL;
    WCHAR   szTemp[MAX_PATH];


    hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("HostPrintQueue"),
                    _pszPrinterPath,
                    fExplicit
                    );


    hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("User"),
                    lpJobInfo2->pUserName,
                    fExplicit
                    );

    hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    lpJobInfo2->pDocument,
                    fExplicit
                    );

    hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("Notify"),
                    lpJobInfo2->pNotifyName,
                    fExplicit
                    );

    hr = SetSYSTEMTIMEPropertyInCache(
                    _pPropertyCache,
                    TEXT("TimeSubmitted"),
                    lpJobInfo2->Submitted,
                    fExplicit
                    );

    hr = SetDWORDPropertyInCache(
                    _pPropertyCache,
                    TEXT("Priority"),
                    lpJobInfo2->Priority,
                    fExplicit
                    );

    hr = SetDWORDPropertyInCache(
                    _pPropertyCache,
                    TEXT("TotalPages"),
                    lpJobInfo2-> TotalPages,
                    fExplicit
                    );


    hr = SetDATEPropertyInCache(
                    _pPropertyCache,
                    TEXT("StartTime"),
                    lpJobInfo2->StartTime,
                    fExplicit
                    );


    hr = SetDATEPropertyInCache(
                    _pPropertyCache,
                    TEXT("UntilTime"),
                    lpJobInfo2->UntilTime,
                    fExplicit
                    );

    hr = SetDWORDPropertyInCache(
                    _pPropertyCache,
                    TEXT("Size"),
                    lpJobInfo2->Size,
                    fExplicit
                    );

    hr = S_OK;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::UnMarshall_Operation
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintJob::UnMarshall_Operation(
    LPJOB_INFO_2 lpJobInfo2,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("Position"),
                lpJobInfo2->Position,
                fExplicit
                );
    BAIL_ON_FAILURE(hr);

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("PagesPrinted"),
                lpJobInfo2->PagesPrinted,
                fExplicit
                );

    BAIL_ON_FAILURE(hr);

    hr = SetDATEPropertyInCache(
                _pPropertyCache,
                TEXT("TimeElapsed"),
                lpJobInfo2->Time,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("Status"),
                lpJobInfo2->Status,
                fExplicit
                );

    BAIL_ON_FAILURE(hr);

    _lStatus = lpJobInfo2->Status;

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::MarshallAndSet
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintJob::MarshallAndSet(
    HANDLE hPrinter,
    LPJOB_INFO_2 lpJobInfo2
    )
{
    LPTSTR pszDescription = NULL;
    LPTSTR pszNotify = NULL;
    DWORD  dwValue;
    HRESULT hr = S_OK;

    //
    // Set Description.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->pDocument = pszDescription;
    }

    //
    // Set Notify.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Notify"),
                    &pszNotify
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->pNotifyName = pszNotify;
    }

    //
    // Set Priority.
    //

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Priority"),
                    &dwValue
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->Priority = dwValue;
    }

    //
    // Set StartTime.
    //

   hr = GetDATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("StartTime"),
                    &dwValue
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->StartTime = dwValue;
    }

    //
    // Set UntilTime
    //

   hr = GetDATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("UntilTime"),
                    &dwValue
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->UntilTime = dwValue;
    }


/*  Clarify the precedence between Notify & NotifyPath

    hr = UM_GET_BSTR_PROPERTY(_pGenInfo, NotifyPath, fExplicit);
    BAIL_ON_FAILURE(hr);
*/

    //
    // Set Position.
    //

   hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Position"),
                    &dwValue
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->Position = dwValue;
    }

    //
    // Commit changes.
    //

    hr = NWApiSetJob(
             hPrinter,
             (DWORD) _lJobId,
             WIN32_API_LEVEL_2,
             (LPBYTE) lpJobInfo2,
             0
             );
    BAIL_ON_FAILURE(hr);

error:
    if(pszDescription)
        FreeADsStr(pszDescription);
    if(pszNotify)
        FreeADsStr(pszNotify);

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cgroups.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroups.cxx
//
//  Contents:  Group object
//
//  History:   Mar-18-965     t-ptam (PatrickT)    Migrated.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Class CNWCOMPATGroupCollection
//

DEFINE_IDispatch_Implementation(CNWCOMPATGroupCollection)

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroupCollection::CNWCOMPATGroupCollection():
        _ParentType(0),
        _ServerName(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CNWCOMPATGroupCollection);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroupCollection::~CNWCOMPATGroupCollection( )
{
    if (_ServerName)
        ADsFreeString(_ServerName);
    delete _pDispMgr;
    VariantClear(&_vFilter);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroupCollection::CreateGroupCollection(
    BSTR Parent,
    ULONG ParentType,
    BSTR ServerName,
    BSTR GroupName,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATGroupCollection FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGroupCollectionObject(&pGroup);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->InitializeCoreObject(
                     Parent,
                     GroupName,
                     L"group",
                     NO_SCHEMA,
                     CLSID_NWCOMPATGroup,
                     ADS_OBJECT_UNBOUND
                     );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName , &pGroup->_ServerName);
    BAIL_ON_FAILURE(hr);

    pGroup->_ParentType = ParentType;

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();
    RRETURN(hr);

error:
    delete pGroup;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATGroupCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollection::get_Count(
    long FAR* retval
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollection::get_Filter(
    THIS_ VARIANT FAR* pVar
    )
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollection::put_Filter(
    THIS_ VARIANT Var
    )
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNWCOMPATGroupCollectionEnum::Create(
             (CNWCOMPATGroupCollectionEnum **)&penum,
             _Parent,
             _ParentType,
             _ADsPath,
             _ServerName,
             _Name,
             _vFilter
             );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroupCollection::AllocateGroupCollectionObject(
    CNWCOMPATGroupCollection ** ppGroup
    )
{
    CNWCOMPATGroupCollection FAR * pGroup = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pGroup = new CNWCOMPATGroupCollection();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsMembers,
             (IADsMembers *)pGroup,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:
    if (pGroup) {
        delete pGroup;
    }

    if (pDispMgr) {
        delete  pDispMgr;
    }

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cjobs.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cjobs.cxx
//
//  Contents:  Job collection object
//
//  History:   May-08-96     t-ptam (PatrickT)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Macro-iszed implementation.
//

DEFINE_IDispatch_Implementation(CNWCOMPATJobCollection)

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::CNWCOMPATJobCollection
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATJobCollection::CNWCOMPATJobCollection():
    _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNWCOMPATJobCollection);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::CreateJobCollection
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATJobCollection::CreateJobCollection(
    BSTR bstrParent,
    BSTR bstrPrinterName,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATJobCollection FAR * pJobs = NULL;
    HRESULT hr = S_OK;

    hr = AllocateJobCollectionObject(&pJobs);
    BAIL_ON_FAILURE(hr);

    hr = pJobs->InitializeCoreObject(
                    bstrParent,
                    bstrPrinterName,
                    PRINTER_CLASS_NAME,
                    NO_SCHEMA,
                    CLSID_NWCOMPATPrintQueue,
                    ADS_OBJECT_UNBOUND
                    );
    BAIL_ON_FAILURE(hr);

    hr = pJobs->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pJobs->Release();
    RRETURN(hr);

error:
    delete pJobs;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::~CNWCOMPATJobCollection
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATJobCollection::~CNWCOMPATJobCollection( )
{
    delete _pDispMgr;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsCollection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsCollection))
    {
        *ppv = (IADsCollection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsCollection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::InterfaceSupportsErrorInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsCollection)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::get__NewEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::get__NewEnum(
    THIS_ IUnknown FAR* FAR* retval
    )
{
    HRESULT hr = S_OK;
    IEnumVARIANT * pEnum = NULL;
    WCHAR szPrinterName[MAX_PATH];

    //
    // Validate input parameter.
    //

    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    *retval = NULL;

    //
    // Express printer name as an ADsPath.
    //

    wsprintf(szPrinterName,
             L"%s/%s",
             _Parent,
             _Name );

    //
    // Create enumerator.
    //

    hr = CNWCOMPATJobCollectionEnum::Create(
             (CNWCOMPATJobCollectionEnum **)&pEnum,
             szPrinterName
             );
    BAIL_ON_FAILURE(hr);

    hr = pEnum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (pEnum) {
        pEnum->Release();
    }

    //
    // Return.
    //

    RRETURN(NOERROR);

error:
    if (pEnum) {
        delete pEnum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::GetObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::GetObject(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvItem
    )
{
    HRESULT hr = S_OK;
    DWORD dwJobId = 0;
    IDispatch *pDispatch = NULL;

    //
    // Validate input parameters.
    //

    if(!bstrName || !pvItem){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    //
    // Convert bstrName, which is a JobId, into DWORD.
    //

    dwJobId = (DWORD)_wtol(bstrName);

    //
    // Create the desire print job object.
    //

    hr = CNWCOMPATPrintJob::CreatePrintJob(
             _ADsPath,
             dwJobId,
             ADS_OBJECT_BOUND,
             IID_IDispatch,
             (void **)&pDispatch
             );
    BAIL_ON_FAILURE(hr);

    //
    // stick this IDispatch pointer into a caller provided variant
    //

    VariantInit(pvItem);
    V_VT(pvItem) = VT_DISPATCH;
    V_DISPATCH(pvItem) = pDispatch;

error:
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::Add
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::Add(
    THIS_ BSTR bstrNewItem,
    VARIANT vItem
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::Remove
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::Remove(
    THIS_ BSTR bstrItemToBeRemoved
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::AllocateJobCollectionObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATJobCollection::AllocateJobCollectionObject(
    CNWCOMPATJobCollection ** ppJob
    )
{
    CNWCOMPATJobCollection FAR * pJob = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a JobCollection object.
    //

    pJob = new CNWCOMPATJobCollection();
    if (pJob == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsCollection,
             (IADsCollection *)pJob,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    pJob->_pDispMgr = pDispMgr;
    *ppJob = pJob;

    RRETURN(hr);

error:

    delete pJob;
    delete  pDispMgr;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cgroup.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   Jan-29-1996     t-ptam(PatrickT)    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Class CNWCOMPATGroup
//

DEFINE_IDispatch_ExtMgr_Implementation(CNWCOMPATGroup)
DEFINE_IADs_TempImplementation(CNWCOMPATGroup)

DEFINE_IADs_PutGetImplementation(CNWCOMPATGroup, GroupClass, gdwGroupTableSize)

DEFINE_IADsPropertyList_Implementation(CNWCOMPATGroup, GroupClass, gdwGroupTableSize)




//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::CNWCOMPATGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroup::CNWCOMPATGroup():
        _pDispMgr(NULL),
        _pExtMgr(NULL),
        _pPropertyCache(NULL),
        _ParentType(0),
        _ServerName(NULL)
{
    ENLIST_TRACKING(CNWCOMPATGroup);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::CreateGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroup::CreateGroup(
    BSTR Parent,
    ULONG ParentType,
    BSTR ServerName,
    BSTR GroupName,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATGroup FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a Group object.
    //

    hr = AllocateGroupObject(&pGroup);
    BAIL_ON_FAILURE(hr);

    //
    // Initialize group's core object.
    //

    hr = pGroup->InitializeCoreObject(
                     Parent,
                     GroupName,
                     GROUP_CLASS_NAME,
                     GROUP_SCHEMA_NAME,
                     CLSID_NWCOMPATGroup,
                     dwObjectState
                     );
    BAIL_ON_FAILURE(hr);

    //
    // Save protected values.
    //

    hr = ADsAllocString( ServerName ,  &pGroup->_ServerName);
    BAIL_ON_FAILURE(hr);

    //
    // QueryInterface.
    //
    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();

    hr = pGroup->_pExtMgr->FinalInitializeExtensions();
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    RRETURN(hr);

error:
    delete pGroup;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::~CNWCOMPATGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroup::~CNWCOMPATGroup( )
{
    ADsFreeString(_ServerName);

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsGroup))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(iid, ppv));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATGroup::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{

    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsGroup) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }

}

/* IADs methods */

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;

    //
    // Bind an object to a real life resource if it is not bounded already.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = BuildObjectInfo(
                _Parent,
                _Name,
                &pObjectInfo
                );
        BAIL_ON_FAILURE(hr);

        hr = NWApiCreateGroup(
                 pObjectInfo
                 );
        BAIL_ON_FAILURE(hr);


        SetObjectState(ADS_OBJECT_BOUND);
    }

    //
    // Persist changes.
    //

    hr = SetInfo(GROUP_WILD_CARD_ID);
    BAIL_ON_FAILURE(hr);


error:

    if (pObjectInfo) {

        FreeObjectInfo(pObjectInfo);
    }
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::GetInfo(THIS)
{
    HRESULT hr = S_OK;

    _pPropertyCache->flushpropcache();

    hr = GetInfo(
             TRUE,
             GROUP_WILD_CARD_ID
             );

    RRETURN_EXP_IF_ERR(hr);
}


/* IADsGroup methods */


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::AllocateGroupObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroup::AllocateGroupObject(
    CNWCOMPATGroup ** ppGroup
    )
{
    CNWCOMPATGroup FAR * pGroup = NULL;
    CNWCOMPATGroupGenInfo FAR * pGenInfo = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CADsExtMgr FAR * pExtensionMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pGroup = new CNWCOMPATGroup();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create dispatch manager.
    //

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsGroup,
             (IADsGroup *)pGroup,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPropertyList,
             (IADsPropertyList *)pGroup,
             DISPID_VALUE
             );
    BAIL_ON_FAILURE(hr);


    hr = CPropertyCache::createpropertycache(
             GroupClass,
             gdwGroupTableSize,
             (CCoreADsObject *)pGroup,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);


    pDispMgr->RegisterPropertyCache(
                pPropertyCache
                );

    hr = ADSILoadExtensionManager(
                GROUP_CLASS_NAME,
                (IADs *)pGroup,
                pDispMgr,
                &pExtensionMgr
                );
    BAIL_ON_FAILURE(hr);

    pGroup->_pPropertyCache = pPropertyCache;
    pGroup->_pExtMgr = pExtensionMgr;
    pGroup->_pDispMgr = pDispMgr;
    pGroup->_pGenInfo = pGenInfo;
    *ppGroup = pGroup;

    RRETURN(hr);

error:
    delete  pDispMgr;
    delete  pExtensionMgr;
    delete  pPropertyCache;
    delete  pGroup;

    RRETURN(hr);
}
//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::SetInfo(THIS_ DWORD dwPropertyID)
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;

    //
    // Get a handle to the bindery this object resides on.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             _ServerName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Persist changes in cache.
    //

    hr = SetDescription(hConn);
    BAIL_ON_FAILURE(hr);

error:
    //
    // Release handle.
    //

    if (hConn) {
        hrTemp = NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::SetDescription
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroup::SetDescription(
    NWCONN_HANDLE hConn
    )
{
    LPWSTR  pszDescription = NULL;
    WCHAR   szwData[MAX_FULLNAME_LEN +1];
    CHAR    szData[(MAX_FULLNAME_LEN + 1)*2];
    HRESULT hr = S_OK;

    memset(szwData, 0, sizeof(WCHAR)*(MAX_FULLNAME_LEN +1));
    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );

    if (SUCCEEDED(hr)) {

        //
        // Convert bstr in ANSI string.
        //

        wcsncpy(szwData, pszDescription, MAX_FULLNAME_LEN);


        UnicodeToAnsiString(
            szwData,
            szData,
            0
            );

        //
        // Commit change.
        //

        hr = NWApiWriteProperty(
                 hConn,
                 _Name,
                 OT_USER_GROUP,
                 NW_PROP_IDENTIFICATION,
                 (LPBYTE) szData
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Not is modified, that's ok.
    // reset hr to  S_OK

    hr = S_OK;

error:

    if (pszDescription ) {

        FreeADsStr(pszDescription);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::GetInfo(
    BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // Get a handle to the bindery this computer object represents.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             _ServerName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get property.
    //

    hr = GetProperty_Description(hConn, fExplicit);
    BAIL_ON_FAILURE(hr);

error:

    if (hConn) {
       hrTemp = NWApiReleaseBinderyHandle(hConn);
    }
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::GetProperty_Description
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroup::GetProperty_Description(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    LPWSTR           lpszFullName = NULL;
    CHAR             szFullName[MAX_FULLNAME_LEN + 1];
    DWORD            dwNumSegment = 0;
    HRESULT          hr = S_OK;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL; // Used by DELETE_LIST macro below

    //
    // Get IDENTIFICATIOIN.  This property contains the full name of an object.
    // It is often used in place of "Description".
    //

    hr = NWApiGetProperty(
             _Name,
             NW_PROP_IDENTIFICATION,
             OT_USER_GROUP,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );

    if (SUCCEEDED(hr)) {
    
        //
        // Convert result into a UNICODE string.
        //

        strcpy(szFullName, lpReplySegment->Segment);

        lpszFullName = (LPWSTR) AllocADsMem(
                                    (strlen(szFullName) + 1) * sizeof(WCHAR)
                                    );
        if (!lpszFullName)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        AnsiToUnicodeString(
            szFullName,
            lpszFullName,
            0
            );

        //
        // Unmarshall.
        //

        hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    lpszFullName,
                    fExplicit
                    );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Couldn't retrieve the property from the server.  Not
    // a problem, we just ignore it.
    //
    hr = S_OK;

error:

    if (lpszFullName) {
        FreeADsMem(lpszFullName);
    }

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cnamcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  NetWare compatible Namespace Object Class Factory Code
//
//             CNWCOMPATNamespaceCF::CreateInstance
//
//  History:   Mar-04-96     t-ptam    Migrated.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATNamespaceCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    Mar-04-96   t-ptam     Migrated.
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATNamespaceCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CNWCOMPATNamespace::CreateNamespace(
                                 L"ADs:",
                                 L"NWCOMPAT:",
                                 ADS_OBJECT_BOUND,
                                 iid,
                                 ppv
                                 );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\common.cxx ===
#include "nwcompat.hxx"
#pragma hdrstop


FILTERS Filters[] = {
                    {L"computer", NWCOMPAT_COMPUTER_ID},
                    {L"user", NWCOMPAT_USER_ID},
                    {L"group", NWCOMPAT_GROUP_ID},
                    {L"service", NWCOMPAT_SERVICE_ID},
                    {L"printqueue", NWCOMPAT_PRINTER_ID},
                    {L"fileshare", NWCOMPAT_FILESHARE_ID},
                    {L"class", NWCOMPAT_CLASS_ID},
                    {L"syntax", NWCOMPAT_SYNTAX_ID},
                    {L"property", NWCOMPAT_PROPERTY_ID}
                  };

#define MAX_FILTERS  (sizeof(Filters)/sizeof(FILTERS))


HRESULT
CreatePropEntry(
    LPWSTR szPropName,
    ADSTYPE dwADsType,
    VARIANT varData,
    REFIID riid,
    LPVOID * ppDispatch
    );



PFILTERS  gpFilters = Filters;
DWORD gdwMaxFilters = MAX_FILTERS;
extern WCHAR * szProviderName;

//+------------------------------------------------------------------------
//
//  Class:      Common
//
//  Purpose:    Contains NWCOMPAT routines and properties that are common to
//              all NWCOMPAT objects. NWCOMPAT objects get the routines and
//              properties through C++ inheritance.
//
//-------------------------------------------------------------------------

HRESULT
MakeUncName(
    LPWSTR szSrcBuffer,
    LPWSTR szTargBuffer
    )
{
    ADsAssert(szSrcBuffer && *szSrcBuffer);
    wcscpy(szTargBuffer, L"\\\\");
    wcscat(szTargBuffer, szSrcBuffer);
    RRETURN(S_OK);
}

HRESULT
ValidateOutParameter(
    BSTR * retval
    )
{
    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    RRETURN(S_OK);
}

HRESULT
BuildADsPath(
    BSTR Parent,
    BSTR Name,
    BSTR *pADsPath
    )
{
    WCHAR ADsPath[MAX_PATH];
    WCHAR ProviderName[MAX_PATH];
    HRESULT hr = S_OK;
    LPWSTR pszDisplayName = NULL;

    //
    // We will assert if bad parameters are passed to us.
    // This is because this should never be the case. This
    // is an internal call
    //

    ADsAssert(Parent && Name);
    ADsAssert(pADsPath);

    hr = GetDisplayName(
             Name,
             &pszDisplayName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Special case the Namespace object; if
    // the parent is L"ADs:", then Name = ADsPath
    //

    if (!_wcsicmp(Parent, L"ADs:")) {
        hr = ADsAllocString(Name, pADsPath);
        BAIL_ON_FAILURE(hr);
        goto cleanup;
    }

    //
    // The rest of the cases we expect valid data,
    // Path, Parent and Name are read-only, the end-user
    // cannot modify this data
    //

    //
    // For the first object, the domain object we do not add
    // the first backslash; so we examine that the parent is
    // L"NWCOMPAT:" and skip the slash otherwise we start with
    // the slash
    //

    wsprintf(ProviderName, L"%s:", szProviderName);

    wcscpy(ADsPath, Parent);

    if (_wcsicmp(ADsPath, ProviderName)) {
        wcscat(ADsPath, L"/");
    }
    else {
       wcscat(ADsPath, L"//");
    }
    wcscat(ADsPath, Name);

    hr = ADsAllocString(ADsPath, pADsPath);

cleanup:
error:

    if (pszDisplayName) {
        FreeADsMem(pszDisplayName);
    }

    RRETURN(hr);
}

HRESULT
BuildSchemaPath(
    BSTR Parent,
    BSTR Name,
    BSTR Schema,
    BSTR *pSchemaPath
    )
{
    WCHAR SchemaPath[MAX_PATH];
    WCHAR ProviderName[MAX_PATH];
    HRESULT hr = S_OK;
    long i;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(Parent);


    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    //
    // We will assert if bad parameters are passed to us.
    // This is because this should never be the case. This
    // is an internal call
    //

    ADsAssert(Parent);
    ADsAssert(pSchemaPath);

    //
    // If no schema name is passed in, then there is no schema path
    //
    if ( Schema == NULL || *Schema == 0 ){

        RRETURN(ADsAllocString(L"", pSchemaPath));
    }

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);


    wsprintf(SchemaPath, L"%s://", szProviderName);

    if (!pObjectInfo->NumComponents) {
        wcscat(SchemaPath, Name);
    }else{
        wcscat(SchemaPath, pObjectInfo->DisplayComponentArray[0]);
    }

    wcscat( SchemaPath, L"/");
    wcscat( SchemaPath, SCHEMA_NAME );
    wcscat( SchemaPath, L"/");
    wcscat( SchemaPath, Schema );

    hr = ADsAllocString(SchemaPath, pSchemaPath);

error:

    FreeObjectInfo( &ObjectInfo, TRUE );

    RRETURN(hr);
}

HRESULT
BuildADsGuid(
    REFCLSID clsid,
    BSTR *pADsClass
    )
{
    WCHAR ADsClass[MAX_PATH];

    if (!StringFromGUID2(clsid, ADsClass, MAX_PATH)) {
        //
        // MAX_PATH should be more than enough for the GUID.
        //
        ADsAssert(!"GUID too big !!!");
        RRETURN(E_FAIL);
    }
 
    RRETURN(ADsAllocString(ADsClass, pADsClass));
}

HRESULT
BuildObjectInfo(
    BSTR ADsParent,
    BSTR Name,
    POBJECTINFO * ppObjectInfo
    )
{
    WCHAR szBuffer[MAX_PATH];
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;

    memset(szBuffer, 0, sizeof(szBuffer));

    wcscpy(szBuffer, ADsParent);
    wcscat(szBuffer, L"/");
    wcscat(szBuffer, Name);

    CLexer Lexer(szBuffer);

    pObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));
    if (!pObjectInfo) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    *ppObjectInfo = pObjectInfo;

    RRETURN(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    *ppObjectInfo = NULL;

    RRETURN(hr);
}

HRESULT
BuildObjectInfo(
    BSTR ADsPath,
    POBJECTINFO * ppObjectInfo
    )
{
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;
    CLexer Lexer(ADsPath);

    pObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));
    if (!pObjectInfo) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    *ppObjectInfo = pObjectInfo;

    RRETURN(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    *ppObjectInfo = NULL;

    RRETURN(hr);
}

VOID
FreeObjectInfo(
    POBJECTINFO pObjectInfo,
    BOOL fStatic
    )
{
    DWORD i = 0;

    if (!pObjectInfo) {
        return;
    }

    FreeADsStr(pObjectInfo->ProviderName);

    for (i = 0; i < pObjectInfo->NumComponents; i++ ) {
        FreeADsStr(pObjectInfo->ComponentArray[i]);
        FreeADsStr(pObjectInfo->DisplayComponentArray[i]);
    }

    if ( !fStatic ) {
        FreeADsMem(pObjectInfo);
    }
}

HRESULT
ValidateObject(
    DWORD dwObjectType,
    POBJECTINFO pObjectInfo
    )
{
    switch (dwObjectType) {
    case NWCOMPAT_USER_ID:
        RRETURN(ValidateUserObject(pObjectInfo));

    case NWCOMPAT_GROUP_ID:
        RRETURN(ValidateGroupObject(pObjectInfo));

    case NWCOMPAT_PRINTER_ID:
        RRETURN(ValidatePrinterObject(pObjectInfo));

    default:
        RRETURN(E_FAIL);
    }
}

HRESULT
GetObjectType(
    PFILTERS pFilters,
    DWORD dwMaxFilters,
    BSTR ClassName,
    PDWORD pdwObjectType
    )
{
    DWORD i = 0;

    ADsAssert(pdwObjectType);

    for (i = 0; i < dwMaxFilters; i++) {
        if (!_wcsicmp(ClassName, (pFilters + i)->szObjectName)) {
            *pdwObjectType = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }
    }
    *pdwObjectType = 0;
    RRETURN(E_FAIL);
}

HRESULT
ValidateProvider(
    POBJECTINFO pObjectInfo
    )
{
    //
    // The provider name is case-sensitive.  This is a restriction that OLE
    // has put on us.
    //
    if (!(wcscmp(pObjectInfo->ProviderName, szProviderName))) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}

HRESULT
ConvertSystemTimeToDATE(
    SYSTEMTIME Time,
    DATE *     pdaTime
    )
{
    FILETIME ft;
    BOOL fRetval = FALSE;
    USHORT wDosDate;
    USHORT wDosTime;

    //
    // System Time To File Time.
    //

    fRetval = SystemTimeToFileTime(&Time,
                                   &ft);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // File Time to DosDateTime.
    //

    fRetval = FileTimeToDosDateTime(&ft,
                                    &wDosDate,
                                    &wDosTime);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // DosDateTime to VariantTime.
    //

    fRetval = DosDateTimeToVariantTime(wDosDate,
                                       wDosTime,
                                       pdaTime );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    RRETURN(S_OK);
}

HRESULT
ConvertDATEToSYSTEMTIME(
    DATE  daDate,
    SYSTEMTIME *pSysTime
    )
{
    HRESULT hr;
    FILETIME ft;
    BOOL fRetval = FALSE;
    USHORT wDosDate;
    USHORT wDosTime;

    fRetval = VariantTimeToDosDateTime(daDate,
                                       &wDosDate,
                                       &wDosTime );

    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    fRetval = DosDateTimeToFileTime(wDosDate,
                                    wDosTime,
                                    &ft);



    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    fRetval = FileTimeToSystemTime(&ft,
                                   pSysTime );


    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    RRETURN(S_OK);
}

HRESULT
ConvertDATEToDWORD(
    DATE  daDate,
    DWORD *pdwDate
    )
{
    BOOL fBool = TRUE;
    WORD wDOSDate = 0;
    WORD wDOSTime = 0;
    WORD wHour = 0;
    WORD wMinute = 0;

    //
    // Break up Variant date.
    //

    fBool = VariantTimeToDosDateTime(
                (DOUBLE) daDate,
                &wDOSDate,
                &wDOSTime
                );
    if (fBool == FALSE) {
        goto error;
    }

    //
    // Convert DOS time into DWORD time which expresses time as the number of
    // minutes elapsed since mid-night.
    //

    wHour = wDOSTime >> 11;
    wMinute = (wDOSTime >> 5) - (wHour << 6);

    //
    // Return.
    //

    *pdwDate = wHour * 60 + wMinute;

error:

    RRETURN(S_OK);
}

HRESULT
ConvertDWORDToDATE(
    DWORD  dwTime,
    DATE * pdaTime
    )
{
    BOOL       fBool = TRUE;
    DOUBLE     vTime = 0;
    SYSTEMTIME SysTime = {1980,1,0,1,0,0,0,0};
    SYSTEMTIME LocalTime = {1980,1,0,1,0,0,0,0};
    WORD       wDOSDate = 0;
    WORD       wDOSTime = 0;
    WORD       wHour = 0;
    WORD       wMinute = 0;
    WORD       wSecond = 0;

    //
    // Get Hour and Minute from DWORD.
    //

    SysTime.wHour = (WORD) (dwTime / 60);
    SysTime.wMinute = (WORD) (dwTime % 60);

    //
    // Get Time-zone specific local time.
    //

    fBool = SystemTimeToTzSpecificLocalTime(
                NULL,
                &SysTime,
                &LocalTime
                );
    if (fBool == FALSE) {
        RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    wHour = LocalTime.wHour;
    wMinute = LocalTime.wMinute;
    wSecond = LocalTime.wSecond;

    //
    // Set a dummy date.
    //

    wDOSDate = DATE_1980_JAN_1;

    //
    // Shift data to correct bit as required by the DOS date & time format.
    //

    wHour = wHour << 11;
    wMinute = wMinute << 5;

    //
    // Put them in DOS format.
    //

    wDOSTime = wHour | wMinute | wSecond;

    //
    // Convert into VariantTime.
    //

    fBool = DosDateTimeToVariantTime(
                wDOSDate,
                wDOSTime,
                &vTime
                );
    //
    // Return.
    //

    if (fBool == TRUE) {

        *pdaTime = vTime;

        RRETURN(S_OK);
    }
    else {
        RRETURN(E_FAIL);
    }
}

HRESULT
DelimitedStringToVariant(
    LPTSTR pszString,
    VARIANT *pvar,
    TCHAR Delimiter
    )
{
    SAFEARRAYBOUND sabound[1];
    DWORD dwElements;
    LPTSTR pszCurrPos = pszString;
    LPTSTR *rgszStrings = NULL;
    SAFEARRAY *psa = NULL;
    VARIANT v;
    HRESULT hr = S_OK;
    LONG i;

    //
    // This function converts a delimited string into a VARIANT of
    // safe arrays.
    //
    // Assumption: a valid string are passed to this function
    // note that the input string gets destroyed in the process
    //

    //
    // scan the delimited string once to find out the dimension
    //

    //
    // in order to filter for NULL input values do a sanity check for
    // length of input string.
    //


    //
    // take care of null case first for sanity's sake
    //

    if (!pszString){
        sabound[0].cElements = 0;
        sabound[0].lLbound = 0;

        psa = SafeArrayCreate(VT_VARIANT, 1, sabound);

        if (psa == NULL){
            hr = E_OUTOFMEMORY;
            goto error;
        }

        VariantInit(pvar);
        V_VT(pvar) = VT_ARRAY|VT_VARIANT;
        V_ARRAY(pvar) = psa;
        goto error;
    }

    dwElements = (wcslen(pszString) == 0) ? 0: 1 ;

    while(!(*pszCurrPos == TEXT('\0'))){
        if(*pszCurrPos == Delimiter){
            dwElements++;
            *pszCurrPos = TEXT('\0');
        }
        pszCurrPos++;
    }

    rgszStrings = (LPTSTR *)AllocADsMem(sizeof(LPTSTR)*dwElements);

    if(!rgszStrings){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // scan string again and put the appropriate pointers
    //

    pszCurrPos = pszString;
    if(rgszStrings != NULL){
        (*rgszStrings) = pszCurrPos;
    }
    i = 1;

    while(i < (LONG)dwElements){

        if(*pszCurrPos == TEXT('\0')){
            *(rgszStrings+i) = ++pszCurrPos;
            i++;
        }
        pszCurrPos++;
    }


    //
    // create the safearray
    //

    sabound[0].cElements = dwElements;
    sabound[0].lLbound = 0;

    psa = SafeArrayCreate(VT_VARIANT, 1, sabound);

    if (psa == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    for(i=0; i<(LONG)dwElements; i++){

        VariantInit(&v);
        V_VT(&v) = VT_BSTR;

        hr = ADsAllocString(*(rgszStrings+i), &(V_BSTR(&v)));
        BAIL_ON_FAILURE(hr);

        //
        // Stick the caller provided data into the end of the SafeArray
        //

        hr = SafeArrayPutElement(psa, &i, &v);
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

    }

    //
    // convert this safearray into a VARIANT
    //

    VariantInit(pvar);
    V_VT(pvar) = VT_ARRAY|VT_VARIANT;
    V_ARRAY(pvar) = psa;

error:
    if(rgszStrings && dwElements != 0){
        FreeADsMem(rgszStrings);
    }
    RRETURN(hr);
}

HRESULT
VariantToDelimitedString(
    VARIANT var,
    LPTSTR *ppszString,
    TCHAR  Delimiter
    )
{

    LONG lIndices;
    ULONG cElements;
    ULONG  ulRequiredLength=0;
    SAFEARRAY  *psa = NULL;
    VARIANT vElement;
    LPTSTR  pszCurrPos = NULL;
    HRESULT hr = S_OK;
    ULONG i;

    //
    // converts the safearray in a variant to a delimited string
    //

    *ppszString = NULL;

    if(!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    psa = V_ARRAY(&var);

    //
    // Check that there is only one dimension in this array
    //

    if (psa->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is atleast one element in this array
    //

    cElements = psa->rgsabound[0].cElements;

    if (cElements == 0){
        hr = E_FAIL;
        goto error;
    }

    //
    // We know that this is a valid single dimension array
    //

    lIndices= 0;
    for(i=0; i< cElements; i++){
        lIndices = i;
        VariantInit(&vElement);
        hr = SafeArrayGetElement(psa, &lIndices, &vElement);
        BAIL_ON_FAILURE(hr);

        if(!(V_VT(&vElement) == VT_BSTR)){
            RRETURN(E_FAIL);
        }

        //
        // unpack the BSTR in the VARIANT
        //

        ulRequiredLength+= wcslen(vElement.bstrVal)+1;
        VariantClear(&vElement);
    }

    ulRequiredLength +=2;

    *ppszString = (LPTSTR)AllocADsMem( ulRequiredLength*sizeof(TCHAR));
    if(*ppszString == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }
    lIndices= 0;

    pszCurrPos = *ppszString;

    for(i=0; i< cElements; i++){
        lIndices = i;
        VariantInit(&vElement);
        hr = SafeArrayGetElement(psa, &lIndices, &vElement);
        BAIL_ON_FAILURE(hr);

        if(!(V_VT(&vElement) == VT_BSTR)){
            RRETURN(E_FAIL);
        }

        //
        // unpack the BSTR in the VARIANT
        //


        wcscpy(pszCurrPos, (LPTSTR)vElement.bstrVal);
        pszCurrPos += wcslen(vElement.bstrVal);

        if(i < cElements-1){
            *pszCurrPos = Delimiter;
        }
        pszCurrPos++;
        VariantClear(&vElement);
    }

    *pszCurrPos = L'\0';
    RRETURN(S_OK);

 error:

    RRETURN(hr);
}
HRESULT
VariantToNulledString(
    VARIANT var,
    LPTSTR *ppszString
    )

{

    LONG lIndices;
    ULONG cElements;
    ULONG  ulRequiredLength=0;
    SAFEARRAY  *psa = NULL;
    VARIANT vElement;
    LPTSTR  szCurrPos = NULL;
    HRESULT hr = S_OK;
    ULONG i;
    //
    //converts the safearray in a variant to a double nulled string
    //

    VariantInit(&vElement);
    *ppszString = NULL;

    if (!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    psa = V_ARRAY(&var);

    //
    // Check that there is only one dimension in this array
    //

    if (psa->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    cElements = psa->rgsabound[0].cElements;

    if (cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    lIndices= 0;
    for(i=0; i< cElements; i++){
        lIndices = i;
        VariantInit(&vElement);

        hr = SafeArrayGetElement(psa, &lIndices, &vElement);
        BAIL_ON_FAILURE(hr);

        if(!(V_VT(&vElement) == VT_BSTR)){
            RRETURN(E_FAIL);
        }

        //
        // unpack the BSTR in the VARIANT
        //


        ulRequiredLength+= wcslen(vElement.bstrVal)+1;
        VariantClear(&vElement);
    }

    ulRequiredLength +=2;

    *ppszString = (LPTSTR)AllocADsMem( ulRequiredLength*sizeof(TCHAR));
    if(*ppszString == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }
    lIndices= 0;

    szCurrPos = *ppszString;

    for(i=0; i< cElements; i++){
        lIndices = i;
        VariantInit(&vElement);

        hr = SafeArrayGetElement(psa, &lIndices, &vElement);
        BAIL_ON_FAILURE(hr);

        if(!(V_VT(&vElement) == VT_BSTR)){
            RRETURN(E_FAIL);
        }

        //
        // unpack the BSTR in the VARIANT
        //


        wcscpy(szCurrPos, (LPTSTR)vElement.bstrVal);
        szCurrPos += wcslen(vElement.bstrVal)+1;
        VariantClear(&vElement);
    }

    *szCurrPos = L'\0';
    RRETURN(S_OK);

error:

    VariantClear(&vElement);

    RRETURN(hr);
}


HRESULT
NulledStringToVariant(
    LPTSTR pszString,
    VARIANT *pvar
    )
{
    SAFEARRAYBOUND sabound[1];
    DWORD dwElements = 0;
    LPTSTR pszCurrPos = pszString;
    BOOL foundNULL = FALSE;
    LPTSTR *rgszStrings = NULL;
    SAFEARRAY *psa = NULL;
    VARIANT v;
    HRESULT hr = S_OK;
    LONG i;

    //
    // This function converts a double nulled string into a VARIANT of
    // safe arrays.
    //
    // Assumption: Valid double nulled strings are passed to this function
    //


    //
    // scan the double nulled string once to find out the dimension
    //

    while(!(*pszCurrPos == L'\0' && foundNULL)){
        if(*pszCurrPos == L'\0'){
            dwElements++;
            foundNULL = TRUE;
        }
        else{
            foundNULL = FALSE;
        }
        pszCurrPos++;
    }

    if(dwElements){
        rgszStrings = (LPTSTR *)AllocADsMem(sizeof(LPTSTR)*dwElements);
    }

    //
    // scan string again and put the appropriate pointers
    //

    pszCurrPos = pszString;
    if(rgszStrings != NULL){
        (*rgszStrings) = pszCurrPos;
    }
    foundNULL = FALSE;
    i = 1;

    while(i < (LONG)dwElements){
        if(foundNULL){
            *(rgszStrings+i) = pszCurrPos;
            i++;
        }
        if(*pszCurrPos == L'\0'){
            foundNULL = TRUE;
        }
        else{
            foundNULL = FALSE;
        }
        pszCurrPos++;
    }


    //
    // create the safearray
    //

    sabound[0].cElements = dwElements;
    sabound[0].lLbound = 0;

    psa = SafeArrayCreate(VT_VARIANT, 1, sabound);

    if (psa == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    for(i=0; i<(LONG)dwElements; i++){

        VariantInit(&v);
        V_VT(&v) = VT_BSTR;

        hr = ADsAllocString(*(rgszStrings+i), &(V_BSTR(&v)));
        BAIL_ON_FAILURE(hr);

        //
        // Stick the caller provided data into the end of the SafeArray
        //

        hr = SafeArrayPutElement(psa, &i, &v);
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

    }

    //
    // convert this safearray into a VARIANT
    //

    VariantInit(pvar);
    V_VT(pvar) = VT_ARRAY|VT_VARIANT;
    V_ARRAY(pvar) = psa;

error:
    if(rgszStrings){
        FreeADsMem(rgszStrings);
    }
    RRETURN(hr);
}



STDMETHODIMP
GenericGetPropertyManager(
    CPropertyCache * pPropertyCache,
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    DWORD dwInfoLevel;
    LPNTOBJECT pNtSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exists

    hr = pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pNtSrcObjects
                );

    BAIL_ON_FAILURE(hr);

    //
    // translate the Nt objects to variants
    //

    if (dwNumValues == 1) {

        hr = NtTypeToVarTypeCopy(
                    pNtSrcObjects,
                    pvProp
                    );

    }else {

        hr = NtTypeToVarTypeCopyConstruct(
                pNtSrcObjects,
                dwNumValues,
                pvProp
                );
    }

    BAIL_ON_FAILURE(hr);

error:

    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}

STDMETHODIMP
GenericPutPropertyManager(
    CPropertyCache * pPropertyCache,
    PPROPERTYINFO  pSchemaProps,
    DWORD dwSchemaPropSize,
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNTOBJECT pNtDestObjects = NULL;

    //
    // Issue: How do we handle multi-valued support
    //
    DWORD dwNumValues = 1;

    //
    // check if this is a legal property for this object,
    //
    //

    hr = ValidatePropertyinSchemaClass(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);


    //
    // check if this is a writeable property
    //

    hr = ValidateIfWriteableProperty(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName
                );
    BAIL_ON_FAILURE(hr);


    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNtTypeCopyConstruct(
                    dwSyntaxId,
                    &vProp,
                    1,
                    &pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    // Should use putproperty, not updateproperty -> unmarshalling from svr only
    //

    hr = pPropertyCache->putproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNtDestObjects) {
        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumValues
                );

    }

    RRETURN(hr);
}



HRESULT
BuildPrinterNameFromADsPath(
    LPWSTR pszADsParent,
    LPWSTR pszPrinterName,
    LPWSTR pszUncPrinterName
    )
{
    POBJECTINFO pObjectInfo = NULL;
    CLexer Lexer(pszADsParent);
    HRESULT hr;

    pObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));
    if (!pObjectInfo)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    wsprintf(
        pszUncPrinterName,
        L"\\\\%s\\%s",
        pObjectInfo->ComponentArray[0],
        pszPrinterName
        );

error:
    if(pObjectInfo){
        FreeObjectInfo(pObjectInfo);
    }
    RRETURN(hr);

}

STDMETHODIMP
GenericGetExPropertyManager(
    DWORD dwObjectState,
    CPropertyCache * pPropertyCache,
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNTOBJECT pNtSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exis
    //

    if (dwObjectState == ADS_OBJECT_UNBOUND) {

        hr = pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // translate the Nds objects to variants
    //

    hr = NtTypeToVarTypeCopyConstruct(
                pNtSrcObjects,
                dwNumValues,
                pvProp
                );

    BAIL_ON_FAILURE(hr);

error:
    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}


STDMETHODIMP
GenericPutExPropertyManager(
    CPropertyCache * pPropertyCache,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    DWORD dwNumValues = 0;
    LPNTOBJECT pNtDestObjects = NULL;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;


    //
    // Issue: How do we handle multi-valued support
    //
    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }


    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY)) ||
        (V_VT(&vProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF))) {

        hr  = ConvertByRefSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    }else {

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    //
    // check if this is a legal property for this object,
    //
    //

    hr = ValidatePropertyinSchemaClass(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if this is a writeable property
    //


    hr = ValidateIfWriteableProperty(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName
                );
    BAIL_ON_FAILURE(hr);


    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNtTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = pPropertyCache->putproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNtDestObjects) {
        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumValues
                );

    }

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }


    RRETURN(hr);
}

HRESULT
GenericPropCountPropertyManager(
    CPropertyCache * pPropertyCache,
    PLONG plCount
    )
{
    HRESULT hr = E_FAIL;

    if (pPropertyCache) {
        hr = pPropertyCache->get_PropertyCount((PDWORD)plCount);
    }
    RRETURN(hr);
}


HRESULT
GenericNextPropertyManager(
    CPropertyCache * pPropertyCache,
    VARIANT FAR *pVariant
    )
{
    HRESULT hr = E_FAIL;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    LPNTOBJECT pNtSrcObjects = NULL;
    VARIANT varData;
    IDispatch * pDispatch = NULL;

    VariantInit(&varData);

    hr = pPropertyCache->unboundgetproperty(
                pPropertyCache->get_CurrentIndex(),
                &dwSyntaxId,
                &dwNumValues,
                &pNtSrcObjects
                );
    BAIL_ON_FAILURE(hr);

    //
    // translate the Nt objects to variants
    //

    hr = ConvertNtValuesToVariant(
                pPropertyCache->get_CurrentPropName(),
                pNtSrcObjects,
                dwNumValues,
                pVariant
                );
    BAIL_ON_FAILURE(hr);


error:

    //
    // - goto next one even if error to avoid infinite looping at a property
    //   which we cannot convert (e.g. schemaless server property.)
    // - do not return the result of Skip() as current operation does not
    //   depend on the sucess of Skip().
    //

    pPropertyCache->skip_propindex(
                1
                );

    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
                pNtSrcObjects,
                dwNumValues
                );
    }

    RRETURN(hr);
}


HRESULT
GenericSkipPropertyManager(
    CPropertyCache * pPropertyCache,
    ULONG cElements
    )
{
    HRESULT hr = E_FAIL;

    hr = pPropertyCache->skip_propindex(
                cElements
                );
    RRETURN(hr);
}

HRESULT
GenericResetPropertyManager(
    CPropertyCache * pPropertyCache
    )
{
    pPropertyCache->reset_propindex();

    RRETURN(S_OK);
}


HRESULT
GenericDeletePropertyManager(
    CPropertyCache * pPropertyCache,
    VARIANT varEntry
    )
{
   HRESULT hr = S_OK;
   DWORD dwIndex = 0;

   switch (V_VT(&varEntry)) {

   case VT_BSTR:

       hr = pPropertyCache->findproperty(
                           V_BSTR(&varEntry),
                           &dwIndex
                           );
       BAIL_ON_FAILURE(hr);
       break;

   case VT_I4:
       dwIndex = V_I4(&varEntry);
       break;


   case VT_I2:
       dwIndex = V_I2(&varEntry);
       break;


   default:
       hr = E_FAIL;
       BAIL_ON_FAILURE(hr);
   }

   hr = pPropertyCache->deleteproperty(
                       dwIndex
                       );
error:
   RRETURN(hr);
}

HRESULT
GenericPutPropItemPropertyManager(
    CPropertyCache * pPropertyCache,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    VARIANT varData
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    WCHAR szPropertyName[MAX_PATH];
    LPNTOBJECT pNtDestObjects = NULL;
    DWORD dwNumValues = 0;
    DWORD dwControlCode = 0;

    hr = ConvertVariantToNtValues(
                varData,
                pSchemaProps,
                dwSchemaPropSize,
                szPropertyName,
                &pNtDestObjects,
                &dwNumValues,
                &dwSyntaxId,
                &dwControlCode
                );
    BAIL_ON_FAILURE(hr);

    if (dwControlCode != ADS_PROPERTY_UPDATE) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    //
    // Find this property in the cache
    //

    hr = pPropertyCache->findproperty(
                        szPropertyName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = pPropertyCache->addproperty(
                    szPropertyName,
                    dwSyntaxId
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = pPropertyCache->putproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNtDestObjects) {
        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumValues
                );

    }

    RRETURN(hr);
}


HRESULT
GenericGetPropItemPropertyManager(
    CPropertyCache * pPropertyCache,
    DWORD dwObjectState,
    BSTR bstrName,
    LONG lnADsType,
    VARIANT * pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNTOBJECT pNtSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exis
    //

    if (dwObjectState == ADS_OBJECT_UNBOUND) {

        hr = pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // translate the Nds objects to variants
    //

    hr = ConvertNtValuesToVariant(
                bstrName,
                pNtSrcObjects,
                dwNumValues,
                pVariant
                );
    BAIL_ON_FAILURE(hr);

error:
    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}


HRESULT
GenericItemPropertyManager(
    CPropertyCache * pPropertyCache,
    DWORD dwObjectState,
    VARIANT varIndex,
    VARIANT *pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNTOBJECT pNtSrcObjects = NULL;
    LPWSTR szPropName = NULL;
    VARIANT *pvVar = &varIndex;

    //
    // retrieve data object from cache; if one exis
    //

    if (V_VT(pvVar) == (VT_BYREF|VT_VARIANT)) {
        //
        // The value is being passed in byref so we need to
        // deref it for vbs stuff to work
        //
        pvVar = V_VARIANTREF(&varIndex);
    }

    switch (V_VT(pvVar)) {

    case VT_BSTR:
        if (dwObjectState == ADS_OBJECT_UNBOUND) {

            hr = pPropertyCache->unboundgetproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwNumValues,
                        &pNtSrcObjects
                        );
            BAIL_ON_FAILURE(hr);

        }else {

            hr = pPropertyCache->getproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwNumValues,
                        &pNtSrcObjects
                        );
            BAIL_ON_FAILURE(hr);
        }

        hr = ConvertNtValuesToVariant(
                    V_BSTR(pvVar),
                    pNtSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);
        break;


    case VT_I4:

        hr = pPropertyCache->unboundgetproperty(
                    V_I4(pvVar),
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = pPropertyCache->get_PropName(V_I4(pvVar));

        hr = ConvertNtValuesToVariant(
                    szPropName,
                    pNtSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);
        break;


    case VT_I2:

        hr = pPropertyCache->unboundgetproperty(
                    (DWORD)V_I2(pvVar),
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = pPropertyCache->get_PropName(V_I2(pvVar));

        hr = ConvertNtValuesToVariant(
                    szPropName,
                    pNtSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);

        break;





    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }

error:
    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);

}


HRESULT
GenericPurgePropertyManager(
    CPropertyCache * pPropertyCache
    )
{
    pPropertyCache->flushpropcache();
    RRETURN(S_OK);
}


HRESULT
CreatePropEntry(
    LPWSTR szPropName,
    ADSTYPE dwADsType,
    VARIANT varData,
    REFIID riid,
    LPVOID * ppDispatch
    )

{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;

    hr = CoCreateInstance(
                CLSID_PropertyEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsPropertyEntry,
                (void **)&pPropEntry
                );
    BAIL_ON_FAILURE(hr);


    hr = pPropEntry->put_Name(szPropName);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_Values(varData);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_ADsType(dwADsType);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->QueryInterface(
                        riid,
                        ppDispatch
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pPropEntry) {
        pPropEntry->Release();
    }

    RRETURN(hr);

}



HRESULT
ConvertNtValuesToVariant(
    LPWSTR szPropertyName,
    PNTOBJECT pNtSrcObject,
    DWORD dwNumValues,
    PVARIANT pVariant
    )
{
    HRESULT hr = S_OK;
    VARIANT varData;
    IDispatch * pDispatch = NULL;
    PADSVALUE pAdsValues = NULL;
    ADSTYPE dwADsType = ADSTYPE_INVALID;

    VariantInit(&varData);
    VariantInit(pVariant);

    if (dwNumValues>0) {

        hr = NTTypeToAdsTypeCopyConstruct(
                pNtSrcObject,
                dwNumValues,
                &pAdsValues
                );

        if (SUCCEEDED(hr)){

            hr = AdsTypeToPropVariant(
                    pAdsValues,
                    dwNumValues,
                    &varData
                    );
            BAIL_ON_FAILURE(hr);

            dwADsType = pAdsValues->dwType;
        }

        else if (hr==E_OUTOFMEMORY) {

            BAIL_ON_FAILURE(hr);
        }

        // failed because of NTType is not supported yet (e.g. NulledString)
        // in NTTypeToAdsTypeCopyConstruct() conversion yet
        // -> use empty variant now.
        else {

            VariantInit(&varData);
        }
    }

    hr = CreatePropEntry(
            szPropertyName,
            dwADsType,
            varData,
            IID_IDispatch,
            (void **)&pDispatch
            );
    BAIL_ON_FAILURE(hr);


    V_DISPATCH(pVariant) = pDispatch;
    V_VT(pVariant) = VT_DISPATCH;

error:

    VariantClear(&varData);

    if (pAdsValues) {
        AdsFreeAdsValues(
            pAdsValues,
            dwNumValues
            );
        FreeADsMem( pAdsValues);
    }

    RRETURN(hr);
}



HRESULT
ConvertVariantToVariantArray(
    VARIANT varData,
    VARIANT ** ppVarArray,
    DWORD * pdwNumValues
    )
{
    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    HRESULT hr = S_OK;
    VARIANT * pVarData = NULL;

    *ppVarArray = NULL;
    *pdwNumValues = 0;

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pVarData = &varData;
    if (V_VT(pVarData) == (VT_BYREF|VT_VARIANT)) {
        pVarData = V_VARIANTREF(&varData);
    }

    if ((V_VT(pVarData) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
        (V_VT(pVarData) == (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertSafeArrayToVariantArray(
                  varData,
                  &pVarArray,
                  &dwNumValues
                  );
        BAIL_ON_FAILURE(hr);

    } else {

        pVarArray = NULL;
        dwNumValues = 0;
    }

    *ppVarArray = pVarArray;
    *pdwNumValues = dwNumValues;

error:
    RRETURN(hr);
}

void
FreeVariantArray(
    VARIANT * pVarArray,
    DWORD dwNumValues
    )
{
    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }
}

HRESULT
ConvertVariantToNtValues(
    VARIANT varData,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    LPWSTR szPropertyName,
    PNTOBJECT *ppNtDestObjects,
    PDWORD pdwNumValues,
    PDWORD pdwSyntaxId,
    PDWORD pdwControlCode
    )
{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;
    IDispatch * pDispatch = NULL;
    BSTR bstrPropName = NULL;
    DWORD dwControlCode = 0;
    DWORD dwAdsType = 0;
    VARIANT varValues;
    VARIANT * pVarArray = NULL;
    DWORD dwNumValues = 0;
    PADSVALUE pAdsValues = NULL;
    DWORD dwAdsValues  = 0;

    PNTOBJECT pNtDestObjects = 0;
    DWORD dwNumNtObjects = 0;
    DWORD dwNtSyntaxId = 0;

    if (V_VT(&varData) != VT_DISPATCH) {
        RRETURN (hr = DISP_E_TYPEMISMATCH);
    }

    pDispatch = V_DISPATCH(&varData);

    hr = pDispatch->QueryInterface(
                        IID_IADsPropertyEntry,
                        (void **)&pPropEntry
                        );
    BAIL_ON_FAILURE(hr);

    VariantInit(&varValues);
    VariantClear(&varValues);


    hr = pPropEntry->get_Name(&bstrPropName);
    BAIL_ON_FAILURE(hr);
    wcscpy(szPropertyName, bstrPropName);

    hr = pPropEntry->get_ControlCode((long *)&dwControlCode);
    BAIL_ON_FAILURE(hr);
    *pdwControlCode = dwControlCode;

    hr = pPropEntry->get_ADsType((long *)&dwAdsType);
    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->get_Values(&varValues);
    BAIL_ON_FAILURE(hr);

    hr = ConvertVariantToVariantArray(
            varValues,
            &pVarArray,
            &dwNumValues
            );
    BAIL_ON_FAILURE(hr);

    if (dwNumValues) {
        hr = PropVariantToAdsType(
                    pVarArray,
                    dwNumValues,
                    &pAdsValues,
                    &dwAdsValues
                    );
        BAIL_ON_FAILURE(hr);

        hr = AdsTypeToNTTypeCopyConstruct(
                    pAdsValues,
                    dwAdsValues,
                    &pNtDestObjects,
                    &dwNumNtObjects,
                    &dwNtSyntaxId
                    );
        BAIL_ON_FAILURE(hr);

    }

    *pdwNumValues = dwNumValues;
    *ppNtDestObjects = pNtDestObjects;
    *pdwSyntaxId = dwNtSyntaxId;

error:

    if (pVarArray) {
        FreeVariantArray(
                pVarArray,
                dwNumValues
                );
    }

    RRETURN(hr);
}

HRESULT
ConvertNtValuesToVariant(
    BSTR bstrName,
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumValues,
    VARIANT * pVariant
    );


HRESULT
ConvertVariantToVariantArray(
    VARIANT varData,
    VARIANT ** ppVarArray,
    DWORD * pdwNumValues
    );

void
FreeVariantArray(
    VARIANT * pVarArray,
    DWORD dwNumValues
    );

HRESULT
ConvertVariantToNtValues(
    VARIANT varData,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    LPWSTR szPropertyName,
    PNTOBJECT *ppNtDestObjects,
    PDWORD pdwNumValues,
    PDWORD pdwSyntaxId
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\core.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  core.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

HRESULT
CCoreADsObject::InitializeCoreObject(
        BSTR Parent,
        BSTR Name,
        BSTR ClassName,
        BSTR Schema,
        REFCLSID rclsid,
        DWORD dwObjectState
        )
{
    HRESULT hr = S_OK;
    ADsAssert(Parent);
    ADsAssert(Name);
    ADsAssert(ClassName);


    if (  ( _tcsicmp( ClassName, PRINTJOB_CLASS_NAME ) == 0 )
       || ( _tcsicmp( ClassName, SESSION_CLASS_NAME ) == 0 )
       || ( _tcsicmp( ClassName, RESOURCE_CLASS_NAME ) == 0 )
       )
    {
        //
        // This three classes are not really DS objects so they don't
        // really have a parent. Hence, we set the parent string to empty
        // string.
        //
        hr = ADsAllocString( TEXT(""), &_ADsPath);

        BAIL_ON_FAILURE(hr);

        hr = ADsAllocString( TEXT(""), &_Parent);
    }
    else
    {
        hr = BuildADsPath(
                 Parent,
                 Name,
                 &_ADsPath
                 );

        BAIL_ON_FAILURE(hr);

        hr = ADsAllocString( Parent, &_Parent);
    }

    BAIL_ON_FAILURE(hr);

    hr = BuildADsGuid(
            rclsid,
            &_ADsGuid
        );
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( Name, &_Name);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ClassName, &_ADsClass);
    BAIL_ON_FAILURE(hr);

    hr = BuildSchemaPath(
        Parent,
        Name,
        Schema,
        &_Schema
        );
    BAIL_ON_FAILURE(hr);

    _dwObjectState = dwObjectState;

error:
    RRETURN(hr);
}

CCoreADsObject::CCoreADsObject():
                        _Name(NULL),
                        _ADsPath(NULL),
                        _Parent(NULL),
                        _ADsClass(NULL),
                        _Schema(NULL),
                        _ADsGuid(NULL),
                        _dwObjectState(0)
{
}


CCoreADsObject::~CCoreADsObject()
{
    if (_Name) {
        ADsFreeString(_Name);
    }

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_Parent) {
        ADsFreeString(_Parent);
    }

    if (_ADsClass) {
        ADsFreeString(_ADsClass);
    }

    if (_Schema) {
        ADsFreeString(_Schema);
    }

    if (_ADsGuid) {
        ADsFreeString(_ADsGuid);
    }
}


HRESULT
CCoreADsObject::get_CoreName(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Name, retval);
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CCoreADsObject::get_CoreADsPath(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsPath, retval);
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CCoreADsObject::get_CoreADsClass(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsClass, retval);
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CCoreADsObject::get_CoreParent(BSTR * retval)
{

    HRESULT hr;

   if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Parent, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreSchema(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    if ( _Schema == NULL || *_Schema == 0 )
        RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);

    hr = ADsAllocString(_Schema, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreGUID(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsGuid, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CCoreADsObject::GetInfo(THIS_ BOOL fExplicit, DWORD dwPropertyID)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cnamesp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cnamesp.cxx
//
//  Contents:  Windows NT 3.5 Namespace Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


DEFINE_IDispatch_Implementation(CNWCOMPATNamespace)
DEFINE_IADs_Implementation(CNWCOMPATNamespace)

//  Class CNWCOMPATNamespace

CNWCOMPATNamespace::CNWCOMPATNamespace()
{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CNWCOMPATNamespace);
}

HRESULT
CNWCOMPATNamespace::CreateNamespace(
    BSTR Parent,
    BSTR NamespaceName,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATNamespace FAR * pNamespace = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNamespaceObject(&pNamespace);
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->InitializeCoreObject(
                         Parent,
                         NamespaceName,
                         NAMESPACE_CLASS_NAME,
                         NO_SCHEMA,
                         CLSID_NWCOMPATNamespace,
                         dwObjectState
                         );
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNamespace->Release();  // <- WHY?

    RRETURN(hr);

error:

    delete pNamespace;
    RRETURN_EXP_IF_ERR(hr);
}


CNWCOMPATNamespace::~CNWCOMPATNamespace( )
{
    delete _pDispMgr;
    VariantClear(&_vFilter);
}

STDMETHODIMP
CNWCOMPATNamespace::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *)this;
    }else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPathnameProvider)) 
    {
        *ppv = (IADsPathnameProvider FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CNWCOMPATNamespace::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CNWCOMPATNamespace::SetInfo(
    THIS
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::GetInfo(
    THIS
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CNWCOMPATNamespace::get_Count(
    long FAR* retval
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::get_Filter(
    THIS_ VARIANT FAR* pVar
    )
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATNamespace::put_Filter(
    THIS_ VARIANT Var
    )
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATNamespace::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATNamespace::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    WCHAR szBuffer[MAX_PATH];
    DWORD dwLength = 0;
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    //
    // Make sure we are not going to overflow the string buffer.
    // +3 for // and \0
    //
    dwLength = wcslen(_ADsPath) + wcslen(RelativeName) + 3;

    if (dwLength > MAX_PATH) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    memset(szBuffer, 0, sizeof(szBuffer));

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"//");
    wcscat(szBuffer, RelativeName);

    if (ClassName && *ClassName) {
        //
        // +1 for the ",".
        //
        dwLength += wcslen(ClassName) + 1;
        if (dwLength > MAX_PATH) {
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }

        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATNamespace::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CNWCOMPATNamespaceEnum::Create(
                                     (CNWCOMPATNamespaceEnum **)&penum
                                     );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    return NOERROR;

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATNamespace::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::Delete(
    THIS_ BSTR SourceName,
    BSTR Type
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CNWCOMPATNamespace::AllocateNamespaceObject(
    CNWCOMPATNamespace ** ppNamespace
    )
{
    CNWCOMPATNamespace FAR * pNamespace = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNamespace = new CNWCOMPATNamespace();
    if (pNamespace == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADs,
             (IADs *)pNamespace,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsContainer,
             (IADsContainer *)pNamespace,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    pNamespace->_pDispMgr = pDispMgr;
    *ppNamespace = pNamespace;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}

HRESULT
CNWCOMPATNamespace::ParsePath(
    BSTR bstrADsPath, 
    DWORD dwType, 
    PPATH_OBJECTINFO pObjectInfo
    )

/*++

Routine Description:

    Parse a path based on the type and return the information in pObjectInfo

Arguments:

    bstrADsPath - ads path to be parsed
    dwType - the type of path to be parsed:
                   ADS_PARSE_FULL
                   ADS_PARSE_DN
                   ADS_PARSE_COMPONENT
    pObjectInfo - the place where the parsed object is stored
    
Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;
    OBJECTINFO ObjInfo;
    POBJECTINFO pObjInfo = &ObjInfo;
    PWSTR szPath = NULL;

    memset(pObjInfo, 0, sizeof(OBJECTINFO));

    switch (dwType) {
        case ADS_PARSE_FULL:
        {
            CLexer Lexer(bstrADsPath);

            hr = Object(&Lexer, pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        case ADS_PARSE_DN:
        {
            WCHAR szToken[MAX_TOKEN_LENGTH];
            DWORD dwToken;

            //
            // Collecting new information
            //
            CLexer Lexer(bstrADsPath);

            Lexer.SetAtDisabler(TRUE);

            hr = PathName(&Lexer,
                          pObjInfo);
            BAIL_ON_FAILURE(hr);

            hr = Lexer.GetNextToken(szToken,
                                    &dwToken);
            BAIL_ON_FAILURE(hr);

            if (dwToken != TOKEN_END) {
                hr = E_ADS_BAD_PATHNAME;
            }
            break;
        }

        case ADS_PARSE_COMPONENT:
        {
            CLexer Lexer(bstrADsPath);
        
            Lexer.SetAtDisabler(TRUE);
        
            hr = Component(&Lexer,
                           pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        default:
            break;
    }

    //
    // Setting new info
    //
    if (pObjInfo->ProviderName) {
        pObjectInfo->ProviderName = AllocADsStr(pObjInfo->ProviderName);
        if (!pObjectInfo->ProviderName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = SetObjInfoComponents(pObjInfo,
                              pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pObjectInfo->NumComponents = pObjInfo->NumComponents;
    pObjectInfo->dwPathType = ADS_PATHTYPE_ROOTFIRST;

error:
    FreeObjectInfo(pObjInfo,TRUE);
    if (szPath != NULL) {
        FreeADsStr(szPath);
    }
    return (hr);
}

HRESULT
CNWCOMPATNamespace::SetObjInfoComponents(
                        OBJECTINFO *pObjectInfo,
                        PATH_OBJECTINFO *pObjectInfoTarget
                        )

/*++

Routine Description:

    Set all the compoents in an objinfo from another objinfo. Assumes that the 
    components in the target objinfo is empty. Users of this function can call 
    FreeObjInfo to free that data prior to this function call.

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;
    HRESULT hr = S_OK;

    NumComponents = 0;
    while (NumComponents < pObjectInfo->NumComponents) {
        if (pObjectInfo->ComponentArray[NumComponents]) {
            pObjectInfoTarget->ComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents]);
            if (pObjectInfoTarget->ComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents]) {
            pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->DisplayComponentArray[NumComponents]);
            if (pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        NumComponents++;
    }
    pObjectInfoTarget->NumComponents = pObjectInfo->NumComponents;
    return hr;

error:
    FreeObjInfoComponents(pObjectInfoTarget);

    RRETURN_EXP_IF_ERR(hr);
}

void
CNWCOMPATNamespace::FreeObjInfoComponents(
                    PATH_OBJECTINFO *pObjectInfo
                    )

/*++

Routine Description:

    Free all the compoents in an objinfo

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;

    while (pObjectInfo->NumComponents > 0) {
        pObjectInfo->NumComponents--;
        NumComponents = pObjectInfo->NumComponents;

        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szComponent);
            pObjectInfo->ComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szValue);
            pObjectInfo->ComponentArray[NumComponents].szValue = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            pObjectInfo->DisplayComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            pObjectInfo->DisplayComponentArray[NumComponents].szValue = NULL;
        }
    }
}

void 
CNWCOMPATNamespace::SetComponent(
                    LPWSTR szReturn,
                    DWORD cComponents,
                    BOOL fEscaped
                    )

/*++

Routine Description:

    Set an individual component in the pathname. For internal use only. 
    Not exposed.

Arguments:
    
    szReturn - the buffer to store the return value
    cComponents - the component number to be set

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    PATH_COMPONENT* pComponent = NULL;
    if (fEscaped) {
        pComponent = _pObjectInfo->DisplayComponentArray;
    }
    else {
        pComponent = _pObjectInfo->ComponentArray;
    }

    if (pComponent[cComponents].szValue) {
        //
        // If value exist, only show display value
        //
        wcscat(szReturn,
               pComponent[cComponents].szValue);
    }
    else {
        //
        // else value is only stored in Component
        //
        wcscat(szReturn,
               pComponent[cComponents].szComponent);
    }
}


HRESULT 
CNWCOMPATNamespace::SetComponents(
                            LPWSTR szReturn,
                            LPWSTR chSeparator,
                            DWORD dwType,
                            BOOL fEscaped
                            )
/*++

Routine Description:

    Set components in the pathname. For internal use only. Not exposed.

Arguments:

    szReturn - the buffer to store the return value
    chSeparator - separator to be used
    dwType - the type to be set
        ADS_COMPONENT_LEAF
        ADS_COMPONENT_DN
        ADS_COMPONENT_PARENT


Return Value:

    S_OK on success, error code otherwise.

--*/
{
    HRESULT hr = S_OK;
    long cComponents;
    long dwLimit;
    long dwOtherLimit = 0;

    if (dwType == ADS_COMPONENT_LEAF) {
        //
        // Only returns the leaf component
        //
        if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
            if (_pObjectInfo->NumComponents > 0) {
                SetComponent(szReturn,
                             _pObjectInfo->NumComponents - 1,
                             fEscaped);
            } 
            else {
                hr = E_ADS_BAD_PATHNAME;
            }
        }
        else {
            if (_pObjectInfo->NumComponents != 0) {
                SetComponent(szReturn,
                             0,
                             fEscaped);
            } 
            else {
                hr = E_ADS_BAD_PATHNAME;
            }

        }
        RRETURN(hr);
    }

    dwLimit = _pObjectInfo->NumComponents;
    if (dwType == ADS_COMPONENT_PARENT) {
        dwLimit--;
    }
    if (dwOtherLimit >= dwLimit) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }
    for (cComponents = dwOtherLimit; cComponents < dwLimit; cComponents++) {
        SetComponent(szReturn,
                     cComponents,
                     fEscaped);
        if (cComponents != dwLimit - 1) {
            wcscat(szReturn,
                   chSeparator);
        }
    }
error:
    RRETURN(S_OK);
}

DWORD CountPath(
    PPATH_OBJECTINFO pObjectInfo
)
{
    DWORD dwPath = 4;   // Basic needs '://' and '/' for servername
    DWORD i;

    if (pObjectInfo->ProviderName) {
        dwPath += wcslen(pObjectInfo->ProviderName);
    }
    if (pObjectInfo->DisplayServerName) {
        dwPath += wcslen(pObjectInfo->DisplayServerName);
    }
    for (i=0;i<pObjectInfo->NumComponents;i++) {
        if (pObjectInfo->DisplayComponentArray[i].szComponent) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szComponent);
        }
        if (pObjectInfo->DisplayComponentArray[i].szValue) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szValue);
        }

        //
        // Add one for comma separator, one for equal sign
        //
        dwPath+=2; 
    }
    return dwPath;
}


STDMETHODIMP
CNWCOMPATNamespace::ConstructPath(
    PPATH_OBJECTINFO pObjectInfo,
    DWORD dwFormatType,
    DWORD dwFlag,
    DWORD dwEscapedMode,
    BSTR *pbstrADsPath
    )
{
    HRESULT hr = S_OK;
    PWSTR szReturn = NULL;
    long cComponents;
    DWORD dwPath = 0;
    BOOL fEscaped = FALSE;

    switch (dwEscapedMode) {
        case ADS_ESCAPEDMODE_OFF:
        case ADS_ESCAPEDMODE_DEFAULT:
        case ADS_ESCAPEDMODE_OFF_EX:
            fEscaped = FALSE;
            break;
        case ADS_ESCAPEDMODE_ON:
            fEscaped = TRUE;
            break;
        default:
            hr = E_INVALIDARG;
            goto error;
    }

    if (!pbstrADsPath) {
        hr = E_INVALIDARG;
        goto error;
    }

    dwPath = CountPath(pObjectInfo);
    szReturn = (PWSTR)AllocADsMem((dwPath + 1)* sizeof(WCHAR));
    if (szReturn == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    _pObjectInfo = pObjectInfo;

    wcscpy(szReturn,TEXT(""));

    switch (dwFormatType) {
        case ADS_FORMAT_WINDOWS:
        case ADS_FORMAT_WINDOWS_NO_SERVER:
            if (dwEscapedMode == ADS_ESCAPEDMODE_DEFAULT) {
                fEscaped = TRUE;
            }
            if (!pObjectInfo->ProviderName) {
                hr = E_FAIL;        // Need Error Code
                goto error;
            }
            wcscat(szReturn,pObjectInfo->ProviderName);
            wcscat(szReturn,TEXT("://"));

            if (dwFormatType == ADS_FORMAT_WINDOWS) {
                if (pObjectInfo->DisplayServerName && (*(pObjectInfo->DisplayServerName))) {
                    wcscat(szReturn,pObjectInfo->DisplayServerName);
                    if (pObjectInfo->NumComponents>0) {
                        wcscat(szReturn,TEXT("/"));
                    }
                }
            }
            hr = SetComponents(szReturn,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_DN:
            hr = SetComponents(szReturn,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_PARENT:
            hr = SetComponents(szReturn,
                               TEXT("/"),
                               ADS_COMPONENT_PARENT,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_X500:
        case ADS_FORMAT_X500_NO_SERVER:
        case ADS_FORMAT_X500_DN:
        case ADS_FORMAT_X500_PARENT:
            hr = E_NOTIMPL;
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_LEAF:
            //
            // Reverse only if pathtype is X500. In that case, we need to get
            // the first element but not the last
            //
            hr = SetComponents(szReturn,
                               NULL,
                               ADS_COMPONENT_LEAF,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        default:
            hr = E_INVALIDARG;
            goto error;
    }
    hr = ADsAllocString(szReturn, pbstrADsPath);
error:
    if (szReturn) {
        FreeADsMem(szReturn);
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATNamespace::GetEscapedElement(
    LONG lnReserved,
    BSTR bstrInStr,
    BSTR* pbstrOutStr
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cpgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cpgi.cxx
//
//  Contents:
//
//  History:   30-Apr-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//
// Properties Get & Set.
//

STDMETHODIMP
CNWCOMPATPrintQueue::get_Model(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_Model(THIS_ BSTR bstrModel)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_Datatype(THIS_ BSTR *retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_Datatype(THIS_ BSTR bstrDatatype)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_Location(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_Location(THIS_ BSTR bstrLocation)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_Priority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_Priority(THIS_ LONG lPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_StartTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_StartTime(THIS_ DATE daStartTime)
{
    PUT_PROPERTY_DATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_UntilTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_UntilTime(THIS_ DATE daUntilTime)
{
    PUT_PROPERTY_DATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_DefaultJobPriority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, DefaultJobPriority);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_DefaultJobPriority(THIS_ LONG lDefaultJobPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, DefaultJobPriority);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_BannerPage(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_BannerPage(THIS_ BSTR bstrBannerPage)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_PrinterPath(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, PrinterPath);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_PrinterPath(THIS_ BSTR bstrPrinterPath)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, PrinterPath);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_PrintProcessor(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, PrintProcessor);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_PrintProcessor(THIS_ BSTR bstrPrintProcessor)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_PrintDevices(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_PrintDevices(THIS_ VARIANT vPorts)
{
    PUT_PROPERTY_VARIANT((IADsPrintQueue *)this, Ports);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_NetAddresses(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsPrintQueue *)this, NetAddresses );
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_NetAddresses(THIS_ VARIANT vNetAddresses )
{
    PUT_PROPERTY_VARIANT((IADsPrintQueue *)this, NetAddresses );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cprovcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  NetWare 3.12 Provider Object Class Factory Code
//
//             CNWCOMPATProviderCF::CreateInstance
//
//  History:   10-Jan-96     t-ptam    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATProviderCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    10-Jan-96     t-ptam    Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATProviderCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr;
    CNWCOMPATProvider *     pProvider;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CNWCOMPATProvider::Create(&pProvider);

    if (FAILED(hr)) {
        RRETURN (hr);
    }

    if (pProvider)
    {
        hr = pProvider->QueryInterface(iid, ppv);
        pProvider->Release();
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cpop.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cpop.cxx
//
//  Contents:
//
//  History:   30-Apr-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::PrintJobs
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::PrintJobs(
    THIS_ IADsCollection FAR* FAR* ppCollection
    )
{
    HRESULT hr = S_OK;

    //
    // Get Job collection object.
    //

    hr = CNWCOMPATJobCollection::CreateJobCollection(
             _Parent,
             _Name,
             IID_IADsCollection,
             (void **)ppCollection
             );

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::Pause
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::Pause(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;
    WCHAR szUncPrinterName[MAX_PATH];

    //
    // Make Unc printer name.
    //

    hr = get_CoreADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = NWApiUncFromADsPath(
             bstrADsPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Pause printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_PAUSE
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    ADSFREESTRING(bstrADsPath);

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::Resume
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::Resume(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;
    WCHAR szUncPrinterName[MAX_PATH];

    //
    // Make Unc printer name.
    //

    hr = get_CoreADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = NWApiUncFromADsPath(
             bstrADsPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Resume printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_RESUME
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::Purge
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::Purge(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;
    WCHAR szUncPrinterName[MAX_PATH];

    //
    // Make Unc printer name.
    //

    hr = get_CoreADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = NWApiUncFromADsPath(
             bstrADsPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Purge printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_PURGE
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    RRETURN_EXP_IF_ERR(hr);
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::get_Status
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::get_Status(
    THIS_ long FAR* retval
    )
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cprinter.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:  cprinter.cxx
//
//  Contents:  CNWCOMPATPrinter
//
//
//  History:   30-Apr-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop


//
// Printer Class
//


//
// Macro-ized implementation.
//

DEFINE_IDispatch_ExtMgr_Implementation(CNWCOMPATPrintQueue)

DEFINE_IADs_TempImplementation(CNWCOMPATPrintQueue)

DEFINE_IADs_PutGetImplementation(CNWCOMPATPrintQueue, PrintQueueClass, gdwPrinterTableSize)

DEFINE_IADsPropertyList_Implementation(CNWCOMPATPrintQueue, PrintQueueClass, gdwPrinterTableSize)



//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::CNWCOMPATPrintQueue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATPrintQueue::CNWCOMPATPrintQueue():
    _pDispMgr(NULL),
    _pExtMgr(NULL)
{
    ENLIST_TRACKING(CNWCOMPATPrintQueue);
    _pPropertyCache = NULL;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::~CNWCOMPATPrintQueue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATPrintQueue::~CNWCOMPATPrintQueue()
{
    delete _pExtMgr;            // created last, destroyed first
    delete _pDispMgr;
    delete _pPropertyCache;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue:: CreatePrintQueue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintQueue:: CreatePrintQueue(
    LPTSTR pszADsParent,
    LPTSTR pszPrinterName,
    DWORD  dwObjectState,
    REFIID riid,
    LPVOID * ppvoid
    )
{
    CNWCOMPATPrintQueue *pPrintQueue =  NULL;
    HRESULT hr = S_OK;
    LPWSTR lpszTempName = NULL;

    //
    // Create the printer object
    //

    hr = AllocatePrintQueueObject(
             &pPrintQueue
             );
    BAIL_ON_FAILURE(hr);

    //
    // Initialize the core object
    //

    hr = pPrintQueue->InitializeCoreObject(
                          pszADsParent,
                          pszPrinterName,
                          PRINTER_CLASS_NAME,
                          PRINTER_SCHEMA_NAME,
                          CLSID_NWCOMPATPrintQueue,
                          dwObjectState
                          );
    BAIL_ON_FAILURE(hr);

    //
    // Query for the specified interface.
    //

    hr = pPrintQueue->QueryInterface(
                          riid,
                          (void **)ppvoid
                          );
    BAIL_ON_FAILURE(hr);

    //
    // Make Unc Printer name for Win32 API.
    //

    hr = BuildPrinterNameFromADsPath(
                pszADsParent,
                pszPrinterName,
                pPrintQueue->_szUncPrinterName
                );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    pPrintQueue->Release();

    hr = pPrintQueue->_pExtMgr->FinalInitializeExtensions();
    BAIL_ON_FAILURE(hr);

    RRETURN(hr);

error:
    delete pPrintQueue;
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::QueryInterface(
    REFIID riid,
    LPVOID FAR* ppvObj
    )
{
    if(!ppvObj)
    {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsPrintQueue FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsPrintQueue FAR *)this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsPrintQueue FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintQueue))
    {
        *ppvObj = (IADsPrintQueue FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintQueueOperations))
    {
        *ppvObj = (IADsPrintQueueOperations FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::InterfaceSupportsErrorInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsPrintQueue) ||
        IsEqualIID(riid, IID_IADsPrintQueueOperations) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::SetInfo(THIS)
{
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    LPBYTE  lpbBuffer = NULL;

    //
    // Make sure object is bound to a tangible resource.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
       /*
        hr = NWApiAddPrinter();
        BAIL_ON_FAILURE(hr);
       */
        SetObjectState(ADS_OBJECT_BOUND);
    }

    //
    // Open a handle to a printer.
    //

    hr = NWApiOpenPrinter(
             _szUncPrinterName,
             &hPrinter,
             PRINTER_ALL_ACCESS
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get Printer Info structure.
    //

    hr = NWApiGetPrinter(
             hPrinter,
             WIN32_API_LEVEL_2,
             &lpbBuffer
             );
    BAIL_ON_FAILURE(hr);

    //
    // Set info.
    //

    hr = MarshallAndSet(
             hPrinter,
             (LPPRINTER_INFO_2) lpbBuffer
             );
error:

    //
    // Close Printer handle.
    //

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (lpbBuffer) {
        FreeADsMem((void*)lpbBuffer);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::GetInfo(THIS)
{

    _pPropertyCache->flushpropcache();

    RRETURN (GetInfo(
                 TRUE,
                 PRINTER_API_LEVEL
                 ));
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::AllocatePrintQueueObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintQueue::AllocatePrintQueueObject(
    CNWCOMPATPrintQueue FAR * FAR * ppPrintQueue
    )
{
    CNWCOMPATPrintQueue FAR * pPrintQueue = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CADsExtMgr FAR * pExtensionMgr = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a PrintQueue object.
    //

    pPrintQueue = new CNWCOMPATPrintQueue();
    if (pPrintQueue == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPrintQueue,
             (IADsPrintQueue *) pPrintQueue,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPrintQueueOperations,
             (IADsPrintQueueOperations *) pPrintQueue,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPropertyList,
             (IADsPropertyList *) pPrintQueue,
             DISPID_VALUE
             );
    BAIL_ON_FAILURE(hr);


    hr = CPropertyCache::createpropertycache(
             PrintQueueClass,
             gdwPrinterTableSize,
             (CCoreADsObject *)pPrintQueue,
             &(pPrintQueue->_pPropertyCache)
             );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                pPrintQueue->_pPropertyCache
                );

    hr = ADSILoadExtensionManager(
                PRINTER_CLASS_NAME,
                (IADsPrintQueue *) pPrintQueue,
                pDispMgr,
                &pExtensionMgr
                );
    BAIL_ON_FAILURE(hr);


    //
    // Return.
    //

    pPrintQueue->_pDispMgr = pDispMgr;
    pPrintQueue->_pExtMgr = pExtensionMgr;

    *ppPrintQueue = pPrintQueue;

    RRETURN(hr);

error:
    delete  pDispMgr;
    delete  pPrintQueue;
    delete  pExtensionMgr;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::GetInfo(
    THIS_ BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    LPBYTE  lpbPrinterInfo = NULL;

    //
    // Open a handle to a printer.
    //

    hr = NWApiOpenPrinter(
             _szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get printer's info.
    //

    hr = NWApiGetPrinter(
             hPrinter,
             WIN32_API_LEVEL_2,
             &lpbPrinterInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Unmarshall.
    //

    hr = UnMarshall_GeneralInfo(
             (LPPRINTER_INFO_2) lpbPrinterInfo,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

    hr = UnMarshall_Operation(
             (LPPRINTER_INFO_2) lpbPrinterInfo,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

error:

    if(lpbPrinterInfo){
        FreeADsMem(lpbPrinterInfo);
    }

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::UnMarshall_GeneralInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintQueue::UnMarshall_GeneralInfo(
    LPPRINTER_INFO_2 lpPrinterInfo2,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    DATE daStartTime = 0;
    DATE daUntilTime = 0;
    VARIANT vPortNames;

   hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("PrinterPath"),
                                  _szUncPrinterName,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Model"),
                                  lpPrinterInfo2->pDriverName,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Datatype"),
                                  lpPrinterInfo2->pDatatype,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("PrintProcessor"),
                                  lpPrinterInfo2->pPrintProcessor,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Description"),
                                  lpPrinterInfo2->pComment,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Location"),
                                  lpPrinterInfo2->pLocation,
                                  fExplicit
                                  );

    hr = SetDATEPropertyInCache(_pPropertyCache,
                                TEXT("StartTime"),
                                lpPrinterInfo2->StartTime,
                                fExplicit
                                );

    hr = SetDATEPropertyInCache(_pPropertyCache,
                                  TEXT("UntilTime"),
                                  lpPrinterInfo2->UntilTime,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("DefaultJobPriority"),
                                 lpPrinterInfo2->DefaultPriority,
                                 fExplicit
                                 );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("Priority"),
                                  lpPrinterInfo2->Priority,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("BannerPage"),
                                  lpPrinterInfo2->pSepFile,
                                  fExplicit
                                  );

    hr = SetDelimitedStringPropertyInCache(_pPropertyCache,
                                           TEXT("PrintDevices"),
                                           lpPrinterInfo2->pPortName,
                                           fExplicit
                                           );

    hr = S_OK;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::UnMarshall_Operation
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintQueue::UnMarshall_Operation(
    LPPRINTER_INFO_2 lpPrinterInfo2,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("Status"),
                                  lpPrinterInfo2->Status,
                                  fExplicit
                                  );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue:: MarshallAndSet
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintQueue::MarshallAndSet(
    HANDLE hPrinter,
    LPPRINTER_INFO_2 lpPrinterInfo2
    )
{
    LPTSTR              pszDriverName = NULL;
    LPTSTR              pszDatatype = NULL;
    LPTSTR              pszDescription = NULL;
    LPTSTR              pszLocation = NULL;
    LPTSTR              pszBannerPage = NULL;
    LPTSTR              pszHostComputer = NULL;
    LPTSTR              pszPrintProcessor = NULL;
    HRESULT           hr = S_OK;
    LPTSTR            pszPorts = NULL;
    VARIANT           vTemp;
    DWORD             dwTimeValue;
    DWORD             dwPriority;

    //
    // Set Model.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Model"),
                    &pszDriverName
                    );
    if (SUCCEEDED(hr)){
        lpPrinterInfo2->pDriverName = (LPTSTR)pszDriverName;
    }

    //
    // Set Datatype.
    //
    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Datatype"),
                    &pszDatatype
                    );
    if (SUCCEEDED(hr)){
        lpPrinterInfo2->pDatatype = (LPTSTR)pszDatatype;
    }

    //
    // Set Description.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );
    if (SUCCEEDED(hr)){
        lpPrinterInfo2->pComment = (LPTSTR)pszDescription;
    }

    //
    // Set Location.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Location"),
                    &pszLocation
                    );
    if (SUCCEEDED(hr)){
        lpPrinterInfo2->pLocation = (LPTSTR)pszLocation;
    }

    //
    // Set Priority.
    //

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Priority"),
                    &dwPriority
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->Priority = dwPriority;
    }

    //
    // Set StartTime.
    //

    hr = GetDATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("StartTime"),
                    &dwTimeValue
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->StartTime = dwTimeValue;
    }


    //
    // Set UntilTime.
    //
    hr = GetDATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("UntilTime"),
                    &dwTimeValue
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->UntilTime = dwTimeValue;
    }


    //
    // Set DefaultJobPriority.
    //

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("DefaultJobPriority"),
                    &dwPriority
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->DefaultPriority = dwPriority;
    }


    //
    // Set BannerPage.
    //
    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("BannerPage"),
                    &pszBannerPage
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->pSepFile = pszBannerPage;
    }


    //
    // Set PrintProcessor.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PrintProcessor"),
                    &pszPrintProcessor
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->pPrintProcessor = pszPrintProcessor;
    }

    //
    // Set Ports.
    //


    hr = GetDelimitedStringPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PrintDevices"),
                    &pszPorts
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->pPortName = pszPorts;
    }


    //
    // Commit changes.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             WIN32_API_LEVEL_2,
             (LPBYTE) lpPrinterInfo2,
             0
             );
    BAIL_ON_FAILURE(hr);

error:
    if(pszDriverName)
        FreeADsStr(pszDriverName);
    if(pszDatatype)
        FreeADsStr(pszDatatype);
    if(pszDescription)
        FreeADsStr(pszDescription);
    if(pszLocation)
        FreeADsStr(pszLocation);
    if(pszBannerPage)
        FreeADsStr(pszBannerPage);
    if(pszPrintProcessor)
        FreeADsStr(pszPrintProcessor);
    if(pszPorts)
        FreeADsStr(pszPorts);


    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cprops.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cprops.cxx
//
//  Contents:   Property Cache functionality for NW
//
//  Functions:
//                CPropertyCache::addproperty
//                CPropertyCache::updateproperty
//                CPropertyCache::findproperty
//                CPropertyCache::getproperty
//                CPropertyCache::putproperty
//                CProperyCache::CPropertyCache
//                CPropertyCache::~CPropertyCache
//                CPropertyCache::createpropertycache
//
//  History:      17-June-1996   KrishnaG   Created.
//                cloned off NDS property cache code
//
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma  hdrstop




//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::addproperty
//
//  Synopsis:   adds a new empty property to the cache
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vt]                --
//              [vaData]            --
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
addproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pNewProperty = NULL;
    LPWSTR tempString = NULL;

    //
    // Allocate the string first
    //
    tempString = AllocADsStr(szPropertyName);

    if (!tempString)
       BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);


    //
    //  extend the property cache by adding a new property entry
    //

    _pProperties = (PPROPERTY)ReallocADsMem(
                                _pProperties,
                                _cb,
                                _cb + sizeof(PROPERTY)
                                );
    if (!_pProperties) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    pNewProperty = (PPROPERTY)((LPBYTE)_pProperties + _cb);

    if (pNewProperty->szPropertyName) {
       FreeADsStr(pNewProperty->szPropertyName);
       pNewProperty->szPropertyName = NULL;
    }

    //
    // Since the memory has already been allocated in tempString
    // just set the value/pointer now.
    //
    pNewProperty->szPropertyName = tempString;


    //
    // Update the index
    //

    _dwMaxProperties++;
    _cb += sizeof(PROPERTY);

    RRETURN(hr);

error:

    if (tempString)
       FreeADsStr(tempString);

    RRETURN_EXP_IF_ERR(hr);
}






//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::updateproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vaData]    --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::updateproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNTOBJECT pNtObject,
    BOOL fExplicit
    )
{
    HRESULT hr;
    DWORD dwIndex;
    PNTOBJECT pNtTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;


    if (!fExplicit) {
        if (PROPERTY_IS_MODIFIED(pThisProperty)) {
            hr = S_OK;
            goto error;
        }
    }

    //
    //   Factor in cases where object state is necessary to
    //   decide on update.
    //

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        NTTypeFreeNTObjects(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_NTOBJECT(pThisProperty) = NULL;
    }

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

    hr = NtTypeCopyConstruct(
            pNtObject,
            dwNumValues,
            &pNtTempObject
            );
    BAIL_ON_FAILURE(hr);

    PROPERTY_NTOBJECT(pThisProperty) = pNtTempObject;

    PROPERTY_FLAGS(pThisProperty)  &= ~CACHE_PROPERTY_MODIFIED;

error:

    RRETURN_EXP_IF_ERR(hr);

}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::findproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::findproperty(
    LPWSTR szPropertyName,
    PDWORD pdwIndex
    )

{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    for (i = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        if (!_wcsicmp(pThisProperty->szPropertyName, szPropertyName)) {
            *pdwIndex = i;
            RRETURN(S_OK);
        }
    }
    *pdwIndex = 0;
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_FOUND);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
getproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;
    DWORD dwResult;
    DWORD dwInfoLevel = 0;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {

        hr = GetPropertyInfoLevel(
                    szPropertyName,
                    _pSchemaClassProps,
                    _dwNumProperties,
                    &dwInfoLevel
                    );
        BAIL_ON_FAILURE(hr);

        //
        // Now call the GetInfo function
        //

        hr = _pCoreADsObject->GetInfo(
                    FALSE,
                    dwInfoLevel
                    );
        BAIL_ON_FAILURE(hr);

        hr = findproperty(
                    szPropertyName,
                    &dwIndex
                    );

    }
    BAIL_ON_FAILURE(hr);




    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(PROPERTY_NTOBJECT(pThisProperty),
                                 PROPERTY_NUMVALUES(pThisProperty),
                                 ppNtObject );
        BAIL_ON_FAILURE(hr);
    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:
    RRETURN_EXP_IF_ERR(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::marshallgetproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
marshallgetproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;
    DWORD dwResult;
    DWORD dwInfoLevel = 0;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );

    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(PROPERTY_NTOBJECT(pThisProperty),
                                 PROPERTY_NUMVALUES(pThisProperty),
                                 ppNtObject );
        BAIL_ON_FAILURE(hr);
    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:
    RRETURN_EXP_IF_ERR(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Clsid index
//              [vaData]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::putproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNTOBJECT pNtObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PNTOBJECT pNtTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;


    //
    // AccountLocked is "half writable" -> need special care
    //

    if (_wcsicmp(szPropertyName, TEXT("IsAccountLocked"))==0 ) {

        if (pNtObject->NTType != NT_SYNTAX_ID_BOOL) {
            hr = E_ADS_BAD_PARAMETER;
            BAIL_ON_FAILURE(hr);
        }

        //
        // canNOT just disallow user to set cache to TRUE since
        // user may have accidentally set cache to FALSE (unlock) and
        // want to set the cache back to TRUE (do not unlock) without
        // GetInfo to affect other changes in cache. It will be a major
        // mistake if cuser cannot set the cache back to TRUE after
        // changing it to FALSE accidentally and thus unlocking the
        // account even if the user does not want to.
        //
        // If cache value on IsAccountLocked is changed from FALSE to TRUE,
        // cached value will be automatically changed back to FALSE upon
        // SetInfo since user cannot lock an account thru' ADSI. (NW server
        // wont' allow. Ref: SysCon)
        //
        // Should: If new value == value already in cache, do nothing.
        //         That is, do not try to set the cache_property_modified flag.
        //         This is to prevent
        //         1) the side effect of setting BadLogins to 0 when a
        //            user set the cached property IsAccountLocked
        //            from FALSE to FALSE (no change really) and call SetInfo.
        //         2) the side effect of changing the cache value to 0 (not
        //            consistent with server or original cached value) when
        //            a user set the cache property IsAccontLocked
        //            from TRUE to TRUE (no change really) and call SetInfo.
        //
        //         If user set IsAccountLocked from FALSE to TRUE and then
        //         back to FALSE, or from TRUE to FALSE and then back to TURE,
        //         side effect 1) or 2) will happen.
        //         Both side effect not critical.
        //
		// We first check whether the object has been set previously, if not,
		// NTOBJECT will be NULL
		//
        if (PROPERTY_NTOBJECT(pThisProperty) &&
			(pNtObject->NTValue.fValue ==
					PROPERTY_NTOBJECT(pThisProperty)->NTValue.fValue)) {
            RRETURN(S_OK);
        }
    }


    if (PROPERTY_NTOBJECT(pThisProperty)) {

        NTTypeFreeNTObjects(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_NTOBJECT(pThisProperty) = NULL;
    }

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

    hr = NtTypeCopyConstruct(
            pNtObject,
            dwNumValues,
            &pNtTempObject
            );
    BAIL_ON_FAILURE(hr);

    PROPERTY_NTOBJECT(pThisProperty) = pNtTempObject;

    PROPERTY_FLAGS(pThisProperty) |= CACHE_PROPERTY_MODIFIED;

error:
    RRETURN_EXP_IF_ERR(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::CPropertyCache():
    _pCoreADsObject(NULL),
    _pSchemaClassProps(NULL),
    _dwMaxProperties(0),
    _pProperties(NULL),
    _dwCurrentIndex(0),
    _cb(0)
{

}

//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
~CPropertyCache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

            if (pThisProperty->szPropertyName) {
               FreeADsStr(pThisProperty->szPropertyName);
               pThisProperty->szPropertyName = NULL;
            }

            if (PROPERTY_NTOBJECT(pThisProperty)) {

                NTTypeFreeNTObjects(
                        PROPERTY_NTOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_NTOBJECT(pThisProperty) = NULL;
            }
        }
        FreeADsMem(_pProperties);
    }
}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
createpropertycache(
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    CCoreADsObject FAR * pCoreADsObject,
    CPropertyCache FAR *FAR * ppPropertyCache
    )
{
    CPropertyCache FAR * pPropertyCache = NULL;

    pPropertyCache = new CPropertyCache();

    if (!pPropertyCache) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    pPropertyCache->_pCoreADsObject = pCoreADsObject;
    pPropertyCache->_pSchemaClassProps = pSchemaClassProps;
    pPropertyCache->_dwNumProperties = dwNumProperties;

    *ppPropertyCache = pPropertyCache;

    RRETURN(S_OK);
}


//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::
unmarshallproperty(
    LPWSTR szPropertyName,
    LPBYTE lpValue,
    DWORD  dwNumValues,
    DWORD  dwSyntaxId,
    BOOL fExplicit
    )
{

    DWORD dwIndex = 0;
    HRESULT hr = S_OK;
    PNTOBJECT pNTObject = NULL;

    hr = UnMarshallNTToNTSynId(
                dwSyntaxId,
                dwNumValues,
                lpValue,
                &pNTObject
                );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = findproperty(
                szPropertyName,
                &dwIndex
                );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = addproperty(
                    szPropertyName,
                    dwSyntaxId
                    );

        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = updateproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNTObject,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);


    if (pNTObject) {
        NTTypeFreeNTObjects(
                pNTObject,
                dwNumValues
                );

    }


error:
    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
ValidatePropertyinSchemaClass(
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    LPWSTR pszPropName,
    PDWORD pdwSyntaxId
    )
{
    DWORD i = 0;

    PPROPERTYINFO pThisSchProperty = NULL;

    for (i = 0; i < dwNumProperties; i++) {

         pThisSchProperty =  (pSchemaClassProps + i);

        if (!_wcsicmp(pszPropName, pThisSchProperty->szPropertyName)) {
            *pdwSyntaxId = pThisSchProperty->dwSyntaxId;
            RRETURN (S_OK);
        }
    }

    RRETURN(E_ADS_SCHEMA_VIOLATION);
}



HRESULT
ValidateIfWriteableProperty(
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    LPWSTR pszPropName
    )
{
    DWORD i = 0;

    PPROPERTYINFO pThisSchProperty = NULL;

    for (i = 0; i < dwNumProperties; i++) {

         pThisSchProperty =  (pSchemaClassProps + i);

        if (!_wcsicmp(pszPropName, pThisSchProperty->szPropertyName)) {

             RRETURN((pThisSchProperty->dwFlags & PROPERTY_WRITEABLE)
                        ? S_OK : E_ADS_SCHEMA_VIOLATION);
        }
    }

    RRETURN(E_ADS_SCHEMA_VIOLATION);

    // for winnt & nw312, return E_ADS_SCHEMA_VIOLATION if not ok even
    // attempt to write to cache only
}



HRESULT
GetPropertyInfoLevel(
    LPWSTR pszPropName,
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    PDWORD pdwInfoLevel
    )
{
    DWORD i = 0;

    PPROPERTYINFO pThisSchProperty = NULL;

    for (i = 0; i < dwNumProperties; i++) {

         pThisSchProperty =  (pSchemaClassProps + i);

        if (!_wcsicmp(pszPropName, pThisSchProperty->szPropertyName)) {

             *pdwInfoLevel = pThisSchProperty->dwInfoLevel;
             RRETURN(S_OK);
        }
    }

    //
    // Returning E_ADS_PROPERTY_NOT_FOUND so that implicit
    // GetInfo fails gracefully
    //
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_FOUND);
}

//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
void
CPropertyCache::
flushpropcache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

            if (pThisProperty->szPropertyName) {
               FreeADsStr(pThisProperty->szPropertyName);
               pThisProperty->szPropertyName = NULL;
            }

            if (PROPERTY_NTOBJECT(pThisProperty)) {

                NTTypeFreeNTObjects(
                        PROPERTY_NTOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_NTOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }

    //
    // Reset the property cache
    //

    _pProperties = NULL;
    _dwMaxProperties = 0;
    _cb = 0;
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNtObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:

   RRETURN_EXP_IF_ERR(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    DWORD dwIndex,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex)) {
        RRETURN(E_ADS_BAD_PARAMETER);     // better if E_ADS_INDEX or sth
     }

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNtObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:

   RRETURN_EXP_IF_ERR(hr);
}


BOOL
CPropertyCache::
index_valid(
   )
{
    //
    // need to check _dwMaxProperties==0 separately since a negative
    // DWORD is equal to +ve large #
    //

    if (_dwMaxProperties==0 || (_dwCurrentIndex>_dwMaxProperties-1) )
        return(FALSE);
    else
        return(TRUE);
}


BOOL
CPropertyCache::
index_valid(
   DWORD dwIndex
   )
{
    //
    // need to check _dwMaxProperties==0 separately since a negative
    // DWORD is equal to +ve large #
    //

    if (_dwMaxProperties==0 || (dwIndex>_dwMaxProperties-1) )
        return(FALSE);
    else
        return(TRUE);
}


void
CPropertyCache::
reset_propindex(
    )
{
  _dwCurrentIndex = 0;

}


HRESULT
CPropertyCache::
skip_propindex(
    DWORD dwElements
    )
{
    DWORD newIndex = _dwCurrentIndex + dwElements;

    if (!index_valid())
        RRETURN_EXP_IF_ERR(E_FAIL);

    //
    // - allow current index to go from within range to out of range by 1
    // - by 1 since initial state is out of range by 1
    //

    if (newIndex>_dwMaxProperties) {
        RRETURN_EXP_IF_ERR(E_FAIL);
    }

    _dwCurrentIndex = newIndex;

    RRETURN(S_OK);
}


HRESULT
CPropertyCache::
get_PropertyCount(
    PDWORD pdwMaxProperties
    )
{
    *pdwMaxProperties = _dwMaxProperties;

    RRETURN(S_OK);
}

DWORD
CPropertyCache::
get_CurrentIndex(
    )
{
    return(_dwCurrentIndex);
}

LPWSTR
CPropertyCache::
get_CurrentPropName(
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid())
        return(NULL);

    pThisProperty = _pProperties + _dwCurrentIndex;

    return(PROPERTY_NAME(pThisProperty));
}

LPWSTR
CPropertyCache::
get_PropName(
    DWORD dwIndex
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex))
       return(NULL);

    pThisProperty = _pProperties + dwIndex;

    return(PROPERTY_NAME(pThisProperty));
}

HRESULT
CPropertyCache::
deleteproperty(
    DWORD dwIndex
    )
{
   HRESULT hr = S_OK;
   PPROPERTY pNewProperties = NULL;
   PPROPERTY pThisProperty = _pProperties + dwIndex;

   if (!index_valid(dwIndex)) {
      RRETURN(E_ADS_BAD_PARAMETER);
   }

   if (_dwMaxProperties == 1) {
      //
      // Deleting everything
      //
      if (PROPERTY_NTOBJECT(pThisProperty)) {
          NTTypeFreeNTObjects(
                  PROPERTY_NTOBJECT(pThisProperty),
                  PROPERTY_NUMVALUES(pThisProperty)
                  );
          PROPERTY_NTOBJECT(pThisProperty) = NULL;
      }

      FreeADsMem(_pProperties);
      _pProperties = NULL;
      _dwMaxProperties = 0;
      _cb = 0;
      //
      // Reset the current index just in case
      //
      _dwCurrentIndex = 0;
      RRETURN(hr);
   }

   pNewProperties = (PPROPERTY)AllocADsMem(
                               _cb - sizeof(PROPERTY)
                               );
   if (!pNewProperties) {
       hr = E_OUTOFMEMORY;
       BAIL_ON_FAILURE(hr);
   }

   //
   // Copying the memory before the deleted item
   //
   if (dwIndex != 0) {
      memcpy( pNewProperties,
              _pProperties,
              dwIndex * sizeof(PROPERTY));
   }

   //
   // Copying the memory following the deleted item
   //
   if (dwIndex != (_dwMaxProperties-1)) {
      memcpy( pNewProperties + dwIndex,
              _pProperties + dwIndex + 1,
              (_dwMaxProperties - dwIndex - 1) * sizeof(PROPERTY));
   }

   if (PROPERTY_NTOBJECT(pThisProperty)) {
       NTTypeFreeNTObjects(
               PROPERTY_NTOBJECT(pThisProperty),
               PROPERTY_NUMVALUES(pThisProperty)
               );
       PROPERTY_NTOBJECT(pThisProperty) = NULL;
   }
   FreeADsMem(_pProperties);
   _pProperties = pNewProperties;
   _dwMaxProperties--;
   _cb -= sizeof(PROPERTY);
   //
   // Reset the current index if necesary so we do not skip a property.
   //
   if (_dwCurrentIndex > dwIndex) {
       _dwCurrentIndex--;
   }
error:

   RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CPropertyCache::
propertyismodified(
    LPWSTR szPropertyName,
    BOOL * pfModified
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;

    if (!szPropertyName || !pfModified) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    *pfModified=PROPERTY_IS_MODIFIED(pThisProperty);

error:

    RRETURN(hr);
}


////////////////////////////////////////////////////////////////////////
//
//  IPropertyCache
//

HRESULT
CPropertyCache::
locateproperty(
    LPWSTR  szPropertyName,
    PDWORD  pdwDispid
    )
{
    HRESULT hr;
    DWORD dwSyntaxId;   // (dummy)

    if (!pdwDispid || !szPropertyName)
        RRETURN(DISP_E_PARAMNOTOPTIONAL);

    //
    // return dispid of property if already in table;
    //
    hr = findproperty(
            szPropertyName,
            pdwDispid
            );

    if (hr==E_ADS_PROPERTY_NOT_FOUND) {

        //
        // check if property in schema
        //      - this is necessary; otherwise, property not in schema will
        //        be allowed to be added to cache and will not be given the
        //        chance to be handled by 3rd party extension.
        //      - note that property not in schema but added to the cache
        //        thru' IADsProperty list will not be handled by 3rd
        //        party extension either.
        //
        hr = ValidatePropertyinSchemaClass(
                _pSchemaClassProps,
                _dwNumProperties,
                szPropertyName,
                &dwSyntaxId
                );

        //
        // Add property that is in the schema but not in the cache
        // That is, property which is in the
        // schema will always be handled by the cache/server thur ADSI but
        // will NOT be handled by 3rd party extension.
        //
        if (SUCCEEDED(hr)) {

            hr = addproperty(
                        szPropertyName,
                        dwSyntaxId
                        );
            BAIL_ON_FAILURE(hr);

        }

        //
        // Property Not in the schema will nto be added to the dynamic
        // dispid table and could be handled by 3rd party extension.
        //
        else {

            hr = DISP_E_MEMBERNOTFOUND;
            BAIL_ON_FAILURE(hr);

        }
    }

    RRETURN(hr);

error:

    //
    // translate E_ADS_ error codes to DISP_E if appropriate, see above
    //
    ADsECodesToDispECodes(&hr);

    *pdwDispid = (DWORD) DISPID_UNKNOWN;

    RRETURN(hr);
}


HRESULT
CPropertyCache::
getproperty(
    DWORD   dwDispid,
    VARIANT * pvarVal
    )
{
    HRESULT hr;
    LPWSTR szPropName = NULL;
    DWORD dwSyntaxId = (DWORD) -1;
    DWORD dwNumValues = 0;
    PNTOBJECT pNtObjs = NULL;

    //
    // Use DISP_E_ERROR codes since this function directly called by
    // the dispatch manager
    //
    if (!pvarVal)
        RRETURN(DISP_E_PARAMNOTOPTIONAL);

    if (!index_valid(dwDispid))
        RRETURN(DISP_E_MEMBERNOTFOUND);

    szPropName = PROPERTY_NAME((_pProperties + dwDispid));

    //
    // return value in cache for szPropName; retrieve value from server
    // if not already in cache; fail if none on sever
    //
    hr = getproperty(
            szPropName,
            &dwSyntaxId,
            &dwNumValues,
            &pNtObjs
            );
    BAIL_ON_FAILURE(hr);

    //
    // translate NT objects into variants
    //
    if (dwNumValues == 1) {

        hr = NtTypeToVarTypeCopy(
                pNtObjs,
                pvarVal
                );

    } else {

        hr = NtTypeToVarTypeCopyConstruct(
                pNtObjs,
                dwNumValues,
                pvarVal
                );
    }
    BAIL_ON_FAILURE(hr);

error:

    if (pNtObjs) {

        NTTypeFreeNTObjects(
            pNtObjs,
            dwNumValues
            );
    }

    if (FAILED(hr)) {

        //
        // return DISP_E errors instead E_ADS_ errors , see above
        //
        ADsECodesToDispECodes(&hr);

        V_VT(pvarVal) = VT_ERROR;
    }

    RRETURN(hr);
}


HRESULT
CPropertyCache::
putproperty(
    DWORD   dwDispid,
    VARIANT varVal
    )
{

    HRESULT hr;
    LPWSTR szPropName = NULL;
    VARIANT * pvProp = NULL;            // do not free
    DWORD dwNumValues = 0;
    VARIANT * pTempVarArray = NULL;     // to be freed
    DWORD dwSyntaxId = (DWORD) -1;
    LPNTOBJECT pNtObjs = NULL;
    DWORD dwIndex = (DWORD) -1;

    //
    // Use DISP_E_ERROR codes since this function directly called by
    // the dispatch manager
    //
    if (!index_valid(dwDispid))
        RRETURN(DISP_E_MEMBERNOTFOUND);

    //
    // retreive property name from Dynamic Dispatch Table
    //
    szPropName = PROPERTY_NAME((_pProperties + dwDispid));
    dwSyntaxId = PROPERTY_SYNTAX((_pProperties + dwDispid));

    //
    // translate variant to NT Objects
    //

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside. ??
    //
    pvProp = &varVal;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(pvProp);
    }

    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY)) ||
        (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF))) {

        hr  = ConvertByRefSafeArrayToVariantArray(
                    varVal,
                    &pTempVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);

        pvProp = pTempVarArray;

    }else {

        //
        // Single value NOT stored in array MUST BE ALLOWED since clients
        // would expect Put() to behave the same whether the dipatch
        // manager is invoked or not. (This funct'n has to be consitent
        // GenericPutPropertyManager(), but NOT GenericPutExProperty...)

        dwNumValues = 1;
    }

    //
    // check if this is a writeable property in schema
    //
    hr = ValidateIfWriteableProperty(
                _pSchemaClassProps,
                _dwNumProperties,
                szPropName
                );
    BAIL_ON_FAILURE(hr);

    //
    // Variant Array to Nt Objects
    //
    hr = VarTypeToNtTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pNtObjs
                    );
    BAIL_ON_FAILURE(hr);

    //
    // update property value in cache
    //
    hr = putproperty(
                szPropName,
                dwSyntaxId,
                dwNumValues,
                pNtObjs
                );
    BAIL_ON_FAILURE(hr);


error:

    if (pNtObjs) {
        NTTypeFreeNTObjects(
            pNtObjs,
            dwNumValues
            );
    }

    if (pTempVarArray) {

        DWORD i = 0;
        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pTempVarArray + i);
        }
        FreeADsMem(pTempVarArray);
    }


    if (FAILED(hr)) {

        //
        // return DISP_E errors instead E_ADS_ errors , see above
        //
        ADsECodesToDispECodes(&hr);
    }

    RRETURN(hr);
}

void
ADsECodesToDispECodes(
    HRESULT *pHr
    )
{
    DWORD dwADsErr = *pHr;

    switch (dwADsErr) {

    case E_ADS_UNKNOWN_OBJECT:
    case E_ADS_PROPERTY_NOT_SUPPORTED:
    case E_ADS_PROPERTY_INVALID:
    case E_ADS_PROPERTY_NOT_FOUND:

        *pHr = DISP_E_MEMBERNOTFOUND;
        break;

    case E_ADS_BAD_PARAMETER:

        //*pHr = DISP_E_PARAMNOTOPTIONAL;
        break;

    case E_ADS_CANT_CONVERT_DATATYPE:

        *pHr = DISP_E_TYPEMISMATCH;
        //*pHr = DISP_E_BADVARTYPE;
        break;

    case E_ADS_SCHEMA_VIOLATION:

        // depends
        break;

    default:

        break;
        // should make it s.t. E_ADS_xxx -> E_FAIL and no changes on others
        // LATER
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cuar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuar.cxx
//
//  Contents:  Account Restrictions Propset for the User object
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//
//        PROPERTY_RW(AccountDisabled, boolean, 1)              NI
//        PROPERTY_RW(AccountExpirationDate, DATE, 2)           NI
//        PROPERTY_RO(AccountCanExpire, boolean, 3)             NI
//        PROPERTY_RO(PasswordCanExpire, boolean, 4)            NI
//        PROPERTY_RW(GraceLoginsAllowed, long, 5)              NI
//        PROPERTY_RW(GraceLoginsRemaining, long, 6)            NI
//        PROPERTY_RW(IsAccountLocked, boolean, 7)              NI
//        PROPERTY_RW(IsAdmin, boolean, 8)                      NI
//        PROPERTY_RW(LoginHours, VARIANT, 9)                   NI
//        PROPERTY_RW(LoginWorkstations, VARIANT, 10)           NI
//        PROPERTY_RW(MaxLogins, long, 11)                      NI
//        PROPERTY_RW(MaxStorage, long, 12)                     NI
//        PROPERTY_RW(PasswordExpirationDate, DATE, 13)         NI
//        PROPERTY_RW(PasswordRequired, boolean, 14)            NI
//        PROPERTY_RW(RequireUniquePassword,boolean, 15)        NI
//
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//  Class CNWCOMPATUser


/* IADsFSUserAccountRestrictions methods */

STDMETHODIMP
CNWCOMPATUser::get_AccountDisabled(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, AccountDisabled);
}

STDMETHODIMP
CNWCOMPATUser::put_AccountDisabled(THIS_ VARIANT_BOOL fAccountDisabled)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, AccountDisabled);
}

STDMETHODIMP
CNWCOMPATUser::get_AccountExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CNWCOMPATUser::put_AccountExpirationDate(THIS_ DATE daAccountExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CNWCOMPATUser::get_GraceLoginsAllowed(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, GraceLoginsAllowed);
}

STDMETHODIMP
CNWCOMPATUser::put_GraceLoginsAllowed(THIS_ long lGraceLoginsAllowed)
{
    PUT_PROPERTY_LONG((IADsUser *)this, GraceLoginsAllowed);
}

STDMETHODIMP
CNWCOMPATUser::get_GraceLoginsRemaining(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, GraceLoginsRemaining);
}

STDMETHODIMP
CNWCOMPATUser::put_GraceLoginsRemaining(THIS_ long lGraceLoginsRemaining)
{
    PUT_PROPERTY_LONG((IADsUser *)this, GraceLoginsRemaining);
}

STDMETHODIMP
CNWCOMPATUser::get_IsAccountLocked(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, IsAccountLocked);
}

STDMETHODIMP
CNWCOMPATUser::put_IsAccountLocked(THIS_ VARIANT_BOOL fIsAccountLocked)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, IsAccountLocked);
}

STDMETHODIMP
CNWCOMPATUser::get_LoginHours(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, LoginHours);
}

STDMETHODIMP
CNWCOMPATUser::put_LoginHours(THIS_ VARIANT vLoginHours)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, LoginHours);
}

STDMETHODIMP
CNWCOMPATUser::get_LoginWorkstations(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATUser::put_LoginWorkstations(THIS_ VARIANT vLoginWorkstations)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATUser::get_MaxLogins(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, MaxLogins);
}

STDMETHODIMP
CNWCOMPATUser::put_MaxLogins(THIS_ long lMaxLogins)
{
    PUT_PROPERTY_LONG((IADsUser *)this, MaxLogins);
}

STDMETHODIMP
CNWCOMPATUser::get_MaxStorage(THIS_ long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATUser::put_MaxStorage(THIS_ long lMaxStorage)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATUser::get_PasswordExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CNWCOMPATUser::put_PasswordExpirationDate(THIS_ DATE daPasswordExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CNWCOMPATUser::get_PasswordMinimumLength(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, PasswordMinimumLength);
}

STDMETHODIMP
CNWCOMPATUser::put_PasswordMinimumLength(THIS_ long lPasswordMinimumLength)
{
    PUT_PROPERTY_LONG((IADsUser *)this, PasswordMinimumLength);
}

STDMETHODIMP
CNWCOMPATUser::get_PasswordRequired(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, PasswordRequired);
}

STDMETHODIMP
CNWCOMPATUser::put_PasswordRequired(THIS_ VARIANT_BOOL fPasswordRequired)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, PasswordRequired);
}

STDMETHODIMP
CNWCOMPATUser::get_RequireUniquePassword(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

STDMETHODIMP
CNWCOMPATUser::put_RequireUniquePassword(THIS_ VARIANT_BOOL fRequireUniquePassword)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

STDMETHODIMP
CNWCOMPATUser::SetPassword(THIS_ BSTR NewPassword)
{
    HRESULT hr = S_OK ;
    NWOBJ_ID      ObjectID;
    NW_USER_INFO NwUserInfo = {NULL, NULL, NULL, NULL};

    //
    // We dont care what state the object is in, since all we need is
    // already there from core init.
    //


    hr = NWApiMakeUserInfo(
                 _ServerName,  
                 _Name,
                 NewPassword,
                 &NwUserInfo
                 );
    BAIL_ON_FAILURE(hr);

    hr = NWApiSetUserPassword(
             &NwUserInfo,
             &ObjectID,
             NULL
             ) ;
    
error:

    (void) NWApiFreeUserInfo(
               &NwUserInfo
               );

    RRETURN_EXP_IF_ERR(hr) ;
}

STDMETHODIMP
CNWCOMPATUser::ChangePassword(THIS_ BSTR bstrOldPassword, BSTR bstrNewPassword)
{
    HRESULT hr = S_OK ;
    NWOBJ_ID      ObjectID;
    NW_USER_INFO NwUserInfo = {NULL, NULL, NULL, NULL};

    //
    // We dont care what state the object is in, since all we need is
    // already there from core init.
    //

    hr = NWApiMakeUserInfo(
                 _ServerName,  
                 _Name,
                 bstrNewPassword,
                 &NwUserInfo
                 );
    BAIL_ON_FAILURE(hr);

    hr = NWApiSetUserPassword(
             &NwUserInfo,
             &ObjectID,
             (LPWSTR) bstrOldPassword
             ) ;
    
error:

    (void) NWApiFreeUserInfo(
               &NwUserInfo
               );

    RRETURN_EXP_IF_ERR(hr) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cprov.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  NetWare 3.12 Provider Object Class Factory Code
//
//             CNWCOMPATProviderCF::CreateInstance
//
//  History:   10-Jan-96     t-ptam    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


HRESULT
GetObject(
   LPWSTR szBuffer,
   LPVOID * ppObject
   );

//  Class CNWCOMPATProvider

CNWCOMPATProvider::CNWCOMPATProvider()
{
    ENLIST_TRACKING(CNWCOMPATProvider);
}

HRESULT
CNWCOMPATProvider::Create(CNWCOMPATProvider FAR * FAR * ppProvider)
{
    CNWCOMPATProvider FAR * pProvider = NULL;
    HRESULT hr = S_OK;

    //
    //Create the Provider Object
    ///

    pProvider = new CNWCOMPATProvider();
    if (pProvider == NULL) {
        RRETURN(ResultFromScode(E_OUTOFMEMORY));
    }

    if (FAILED(hr)) {
        delete pProvider;
        RRETURN(hr);
    }

    *ppProvider = pProvider;
    RRETURN(hr);
}

CNWCOMPATProvider::~CNWCOMPATProvider( )
{

}

STDMETHODIMP
CNWCOMPATProvider::QueryInterface(REFIID iid,LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = this;
    }
    else if (IsEqualIID(iid, IID_IParseDisplayName))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CNWCOMPATProvider::ParseDisplayName(
                    IBindCtx* pbc,
                    WCHAR* szDisplayName,
                    ULONG* pchEaten,
                    IMoniker** ppmk
                    )
{
    HRESULT hr;

    // clear out-parameters
    *ppmk = NULL;
    if (pchEaten != NULL)
        *pchEaten = 0;

    hr = ResolvePathName(pbc, szDisplayName, pchEaten, ppmk);

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CNWCOMPATProvider::ResolvePathName(
                    IBindCtx* pbc,
                    WCHAR* szDisplayName,
                    ULONG* pchEaten,
                    IMoniker** ppmk
                    )
{
    HRESULT hr;
    LPUNKNOWN pUnknown = NULL;

    if (!pchEaten) {
        BAIL_IF_ERROR(hr = E_INVALIDARG);
    }

    *pchEaten = 0;
    hr = GetObject(szDisplayName, (LPVOID *)&pUnknown);
    BAIL_IF_ERROR(hr);

    hr = CreatePointerMoniker(pUnknown, ppmk);
    BAIL_IF_ERROR(hr);

    *pchEaten += wcslen(szDisplayName);

cleanup:

    if (pUnknown) {
        pUnknown->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cuoi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cuoi.cxx
//
//  Contents:  User Object Other Information FunctionalSet
//
//  History:   Feb-14-96     t-ptam    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Class CNWCOMPATUser
//


STDMETHODIMP CNWCOMPATUser::get_EmailAddress(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::put_EmailAddress(THIS_ BSTR bstrEmailAddress)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_HomeDirectory(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::put_HomeDirectory(THIS_ BSTR bstrHomeDirectory)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_Languages(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::put_Languages(THIS_ VARIANT vLanguages)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_Profile(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::put_Profile(THIS_ BSTR bstrProfile)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_LoginScript(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::put_LoginScript(THIS_ BSTR bstrLoginScript)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cschema.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cschema.cxx
//
//  Contents:  Windows NT 3.51
//
//
//  History:   01-09-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


/******************************************************************/
/*  Class CNWCOMPATSchema
/******************************************************************/

DEFINE_IDispatch_Implementation(CNWCOMPATSchema)
DEFINE_IADs_Implementation(CNWCOMPATSchema)

CNWCOMPATSchema::CNWCOMPATSchema()
{
    VariantInit( &_vFilter );

    ENLIST_TRACKING(CNWCOMPATSchema);
}

CNWCOMPATSchema::~CNWCOMPATSchema()
{
    VariantClear( &_vFilter );
    delete _pDispMgr;
}

HRESULT
CNWCOMPATSchema::CreateSchema(
    BSTR   bstrParent,
    BSTR   bstrName,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATSchema FAR *pSchema = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSchemaObject( &pSchema );
    BAIL_ON_FAILURE(hr);

    hr = pSchema->InitializeCoreObject(
             bstrParent,
             bstrName,
             SCHEMA_CLASS_NAME,
             NO_SCHEMA,
             CLSID_NWCOMPATSchema,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    hr = pSchema->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSchema->Release();

    RRETURN(hr);

error:

    delete pSchema;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSchema::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATSchema::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CNWCOMPATSchema::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSchema::GetInfo(THIS)
{
    RRETURN(S_OK);
}

/* IADsContainer methods */

STDMETHODIMP
CNWCOMPATSchema::get_Count(long FAR* retval)
{
    HRESULT hr;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *retval = g_cNWCOMPATClasses + g_cNWCOMPATSyntax;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATSchema::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    if ( !pVar )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    VariantInit( pVar );
    hr = VariantCopy( pVar, &_vFilter );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSchema::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy( &_vFilter, &Var );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSchema::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATSchema::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSchema::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject)
{
    TCHAR szBuffer[MAX_PATH];
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }


    memset(szBuffer, 0, sizeof(szBuffer));

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"/");
    wcscat(szBuffer, RelativeName);

    if (ClassName && *ClassName) {
        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSchema::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IEnumVARIANT *penum = NULL;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CNWCOMPATSchemaEnum::Create( (CNWCOMPATSchemaEnum **)&penum,
                                   _ADsPath,
                                   _Name,
                                   _vFilter );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface( IID_IUnknown, (VOID FAR* FAR*)retval );
    BAIL_ON_FAILURE(hr);

    if ( penum )
        penum->Release();

    RRETURN(hr);

error:

    if ( penum )
        delete penum;

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSchema::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSchema::Delete(THIS_ BSTR SourceName, BSTR Type)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSchema::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSchema::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CNWCOMPATSchema::AllocateSchemaObject(CNWCOMPATSchema FAR * FAR * ppSchema)
{
    CNWCOMPATSchema FAR *pSchema = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSchema = new CNWCOMPATSchema();
    if ( pSchema == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pSchema,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsContainer,
                            (IADsContainer *) pSchema,
                            DISPID_NEWENUM );
    BAIL_ON_FAILURE(hr);

    pSchema->_pDispMgr = pDispMgr;
    *ppSchema = pSchema;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSchema;

    RRETURN(hr);

}


/******************************************************************/
/*  Class CNWCOMPATClass
/******************************************************************/

DEFINE_IDispatch_Implementation(CNWCOMPATClass)
DEFINE_IADs_Implementation(CNWCOMPATClass)

CNWCOMPATClass::CNWCOMPATClass()
    : _pDispMgr( NULL ),
      _aPropertyInfo( NULL ),
      _cPropertyInfo( 0 ),
      _bstrCLSID( NULL ),
      _bstrOID( NULL ),
      _bstrPrimaryInterface( NULL ),
      _fAbstract( FALSE ),
      _fContainer( FALSE ),
      _bstrHelpFileName( NULL ),
      _lHelpFileContext( 0 )
{
    VariantInit( &_vMandatoryProperties );
    VariantInit( &_vOptionalProperties );
    VariantInit( &_vPossSuperiors );
    VariantInit( &_vContainment );
    VariantInit( &_vFilter );

    ENLIST_TRACKING(CNWCOMPATClass);
}

CNWCOMPATClass::~CNWCOMPATClass()
{
    if ( _bstrCLSID ) {
        ADsFreeString( _bstrCLSID );
    }

    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrPrimaryInterface ) {
        ADsFreeString( _bstrPrimaryInterface );
    }

    if ( _bstrHelpFileName ) {
        ADsFreeString( _bstrHelpFileName );
    }

    VariantClear( &_vMandatoryProperties );
    VariantClear( &_vOptionalProperties );
    VariantClear( &_vPossSuperiors );
    VariantClear( &_vContainment );
    VariantClear( &_vFilter );

    delete _pDispMgr;
}

HRESULT
CNWCOMPATClass::CreateClass(
    BSTR   bstrParent,
    CLASSINFO *pClassInfo,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATClass FAR *pClass = NULL;
    HRESULT hr = S_OK;
    BSTR bstrTmp = NULL;

    hr = AllocateClassObject( &pClass );
    BAIL_ON_FAILURE(hr);

    pClass->_aPropertyInfo = pClassInfo->aPropertyInfo;
    pClass->_cPropertyInfo = pClassInfo->cPropertyInfo;
    pClass->_lHelpFileContext = pClassInfo->lHelpFileContext;
    pClass->_fContainer = (VARIANT_BOOL) pClassInfo->fContainer;
    pClass->_fAbstract = (VARIANT_BOOL) pClassInfo->fAbstract;

    hr = StringFromCLSID( (REFCLSID) *(pClassInfo->pPrimaryInterfaceGUID),
                          &bstrTmp );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrTmp,
                           &pClass->_bstrPrimaryInterface );
    BAIL_ON_FAILURE(hr);

    CoTaskMemFree( bstrTmp );
    bstrTmp = NULL;

    hr = StringFromCLSID( (REFCLSID) *(pClassInfo->pCLSID),
                          &bstrTmp );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrTmp,
                           &pClass->_bstrCLSID );
    BAIL_ON_FAILURE(hr);

    CoTaskMemFree( bstrTmp );
    bstrTmp = NULL;

    hr = ADsAllocString( pClassInfo->bstrOID, &pClass->_bstrOID);
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringList( pClassInfo->bstrMandatoryProperties,
                                    &(pClass->_vMandatoryProperties));
    BAIL_ON_FAILURE(hr);


    hr = MakeVariantFromStringList( pClassInfo->bstrOptionalProperties,
                                    &(pClass->_vOptionalProperties));
    BAIL_ON_FAILURE(hr);


    hr = MakeVariantFromStringList( pClassInfo->bstrPossSuperiors,
                                    &(pClass->_vPossSuperiors));
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringList( pClassInfo->bstrContainment,
                                    &(pClass->_vContainment));
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pClassInfo->bstrHelpFileName,
                           &pClass->_bstrHelpFileName);
    BAIL_ON_FAILURE(hr);

    hr = pClass->InitializeCoreObject(
             bstrParent,
             pClassInfo->bstrName,
             CLASS_CLASS_NAME,
             NO_SCHEMA,
             CLSID_NWCOMPATClass,
             dwObjectState );

    BAIL_ON_FAILURE(hr);

    hr = pClass->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pClass->Release();

    RRETURN(hr);

error:
    if ( bstrTmp != NULL )
        CoTaskMemFree( bstrTmp );

    delete pClass;
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNWCOMPATClass::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsClass FAR * ) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsClass))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATClass::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid 
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsClass)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CNWCOMPATClass::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATClass::GetInfo(THIS)
{
    RRETURN(S_OK);
}

/* IADsClass methods */

STDMETHODIMP
CNWCOMPATClass::get_PrimaryInterface( THIS_ BSTR FAR *pbstrGUID )
{
    HRESULT hr;
    if ( !pbstrGUID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrPrimaryInterface, pbstrGUID );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::get_CLSID( THIS_ BSTR FAR *pbstrCLSID )
{
    HRESULT hr;
    if ( !pbstrCLSID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrCLSID, pbstrCLSID );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_CLSID( THIS_ BSTR bstrCLSID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    HRESULT hr;
    if ( !pbstrOID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrOID, pbstrOID );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_Abstract( THIS_ VARIANT_BOOL FAR *pfAbstract )
{
    if ( !pfAbstract )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfAbstract = _fAbstract? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATClass::put_Abstract( THIS_ VARIANT_BOOL fAbstract )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_Auxiliary( THIS_ VARIANT_BOOL FAR *pfAuxiliary )
{
    if ( !pfAuxiliary )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfAuxiliary = VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATClass::put_Auxiliary( THIS_ VARIANT_BOOL fAuxiliary )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_MandatoryProperties( THIS_ VARIANT FAR *pvMandatoryProperties )
{
    HRESULT hr;
    VariantInit( pvMandatoryProperties );
    hr = VariantCopy( pvMandatoryProperties, &_vMandatoryProperties );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_MandatoryProperties( THIS_ VARIANT vMandatoryProperties )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_DerivedFrom( THIS_ VARIANT FAR *pvDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::put_DerivedFrom( THIS_ VARIANT vDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_AuxDerivedFrom( THIS_ VARIANT FAR *pvAuxDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::put_AuxDerivedFrom( THIS_ VARIANT vAuxDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_PossibleSuperiors( THIS_ VARIANT FAR *pvPossSuperiors )
{
    HRESULT hr;
    VariantInit( pvPossSuperiors );
    hr = VariantCopy( pvPossSuperiors, &_vPossSuperiors );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_PossibleSuperiors( THIS_ VARIANT vPossSuperiors )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_Containment( THIS_ VARIANT FAR *pvContainment )
{
    HRESULT hr;
    VariantInit( pvContainment );
    hr = VariantCopy( pvContainment, &_vContainment );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_Containment( THIS_ VARIANT vContainment )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_Container( THIS_ VARIANT_BOOL FAR *pfContainer )
{
    if ( !pfContainer )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfContainer = _fContainer? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATClass::put_Container( THIS_ VARIANT_BOOL fContainer )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_HelpFileName( THIS_ BSTR FAR *pbstrHelpFileName )
{
    HRESULT hr;
    if ( !pbstrHelpFileName )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrHelpFileName, pbstrHelpFileName );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_HelpFileName( THIS_ BSTR bstrHelpFile )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_HelpFileContext( THIS_ long FAR *plHelpContext )
{
    if ( !plHelpContext )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plHelpContext = _lHelpFileContext;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATClass::put_HelpFileContext( THIS_ long lHelpContext )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CNWCOMPATClass::AllocateClassObject(CNWCOMPATClass FAR * FAR * ppClass)
{

    CNWCOMPATClass FAR  *pClass = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pClass = new CNWCOMPATClass();
    if ( pClass == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsClass,
                            (IADsClass *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pClass->_pDispMgr = pDispMgr;
    *ppClass = pClass;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pClass;

    RRETURN(hr);

}


/******************************************************************/
/*  Class CNWCOMPATProperty
/******************************************************************/

DEFINE_IDispatch_Implementation(CNWCOMPATProperty)
DEFINE_IADs_Implementation(CNWCOMPATProperty)

CNWCOMPATProperty::CNWCOMPATProperty()
    : _pDispMgr( NULL ),
      _bstrOID( NULL ),
      _bstrSyntax( NULL ),
      _lMaxRange( 0 ),
      _lMinRange( 0 ),
      _fMultiValued( FALSE )
{

    ENLIST_TRACKING(CNWCOMPATProperty);
}

CNWCOMPATProperty::~CNWCOMPATProperty()
{
    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrSyntax ) {
        ADsFreeString( _bstrSyntax );
    }

    delete _pDispMgr;
}

HRESULT
CNWCOMPATProperty::CreateProperty(
    BSTR   bstrParent,
    PROPERTYINFO *pPropertyInfo,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATProperty FAR * pProperty = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePropertyObject( &pProperty );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pPropertyInfo->bstrOID, &pProperty->_bstrOID);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pPropertyInfo->bstrSyntax, &pProperty->_bstrSyntax);
    BAIL_ON_FAILURE(hr);

    pProperty->_lMaxRange = pPropertyInfo->lMaxRange;
    pProperty->_lMinRange = pPropertyInfo->lMinRange;
    pProperty->_fMultiValued  = (VARIANT_BOOL) pPropertyInfo->fMultiValued;

    hr = pProperty->InitializeCoreObject(
             bstrParent,
             pPropertyInfo->szPropertyName,
             PROPERTY_CLASS_NAME,
             NO_SCHEMA,
             CLSID_NWCOMPATProperty,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    hr = pProperty->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pProperty->Release();

    RRETURN(hr);

error:

    delete pProperty;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATProperty::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsProperty))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATProperty::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsProperty)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CNWCOMPATProperty::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATProperty::GetInfo(THIS)
{
    RRETURN(S_OK);
}

/* IADsProperty methods */


STDMETHODIMP
CNWCOMPATProperty::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    HRESULT hr;
    if ( !pbstrOID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrOID, pbstrOID );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATProperty::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATProperty::get_Syntax( THIS_ BSTR FAR *pbstrSyntax )
{
    HRESULT hr;
    if ( !pbstrSyntax )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrSyntax, pbstrSyntax );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATProperty::put_Syntax( THIS_ BSTR bstrSyntax )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATProperty::get_MaxRange( THIS_ long FAR *plMaxRange )
{
    if ( !plMaxRange )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plMaxRange = _lMaxRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATProperty::put_MaxRange( THIS_ long lMaxRange )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATProperty::get_MinRange( THIS_ long FAR *plMinRange )
{
    if ( !plMinRange )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plMinRange = _lMinRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATProperty::put_MinRange( THIS_ long lMinRange )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATProperty::get_MultiValued( THIS_ VARIANT_BOOL FAR *pfMultiValued )
{
    if ( !pfMultiValued )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfMultiValued = _fMultiValued? VARIANT_TRUE: VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATProperty::put_MultiValued( THIS_ VARIANT_BOOL fMultiValued )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATProperty::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CNWCOMPATProperty::AllocatePropertyObject(CNWCOMPATProperty FAR * FAR * ppProperty)
{
    CNWCOMPATProperty FAR *pProperty = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pProperty = new CNWCOMPATProperty();
    if ( pProperty == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsProperty,
                            (IADsProperty *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pProperty->_pDispMgr = pDispMgr;
    *ppProperty = pProperty;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pProperty;

    RRETURN(hr);

}


/******************************************************************/
/*  Class CNWCOMPATSyntax
/******************************************************************/

DEFINE_IDispatch_Implementation(CNWCOMPATSyntax)
DEFINE_IADs_Implementation(CNWCOMPATSyntax)

CNWCOMPATSyntax::CNWCOMPATSyntax()
{
    ENLIST_TRACKING(CNWCOMPATSyntax);
}

CNWCOMPATSyntax::~CNWCOMPATSyntax()
{
    delete _pDispMgr;
}

HRESULT
CNWCOMPATSyntax::CreateSyntax(
    BSTR   bstrParent,
    SYNTAXINFO *pSyntaxInfo,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATSyntax FAR *pSyntax = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSyntaxObject( &pSyntax );
    BAIL_ON_FAILURE(hr);

    hr = pSyntax->InitializeCoreObject(
             bstrParent,
             pSyntaxInfo->bstrName,
             SYNTAX_CLASS_NAME,
             NO_SCHEMA,
             CLSID_NWCOMPATSyntax,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pSyntax->_lOleAutoDataType = pSyntaxInfo->lOleAutoDataType;

    hr = pSyntax->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSyntax->Release();

    RRETURN(hr);

error:

    delete pSyntax;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSyntax::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsSyntax))
    {
        *ppv = (IADsSyntax FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATSyntax::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsSyntax)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CNWCOMPATSyntax::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSyntax::GetInfo(THIS)
{
    RRETURN(S_OK);
}

HRESULT
CNWCOMPATSyntax::AllocateSyntaxObject(CNWCOMPATSyntax FAR * FAR * ppSyntax)
{
    CNWCOMPATSyntax FAR *pSyntax = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSyntax = new CNWCOMPATSyntax();
    if ( pSyntax == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsSyntax,
                            (IADsSyntax *) pSyntax,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pSyntax->_pDispMgr = pDispMgr;
    *ppSyntax = pSyntax;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSyntax;

    RRETURN(hr);

}

STDMETHODIMP
CNWCOMPATSyntax::get_OleAutoDataType( THIS_ long FAR *plOleAutoDataType )
{
    if ( !plOleAutoDataType )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plOleAutoDataType = _lOleAutoDataType;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATSyntax::put_OleAutoDataType( THIS_ long lOleAutoDataType )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}


/******************************************************************/
/*  Misc Helpers
/******************************************************************/

HRESULT
MakeVariantFromStringList(
    BSTR bstrList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    BSTR pszTempList = NULL;

    if ( bstrList != NULL )
    {
        long i = 0;
        long nCount = 1;
        TCHAR c;
        BSTR pszSrc;

        hr = ADsAllocString( bstrList, &pszTempList );
        BAIL_ON_FAILURE(hr);

        while ( c = pszTempList[i] )
        {
            if ( c == TEXT(','))
            {
                pszTempList[i] = 0;
                nCount++;
            }

            i++;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pszSrc = pszTempList;

        for ( i = 0; i < nCount; i++ )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;
            hr = ADsAllocString( pszSrc, &(V_BSTR(&v)));
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList,
                                      &i,
                                      &v );
            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszSrc += _tcslen( pszSrc ) + 1;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

        ADsFreeString( pszTempList );
        pszTempList = NULL;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    RRETURN(S_OK);

error:

    if ( pszTempList )
        ADsFreeString( pszTempList );

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}


STDMETHODIMP
CNWCOMPATClass::get_OptionalProperties( THIS_ VARIANT FAR *retval )
{
    HRESULT hr;
    VariantInit( retval);
    hr = VariantCopy( retval, &_vOptionalProperties );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_OptionalProperties( THIS_ VARIANT vOptionalProperties )
{

    HRESULT hr = E_NOTIMPL;

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::get_NamingProperties( THIS_ VARIANT FAR *retval )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATClass::put_NamingProperties( THIS_ VARIANT vNamingProperties )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cuas.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(BadPasswordAttempts, long, 4)     Implemented
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//  Class CNWCOMPATUser


/* IADsFSUserAccountStatistics methods */

STDMETHODIMP CNWCOMPATUser::get_BadLoginAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, BadLoginAddress);
}

STDMETHODIMP CNWCOMPATUser::get_BadLoginCount(THIS_ long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_LastLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastLogin);
}

STDMETHODIMP CNWCOMPATUser::get_LastLogoff(THIS_ DATE FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_LastFailedLogin(THIS_ DATE FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_PasswordLastChanged(THIS_ DATE FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cubi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cubi.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//
//      PROPERTY_RW(Address, VARIANT, 1)                NI
//      PROPERTY_RW(Department, BSTR, 3)                NI
//      PROPERTY_RW(Division, BSTR, 5)                  NI
//      PROPERTY_RW(EmployeeID, BSTR, 6)                NI
//      PROPERTY_RW(FirstName, BSTR, 8)                 Implemented
//      PROPERTY_RW(FullName, BSTR, 9)                  NI
//      PROPERTY_RW(Initials, BSTR, 10)                 NI
//      PROPERTY_RW(LastName, BSTR, 11)                 NI
//      PROPERTY_RW(Manager, BSTR, 12)                  NI
//      PROPERTY_RW(NickName, BSTR, 13)                 NI
//      PROPERTY_RW(OfficeLocation, BSTR, 14)           NI
//      PROPERTY_RW(Picture, VARIANT, 15)               NI
//      PROPERTY_RW(TelephoneNumber, BSTR, 18)          NI
//      PROPERTY_RW(Title, BSTR, 19)
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//  Class CNWCOMPATUser




/* IADsFSUserBusinessInformation methods */

STDMETHODIMP
CNWCOMPATUser::get_Department(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}


STDMETHODIMP
CNWCOMPATUser::put_Department(THIS_ BSTR bstrDepartment)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_Description(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_Description(THIS_ BSTR bstrDescription)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_Division(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_Division(THIS_ BSTR bstrDivision)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_EmployeeID(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_EmployeeID(THIS_ BSTR bstrEmployeeID)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_FirstName(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_FirstName(THIS_ BSTR bstrFirstName)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_FullName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CNWCOMPATUser::put_FullName(THIS_ BSTR bstrFullName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CNWCOMPATUser::get_LastName(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_LastName(THIS_ BSTR bstrLastName)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_Manager(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_Manager(THIS_ BSTR bstrManager)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_OfficeLocations(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_OfficeLocations(THIS_ VARIANT vOfficeLocation)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_Picture(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_Picture(THIS_ VARIANT vPicture)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_PostalAddresses(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_PostalAddresses(THIS_ VARIANT vPostalAddresses)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_PostalCodes(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_PostalCodes(THIS_ VARIANT vPostalCodes)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_TelephoneNumber(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_TelephoneNumber(THIS_ VARIANT vTelephoneNumber)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_TelephoneHome(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_TelephoneHome(THIS_ VARIANT vTelephoneHome)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_TelephoneMobile(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_TelephoneMobile(THIS_ VARIANT vTelephoneMobile)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_TelephonePager(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_TelephonePager(THIS_ VARIANT vTelephonePager)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_FaxNumber(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_FaxNumber(THIS_ VARIANT vFaxNumber)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_Title(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_Title(THIS_ BSTR bstrTitle)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::Groups(THIS_ IADsMembers FAR*  FAR * ppGroups)
{
    HRESULT hr = S_OK;

    hr = CNWCOMPATUserCollection::CreateUserCollection(
             _Parent,
             _ParentType,
             _ServerName,
             _Name,
             IID_IADsMembers,
             (void **)ppGroups
             );
    RRETURN_EXP_IF_ERR(hr);
}
STDMETHODIMP CNWCOMPATUser::get_HomePage(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNWCOMPATUser::put_HomePage(THIS_ BSTR bstrHomePage)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNWCOMPATUser::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNWCOMPATUser::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNWCOMPATUser::get_NamePrefix(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNWCOMPATUser::put_NamePrefix(THIS_ BSTR bstrNamePrefix)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNWCOMPATUser::get_NameSuffix(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNWCOMPATUser::put_NameSuffix(THIS_ BSTR bstrNamePrefix)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNWCOMPATUser::get_OtherName(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNWCOMPATUser::put_OtherName(THIS_ BSTR bstrOtherName)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\guid.c ===
#define INITGUID

#include <ole2.h>

//--------------------------------------------------------------------------
//
//  NWCOMPAT CLSIDs
//
//--------------------------------------------------------------------------

DEFINE_GUID(CLSID_NWCOMPATProvider,0x0df68130L,0x4b62,0x11CF,0xAE,0x2C,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATNamespace,0x0fb32cc0L,0x4b62,0x11CF,0xAE,0x2C,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATComputer,0xcad1bde0L,0x4cf0,0x11cf,0xae,0x2d,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATUser,0x5c250b00L,0x5863,0x11cf,0xae,0x32,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATGroup,0x3c5662e0L,0x5a74,0x11cf,0xae,0x32,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATDomain,0x9f6616f0L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATService,0x9f02c3c0L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATPrintQueue,0x9e7dd270L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATPrintJob,0x9e09b030L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATFileService,0x9d9eb910L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATSession,0x9d2a96d0L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATResource,0x9cb36630L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATFileShare,0x9c486f10L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATSchema,0x9bcfb740L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATClass,0x9b602a90L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATSyntax,0x9af53370L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATProperty,0x44687d30L,0x7937,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

//------------------------------------------------------------------------
//  GUIDS that come out of NWCOMPAT.tlb.
//------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guid.h
//
//  Contents:   extern references for NWCOMPAT guids
//
//  History:    10-Jan-06  t-ptam
//
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// NWCOMPATOle CLSIDs
//
//-------------------------------------------

// uuids from NWCOMPAT.tlb

extern const CLSID CLSID_NWCOMPATProvider;

extern const CLSID CLSID_NWCOMPATNamespace;

extern const CLSID CLSID_NWCOMPATComputer;

extern const CLSID CLSID_NWCOMPATUser;

extern const CLSID CLSID_NWCOMPATGroup;

extern const CLSID CLSID_NWCOMPATProvider;

extern const CLSID CLSID_NWCOMPATNamespace;

extern const CLSID CLSID_NWCOMPATComputer;

extern const CLSID CLSID_NWCOMPATUser;

extern const CLSID CLSID_NWCOMPATGroup;

extern const CLSID CLSID_NWCOMPATDomain;

extern const CLSID CLSID_NWCOMPATService;

extern const CLSID CLSID_NWCOMPATPrintQueue;

extern const CLSID CLSID_NWCOMPATPrintJob;

extern const CLSID CLSID_NWCOMPATFileService;

extern const CLSID CLSID_NWCOMPATSession;

extern const CLSID CLSID_NWCOMPATResource;

extern const CLSID CLSID_NWCOMPATFileShare;

extern const CLSID CLSID_NWCOMPATSchema;

extern const CLSID CLSID_NWCOMPATClass;

extern const CLSID CLSID_NWCOMPATSyntax;

extern const CLSID CLSID_NWCOMPATProperty;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cusers.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroups.cxx
//
//  Contents:  Group object
//
//  History:   Mar-18-965     t-ptam (PatrickT)    Migrated.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Class CNWCOMPATUserCollection
//

DEFINE_IDispatch_Implementation(CNWCOMPATUserCollection)

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUserCollection::CNWCOMPATUserCollection():
        _ParentType(0),
        _ServerName(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CNWCOMPATUserCollection);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUserCollection::~CNWCOMPATUserCollection( )
{
    if (_ServerName)
        ADsFreeString(_ServerName);
    delete _pDispMgr;
    VariantClear(&_vFilter);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUserCollection::CreateUserCollection(
    BSTR Parent,
    ULONG ParentType,
    BSTR ServerName,
    BSTR UserName,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATUserCollection FAR * pUser = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserCollectionObject(&pUser);
    BAIL_ON_FAILURE(hr);

    hr = pUser->InitializeCoreObject(
                     Parent,
                     UserName,
                     L"users",
                     NO_SCHEMA,
                     CLSID_NWCOMPATUser,
                     ADS_OBJECT_UNBOUND
                     );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(ServerName, &pUser->_ServerName);
    BAIL_ON_FAILURE(hr);

    pUser->_ParentType = ParentType;

    hr = pUser->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUser->Release();
    RRETURN(hr);

error:
    delete pUser;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

//----------------------------------------------------------------------------
//
//  Function:CNWCOMPATUserCollection::InterfaceSupportsErrorInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::get_Count(
    long FAR* retval
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::get_Filter(
    THIS_ VARIANT FAR* pVar
    )
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::put_Filter(
    THIS_ VARIANT Var
    )
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNWCOMPATUserCollectionEnum::Create(
             (CNWCOMPATUserCollectionEnum **)&penum,
             _Parent,
             _ParentType,
             _ADsPath,
             _ServerName,
             _Name,
             _vFilter
             );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUserCollection::AllocateUserCollectionObject(
    CNWCOMPATUserCollection ** ppUser
    )
{
    CNWCOMPATUserCollection FAR * pUser = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pUser = new CNWCOMPATUserCollection();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsMembers,
             (IADsMembers *)pUser,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    pUser->_pDispMgr = pDispMgr;
    *ppUser = pUser;

    RRETURN(hr);

error:
    if (pUser) {
        delete pUser;
    }

    if (pDispMgr) {
        delete  pDispMgr;
    }

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\cuser.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cuser.cxx
//
//  Contents:  Host user object code
//
//  History:   Feb-14-96     t-ptam    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Macro-ized implementation.
//

DEFINE_IDispatch_ExtMgr_Implementation(CNWCOMPATUser)

DEFINE_IADs_TempImplementation(CNWCOMPATUser)

DEFINE_IADs_PutGetImplementation(CNWCOMPATUser, UserClass, gdwUserTableSize)

DEFINE_IADsPropertyList_Implementation(CNWCOMPATUser, UserClass, gdwUserTableSize)

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::CNWCOMPATUser()
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUser::CNWCOMPATUser():
        _pDispMgr(NULL),
        _pExtMgr(NULL),
        _pPropertyCache(NULL),
        _ParentType(0),
        _ServerName(NULL),
        _szHostServerName(NULL)
{
    ENLIST_TRACKING(CNWCOMPATUser);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::CreateUser
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::CreateUser(
    BSTR Parent,
    ULONG ParentType,
    BSTR ServerName,
    BSTR UserName,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATUser FAR * pUser = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserObject(&pUser);
    BAIL_ON_FAILURE(hr);

    hr = pUser->InitializeCoreObject(
                    Parent,
                    UserName,
                    USER_CLASS_NAME,
                    USER_SCHEMA_NAME,
                    CLSID_NWCOMPATUser,
                    dwObjectState
                    );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName , &pUser->_ServerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName,  &pUser->_szHostServerName);
    BAIL_ON_FAILURE(hr);

    hr = pUser->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUser->Release();

    hr = pUser->_pExtMgr->FinalInitializeExtensions();
    BAIL_ON_FAILURE(hr);

    RRETURN(hr);

error:
    delete pUser;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::~CNWCOMPATUser
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUser::~CNWCOMPATUser( )
{
    ADsFreeString(_ServerName);
    ADsFreeString(_szHostServerName);

    delete _pExtMgr;                // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsUser))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN(_pExtMgr->QueryInterface(iid,ppv));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::InterfaceSupportsErrorInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsUser) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;
    NW_USER_INFO NwUserInfo = {NULL, NULL, NULL, NULL};

    //
    // Bind an object to a real tangible resource if it is not bounded already.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = BuildObjectInfo(
                _Parent,
                _Name,
                &pObjectInfo
                );
        BAIL_ON_FAILURE(hr);

        hr = NWApiMakeUserInfo(
                 pObjectInfo->ComponentArray[0],
                 pObjectInfo->ComponentArray[1],
                 L"",                              // empty password initially
                 &NwUserInfo
                 );
        BAIL_ON_FAILURE(hr);

        hr = NWApiCreateUser(
                 &NwUserInfo
                 );
        BAIL_ON_FAILURE(hr);

        SetObjectState(ADS_OBJECT_BOUND);
    }

    //
    // Persist changes.
    //

    hr = SetInfo(USER_WILD_CARD_ID);
    BAIL_ON_FAILURE(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    (void) NWApiFreeUserInfo(&NwUserInfo) ;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::GetInfo(THIS)
{

   _pPropertyCache->flushpropcache();

   RRETURN(GetInfo(
               TRUE,
               USER_WILD_CARD_ID
               ));
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::AllocateUserObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::AllocateUserObject(
    CNWCOMPATUser ** ppUser
    )
{
    CNWCOMPATUser FAR * pUser = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    CADsExtMgr FAR * pExtensionMgr = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a  User object.
    //

    pUser = new CNWCOMPATUser();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create dispatch manager.
    //

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsUser,
             (IADsUser *)pUser,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPropertyList,
             (IADsPropertyList *)pUser,
             DISPID_VALUE
             );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             UserClass,
             gdwUserTableSize,
             (CCoreADsObject *)pUser,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                pPropertyCache
                );

    hr = ADSILoadExtensionManager(
                USER_CLASS_NAME,
                (IADs *) pUser,
                pDispMgr,
                &pExtensionMgr
                );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //
    pUser->_pPropertyCache = pPropertyCache;
    pUser->_pDispMgr = pDispMgr;
    pUser->_pExtMgr = pExtensionMgr;

    *ppUser = pUser;

    RRETURN(hr);

error:
    delete pDispMgr;
    delete pPropertyCache;
    delete pUser;
    delete pExtensionMgr;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::SetInfo(THIS_ DWORD dwPropertyID)
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;

    //
    // Get a handle to the bindery this object resides on.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             _ServerName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Persist changes in cache.
    //

    hr = SetBusinessInfo(hConn);
    BAIL_ON_FAILURE(hr);

    hr = SetAccountRestrictions(hConn);
    BAIL_ON_FAILURE(hr);

error:
    //
    // Release handle.
    //

    if (hConn) {
        hrTemp = NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::SetBusinessInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::SetBusinessInfo(
    NWCONN_HANDLE hConn
    )
{
    LPWSTR  lpszRightSize = NULL;
    LPWSTR  pszFullName = NULL;
    CHAR    szData[(MAX_FULLNAME_LEN + 1)*2];
    HRESULT hr = S_OK;

    //
    // Set FullName.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("FullName"),
                    &pszFullName
                    );

    if (SUCCEEDED(hr)) {

        //
        // Cut the FullName down to no more than MAX_FULLNAME_LEN of characters.
        //

        lpszRightSize = (LPWSTR) AllocADsMem(
                                     sizeof(WCHAR) * (MAX_FULLNAME_LEN + 1)
                                     );
        if (!lpszRightSize) {
            RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
        }

        lpszRightSize[MAX_FULLNAME_LEN] = 0;

        wcsncpy(
            lpszRightSize,
            pszFullName,
            MAX_FULLNAME_LEN
            );

        //
        // Convert bstr in ANSI string.
        //

        UnicodeToAnsiString(
            lpszRightSize,
            szData,
            0
            );

        //
        // Commit change.
        //

        hr = NWApiWriteProperty(
                 hConn,
                 _Name,
                 OT_USER,
                 NW_PROP_IDENTIFICATION,
                 (LPBYTE) szData
                 );
        BAIL_ON_FAILURE(hr);

        FreeADsMem(lpszRightSize);
    }

error:

    if (pszFullName) {
        FreeADsStr(pszFullName);
    }

    RRETURN(S_OK);
}
//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::SetAccountRestrictions
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::SetAccountRestrictions(
    NWCONN_HANDLE hConn
    )
{
    BOOL             fModified = FALSE;
    DATE             daDate  = 0;
    DWORD            dwNumSegment;
    HRESULT          hr = S_OK;
    LC_STRUCTURE     LoginCtrl;
    LONG             lData = 0;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL;
    SYSTEMTIME       SysTime;
    USER_DEFAULT     UserDefault;
    BOOL             fBool;
    WORD             wDay = 0;
    WORD             wMonth = 0;
    WORD             wYear = 0;
    WCHAR            szTemp[MAX_PATH];
    BYTE             byDateTime[6];
    BOOL             fAccntLckModified;

    hr = NWApiGetLOGIN_CONTROL(
             hConn,
             _Name,
             &LoginCtrl
             );
    BAIL_ON_FAILURE(hr);

    //
    // SET AccountDisabled.
    //

    hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("AccountDisabled"),
                &fBool
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byAccountDisabled = (BYTE) fBool;

        fModified = TRUE;
    }

    //
    // SET AccountExpirationDate.
    //

    memset(byDateTime, 0, 6);
    hr = GetNw312DATEPropertyFromCache(
                _pPropertyCache,
                TEXT("AccountExpirationDate"),
                byDateTime
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byAccountExpires[0] = (BYTE) byDateTime[0];
        LoginCtrl.byAccountExpires[1] = (BYTE) byDateTime[1];
        LoginCtrl.byAccountExpires[2] = (BYTE) byDateTime[2];

        fModified = TRUE;
    }

    //
    // SET AccountCanExpire.
    //

    hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("AccountCanExpire"),
                &fBool
                );

    if (SUCCEEDED(hr)) {

        if (fBool == FALSE) {

            LoginCtrl.byAccountExpires[0] = 0;
            LoginCtrl.byAccountExpires[1] = 0;
            LoginCtrl.byAccountExpires[2] = 0;

            fModified = TRUE;

        }
    }

    //
    // SET GraceLoginsAllowed.
    //

    hr = GetDWORDPropertyFromCache(
                _pPropertyCache,
                TEXT("GraceLoginsAllowed"),
                (PDWORD)&lData
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byGraceLoginReset = (BYTE) lData;

        fModified = TRUE;
    }

    //
    // SET GraceLoginsRemaining.
    //

    hr = GetDWORDPropertyFromCache(
                _pPropertyCache,
                TEXT("GraceLoginsRemaining"),
                (PDWORD)&lData
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byGraceLogins = (BYTE) lData;

        fModified = TRUE;
    }

    //
    // SET IsAccountLocked.
    //

    //
    // if this property not modified in cache, no need to set on svr
    //
    hr =  _pPropertyCache->propertyismodified(
                TEXT("IsAccountLocked"),
                &fAccntLckModified
                );

    if ( SUCCEEDED(hr) && fAccntLckModified==TRUE ) {

        hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("IsAccountLocked"),
                &fBool
                );

        if (SUCCEEDED(hr)) {

            //
            // If fBool is changed from TRUE to FALSE, set wBadLogins
            // back to 0  -> this will unlock account on nw svr
            //

            if (fBool == FALSE) {

                LoginCtrl.wBadLogins = 0;
                fModified = TRUE;

            }else {

                //
                // Reset it to FALSE if it is changed to TRUE.
                // -> cannot lock an account on nwsvr thru' adsi
                //

                fBool = FALSE;

                hr = SetBOOLPropertyInCache(
                        _pPropertyCache,
                        TEXT("IsAccountLocked"),
                        fBool,
                        TRUE
                        );
                BAIL_ON_FAILURE(hr);
            }
        }
    }

    //
    // SET IsAdmin.
    //

    hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("IsAdmin"),
                &fBool
                );

    if (SUCCEEDED(hr)) {

        hr = NWApiUserAsSupervisor(
                 hConn,
                 _Name,
                 fBool
                 );

        //
        // For beta, disabling the bail. It does not work in the user not
        // supervisor mode.
        //

        // BAIL_ON_FAILURE(hr);
    }

    //
    // SET MaxLogins.
    //

    hr = GetDWORDPropertyFromCache(
                _pPropertyCache,
                TEXT("MaxLogins"),
                (PDWORD)&lData
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.wMaxConnections = NWApiReverseWORD(
                                        (WORD) lData
                                        );

        fModified = TRUE;
    }

    //
    // SET PasswordExpirationDate.
    //

    memset(byDateTime, 0, 6);
    hr = GetNw312DATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PasswordExpirationDate"),
                    byDateTime
                    );

    if (SUCCEEDED(hr)) {


        LoginCtrl.byPasswordExpires[0] = (BYTE) byDateTime[0];
        LoginCtrl.byPasswordExpires[1] = (BYTE) byDateTime[1];
        LoginCtrl.byPasswordExpires[2] = (BYTE) byDateTime[2];

        fModified = TRUE;
    }

    //
    // SET PasswordCanExpire.
    //

    hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("PasswordCanExpire"),
                &fBool
                );

    if (SUCCEEDED(hr)) {

        if (fBool == FALSE) {

            //
            // If passowrd cannot expire, set password expiration date to zero.
            // This is what SysCon does.
            //

            LoginCtrl.byPasswordExpires[0] = 0;
            LoginCtrl.byPasswordExpires[1] = 0;
            LoginCtrl.byPasswordExpires[2] = 0;

            fModified = TRUE;

        }
    }

    //
    // SET PasswordMinimumLength.
    //

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PasswordMinimumLength"),
                    (PDWORD)&lData
                    );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byMinPasswordLength = (BYTE) lData;

        fModified = TRUE;
    }

    //
    // SET PasswordRequired.  The section below must goes before "Set
    // PasswordMinimumLength" for it to make sense.
    //

    hr = GetBOOLPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PasswordRequired"),
                    &fBool
                    );


    if (SUCCEEDED(hr)) {

        //
        // If Password is required, set PasswordMinimumLength to default value.
        //

        //
        // If Password is not required, set PasswordMinimumLength to 0.  Again,
        // this is what SysCon does.
        //

        if (fBool) {
            if (!LoginCtrl.byMinPasswordLength) {
                LoginCtrl.byMinPasswordLength = DEFAULT_MIN_PSWD_LEN;
            }
        }else{
            LoginCtrl.byMinPasswordLength = 0;
        }

        fModified = TRUE;
    }

    //
    // Set LoginHours
    //
	OctetString octString;

    hr = GetOctetPropertyFromCache(
                _pPropertyCache,
                TEXT("LoginHours"),
                &octString
                );

    if (SUCCEEDED(hr)) {
        memcpy(LoginCtrl.byLoginTimes, octString.pByte, octString.dwSize);
		FreeADsMem(octString.pByte);
        fModified = TRUE;
    }

    //
    // Set RequireUniquePassword.
    //

    hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("RequireUniquePassword"),
                &fBool
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byRestrictions =  fBool ? REQUIRE_UNIQUE_PSWD : 0;

        fModified = TRUE;

    }

    //
    // Commit changes of the properties associated with LOGIN_CONTROL.
    //

    if (fModified == TRUE) {

        hr = NWApiWriteProperty(
                 hConn,
                 _Name,
                 OT_USER,
                 NW_PROP_LOGIN_CONTROL,
                 (LPBYTE) &LoginCtrl
                 );
    }
    else {

        hr = S_OK;
    }

error:

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::GetInfo(
    BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // Get a handle to the bindery this object resides on.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             _ServerName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Fill in all property caches with values - explicit, or return the
    // indicated property - implicit.
    //

    if (fExplicit) {
       hr = ExplicitGetInfo(hConn, fExplicit);
       BAIL_ON_FAILURE(hr);
    }
    else {
       hr = ImplicitGetInfo(hConn, dwPropertyID, fExplicit);
       BAIL_ON_FAILURE(hr);
    }

error:
    //
    // Release handle.
    //

    if (hConn) {
        hrTemp = NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::ExplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::ExplicitGetInfo(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    LC_STRUCTURE LoginCtrlStruct;

    //
    // Get BusinessInfo functional set.
    //

    hr = GetProperty_FullName(
             hConn,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get LOGIN_CONTROL, which is used in AccountRestriction functional set &
    // AccountStatistics functional set.
    //

    hr = NWApiGetLOGIN_CONTROL(
             hConn,
             _Name,
             &LoginCtrlStruct
             );

    if (SUCCEEDED(hr)) {
        //
        // Get AccountRestriction functional set.
        //

        hr = GetProperty_LoginHours(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_AccountDisabled(

                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_AccountExpirationDate(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_CanAccountExpire(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_GraceLoginsAllowed(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_GraceLoginsRemaining(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_IsAccountLocked(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_IsAdmin(
                 hConn,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_MaxLogins(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_CanPasswordExpire(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_PasswordExpirationDate(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_PasswordMinimumLength(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_PasswordRequired(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_RequireUniquePassword(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);

        //
        // Get AccountStatistics functional set.
        //

        hr = GetProperty_BadLoginAddress(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_LastLogin(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);
    }

    // 
    // if NWApiGetLOGIN_CONTROL failed, it's okay, we just ignore
    // it and don't load those properties into the cache
    //
    hr = S_OK;

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::ImplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::ImplicitGetInfo(
    NWCONN_HANDLE hConn,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    if (dwPropertyID < 100) {
        hr = GetBusinessInfo(
                 hConn,
                 dwPropertyID,
                 fExplicit
                 );
    }
    else if (dwPropertyID < 200) {
        hr = GetAccountRestrictions(
                 hConn,
                 dwPropertyID,
                 fExplicit
                 );
    }
    else if (dwPropertyID < 300) {
        hr = GetAccountStatistics(
                 hConn,
                 dwPropertyID,
                 fExplicit
                 );
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetBusinessInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetBusinessInfo(
    NWCONN_HANDLE hConn,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    switch (dwPropertyID) {

    case USER_FULLNAME_ID:
         hr = GetProperty_FullName(
                  hConn,
                  fExplicit
                  );
         break;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetAccountRestrictions
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetAccountRestrictions(
    NWCONN_HANDLE hConn,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    LC_STRUCTURE LoginCtrlStruct;

    //
    // Get LOGIN_CONTROL.
    //

    hr = NWApiGetLOGIN_CONTROL(
             hConn,
             _Name,
             &LoginCtrlStruct
             );
    if (SUCCEEDED(hr)) {

        //
        // Get property.
        //

        switch (dwPropertyID) {

        case USER_ACCOUNTDISABLED_ID:
             hr = GetProperty_AccountDisabled(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_ACCOUNTEXPIRATIONDATE_ID:
             hr = GetProperty_AccountExpirationDate(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_CANACCOUNTEXPIRE_ID:
             hr = GetProperty_CanAccountExpire(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_GRACELOGINSALLOWED_ID:
             hr = GetProperty_GraceLoginsAllowed(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
                      break;

        case USER_GRACELOGINSREMAINING_ID:
             hr = GetProperty_GraceLoginsRemaining(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_ISACCOUNTLOCKED_ID:
             hr = GetProperty_IsAccountLocked(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_ISADMIN_ID:
             hr = GetProperty_IsAdmin(
                      hConn,
                      fExplicit
                      );
             break;

        case USER_MAXLOGINS_ID:
             hr = GetProperty_MaxLogins(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_CANPASSWORDEXPIRE_ID:
             hr = GetProperty_CanPasswordExpire(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_PASSWORDEXPIRATIONDATE_ID:
             hr = GetProperty_PasswordExpirationDate(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_PASSWORDMINIMUMLENGTH_ID:
             hr = GetProperty_PasswordMinimumLength(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_PASSWORDREQUIRED_ID:
             hr = GetProperty_PasswordRequired(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_REQUIREUNIQUEPASSWORD_ID:
             hr = GetProperty_RequireUniquePassword(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

         case USER_LOGINHOURS_ID:
             hr = GetProperty_LoginHours(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        }

        BAIL_ON_FAILURE(hr);
    }

    // 
    // if NWApiGetLOGIN_CONTROL failed, it's okay, we just ignore
    // it and don't load those properties into the cache
    //
    hr = S_OK;

error:

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetAccountStatistics
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetAccountStatistics(
    NWCONN_HANDLE hConn,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    LC_STRUCTURE LoginCtrlStruct;

    //
    // Get LOGIN_CONTROL.
    //

    hr = NWApiGetLOGIN_CONTROL(
             hConn,
             _Name,
             &LoginCtrlStruct
             );

    if (SUCCEEDED(hr)) {

        //
        // Get property.
        //

        switch (dwPropertyID) {

        case USER_BADLOGINADDRESS_ID:
             hr = GetProperty_BadLoginAddress(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_LASTLOGIN_ID:
             hr = GetProperty_LastLogin(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;
        }

        BAIL_ON_FAILURE(hr);
    }

    // 
    // if NWApiGetLOGIN_CONTROL failed, it's okay, we just ignore
    // it and don't load those properties into the cache
    //
    hr = S_OK;

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_FullName
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_FullName(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    LPWSTR           lpszFullName = NULL;
    CHAR             szFullName[MAX_FULLNAME_LEN + 1];
    DWORD            dwNumSegment = 0;
    HRESULT          hr = S_OK;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL; // Used by DELETE_LIST macro below

    //
    // Get IDENTIFICATIOIN.  This property contains the full name of an object.
    //

    hr = NWApiGetProperty(
             _Name,
             NW_PROP_IDENTIFICATION,
             OT_USER,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );

    //
    // This call will fail for those users who has never set
    // their Fullname, ie. "IDENTIFICATION" is not created. Per Raid #34833
    // (resolved By Design), there is no way to distinguish a failure for
    // the property not existing from a general failure --- they both return the
    // same error code.  In general, it is expected that a Bindery user will have
    // the IDENTIFICATION property, so if this call fails we assume it was because
    // the property didn't exist.  In this case, we return success, since it was
    // successful, there just didn't happen to be an IDENTIFICATION.
    //
    if (FAILED(hr)) {
	hr = S_OK;
	goto error;
    }

    //
    // Convert result into a UNICODE string.
    //

    strcpy(szFullName, lpReplySegment->Segment);

    lpszFullName = (LPWSTR) AllocADsMem(
                                (strlen(szFullName)+1) * sizeof(WCHAR)
                                );
    if (!lpszFullName)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    AnsiToUnicodeString(
        szFullName,
        lpszFullName,
        0
        );

    //
    // Unmarshall.
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("FullName"),
                (LPWSTR)lpszFullName,
                fExplicit
                );
    BAIL_ON_FAILURE(hr);

error:

    if (lpszFullName) {

        FreeADsMem(lpszFullName);
    }
    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }



    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_AccountDisabled
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_AccountDisabled(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // Put value into a variant.
    //

    dwBool = (BOOL) LoginCtrlStruct.byAccountDisabled;

    //
    // Unmarshall.
    //

    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("AccountDisabled"),
             dwBool,
             fExplicit
             );


    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_AccountExpirationDate
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_AccountExpirationDate(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    BYTE byDateTime[6];
    BYTE byNoDateTime[6];

    memset(byNoDateTime, 0, 6);
    memset(byDateTime, 0, 6);
    memcpy(byDateTime, LoginCtrlStruct.byAccountExpires, 3);

    //
    // LoginCtrlSturct.byAccountExpires == 000 indicates no expired date
    //
    if (memcmp(byDateTime, byNoDateTime, 3)!=0) {

        hr = SetNw312DATEPropertyInCache(
                    _pPropertyCache,
                    TEXT("AccountExpirationDate"),
                    byDateTime,
                    fExplicit
                    );

        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_CanAccountExpire
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_CanAccountExpire(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // Account cannot expire if there is no expiration date.
    //

    if ((LoginCtrlStruct.byAccountExpires[0] == 0) &&
        (LoginCtrlStruct.byAccountExpires[1] == 0) &&
        (LoginCtrlStruct.byAccountExpires[2] == 0)) {

        dwBool = FALSE;
    }

    //
    // Unmarshall.
    //

    hr = SetBOOLPropertyInCache(
            _pPropertyCache,
            TEXT("AccountCanExpire"),
            dwBool,
            fExplicit
            );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_GraceLoginsAllowed
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_GraceLoginsAllowed(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    LONG         lGraceLoginsAllowed = 0;

    //
    // Get "byGraceLoginReset".  The property is not meaningful when it equals
    // to 0xff.
    //

    if (LoginCtrlStruct.byGraceLoginReset != 0xff) {

        lGraceLoginsAllowed = (LONG) LoginCtrlStruct.byGraceLoginReset;
    }

    //
    // Unmarshall.
    //

    hr = SetDWORDPropertyInCache(
             _pPropertyCache,
             TEXT("GraceLoginsAllowed"),
             (DWORD)lGraceLoginsAllowed,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_GraceLoginsRemaining
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_GraceLoginsRemaining(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    LONG         lGraceLoginsRemaining = 0;

    //
    // Get "byGraceLogins".  The property is not meaningful when it equals to
    // 0xff.
    //

    if (LoginCtrlStruct.byGraceLogins != 0xff) {

        lGraceLoginsRemaining = (LONG) LoginCtrlStruct.byGraceLogins;
    }

    //
    // Unmarshall.
    //

    hr = SetDWORDPropertyInCache(
             _pPropertyCache,
             TEXT("GraceLoginsRemaining"),
             (DWORD)lGraceLoginsRemaining,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_IsAccountLocked
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_IsAccountLocked(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = FALSE;
    HRESULT      hr = S_OK;

    //
    // Account is locked when wBadLogins = 0xffff.
    //

    if (LoginCtrlStruct.wBadLogins == 0xffff) {

        dwBool = TRUE;
    }

    //
    // Unmarshall.
    //

    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("IsAccountLocked"),
             dwBool,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_IsAdmin
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_IsAdmin(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    BOOL    dwBool = TRUE;
    HRESULT hr = S_OK;

    //
    // Check if this user has the same security as the supervisor.  If it does,
    // then it is an admin.
    //

    hr = NWApiIsObjectInSet(
             hConn,
             _Name,
             OT_USER,
             NW_PROP_SECURITY_EQUALS,
             NW_PROP_SUPERVISOR,
             OT_USER
             );

    // Per bug #33322 (resolved By Design), there is no way to distinguish
    // "no such object" from a general failure.  So we assume that any failure
    // is "no such object".

    if (FAILED(hr)) {
        dwBool = FALSE;
        hr = S_OK;
    }

    //
    // Unmarshall.
    //

    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("IsAdmin"),
             dwBool,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_MaxLogins
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_MaxLogins(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    LONG         lMaxLogins = 0;

    //
    // Get "wMaxConnections".
    //

    lMaxLogins = (LONG) NWApiReverseWORD(
                            LoginCtrlStruct.wMaxConnections
                            );

    //
    // Unmarshall.
    //

    hr = SetDWORDPropertyInCache(
             _pPropertyCache,
             TEXT("MaxLogins"),
             (DWORD)lMaxLogins,
             fExplicit
             );


    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_CanPasswordExpire
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_CanPasswordExpire(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // Password cannot expire if there is no expiration date.
    //

    if ((LoginCtrlStruct.byPasswordExpires[0] == 0) &&
        (LoginCtrlStruct.byPasswordExpires[1] == 0) &&
        (LoginCtrlStruct.byPasswordExpires[2] == 0)) {

        dwBool = FALSE;
    }

    //
    // Unmarshall.
    //
    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("PasswordCanExpire"),
             dwBool,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_PasswordExpirationDate
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_PasswordExpirationDate(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    BYTE byDateTime[6];

    memset(byDateTime, 0, 6);
    memcpy(byDateTime, LoginCtrlStruct.byPasswordExpires, 3);

    hr = SetNw312DATEPropertyInCache(
                _pPropertyCache,
                TEXT("PasswordExpirationDate"),
                byDateTime,
                fExplicit
                );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_PasswordMinimumLength
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_PasswordMinimumLength(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    LONG         lMinimumLength = 0;

    //
    // Get "byMinPasswordLength".
    //

    lMinimumLength = (LONG) LoginCtrlStruct.byMinPasswordLength;

    //
    // Unmarshall.
    //

    hr = SetDWORDPropertyInCache(
             _pPropertyCache,
             TEXT("PasswordMinimumLength"),
             (DWORD)lMinimumLength,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_PasswordRequired
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_PasswordRequired(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // Password is not required if "byMinPasswordLength" is 0.
    //

    if (LoginCtrlStruct.byMinPasswordLength == 0) {

        dwBool = FALSE;
    }

    //
    // Unmarshall.
    //

    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("PasswordRequired"),
             dwBool,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_RequireUniquePassword
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_RequireUniquePassword(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // If byRestrictions = 0, "RequireUniquePassword" = FALSE.
    //

    if (LoginCtrlStruct.byRestrictions == 0) {

        dwBool = FALSE;
    }

    //
    // Unmarshall.
    //
    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("RequireUniquePassword"),
             dwBool,
             fExplicit
             );

    RRETURN(hr);
}

HRESULT
CNWCOMPATUser::GetProperty_LoginHours(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // Unmarshall.
    //
    hr = SetOctetPropertyInCache(
             _pPropertyCache,
             TEXT("LoginHours"),
             (BYTE*)LoginCtrlStruct.byLoginTimes,
             24,
             fExplicit
             );

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_BadLoginAddress
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_BadLoginAddress(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    LPWSTR  lpszTemp = NULL;

    //
    // Put address together in the format described in spec.
    //

    lpszTemp = (LPWSTR) AllocADsMem((NET_ADDRESS_NUM_CHAR+1)*sizeof(WCHAR));
    if (!lpszTemp) {
        RRETURN(E_OUTOFMEMORY);
    }

    wsprintf(
        lpszTemp,
        L"%s:%02X%02X%02X%02X.%02X%02X%02X%02X%02X%02X.%02X%02X",
        bstrAddressTypeString,
        LoginCtrlStruct.byBadLoginAddr[10],
        LoginCtrlStruct.byBadLoginAddr[11],
        LoginCtrlStruct.byBadLoginAddr[0],
        LoginCtrlStruct.byBadLoginAddr[1],
        LoginCtrlStruct.byBadLoginAddr[2],
        LoginCtrlStruct.byBadLoginAddr[3],
        LoginCtrlStruct.byBadLoginAddr[4],
        LoginCtrlStruct.byBadLoginAddr[5],
        LoginCtrlStruct.byBadLoginAddr[6],
        LoginCtrlStruct.byBadLoginAddr[7],
        LoginCtrlStruct.byBadLoginAddr[8],
        LoginCtrlStruct.byBadLoginAddr[9]
        );

    //
    // Unmarshall.
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("BadLoginAddress"),
                (LPWSTR)lpszTemp,
                fExplicit
                );
    BAIL_ON_FAILURE(hr);

error:

    if (lpszTemp) {

        FreeADsMem(lpszTemp);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_LastLogin
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_LastLogin(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{

    HRESULT hr = S_OK;
    BYTE byNoDateTime[6];

    memset(byNoDateTime, 0, 6);

    //
    // LastLogin==000000 indicates no or unknown LastLogin
    //
    if (memcmp(LoginCtrlStruct.byLastLogin, byNoDateTime, 6) != 0)  {

        hr =  SetNw312DATEPropertyInCache(
                _pPropertyCache,
                TEXT("LastLogin"),
                LoginCtrlStruct.byLastLogin,
                fExplicit
                );
    }

    RRETURN(hr);
}



HRESULT
ConvertNW312DateToVariant(
    BYTE byDateTime[],
    PDATE pDate
    )
{
    HRESULT hr = S_OK;
    WORD wYear;

    //
    // Subtract 80 from wYear for NWApiMakeVariantTime.
    //

    wYear = (WORD)byDateTime[0];

    if (wYear != 0) {
        wYear -= 80;
    }

    //
    // Convert into Variant Time.
    //

    hr = NWApiMakeVariantTime(
                pDate,
                (WORD)byDateTime[2],
                (WORD)byDateTime[1],
                wYear,
                0,0,0
                );
    RRETURN(hr);
}


HRESULT
ConvertVariantToNW312Date(
    DATE daDate,
    BYTE byDateTime[]
    )
{
    WORD wDay;
    WORD wYear;
    WORD wMonth;
    HRESULT hr = S_OK;

    hr = NWApiBreakVariantTime(
                daDate,
                &wDay,
                &wMonth,
                &wYear
                );
    BAIL_ON_FAILURE(hr);

    byDateTime[0] = (BYTE)wYear;
    byDateTime[1] = (BYTE)wMonth;
    byDateTime[2] = (BYTE)wDay;

    byDateTime[3] = 0;
    byDateTime[4] = 0;
    byDateTime[5] = 0;

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\fsmacro.h ===
#define PUT_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\globals.cxx ===
#include "NWCOMPAT.hxx"
#pragma hdrstop

const BSTR bstrAddressTypeString = L"IPX";
const BSTR bstrComputerOperatingSystem = L"NW3Compat";
const BSTR bstrFileShareDescription = L"Disk";
const BSTR bstrNWFileServiceName = L"NetWareFileServer";
const BSTR bstrProviderName   = L"NWCOMPAT";
const BSTR bstrProviderPrefix = L"NWCOMPAT:";

#define MAX_LONG    (0x7FFFFFFF)
#define MIN_LONG    (0x80000000)
#define MAX_BOOLEAN 1
#define MAX_STRLEN  256
#define MAX_UCHAR   255
#define MAX_USHORT  65535


PROPERTYINFO ComputerClass[] =
    { { TEXT("OperatingSystem"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, COMP_OPERATINGSYSTEM_ID, NT_SYNTAX_ID_LPTSTR},
      { TEXT("OperatingSystemVersion"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, COMP_OPERATINGSYSTEMVERSION_ID, NT_SYNTAX_ID_LPTSTR}
    };


DWORD gdwComputerTableSize = sizeof(ComputerClass)/sizeof(PROPERTYINFO);


PROPERTYINFO UserClass[] =
    { { TEXT("FullName"),
        TEXT(""), TEXT("String"), NW_DATA_SIZE, 0, FALSE,   //  max 128 bytes
        PROPERTY_RW, USER_FULLNAME_ID, NT_SYNTAX_ID_LPTSTR },
      { TEXT("AccountDisabled"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ACCOUNTDISABLED_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("AccountExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, USER_ACCOUNTEXPIRATIONDATE_ID, NT_SYNTAX_ID_NW312DATE },
      { TEXT("AccountCanExpire"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_CANACCOUNTEXPIRE_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("GraceLoginsAllowed"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_GRACELOGINSALLOWED_ID, NT_SYNTAX_ID_DWORD },
      { TEXT("GraceLoginsRemaining"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_GRACELOGINSREMAINING_ID, NT_SYNTAX_ID_DWORD },
      { TEXT("IsAccountLocked"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ISACCOUNTLOCKED_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("IsAdmin"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ISADMIN_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("MaxLogins"),
        TEXT(""), TEXT("Integer"), MAX_USHORT, 0, FALSE,
        PROPERTY_RW, USER_MAXLOGINS_ID, NT_SYNTAX_ID_DWORD},
      { TEXT("PasswordExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDEXPIRATIONDATE_ID, NT_SYNTAX_ID_NW312DATE},
      { TEXT("PasswordCanExpire"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_CANPASSWORDEXPIRE_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("PasswordMinimumLength"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDMINIMUMLENGTH_ID, NT_SYNTAX_ID_DWORD},
      { TEXT("PasswordRequired"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDREQUIRED_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("RequireUniquePassword"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_REQUIREUNIQUEPASSWORD_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("BadLoginAddress"),    // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, USER_BADLOGINADDRESS_ID, NT_SYNTAX_ID_LPTSTR},
      { TEXT("LastLogin"),          // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, USER_LASTLOGIN_ID, NT_SYNTAX_ID_NW312DATE},
      { TEXT("LoginHours"),          
        TEXT(""), TEXT("OctetString"), 0, 0, FALSE,
        PROPERTY_RW, USER_LOGINHOURS_ID, NT_SYNTAX_ID_OCTETSTRING}
    };

DWORD gdwUserTableSize = sizeof(UserClass)/sizeof(PROPERTYINFO);


PROPERTYINFO GroupClass[] =
    { { TEXT("Description"),            // FSGroupGeneralInfo
        TEXT(""), TEXT("String"), NW_DATA_SIZE, 0, FALSE,   // max 128 bytes
        PROPERTY_RW, GROUP_DESCRIPTION_ID, NT_SYNTAX_ID_LPTSTR }
    };


DWORD gdwGroupTableSize = sizeof(GroupClass)/sizeof(PROPERTYINFO);

PROPERTYINFO FileServiceClass[] =
    { { TEXT("HostComputer"),          // FSServiceConfiguration
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_USHORT, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD }
    };

DWORD gdwFileServiceTableSize = sizeof(FileServiceClass)/sizeof(PROPERTYINFO);

PROPERTYINFO FileShareClass[] =
    { { TEXT("Description"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("HostComputer"),
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_USHORT, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD }
    };

DWORD gdwFileShareTableSize = sizeof(FileShareClass)/sizeof(PROPERTYINFO);

PROPERTYINFO PrintQueueClass[] =
    { { TEXT("PrinterPath"), // FSPrintQueueGeneralInfo
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Model"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Datatype"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintProcessor"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Description"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Location"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("StartTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("UntilTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("DefaultJobPriority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Priority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("BannerPage"),
        TEXT(""), TEXT("Path"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintDevices"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DelimitedString }
    };

DWORD gdwPrinterTableSize = sizeof(PrintQueueClass)/sizeof(PROPERTYINFO);


PROPERTYINFO PrintJobClass[] =
    { { TEXT("HostPrintQueue"),     // ro, FSPrintJobGeneralInfo
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("User"),               // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeSubmitted"),      // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_SYSTEMTIME },
      { TEXT("TotalPages"),         // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_DWORD },
      { TEXT("Size"),               // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("Description"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("Priority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 1,  NT_SYNTAX_ID_DWORD },
      { TEXT("StartTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_DATE },
      { TEXT("UntilTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_DATE },
      { TEXT("Notify"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeElapsed"),        // ro
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("PagesPrinted"),       // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("Position"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_DWORD }
    };


DWORD gdwJobTableSize = sizeof(PrintJobClass)/sizeof(PROPERTYINFO);

CLASSINFO g_aNWCOMPATClasses[] =
{

//
//  Computer Class
//



  { COMPUTER_SCHEMA_NAME, &CLSID_NWCOMPATComputer, &IID_IADsComputer,
    TEXT(""), FALSE,

    NULL,


    TEXT("OperatingSystemVersion"),


    NULL, TEXT("User,Group,FileService,PrintQueue"), TRUE,
    TEXT(""), 0,
    ComputerClass, sizeof(ComputerClass)/sizeof(PROPERTYINFO) },


  { USER_SCHEMA_NAME, &CLSID_NWCOMPATUser, &IID_IADsUser,
    TEXT(""), FALSE,


    NULL,


    TEXT("FullName,AccountDisabled,AccountExpirationDate,")
    TEXT("AccountCanExpire,GraceLoginsAllowed,GraceLoginsRemaining,")
    TEXT("IsAccountLocked,IsAdmin,MaxLogins,PasswordExpirationDate,")
    TEXT("PasswordCanExpire,PasswordMinimumLength,PasswordRequired,")
    TEXT("RequireUniquePassword,BadLoginAddress,LastLogin"),


    TEXT("Computer"), NULL, FALSE,
    TEXT(""), 0,
    UserClass, sizeof(UserClass)/sizeof(PROPERTYINFO) },


  { GROUP_SCHEMA_NAME, &CLSID_NWCOMPATGroup, &IID_IADsGroup,
    TEXT(""), FALSE,


    NULL,


    TEXT("Description"),


    TEXT("Computer"), NULL, FALSE,
    TEXT(""), 0,
    GroupClass, sizeof(GroupClass)/sizeof(PROPERTYINFO) },

  { FILESERVICE_SCHEMA_NAME, &CLSID_NWCOMPATFileService, &IID_IADsFileService,
    TEXT(""), FALSE,


    NULL,


    TEXT("HostComputer,MaxUserCount,"),

    TEXT("Computer"), TEXT("FileShare"), TRUE,
    TEXT(""), 0,
    FileServiceClass, sizeof(FileServiceClass)/sizeof(PROPERTYINFO) },

  { FILESHARE_SCHEMA_NAME,  &CLSID_NWCOMPATFileShare,  &IID_IADsFileShare,
    TEXT(""), FALSE,

    NULL,

    TEXT("Description,HostComputer,MaxUserCount"),

    TEXT("FileService"), NULL, FALSE,
    TEXT(""), 0,
    FileShareClass, sizeof(FileShareClass)/sizeof(PROPERTYINFO) },


  { PRINTER_SCHEMA_NAME, &CLSID_NWCOMPATPrintQueue, &IID_IADsPrintQueue,
    TEXT(""), FALSE,

    NULL,


    TEXT("PrinterPath,Model,Datatype,PrintProcessor,")
    TEXT("Description,Location,StartTime,UntilTime,DefaultJobPriority,")
    TEXT("Priority,BannerPage,PrintDevices"),


    TEXT("Computer"), NULL, FALSE,
    TEXT(""), 0,
    PrintQueueClass, sizeof(PrintQueueClass)/sizeof(PROPERTYINFO) },

  { PRINTJOB_SCHEMA_NAME, &CLSID_NWCOMPATPrintJob, &IID_IADsPrintJob,
    TEXT(""), FALSE,


    NULL,


    TEXT("HostPrintQueue,User,TimeSubmitted,TotalPages,")
    TEXT("Size,Priority,StartTime,UntilTime,Notify,TimeElapsed,")
    TEXT("PagesPrinted,Position"),


    NULL, NULL, FALSE,
    TEXT(""), 0,
    PrintJobClass, sizeof(PrintJobClass)/sizeof(PROPERTYINFO) }

};

SYNTAXINFO g_aNWCOMPATSyntax[] =
{ {  TEXT("Boolean"),       VT_BOOL },
  {  TEXT("Counter"),       VT_I4 },
  {  TEXT("ADsPath"),     VT_BSTR },
  {  TEXT("EmailAddress"),  VT_BSTR },
  {  TEXT("FaxNumber"),     VT_BSTR },
  {  TEXT("Integer"),       VT_I4 },
  {  TEXT("Interval"),      VT_I4 },
  {  TEXT("List"),          VT_VARIANT },  // VT_BSTR | VT_ARRAY
  {  TEXT("NetAddress"),    VT_BSTR },
  {  TEXT("OctetString"),   VT_VARIANT },  // VT_UI1| VT_ARRAY
  {  TEXT("Path"),          VT_BSTR },
  {  TEXT("PhoneNumber"),   VT_BSTR },
  {  TEXT("PostalAddress"), VT_BSTR },
  {  TEXT("SmallInterval"), VT_I4 },
  {  TEXT("String"),        VT_BSTR },
  {  TEXT("Time"),          VT_DATE }
};

DWORD g_cNWCOMPATClasses = (sizeof(g_aNWCOMPATClasses)/sizeof(g_aNWCOMPATClasses[0]));
DWORD g_cNWCOMPATSyntax = (sizeof(g_aNWCOMPATSyntax)/sizeof(g_aNWCOMPATSyntax[0]));

PROPERTYINFO g_aNWCOMPATProperties[] =
    { { TEXT("OperatingSystem"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, COMP_OPERATINGSYSTEM_ID, NT_SYNTAX_ID_LPTSTR},
      { TEXT("OperatingSystemVersion"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, COMP_OPERATINGSYSTEMVERSION_ID, NT_SYNTAX_ID_LPTSTR},

      // User Properties

      { TEXT("FullName"),
        TEXT(""), TEXT("String"), NW_DATA_SIZE, 0, FALSE,   //  max 128 bytes
        PROPERTY_RW, USER_FULLNAME_ID, NT_SYNTAX_ID_LPTSTR },
      { TEXT("AccountDisabled"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ACCOUNTDISABLED_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("AccountExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, USER_ACCOUNTEXPIRATIONDATE_ID, NT_SYNTAX_ID_NW312DATE },
      { TEXT("AccountCanExpire"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_CANACCOUNTEXPIRE_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("GraceLoginsAllowed"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_GRACELOGINSALLOWED_ID, NT_SYNTAX_ID_DWORD },
      { TEXT("GraceLoginsRemaining"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_GRACELOGINSREMAINING_ID, NT_SYNTAX_ID_DWORD },
      { TEXT("IsAccountLocked"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ISACCOUNTLOCKED_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("IsAdmin"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ISADMIN_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("MaxLogins"),
        TEXT(""), TEXT("Integer"), MAX_USHORT, 0, FALSE,
        PROPERTY_RW, USER_MAXLOGINS_ID, NT_SYNTAX_ID_DWORD},
      { TEXT("PasswordExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDEXPIRATIONDATE_ID, NT_SYNTAX_ID_NW312DATE},
      { TEXT("PasswordCanExpire"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_CANPASSWORDEXPIRE_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("PasswordMinimumLength"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDMINIMUMLENGTH_ID, NT_SYNTAX_ID_DWORD},
      { TEXT("PasswordRequired"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDREQUIRED_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("RequireUniquePassword"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_REQUIREUNIQUEPASSWORD_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("BadLoginAddress"),    // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, USER_BADLOGINADDRESS_ID, NT_SYNTAX_ID_LPTSTR},
      { TEXT("LastLogin"),          // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, USER_LASTLOGIN_ID, NT_SYNTAX_ID_NW312DATE},

      // Group Properties

      { TEXT("Description"),            // FSGroupGeneralInfo
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,   // max 128 bytes
        PROPERTY_RW, GROUP_DESCRIPTION_ID, NT_SYNTAX_ID_LPTSTR },

      // FileService Properties

      { TEXT("HostComputer"),          // FSServiceConfiguration
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_USHORT, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD },

      // FileShare Properties

      //
      // Description (Group)
      //
      // HostComputer (FileService)
      //
      // MaxUserCount(FileService)
      //

      // PrintQueue Properties

      //
      // HostComputer (FileService)
      //
      { TEXT("Model"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Datatype"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintProcessor"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      //
      // Description (Group)
      //
      { TEXT("Location"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("StartTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("UntilTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("DefaultJobPriority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Priority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("BannerPage"),
        TEXT(""), TEXT("Path"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintDevices"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DelimitedString },

      // PrintJob Properties

      { TEXT("HostPrintQueue"),     // ro, FSPrintJobGeneralInfo
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("User"),               // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeSubmitted"),      // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_SYSTEMTIME },
      { TEXT("TotalPages"),         // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_DWORD },
      { TEXT("Size"),               // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      //
      //  Description (Group)
      //
      // Priority (PrintQueue)
      //
      //
      // StartTime (PrintQueue)
      //
      // UntilTime(PrintQueue)
      //
      { TEXT("Notify"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeElapsed"),        // ro
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("PagesPrinted"),       // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("Position"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_DWORD }

    };


DWORD g_cNWCOMPATProperties = (sizeof(g_aNWCOMPATProperties)/sizeof(g_aNWCOMPATProperties[0]));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\nw312_2.h ===
#define NWCOMPAT_LIBIID_NWCOMPATOle        09d69aa0-4b62-11cf-ae2c-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATProvider    0df68130-4b62-11cf-ae2c-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATNamespace   0fb32cc0-4b62-11cf-ae2c-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATComputer    cad1bde0-4cf0-11cf-ae2d-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATUser        5c250b00-5863-11cf-ae32-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATGroup       3c5662e0-5a74-11cf-ae32-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATDomain             9f6616f0-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATService            9f02c3c0-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATPrintQueue         9e7dd270-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATPrintJob           9e09b030-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATFileService        9d9eb910-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATSession            9d2a96d0-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATResource           9cb36630-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATFileShare          9c486f10-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATSchema             9bcfb740-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATClass              9b602a90-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATSyntax             9af53370-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATProperty           44687d30-7937-11cf-ae3b-00aa006ebfb9
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\extension.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for ADs.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma hdrstop


LPCWSTR lpszTopLevel = L"SOFTWARE\\Microsoft\\ADs\\Providers\\NWCOMPAT";
LPCWSTR lpszExtensions = L"Extensions";

PCLASS_ENTRY gpClassHead = NULL;


PCLASS_ENTRY
BuildClassesList()
{
    HKEY hTopLevelKey = NULL;
    HKEY hExtensionKey = NULL;
    HKEY hExtensionRootKey = NULL;

    HKEY hClassKey = NULL;

    DWORD dwIndex = 0;
    WCHAR lpszClassName[MAX_PATH];
    DWORD dwchClassName = 0;
    PCLASS_ENTRY pClassHead = NULL;
    PCLASS_ENTRY pClassEntry = NULL;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     lpszTopLevel,
                     0,
                     KEY_READ,
                     &hTopLevelKey
                     ) != ERROR_SUCCESS)
    {
        goto CleanupAndExit;
    }

    if (RegOpenKeyEx(hTopLevelKey,
                     lpszExtensions,
                     0,
                     KEY_READ,
                     &hExtensionRootKey
                     ) != ERROR_SUCCESS)

    {
        goto CleanupAndExit;

    }

    memset(lpszClassName, 0, sizeof(lpszClassName));
    dwchClassName = sizeof(lpszClassName)/sizeof(WCHAR);

    while(RegEnumKeyEx(hExtensionRootKey,
                     dwIndex,
                     lpszClassName,
                     &dwchClassName,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hExtensionRootKey,
                         lpszClassName,
                         0,
                         KEY_READ,
                         &hClassKey
                         ) != ERROR_SUCCESS){
            goto CleanupAndExit;
        }

        pClassEntry  = BuildClassEntry(
                                lpszClassName,
                                hClassKey
                                );

        if (pClassEntry) {

            pClassEntry->pNext = pClassHead;
            pClassHead = pClassEntry;
        }

        if (hClassKey) {
            CloseHandle(hClassKey);
        }

        memset(lpszClassName, 0, sizeof(lpszClassName));
        dwchClassName = sizeof(lpszClassName)/sizeof(WCHAR);
        dwIndex++;
    }

CleanupAndExit:

    if (hExtensionRootKey) {
        RegCloseKey(hExtensionRootKey);
    }

    if (hTopLevelKey) {
        RegCloseKey(hTopLevelKey);
    }

    return(pClassHead);
}


VOID
FreeClassesList(
    PCLASS_ENTRY pClassHead
    )
{
    PCLASS_ENTRY pDelete;

    while (pClassHead) {

        pDelete = pClassHead;
        pClassHead = pClassHead->pNext;

        FreeClassEntry(pDelete);
    }

    return;
}


PCLASS_ENTRY
BuildClassEntry(
    LPWSTR lpszClassName,
    HKEY hClassKey
    )
{
    HKEY hTopLevelKey = NULL;
    HKEY hExtensionKey = NULL;

    DWORD dwIndex = 0;
    DWORD dwchExtensionCLSID = 0;
    WCHAR lpszExtensionCLSID[MAX_PATH];
    PCLASS_ENTRY pClassEntry = NULL;
    PEXTENSION_ENTRY pExtensionHead = NULL;
    PEXTENSION_ENTRY pExtensionEntry = NULL;

    pClassEntry =  (PCLASS_ENTRY)AllocADsMem(sizeof(CLASS_ENTRY));

    if (!pClassEntry) {

        goto CleanupAndExit;
    }

    wcscpy(pClassEntry->szClassName, lpszClassName);

    memset(lpszExtensionCLSID, 0, sizeof(lpszExtensionCLSID));
    dwchExtensionCLSID = sizeof(lpszExtensionCLSID)/sizeof(WCHAR);

    while(RegEnumKeyEx(hClassKey,
                     dwIndex,
                     lpszExtensionCLSID,
                     &dwchExtensionCLSID,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hClassKey,
                         lpszExtensionCLSID,
                         0,
                         KEY_READ,
                         &hExtensionKey
                         ) != ERROR_SUCCESS){
            goto CleanupAndExit;
        }

        //
        // Read the Interfaces that this Extension supports
        //

        pExtensionEntry = BuildExtensionEntry(
                                lpszExtensionCLSID,
                                hExtensionKey
                                );

        if (pExtensionEntry) {

            wcscpy(pExtensionEntry->szExtensionCLSID, lpszExtensionCLSID);

            pExtensionEntry->pNext = pExtensionHead;
            pExtensionHead = pExtensionEntry;
        }


        if (hExtensionKey) {

            CloseHandle(hExtensionKey);
        }

        memset(lpszExtensionCLSID, 0, sizeof(lpszExtensionCLSID));
        dwchExtensionCLSID = sizeof(lpszExtensionCLSID)/sizeof(WCHAR);
        dwIndex++;

    }

    pClassEntry->pExtensionHead = pExtensionHead;




CleanupAndExit:

    return(pClassEntry);
}


PEXTENSION_ENTRY
BuildExtensionEntry(
    LPWSTR lpszExtensionCLSID,
    HKEY hExtensionKey
    )
{
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PINTERFACE_ENTRY pInterfaceEntry = NULL;
    PINTERFACE_ENTRY pInterfaceHead = NULL;
    WCHAR lpszInterfaces[MAX_PATH];
    DWORD dwchInterfaces = 0;
    LPWSTR psz = NULL;
    WCHAR Interface[MAX_PATH];
    HRESULT hr = S_OK;


    pExtensionEntry =  (PEXTENSION_ENTRY)AllocADsMem(sizeof(EXTENSION_ENTRY));

    if (!pExtensionEntry) {

        goto CleanupAndExit;
    }

    memset(lpszInterfaces, 0, sizeof(lpszInterfaces));
    dwchInterfaces = sizeof(lpszInterfaces);

    RegQueryValueEx(
            hExtensionKey,
            L"Interfaces",
            NULL,
            NULL,
            (LPBYTE) lpszInterfaces,
            &dwchInterfaces
            );

    psz = lpszInterfaces;

    while (psz && *psz) {

       wcscpy(Interface, psz);

       // skip (length) + 1
       // lstrlen returns length sans '\0'


       pInterfaceEntry = (PINTERFACE_ENTRY)AllocADsMem(sizeof(INTERFACE_ENTRY));

       if (pInterfaceEntry) {

           wcscpy(pInterfaceEntry->szInterfaceIID, Interface);
           hr = IIDFromString(Interface, &(pInterfaceEntry->iid));

           pInterfaceEntry->pNext = pInterfaceHead;
           pInterfaceHead = pInterfaceEntry;

       }

       psz = psz + lstrlen(psz) + 1;

    }

    wcscpy(pExtensionEntry->szExtensionCLSID, lpszExtensionCLSID);
    hr = CLSIDFromString(lpszExtensionCLSID, &(pExtensionEntry->ExtCLSID));

    pExtensionEntry->pIID = pInterfaceHead;

CleanupAndExit:

    return(pExtensionEntry);
}


void
FreeInterfaceEntry(
    PINTERFACE_ENTRY pInterfaceEntry
    )
{
    if (pInterfaceEntry) {

        FreeADsMem(pInterfaceEntry);
    }
}


void
FreeExtensionEntry(
    PEXTENSION_ENTRY pExtensionEntry
    )
{
    PINTERFACE_ENTRY pInterfaceEntry = NULL;
    PINTERFACE_ENTRY pTemp = NULL;

    if (pExtensionEntry) {

        pInterfaceEntry = pExtensionEntry->pIID;

        while (pInterfaceEntry) {

            pTemp = pInterfaceEntry->pNext;

            if (pInterfaceEntry) {

                FreeInterfaceEntry(pInterfaceEntry);
            }

            pInterfaceEntry = pTemp;

        }

        //
        // Now unload the Extension Object
        //

        if (pExtensionEntry->pUnknown) {

            //
            // Call non-delegating Release to release ref. count on innner
            // object (for pUnkown) -> inner object self destroy
            //
            (pExtensionEntry->pUnknown)->Release();

        }


        FreeADsMem(pExtensionEntry);
    }

    return;
}

void
FreeClassEntry(
    PCLASS_ENTRY pClassEntry
    )
{

    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PEXTENSION_ENTRY pTemp = NULL;

    if (pClassEntry) {

        pExtensionEntry = pClassEntry->pExtensionHead;

        while (pExtensionEntry) {

            pTemp = pExtensionEntry->pNext;

            if (pExtensionEntry) {

                FreeExtensionEntry(pExtensionEntry);
            }

            pExtensionEntry = pTemp;

        }

        FreeADsMem(pClassEntry);
    }

    return;
}


PINTERFACE_ENTRY
MakeCopyofInterfaceEntry(
    PINTERFACE_ENTRY pInterfaceEntry
    )
{
    PINTERFACE_ENTRY pNewInterfaceEntry = NULL;

    pNewInterfaceEntry = (PINTERFACE_ENTRY)AllocADsMem(sizeof(INTERFACE_ENTRY));

    if (pNewInterfaceEntry) {

        wcscpy(pNewInterfaceEntry->szInterfaceIID, pInterfaceEntry->szInterfaceIID);
        memcpy(&(pNewInterfaceEntry->iid), &(pInterfaceEntry->iid), sizeof(GUID));
    }

    return(pNewInterfaceEntry);
}



PEXTENSION_ENTRY
MakeCopyofExtensionEntry(
    PEXTENSION_ENTRY pExtensionEntry
    )
{
    PEXTENSION_ENTRY pNewExtensionEntry = NULL;

    PINTERFACE_ENTRY pInterfaceEntry = NULL;

    PINTERFACE_ENTRY pNewInterfaceEntry = NULL;

    PINTERFACE_ENTRY pNewInterfaceHead = NULL;


    pInterfaceEntry = pExtensionEntry->pIID;

    while (pInterfaceEntry) {

        pNewInterfaceEntry = MakeCopyofInterfaceEntry(pInterfaceEntry);

        if (pNewInterfaceEntry) {

            pNewInterfaceEntry->pNext = pNewInterfaceHead;
            pNewInterfaceHead = pNewInterfaceEntry;
        }

        pInterfaceEntry = pInterfaceEntry->pNext;

    }

    pNewExtensionEntry = (PEXTENSION_ENTRY)AllocADsMem(sizeof(EXTENSION_ENTRY));

    if (pNewExtensionEntry) {

        wcscpy(
            pNewExtensionEntry->szExtensionCLSID,
            pExtensionEntry->szExtensionCLSID
            );

        memcpy(
            &(pNewExtensionEntry->ExtCLSID),
            &(pExtensionEntry->ExtCLSID),
            sizeof(GUID)
            );

        pNewExtensionEntry->pIID = pNewInterfaceHead;


        //
        // Initialize fields we won't know the values of until an instacne of
        // the extension is created and aggregated (loaded).
        //

        pNewExtensionEntry->pUnknown=NULL;
        pNewExtensionEntry->pPrivDisp=NULL;
        pNewExtensionEntry->pADsExt=NULL;
        pNewExtensionEntry->fDisp=FALSE;
        pNewExtensionEntry->dwExtensionID = (DWORD) -1; //invalid dwExtensionID

        //
        // let class entry handle pNext
        //
    }

    return(pNewExtensionEntry);
}


PCLASS_ENTRY
MakeCopyofClassEntry(
    PCLASS_ENTRY pClassEntry
    )
{
    PCLASS_ENTRY pNewClassEntry = NULL;

    PEXTENSION_ENTRY pExtensionEntry = NULL;

    PEXTENSION_ENTRY pNewExtensionEntry = NULL;

    PEXTENSION_ENTRY pNewExtensionHead = NULL;


    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        pNewExtensionEntry = MakeCopyofExtensionEntry(pExtensionEntry);

        if (pNewExtensionEntry) {

            pNewExtensionEntry->pNext = pNewExtensionHead;
            pNewExtensionHead = pNewExtensionEntry;
        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    pNewClassEntry = (PCLASS_ENTRY)AllocADsMem(sizeof(CLASS_ENTRY));

    if (pNewClassEntry) {

        wcscpy(pNewClassEntry->szClassName, pClassEntry->szClassName);

        pNewClassEntry->pExtensionHead = pNewExtensionHead;

    }

    return(pNewClassEntry);
}


CRITICAL_SECTION g_ExtCritSect;


#define ENTER_EXTENSION_CRITSECT()  EnterCriticalSection(&g_ExtCritSect)
#define LEAVE_EXTENSION_CRITSECT()  LeaveCriticalSection(&g_ExtCritSect)

HRESULT
ADSIGetExtensionList(
    LPWSTR pszClassName,
    PCLASS_ENTRY * ppClassEntry
    )
{

    PCLASS_ENTRY pTempClassEntry = NULL;
    PCLASS_ENTRY pClassEntry = NULL;
    ENTER_EXTENSION_CRITSECT();

    pTempClassEntry = gpClassHead;

    while (pTempClassEntry) {


        if (!_wcsicmp(pTempClassEntry->szClassName, pszClassName)) {

            //
            // Make a copy of this entire extension and
            // hand it over to the calling entity.
            //

            pClassEntry = MakeCopyofClassEntry(pTempClassEntry);

            *ppClassEntry = pClassEntry;

            LEAVE_EXTENSION_CRITSECT();

            RRETURN(S_OK);

        }

        pTempClassEntry = pTempClassEntry->pNext;

   }


   *ppClassEntry = NULL;

   LEAVE_EXTENSION_CRITSECT();

   RRETURN(S_OK);

}


//
//
// Instantiate extension objects listed in <pClassEntry> as aggregatees of
// aggregator <pUnkOuter>.
//
// Max Load 127 extensions. Return S_FALSE if more extension in <pClassEntry>


HRESULT
ADSILoadExtensions(
    IUnknown FAR * pUnkOuter,
    PCLASS_ENTRY pClassEntry
    )

{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtEntry = NULL;
    DWORD dwExtensionID = MIN_EXTENSION_ID;
    IPrivateDispatch * pPrivDisp = NULL;
    BOOL    fReturnError = FALSE;
    VARIANT varUserName, varPassword, varAuthFlags;

    VariantInit(&varUserName);
    VariantInit(&varPassword);
    VariantInit(&varAuthFlags);

    varUserName.vt = VT_BSTR;
    varUserName.bstrVal = NULL;

    varPassword.vt = VT_BSTR;
    varPassword.bstrVal = NULL;

    varAuthFlags.vt = VT_I4;
    varAuthFlags.lVal = 0;

    ASSERT(pUnkOuter);


    if (!pClassEntry || !(pExtEntry=pClassEntry->pExtensionHead) ) {
        RRETURN(S_OK);
    }

    while (pExtEntry) {

        //
        // Max # of extension have been loaded, cannot load more
        //

        if (dwExtensionID>MAX_EXTENSION_ID) {

            hr = S_FALSE;
            fReturnError = TRUE;
            break;
        }

        //
        // create extension object (aggregatee) and ask for Non-delegating
        // IUnknown. Ref count on extension object = 1.
        //

        hr = CoCreateInstance(
                    pExtEntry->ExtCLSID,
                    pUnkOuter,
                    CLSCTX_INPROC_SERVER,
                    IID_IUnknown,
                    (void **)&(pExtEntry->pUnknown)
                    );

        //
        // if fail, go to next extesion entry s.t. bad individual extension
        // cannot block other extensions from loading (no clean up needed)
        //
        // The user receives no warning about the failure to load a particular
        // extension (we really don't have any way to do so specified), other
        // than the fact that their extension doesn't work when they try to
        // use it (e.g., they'll probably get back something like
        // DISP_E_UNKNOWNNAME when they try to use GetIDsOfNames to find its
        // methods).
        //

        if (SUCCEEDED(hr)) {

            pExtEntry->dwExtensionID = dwExtensionID;


            hr = (pExtEntry->pUnknown)->QueryInterface(
                        IID_IADsExtension,
                        (void **) &(pExtEntry->pADsExt)
                        );

            if  (FAILED(hr)) {

                //
                // extension does not support the optioanl IADsExtension -> OK.
                // (no clean up needed)
                //

                pExtEntry->pADsExt=NULL;

                pExtEntry->fDisp = FALSE;

            } else {

                //
                // Cache the interface ptr but call Release() immediately to
                // avoid aggregator having a ref count on itself
                // since IADsExtension inherits from delegating IUnknown.
                //
                // Note: codes still works if inherit from NonDelegatingIUknown
                //

                (pExtEntry->pADsExt)->Release() ;

                //
                // For efficiency, set this flag to FALSE on FIRST encounter of
                // pADsExt->PrivateGetIDsOfNames()/Invoke() returning E_NOTIMPL.
                // Set as TRUE now s.t. at least first encounter will happen.
                //

                pExtEntry->fDisp = TRUE;

                pExtEntry->pADsExt->Operate(
                                        ADS_EXT_INITCREDENTIALS,
                                        varUserName,
                                        varPassword,
                                        varAuthFlags
                                        );
            }

        } // end if CoCreateInstance() succeeded

        pExtEntry = pExtEntry->pNext;


        //
        // ++ extension ID even if creat'n of extension fails just to be safe
        // - chuck's stuff :)
        //

        dwExtensionID++;

    }   // end while


    if (fReturnError) {
        RRETURN(hr);        // fetal error,
    }
    else {
        RRETURN(S_OK);      // "okay" error if any, optional support
    }

}

#if 0
HRESULT
ADSILoadExtensions(
    IUnknown FAR * pUnkOuter,
    PCLASS_ENTRY pClassEntry,
    LPTSTR pszClassName
    )

{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    DWORD dwExtensionID = 1;
    IPrivateDispatch * pPrivDisp = NULL;

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        hr = CoCreateInstance(
                    pExtensionEntry->ExtCLSID,
                    pUnkOuter,
                    CLSCTX_INPROC_SERVER,
                    IID_IPrivateUnknown,
                    (void **)&(pExtensionEntry->pUnknown)
                    );


        if (SUCCEEDED(hr)) {


            hr = (pExtensionEntry->pUnknown)->ADSIInitializeObject(
                                                    NULL,
                                                    NULL,
                                                    0
                                                    );

            pExtensionEntry->dwExtensionID = dwExtensionID;

            hr = (pExtensionEntry->pUnknown)->QueryInterface(
                                    IID_IPrivateDispatch,
                                    (void **)&pPrivDisp
                                    );
            if (SUCCEEDED(hr)) {

                hr = pPrivDisp->ADSIInitializeDispatchManager(dwExtensionID);

                if (FAILED(hr)) {

                    //
                    // Remember NOT to do a Release here for IPrivateDispatch
                    //

                    pExtensionEntry->fDisp = FALSE;

                    (pExtensionEntry->pUnknown)->Release();


                }else {
                    pExtensionEntry->fDisp = TRUE;
                    pExtensionEntry->pPrivDisp = pPrivDisp;

                    //
                    // Now release  both pointers because we don't want to
                    // have a cyclic reference count
                    //

                    (pExtensionEntry->pPrivDisp)->Release();
                    (pExtensionEntry->pUnknown)->Release();
                }

            }else {
                pExtensionEntry->fDisp = FALSE;

                (pExtensionEntry->pUnknown)->Release();

            }

        }

        pExtensionEntry = pExtensionEntry->pNext;

        dwExtensionID++;

    }

    RRETURN(S_OK);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\getobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  getobj.cxx
//
//  Contents:  NetWare 3.12 GetObject functionality
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//  Function:  GetObject
//
//  Synopsis:  Called by ResolvePathName to return an object
//
//  Arguments:  [LPWSTR szBuffer]
//              [LPVOID *ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    11-Jan-96   t-ptam     Created.
//
//----------------------------------------------------------------------------

HRESULT
GetObject(
    LPWSTR szBuffer,
    LPVOID * ppObject
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);
    HRESULT hr = S_OK;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = ValidateProvider(pObjectInfo);
    BAIL_ON_FAILURE(hr);

    if (pObjectInfo->NumComponents >= 1) {

        hr = NWApiLoginToServer(pObjectInfo->ComponentArray[0],
                 NULL,
                 NULL) ;
        BAIL_ON_FAILURE(hr);
    }

    switch (pObjectInfo->ObjectType) {
    case TOKEN_COMPUTER:
        hr = GetComputerObject(pObjectInfo, ppObject);
        break;

    case TOKEN_USER:
        hr = GetUserObject(pObjectInfo, ppObject);
        break;

    case TOKEN_GROUP:
        hr = GetGroupObject(pObjectInfo, ppObject);
        break;

    case TOKEN_SCHEMA:
        hr = GetSchemaObject(pObjectInfo, ppObject);
        break;

    case TOKEN_CLASS:
        hr = GetClassObject(pObjectInfo, ppObject);
        break;

    case TOKEN_PROPERTY:
        hr = GetPropertyObject(pObjectInfo, ppObject);
        break;

    case TOKEN_SYNTAX:
        hr = GetSyntaxObject(pObjectInfo, ppObject);
        break;

    case TOKEN_FILESERVICE:
        hr = GetFileServiceObject(pObjectInfo, ppObject);
        break;

    case TOKEN_FILESHARE:
        hr = GetFileShareObject(pObjectInfo, ppObject);
        break;

    case TOKEN_PRINTER:
        hr = GetPrinterObject(pObjectInfo, ppObject);
        break;

    default:
        hr = HeuristicGetObject(pObjectInfo, ppObject);
        break;
    }

error:

    FreeObjectInfo( &ObjectInfo, TRUE );
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HeuristicGetObject
//
// Synopsis:   Get object of yet undetermined type.
//
// Arguments:  [POBJECTINFO pObjectInfo]
//             [LPVOID *ppObject]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    11-Jan-96   t-ptam     Created.
//
//----------------------------------------------------------------------------

HRESULT
HeuristicGetObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;

    //
    // Case 0: No componenet - Namespace object.
    //

    if (pObjectInfo->NumComponents == 0) {
        RRETURN(GetNamespaceObject(pObjectInfo, ppObject));
    }

    //
    // Case 1: Single component - Computer object.
    //

    if (pObjectInfo->NumComponents == 1) {

        RRETURN(GetComputerObject(pObjectInfo, ppObject));
    }

    //
    // Case 2: Two components - FileService object
    //                          Group object
    //                          Schema object
    //                          User object
    //                          Printer object
    //

    if (pObjectInfo->NumComponents == 2) {

        hr = GetSchemaObject(pObjectInfo, ppObject);

        if (FAILED(hr)) {

            hr = GetUserObject(pObjectInfo, ppObject);

            if (FAILED(hr)) {

                hr = GetGroupObject(pObjectInfo, ppObject);

                if (FAILED(hr)) {

                    hr = GetFileServiceObject(pObjectInfo, ppObject);

                    if (FAILED(hr)) {

                        hr = GetPrinterObject(pObjectInfo, ppObject);
                    }
                }
            }
        }

        if (FAILED(hr)) {
           hr = E_ADS_UNKNOWN_OBJECT;
        }
        else {
           RRETURN(S_OK);
        }
    }

    //
    // Case 3: Three components - FileShare object
    //                            Schema Class object
    //                            Schema FunctionSet object
    //                            Schema Syntax object
    //

    if (pObjectInfo->NumComponents == 3) {

        hr = GetFileShareObject(pObjectInfo, ppObject);

        if (FAILED(hr)) {

            if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) == 0 ){

                hr = GetClassObject(pObjectInfo, ppObject);

                if (FAILED(hr)) {
                    hr = GetPropertyObject(pObjectInfo, ppObject);
                }

                if (FAILED(hr)) {

                    hr = GetSyntaxObject(pObjectInfo, ppObject);
                }
            }
        }

        if (FAILED(hr)) {
           hr = E_ADS_UNKNOWN_OBJECT;
        }
        else {
           RRETURN(S_OK);
        }
    }

    //
    // Case 4: Four components - Schema FunctionSetAlias object
    //                           Schema Property object
    //

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetNamespaceObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    04-Mar-96   t-ptam     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetNamespaceObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ValidateNamespaceObject(
             pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    hr = CoCreateInstance(
             CLSID_NWCOMPATNamespace,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IUnknown,
             (void **)ppObject
             );

    RRETURN(hr);

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetComputerObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    11-Jan-96   t-ptam     Created.
//
//----------------------------------------------------------------------------

HRESULT
GetComputerObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidateComputerObject(
             pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATComputer::CreateComputer(
             ADsParent,
             pObjectInfo->ComponentArray[0],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetUserObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    29-Feb-96   t-ptam     Created.
//
//----------------------------------------------------------------------------

HRESULT
GetUserObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidateUserObject(
             pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATUser::CreateUser(
             ADsParent,
             NWCOMPAT_COMPUTER_ID,
             pObjectInfo->ComponentArray[0],
             pObjectInfo->ComponentArray[1],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetGroupObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    29-Feb-96   t-ptam     Created.
//
//----------------------------------------------------------------------------

HRESULT
GetGroupObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidateGroupObject(
             pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATGroup::CreateGroup(
             ADsParent,
             NWCOMPAT_COMPUTER_ID,
             pObjectInfo->ComponentArray[0],
             pObjectInfo->ComponentArray[1],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetSchemaObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetSchemaObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;

    if (pObjectInfo->NumComponents != 2)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATSchema::CreateSchema(
             ADsParent,
             pObjectInfo->ComponentArray[1],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             (void **)&pUnknown
             );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetClassObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetClassObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    DWORD i;

    if (pObjectInfo->NumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Look for the given class name
    //

    for ( i = 0; i < g_cNWCOMPATClasses; i++ )
    {
         if ( _wcsicmp( g_aNWCOMPATClasses[i].bstrName,
                        pObjectInfo->ComponentArray[2] ) == 0 )
             break;
    }

    if ( i == g_cNWCOMPATClasses )
    {
        //
        // Class name not found, return error
        //

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Class name found, create and return the object
    //

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATClass::CreateClass(
             ADsParent,
             &g_aNWCOMPATClasses[i],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             (void **)&pUnknown
             );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetSyntaxObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetSyntaxObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    DWORD i;

    if (pObjectInfo->NumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Look for the given syntax name
    //

    for ( i = 0; i < g_cNWCOMPATSyntax; i++ )
    {
         if ( _wcsicmp( g_aNWCOMPATSyntax[i].bstrName,
                        pObjectInfo->ComponentArray[2] ) == 0 )
             break;
    }

    if ( i == g_cNWCOMPATSyntax )
    {
        //
        // Syntax name not found, return error
        //

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Syntax name found, create and return the object
    //

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATSyntax::CreateSyntax(
             ADsParent,
             &g_aNWCOMPATSyntax[i],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             (void **)&pUnknown
             );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetPropertyObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetPropertyObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    WCHAR ADsGrandParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    DWORD nClass, nProp;

    if (pObjectInfo->NumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We found the specified functional set, now see if we can locate
    // the given property name
    //

    for ( nProp = 0; nProp < g_cNWCOMPATProperties; nProp++ )
    {
         if ( _wcsicmp(g_aNWCOMPATProperties[nProp].szPropertyName,
                        pObjectInfo->ComponentArray[2] ) == 0 )
             break;
    }

    if ( nProp == g_cNWCOMPATProperties )
    {
        // Return error because the given property name is not found

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Property name is found, so create and return the object
    //

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = BuildGrandParent(pObjectInfo, ADsGrandParent);
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATProperty::CreateProperty(
             ADsParent,
             &(g_aNWCOMPATProperties[nProp]),
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             (void **)&pUnknown
             );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetFileServiceObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    22-Apr-96   t-ptam     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetFileServiceObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidateFileServiceObject(
             pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATFileService::CreateFileService(
             ADsParent,
             pObjectInfo->ComponentArray[0],
             pObjectInfo->ComponentArray[1],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetFileShareObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    22-Apr-96   t-ptam     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetFileShareObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidateFileShareObject(
             pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATFileShare::CreateFileShare(
             ADsParent,
             pObjectInfo->ComponentArray[2],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetPrinterObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    2-May-96   t-ptam     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetPrinterObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidatePrinterObject(
             pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATPrintQueue::CreatePrintQueue(
             ADsParent,
             pObjectInfo->ComponentArray[1],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidateNamespaceObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    16-Jan-96   t-ptam (Patrick)     Created.
//
//----------------------------------------------------------------------------
HRESULT
ValidateNamespaceObject(
    POBJECTINFO pObjectInfo
    )
{

    if (!_wcsicmp(pObjectInfo->ProviderName, bstrProviderName)) {
    }
    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   ValidateComputerObject
//
// Synopsis:   Validate the existence of a computer object by obtaining
//             a handle to it.  A computer object must exist if a handle
//             to it can be obtained.
//
// Arguments:  [LPWSTR szComputerName]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    16-Jan-96   t-ptam (Patrick)     Created.
//
//----------------------------------------------------------------------------

HRESULT
ValidateComputerObject(
     POBJECTINFO pObjectInfo
     )
{
    //
    // A handle of a certain bindery can only be obtained if the bindery
    // exist.  Therefore we used this fact to validate the existence of
    // a computer object.
    //

    NWCONN_HANDLE hConn = NULL;
    HRESULT hr = S_OK;

    if (pObjectInfo->NumComponents != 1) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Try to obtain a handle to a NWCOMPAT Server.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Detach handle.
    //

    hr = NWApiReleaseBinderyHandle(
             hConn
             );

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidateUserObject
//
// Synopsis:   Validate the existence of a computer object by obtaining
//             a handle to it.  A computer object must exist if a handle
//             to it can be obtained.
//
// Arguments:  [LPWSTR szComputerName]
//
// Returns:    HRESULT
//
// Modifies:   pObjectInfo->ComponentArray[1] is upper-cased
//
// History:    29-Feb-96   t-ptam (Patrick)     Created.
//             29-Jul-96   t-danal              Uppercase fix.
//
// Note:       Netware will let you create a lowercase user name but will
//             internally store only uppercase.  However, it will not
//             return the uppercase user name on a lowercase request.
//
//----------------------------------------------------------------------------

HRESULT
ValidateUserObject(
     POBJECTINFO pObjectInfo
     )
{
    NWCONN_HANDLE hConn = NULL;
    HRESULT hr = S_OK;
    DWORD dwResumeObjectID = 0xffffffff;

    if (pObjectInfo->NumComponents != 2) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Obtain a handle to a NetWare Server.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get the specified (uppercased) user object.
    //

    hr = NWApiValidateObject(
             hConn,
             OT_USER,
             _wcsupr(pObjectInfo->ComponentArray[1]),
             &dwResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

error:
    if (hConn) {
        NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidateGroupObject
//
// Synopsis:   Validate the existence of a group object by scanning
//             for it in the bindery.
//
// Arguments:  [POBJECTINFO pObjectInfo]
//
// Returns:    HRESULT
//
// Modifies:   pObjectInfo->ComponentArray[1] is upper-cased
//
// History:    29-Feb-96   t-ptam (Patrick)     Created.
//             29-Jul-96   t-danal              Uppercase fix.
//
// Note:       Netware will let you create a lowercase user name but will
//             internally store only uppercase.  However, it will not
//             return the uppercase user name on a lowercase request.
//
//----------------------------------------------------------------------------

HRESULT
ValidateGroupObject(
     POBJECTINFO pObjectInfo
     )
{
    NWCONN_HANDLE hConn = NULL;
    HRESULT hr = S_OK;
    DWORD dwResumeObjectID = 0xffffffff;

    if (pObjectInfo->NumComponents != 2) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Obtain a handle to a NetWare Server.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get the specified (uppercased) group object.
    //

    hr = NWApiValidateObject(
             hConn,
             OT_USER_GROUP,
             _wcsupr(pObjectInfo->ComponentArray[1]),
             &dwResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

error:
    if (hConn) {
        NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidateFileServiceObject
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    22-Apr-96   t-ptam (Patrick)     Created.
//
//----------------------------------------------------------------------------
HRESULT
ValidateFileServiceObject(
    POBJECTINFO pObjectInfo
    )
{
    //
    // In NetWare, a FileService object represents a bindery, which is also
    // represented as a computer object.  Therefore validation of file service
    // object can be done the same way as the computer object.
    //

    //
    // A handle of a certain bindery can only be obtained if the bindery exist.
    // Therefore we used this fact to validate the existence of a computer
    // object.
    //

    NWCONN_HANDLE hConn = NULL;
    HRESULT hr = S_OK;

    if (pObjectInfo->NumComponents != 2) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Check for valid NetWare File Server name.
    //

    if (_wcsicmp(pObjectInfo->ComponentArray[1], bstrNWFileServiceName)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Try to obtain a handle to a NWCOMPAT Server.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Detach handle.
    //

    hr = NWApiReleaseBinderyHandle(
             hConn
             );

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidateFileShareObject
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    29-Apr-96   t-ptam (Patrick)     Created.
//
//----------------------------------------------------------------------------
HRESULT
ValidateFileShareObject(
     POBJECTINFO pObjectInfo
     )
{
    HRESULT hr = S_OK;
    DWORD dwResumeObjectID = 0xffffffff;
    NWCONN_HANDLE hConn = NULL;
    NWVOL_NUM VolumeNumber = 0;

    if (pObjectInfo->NumComponents != 3) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Obtain a handle to a NetWare Server.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Try to get the Volume ID that correspond to the Volume name.  If it
    // succeeds, the FileShare is valid.
    //

    hr = NWApiGetVolumeNumber(
             hConn,
             pObjectInfo->ComponentArray[2],
             &VolumeNumber
             );
    BAIL_ON_FAILURE(hr);

error:
    if (hConn) {
        NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidatePrinterObject
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    2-May-96   t-ptam (Patrick)     Created.
//
//----------------------------------------------------------------------------
HRESULT
ValidatePrinterObject(
     POBJECTINFO pObjectInfo
     )
{
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    WCHAR szUncName[MAX_PATH];

    if (pObjectInfo->NumComponents != 2) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Build UNC name from ObjectInfo.
    //

    wsprintf(
        szUncName,
        L"\\\\%s\\%s",
        pObjectInfo->ComponentArray[0],
        pObjectInfo->ComponentArray[1]
        );

    //
    // Get a handle of the printer.
    //

    hr = NWApiOpenPrinter(
             szUncName,
             &hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Release it.
    //

    hr = NWApiClosePrinter(
             hPrinter
             );
error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   BuildParent
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//             [LPWSTR szBuffer]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------

HRESULT
BuildParent(
    POBJECTINFO pObjectInfo,
    LPWSTR szBuffer
    )
{
    DWORD i = 0;


    if (!pObjectInfo->ProviderName) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    wsprintf(szBuffer,L"%s:", pObjectInfo->ProviderName);

    if (pObjectInfo->NumComponents - 1) {

        wcscat(szBuffer, L"//");
        wcscat(szBuffer, pObjectInfo->DisplayComponentArray[0]);

        for (i = 1; i < (pObjectInfo->NumComponents - 1); i++) {
            wcscat(szBuffer, L"/");
            wcscat(szBuffer, pObjectInfo->DisplayComponentArray[i]);
        }
    }
    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   BuildGrandParent
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//             [LPWSTR szBuffer]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------

HRESULT
BuildGrandParent(POBJECTINFO pObjectInfo, LPWSTR szBuffer)
{
    DWORD i = 0;

    if (!pObjectInfo->ProviderName) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    wsprintf(szBuffer,L"%s:", pObjectInfo->ProviderName);

    if (pObjectInfo->NumComponents - 2) {

        wcscat(szBuffer, L"//");
        wcscat(szBuffer, pObjectInfo->DisplayComponentArray[0]);

        for (i = 1; i < (pObjectInfo->NumComponents - 2); i++) {
            wcscat(szBuffer, L"/");
            wcscat(szBuffer, pObjectInfo->DisplayComponentArray[i]);
        }
    }

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   BuildADsPath
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//             [LPWSTR szBuffer]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------

HRESULT
BuildADsPath(
    POBJECTINFO pObjectInfo,
    LPWSTR szBuffer
    )
{
    DWORD i = 0;

    if (!pObjectInfo->ProviderName) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    wsprintf(szBuffer,L"%s:", pObjectInfo->ProviderName);

    if (pObjectInfo->NumComponents) {


        wcscat(szBuffer, L"//");
        wcscat(szBuffer, pObjectInfo->DisplayComponentArray[0]);

        for (i = 1; i < (pObjectInfo->NumComponents); i++) {
            wcscat(szBuffer, L"/");
            wcscat(szBuffer, pObjectInfo->DisplayComponentArray[i]);
        }
    }
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\nwcmacro.h ===
#include "nwapi32.h"

//
// Return Code macro
//
#define NWCCODE_FAILED(Status) ((NWCCODE)(Status) != SUCCESSFUL)

#define NWCCODE_SUCCESS(Status) ((NWCCODE)(Status) == SUCCESSFUL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for oleds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//              09-Jan-96   PatrickT   Migrated to the Netware 3.12 Provider.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


HINSTANCE          g_hInst = NULL;
PNW_CACHED_SERVER  pNwCachedServers = NULL ;
WCHAR             *szNWCOMPATPrefix = L"@NWCOMPAT!";

//
// 3rd party extension
//
extern PCLASS_ENTRY gpClassHead;
extern CRITICAL_SECTION g_ExtCritSect;
extern CRITICAL_SECTION g_TypeInfoCritSect;
//
// Disabled to avoid link warnings.
// extern CRITICAL_SECTION g_DispTypeInfoCritSect;
//

//
// login to server (in win{95,nt}\nw3login.cxx)
//
extern CRITICAL_SECTION g_csLoginCritSect;


//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     AllocArenaDump( NULL );
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    WCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(L"NWCOMPAT",L"heapInfoLevel", L"00000003", awcs,MAXINFOLEN))
        heapInfoLevel = wcstoul(awcs, NULL, 16);

    if (GetProfileString(L"NWCOMPAT",L"Ot", L"00000003", awcs, MAXINFOLEN))
        OtInfoLevel = wcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(L"NWCOMPAT",L"ADsInfoLevel", L"00000003", awcs,MAXINFOLEN))
        ADsInfoLevel = wcstoul(awcs, NULL, 16);
#endif
}

//  Globals


ULONG  g_ulObjCount = 0;  // Number of objects alive in oleds.dll


//+------------------------------------------------------------------------
//
//  Macro that calculates the number of elements in a statically-defined
//  array.
//
//  Note - I swiped this from ADsary.cxx - A type-safe array class. Remember
//  to swipe the whole thing as required.
//-------------------------------------------------------------------------
#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))

CNWCOMPATProviderCF g_cfProvider;
CNWCOMPATNamespaceCF g_cfNamespace;


//+------------------------------------------------------------------------
//
//  oleds class factories
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};



CLSCACHE g_aclscache[] =
{
    &CLSID_NWCOMPATProvider,                        &g_cfProvider,
    &CLSID_NWCOMPATNamespace,                       &g_cfNamespace
};


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    //
    // Add Debugging Code to indicate that the oleds.DllGetClassObject has been
    // called with an unknown CLSID.
    //

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    if (AggregatorDllCanUnload()) {
        hr = S_OK;
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Need to catch case of init crit sect failing.
        //
        __try {

            DisableThreadLibraryCalls(hInst);

            g_hInst = hInst;

#if DBG==1
#ifndef MSVC
            InitializeCriticalSection(&g_csOT);
            InitializeCriticalSection(&g_csMem);
#endif
            InitializeCriticalSection(&g_csDP);
#endif


            InitializeCriticalSection(&g_TypeInfoCritSect);
            InitializeCriticalSection(&g_csLoginCritSect);
            //
            // Disabled to avoid link warnings.
            // InitializeCriticalSection(&g_DispTypeInfoCritSect);
            //

            //
            // for 3rd party extension
            //

            InitializeCriticalSection(&g_ExtCritSect);
            gpClassHead = BuildClassesList();
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Critical failure
            //
            return FALSE;
        }

        break;


    case DLL_PROCESS_DETACH:

        //
        // free global list of class entries for 3rd party ext
        //

        FreeClassesList(gpClassHead);


        while (pNwCachedServers != NULL) {

            PVOID pTmp ;
            LPWSTR pszServer ;

            pTmp = (PVOID) pNwCachedServers ;

            pszServer = pNwCachedServers->pszServerName ;
            NWApiLogoffServer(pszServer) ;
            FreeADsStr(pszServer);

            pNwCachedServers = pNwCachedServers->pNextEntry ;
            FreeADsMem(pTmp);
        }

        //
        // Delete the critical sections
        //
#if DBG==1
#ifndef MSVC
        DeleteCriticalSection(&g_csOT);
        DeleteCriticalSection(&g_csMem);
#endif
        DeleteCriticalSection(&g_csDP);
#endif
        DeleteCriticalSection(&g_TypeInfoCritSect);
        DeleteCriticalSection(&g_csLoginCritSect);
        //
        // Disabled to avoid link warnings.
        // DeleteCriticalSection(&g_DispTypeInfoCritSect);
        //
        DeleteCriticalSection(&g_ExtCritSect);

        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}


//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsidIndex
//
//  Synopsis:   Returns the index of the given CLSID in the cache, or
//              -1 if the CLSID is not present in the cache
//
//  Arguments:  [clsid]
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
GetCachedClsidIndex(REFCLSID clsid)
{
    int             i;
    CLSCACHE *      pclscache;

    for (i = 0, pclscache = g_aclscache;
         i < ARRAY_SIZE(g_aclscache);
         i ++, pclscache++)
    {
        if (IsEqualCLSID(*pclscache->pclsid, clsid))
            return i;
    }

    return -1;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClassFactory
//
//  Synopsis:   Returns the cached class factory with the given index.
//              The pointer returned has been AddRef'd.
//
//  Arguments:  [iclsid]
//
//  Returns:    IClassFactory *
//
//-------------------------------------------------------------------------

IClassFactory *
GetCachedClassFactory(int iclsid)
{
    IClassFactory * pCF;

    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    pCF = g_aclscache[iclsid].pCF;
    pCF->AddRef();

    return pCF;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsid
//
//  Synopsis:   Returns the CLSID corresponding to the given index.
//              Normally, code should call GetCachedClassFactory to get
//              the class factory directly.
//
//  Arguments:  [iclsid]    --  Clsid index
//              [pclsid]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

void
GetCachedClsid(int iclsid, CLSID * pclsid)
{
    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    *pclsid = *g_aclscache[iclsid].pclsid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\grputils.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      grputils.cxx
//
//  Contents:  NetWare compatible GroupCollection Enumeration Code
//
//  History:   22-Mar-96    t-ptam (PatrickT) migrated from KrishnaG for NetWare
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop

COMPUTER_GROUP_MEMBER CompMember;

//
// This assumes that addr is an LPBYTE type.
//

#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((UINT_PTR)addr & ~1))

DWORD ComputerGrpMemberStrings[]=
                             {
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Parent),
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Computer),
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Name),
                             0xFFFFFFFF
                             };

DECLARE_INFOLEVEL(GrpUt)
DECLARE_DEBUG(GrpUt)
#define GrpUtDebugOut(x) GrpUtInlineDebugOut x

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerGroupOpen
//
//  Synopsis: This function opens a handle to a INI_COMP_GROUP structure.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerGroupOpen(
    LPWSTR szComputerName,
    LPWSTR szGroupName,
    PHANDLE phGroup
    )
{
    WCHAR szTempBuffer[MAX_PATH];
    PINI_COMP_GROUP pIniCompGrp;
    HRESULT hr = S_OK;

    if (!phGroup) {
        return(FALSE);
    }

    pIniCompGrp = (PINI_COMP_GROUP)AllocADsMem(
                                       sizeof(INI_COMP_GROUP)
                                       );
    if (!pIniCompGrp) {
        return(FALSE);
    }

    //
    // Fill structure's fields.
    //

    if (!(pIniCompGrp->szComputerName =  AllocADsStr(szComputerName))){
        goto error;
    }

    if (!(pIniCompGrp->szGroupName = AllocADsStr(szGroupName))){
        goto error;
    }

    hr = NWApiGetBinderyHandle(
             &pIniCompGrp->_hConn,
             szComputerName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return
    //

    *phGroup =  (HANDLE)pIniCompGrp;

    return(TRUE);


error:
    if (pIniCompGrp) {
        FreeIniCompGroup(pIniCompGrp);
    }

    *phGroup = NULL;

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerGroupEnum
//
//  Synopsis: This function returns a buffer which contains all the binding
//            informations for the requested number of objects without any
//            references.
//            It returns TRUE iff dwReturned = dwRequested.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerGroupEnum(
    HANDLE hGroup,
    DWORD  dwRequested,
    LPBYTE * ppBuffer,
    PDWORD pdwReturned
    )
{
    LPCOMPUTER_GROUP_MEMBER * ppGroupMembers = NULL;
    DWORD i = 0;
    BOOL dwRet = FALSE;
    DWORD dwReturned = 0;
    DWORD dwSize = 0;
    LPCOMPUTER_GROUP_MEMBER pBuffer = NULL;
    LPBYTE pEnd = NULL;

    //
    // Allocate buffer for the number of requested members.
    //

    ppGroupMembers = (LPCOMPUTER_GROUP_MEMBER *)AllocADsMem(
                                                    sizeof(LPCOMPUTER_GROUP_MEMBER)* dwRequested
                                                    );
    if (!ppGroupMembers) {
        return(FALSE);
    }

    //
    // Fill in ppGroupMembers one by one.
    //

    for (i = 0; i < dwRequested; i++) {

        dwRet = NWCOMPATComputerGroupGetObject(
                    hGroup,
                    &ppGroupMembers[i]
                    );
        if (!dwRet) {
            break;
        }
    }

    if (dwRet) {
        dwReturned = i;

        //
        // Determine actual size of ppGroupMembers[], ie. since each string in
        // COMPUTER_GROUP_MEMBER have a different length, a buffer that is going
        // to contain all the data without any references is unknown.
        //

        dwRet = ComputeComputerGroupDataSize(
                    ppGroupMembers,
                    dwReturned,
                    &dwSize
                    );

        pBuffer = (LPCOMPUTER_GROUP_MEMBER)AllocADsMem(
                                               dwSize
                                               );
        if (!pBuffer) {
            goto error;
        }

        pEnd = (LPBYTE)((LPBYTE)(pBuffer) + dwSize);

        //
        // Put data into pBuffer, starting from the end.
        //

        for (i = 0; i < dwReturned; i++) {

            pEnd = CopyIniCompGroupToCompGroup(
                       ppGroupMembers[i],
                       (LPBYTE)(pBuffer + i),
                       pEnd
                       );
        }

        //
        // Clean up.
        //

        for (i = 0; i < dwReturned; i++ ) {
            FreeIntCompGroup(*(ppGroupMembers + i));
        }

        //
        // Return values.
        //

        *ppBuffer = (LPBYTE)pBuffer;
        *pdwReturned  = dwReturned;
    }

    FreeADsMem(ppGroupMembers);

    if (dwReturned == dwRequested){
        return(TRUE);
    }else {
        return(FALSE);
    }

error:
    
    for (i = 0; i < dwReturned; i++ ) {
        FreeIntCompGroup(*(ppGroupMembers + i));
    }
    
    FreeADsMem(ppGroupMembers);
    
    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerGroupGetObject
//
//  Synopsis: This function returns binding information of a user (group member)
//            object one by one.  In its first call, it builds a buffer that
//            contains all the UserID of the group members.  Then, and in
//            subsequent calls, this UserID is translated into a user name.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerGroupGetObject(
    HANDLE hGroup,
    LPCOMPUTER_GROUP_MEMBER * ppGroupMember
    )
{
    BOOL            dwRet = FALSE;
    DWORD           dwUserID = 0;
    HRESULT         hr = S_OK;
    PINI_COMP_GROUP pIniCompGrp = (PINI_COMP_GROUP)hGroup;

    //
    // Fill buffer with User ID.  NetWare returns all UserID in one call.
    //

    if (!pIniCompGrp->_pBuffer) {

        pIniCompGrp->_dwCurrentObject = 0;

        hr = NWApiGroupGetMembers(
                 pIniCompGrp->_hConn,
                 pIniCompGrp->szGroupName,
                 &(pIniCompGrp->_pBuffer)
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Build one group member.
    //

    dwUserID = *((LPDWORD)pIniCompGrp->_pBuffer + pIniCompGrp->_dwCurrentObject);

    if (dwUserID != 0x0000) {

        dwRet = BuildComputerGroupMember(
                    hGroup,
                    dwUserID,
                    ppGroupMember
                    );
        if (!dwRet) {
            goto error;
        }

        pIniCompGrp->_dwCurrentObject++;

        return(TRUE);
    }

error:

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerGroupClose
//
//  Synopsis: Wrapper of FreeIniCompGroup.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerGroupClose(
    HANDLE hGroup
    )
{
    PINI_COMP_GROUP pIniCompGrp = (PINI_COMP_GROUP)hGroup;

    if (pIniCompGrp) {
        FreeIniCompGroup(pIniCompGrp);
    }
    return(TRUE);
}

//----------------------------------------------------------------------------
//
//  Function: FreeIniCompGroup
//
//  Synopsis: Free an INI_COMP_GROUP structure.
//
//----------------------------------------------------------------------------
void
FreeIniCompGroup(
    PINI_COMP_GROUP pIniCompGrp
    )
{
    HRESULT hr = S_OK;

    if (pIniCompGrp) {

        if (pIniCompGrp->szComputerName) {
            FreeADsStr(pIniCompGrp->szComputerName);
        }

        if (pIniCompGrp->szGroupName) {
            FreeADsStr(pIniCompGrp->szGroupName);
        }

        if (pIniCompGrp->_pBuffer) {
            FreeADsMem(pIniCompGrp->_pBuffer);
        }

        if (pIniCompGrp->_hConn) {
            hr = NWApiReleaseBinderyHandle(pIniCompGrp->_hConn);
        }

        FreeADsMem(pIniCompGrp);
    }

    return;
}

//----------------------------------------------------------------------------
//
//  Function: FreeIntCompGroup
//
//  Synopsis: Free a COMPUTER_GROUP_MEMBER structure.
//
//----------------------------------------------------------------------------
void
FreeIntCompGroup(
    LPCOMPUTER_GROUP_MEMBER pCompGroupMember
    )
{
    if (pCompGroupMember) {

        if (pCompGroupMember->Parent) {
            FreeADsStr(pCompGroupMember->Parent);
        }

        if (pCompGroupMember->Computer) {
            FreeADsStr(pCompGroupMember->Computer);
        }

        if (pCompGroupMember->Name) {
            FreeADsStr(pCompGroupMember->Name);
        }

        FreeADsMem(pCompGroupMember);
    }

    return;
}

//----------------------------------------------------------------------------
//
//  Function: ComputeComputerGroupDataSize
//
//  Synopsis: Calculate the size of a buffer that is going to store the data in
//            ppGroupMembers without any references.
//
//----------------------------------------------------------------------------
BOOL
ComputeComputerGroupDataSize(
        LPCOMPUTER_GROUP_MEMBER * ppGroupMembers,
        DWORD  dwReturned,
        PDWORD pdwSize
        )
{

    DWORD i = 0;
    DWORD cb = 0;
    LPCOMPUTER_GROUP_MEMBER pMember = NULL;

    for (i = 0; i < dwReturned; i++) {

        pMember = *(ppGroupMembers + i);

        cb += sizeof(COMPUTER_GROUP_MEMBER);

        if (pMember->Parent) {
            cb += wcslen(pMember->Parent)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Computer) {
            cb += wcslen(pMember->Computer)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Name) {
            cb += wcslen(pMember->Name)*sizeof(WCHAR) + sizeof(WCHAR);
        }
    }

    *pdwSize = cb;
    return(TRUE);
}

//------------------------------------------------------------------------------
//
//  Function: CopyIniCompGroupToCompGroup
//
//  Synopsis: Pack referenced data (string) into a buffer without any reference.
//
//------------------------------------------------------------------------------
LPBYTE
CopyIniCompGroupToCompGroup(
    LPCOMPUTER_GROUP_MEMBER  pIntCompGrp,
    LPBYTE  pExtCompGrp,
    LPBYTE  pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(COMPUTER_GROUP_MEMBER)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings =  SourceStrings;
    LPCOMPUTER_GROUP_MEMBER pCompGrpMember = (LPCOMPUTER_GROUP_MEMBER)pExtCompGrp;

    memset(SourceStrings, 0, sizeof(COMPUTER_GROUP_MEMBER));
    *pSourceStrings++ = pIntCompGrp->Parent;
    *pSourceStrings++ = pIntCompGrp->Computer;
    *pSourceStrings++ = pIntCompGrp->Name;

    pEnd = PackStrings(
                SourceStrings,
                pExtCompGrp,
                ComputerGrpMemberStrings,
                pEnd
                );

    pCompGrpMember->Type = pIntCompGrp->Type;

    return pEnd;
}

//----------------------------------------------------------------------------
//
//  Function: BuildComputerGroupMember
//
//  Synopsis: Put binding information of a group member into ppGroupMember.
//
//----------------------------------------------------------------------------
BOOL
BuildComputerGroupMember(
    HANDLE hGroup,
    DWORD  dwUserID,
    LPCOMPUTER_GROUP_MEMBER * ppGroupMember
    )
{
    DWORD                   dwTempUserID = dwUserID;
    HRESULT                 hr = S_OK;
    LPCOMPUTER_GROUP_MEMBER pGroupMember = NULL;
    LPINI_COMP_GROUP        pGroup = (LPINI_COMP_GROUP)hGroup;
    WCHAR                   szADsParent[MAX_PATH];

    //
    // Allocate one COMPUTER_GROUP_MEMBER.
    //

    pGroupMember = (LPCOMPUTER_GROUP_MEMBER)AllocADsMem(
                                                sizeof(COMPUTER_GROUP_MEMBER)
                                                );
    if (!pGroupMember) {
        return(FALSE);
    }

    //
    // Fill structure's fields.
    //

    pGroupMember->Type = NWCOMPAT_USER_ID;

    wsprintf(
        szADsParent,
        L"%s://%s",
        szProviderName,
        pGroup->szComputerName
        );
    pGroupMember->Parent = AllocADsStr(szADsParent);

    pGroupMember->Computer = AllocADsStr(pGroup->szComputerName);

    hr = NWApiGetObjectName(
             pGroup->_hConn,
             dwTempUserID,
             &pGroupMember->Name
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    *ppGroupMember = pGroupMember;
    return(TRUE);

error:

    if (pGroupMember) {

        if (pGroupMember->Parent)
            FreeADsStr(pGroupMember->Parent);

        if (pGroupMember->Computer)
            FreeADsStr(pGroupMember->Computer);

        FreeADsMem(pGroupMember);
    }

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: PackStrings
//
//  Synopsis:
//
//----------------------------------------------------------------------------
LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD *DestOffsets,
    LPBYTE pEnd
    )
{
    DWORD cbStr;
    WORD_ALIGN_DOWN(pEnd);

    while (*DestOffsets != -1) {
        if (*pSource) {
            cbStr = wcslen(*pSource)*sizeof(WCHAR) + sizeof(WCHAR);
            pEnd -= cbStr;
            CopyMemory( pEnd, *pSource, cbStr);
            *(LPWSTR *)(pDest+*DestOffsets) = (LPWSTR)pEnd;
        } else {
            *(LPWSTR *)(pDest+*DestOffsets)=0;
        }
        pSource++;
        DestOffsets++;
    }
    return pEnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\macro.h ===
//
// This is a macro which is ONLY used in CNWCOMPATUser::SetAccountRestrictions.
//

#define GET_LOGIN_CONTROL()             \
        if (fUmOK == FALSE) {           \
                                        \
            hr = NWApiGetLOGIN_CONTROL( \
                     hConn,             \
                     _Name,             \
                     &LoginCtrl         \
                     );                 \
            BAIL_ON_FAILURE(hr);        \
                                        \
            fUmOK = TRUE;               \
        }

//
// NCP Reply buffer macro.
//

#define INIT_RPLY_SGMT(RS)          \
        RS## = new RPLY_SGMT_LST;   \
        if (!##RS##) {              \
            RRETURN(E_OUTOFMEMORY); \
        }                           \
        RS##->lpNext = NULL;

#define DELETE_LIST(ptr)                    \
        if (##ptr##) {                      \
            do {                            \
                lpTemp = (##ptr##)->lpNext; \
                delete (##ptr##);           \
                (##ptr##) = lpTemp;         \
            } while (##ptr##);              \
        }

//
// Misc Macro.
//

#define ADSFREESTRING(str)          \
        if (##str##) {                \
            ADsFreeString(##str##); \
        }

//
// Error flow control macro.
//

#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);

#define BAIL_IF_ERROR(hr)     \
        if (FAILED(hr)) {     \
                goto cleanup; \
        }                     \

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {   \
                goto error; \
        }                   \

//
// DEFINE_IDispatch_Implementation_Unimplemented
//

#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                               \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)           \
{                                                          \
    RRETURN(E_NOTIMPL);                                    \
}                                                          \
                                                           \
STDMETHODIMP                                               \
cls::GetTypeInfo(                                          \
         unsigned int itinfo,                              \
         LCID lcid,                                        \
         ITypeInfo FAR* FAR* pptinfo                       \
         )                                                 \
{                                                          \
    RRETURN(E_NOTIMPL);                                    \
}                                                          \
                                                           \
STDMETHODIMP                                               \
cls::GetIDsOfNames(                                        \
         REFIID iid,                                       \
         LPWSTR FAR* rgszNames,                            \
         unsigned int cNames,                              \
         LCID lcid,                                        \
         DISPID FAR* rgdispid                              \
         )                                                 \
{                                                          \
    RRETURN(E_NOTIMPL);                                    \
}                                                          \
                                                           \
STDMETHODIMP                                               \
cls::Invoke(                                               \
         DISPID dispidMember,                              \
         REFIID iid, LCID lcid,                            \
         unsigned short wFlags,                            \
         DISPPARAMS FAR* pdispparams,                      \
         VARIANT FAR* pvarResult,                          \
         EXCEPINFO FAR* pexcepinfo,                        \
         unsigned int FAR* puArgErr                        \
         )                                                 \
{                                                          \
    RRETURN(E_NOTIMPL);                                    \
}

//
// DEFINE_IDispatch_Implementation
//

#define DEFINE_IDispatch_Implementation(cls)       \
STDMETHODIMP                                       \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)   \
{                                                  \
    RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo)); \
}                                                  \
                                                   \
STDMETHODIMP                                       \
cls::GetTypeInfo(                                  \
         unsigned int itinfo,                      \
         LCID lcid,                                \
         ITypeInfo FAR* FAR* pptinfo)              \
{                                                  \
    RRETURN(_pDispMgr->GetTypeInfo(                \
                           itinfo,                 \
                           lcid,                   \
                           pptinfo                 \
                           ));                     \
}                                                  \
                                                   \
STDMETHODIMP                                       \
cls::GetIDsOfNames(                                \
         REFIID iid,                               \
         LPWSTR FAR* rgszNames,                    \
         unsigned int cNames,                      \
         LCID lcid,                                \
         DISPID FAR* rgdispid                      \
         )                                         \
{                                                  \
    RRETURN(_pDispMgr->GetIDsOfNames(              \
                           iid,                    \
                           rgszNames,              \
                           cNames,                 \
                           lcid,                   \
                           rgdispid                \
                           ));                     \
}                                                  \
                                                   \
STDMETHODIMP                                       \
cls::Invoke(                                       \
         DISPID dispidMember,                      \
         REFIID iid,                               \
         LCID lcid,                                \
         unsigned short wFlags,                    \
         DISPPARAMS FAR* pdispparams,              \
         VARIANT FAR* pvarResult,                  \
         EXCEPINFO FAR* pexcepinfo,                \
         unsigned int FAR* puArgErr                \
         )                                         \
{                                                  \
    RRETURN (_pDispMgr->Invoke(                    \
                            dispidMember,          \
                            iid,                   \
                            lcid,                  \
                            wFlags,                \
                            pdispparams,           \
                            pvarResult,            \
                            pexcepinfo,            \
                            puArgErr               \
                            ));                    \
}                                                  \

//
// DEFINE_IADs_Implementation
//

#define DEFINE_IADs_Implementation(cls)  \
STDMETHODIMP                               \
cls::get_Name(THIS_ BSTR FAR* retval)      \
{                                          \
    RRETURN(get_CoreName(retval));         \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_ADsPath(THIS_ BSTR FAR* retval) \
{                                          \
    RRETURN(get_CoreADsPath(retval));    \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Class(THIS_ BSTR FAR* retval)     \
{                                          \
    RRETURN(get_CoreADsClass(retval));   \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Parent(THIS_ BSTR FAR* retval)    \
{                                          \
    RRETURN(get_CoreParent(retval));       \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Schema(THIS_ BSTR FAR* retval)    \
{                                          \
    RRETURN(get_CoreSchema(retval));       \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_GUID(THIS_ BSTR FAR* retval)      \
{                                          \
    RRETURN(get_CoreGUID(retval));         \
}                                          \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(GetInfo());                                               \
}

//
// DEFINE_IADs_Implementation
//

#define DEFINE_IADs_TempImplementation(cls)  \
STDMETHODIMP                               \
cls::get_Name(THIS_ BSTR FAR* retval)      \
{                                          \
    RRETURN(get_CoreName(retval));         \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_ADsPath(THIS_ BSTR FAR* retval) \
{                                          \
    RRETURN(get_CoreADsPath(retval));    \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Class(THIS_ BSTR FAR* retval)     \
{                                          \
    RRETURN(get_CoreADsClass(retval));   \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Parent(THIS_ BSTR FAR* retval)    \
{                                          \
    RRETURN(get_CoreParent(retval));       \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Schema(THIS_ BSTR FAR* retval)    \
{                                          \
    RRETURN(get_CoreSchema(retval));       \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_GUID(THIS_ BSTR FAR* retval)      \
{                                          \
    RRETURN(get_CoreGUID(retval));         \
}                                          \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(GetInfo());                                               \
}










#define DEFINE_IADs_PutGetImplementation(cls, SchemaClassTable, dwTableSize)                   \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericGetPropertyManager(                                   \
                _pPropertyCache,                                      \
                bstrName,                                             \
                pvProp                                                \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericPutPropertyManager(                                   \
                _pPropertyCache,                                      \
                SchemaClassTable,                                     \
                dwTableSize,                                          \
                bstrName,                                             \
                vProp                                                 \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericGetExPropertyManager(                                 \
                GetObjectState(),                                     \
                _pPropertyCache,                                      \
                bstrName,                                             \
                pvProp                                                \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericPutExPropertyManager(                                 \
                _pPropertyCache,                                      \
                SchemaClassTable,                                     \
                dwTableSize,                                          \
                bstrName,                                             \
                vProp                                                 \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}


#define DEFINE_IADsPropertyList_Implementation(cls, SchemaClassTable, dwTableSize)                 \
STDMETHODIMP                                                                                       \
cls::get_PropertyCount(THIS_ long  FAR * plCount)                                                  \
{                                                                                                  \
    HRESULT hr = E_FAIL;                                                                           \
                                                                                                   \
    hr = GenericPropCountPropertyManager(                                                          \
                _pPropertyCache,                                                                   \
                plCount                                                                            \
                );                                                                                 \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::Next(THIS_ VARIANT FAR *pVariant)                                                             \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericNextPropertyManager(                                                               \
                    _pPropertyCache,                                                               \
                    pVariant                                                                       \
                    );                                                                             \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::Skip(THIS_ long cElements)                                                                   \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
                                                                                                   \
    hr = GenericSkipPropertyManager(                                                               \
                    _pPropertyCache,                                                               \
                    cElements                                                                      \
                    );                                                                             \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
                                                                                                   \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::Reset()                                                                                       \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericResetPropertyManager(                                                              \
                _pPropertyCache                                                                    \
                );                                                                                 \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::ResetPropertyItem(THIS_ VARIANT varEntry)                                                    \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericDeletePropertyManager(                                                             \
                    _pPropertyCache,                                                               \
                    varEntry                                                                       \
                    );                                                                             \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::GetPropertyItem(THIS_ BSTR bstrName, LONG lnADsType, VARIANT * pVariant)                      \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericGetPropItemPropertyManager(                                                        \
                _pPropertyCache,                                                                   \
                GetObjectState(),                                                                  \
                bstrName,                                                                          \
                lnADsType,                                                                         \
                pVariant                                                                           \
                );                                                                                 \
                                                                                                   \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
STDMETHODIMP                                                                                       \
cls::PutPropertyItem(THIS_ VARIANT varData)                                                        \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericPutPropItemPropertyManager(                                                        \
                _pPropertyCache,                                                                   \
                SchemaClassTable,                                                                  \
                dwTableSize,                                                                       \
                varData                                                                            \
                );                                                                                 \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::PurgePropertyList(THIS_)                                                                      \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericPurgePropertyManager(                                                              \
                _pPropertyCache                                                                    \
                );                                                                                 \
                                                                                                   \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
STDMETHODIMP                                                                                       \
cls::Item(THIS_ VARIANT varIndex, VARIANT * pVariant)                                              \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericItemPropertyManager(                                                               \
                _pPropertyCache,                                                                   \
                GetObjectState(),                                                                  \
                varIndex,                                                                          \
                pVariant                                                                           \
                );                                                                                 \
                                                                                                   \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   

#define DEFINE_IDispatch_ExtMgr_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pExtMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pExtMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pExtMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pExtMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\object.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  object.cxx
//
//  Contents:
//
//  History:
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma hdrstop

HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    );

HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    );


ObjectTypeList::ObjectTypeList()
{
    _pObjList = NULL;
    _dwCurrentIndex = 0;
    _dwMaxElements = 0;
    _dwUBound  = 0;
    _dwLBound = 0;

}


HRESULT
ObjectTypeList::CreateObjectTypeList(
    VARIANT vFilter,
    ObjectTypeList ** ppObjectTypeList
    )
{
    ObjectTypeList * pObjectTypeList = NULL;
    HRESULT hr = S_OK;

    pObjectTypeList = new ObjectTypeList;

    if (!pObjectTypeList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildObjectArray(
            vFilter,
            &pObjectTypeList->_pObjList,
            &pObjectTypeList->_dwMaxElements
            );

    if (FAILED(hr)) {

        hr = BuildDefaultObjectArray(
                gpFilters,
                gdwMaxFilters,
                &pObjectTypeList->_pObjList,
                &pObjectTypeList->_dwMaxElements
                );

        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetUBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetLBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwLBound
                );
    BAIL_ON_FAILURE(hr);

    pObjectTypeList->_dwCurrentIndex = pObjectTypeList->_dwLBound;

    *ppObjectTypeList = pObjectTypeList;

    RRETURN(S_OK);


error:
    if (pObjectTypeList) {
        delete pObjectTypeList;
    }
    RRETURN(hr);

}


ObjectTypeList::~ObjectTypeList()
{
    HRESULT hr = S_OK;
    if (_pObjList) {
        hr = SafeArrayDestroy(_pObjList);
    }
}


HRESULT
ObjectTypeList::GetCurrentObject(
    PDWORD pdwObject
    )
{
    HRESULT hr = S_OK;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    hr = SafeArrayGetElement(
                    _pObjList,
                    (long FAR *)&_dwCurrentIndex,
                    (void *)pdwObject
                    );
    RRETURN(hr);
}

HRESULT
ObjectTypeList::Next()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex++;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    return(hr);
}



HRESULT
ObjectTypeList::Reset()
{
    HRESULT hr = S_OK;

    return(hr);

}


HRESULT
IsValidFilter(
    LPWSTR ObjectName,
    DWORD *pdwFilterId,
    PFILTERS pFilters,
    DWORD dwMaxFilters
    )
{

    DWORD i = 0;

    for (i = 0; i < dwMaxFilters; i++) {

        if (!_wcsicmp(ObjectName, (pFilters + i)->szObjectName)) {
            *pdwFilterId = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }

    }
    *pdwFilterId = 0;
    RRETURN(E_FAIL);
}



HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    DWORD i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;

    sabNewArray.cElements = dwMaxFilters;
    sabNewArray.lLbound =  0;

    pFilter =   SafeArrayCreate(
                        VT_I4,
                        1,
                        &sabNewArray
                        );
    if (!pFilter){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwMaxFilters; i++) {

        hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&((pFilters + i)->dwFilterId)
            );
        BAIL_ON_FAILURE(hr);
    }

    *ppFilter = pFilter;
    *pdwNumElements = dwMaxFilters;

    RRETURN(S_OK);

error:
    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}



HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    VARIANT varDest;
    LONG i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    DWORD dwFilterId;
    SAFEARRAY * pFilter = NULL;

    if (!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    sabNewArray.cElements = dwSUBound - dwSLBound + 1;
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_I4,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }


        hr = IsValidFilter(
                V_BSTR(&v),
                &dwFilterId,
                gpFilters,
                gdwMaxFilters
                );

        if (FAILED(hr)) {

            VariantClear(&v);
            continue;
        }

        VariantClear(&v);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&uDestCount,
                (void *)&dwFilterId
                );

        if(FAILED(hr)){
            continue;
        }

        uDestCount++;

    }

    //
    // There was nothing of value that could be retrieved from the
    // filter and vFilter do not contain entries, that means no filter is
    // being set. Hence, we return err in this case so that we build the
    // default array.
    //

    if ( !uDestCount && (( dwSUBound - dwSLBound + 1 ) == 0 )) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    *pdwNumElements  = uDestCount;
    *ppFilter = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {

        SafeArrayDestroy(pFilter);
    }
    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\nw2ods.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nw2ods.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma  hdrstop



HRESULT
NTTypeToAdsTypeCopyString(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )

{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNtSrcObject->NTValue.pszValue
                                );
    if ((!lpAdsDestValue->DNString) &&
        (lpNtSrcObject->NTValue.pszValue)) {
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(hr);
}



HRESULT
NTTypeToAdsTypeCopyBoolean(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    lpAdsDestValue->Boolean =
                        lpNtSrcObject->NTValue.fValue;

    RRETURN(hr);
}


HRESULT
NTTypeToAdsTypeCopyInteger(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                        lpNtSrcObject->NTValue.dwValue;

    RRETURN(hr);

}


HRESULT
NTTypeToAdsTypeCopy(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    switch (lpNtSrcObject->NTType) {

    case NT_SYNTAX_ID_BOOL:
        hr = NTTypeToAdsTypeCopyBoolean(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_DWORD:
        hr = NTTypeToAdsTypeCopyInteger(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = NTTypeToAdsTypeCopyString(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;
    /*
    case NT_SYNTAX_ID_SYSTEMTIME:
    case NT_SYNTAX_ID_DATE:
    case NT_SYNTAX_ID_NW312TIME:
        hr = NTTypeToAdsTypeCopyNDSSynId4(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = NTTypeToAdsTypeCopyNDSSynId5(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_DelimitedString:
        hr = NTTypeToAdsTypeCopyNDSSynId6(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;
    */

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
NTTypeToAdsTypeCopyConstruct(
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumObjects,
    LPADSVALUE * ppAdsDestValues
    )
{

    DWORD i = 0;
    LPADSVALUE pAdsDestValues = NULL;
    HRESULT hr = S_OK;

    if (!dwNumObjects) {
        *ppAdsDestValues =0;
        RRETURN(S_OK);
    }

    pAdsDestValues = (LPADSVALUE)AllocADsMem(
                                    dwNumObjects * sizeof(ADSVALUE)
                                    );

    if (!pAdsDestValues) {
        RRETURN(E_OUTOFMEMORY);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = NTTypeToAdsTypeCopy(
                    pNtSrcObjects + i,
                    pAdsDestValues + i
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppAdsDestValues = pAdsDestValues;

     RRETURN(S_OK);

error:

     if (pAdsDestValues) {
        AdsFreeAdsValues(
            pAdsDestValues,
            dwNumObjects
            );
       FreeADsMem(pAdsDestValues); 
     }

     *ppAdsDestValues = NULL;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\nw2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nw2var.cxx
//
//  Contents:   Nw312 Object to Variant Copy Routines
//
//  Functions:
//
//  History:      06/12/96   KrishnaG created.
//                cloned off NDS conversion code.
//
//
//----------------------------------------------------------------------------

//
// NTType objects copy code
//

#include "nwcompat.hxx"
#pragma  hdrstop

void
VarTypeFreeVarObjects(
    PVARIANT pVarObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    if( !pVarObject){
        return;
    }

    for (i = 0; i < dwNumValues; i++ ) {
         VariantClear(pVarObject + i);
    }

    FreeADsMem(pVarObject);

    return;
}


HRESULT
NTTypeToVarTypeCopyBOOL(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_BOOL;

    if((pNTSrcValue->NTValue).fValue){
        lpVarDestObject->boolVal = VARIANT_TRUE;  // notation for TRUE in V_BOOL
    } else {
        lpVarDestObject->boolVal = VARIANT_FALSE;
    }

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopySYSTEMTIME(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

 lpVarDestObject->vt = VT_DATE;

    hr = ConvertSystemTimeToDATE (pNTSrcValue->NTValue.stSystemTimeValue,
                                  &lpVarDestObject->date );


    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyDWORD(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    //
    // we cast the DWORD  to a LONG
    //

    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_I4;

    lpVarDestObject->lVal = (LONG)(pNTSrcValue->NTValue).dwValue;

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyDATE(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{

    HRESULT hr = S_OK;
    SYSTEMTIME stSystemTime;
    SYSTEMTIME LocalTime;
    DATE       date ;
    BOOL       fRetval;

    GetSystemTime( &stSystemTime);

    fRetval = SystemTimeToTzSpecificLocalTime(
                  NULL,
                  &stSystemTime,
                  &LocalTime
                  );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    stSystemTime.wHour = (WORD)(pNTSrcValue->NTValue.dwValue)/60;
    stSystemTime.wMinute = (WORD)(pNTSrcValue->NTValue.dwValue)%60;
    stSystemTime.wSecond =0;
    stSystemTime.wMilliseconds = 0;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_DATE;

    hr = ConvertSystemTimeToDATE (stSystemTime,
                                  &date );
    BAIL_ON_FAILURE(hr);

    lpVarDestObject->date = date - (DWORD)date;

error:

    RRETURN(hr);
}


HRESULT
NTTypeToVarTypeCopyNW312DATE(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{

    HRESULT hr = S_OK;
    SYSTEMTIME stSystemTime;
    SYSTEMTIME LocalTime;
    DATE       date ;
    BOOL       fRetval;


    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_DATE;


    hr = ConvertNW312DateToVariant(
              pNTSrcValue->NTValue.Nw312Date,
              &lpVarDestObject->date
              );
    BAIL_ON_FAILURE(hr);


error:

    RRETURN(hr);
}


HRESULT
NTTypeToVarTypeCopyOctetString(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

	hr = BinaryToVariant(
		(pNTSrcValue->NTValue).octetstring.dwSize,
		(pNTSrcValue->NTValue).octetstring.pByte,
		lpVarDestObject
    );

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyLPTSTR(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_BSTR;

    if(!(pNTSrcValue->NTValue).pszValue){
        lpVarDestObject->bstrVal = NULL;
        hr = S_OK;
        goto error;
    }


    if(!pNTSrcValue){
        lpVarDestObject->bstrVal = NULL;
    } else {
        hr =  ADsAllocString((pNTSrcValue->NTValue).pszValue,
                               &(lpVarDestObject->bstrVal));
    }

error:
    RRETURN(hr);
}



HRESULT
NTTypeToVarTypeCopyDelimitedString(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
   HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    } else {
        hr = DelimitedStringToVariant((pNTSrcValue->NTValue).pszValue,
                                      lpVarDestObject,
                                      TEXT(',') );
    }
    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyNulledString(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!(pNTSrcValue->NTValue).pszValue){
        RRETURN(E_POINTER);
    }

    hr = NulledStringToVariant((pNTSrcValue->NTValue).pszValue,
                               lpVarDestObject );

    RRETURN(hr);
}


HRESULT
NtTypeToVarTypeCopy(
    PNTOBJECT lpNtSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNtSrcObject->NTType) {
    case NT_SYNTAX_ID_BOOL:
        hr = NTTypeToVarTypeCopyBOOL(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = NTTypeToVarTypeCopySYSTEMTIME(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;


    case NT_SYNTAX_ID_DWORD:
        hr = NTTypeToVarTypeCopyDWORD(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = NTTypeToVarTypeCopyDATE(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;


    case NT_SYNTAX_ID_NW312DATE:
        hr = NTTypeToVarTypeCopyNW312DATE(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;


    case NT_SYNTAX_ID_LPTSTR:
        hr = NTTypeToVarTypeCopyLPTSTR(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_DelimitedString:

        hr = NTTypeToVarTypeCopyDelimitedString(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_NulledString :
        hr = NTTypeToVarTypeCopyNulledString(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_OCTETSTRING :
        hr = NTTypeToVarTypeCopyOctetString(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
NtTypeToVarTypeCopyConstruct(
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumObjects,
    PVARIANT pVarDestObjects
    )
{

    long i = 0;
    HRESULT hr = S_OK;

    VariantInit(pVarDestObjects);

    //
    // The following are for handling are multi-value properties
    //

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = dwNumObjects;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) dwNumObjects; i++ )
    {
        VARIANT v;

        VariantInit(&v);
        hr = NtTypeToVarTypeCopy( pNtSrcObjects + i,
                                  &v );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarDestObjects) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\nw3utils.cxx ===
#include "NWCOMPAT.hxx"
#pragma hdrstop

//----------------------------------------------------------------------------
//
//  Function: NWApiGetProperty
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetProperty(
    BSTR bstrObjectName,
    LPSTR lpszPropertyName,
    NWOBJ_TYPE dwOT_ID,
    NWCONN_HANDLE hConn,
    LPP_RPLY_SGMT_LST lppReplySegment,
    LPDWORD pdwNumSegment
    )
{
    CHAR             szObjectName[(OBJ_NAME_SIZE + 1)*2];
    NWFLAGS          pucMoreFlag = 0;
    NWFLAGS          pucPropFlag = 0;
    unsigned char    ucSegment = 1;
    LP_RPLY_SGMT_LST lpHeadReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTempReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL;
    HRESULT          hr = S_OK;
    NWCCODE          usRet = 0;

    //
    // lppReplySegment is assumed to be NULL.
    //

    ADsAssert((*lppReplySegment) == NULL);

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    
    if (wcslen(bstrObjectName) > OBJ_NAME_SIZE) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    UnicodeToAnsiString(
        bstrObjectName,
        szObjectName,
        0
        );

    //
    // Initialize first node of the list and set up temp traversal pointer.
    //

    INIT_RPLY_SGMT(lpTempReplySegment);
    lpHeadReplySegment = lpTempReplySegment;

    //
    // Read & dump property values into linked-list.
    //

    do {

       usRet = NWCReadPropertyValue(
                   hConn,
                   szObjectName,
                   dwOT_ID,
                   lpszPropertyName,
                   ucSegment,
                   lpTempReplySegment->Segment,
                   &pucMoreFlag,
                   &pucPropFlag
                   );
       hr = HRESULT_FROM_NWCCODE(usRet);

       BAIL_ON_FAILURE(hr);

       if (pucMoreFlag) {

           INIT_RPLY_SGMT(lpTempReplySegment->lpNext);
           lpTempReplySegment = lpTempReplySegment->lpNext;

          ucSegment++;
       }

    } while(pucMoreFlag);

    //
    // Return the resulting linked-list.
    //

    *lppReplySegment = lpHeadReplySegment;
    *pdwNumSegment = ucSegment;

error:
    if (FAILED(hr) && lpHeadReplySegment) {

        DELETE_LIST(lpHeadReplySegment);
    }

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGetFileServerVersionInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetFileServerVersionInfo(
    NWCONN_HANDLE hConn,
    VERSION_INFO  *pVersionInfo
    )
{
    NWCCODE usRet = SUCCESSFUL;
    HRESULT hr = S_OK;

    usRet = NWCGetFileServerVersionInfo(
                hConn,
                pVersionInfo
                );
    hr = HRESULT_FROM_NWCCODE(usRet);

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiIsObjectInSet
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiIsObjectInSet(
    NWCONN_HANDLE hConn,
    LPWSTR lpszObjectName,
    NWOBJ_TYPE wObjType,
    LPSTR lpszPropertyName,
    LPSTR lpszMemberName,
    NWOBJ_TYPE wMemberType
    )
{
    CHAR szAnsiObjectName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    if (wcslen(lpszObjectName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    //
    // Call NWCIsObjectInSet.
    //

    usRet = NWCIsObjectInSet(
                hConn,
                szAnsiObjectName,
                wObjType,
                lpszPropertyName,
                lpszMemberName,
                wMemberType
                );
    hr = HRESULT_FROM_NWCCODE(usRet);

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGetObjectID
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetObjectID(
    NWCONN_HANDLE hConn,
    LPWSTR lpszObjectName,
    NWOBJ_TYPE wObjType,
    NWOBJ_ID *pObjectID
    )
{
    CHAR szAnsiObjectName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(lpszObjectName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    //
    // Get Object's ID.
    //

    usRet = NWCGetObjectID(
                hConn,
                szAnsiObjectName,
                wObjType,
                pObjectID
                );
    hr = HRESULT_FROM_NWCCODE(usRet);

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGroupGetMembers
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGroupGetMembers(
    NWCONN_HANDLE hConn,
    LPWSTR szGroupName,
    LPBYTE *lppBuffer
    )
{
    DWORD   dwNumSegment = 0;
    HRESULT hr = S_OK;
    DWORD   i;
    LP_RPLY_SGMT_LST lpTemp = NULL;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;

    //
    // Assert
    //

    ADsAssert(*lppBuffer == NULL);

    //
    // Get GROUP_MEMBERS.
    //

    hr = NWApiGetProperty(
             szGroupName,
             NW_PROP_GROUP_MEMBERS,
             OT_USER_GROUP,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );
    BAIL_ON_FAILURE(hr);

    //
    // Pack returned linked list into buffer.
    //

    *lppBuffer = (LPBYTE) AllocADsMem(
                           dwNumSegment * REPLY_VALUE_SIZE
                           );
    if (!(*lppBuffer)) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpTemp = lpReplySegment;

    for (i = 0; i < dwNumSegment; i++) {
        memcpy(
            *lppBuffer + i * REPLY_VALUE_SIZE,
            lpTemp->Segment,
            REPLY_VALUE_SIZE
            );
        lpTemp = lpTemp->lpNext;
    }

error:

    //
    // Clean up.
    //

    lpTemp = NULL;

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN(hr);
}
//----------------------------------------------------------------------------
//
//  Function: NWApiAddGroupMember
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiAddGroupMember(
    NWCONN_HANDLE hConn,
    LPWSTR pszGroupName,
    LPWSTR pszMemberName
    )
{
    CHAR    szGroupName[(OBJ_NAME_SIZE + 1)*2];
    CHAR    szMemberName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(pszGroupName) > OBJ_NAME_SIZE) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }
    
    if (wcslen(pszMemberName) > OBJ_NAME_SIZE) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    UnicodeToAnsiString(
        pszGroupName,
        szGroupName,
        0
        );

    UnicodeToAnsiString(
        pszMemberName,
        szMemberName,
        0
        );

    //
    // Modify GROUP_MEMBERS property of the group to include the new member.
    //

    usRet = NWCAddObjectToSet(
                hConn,
                szGroupName,
                OT_USER_GROUP,
                "GROUP_MEMBERS",
                szMemberName,
                OT_USER
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

    //
    // Modify GROUPS_I'M_IN property of the new member to reflect its included
    // in the new group.
    //

    usRet = NWCAddObjectToSet(
                hConn,
                szMemberName,
                OT_USER,
                "GROUPS_I'M_IN",
                szGroupName,
                OT_USER_GROUP
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

    //
    // Modify SECURITY_EQUALS property of the new member to equate its security
    // to that of the new group it just joined.
    //

    usRet = NWCAddObjectToSet(
                hConn,
                szMemberName,
                OT_USER,
                "SECURITY_EQUALS",
                szGroupName,
                OT_USER_GROUP
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiRemoveGroupMember
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiRemoveGroupMember(
    NWCONN_HANDLE hConn,
    LPWSTR pszGroupName,
    LPWSTR pszMemberName
    )
{
    CHAR    szGroupName[(OBJ_NAME_SIZE + 1)*2];
    CHAR    szMemberName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(pszGroupName) > OBJ_NAME_SIZE) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }
    
    if (wcslen(pszMemberName) > OBJ_NAME_SIZE) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    UnicodeToAnsiString(
        pszGroupName,
        szGroupName,
        0
        );

    UnicodeToAnsiString(
        pszMemberName,
        szMemberName,
        0
        );

    //
    // Modify SECURITY_EQUALS property of the removed member to break its
    // security tie with the group it joined.
    //

    usRet = NWCDeleteObjectFromSet(
                hConn,
                szMemberName,
                OT_USER,
                "SECURITY_EQUALS",
                szGroupName,
                OT_USER_GROUP
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

    //
    // Modify GROUPS_I'M_IN property of the new member to reflect it is not
    // included in the group anymore.
    //

    usRet = NWCDeleteObjectFromSet(
                hConn,
                szMemberName,
                OT_USER,
                "GROUPS_I'M_IN",
                szGroupName,
                OT_USER_GROUP
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

    //
    // Modify GROUP_MEMBERS property of the group to remove the member.
    //

    usRet = NWCDeleteObjectFromSet(
                hConn,
                szGroupName,
                OT_USER_GROUP,
                "GROUP_MEMBERS",
                szMemberName,
                OT_USER
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);

}
//----------------------------------------------------------------------------
//
//  Function: NWApiGetLOGIN_CONTROL
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetLOGIN_CONTROL(
    NWCONN_HANDLE hConn,
    LPWSTR lpszUserName,
    LPLC_STRUCTURE lpLoginCtrlStruct
    )
{
    DWORD            dwNumSegment = 0;
    HRESULT          hr = S_OK;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL;

    hr = NWApiGetProperty(
             lpszUserName,
             NW_PROP_LOGIN_CONTROL,
             OT_USER,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );
    BAIL_ON_FAILURE(hr);

    *lpLoginCtrlStruct = *((LPLC_STRUCTURE) lpReplySegment->Segment);

error:

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiSetDefaultAcctExpDate
//
//  Synopsis: This function looks at the local time and returns a default value
//            for an account expiration date in a variant date.
//
//----------------------------------------------------------------------------
HRESULT
NWApiSetDefaultAcctExpDate(
    DOUBLE * pdTime,
    SYSTEMTIME SysTime
    )
{
    DOUBLE  vTime;
    HRESULT hr = S_OK;

    //
    // According to SysCon, the default account expiration date is the first day
    // of the following month.
    //

    if (SysTime.wMonth == 12) {
        SysTime.wMonth = 1;
    }
    else {
        SysTime.wMonth++;
    }

    SysTime.wDay = 1;

    //
    // Subtract 1980 from wYear for NWApiMakeVariantTime.
    //

    SysTime.wYear -= 1980;

    hr = NWApiMakeVariantTime(
             &vTime,
             SysTime.wDay,
             SysTime.wMonth,
             SysTime.wYear,
             0,0,0
             );
    BAIL_ON_FAILURE(hr);

    *pdTime = vTime;

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiUserAsSupervisor
//
//  Synopsis: This functions turns the user into one of the supervisors if TRUE
//            is passed.  User's supervisor privilege is removed otherwise.
//
//----------------------------------------------------------------------------
HRESULT
NWApiUserAsSupervisor(
    NWCONN_HANDLE hConn,
    LPWSTR lpszUserName,
    BOOL fSupervisor
    )
{
    CHAR    szUserName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(lpszUserName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }    

    UnicodeToAnsiString(
        lpszUserName,
        szUserName,
        0
        );

    //
    // Make it a supervisor.
    //

    if (fSupervisor == TRUE) {
        usRet = NWCAddObjectToSet(
                    hConn,
                    szUserName,
                    OT_USER,
                    "SECURITY_EQUALS",
                    "SUPERVISOR",
                    OT_USER
                    );
    }

    //
    // Remove supervisor privilege.
    //

    else {
        usRet = NWCDeleteObjectFromSet(
                    hConn,
                    szUserName,
                    OT_USER,
                    "SECURITY_EQUALS",
                    "SUPERVISOR",
                    OT_USER
                    );
    }

    hr = HRESULT_FROM_NWCCODE(usRet);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiGetVolumeNumber
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetVolumeNumber(
    NWCONN_HANDLE hConn,
    LPWSTR lpszVolumeName,
    NWVOL_NUM *pVolumeNumber
    )
{
    CHAR    szVolumeName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(lpszVolumeName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }    

    UnicodeToAnsiString(
        lpszVolumeName,
        szVolumeName,
        0
        );

    //
    // Get Volume's number.
    //

    usRet = NWCGetVolumeNumber(
                hConn,
                szVolumeName,
                pVolumeNumber
                );
    hr = HRESULT_FROM_NWCCODE(usRet);

    //
    // Return.
    //

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiGetVolumeName
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetVolumeName(
    NWCONN_HANDLE hConn,
    NWVOL_NUM bVolNum,
    LPWSTR *lppszVolName
    )
{
    CHAR    szVolumeName[OBJ_NAME_SIZE + 1];
    HRESULT hr = S_OK;
    LPWSTR  lpszTemp = NULL;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Get Volume's name.
    //

    usRet = NWCGetVolumeName(
                hConn,
                bVolNum,
                szVolumeName
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

    //
    // Convert result into Unicode.
    //

    lpszTemp = AllocateUnicodeString(szVolumeName);
    if (!lpszTemp) {
       RRETURN(E_OUTOFMEMORY);
    }

    *lppszVolName = AllocADsStr(lpszTemp);
    if (!(*lppszVolName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    FreeUnicodeString(lpszTemp);

    //
    // Return.
    //

    RRETURN(hr);

error:

    *lppszVolName = NULL;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiEnumJobs
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiEnumJobs(
    HANDLE hPrinter,
    DWORD dwFirstJob,
    DWORD dwNoJobs,
    DWORD dwLevel,
    LPBYTE *lplpbJobs,
    DWORD *pcbBuf,
    LPDWORD lpdwReturned
    )
{
    BOOL    fStatus = TRUE;
    HRESULT hr = S_OK;

    fStatus = WinNTEnumJobs(
                  hPrinter,
                  dwFirstJob,
                  dwNoJobs,
                  dwLevel,
                  lplpbJobs,
                  pcbBuf,
                  lpdwReturned
                  );

    if (fStatus == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiGetPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE *lplpbPrinters
    )
{
    BOOL    fStatus = TRUE;
    HRESULT hr = S_OK;

    fStatus = WinNTGetPrinter(
                  hPrinter,
                  dwLevel,
                  lplpbPrinters
                  );

    if (fStatus == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiUncFromADsPath
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiUncFromADsPath(
    LPWSTR lpszADsPath,
    LPWSTR lpszUncName
    )
{
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;

    hr = BuildObjectInfo(lpszADsPath,
                         &pObjectInfo );

    BAIL_ON_FAILURE(hr);

   wsprintf(
        lpszUncName,
        L"\\\\%s\\%s",
        pObjectInfo->ComponentArray[0],
        pObjectInfo->ComponentArray[1]
        );

error:
    if(pObjectInfo){
        FreeObjectInfo(pObjectInfo);
    }
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiMakeUserInfo
//
//  Synopsis: This function is very provider specific.
//
//----------------------------------------------------------------------------
HRESULT
NWApiMakeUserInfo(
    LPWSTR lpszBinderyName,
    LPWSTR lpszUserName,
    LPWSTR lpszPassword,
    PNW_USER_INFO pNwUserInfo
    )
{
    HRESULT hr = S_OK;
    NW_USER_INFO NwUserInfo = {NULL, NULL, NULL, NULL};

    hr = NWApiGetBinderyHandle(
             &NwUserInfo.hConn,
             lpszBinderyName
             );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(lpszBinderyName, &NwUserInfo.lpszBinderyName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(lpszUserName, &NwUserInfo.lpszUserName);
    BAIL_ON_FAILURE(hr);

    if (lpszPassword) {

        hr = ADsAllocString(lpszPassword, &NwUserInfo.lpszPassword);
        BAIL_ON_FAILURE(hr);
    }

    //
    // Return.
    //

    *pNwUserInfo = NwUserInfo;
    RRETURN(hr);

error:
    if (NwUserInfo.lpszBinderyName)
        ADsFreeString(NwUserInfo.lpszBinderyName);

    if (NwUserInfo.lpszUserName)
        ADsFreeString(NwUserInfo.lpszUserName);

    if (NwUserInfo.lpszPassword)
        ADsFreeString(NwUserInfo.lpszPassword);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiFreeUserInfo
//
//  Synopsis: This function is very provider specific.
//
//----------------------------------------------------------------------------
HRESULT
NWApiFreeUserInfo(
    PNW_USER_INFO pNwUserInfo
    )
{
    HRESULT hr = S_OK;

    if (pNwUserInfo->lpszBinderyName) {
        ADsFreeString(pNwUserInfo->lpszBinderyName);
        pNwUserInfo->lpszBinderyName = NULL ;
    }

    if (pNwUserInfo->lpszUserName) {
        ADsFreeString(pNwUserInfo->lpszUserName);
        pNwUserInfo->lpszUserName = NULL;
    }

    if (pNwUserInfo->lpszPassword) {
        ADsFreeString(pNwUserInfo->lpszPassword);
        pNwUserInfo->lpszPassword = NULL;
    }

    if (pNwUserInfo->hConn) {
        hr = NWApiReleaseBinderyHandle(
                 pNwUserInfo->hConn
                 );
        BAIL_ON_FAILURE(hr);
    }

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreateUser
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreateUser(
    PNW_USER_INFO pNwUserInfo
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NTSTATUS      Status = STATUS_SUCCESS;
    NWCCODE       usRet = SUCCESSFUL;
    NWCONN_HANDLE hConn = NULL;
    NWOBJ_ID      UserObjectID;
    UCHAR         ChallengeKey[8];
    UCHAR         NewKeyedPassword[17];
    UCHAR         ValidationKey[8];
    WCHAR         szTemp[MAX_PATH];

    //
    // "Create Bindery Object" - user object.  This user object is going to be
    // static, with access equals to logged read, supervisor write.
    //

    hr = NWApiCreateBinderyObject(
             pNwUserInfo->hConn,
             pNwUserInfo->lpszUserName,
             OT_USER,
             BF_STATIC,
             BS_LOGGED_READ | BS_SUPER_WRITE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Add user password.
    //

    hr = NWApiSetUserPassword(
             pNwUserInfo,
             &UserObjectID,
             NULL                 // no old passwd - this is a SET
             );
    BAIL_ON_FAILURE(hr);

    //
    // Create necessary bindery property to facilitate the addition of this user
    // to the group EVERYONE.
    //

    hr = NWApiCreateProperty(
             pNwUserInfo->hConn,
             pNwUserInfo->lpszUserName,
             OT_USER,
             "GROUPS_I'M_IN",
             BF_SET
             );
    BAIL_ON_FAILURE(hr);

    hr = NWApiCreateProperty(
             pNwUserInfo->hConn,
             pNwUserInfo->lpszUserName,
             OT_USER,
             "SECURITY_EQUALS",
             BF_SET
             );
    BAIL_ON_FAILURE(hr);

    //
    // Add this user to the group EVERYONE.
    // (okay if this fails, EVERYONE might not exist)
    //

    wcscpy(szTemp, L"EVERYONE");

    hrTemp = NWApiAddGroupMember(
                pNwUserInfo->hConn,
                szTemp,
                pNwUserInfo->lpszUserName
                );

    //
    // Create mail directory and login files.
    // (okay if this fails)
    //

    hrTemp = NWApiCreateMailDirectory(
                pNwUserInfo,
                UserObjectID
                );

    //
    // Create LOGIN_CONTROL & ACCOUNT_BALANCE property for the user.  Values
    // from USER_DEFAULTS are used as default.
    //

    hr = NWApiSetLoginCtrlAndAcctBalance(
             pNwUserInfo
             );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiDeleteUser
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiDeleteUser(
    POBJECTINFO pObjectInfo
    )
{
    BOOL          err = TRUE;
    DWORD         dwErr = 0;
    HRESULT       hr = S_OK;
    NWCONN_HANDLE hConn = NULL;
    NWOBJ_ID      ObjectID;
    WCHAR         szPath[MAX_PATH];

    //
    // Open a handle to the bindery.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get the user's ObjectID which is needed to compose the path name of LOGIN
    // and LOGIN.OS2.
    //

    hr = NWApiGetObjectID(
             hConn,
             pObjectInfo->ComponentArray[1],
             OT_USER,
             &ObjectID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Delete SYS:MAIL\<JOBID>\LOGIN.  If the file is not found, that's OK, as
    // long as it is not there.
    //

    wsprintf(
        szPath,
        L"\\\\%s\\SYS\\MAIL\\%X\\LOGIN",
        pObjectInfo->ComponentArray[0],
        dwSWAP(ObjectID)
        );

    err = DeleteFile(szPath);

    //
    // Remove any error checking for the cleanup of
    // files. If they do exist, and we do clean them up
    // great. But otherwise Win95 chokes on us.
    //

    //
    // Delete SYS:MAIL\<JOBID>\LOGIN.OS2.  If the file is not found, that's OK,
    // as long as it is not there.
    //

    wsprintf(
        szPath,
        L"\\\\%s\\SYS\\MAIL\\%X\\LOGIN.OS2",
        pObjectInfo->ComponentArray[0],
        dwSWAP(ObjectID)
        );

    err = DeleteFile(szPath);

    //
    // Remove any error checking for the cleanup of
    // files. If they do exist, and we do clean them up
    // great. But otherwise Win95 chokes on us.
    //

    //
    // Delete SYS:MAIL\<JOBID>.
    //

    wsprintf(
        szPath,
        L"\\\\%s\\SYS\\MAIL\\%X",
        pObjectInfo->ComponentArray[0],
        dwSWAP(ObjectID)
        );

    err = RemoveDirectory(szPath);

    //
    // Remove any error checking for the cleanup of
    // files. If they do exist, and we do clean them up
    // great. But otherwise Win95 chokes on us.
    //


    //
    // Delete the user object.
    //

    hr = NWApiDeleteBinderyObject(
             hConn,
             pObjectInfo->ComponentArray[1],
             OT_USER
             );
    BAIL_ON_FAILURE(hr);

error:

    NWApiReleaseBinderyHandle(hConn);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreateBinderyObject
//
//  Synopsis: This function create the specified object in the specified NetWare
//            bindery.  It returns S_OK if the object alread exist.
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreateBinderyObject(
    NWCONN_HANDLE hConn,
    LPWSTR lpszObjectName,
    NWOBJ_TYPE wObjType,
    NWFLAGS ucObjectFlags,
    NWFLAGS usObjSecurity
    )
{
    CHAR szAnsiObjectName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(lpszObjectName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }    

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    //
    // Create a Static object with LOGGED_READ & SUPERVISOR_WRITE.
    //

    usRet = NWCCreateObject(
                hConn,
                szAnsiObjectName,
                wObjType,
                BF_STATIC,
                BS_LOGGED_READ | BS_SUPER_WRITE
                );
    //
    // If an error occured, check if it is OBJECT_ALREADY_EXISTS.  If it is,
    // treat it as no error.
    //

    if (usRet) {
        if (usRet == OBJECT_ALREADY_EXISTS) {
            usRet = SUCCESSFUL;
        }
    }

    //
    // Return.
    //

    hr = HRESULT_FROM_NWCCODE(usRet);
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiDeleteBinderyObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiDeleteBinderyObject(
    NWCONN_HANDLE hConn,
    LPWSTR lpszObjectName,
    NWOBJ_TYPE wObjType
    )
{
    CHAR szAnsiObjectName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(lpszObjectName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }    

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    //
    // Delete the object from the bindery.
    //

    usRet = NWCDeleteObject(
                hConn,
                szAnsiObjectName,
                wObjType
                );
    //
    // Return.
    //

    hr = HRESULT_FROM_NWCCODE(usRet);
    RRETURN(hr);
}

#define            NW_MAX_PASSWORD_LEN    256

//----------------------------------------------------------------------------
//
//  Function: NWApiSetUserPassword
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiSetUserPassword(
    PNW_USER_INFO pNwUserInfo,
    DWORD *pdwUserObjID,
    LPWSTR pszOldPassword
    )
{
    CHAR           szAnsiUserName[(OBJ_NAME_SIZE + 1)*2];
    CHAR           szAnsiPassword[(NW_MAX_PASSWORD_LEN + 1)*2];
    CHAR           szAnsiOldPassword[(NW_MAX_PASSWORD_LEN + 1)*2];
    CHAR           Buffer[128];
    DWORD          err = 0;
    HRESULT        hr = S_OK;
    LC_STRUCTURE   LoginCtrl;
    NTSTATUS       NtStatus;
    UCHAR          ChallengeKey[8];
    UCHAR          ucMoreFlag;
    UCHAR          ucPropFlag;
    WCHAR          szOldPasswordCopy[NW_MAX_PASSWORD_LEN + 1];

    if ( !pNwUserInfo ||
         !(pNwUserInfo->lpszUserName) ||
         !(pNwUserInfo->lpszPassword) ) {

        hr = E_INVALIDARG ;
        BAIL_ON_FAILURE(hr);
    }

    if ( (wcslen(pNwUserInfo->lpszUserName) > OBJ_NAME_SIZE) ||
         (wcslen(pNwUserInfo->lpszPassword) > NW_MAX_PASSWORD_LEN) ||
         ( pszOldPassword && (wcslen(pszOldPassword) > NW_MAX_PASSWORD_LEN)) ) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Convert UNICODE into ANSI representation required by NW APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    err = UnicodeToAnsiString(
        pNwUserInfo->lpszUserName,
        szAnsiUserName,
        0
        );
    if (!err) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    _wcsupr(pNwUserInfo->lpszPassword) ;
    err = UnicodeToAnsiString(
        pNwUserInfo->lpszPassword,
        szAnsiPassword,
        0
        );
    if (!err) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (pszOldPassword) {
        wcscpy(szOldPasswordCopy, pszOldPassword);
        _wcsupr(szOldPasswordCopy) ;
        err = UnicodeToAnsiString(
            szOldPasswordCopy,
            szAnsiOldPassword,
            0
            );
        if (!err) {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

    }
    else {

        szAnsiOldPassword[0] = 0 ;
    }

    //
    // Get challenge key.
    //

    err = NWApiMapNtStatusToDosError(
              NWPGetChallengeKey(
                  pNwUserInfo->hConn,
                  ChallengeKey
                  ));

    if (!err) {

        //
        // For NetWare 4.x servers, this has to be done after the
        // NWPGetChallengeKey so that the object id returned can be used to
        // encrypt the password. 4.x bindery emulation might return different
        // object ids for some users depending on whether the NWPGetChallengeKey
        // is called beforehand.
        //

        err = NWApiMapNtStatusToDosError(
                  NWPGetObjectID(
                      pNwUserInfo->hConn,
                      szAnsiUserName,
                      OT_USER,
                      pdwUserObjID
                      ));
    }


    if (!err) {

        //
        // The old password and object ID make up the 17-byte Vold. This is used
        // later to form the 17-byte Vc for changing password on the server.
        //

        UCHAR ValidationKey[8];
        UCHAR NewKeyedPassword[17];

        EncryptChangePassword(
            (PUCHAR) szAnsiOldPassword,
            (PUCHAR) szAnsiPassword,
            *pdwUserObjID,
            ChallengeKey,
            ValidationKey,
            NewKeyedPassword
            );

        err = NWApiMapNtStatusToDosError(
                  NWPChangeObjectPasswordEncrypted(
                      pNwUserInfo->hConn,
                      szAnsiUserName,
                      OT_USER,
                      ValidationKey,
                      NewKeyedPassword
                      ));
    }

    //
    // Return.
    //

    hr = HRESULT_FROM_WIN32(err);


error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreateMailDirectory
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreateMailDirectory(
    PNW_USER_INFO pNwUserInfo,
    NWOBJ_ID UserObjID
    )
{
    BYTE    szPath[(MAX_PATH + 1) * sizeof(WCHAR)];
    CHAR    szUserObjID[255];
    DWORD   err = 0;
    HRESULT hr = S_OK;

    //
    // Make path.
    //

    _ltoa(
        dwSWAP(UserObjID),
        szUserObjID,
        16
        );

    strcpy((char *) szPath, "SYS:\\MAIL\\");
    strcat((char *) szPath, szUserObjID);

    //
    // Create a directory with Maximum rights mask.
    //

    err = NWApiMapNtStatusToDosError(
              NWPCreateDirectory(
                  pNwUserInfo->hConn,
                  0,
                  (char *) szPath,
                  0xFF // From SysCon --- Max. access rights for directory
                  ));  //   = Full Access
                  
    if ( !err ) {
        //
        // Add a trustee with all rights except PARENTAL right.
        //

        err = NWApiMapNtStatusToDosError(
                  NWPAddTrustee(
                      pNwUserInfo->hConn,
                      0,
                      (char *) szPath,
                      UserObjID,
                      0xDF  // From SysCon --- Trustee has all rights
                      ));   //   EXCEPT parental rights (right to create/
                            //   delete subdirs, make others trustees)
        //
        // Create a Login file.
        //

        if ( !err ) {
            HANDLE hFile;

            wsprintfW(
                (LPWSTR) szPath,
                L"\\\\%ws\\SYS\\MAIL\\%X\\LOGIN",
                pNwUserInfo->lpszBinderyName,
                dwSWAP(UserObjID)
                );

            hFile = CreateFile(
                        (LPWSTR) szPath,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        0
                        );

            if ( hFile == INVALID_HANDLE_VALUE ) {
                err = GetLastError();
            }

            if ( !err )
                CloseHandle( hFile );

            //
            // Create a Login.os2 file.
            //

            wsprintfW(
                (LPWSTR) szPath,
                L"\\\\%ws\\SYS\\MAIL\\%X\\LOGIN.OS2",
                pNwUserInfo->lpszBinderyName,
                dwSWAP(UserObjID)
                );

            hFile = CreateFile(
                        (LPWSTR) szPath,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        0
                        );

            if ( hFile == INVALID_HANDLE_VALUE ) {
                err = GetLastError();
            }

            if ( !err )
                CloseHandle( hFile );
        }
    }

    // err == 255 == "FAILURE"
    // might be used to indicate directory already exists,
    // but also used to signal generic failure

    hr = HRESULT_FROM_WIN32(err);
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiSetLoginCtrlAndAcctBalance
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiSetLoginCtrlAndAcctBalance(
    PNW_USER_INFO pNwUserInfo
    )
{
    ACCT_BALANCE     AccountBalance;
    DWORD            dwNumSegment;
    HRESULT          hr = S_OK;
    int              i = 0;
    LC_STRUCTURE     LoginCtrl;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL;
    USER_DEFAULT     UserDefault;
    WCHAR            szTemp[MAX_PATH];

    //
    // Get Supervisor's USER_DEFAULTS.
    //

    wcscpy(szTemp, NW_PROP_SUPERVISORW);

    hr = NWApiGetProperty(
             szTemp,
             NW_PROP_USER_DEFAULTS,
             OT_USER,
             pNwUserInfo->hConn,
             &lpReplySegment,
             &dwNumSegment
             );

    if (SUCCEEDED(hr)) {
    
        UserDefault = *((LPUSER_DEFAULT) lpReplySegment->Segment);

        //
        // Put default values into LoginCtrl.
        //

        LoginCtrl.byAccountExpires[0] = UserDefault.byAccountExpiresYear;
        LoginCtrl.byAccountExpires[1] = UserDefault.byAccountExpiresMonth;
        LoginCtrl.byAccountExpires[2] = UserDefault.byAccountExpiresDay;
        LoginCtrl.byAccountDisabled = 0;
        LoginCtrl.byPasswordExpires[0] = 85;
        LoginCtrl.byPasswordExpires[1] = 01;
        LoginCtrl.byPasswordExpires[2] = 01;
        LoginCtrl.byGraceLogins = UserDefault.byGraceLoginReset;
        LoginCtrl.wPasswordInterval = UserDefault.wPasswordInterval;
        LoginCtrl.byGraceLoginReset = UserDefault.byGraceLoginReset;
        LoginCtrl.byMinPasswordLength = UserDefault.byMinPasswordLength;
        LoginCtrl.wMaxConnections = UserDefault.wMaxConnections;
        LoginCtrl.byRestrictions = UserDefault.byRestrictions;
        LoginCtrl.byUnused = 0;
        LoginCtrl.lMaxDiskBlocks = UserDefault.lMaxDiskBlocks;
        LoginCtrl.wBadLogins = 0;
        LoginCtrl.lNextResetTime = 0;

        for (i = 0; i < 42; i++) {
            LoginCtrl.byLoginTimes[i] = UserDefault.byLoginTimes[i];
        }

        for (i = 0; i < 6; i++) {
            LoginCtrl.byLastLogin[i] = 0;
        }

        for (i = 0; i < 12; i++) {
            LoginCtrl.byBadLoginAddr[i] = 0;
        }


        LoginCtrl.byGraceLogins = LoginCtrl.byGraceLoginReset;

        //
        // Put default values into AccountBalance.
        //

        AccountBalance.lBalance = UserDefault.lBalance;
        AccountBalance.lCreditLimit = UserDefault.lCreditLimit;

        //
        // Write LOGIN_CONTROL property.
        //

        hr = NWApiWriteProperty(
                 pNwUserInfo->hConn,
                 pNwUserInfo->lpszUserName,
                 OT_USER,
                 NW_PROP_LOGIN_CONTROL,
                 (LPBYTE) &LoginCtrl
                 );
        BAIL_ON_FAILURE(hr);

        //
        // Write ACCOUNT_BALANCE property.
        //

        hr = NWApiWriteProperty(
                 pNwUserInfo->hConn,
                 pNwUserInfo->lpszUserName,
                 OT_USER,
                 NW_PROP_ACCOUNT_BALANCE,
                 (LPBYTE) &AccountBalance
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // SUPERVISOR may not exist, or may not have USER_DEFAULTS.
    // This is okay.
    //
    hr = S_OK;

error:

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreateGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreateGroup(
    POBJECTINFO pObjectInfo
    )
{
    HRESULT       hr = S_OK;
    NWCONN_HANDLE hConn = NULL;

    //
    // Open a handle to the bindery.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Create a group bindery object.
    //

    hr = NWApiCreateBinderyObject(
             hConn,
             pObjectInfo->ComponentArray[1],
             OT_USER_GROUP,
             BF_STATIC,
             BS_LOGGED_READ | BS_SUPER_WRITE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Create GROUP_MEMBERS property.
    //

    hr = NWApiCreateProperty(
             hConn,
             pObjectInfo->ComponentArray[1],
             OT_USER_GROUP,
             NW_PROP_GROUP_MEMBERS,
             BF_SET
             );
    BAIL_ON_FAILURE(hr);

error:

    NWApiReleaseBinderyHandle(hConn);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiDeleteGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiDeleteGroup(
    POBJECTINFO pObjectInfo
    )
{
    HRESULT       hr = S_OK;
    NWCONN_HANDLE hConn = NULL;

    //
    // Open a handle to the bindery.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Delete the group object.
    //

    hr = NWApiDeleteBinderyObject(
             hConn,
             pObjectInfo->ComponentArray[1],
             OT_USER_GROUP
             );
    BAIL_ON_FAILURE(hr);

error:

    NWApiReleaseBinderyHandle(hConn);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreatePrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreatePrinter(
    POBJECTINFO pObjectInfo
    )
{
    CHAR          szQueueName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT       hr = S_OK;
    NWCCODE       usRet = SUCCESSFUL;
    NWCONN_HANDLE hConn = NULL;
    WCHAR         szTemp[MAX_PATH];

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(pObjectInfo->ComponentArray[1]) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }    

    UnicodeToAnsiString(
        pObjectInfo->ComponentArray[1],
        szQueueName,
        0
        );

    //
    // Open a handle to the bindery.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Create a print queue object.
    //

    hr = NWApiCreatePrintQueue(
             hConn,
             pObjectInfo->ComponentArray[1]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Change property security.
    //

    usRet = NWCChangePropertySecurity(
                hConn,
                szQueueName,
                OT_PRINT_QUEUE,
                NW_PROP_Q_OPERATORS,
                BS_LOGGED_READ | BS_SUPER_WRITE
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

    //
    // Add SUPERVISOR to Q_OPERATORS.
    // (okay if this fails, maybe SUPERVISOR doesn't exist)
    //

    usRet = NWCAddObjectToSet(
                hConn,
                szQueueName,
                OT_PRINT_QUEUE,
                NW_PROP_Q_OPERATORS,
                NW_PROP_SUPERVISOR,
                OT_USER
                );

    //
    // Add EVERYONE to Q_USERS.
    // (okay if this fails, maybe EVERYONE doesn't exist)    
    //

    usRet = NWCAddObjectToSet(
                hConn,
                szQueueName,
                OT_PRINT_QUEUE,
                NW_PROP_Q_USERS,
                NW_PROP_EVERYONE,
                OT_USER_GROUP
                );

    //
    // Return.
    //

error:

    NWApiReleaseBinderyHandle(hConn);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiDeleteGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiDeletePrinter(
    POBJECTINFO pObjectInfo
    )
{
    HRESULT       hr = S_OK;
    NWCONN_HANDLE hConn = NULL;
    NWOBJ_ID      dwQueueID = 0;

    //
    // Open a handle to the bindery.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get Queue ID.
    //

    hr = NWApiDestroyPrintQueue(
             hConn,
             pObjectInfo->ComponentArray[1]
             );
    BAIL_ON_FAILURE(hr);

error:

    NWApiReleaseBinderyHandle(hConn);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreatePrintQueue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreatePrintQueue(
    NWCONN_HANDLE hConn,
    LPWSTR lpszQueueName
    )
{
    CHAR    szQueueName[(OBJ_NAME_SIZE + 1)*2];
    DWORD   dwQueueID = 0;
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(lpszQueueName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }    

    UnicodeToAnsiString(
        lpszQueueName,
        szQueueName,
        0
        );

    //
    // Create a print queue object.
    //

    usRet = NWCCreateQueue(
                hConn,
                NULL,
                szQueueName,
                OT_PRINT_QUEUE,
                NW_PRINTER_PATH,
                &dwQueueID
                );
    hr = HRESULT_FROM_NWCCODE(usRet);

    //
    // Return.
    //

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiDestroyPrintQueue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiDestroyPrintQueue(
    NWCONN_HANDLE hConn,
    LPWSTR lpszQueueName
    )
{
    DWORD   dwQueueID = 0;
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Get Queue ID.
    //

    hr = NWApiGetObjectID(
             hConn,
             lpszQueueName,
             OT_PRINT_QUEUE,
             &dwQueueID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Destroy print queue.
    //

    usRet = NWCDestroyQueue(
                hConn,
                dwSWAP(dwQueueID)
                );
    hr = HRESULT_FROM_NWCCODE(usRet);

    //
    // Return.
    //

error:

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiMapNtStatusToDosError
//
//  Synopsis: This function maps the ntstatus that was returned from the NetWare
//            redirector to window errors. Similar to RtlNtStatusToDosError
//            except that the special handling is done to ntstatus with netware
//            facility codes.
//
//  Argument: NtStatus - The ntstatus returned from NetWare rdr
//
//  Return Value: WinError
//
//----------------------------------------------------------------------------
DWORD
NWApiMapNtStatusToDosError(
    IN NTSTATUS NtStatus
    )
{
    if ( (HIWORD( NtStatus) & FACILITY_NWRDR ) == FACILITY_NWRDR )
    {
        if ( NtStatus == NWRDR_PASSWORD_HAS_EXPIRED )
            return ERROR_PASSWORD_EXPIRED;
        else
            return NETWARE_GENERAL_ERROR;
    }
    else if ( HIWORD( NtStatus) == 0xC001 )
    {
        return LOWORD( NtStatus ) + NETWARE_ERROR_BASE;
    }

    return RtlNtStatusToDosError( NtStatus );
}

//----------------------------------------------------------------------------
//
//  Function: NWApiConvertToAddressFormat
//
//  Synopsis: Convert an IPX address obtain from NWApiGetProperty into the
//            format specified in spec.
//
//----------------------------------------------------------------------------
HRESULT
NWApiConvertToAddressFormat(
    LP_RPLY_SGMT_LST lpReplySegment,
    LPWSTR *lppszAddresses
    )
{
    int    i = 0;
    LPBYTE lpBuffer = NULL;
    LPWSTR lpszTemp = NULL;
    WORD   wSegment[NET_ADDRESS_WORD_SIZE];

    //
    // Put values from szReply into the wSegment array
    //

    lpBuffer = (LPBYTE) lpReplySegment->Segment;

    for (i = 0; i < NET_ADDRESS_WORD_SIZE; i++) {

        wSegment[i] = NWApiReverseWORD(*((LPWORD)lpBuffer + i));
    }

    //
    // Put address together in the format described in spec.
    //

    lpszTemp = (LPWSTR) AllocADsMem((NET_ADDRESS_NUM_CHAR+1)*sizeof(WCHAR));
    if (!lpszTemp) {
        RRETURN(E_OUTOFMEMORY);
    }

    wsprintf(
        lpszTemp,
        L"%s:%04X%04X.%04X%04X%04X.%04X",
        bstrAddressTypeString,
        wSegment[0],
        wSegment[1],
        wSegment[2],
        wSegment[3],
        wSegment[4],
        wSegment[5]
        );

    //
    // Return.
    //
    *lppszAddresses = lpszTemp;

    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiMakeVariantTime
//
//  Synopsis: This function creates a double precision variant time.
//
//----------------------------------------------------------------------------
HRESULT
NWApiMakeVariantTime(
    DOUBLE * pdTime,
    WORD wDay,         // Day = 1..31
    WORD wMonth,       // Month = 1..12
    WORD wYear,        // Year = (19XX or 20XX) - 1980, ie. 2019 -> 39
    WORD wSecond,      // Second = 0..30, Second divided by 2
    WORD wMinute,      // Minute = 0..59
    WORD wHour         // Hour = 0..23
    )
{
    BOOL   fBool = TRUE;
    DOUBLE vTime = 0;
    WORD   wDOSDate = 0;
    WORD   wDOSTime = 0;

    //
    // Fix up parameters.
    // If wDay and wMonth are 0, turn them into one.
    //

    if (wDay == 0) {
        wDay++;
    }

    if (wMonth == 0) {
        wMonth++;
    }

    //
    // Shift data to correct bit as required by the DOS date & time format.
    //

    wMonth = wMonth << 5;
    wYear =  wYear << 9;
    wMinute = wMinute << 5;
    wHour = wHour << 11;

    //
    // Put them in DOS format.
    //

    wDOSDate = wYear | wMonth | wDay;
    wDOSTime = wHour | wMinute | wSecond;

    //
    // Convert into VariantTime.
    //

    fBool = DosDateTimeToVariantTime(
                wDOSDate,
                wDOSTime,
                &vTime
                );

    //
    // Return.
    //

    if (fBool == TRUE) {

        *pdTime = vTime;

        RRETURN(S_OK);
    }
    else {
        RRETURN(E_FAIL);
    }
}

//----------------------------------------------------------------------------
//
//  Function: NWApiBreakVariantTime
//
//  Synopsis: This function interprets a double precision variant time and
//            returns the day, month and year individually.
//
//----------------------------------------------------------------------------
HRESULT
NWApiBreakVariantTime(
    DOUBLE daDate,
    PWORD pwDay,
    PWORD pwMonth,
    PWORD pwYear
    )
{
    BOOL   fBool;
    DOUBLE vTime;
    WORD   wDOSDate = 0;
    WORD   wDOSTime = 0;
    WORD   wDay = 0;
    WORD   wMonth = 0;
    WORD   wYear = 0;

    //
    // Convert variant time into DOS format.
    //

    fBool = VariantTimeToDosDateTime(
                daDate,
                &wDOSDate,
                &wDOSTime
                );
    if (fBool == FALSE) {
        goto error;
    }

    //
    // Year: bits 9-15, add 80 to wYear because 80 was subtracted from it to
    // call VariantTimeToDosDateTime.
    //

    wYear = wDOSDate >> 9;
    wYear += 80;

    //
    // Month: bits 5-8.
    //

    wMonth = (wDOSDate >> 5) - (wYear << 4);

    //
    // Day: bits 0-4.
    //

    wDay = wDOSDate - (wMonth << 5) - (wYear << 9);

    //
    // Return.
    //

    *pwDay = wDay;
    *pwMonth = wMonth;
    *pwYear = wYear;

    RRETURN(S_OK);

error:

    RRETURN(E_FAIL);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiReverseWORD
//
//  Synopsis: This function reverse a WORD.
//
//----------------------------------------------------------------------------
WORD
NWApiReverseWORD(
    WORD wWORD
    )
{

    LPBYTE lpbTemp = (LPBYTE) &wWORD;
    BYTE bTemp;

    bTemp = *lpbTemp;
    *lpbTemp = *(lpbTemp + 1);
    *(lpbTemp + 1) = bTemp;

    return(*((LPWORD) lpbTemp));
}


//----------------------------------------------------------------------------
//
//  Function: NWApiUserGetGroups
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiUserGetGroups(
    NWCONN_HANDLE hConn,
    LPWSTR szUserName,
    LPBYTE *lppBuffer
    )
{
    DWORD   dwNumSegment = 0;
    HRESULT hr = S_OK;
    DWORD   i;
    LP_RPLY_SGMT_LST lpTemp = NULL;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;

    //
    // Assert
    //

    ADsAssert(*lppBuffer == NULL);

    //
    // Get GROUP_MEMBERS.
    //

    hr = NWApiGetProperty(
             szUserName,
             NW_PROP_USER_GROUPS,
             OT_USER,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );
    BAIL_ON_FAILURE(hr);

    //
    // Pack returned linked list into buffer.
    //

    *lppBuffer = (LPBYTE) AllocADsMem(
                           dwNumSegment * REPLY_VALUE_SIZE
                           );
    if (!(*lppBuffer)) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpTemp = lpReplySegment;

    for (i = 0; i < dwNumSegment; i++) {
        memcpy(
            *lppBuffer + i * REPLY_VALUE_SIZE,
            lpTemp->Segment,
            REPLY_VALUE_SIZE
            );
        lpTemp = lpTemp->lpNext;
    }

error:

    //
    // Clean up.
    //

    lpTemp = NULL;

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\nwmrshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       nwmrshl.cxx
//
//  Contents:
//
//  Functions:
//
//  History:      23-June-1996   KrishnaG Created.
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma  hdrstop

HRESULT
CopyNTOBJECTToDWORD(
    PNTOBJECT pNtSrcObject,
    PDWORD   pdwRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }
    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DWORD)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pdwRetval = (pNtSrcObject->NTValue).dwValue;

    RRETURN(S_OK);

}

HRESULT
CopyNTOBJECTToDATE(
    PNTOBJECT pNtSrcObject,
    PDWORD   pdwRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }
    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DATE)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pdwRetval = (pNtSrcObject->NTValue).dwValue;

    RRETURN(S_OK);

}



HRESULT
CopyNTOBJECTToNw312DATE(
    PNTOBJECT pNtSrcObject,
    PBYTE   pbyRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }
    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_NW312DATE)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }


    memcpy(pbyRetval,(pNtSrcObject->NTValue).Nw312Date, 6);

    RRETURN(S_OK);

}


HRESULT
CopyNTOBJECTToBOOL(
    PNTOBJECT pNtSrcObject,
    PBOOL   pfRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_BOOL)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pfRetval = (pNtSrcObject->NTValue).fValue;

    RRETURN(S_OK);

}


HRESULT
CopyNTOBJECTToSYSTEMTIME(
    PNTOBJECT pNtSrcObject,
    SYSTEMTIME *pstRetVal
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_SYSTEMTIME)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pstRetVal = (pNtSrcObject->NTValue).stSystemTimeValue;

    RRETURN(S_OK);

}

HRESULT
CopyNTOBJECTToLPTSTR(
    PNTOBJECT pNtSrcObject,
    LPTSTR  *ppszRetval
    )
{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_LPTSTR)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *ppszRetval = AllocADsStr((pNtSrcObject->NTValue).pszValue);

    if (! *ppszRetval && ((pNtSrcObject->NTValue).pszValue)) {
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(S_OK);

}


HRESULT
CopyNTOBJECTToOctet(
    PNTOBJECT pNtSrcObject,
    OctetString *pOctet
    )
{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_OCTETSTRING)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    pOctet->dwSize = (pNtSrcObject->NTValue).octetstring.dwSize;
    pOctet->pByte = (BYTE*)AllocADsMem(sizeof(BYTE) * (pNtSrcObject->NTValue).octetstring.dwSize);
    if (!pOctet->pByte) {
        RRETURN(E_OUTOFMEMORY);
    }
    memcpy(pOctet->pByte,
           (pNtSrcObject->NTValue).octetstring.pByte,
           (pNtSrcObject->NTValue).octetstring.dwSize);
    RRETURN(S_OK);

}


HRESULT
CopyNTOBJECTToDelimitedString(
    PNTOBJECT pNtSrcObject,
    LPTSTR  *ppszRetval
    )
{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DelimitedString)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    if ((pNtSrcObject->NTValue).pszValue == NULL){
        *ppszRetval = NULL;
    } else {
        *ppszRetval = AllocADsStr((pNtSrcObject->NTValue).pszValue);
    }

    if (! *ppszRetval && ((pNtSrcObject->NTValue).pszValue)) {
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(S_OK);
}


HRESULT
CopyNTOBJECTToNulledString(
    PNTOBJECT pNtSrcObject,
    LPTSTR  *ppszRetval
    )
{
    HRESULT hr = S_OK;

    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_NulledString)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = CopyNulledString((pNtSrcObject->NTValue).pszValue,
                          ppszRetval );

    if ( FAILED (hr)){
        RRETURN(hr);
    }
    RRETURN(S_OK);
}

HRESULT
CopyNTOBJECTToNT(
    DWORD dwSyntaxId,
    PNTOBJECT lpNTObject,
    LPBYTE lpByte
    )
{

    HRESULT hr = S_OK;

    switch (dwSyntaxId) {
    case NT_SYNTAX_ID_BOOL:
        hr = CopyNTOBJECTToBOOL(
                         lpNTObject,
                         (PBOOL)lpByte
                         );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = CopyNTOBJECTToSYSTEMTIME(
                         lpNTObject,
                         (PSYSTEMTIME)lpByte
                         );
        break;

    case NT_SYNTAX_ID_DWORD:
        hr = CopyNTOBJECTToDWORD(
                         lpNTObject,
                         (PDWORD)lpByte
                         );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = CopyNTOBJECTToDATE(
                         lpNTObject,
                         (PDWORD)lpByte
                         );
        break;

    case NT_SYNTAX_ID_NW312DATE:
        hr = CopyNTOBJECTToNw312DATE(
                         lpNTObject,
                         (LPBYTE)lpByte
                         );
        break;

    case NT_SYNTAX_ID_DelimitedString:
        hr = CopyNTOBJECTToDelimitedString(
                         lpNTObject,
                         (LPTSTR *)lpByte
                         );
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = CopyNTOBJECTToNulledString(
                         lpNTObject,
                         (LPTSTR *)lpByte
                         );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = CopyNTOBJECTToLPTSTR(
                         lpNTObject,
                         (LPTSTR *)lpByte
                         );
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = CopyNTOBJECTToOctet(
                         lpNTObject,
                         (OctetString *)lpByte
                         );
        break;

    default:
        hr = E_FAIL;
        break;

    }

    RRETURN(hr);
}


HRESULT
MarshallNTSynIdToNT(
    DWORD dwSyntaxId,
    PNTOBJECT pNTObject,
    DWORD dwNumValues,
    LPBYTE lpValue
    )
{

    HRESULT hr = S_OK;
    DWORD  i = 0;

    //
    // Loop below does not really handle case other than 1 value
    //

    for (i = 0; i < dwNumValues; i++) {

        hr  = CopyNTOBJECTToNT(
                         dwSyntaxId,
                         (pNTObject + i) ,
                         lpValue
                         );

    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\nwcopy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nwcopy.cxx
//
//  Contents:   Nw312 Object Copy Routines
//
//  Functions:
//
//  History:      17-June-96   KrishnaG   Created.
//                cloned off NDS copy code.
//
//
//
//
//
//----------------------------------------------------------------------------

//
// NtType objects copy code
//

#include "nwcompat.hxx"
#pragma  hdrstop


HRESULT
NtTypeCopy(
    PNTOBJECT lpNtSrcObject,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNtSrcObject->NTType) {

    case NT_SYNTAX_ID_BOOL:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_BOOL;
        (lpNtDestObject->NTValue).fValue =  (lpNtSrcObject->NTValue).fValue;
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_SYSTEMTIME;
        (lpNtDestObject->NTValue).stSystemTimeValue =
            (lpNtSrcObject->NTValue).stSystemTimeValue;
        break;

    case NT_SYNTAX_ID_DWORD:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DWORD;
        (lpNtDestObject->NTValue).dwValue =
            (lpNtSrcObject->NTValue).dwValue;
        break;

    case NT_SYNTAX_ID_DATE:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DATE;
        (lpNtDestObject->NTValue).dwValue =
            (lpNtSrcObject->NTValue).dwValue;
        break;

    case NT_SYNTAX_ID_NW312DATE:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_NW312DATE;
        memcpy(
            (lpNtDestObject->NTValue).Nw312Date,
            (lpNtSrcObject->NTValue).Nw312Date,
            6
            );
        break;


    case NT_SYNTAX_ID_LPTSTR:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_LPTSTR;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }

        (lpNtDestObject->NTValue).pszValue =
            AllocADsStr((lpNtSrcObject->NTValue).pszValue);

        hr =((lpNtDestObject->NTValue).pszValue == NULL)
            ? E_OUTOFMEMORY :S_OK;

        break;

    case NT_SYNTAX_ID_OCTETSTRING:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_OCTETSTRING;
        (lpNtDestObject->NTValue).octetstring.dwSize = 
			(lpNtSrcObject->NTValue).octetstring.dwSize;
		if ((lpNtSrcObject->NTValue).octetstring.dwSize == 0) {
			(lpNtDestObject->NTValue).octetstring.pByte = NULL;
		}
		else {
			(lpNtDestObject->NTValue).octetstring.pByte = 
					(BYTE*)AllocADsMem(sizeof(BYTE)*(lpNtSrcObject->NTValue).octetstring.dwSize);
			if (!(lpNtDestObject->NTValue).octetstring.pByte) {
				RRETURN(E_OUTOFMEMORY);
			}
			memcpy((lpNtDestObject->NTValue).octetstring.pByte, 
				   (lpNtSrcObject->NTValue).octetstring.pByte,
				   (lpNtSrcObject->NTValue).octetstring.dwSize);
		}

        break;

    case NT_SYNTAX_ID_DelimitedString:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DelimitedString;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }

        (lpNtDestObject->NTValue).pszValue =
            AllocADsStr((lpNtSrcObject->NTValue).pszValue);

        hr =((lpNtDestObject->NTValue).pszValue == NULL)
            ? E_OUTOFMEMORY :S_OK;

        break;

    case NT_SYNTAX_ID_NulledString:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_NulledString;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }

        hr = CopyNulledString((lpNtSrcObject->NTValue).pszValue,
                              &(lpNtDestObject->NTValue).pszValue );

        BAIL_ON_FAILURE(hr);

        break;

    default:
        hr = E_FAIL;
        break;
    }

error:
    RRETURN(hr);
}



HRESULT
NtTypeCopyConstruct(
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumObjects,
    LPNTOBJECT * ppNtDestObjects
    )
{

    DWORD i = 0;
    LPNTOBJECT pNtDestObjects = NULL;
    HRESULT hr = S_OK;

    pNtDestObjects = (LPNTOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NTOBJECT)
                                    );

    if (!pNtDestObjects) {
        RRETURN(E_FAIL);
    }

    //
    // Zero out so we can clear the memory on an error
    //

    memset(pNtDestObjects, 0, dwNumObjects * sizeof(NTOBJECT));

    for (i = 0; i < dwNumObjects; i++ ) {
        hr = NtTypeCopy(pNtSrcObjects + i, pNtDestObjects + i);
        BAIL_ON_FAILURE(hr);
    }

    *ppNtDestObjects = pNtDestObjects;

    RRETURN(S_OK);

error:
    //
    // pNtDestObjects is assumed to be non-NULL
    //
    NTTypeFreeNTObjects(pNtDestObjects, dwNumObjects);
    RRETURN(hr);
}


HRESULT
CopyNulledString(
    LPTSTR pszSrcString,
    LPTSTR *ppszDestString
    )

{
    HRESULT hr = S_OK;
    LPTSTR pszPosition = pszSrcString;
    DWORD dwLength = 0 ;
    DWORD dwCurrLen = 0;
    BOOL foundNULL  = FALSE;
    DWORD i;

    ADsAssert(ppszDestString);
    *ppszDestString = NULL;

    if (!pszSrcString)
        RRETURN(S_OK);

    //
    // scan source string looking for 2 successive NULLS
    //

    if(*pszPosition == TEXT('\0')) {
        pszPosition++;
        dwLength++;
    }

    while(*pszPosition != TEXT('\0')){
        dwCurrLen = wcslen(pszPosition) +1;
        dwLength += dwCurrLen;
        pszPosition += dwCurrLen;
    }
    dwLength++;

    *ppszDestString = (LPTSTR)AllocADsMem (dwLength * sizeof(TCHAR));

    if ( !*ppszDestString){
        RRETURN(E_OUTOFMEMORY);
    }

    // copy one character at a time

    for ( i=0; i<dwLength; i++){
        (*ppszDestString)[i] = pszSrcString[i] ;
    }

    RRETURN (hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\property.cxx ===
#include "nwcompat.hxx"
#pragma hdrstop


#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);




HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackStringinVariant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varOutputData);
    RRETURN(hr);

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDATEfromVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT_BOOL pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_VARIANT_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANTinVariant(
            vSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varOutputData);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\ods2nw.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ods2nw.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop



HRESULT
AdsTypeToNTTypeCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNtDestObject->NTType = NT_SYNTAX_ID_LPTSTR;

    lpNtDestObject->NTValue.pszValue =
                        AllocADsStr(
                            lpAdsSrcValue->CaseIgnoreString
                        );
    if ((!lpNtDestObject->NTValue.pszValue) &&
        (lpAdsSrcValue->CaseIgnoreString)) {
        RRETURN(E_OUTOFMEMORY);
    }
    
    RRETURN(hr);

}


HRESULT
AdsTypeToNTTypeCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNtDestObject->NTType = NT_SYNTAX_ID_BOOL;

    lpNtDestObject->NTValue.fValue =
                        lpAdsSrcValue->Boolean;

    RRETURN(hr);
}


HRESULT
AdsTypeToNTTypeCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNtDestObject->NTType = NT_SYNTAX_ID_DWORD;

    lpNtDestObject->NTValue.dwValue =
                                lpAdsSrcValue->Integer;

    RRETURN(hr);
}

HRESULT
AdsTypeToNTTypeCopy(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_CASE_IGNORE_STRING:
        hr = AdsTypeToNTTypeCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpNtDestObject
                );
        break;

    case ADSTYPE_BOOLEAN:
        hr = AdsTypeToNTTypeCopyBoolean(
                lpAdsSrcValue,
                lpNtDestObject
                );
        break;

    case ADSTYPE_INTEGER:
        hr = AdsTypeToNTTypeCopyInteger(
                lpAdsSrcValue,
                lpNtDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
AdsTypeToNTTypeCopyConstruct(
    LPADSVALUE pAdsSrcValues,
    DWORD dwNumObjects,
    LPNTOBJECT * ppNtDestObjects,
    PDWORD pdwNumNdsObjects,
    PDWORD pdwNdsSyntaxId
    )
{

    DWORD i = 0;
    LPNTOBJECT pNtDestObjects = NULL;
    HRESULT hr = S_OK;

    pNtDestObjects = (LPNTOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NTOBJECT)
                                    );

    if (!pNtDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = AdsTypeToNTTypeCopy(
                    pAdsSrcValues + i,
                    pNtDestObjects + i
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppNtDestObjects = pNtDestObjects;
     *pdwNumNdsObjects = dwNumObjects;
     *pdwNdsSyntaxId = pNtDestObjects->NTType;
     RRETURN(S_OK);

error:

     if (pNtDestObjects) {

        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumObjects
                );
     }

     *ppNtDestObjects = NULL;
     *pdwNumNdsObjects = 0;

     RRETURN(hr);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\nwtypes.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nttypes.h
//
//  Contents:    Types for generic Get and Put
//
//  Functions:
//
//
//  History:      14-June-1996   RamV   Cloned off nds code.
//
//----------------------------------------------------------------------------

//
// various values of NT types
//

#define NT_SYNTAX_ID_BOOL                     1
#define NT_SYNTAX_ID_SYSTEMTIME               2
#define NT_SYNTAX_ID_DWORD                    3
#define NT_SYNTAX_ID_LPTSTR                   4
#define NT_SYNTAX_ID_DelimitedString          5
#define NT_SYNTAX_ID_NulledString             6
#define NT_SYNTAX_ID_DATE                     7 // internally treated as DWORD
#define NT_SYNTAX_ID_NW312DATE                8
#define NT_SYNTAX_ID_OCTETSTRING              9

typedef struct _octetstring {
    DWORD dwSize;
    BYTE *pByte;
} OctetString;

typedef struct _nttype{
    DWORD NTType;
    union {
        DWORD dwValue;
        LPTSTR pszValue;
        SYSTEMTIME stSystemTimeValue;
        BOOL       fValue;
        BYTE       Nw312Date[6];
        OctetString octetstring;
    }NTValue;

    //
    // for both Delimited and Nulled Strings we use pszValue
    //
}NTOBJECT, *PNTOBJECT, *LPNTOBJECT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\nwumrshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nwumrshl.cxx
//
//  Contents:
//
//  Functions:
//
//
//  History:      17-June-1996   KrishnaG   Cloned off NDS.
//
//
//  Notes :
//
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma  hdrstop

HRESULT
NTTypeInit(
    PNTOBJECT pNtType
    )
{
    memset(pNtType, 0, sizeof(NTOBJECT));

    RRETURN(S_OK);
}


HRESULT
NTTypeClear(
    PNTOBJECT pNtObject
    )
{
    if(!pNtObject)
        RRETURN(S_OK);

    switch (pNtObject->NTType) {
    case NT_SYNTAX_ID_LPTSTR:
    case NT_SYNTAX_ID_DelimitedString:
        FreeADsStr((pNtObject->NTValue).pszValue);
        break;
    case NT_SYNTAX_ID_NulledString:
        FreeADsMem((pNtObject->NTValue).pszValue);
        break;
    case NT_SYNTAX_ID_OCTETSTRING:
        FreeADsMem((pNtObject->NTValue).octetstring.pByte);
        break;
    default:
        break;
    }
    RRETURN(S_OK);
}


void
NTTypeFreeNTObjects(
    PNTOBJECT pNtObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumValues; i++ ) {
         NTTypeClear(pNtObject + i);
    }

    FreeADsMem(pNtObject);

    return;
}


HRESULT
CopyDWORDToNTOBJECT(
    PDWORD pdwSrcValue,
    PNTOBJECT lpNtDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpNtDestValue){
        RRETURN(E_POINTER);
    }

    lpNtDestValue->NTType = NT_SYNTAX_ID_DWORD;
    (lpNtDestValue->NTValue).dwValue = *pdwSrcValue;

    RRETURN(hr);

}

HRESULT
CopyDATEToNTOBJECT(
    PDWORD pdwSrcValue,
    PNTOBJECT lpNtDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpNtDestValue){
        RRETURN(E_POINTER);
    }

    lpNtDestValue->NTType = NT_SYNTAX_ID_DATE;
    (lpNtDestValue->NTValue).dwValue = *pdwSrcValue;

    RRETURN(hr);

}


HRESULT
CopyNw312DATEToNTOBJECT(
    PBYTE pbyDateTime,
    PNTOBJECT lpNtDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpNtDestValue){
        RRETURN(E_POINTER);
    }

    lpNtDestValue->NTType = NT_SYNTAX_ID_NW312DATE;
    memcpy((lpNtDestValue->NTValue).Nw312Date, pbyDateTime, 6);

    RRETURN(hr);

}






HRESULT
CopyBOOLToNTOBJECT(
    PBOOL pfSrcValue,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }


    lpNtObject->NTType = NT_SYNTAX_ID_BOOL;

    (lpNtObject->NTValue).fValue = *pfSrcValue;

    RRETURN(S_OK);

}


HRESULT
CopySYSTEMTIMEToNTOBJECT(
    PSYSTEMTIME pSysTime,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    (lpNtObject->NTValue).stSystemTimeValue = *pSysTime;
    lpNtObject->NTType = NT_SYNTAX_ID_SYSTEMTIME;

    RRETURN(S_OK);
}

HRESULT
CopyLPTSTRToNTOBJECT(
    LPTSTR   pszSrcValue,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    lpNtObject->NTType = NT_SYNTAX_ID_LPTSTR;

    if(!pszSrcValue){
        (lpNtObject->NTValue). pszValue = NULL;
    } else {

        (lpNtObject->NTValue). pszValue = AllocADsStr(pszSrcValue);
        if (!((lpNtObject->NTValue). pszValue)){
            RRETURN(E_OUTOFMEMORY);
        }
    }

    RRETURN(S_OK);
}

HRESULT
CopyOctetToNTOBJECT(
    PBYTE   pOctetString,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    lpNtObject->NTType = NT_SYNTAX_ID_OCTETSTRING;

    if(!pOctetString){
        (lpNtObject->NTValue).octetstring.dwSize = 0;
        (lpNtObject->NTValue).octetstring.pByte = NULL;
    } else {
        OctetString *pOctString = (OctetString*)pOctetString;
        (lpNtObject->NTValue).octetstring.dwSize = pOctString->dwSize;
        (lpNtObject->NTValue).octetstring.pByte = (BYTE*)AllocADsMem(sizeof(BYTE)*pOctString->dwSize);
        if (!(lpNtObject->NTValue).octetstring.pByte) {
            RRETURN(E_OUTOFMEMORY);
        }
        memcpy((lpNtObject->NTValue).octetstring.pByte, pOctString->pByte,pOctString->dwSize);
    }

    RRETURN(S_OK);
}


HRESULT
CopyDelimitedStringToNTOBJECT(
    LPTSTR   pszSrcValue,
    PNTOBJECT lpNtObject
    )
{
    if(!pszSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    lpNtObject->NTType = NT_SYNTAX_ID_DelimitedString;
    (lpNtObject->NTValue). pszValue = AllocADsStr(pszSrcValue);

    if (!((lpNtObject->NTValue). pszValue)){
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(S_OK);
}


HRESULT
CopyNulledStringToNTOBJECT(
    LPTSTR   pszSrcValue,
    PNTOBJECT lpNtObject
    )
{
    HRESULT hr = S_OK;

    if(!pszSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    lpNtObject->NTType = NT_SYNTAX_ID_NulledString;

    hr = CopyNulledString (pszSrcValue,
                           &((lpNtObject->NTValue). pszValue) );

    if (FAILED(hr)){
        RRETURN(hr);
    }
    RRETURN(S_OK);
}


HRESULT
CopyNTToNTSynId(
    DWORD dwSyntaxId,
    LPBYTE lpByte,
    PNTOBJECT lpNTObject
    )
{
    HRESULT hr = S_OK;

    switch (dwSyntaxId) {
    case NT_SYNTAX_ID_BOOL:

        hr = CopyBOOLToNTOBJECT(
                         (PBOOL)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = CopySYSTEMTIMEToNTOBJECT(
                         (PSYSTEMTIME)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DWORD:
        hr = CopyDWORDToNTOBJECT(
                         (PDWORD)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = CopyDATEToNTOBJECT(
                         (PDWORD)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_NW312DATE:
        hr = CopyNw312DATEToNTOBJECT(
                         lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DelimitedString:
        hr = CopyDelimitedStringToNTOBJECT(
                         (LPTSTR)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = CopyNulledStringToNTOBJECT(
                         (LPTSTR)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = CopyLPTSTRToNTOBJECT(
                         (LPTSTR)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = CopyOctetToNTOBJECT(
                         lpByte,
                         lpNTObject
                         );
        break;

    default:
        break;

    }

    RRETURN(hr);
}



//
//  NT is always single-valued!!
//

HRESULT
UnMarshallNTToNTSynId(
    DWORD dwSyntaxId,
    DWORD dwNumValues,
    LPBYTE lpValue,
    PNTOBJECT * ppNTObject
    )
{
    LPBYTE lpByte = lpValue;
    DWORD  i = 0;
    PNTOBJECT pNTObject = NULL;
    HRESULT hr = S_OK;

    pNTObject = (PNTOBJECT)AllocADsMem(
                            sizeof(NTOBJECT)
                            );

    if (!pNTObject) {
        RRETURN(E_FAIL);
    }

    hr = CopyNTToNTSynId(
                     dwSyntaxId,
                     lpByte,
                     pNTObject
                     );
    BAIL_ON_FAILURE(hr);


    *ppNTObject = pNTObject;
    RRETURN(hr);

error:
    if (pNTObject) {
        FreeADsMem(pNTObject);
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\parse.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  parse.cxx
//
//  Contents:  Windows NT 3.5 GetObject functionality
//
//  History:
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop

KWDLIST KeywordList[MAX_KEYWORDS] =
{
    { TOKEN_DOMAIN, L"domain"},
    { TOKEN_USER, L"user"},
    { TOKEN_GROUP, L"group"},
    { TOKEN_COMPUTER, L"computer"},
    { TOKEN_PRINTER, L"printqueue"},
    { TOKEN_SERVICE, L"service"},
    { TOKEN_FILESERVICE, L"fileservice"},
    { TOKEN_FILESHARE, L"fileshare"},
    { TOKEN_NAMESPACE, L"namespace"},
    { TOKEN_SCHEMA, L"schema"},
    { TOKEN_CLASS,  L"class"},
    { TOKEN_PROPERTY, L"property"},
    { TOKEN_SYNTAX, L"syntax" }
};

WCHAR *  szProviderName  = L"NWCOMPAT";


// Object -> PathName, Type, eos
// Object -> PathName, eos

//+---------------------------------------------------------------------------
//  Function:
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Object(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = ProviderName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);


    switch (dwToken) {
    case TOKEN_END:
        RRETURN(S_OK);

    case TOKEN_COMMA:
        hr = Type(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);
        if (dwToken == TOKEN_END) {
            RRETURN(S_OK);
        }else {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    default:
        hr = pTokenizer->PushBackToken();

        hr = DsPathName(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        switch (dwToken) {
        case TOKEN_END:
            RRETURN(S_OK);

        case TOKEN_COMMA:
            hr = Type(pTokenizer, pObjectInfo);
            BAIL_IF_ERROR(hr);
            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);
            if (dwToken == TOKEN_END) {
                RRETURN(S_OK);
            }else {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

        default:
            RRETURN(E_FAIL);

        }

    }

cleanup:
    RRETURN(hr);
}



HRESULT
ProviderName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_ATSIGN) {

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_EXCLAMATION) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else if (dwToken == TOKEN_IDENTIFIER) {

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_COLON) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // You can now disable the processing for "@" and "!" treat them
    // as ordinary characters.
    //

    pTokenizer->SetAtDisabler(TRUE);


    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}


// PathName -> Component \\ PathName
// PathName -> Component

HRESULT
DsPathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
PathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    HRESULT hr;
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;

    hr = Component(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);

    if (dwToken == TOKEN_FSLASH) {
        RRETURN (PathName(pTokenizer, pObjectInfo));
    }else {
        hr = pTokenizer->PushBackToken();
        RRETURN (S_OK);
    }
cleanup:
    RRETURN(hr);
}

// Component -> <identifier>





//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Component(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    WCHAR szDisplayToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, szDisplayToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = AddComponent(pObjectInfo, szToken, szDisplayToken);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);
cleanup:
    RRETURN(hr);
}

// Type -> "user", "group","printer","service"

//+---------------------------------------------------------------------------
// Function:    Type
//
// Synopsis:    Parses Type-> "user" | "group" etc
//
// Arguments:   [CLexer * pTokenizer]
//              [POBJECTINFo pObjectInfo]
//
// Returns:     HRESULT
//
// Modifies:    -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------


HRESULT
Type(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_PATH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_IDENTIFIER ) {
        if (pTokenizer->IsKeyword(szToken, &dwToken)) {
            hr = SetType(pObjectInfo, dwToken);
            RRETURN(hr);
        }
    }

    RRETURN(E_FAIL);

cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLexer::CLexer(LPWSTR szBuffer):
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _bAtDisabled(FALSE)
{
    if (!szBuffer || !*szBuffer) {
        return;
    }
    _Buffer = AllocADsStr(szBuffer);
    _ptr = _Buffer;
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    08-12-96   t-danal     Created.
//
//----------------------------------------------------------------------------
CLexer::~CLexer()
{
    FreeADsStr(_Buffer);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPWSTR szDisplayToken, LPDWORD pdwToken)
{
    WCHAR c;
    DWORD state = 0;
    LPWSTR pch = szToken;
    LPWSTR pDisplayCh = szDisplayToken;
    BOOL fEscapeOn = FALSE, fQuotingOn = FALSE;

    memset(szToken, 0, sizeof(WCHAR) * MAX_TOKEN_LENGTH);

    if (szDisplayToken) {
        memset(szDisplayToken, 0, sizeof(TCHAR) * MAX_TOKEN_LENGTH);
    }

    _dwLastTokenLength = 0;
    while (1) {
        c = NextChar();
        switch (state) {
        case  0:
            *pch++ = c;
            _dwLastTokenLength++;

            if (c == TEXT('"')) {
                //
                // Quoting; 
                //

                fQuotingOn = TRUE;

                pch--;
                state = 1;
                
            }else if (c == TEXT('\\')) {
                //
                // Escaping; Ignore the '\' in the token and check to make 
                // sure that the next character exists
                //
                pch--;

                fEscapeOn = TRUE;

                state = 1;

            }else if (c == L'/') {
                *pdwToken = TOKEN_FSLASH;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L',') {
                *pdwToken = TOKEN_COMMA;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L':'){
                if (!_bAtDisabled) {
                    *pdwToken = TOKEN_COLON;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }else {
                    state = 1;
                }
            }else if (c == TEXT('<')) {
                RRETURN(E_FAIL);
            }else if (c == TEXT('>')) {
                RRETURN(E_FAIL);
            }else if (c == L'\0'){
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'@') {

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_ATSIGN;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else if (c == L'!'){

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_EXCLAMATION;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else {

                state = 1;
            }
            break;


        case 1:
            if ((fEscapeOn || fQuotingOn) && c == TEXT('\0') ) {
                RRETURN(E_FAIL);
            }
            else if (fEscapeOn) {
                fEscapeOn = FALSE;
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
            else if (fQuotingOn) {
                if (c == TEXT('"')) {
                    fQuotingOn = FALSE;
                }
                *pch++ = c;
                _dwLastTokenLength++;
                break;
            }
            else if (c == TEXT('\\') ) {
                fEscapeOn = TRUE;
                _dwLastTokenLength++;

                break;

            }
            else if (c == TEXT('"')) {
                fQuotingOn = TRUE;
                _dwLastTokenLength++;
                break;
            }
            if (c == L'\0' || c == L',' || c == L'/') {
                PushbackChar();

                *pdwToken = TOKEN_IDENTIFIER;
                _dwLastToken = *pdwToken;
                RRETURN (S_OK);
            }else if (c == L'@' || c == L'!' || c == L':') {

                if (!_bAtDisabled) {

                    PushbackChar();

                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {

                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                    break;

                }
            }else {
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
        default:
            RRETURN(E_FAIL);
        }

        if (pDisplayCh) {
            *pDisplayCh++ = c;
        }

    }
}

HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPDWORD pdwToken)
{
    RRETURN (GetNextToken(szToken, NULL, pdwToken));
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
WCHAR
CLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::PushBackToken()
{
    if (_dwLastToken == TOKEN_END) {
        RRETURN(S_OK);
    }
    _ptr -= _dwLastTokenLength;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
BOOL
CLexer::IsKeyword(LPWSTR szToken, LPDWORD pdwToken)
{
    DWORD i = 0;

    for (i = 0; i < MAX_KEYWORDS; i++) {
        if (!_wcsicmp(szToken, KeywordList[i].Keyword)) {
            *pdwToken = KeywordList[i].dwTokenId;
            return(TRUE);
        }
    }
    *pdwToken = 0;
    return(FALSE);
}


//+---------------------------------------------------------------------------
//Function:
//
//Synopsis:
//
//Arguments:
//
//Returns:
//
//Modifies:
//
//History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
AddComponent(POBJECTINFO pObjectInfo, LPWSTR szToken, LPWSTR szDisplayToken)
{
    if (!szToken || !*szToken) {
    }
    pObjectInfo->ComponentArray[pObjectInfo->NumComponents] =
                    AllocADsStr(szToken);

    pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents] =
                    AllocADsStr(szToken);
                
    pObjectInfo->NumComponents++;

    RRETURN(S_OK);

}

HRESULT
AddProviderName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->ProviderName = AllocADsStr(szToken);

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
SetType(POBJECTINFO pObjectInfo, DWORD dwToken)
{
    pObjectInfo->ObjectType = dwToken;
    RRETURN(S_OK);
}


void
CLexer::SetAtDisabler(
    BOOL bFlag
    )
{
    _bAtDisabled = bFlag;
}

BOOL
CLexer::GetAtDisabler()
{
    return(_bAtDisabled);
}

HRESULT
GetDisplayName(
    LPWSTR szName,
    LPWSTR *ppszDisplayName
    )
{

    HRESULT hr = S_OK;
    DWORD len = 0;
    LPWSTR pch = szName;
    LPWSTR pszDisplayCh = NULL, pszDisplay = NULL;
    BOOL fQuotingOn = FALSE;

    if (!ppszDisplayName ) {
        RRETURN (E_INVALIDARG);
    }

    *ppszDisplayName = NULL;

    if (!szName) {
        RRETURN (S_OK);
    }

    pch = szName;
    fQuotingOn = FALSE;

    for (len=0; *pch; pch++, len++) {
        if ((!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'"') ) {
            fQuotingOn = ~fQuotingOn;
        }
        else if (!fQuotingOn && (!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'/' || *pch == L'<' || *pch == L'>') ) {
            len++;
        }
    }

    pszDisplay = (LPWSTR) AllocADsMem((len+1) * sizeof(WCHAR));

    if (!pszDisplay) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pch = szName; 
    pszDisplayCh = pszDisplay;
    fQuotingOn = FALSE;

    for (; *pch; pch++, pszDisplayCh++) {
        if ((!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'"') ) {
            fQuotingOn = ~fQuotingOn;
        }
        else if (!fQuotingOn && (!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'/' || *pch == L'<' || *pch == L'>') ) {
            *pszDisplayCh++ = L'\\';
        }
        *pszDisplayCh = *pch;
    }

    *pszDisplayCh = L'\0';

    *ppszDisplayName = pszDisplay;

error:

    RRETURN(hr);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\var2nw.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       var2nw.cxx
//
//  Contents:
//
//  Functions:
//
//  History:      13-June-1996   KrishnaG Created.
//
//
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma  hdrstop


//
// WinNT objects copy code
//

HRESULT
VarTypeToWinNTTypeCopyBOOL(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpVarSrcObject){
        RRETURN(E_POINTER);
    }

    if(lpVarSrcObject->vt != VT_BOOL){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_BOOL;

    if(lpVarSrcObject->boolVal){
        (pNTDestValue->NTValue).fValue = TRUE;

    } else {
        (pNTDestValue->NTValue).fValue = FALSE;
    }

    RRETURN(hr);
}

HRESULT
VarTypeToWinNTTypeCopySYSTEMTIME(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpVarSrcObject){
        RRETURN(E_POINTER);
    }

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = ConvertDATEToSYSTEMTIME(lpVarSrcObject->date,
                                 &(pNTDestValue->NTValue.stSystemTimeValue) );


    RRETURN( hr );
}


HRESULT
VarTypeToWinNTTypeCopyDWORD(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_I4){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_DWORD;

    (pNTDestValue->NTValue).dwValue = (DWORD)lpVarSrcObject->lVal;
    RRETURN(hr);

}

HRESULT
VarTypeToWinNTTypeCopyDATE(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME stTime;

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_DATE;

    //
    // Note carefully! date is supplied as a value which is < 1 however
    // VariantTimeToDosDateTime complains when given a value < 30000.
    // (Number of days between 1900 and 1980). So
    // we add 35000 to make it a legal value.
    //

    hr = ConvertDATEToSYSTEMTIME(lpVarSrcObject->date+ 35000,
                                 &stTime);

    BAIL_ON_FAILURE(hr);

    (pNTDestValue->NTValue).dwValue = stTime.wHour*60 + stTime.wMinute ;


error:
    RRETURN(hr);

}

HRESULT
VarTypeToWinNTTypeCopyNW312DATE(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME stTime;

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_NW312DATE;

    hr = ConvertVariantToNW312Date(
                lpVarSrcObject->date,
                pNTDestValue->NTValue.Nw312Date
                );
    BAIL_ON_FAILURE(hr);


error:
    RRETURN(hr);

}

HRESULT
VarTypeToWinNTTypeCopyLPTSTR(
    PVARIANT lpVarSrcObject,
    PNTOBJECT   pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_LPTSTR;

    (pNTDestValue->NTValue).pszValue =
        AllocADsStr(lpVarSrcObject->bstrVal);

    if(!(pNTDestValue->NTValue).pszValue){
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
VarTypeToWinNTTypeCopyDelimitedString(
    PVARIANT lpVarSrcObject,
    PNTOBJECT   pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if (!(V_VT(lpVarSrcObject) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }


    pNTDestValue->NTType = NT_SYNTAX_ID_DelimitedString;

    hr = VariantToDelimitedString(*lpVarSrcObject,
                                  &((pNTDestValue->NTValue).pszValue),
                                  TEXT(','));

    RRETURN(hr);
}

HRESULT
VarTypeToWinNTTypeCopyOctetString(
    PVARIANT lpVarSrcObject,
    PNTOBJECT   pNTDestValue
    )
{
    HRESULT hr = S_OK;

    pNTDestValue->NTType = NT_SYNTAX_ID_OCTETSTRING;
    hr = VariantToBinary(
            lpVarSrcObject,
            &(pNTDestValue->NTValue).octetstring.dwSize,
            &(pNTDestValue->NTValue).octetstring.pByte);

    RRETURN(hr);
}


HRESULT
VarTypeToWinNTTypeCopyNulledString(
    PVARIANT lpVarSrcObject,
    PNTOBJECT   pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(!(V_VT(lpVarSrcObject) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_NulledString;

    hr = VariantToNulledString(*lpVarSrcObject,
                                  &((pNTDestValue->NTValue).pszValue) );

    RRETURN(hr);
}

HRESULT
VarTypeToNtTypeCopy(
    DWORD dwNtType,
    PVARIANT lpVarSrcObject,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;
    switch (dwNtType){
    case NT_SYNTAX_ID_BOOL:
        hr = VarTypeToWinNTTypeCopyBOOL(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = VarTypeToWinNTTypeCopySYSTEMTIME(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;


    case NT_SYNTAX_ID_DWORD:
        hr = VarTypeToWinNTTypeCopyDWORD(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = VarTypeToWinNTTypeCopyDATE(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;


    case NT_SYNTAX_ID_NW312DATE:
        hr = VarTypeToWinNTTypeCopyNW312DATE(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;



    case NT_SYNTAX_ID_LPTSTR:
        hr = VarTypeToWinNTTypeCopyLPTSTR(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;

    case NT_SYNTAX_ID_DelimitedString:
        hr = VarTypeToWinNTTypeCopyDelimitedString(
                 lpVarSrcObject,
                 lpNtDestObject
                 );
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = VarTypeToWinNTTypeCopyNulledString(
                 lpVarSrcObject,
                 lpNtDestObject
                 );
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = VarTypeToWinNTTypeCopyOctetString(
                 lpVarSrcObject,
                 lpNtDestObject
                 );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
VarTypeToNtTypeCopyConstruct(
    DWORD dwNtType,
    LPVARIANT pVarSrcObjects,
    DWORD dwNumObjects,
    LPNTOBJECT * ppNtDestObjects
    )
{

    DWORD i = 0;
    LPNTOBJECT pNtDestObjects = NULL;
    HRESULT hr = S_OK;

    pNtDestObjects = (LPNTOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NTOBJECT)
                                    );

    if (!pNtDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {

         hr = VarTypeToNtTypeCopy(
                    dwNtType,
                    pVarSrcObjects + i,
                    pNtDestObjects + i
                    );

         BAIL_ON_FAILURE(hr);
     }

     *ppNtDestObjects = pNtDestObjects;

     RRETURN(S_OK);

error:

    if (pNtDestObjects) {

        FreeADsMem(pNtDestObjects);
    }

    *ppNtDestObjects = NULL;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\usrutils.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      usrutils.cxx
//
//  Contents:  NetWare compatible UserCollection Enumeration Code
//
//  History:   22-Mar-96    t-ptam (PatrickT) migrated from KrishnaG for NetWare
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop

USER_GROUP_ENTRY UserGroupEntry;

//
// This assumes that addr is an LPBYTE type.
//

#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((DWORD)addr & ~1))

DWORD UserGrpEntryStrings[]=
                             {
                             FIELD_OFFSET(USER_GROUP_ENTRY, Parent),
                             FIELD_OFFSET(USER_GROUP_ENTRY, Computer),
                             FIELD_OFFSET(USER_GROUP_ENTRY, Name),
                             0xFFFFFFFF
                             };

DECLARE_INFOLEVEL(UsrUt)
DECLARE_DEBUG(UsrUt)
#define UsrUtDebugOut(x) UsrUtInlineDebugOut x

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerUserOpen
//
//  Synopsis: This function opens a handle to a INI_COMP_USER structure.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerUserOpen(
    LPWSTR szComputerName,
    LPWSTR szGroupName,
    PHANDLE phUser
    )
{
    WCHAR szTempBuffer[MAX_PATH];
    PINI_COMP_USER pIniCompUsr;
    HRESULT hr = S_OK;

    if (!phUser) {
        return(FALSE);
    }

    pIniCompUsr = (PINI_COMP_USER)AllocADsMem(
                                       sizeof(INI_COMP_USER)
                                       );
    if (!pIniCompUsr) {
        return(FALSE);
    }

    //
    // Fill structure's fields.
    //

    if (!(pIniCompUsr->szComputerName =  AllocADsStr(szComputerName))){
        goto error;
    }

    if (!(pIniCompUsr->szGroupName = AllocADsStr(szGroupName))){
        goto error;
    }

    hr = NWApiGetBinderyHandle(
             &pIniCompUsr->_hConn,
             szComputerName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return
    //

    *phUser =  (HANDLE)pIniCompUsr;

    return(TRUE);


error:
    if (pIniCompUsr) {
        FreeIniCompUser(pIniCompUsr);
    }

    *phUser = NULL;

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerUserEnum
//
//  Synopsis: This function returns a buffer which contains all the binding
//            informations for the requested number of objects without any
//            references.
//            It returns TRUE iff dwReturned = dwRequested.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerUserEnum(
    HANDLE hUser,
    DWORD  dwRequested,
    LPBYTE * ppBuffer,
    PDWORD pdwReturned
    )
{
    LPUSER_GROUP_ENTRY * ppUserMembers = NULL;
    DWORD i = 0;
    BOOL dwRet = FALSE;
    DWORD dwReturned = 0;
    DWORD dwSize = 0;
    LPUSER_GROUP_ENTRY pBuffer = NULL;
    LPBYTE pEnd = NULL;

    //
    // Allocate buffer for the number of requested members.
    //

    ppUserMembers = (LPUSER_GROUP_ENTRY *)AllocADsMem(
                                                    sizeof(LPUSER_GROUP_ENTRY)* dwRequested
                                                    );
    if (!ppUserMembers) {
        return(FALSE);
    }

    //
    // Fill in ppUserMembers one by one.
    //

    for (i = 0; i < dwRequested; i++) {

        dwRet = NWCOMPATComputerUserGetObject(
                    hUser,
                    &ppUserMembers[i]
                    );
        if (!dwRet) {
            break;
        }
    }

    if (dwRet) {
        dwReturned = i;

        //
        // Determine actual size of ppUserMembers[], ie. since each string in
        // USER_GROUP_ENTRY have a different length, a buffer that is going
        // to contain all the data without any references is unknown.
        //

        dwRet = ComputeComputerUserDataSize(
                    ppUserMembers,
                    dwReturned,
                    &dwSize
                    );

        pBuffer = (LPUSER_GROUP_ENTRY)AllocADsMem(
                                               dwSize
                                               );
        if (!pBuffer) {
            goto error;
        }

        pEnd = (LPBYTE)((LPBYTE)(pBuffer) + dwSize);

        //
        // Put data into pBuffer, starting from the end.
        //

        for (i = 0; i < dwReturned; i++) {

            pEnd = CopyIniCompUserToCompUser(
                       ppUserMembers[i],
                       (LPBYTE)(pBuffer + i),
                       pEnd
                       );
        }

        //
        // Clean up.
        //

        for (i = 0; i < dwReturned; i++ ) {
            FreeIntCompUser(*(ppUserMembers + i));
        }

        //
        // Return values.
        //

        *ppBuffer = (LPBYTE)pBuffer;
        *pdwReturned  = dwReturned;
    }

    FreeADsMem(ppUserMembers);

    if (dwReturned == dwRequested){
        return(TRUE);
    }else {
        return(FALSE);
    }

error:

    for (i = 0; i < dwReturned; i++ ) {
        FreeIntCompUser(*(ppUserMembers + i));
    }
    
    FreeADsMem(ppUserMembers);
    
    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerUserGetObject
//
//  Synopsis: This function returns binding information of a user (group member)
//            object one by one.  In its first call, it builds a buffer that
//            contains all the UserID of the group members.  Then, and in
//            subsequent calls, this UserID is translated into a user name.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerUserGetObject(
    HANDLE hUser,
    LPUSER_GROUP_ENTRY * ppUserMember
    )
{
    BOOL            dwRet = FALSE;
    DWORD           dwGroupId = 0;
    HRESULT         hr = S_OK;
    PINI_COMP_USER pIniCompUsr = (PINI_COMP_USER)hUser;

    //
    // Fill buffer with User ID.  NetWare returns all UserID in one call.
    //

    if (!pIniCompUsr->_pBuffer) {

        pIniCompUsr->_dwCurrentObject = 0;

        hr = NWApiUserGetGroups(
                 pIniCompUsr->_hConn,
                 pIniCompUsr->szGroupName,
                 &(pIniCompUsr->_pBuffer)
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Build one group member.
    //

    dwGroupId = *((LPDWORD)pIniCompUsr->_pBuffer + pIniCompUsr->_dwCurrentObject);

    if (dwGroupId != 0x0000) {

        dwRet = BuildComputerUserMember(
                    hUser,
                    dwGroupId,
                    ppUserMember
                    );
        if (!dwRet) {
            goto error;
        }

        pIniCompUsr->_dwCurrentObject++;

        return(TRUE);
    }

error:

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerUserClose
//
//  Synopsis: Wrapper of FreeIniCompUser.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerUserClose(
    HANDLE hUser
    )
{
    PINI_COMP_USER pIniCompUsr = (PINI_COMP_USER)hUser;

    if (pIniCompUsr) {
        FreeIniCompUser(pIniCompUsr);
    }
    return(TRUE);
}

//----------------------------------------------------------------------------
//
//  Function: FreeIniCompUser
//
//  Synopsis: Free an INI_COMP_USER structure.
//
//----------------------------------------------------------------------------
void
FreeIniCompUser(
    PINI_COMP_USER pIniCompUsr
    )
{
    HRESULT hr = S_OK;

    if (pIniCompUsr) {

        if (pIniCompUsr->szComputerName) {
            FreeADsStr(pIniCompUsr->szComputerName);
        }

        if (pIniCompUsr->szGroupName) {
            FreeADsStr(pIniCompUsr->szGroupName);
        }

        if (pIniCompUsr->_pBuffer) {
            FreeADsMem(pIniCompUsr->_pBuffer);
        }

        if (pIniCompUsr->_hConn) {
            hr = NWApiReleaseBinderyHandle(pIniCompUsr->_hConn);
        }

        FreeADsMem(pIniCompUsr);
    }

    return;
}

//----------------------------------------------------------------------------
//
//  Function: FreeIntCompUser
//
//  Synopsis: Free a USER_GROUP_ENTRY structure.
//
//----------------------------------------------------------------------------
void
FreeIntCompUser(
    LPUSER_GROUP_ENTRY pCompUserMember
    )
{
    if (pCompUserMember) {

        if (pCompUserMember->Parent) {
            FreeADsStr(pCompUserMember->Parent);
        }

        if (pCompUserMember->Computer) {
            FreeADsStr(pCompUserMember->Computer);
        }

        if (pCompUserMember->Name) {
            FreeADsStr(pCompUserMember->Name);
        }

        FreeADsMem(pCompUserMember);
    }

    return;
}

//----------------------------------------------------------------------------
//
//  Function: ComputeComputerUserDataSize
//
//  Synopsis: Calculate the size of a buffer that is going to store the data in
//            ppUserMembers without any references.
//
//----------------------------------------------------------------------------
BOOL
ComputeComputerUserDataSize(
        LPUSER_GROUP_ENTRY * ppUserMembers,
        DWORD  dwReturned,
        PDWORD pdwSize
        )
{

    DWORD i = 0;
    DWORD cb = 0;
    LPUSER_GROUP_ENTRY pMember = NULL;

    for (i = 0; i < dwReturned; i++) {

        pMember = *(ppUserMembers + i);

        cb += sizeof(USER_GROUP_ENTRY);

        if (pMember->Parent) {
            cb += wcslen(pMember->Parent)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Computer) {
            cb += wcslen(pMember->Computer)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Name) {
            cb += wcslen(pMember->Name)*sizeof(WCHAR) + sizeof(WCHAR);
        }
    }

    *pdwSize = cb;
    return(TRUE);
}

//------------------------------------------------------------------------------
//
//  Function: CopyIniCompUserToCompUser
//
//  Synopsis: Pack referenced data (string) into a buffer without any reference.
//
//------------------------------------------------------------------------------
LPBYTE
CopyIniCompUserToCompUser(
    LPUSER_GROUP_ENTRY  pIntCompGrp,
    LPBYTE  pExtCompGrp,
    LPBYTE  pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(USER_GROUP_ENTRY)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings =  SourceStrings;
    LPUSER_GROUP_ENTRY pCompGrpMember = (LPUSER_GROUP_ENTRY)pExtCompGrp;

    memset(SourceStrings, 0, sizeof(USER_GROUP_ENTRY));
    *pSourceStrings++ = pIntCompGrp->Parent;
    *pSourceStrings++ = pIntCompGrp->Computer;
    *pSourceStrings++ = pIntCompGrp->Name;

    pEnd = PackStrings(
                SourceStrings,
                pExtCompGrp,
                UserGrpEntryStrings,
                pEnd
                );

    pCompGrpMember->Type = pIntCompGrp->Type;

    return pEnd;
}

//----------------------------------------------------------------------------
//
//  Function: BuildComputerUserMember
//
//  Synopsis: Put binding information of a group member into ppUserMember.
//
//----------------------------------------------------------------------------
BOOL
BuildComputerUserMember(
    HANDLE hUser,
    DWORD  dwGroupId,
    LPUSER_GROUP_ENTRY * ppUserMember
    )
{
    DWORD                   dwTempUserId = dwGroupId;
    HRESULT                 hr = S_OK;
    LPUSER_GROUP_ENTRY pUserMember = NULL;
    LPINI_COMP_USER        pUser = (LPINI_COMP_USER)hUser;
    WCHAR                   szADsParent[MAX_PATH];

    //
    // Allocate one USER_GROUP_ENTRY.
    //

    pUserMember = (LPUSER_GROUP_ENTRY)AllocADsMem(
                                                sizeof(USER_GROUP_ENTRY)
                                                );
    if (!pUserMember) {
        return(FALSE);
    }

    //
    // Fill structure's fields.
    //

    pUserMember->Type = NWCOMPAT_USER_ID;

    wsprintf(
        szADsParent,
        L"%s://%s",
        szProviderName,
        pUser->szComputerName
        );
    pUserMember->Parent = AllocADsStr(szADsParent);

    pUserMember->Computer = AllocADsStr(pUser->szComputerName);

    hr = NWApiGetObjectName(
             pUser->_hConn,
             dwTempUserId,
             &pUserMember->Name
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    *ppUserMember = pUserMember;
    return(TRUE);

error:

    if (pUserMember) {

        if (pUserMember->Parent)
            FreeADsStr(pUserMember->Parent);

        if (pUserMember->Computer)
            FreeADsStr(pUserMember->Computer);

        FreeADsMem(pUserMember);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\printhlp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      printhlp.cxx
//
//  Contents:  Helper functions for printer object.
//
//  History:   08-May-96    t-ptam (PatrickT) migrated
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma hdrstop

//----------------------------------------------------------------------------
//
//  Function: WinNTEnumJobs
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL
WinNTEnumJobs(
    HANDLE hPrinter,
    DWORD dwFirstJob,
    DWORD dwNoJobs,
    DWORD dwLevel,
    LPBYTE *lplpbJobs,
    DWORD *pcbBuf,
    LPDWORD lpdwReturned
    )
{
    BOOL  fStatus = FALSE;
    DWORD dwNeeded = 0;
    DWORD dwError = 0;

    //
    // Enumerate Jobs using Win32 API.
    //

    fStatus = EnumJobs(
                  hPrinter,
                  dwFirstJob,
                  dwNoJobs,
                  dwLevel,
                  *lplpbJobs,
                  *pcbBuf,
                  &dwNeeded,
                  lpdwReturned
                  );

    //
    // Enumerate for Jobs again with a bigger buffer if a bigger one is needed
    // for the result.
    //

    if (!fStatus) {

        if ((dwError = GetLastError()) == ERROR_INSUFFICIENT_BUFFER) {

            if (*lplpbJobs) {
                FreeADsMem( *lplpbJobs );
            }

            *lplpbJobs = (LPBYTE)AllocADsMem(dwNeeded);

            if (!*lplpbJobs) {
                *pcbBuf = 0;
                return(FALSE);
            }

            *pcbBuf = dwNeeded;

            fStatus = EnumJobs(
                          hPrinter,
                          dwFirstJob,
                          dwNoJobs,
                          dwLevel,
                          *lplpbJobs,
                          *pcbBuf,
                          &dwNeeded,
                          lpdwReturned
                          );

            if (!fStatus) {
                return(FALSE);
            }
            else {
                return(TRUE);
            }
        }
        else {
            return(FALSE);
        }
    }
    else {
        return(TRUE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: WinNTEnumPrinters
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL
WinNTEnumPrinters(
    DWORD  dwType,
    LPTSTR lpszName,
    DWORD  dwLevel,
    LPBYTE *lplpbPrinters,
    LPDWORD lpdwReturned
    )
{
    BOOL   fStatus = FALSE;
    DWORD  dwPassed = 1024;
    DWORD  dwNeeded = 0;
    DWORD  dwError = 0;
    LPBYTE pMem = NULL;

    //
    // Allocate memory for return buffer.
    //

    pMem =  (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        goto error;
    }

    //
    // Enumerate Printers using Win32 API.
    //

    fStatus = EnumPrinters(
                  dwType,
                  lpszName,
                  dwLevel,
                  pMem,
                  dwPassed,
                  &dwNeeded,
                  lpdwReturned
                  );

    //
    // Enumerate for Printers again with a bigger buffer if a bigger one is
    // needed for the result.
    //

    if (!fStatus) {

        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            goto error;
        }

        if (pMem) {
            FreeADsMem(pMem);
        }

        pMem = (LPBYTE)AllocADsMem(
                           dwNeeded
                           );

        if (!pMem) {
            goto error;
        }

        dwPassed = dwNeeded;

        fStatus = EnumPrinters(
                      dwType,
                      lpszName,
                      dwLevel,
                      pMem,
                      dwPassed,
                      &dwNeeded,
                      lpdwReturned
                      );

        if (!fStatus) {
            goto error;
        }
    }

    //
    // Return.
    //

    *lplpbPrinters = pMem;

    return(TRUE);

error:

    if (pMem) {
        FreeADsMem(pMem);
    }

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: WinNTGetPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL
WinNTGetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE *lplpbPrinters
    )
{

    BOOL    fStatus = FALSE;
    DWORD   dwPassed = 1024;
    DWORD   dwNeeded = 0;
    DWORD   dwError = 0;
    LPBYTE  pMem = NULL;

    //
    // Allocate memory for return buffer.
    //

    pMem =  (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        goto error;
    }

    //
    // Get printer's information.
    //

    fStatus = GetPrinter(
                  hPrinter,
                  dwLevel,
                  pMem,
                  dwPassed,
                  &dwNeeded
                  );

    //
    // Get printer's information again with a bigger buffer if a bigger buffer
    // is needed for the result.
    //

    if (!fStatus) {

        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            goto error;
        }

        if (pMem) {
            FreeADsMem(pMem);
        }

        pMem = (LPBYTE)AllocADsMem(
                           dwNeeded
                           );

        if (!pMem) {
            goto error;
        }

        dwPassed = dwNeeded;

        fStatus = GetPrinter(
                      hPrinter,
                      dwLevel,
                      pMem,
                      dwPassed,
                      &dwNeeded
                      );

        if (!fStatus) {
            goto error;
        }
    }

    //
    // Return.
    //

    *lplpbPrinters = pMem;

    return(TRUE);


error:
    if (pMem) {
        FreeADsMem(pMem);
    }

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: GetPrinterInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
GetPrinterInfo(
     THIS_ LPPRINTER_INFO_2 *lplpPrinterInfo2,
     BSTR  bstrPrinterName
     )
{
    //
    // Do a GetPrinter call to bstrPrinterName
    //

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE |
                                              READ_CONTROL};
    DWORD LastError = 0;
    HANDLE hPrinter = NULL;
    LPBYTE pMem = NULL;
    HRESULT hr = S_OK;

    ADsAssert(bstrPrinterName);

    //
    // Open a printer handle.
    //

    fStatus = OpenPrinter(
                  (LPTSTR)bstrPrinterName,
                  &hPrinter,
                  &PrinterDefaults
                  );

    //
    // If access is denied, do it again with a different access right.
    //

    if (!fStatus) {
        LastError = GetLastError();
        switch (LastError) {

        case ERROR_ACCESS_DENIED:
            {
                PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
                fStatus = OpenPrinter(
                              (LPTSTR)bstrPrinterName,
                              &hPrinter,
                              &PrinterDefaults
                              );
                if (fStatus) {
                    break;
                }
            }

        default:
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    //
    // Get printer's info.
    //

    fStatus = WinNTGetPrinter(
                  hPrinter,
                  2,
                  (LPBYTE *)&pMem
                  );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    //
    // Return.
    //

    *lplpPrinterInfo2 = (LPPRINTER_INFO_2)pMem;

cleanup:

    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: Set
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
Set(
    LPPRINTER_INFO_2 lpPrinterInfo2,
    LPTSTR   pszPrinterName
    )
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ALL_ACCESS};
    HANDLE hPrinter = NULL;
    HRESULT hr;

    ADsAssert(pszPrinterName);

    //
    // Open a printer handle.
    //

    fStatus = OpenPrinter(
                  pszPrinterName,
                  &hPrinter,
                  &PrinterDefaults
                  );

    if (!fStatus) {
        goto error;
    }

    //
    // Set printer's data.
    //

    fStatus = SetPrinter(
                  hPrinter,
                  2,
                  (LPBYTE)lpPrinterInfo2,
                  0
                  );

    if (!fStatus) {
        goto error;
    }

    //
    // Return.
    //

    fStatus = ClosePrinter(hPrinter);

    RRETURN(S_OK);

error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);

}

//----------------------------------------------------------------------------
//
//  Function: WinNTDeletePrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
WinNTDeletePrinter(
    POBJECTINFO pObjectInfo
    )
{
    WCHAR szUncServerName[MAX_PATH];
    WCHAR szUncPrinterName[MAX_PATH];
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;

    //
    // Make Unc Name for OpenPrinter.
    //

    MakeUncName(pObjectInfo->ComponentArray[1],
                szUncServerName
                );

    wcscpy(szUncPrinterName, szUncServerName);
    wcscat(szUncPrinterName, L"\\");
    wcscat(szUncPrinterName, (LPTSTR)pObjectInfo->ComponentArray[2]);

    //
    // Open a printer handle.
    //

    fStatus = OpenPrinter(
                  (LPTSTR)szUncPrinterName,
                  &hPrinter,
                  &PrinterDefaults
                  );

    if (!fStatus) {
        goto error;
    }

    //
    // Delete the given printer.
    //

    fStatus = DeletePrinter(hPrinter);

    //
    // Return.
    //

    if (!fStatus) {

        hr = GetLastError();

        fStatus = ClosePrinter(hPrinter);

        goto error;
    }


error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\winnt\nw3login.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nw3login.cxx
//
//  Description:
//          Spin off from nw3utils.cxx because of differences in Win95
//
//  Functions:
//
//  History:      18-Sept-1996   t-felixw Created.
//
//
//  Issues:     
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

CRITICAL_SECTION g_csLoginCritSect;

HRESULT 
NWApiLoginToServer(
    LPWSTR pszServerName,
    LPWSTR pszUserName,
    LPWSTR pszPassword
    )
{
    PNW_CACHED_SERVER pNwServer = pNwCachedServers ;
    DWORD Status ;
    NETRESOURCE netResource ;

    if (!pszServerName)
        return NOERROR ;

    EnterCriticalSection(&g_csLoginCritSect);
    
    while (pNwServer) {
 
        if (_wcsicmp(pszServerName,pNwServer->pszServerName)==0) {
            break ;
        }

        pNwServer = pNwServer->pNextEntry;   
    } 

    if (pNwServer == NULL) {

        //
        // not in list. add connection 
        //

        memset(&netResource, 
            0, 
            sizeof(netResource)
            );

        netResource.lpRemoteName = pszServerName;

        Status = WNetAddConnection2(&netResource,
                     pszUserName,
                     pszPassword,
                     0
                     );

        if (Status) {

            LeaveCriticalSection(&g_csLoginCritSect);
            return(HRESULT_FROM_WIN32(Status));
        }

        if (!(pNwServer = (PNW_CACHED_SERVER)
                  AllocADsMem(sizeof(NW_CACHED_SERVER)))) {

            NWApiLogoffServer(pszServerName) ;
            LeaveCriticalSection(&g_csLoginCritSect);
            return(E_OUTOFMEMORY);
        }

        LPWSTR pszTmp ;
        
        if (!(pszTmp = AllocADsStr(pszServerName))) {

            NWApiLogoffServer(pszServerName) ;
            (void) FreeADsMem(pNwServer) ;
            LeaveCriticalSection(&g_csLoginCritSect);
            return(E_OUTOFMEMORY);
        }

        pNwServer->pszServerName = pszTmp ;
        pNwServer->pNextEntry = pNwCachedServers ;
        pNwCachedServers = pNwServer ;
 
    }

    LeaveCriticalSection(&g_csLoginCritSect);
    return(NOERROR) ;
}


// Because this function is used in a variety of contexts,
// it is the responsibility of the caller to remove the
// server from the list of cached servers (pNwCachedServers)
// if necessary.  This function simply logouts from the server.
HRESULT 
NWApiLogoffServer(
    LPWSTR pszServerName
    )
{
    return(HRESULT_FROM_WIN32(WNetCancelConnection(pszServerName,FALSE))) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\adscopy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       adscopy.cxx
//
//  Contents:   ADS Object Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//              Object Types 6, 13, 16, and 21 are flaky - pay extra attn.
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

//
// ADsType objects copy code
//


HRESULT
ADsTypeCopy(
    PADSVALUE lpADsSrcObject,
    PADSVALUE lpADsDestObject
    )
{
    HRESULT hr = S_OK;

    lpADsDestObject->dwType = lpADsSrcObject->dwType;

    switch (lpADsSrcObject->dwType) {
    
    case    ADSTYPE_DN_STRING:
        lpADsDestObjec->DnString = lpADsSrcObject->DNString;
        break;

    case    ADSTYPE_CASE_EXACT_STRING:
        lpADsDestObjec->CaseExactString = lpADsSrcObject->CaseExactString;
        break;

    case    ADSTYPE_CASE_IGNORE_STRING:
        lpADsDestObjec->CaseIgnoreString = lpADsSrcObject->CaseIgnoreString;
        break;

    case    ADSTYPE_PRINTABLE_STRING:
        lpADsDestObjec->PrintableString = lpADsSrcObject->PrintableString;
        break;

    case    ADSTYPE_NUMERIC_STRING:
        lpADsDestObjec->NumericString = lpADsSrcObject->NumericString;
        break;

    case    ADSTYPE_BOOLEAN:
        lpADsDestObjec->Boolean = lpADsSrcObject->Boolean;
        break;

    case    ADSTYPE_INTEGER:
        lpADsDestObjec->Integer = lpADsSrcObject->Integer;
        break;

    case    ADSTYPE_OCTET_STRING:
        lpADsDestObjec->OctetString.dwLength = lpADsSrcObject->OctetString.dwLength;
        lpADsDestObjec->OctetString.lpValue = AllocADsMem(lpADsSrcObject->OctetString.dwLength);

        if (!lpADsDestObjec->OctetString.lpValue) {
            RRETURN(E_OUTOFMEMORY);
        }                          

        break;

    case    ADSTYPE_UTC_TIME:
        lpADsDestObjec->UTCTime = lpADsSrcObject->UTCTime;
        break;

    case    ADSTYPE_LARGE_INTEGER:
        lpADsDestObjec->LargeInteger = lpADsSrcObject->LargeInteger;
        break;

    case    ADSTYPE_PROV_SPECIFIC:
        lpADsDestObjec->ProviderSpecific.dwLength = lpADsSrcObject->ProviderSpecific.dwLength;
        lpADsDestObjec->ProviderSpecific.lpValue = AllocADsMem(lpADsSrcObject->ProviderSpecific.dwLength);

        if (!lpADsDestObjec->ProviderSpecific.lpValue) {
            RRETURN(E_OUTOFMEMORY);
        }                          

        lpADsDestObjec->DnString = lpADsSrcObject->DNString;
        break;

    case    ADSTYPE_OBJECT_CLASS:
        lpADsDestObjec->ClassName = lpADsSrcObject->ClassName;
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
ADsTypeCopyConstruct(
    LPADSVALUE pADsSrcObjects,
    DWORD dwNumObjects,
    LPADSVALUE * ppADsDestObjects
    )
{

    DWORD i = 0;
    LPADSVALUE pADsDestObjects = NULL;
    HRESULT hr = S_OK;

    pADsDestObjects = (LPADSVALUE)AllocADsMem(
                                    dwNumObjects * sizeof(ADSVALUE)
                                    );

    if (!pADsDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = ADsTypeCopy(pADsSrcObjects + i, pADsDestObjects + i);
     }

     *ppADsDestObjects = pADsDestObjects;

     RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nw312\win95\nw3login.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       nw3login.cxx
//
//  Description:
//          Spinned off from nw3utils.cxx because of differences in Win95
//          Contains routines to login and logoff from servers.
//
//  Functions:
//
//  History:      18-Sept-1996   t-felixw Created.
//
//
//  Issues:     
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

CRITICAL_SECTION g_csLoginCritSect;

DWORD
WideToSz( 
    LPSTR lpszC, 
        LPCWSTR lpszW, 
    INT nSize 
    )
{
    if (!WideCharToMultiByte(CP_ACP,
                             WC_COMPOSITECHECK | WC_SEPCHARS,
                             lpszW,
                             -1,
                             lpszC,
                             nSize,
                             NULL,
                             NULL)) {
        return (GetLastError()) ;
    }
    
    return NO_ERROR ;
};



HRESULT 
NWApiLoginToServer(
    LPWSTR pszServerName,
    LPWSTR pszUserName,
    LPWSTR pszPassword
    )
{
    PNW_CACHED_SERVER pNwServer = pNwCachedServers ;
    DWORD Status ;
    NETRESOURCEA netResource ;
    DWORD nSize;
    LPSTR lpszServerName = NULL;
    LPSTR lpszUserName = NULL;
    LPSTR lpszPassword = NULL;
    HRESULT hrResult = NO_ERROR;    

    if (!pszServerName)
        return NOERROR ;

    EnterCriticalSection(&g_csLoginCritSect);
    
    // Is the code below necessary?
    while (pNwServer) {
        if (_wcsicmp(pszServerName,pNwServer->pszServerName)==0)
            break ;
    } 

    if (pNwServer == NULL) {

        //
        // not in list. add connection 
        //

        memset(&netResource, 
            0, 
            sizeof(netResource)
            );
        
        if (pszServerName) {
            nSize = wcslen(pszServerName) + 1;
            
            if(!(lpszServerName = (LPSTR) AllocADsMem(nSize * sizeof(CHAR) ))) {
                hrResult = E_OUTOFMEMORY;
                goto Exit;
            }
            if (WideToSz(lpszServerName, 
                         pszServerName, 
                         nSize ) != NO_ERROR) {
                hrResult = E_FAIL;
                goto Exit;
            }
        }

        if (pszUserName) {
            nSize = wcslen(pszUserName) + 1;
            
            if(!(lpszUserName = (LPSTR) AllocADsMem(nSize * sizeof(CHAR) ))) {
                hrResult = E_OUTOFMEMORY;
                goto Exit;
            }
            if (WideToSz( lpszUserName, 
                          pszUserName, 
                          nSize ) != NO_ERROR) {
                hrResult = E_FAIL;
                goto Exit;
            }
        }
                                           
        if (pszPassword) {
            nSize = wcslen(pszPassword) + 1;
            
            if(!(lpszPassword = (LPSTR) AllocADsMem(nSize * sizeof(CHAR) ))) {
                hrResult = E_OUTOFMEMORY;
                goto Exit;
                }
            if (WideToSz( lpszPassword, 
                          pszPassword, 
                          nSize ) != NO_ERROR) {
                hrResult = E_FAIL;
                goto Exit;
            }
        }
                                           
                
        netResource.lpRemoteName = (LPSTR)lpszServerName;

        Status = WNetAddConnection2A( &netResource,
                                      lpszUserName,
                                      lpszPassword,
                                      0 );

        if (Status) {   
            // FAILURE
            hrResult = HRESULT_FROM_WIN32(Status);
            goto Exit;
        }

        if (!(pNwServer = (PNW_CACHED_SERVER)
                        AllocADsMem(sizeof(NW_CACHED_SERVER)))) {
            NWApiLogoffServer(pszServerName) ;
            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }

        LPWSTR pszTmp ;
        
        if (!(pszTmp = AllocADsStr(pszServerName))) {
            NWApiLogoffServer(pszServerName) ;
            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }

        pNwServer->pszServerName = pszTmp ;
        pNwServer->pNextEntry = pNwCachedServers ;
        pNwCachedServers = pNwServer ;
Exit:
    if (lpszServerName)
        FreeADsMem(lpszServerName);
    if (lpszUserName)
        FreeADsMem(lpszUserName);
    if (lpszPassword)
        FreeADsMem(lpszPassword);
    // Not necessary to free pszTmp cuz it is the last one
    if (hrResult != NO_ERROR) {
        if (pNwServer)
            FreeADsMem(pNwServer);
    }
  }
  LeaveCriticalSection(&g_csLoginCritSect);
  return hrResult;
}


// Because this function is used in a variety of contexts,
// it is the responsibility of the caller to remove the
// server from the list of cached servers (pNwCachedServers)
// if necessary.  This function simply logouts from the server.
HRESULT 
NWApiLogoffServer(
    LPWSTR pszServerName
    )
{
    LPSTR lpszServerName;
    HRESULT hrResult = NOERROR;
    DWORD nSize = wcslen(pszServerName) + 1;
    
    if(!(lpszServerName = (LPSTR) AllocADsMem(nSize * sizeof(CHAR) ))) {
        return(E_FAIL);
    }
    if (WideToSz( lpszServerName, 
                  pszServerName, 
                  nSize ) != NO_ERROR) {
        hrResult = E_FAIL;
        goto Exit;
    }
    
    hrResult = HRESULT_FROM_WIN32(WNetCancelConnectionA(lpszServerName,FALSE));
Exit:
    FreeADsMem(lpszServerName);
    return hrResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cclsobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cclsobj.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//  Class CNDSClass

DEFINE_IDispatch_Implementation(CNDSClass)
DEFINE_IADs_Implementation(CNDSClass)


CNDSClass::CNDSClass():
      _pDispMgr( NULL ),
      _bstrCLSID( NULL ),
      _bstrOID( NULL ),
      _bstrPrimaryInterface( NULL ),
      _bstrHelpFileName( NULL ),
      _lHelpFileContext( 0 ),

      _dwFlags(0),
      _lpClassName(0),
      _dwNumberOfSuperClasses(0),
      _lpSuperClasses(0),
      _dwNumberOfContainmentClasses(0),
      _lpContainmentClasses(0),
      _dwNumberOfNamingAttributes(0),
      _lpNamingAttributes(0),
      _dwNumberOfMandatoryAttributes(0),
      _lpMandatoryAttributes(0),
      _dwNumberOfOptionalAttributes(0),
      _lpOptionalAttributes(0)

{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CNDSClass);
}

HRESULT
CNDSClass::CreateClass(
    BSTR Parent,
    BSTR CommonName,
    LPNDS_CLASS_DEF lpClassDefs,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSClass FAR * pClass = NULL;
    HRESULT hr = S_OK;

    hr = AllocateClassObject(Credentials, &pClass);
    BAIL_ON_FAILURE(hr);

    hr = pClass->InitializeCoreObject(
                Parent,
                CommonName,
                CLASS_CLASS_NAME,
                L"",
                CLSID_NDSClass,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = pClass->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pClass->_Credentials = Credentials;

    pClass->_dwFlags = lpClassDefs->dwFlags;

    pClass->_dwNumberOfSuperClasses =
                    lpClassDefs->dwNumberOfSuperClasses;
    pClass->_lpSuperClasses = CreatePropertyList(
                                    lpClassDefs->lpSuperClasses
                                    );

    pClass->_dwNumberOfContainmentClasses =
                    lpClassDefs->dwNumberOfContainmentClasses;
    pClass->_lpContainmentClasses = CreatePropertyList(
                                        lpClassDefs->lpContainmentClasses
                                        );

    pClass->_dwNumberOfNamingAttributes =
                    lpClassDefs->dwNumberOfNamingAttributes;
    pClass->_lpNamingAttributes = CreatePropertyList(
                                        lpClassDefs->lpNamingAttributes
                                        );

    pClass->_dwNumberOfMandatoryAttributes =
                    lpClassDefs->dwNumberOfMandatoryAttributes;
    pClass->_lpMandatoryAttributes = CreatePropertyList(
                                          lpClassDefs->lpMandatoryAttributes
                                          );

    pClass->_dwNumberOfOptionalAttributes =
                    lpClassDefs->dwNumberOfOptionalAttributes;
    pClass->_lpOptionalAttributes = CreatePropertyList(
                                            lpClassDefs->lpOptionalAttributes
                                            );

    pClass->Release();

    RRETURN(hr);

error:

    delete pClass;
    RRETURN(hr);
}

HRESULT
CNDSClass::CreateClass(
    BSTR Parent,
    BSTR CommonName,
    NDS_CONTEXT_HANDLE hADsContext,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    DWORD dwStatus = 0;
    HRESULT hr = S_OK;
    LPNDS_CLASS_DEF lpClassDefs = NULL;
    DWORD dwObjectsReturned = 0;
    DWORD dwInfoType = 0;
    HANDLE hOperationData = NULL;


    hr = ADsNdsReadClassDef(
                    hADsContext,
                    DS_EXPANDED_CLASS_DEFS,
                    &CommonName,
                    1,
                    &hOperationData
                    );
    BAIL_ON_FAILURE(hr);


    hr = ADsNdsGetClassDefListFromBuffer(
                    hADsContext,
                    hOperationData,
                    &dwObjectsReturned,
                    &dwInfoType,
                    &lpClassDefs
                    );
    BAIL_ON_FAILURE(hr);

    if (!lpClassDefs) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = CNDSClass::CreateClass(
                    Parent,
                    CommonName,
                    lpClassDefs,
                    Credentials,
                    dwObjectState,
                    riid,
                    ppvObj
                    );

error:

    if (hOperationData) {
        ADsNdsFreeBuffer(hOperationData);
    }

    ADsNdsFreeClassDefList(lpClassDefs, dwObjectsReturned);

    RRETURN(hr);
}

CNDSClass::~CNDSClass( )
{
    if ( _bstrCLSID ) {
        ADsFreeString( _bstrCLSID );
    }

    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrPrimaryInterface ) {
        ADsFreeString( _bstrPrimaryInterface );
    }

    if ( _bstrHelpFileName ) {
        ADsFreeString( _bstrHelpFileName );
    }


    if (_lpSuperClasses) {

        FreePropertyList(_lpSuperClasses);
    }

    if (_lpContainmentClasses) {

        FreePropertyList(_lpContainmentClasses);
    }

    if (_lpNamingAttributes) {

        FreePropertyList(_lpNamingAttributes);
    }

    if (_lpMandatoryAttributes) {

        FreePropertyList(_lpMandatoryAttributes);
    }


    if (_lpOptionalAttributes) {

        FreePropertyList(_lpOptionalAttributes);
    }



    VariantClear( &_vFilter );

    delete _pDispMgr;
}

STDMETHODIMP
CNDSClass::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsClass))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CNDSClass::SetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSClass::GetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSClass::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN(E_NOTIMPL);
}


HRESULT
CNDSClass::AllocateClassObject(
    CCredentials& Credentials,
    CNDSClass ** ppClass
    )
{
    CNDSClass FAR * pClass = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pClass = new CNDSClass();
    if (pClass == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsClass,
                (IADsClass *)pClass,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pClass->_pDispMgr = pDispMgr;
    *ppClass = pClass;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CNDSClass::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CNDSClass::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN(E_NOTIMPL);
}



STDMETHODIMP
CNDSClass::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CNDSClass::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN(E_NOTIMPL);
}



STDMETHODIMP
CNDSClass::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}



/* IADsClass methods */

STDMETHODIMP
CNDSClass::get_PrimaryInterface( THIS_ BSTR FAR *pbstrGUID )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_CLSID( THIS_ BSTR FAR *pbstrCLSID )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::put_CLSID( THIS_ BSTR bstrCLSID )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_Abstract( THIS_ VARIANT_BOOL FAR *pfAbstract )
{
    if (_dwFlags & NDS_EFFECTIVE_CLASS) {
        *pfAbstract = VARIANT_FALSE;
    }else {
        *pfAbstract = VARIANT_TRUE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSClass::put_Abstract( THIS_ VARIANT_BOOL fAbstract )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_Auxiliary( THIS_ VARIANT_BOOL FAR *pfAuxiliary )
{
    *pfAuxiliary = VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSClass::put_Auxiliary( THIS_ VARIANT_BOOL fAuxiliary )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_MandatoryProperties( THIS_ VARIANT FAR *pvMandatoryProperties )
{
    HRESULT hr = S_OK;

    hr = MakeVariantFromPropList(
            _lpMandatoryAttributes,
            _dwNumberOfMandatoryAttributes,
            pvMandatoryProperties
            );
    RRETURN(hr);
}

STDMETHODIMP
CNDSClass::put_MandatoryProperties( THIS_ VARIANT vMandatoryProperties )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_DerivedFrom( THIS_ VARIANT FAR *pvDerivedFrom )
{
    HRESULT hr = S_OK;

    hr = MakeVariantFromPropList(
            _lpSuperClasses,
            _dwNumberOfSuperClasses,
            pvDerivedFrom
            );
    RRETURN(hr);
}

STDMETHODIMP
CNDSClass::put_DerivedFrom( THIS_ VARIANT vDerivedFrom )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_AuxDerivedFrom( THIS_ VARIANT FAR *pvAuxDerivedFrom )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSClass::put_AuxDerivedFrom( THIS_ VARIANT vAuxDerivedFrom )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_PossibleSuperiors( THIS_ VARIANT FAR *pvPossSuperiors)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSClass::put_PossibleSuperiors( THIS_ VARIANT vPossSuperiors )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_Containment( THIS_ VARIANT FAR *pvContainment )
{
    HRESULT hr = S_OK;

    hr = MakeVariantFromPropList(
            _lpContainmentClasses,
            _dwNumberOfContainmentClasses,
            pvContainment
            );
    RRETURN(hr);
}

STDMETHODIMP
CNDSClass::put_Containment( THIS_ VARIANT vContainment )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_Container( THIS_ VARIANT_BOOL FAR *pfContainer )
{
    if (_dwFlags & NDS_CONTAINER_CLASS) {
        *pfContainer = VARIANT_TRUE;
    }else {
        *pfContainer = VARIANT_FALSE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSClass::put_Container( THIS_ VARIANT_BOOL fContainer )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_HelpFileName( THIS_ BSTR FAR *pbstrHelpFileName )
{
    if ( !pbstrHelpFileName )
        RRETURN(E_ADS_BAD_PARAMETER);

    RRETURN( ADsAllocString( _bstrHelpFileName, pbstrHelpFileName ));
}

STDMETHODIMP
CNDSClass::put_HelpFileName( THIS_ BSTR bstrHelpFile )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_HelpFileContext( THIS_ long FAR *plHelpContext )
{
    if ( !plHelpContext )
        RRETURN(E_ADS_BAD_PARAMETER);

    *plHelpContext = _lHelpFileContext;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSClass::put_HelpFileContext( THIS_ long lHelpContext )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN(E_NOTIMPL);
}



PPROPENTRY
CreatePropertyList(
    LPWSTR_LIST  lpStringList
    )
{
    PPROPENTRY pStart = NULL;
    PPROPENTRY pPropEntry = NULL;

    while (lpStringList) {

        pPropEntry = CreatePropertyEntry(
                            lpStringList->szString,
                            0
                            );

        if (!pPropEntry)
            goto error;

        pPropEntry->pNext = pStart;
        pStart = pPropEntry;

        lpStringList = lpStringList->Next;
    }

error:
    return(pStart);
}

HRESULT
MakeVariantFromPropList(
    PPROPENTRY pPropList,
    DWORD dwNumEntries,
    VARIANT * pVarList
    )
{
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    VARIANT v;

    VariantInit(pVarList);

    sabNewArray.cElements = dwNumEntries;
    sabNewArray.lLbound = 0;

    pFilter = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );

    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i < (dwSLBound + dwNumEntries); i++) {
        VariantInit(&v);
        V_VT(&v) = VT_BSTR;

        V_BSTR(&v) = SysAllocString(pPropList->pszPropName);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&i,
                (void *)&v
                );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

        pPropList = pPropList->pNext;

    }

    V_VT(pVarList) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarList) = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    RRETURN(hr);
}


STDMETHODIMP
CNDSClass::get_OptionalProperties( THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;

    hr = MakeVariantFromPropList(
            _lpOptionalAttributes,
            _dwNumberOfOptionalAttributes,
            retval
            );
    RRETURN(hr);
}

STDMETHODIMP
CNDSClass::put_OptionalProperties( THIS_ VARIANT vOptionalProperties )
{

    HRESULT hr = E_NOTIMPL;

    RRETURN(hr);
}

STDMETHODIMP
CNDSClass::get_NamingProperties( THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;

    hr = MakeVariantFromPropList(
            _lpNamingAttributes,
            _dwNumberOfNamingAttributes,
            retval
            );
    RRETURN(hr);
}

STDMETHODIMP
CNDSClass::put_NamingProperties( THIS_ VARIANT vNamingProperties )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cclscach.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cprops.cxx
//
//  Contents:     Class Cache functionality for the NDS Provider
//
//  Functions:
//                CClassCache::addentry
//                CClassCache::findentry
//                CClassCache::getentry
//                CProperyCache::CClassCache
//                CClassCache::~CClassCache
//                CClassCache::CreateClassCache
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"


//+------------------------------------------------------------------------
//
//  Function:   CClassCache::addentry
//
//  Synopsis:
//
//
//
//  Arguments:  [pszTreeName]       --
//              [pszClassName]      --
//              [pClassEntry]       --
//
//
//-------------------------------------------------------------------------
HRESULT
CClassCache::
addentry(
    LPWSTR pszTreeName,
    LPWSTR pszClassName,
    PPROPENTRY pPropList
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD dwLRUEntry = 0;
    DWORD dwIndex = 0;
    PPROPENTRY pNewPropList = NULL;


    EnterCriticalSection(&_cs);

    hr = findentry(
            pszTreeName,
            pszClassName,
            &dwIndex
            );

    if (SUCCEEDED(hr)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Restore yr error code
    //
    hr = S_OK;

    if (_dwMaxCacheSize == 0 ) {


        LeaveCriticalSection(&_cs);

        RRETURN(E_FAIL);

    }

    for (i = 0; i < _dwMaxCacheSize; i++ ) {

        if (!_ClassEntries[i].bInUse) {

            //
            // Found an available entry; use it
            // fill in the name of the printer and the providor
            // that supports this printer.
            //
            break;

        } else {

            if ((dwLRUEntry == -1) || (i == IsOlderThan(i, dwLRUEntry))){
                dwLRUEntry = i;
            }
        }

    }

    if (i == _dwMaxCacheSize){

        //
        // We have no available entries so we need to use
        // the LRUEntry which is busy
        //


        //
        // Free this entry
        //

        if (_ClassEntries[dwLRUEntry].pPropList) {

            FreePropertyList(_ClassEntries[dwLRUEntry].pPropList);

            _ClassEntries[dwLRUEntry].pPropList = NULL;
        }

        //
        // BugBug: KrishnaG - add the free code!
        //

        _ClassEntries[dwLRUEntry].bInUse = FALSE;

        i = dwLRUEntry;
    }


    //
    // Insert the new entry into the Cache
    //

    wcscpy(_ClassEntries[i].szTreeName, pszTreeName);
    wcscpy(_ClassEntries[i].szClassName, pszClassName);

    pNewPropList = CopyPropList(pPropList);
    if (pNewPropList) {

        _ClassEntries[i].pPropList = pNewPropList;
    }

    _ClassEntries[i].bInUse = TRUE;

    //
    // update the time stamp so that we know when this entry was made
    //

    GetSystemTime(&_ClassEntries[i].st);

error:

    LeaveCriticalSection(&_cs);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CClassCache::findentry
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CClassCache::
findentry(
    LPWSTR pszTreeName,
    LPWSTR pszClassName,
    PDWORD pdwIndex
    )
{
    DWORD i = 0;


    EnterCriticalSection(&_cs);

    if (_dwMaxCacheSize == 0 ) {

        LeaveCriticalSection(&_cs);

        RRETURN(E_FAIL);
    }

    for (i = 0; i < _dwMaxCacheSize; i++ ) {

        if (_ClassEntries[i].bInUse) {
            if ((!_wcsicmp(_ClassEntries[i].szTreeName, pszTreeName)) &&
                (!_wcsicmp(_ClassEntries[i].szClassName, pszClassName))) {

                //
                // update the time stamp so that it is current and not old
                //
                GetSystemTime(&_ClassEntries[i].st);

                *pdwIndex = i;


                LeaveCriticalSection(&_cs);

                RRETURN(S_OK);

            }
        }
    }

    LeaveCriticalSection(&_cs);

    RRETURN(E_FAIL);
}

//+------------------------------------------------------------------------
//
//  Function:   CClassCache::findentry
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CClassCache::
getentry(
    LPWSTR pszTreeName,
    LPWSTR pszClassName,
    PPROPENTRY * ppPropList
    )
{
    DWORD dwIndex = 0;
    HRESULT hr = S_OK;
    PPROPENTRY pPropList = NULL;

    EnterCriticalSection(&_cs);

    hr = findentry(
            pszTreeName,
            pszClassName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pPropList = CopyPropList(
                    _ClassEntries[dwIndex].pPropList
                    );

    *ppPropList =  pPropList;

error:

    LeaveCriticalSection(&_cs);

    RRETURN(hr);

}

//+------------------------------------------------------------------------
//
//  Function:   CClassCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CClassCache::
CClassCache():
        _dwMaxCacheSize(2)
{
    memset(_ClassEntries, 0, sizeof(CLASSENTRY));
}

//+------------------------------------------------------------------------
//
//  Function:   ~CClassCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CClassCache::
~CClassCache()
{
    //
    // BugBug: KrishnaG - free each one of the data items
    //
    DWORD i;
    for (i = 0; i < _dwMaxCacheSize; i++ ) {
        if (_ClassEntries[i].bInUse) {
            if (_ClassEntries[i].pPropList) {
                FreePropertyList(_ClassEntries[i].pPropList);
                _ClassEntries[i].pPropList = NULL;
            }
            _ClassEntries[i].bInUse = FALSE;
        }
    }
}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CClassCache::
CreateClassCache(
    CClassCache FAR *FAR * ppClassCache
    )
{
    CClassCache FAR * pClassCache = NULL;

    pClassCache = new CClassCache();

    if (!pClassCache) {
        RRETURN(E_FAIL);
    }


    InitializeCriticalSection(&(pClassCache->_cs));

    *ppClassCache = pClassCache;

    RRETURN(S_OK);
}

DWORD
CClassCache::
IsOlderThan(
    DWORD i,
    DWORD j
    )
{
    SYSTEMTIME *pi, *pj;
    DWORD iMs, jMs;
    // DBGMSG(DBG_TRACE, ("IsOlderThan entering with i %d j %d\n", i, j));

    pi = &(_ClassEntries[i].st);
    pj = &(_ClassEntries[j].st);

    if (pi->wYear < pj->wYear) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wYear > pj->wYear) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
        return(j);
    } else  if (pi->wMonth < pj->wMonth) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wMonth > pj->wMonth) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
        return(j);
    } else if (pi->wDay < pj->wDay) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wDay > pj->wDay) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
        return(j);
    } else {
        iMs = ((((pi->wHour * 60) + pi->wMinute)*60) + pi->wSecond)* 1000 + pi->wMilliseconds;
        jMs = ((((pj->wHour * 60) + pj->wMinute)*60) + pj->wSecond)* 1000 + pj->wMilliseconds;

        if (iMs <= jMs) {
            // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
            return(i);
        } else {
            // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
            return(j);
        }
    }
}

HRESULT
ValidatePropertyinCache(
    LPWSTR pszTreeName,
    LPWSTR pszClassName,
    LPWSTR pszPropName,
    CCredentials& Credentials,
    PDWORD pdwSyntaxId
    )
{

    HRESULT hr = S_OK;
    PPROPENTRY pPropList = NULL;

    hr = pgClassCache->getentry(
                    pszTreeName,
                    pszClassName,
                    &pPropList
                    );

    if (FAILED(hr)) {
        hr = NdsGetClassInformation(
                 pszTreeName,
                 pszClassName,
                 Credentials,
                 &pPropList
                 );
        BAIL_ON_FAILURE(hr);

        hr = pgClassCache->addentry(
                    pszTreeName,
                    pszClassName,
                    pPropList
                    );
        BAIL_ON_FAILURE(hr);

    }

    hr = FindProperty(
               pPropList,
               pszPropName,
               pdwSyntaxId
               );
    BAIL_ON_FAILURE(hr);

error:

    if (pPropList) {
        FreePropertyList(pPropList);
    }

    RRETURN(hr);

}

HRESULT
NdsGetClassInformation(
    LPWSTR pszTreeName,
    LPWSTR pszClassName,
    CCredentials& Credentials,
    PPROPENTRY * ppPropList
    )
{
    HRESULT hr = S_OK;
    LPNDS_CLASS_DEF lpClassDefs = NULL;
    DWORD dwStatus;
    DWORD dwObjectReturned = 0;
    DWORD dwInfoType = 0;
    NDS_CONTEXT_HANDLE hADsContext = NULL;
    NDS_BUFFER_HANDLE hOperationData = NULL;
    PPROPENTRY pPropList = NULL;

    hr = ADsNdsOpenContext(
             pszTreeName,
             Credentials,
             &hADsContext
             );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsReadClassDef(
                    hADsContext,
                    DS_EXPANDED_CLASS_DEFS,
                    &pszClassName,
                    1,
                    &hOperationData
                    );
    BAIL_ON_FAILURE(hr);


    hr = ADsNdsGetClassDefListFromBuffer(
                    hADsContext,
                    hOperationData,
                    &dwObjectReturned,
                    &dwInfoType,
                    &lpClassDefs
                    );
    BAIL_ON_FAILURE(hr);

    pPropList = GenerateAttrIdList(
                        hADsContext,
                        lpClassDefs->lpMandatoryAttributes,
                        lpClassDefs->lpOptionalAttributes
                        );

/*
    pPropList = GeneratePropertyAndIdList(
                        pszTreeName,
                        lpClassDefs->lpMandatoryAttributes,
                        lpClassDefs->lpOptionalAttributes
                        );*/
    if (!pPropList) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    *ppPropList = pPropList;


error:

    if (hADsContext) {
        ADsNdsCloseContext(hADsContext);
    }

    if (hOperationData) {
        ADsNdsFreeBuffer(hOperationData);
    }

    ADsNdsFreeClassDefList(lpClassDefs, dwObjectReturned);

    RRETURN(hr);
}


PPROPENTRY
CreatePropertyEntry(
    LPWSTR pszPropertyName,
    DWORD dwSyntaxId
    )
{
    LPWSTR pszTemp = NULL;
    PPROPENTRY pPropName = NULL;

    pszTemp = (LPWSTR)AllocADsStr(
                    pszPropertyName
                    );
    if (!pszTemp) {
        return(NULL);
    }

    pPropName = (PPROPENTRY)AllocADsMem(
                        sizeof(PROPENTRY)
                        );
    if (!pPropName) {
        FreeADsStr(pszTemp);
        return(NULL);
    }

    pPropName->pszPropName = pszTemp;
    pPropName->dwSyntaxId = dwSyntaxId;

    return(pPropName);
}

void
FreePropertyEntry(
    PPROPENTRY pPropName
    )
{
    if (pPropName->pszPropName) {
        FreeADsStr(pPropName->pszPropName);
    }

    FreeADsMem(pPropName);

    return;
}


void
FreePropertyList(
    PPROPENTRY pPropList
    )
{
    PPROPENTRY pTemp = NULL;

    while (pPropList) {
        pTemp = pPropList->pNext;

        FreePropertyEntry(pPropList);

        pPropList = pTemp;
    }
    return;
}


PPROPENTRY
GeneratePropertyList(
    LPWSTR_LIST lpMandatoryProps,
    LPWSTR_LIST lpOptionalProps
    )
{
    PPROPENTRY pStart = NULL;
    PPROPENTRY lpProperty = NULL;
    LPWSTR_LIST lpTempStrings = NULL;

    lpTempStrings = lpMandatoryProps;

    while (lpTempStrings) {


        lpProperty = CreatePropertyEntry(
                            lpTempStrings->szString,
                            0
                            );
        if (!lpProperty) {
            goto cleanup;
        }

        lpProperty->pNext = pStart;
        pStart = lpProperty;

        lpTempStrings = lpTempStrings->Next;
    }

    lpTempStrings = lpOptionalProps;

    while (lpTempStrings) {


        lpProperty = CreatePropertyEntry(
                            lpTempStrings->szString,
                            0
                            );
        if (!lpProperty) {
            goto cleanup;
        }

        lpProperty->pNext = pStart;
        pStart = lpProperty;

        lpTempStrings = lpTempStrings->Next;
    }


cleanup:

    return(pStart);

}

HRESULT
FindProperty(
    PPROPENTRY pPropList,
    LPWSTR pszPropName,
    PDWORD pdwSyntaxId
    )
{
    while (pPropList) {
        if (!_wcsicmp(pPropList->pszPropName, pszPropName)) {
            *pdwSyntaxId = pPropList->dwSyntaxId;
            RRETURN(S_OK);
        }

        pPropList = pPropList->pNext;
    }

    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}


PPROPENTRY
CopyPropList(
    PPROPENTRY pPropList
    )
{

    PPROPENTRY pPropEntry = NULL;
    PPROPENTRY pStart = NULL;

    while (pPropList) {
      pPropEntry = CreatePropertyEntry(
                        pPropList->pszPropName,
                        pPropList->dwSyntaxId
                        );
      if (!pPropEntry) {
          return(pStart);
      }

      pPropEntry->pNext = pStart;
      pStart = pPropEntry;

      pPropList = pPropList->pNext;

    }

    return(pStart);

}


PPROPENTRY
GenerateAttrIdList(
    NDS_CONTEXT_HANDLE hADsContext,
    LPWSTR_LIST lpMandatoryProps,
    LPWSTR_LIST lpOptionalProps
    )
{
    PPROPENTRY pStart = NULL;
    PPROPENTRY pPropEntry = NULL;
    LPWSTR_LIST lpTempStrings = NULL;
    HANDLE hOperationData = NULL;
    DWORD i = 0;
    WCHAR szTempBuffer[MAX_PATH];

    DWORD dwSyntaxId = 0;
    HRESULT hr = S_OK;

    lpTempStrings = lpMandatoryProps;

    while (lpTempStrings) {

        wcscpy(szTempBuffer, lpTempStrings->szString);

        hr = ADsNdsGetSyntaxID(
                 hADsContext,
                 szTempBuffer,
                 &dwSyntaxId
                 );
        BAIL_ON_FAILURE(hr);

        pPropEntry = CreatePropertyEntry(
                            szTempBuffer,
                            dwSyntaxId
                            );

        if (!pPropEntry)
            goto error;

        pPropEntry->pNext = pStart;
        pStart = pPropEntry;

        lpTempStrings = lpTempStrings->Next;
    }

    lpTempStrings = lpOptionalProps;

    while (lpTempStrings) {

        wcscpy(szTempBuffer, lpTempStrings->szString);

        hr = ADsNdsGetSyntaxID(
                 hADsContext,
                 szTempBuffer,
                 &dwSyntaxId
                 );
        BAIL_ON_FAILURE(hr);

        pPropEntry = CreatePropertyEntry(
                            szTempBuffer,
                            dwSyntaxId
                            );

        if (!pPropEntry)
            goto error;

        pPropEntry->pNext = pStart;
        pStart = pPropEntry;

        lpTempStrings = lpTempStrings->Next;
    }

error:

    return(pStart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cdssch.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdssch.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   03-02-97     ShankSh    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


static WCHAR gszObjClassAttr[] = L"Object Class";
static WCHAR gszNameAttr[] = L"cn";


HRESULT
CNDSGenObject::EnumAttributes(
    LPWSTR * ppszAttrNames,
    DWORD dwNumAttributes,
    PADS_ATTR_DEF * ppAttrDefinition,
    DWORD * pdwNumAttributes
    )
{
    HRESULT hr = S_OK;
    DWORD dwNumberOfEntries = 0;
    DWORD dwInfoType;
    LPNDS_ATTR_DEF lpAttrDefs = NULL;
    NDS_BUFFER_HANDLE hOperationData = NULL;
    DWORD i,j,k;

    DWORD dwMemSize = 0;

    LPBYTE pBuffer = NULL;
    LPWSTR pszNameEntry = NULL;
    PADS_ATTR_DEF pAttrDefEntry = NULL;

    if ( !ppAttrDefinition || !pdwNumAttributes ||
        (dwNumAttributes < 0 && dwNumAttributes != -1) ) {
        RRETURN (E_INVALIDARG);
    }

    *ppAttrDefinition = NULL;
    *pdwNumAttributes = NULL;

    hr = ADsNdsReadAttrDef(
                    _hADsContext,
                    DS_ATTR_DEFS,
                    ppszAttrNames,
                    dwNumAttributes,
                    &hOperationData
                    );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsGetAttrDefListFromBuffer(
                    _hADsContext,
                    hOperationData,
                    &dwNumberOfEntries,
                    &dwInfoType,
                    &lpAttrDefs
                    );
    BAIL_ON_FAILURE(hr);

    if (dwInfoType != DS_ATTR_DEFS )
        BAIL_ON_FAILURE( hr = E_FAIL );

    //
    // Now package this data into a single contiguous buffer
    //

    hr =  ComputeADsAttrDefBufferSize(
                lpAttrDefs,
                dwNumberOfEntries,
                &dwMemSize
                );
    BAIL_ON_FAILURE(hr);


    pBuffer = (LPBYTE) AllocADsMem(dwMemSize);

    if (!pBuffer)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    pAttrDefEntry = (PADS_ATTR_DEF) pBuffer;
    pszNameEntry = (LPWSTR) (pBuffer + dwNumberOfEntries * sizeof(ADS_ATTR_DEF));

    for (j = 0; j < dwNumberOfEntries ; j++ ) {

        if (lpAttrDefs[j].dwSyntaxID >= g_cMapNdsTypeToADsType)
            pAttrDefEntry->dwADsType = ADSTYPE_INVALID;
        else
            pAttrDefEntry->dwADsType = g_MapNdsTypeToADsType[lpAttrDefs[j].dwSyntaxID];

        pAttrDefEntry->dwMinRange = lpAttrDefs[j].dwLowerLimit;

        pAttrDefEntry->dwMaxRange = lpAttrDefs[j].dwUpperLimit;

        pAttrDefEntry->fMultiValued = !(lpAttrDefs[j].dwFlags & NDS_SINGLE_VALUED_ATTR);

        wcscpy(pszNameEntry, lpAttrDefs[j].szAttributeName);
        pAttrDefEntry->pszAttrName = pszNameEntry;

        pszNameEntry += wcslen(lpAttrDefs[j].szAttributeName) + 1;
        pAttrDefEntry ++;
    }


    *ppAttrDefinition = (PADS_ATTR_DEF) pBuffer;
    *pdwNumAttributes = dwNumberOfEntries;


error:
    if (hOperationData) {
        ADsNdsFreeBuffer(hOperationData);
    }

    ADsNdsFreeAttrDefList(lpAttrDefs, dwNumberOfEntries);

    RRETURN(hr);
}


HRESULT
CNDSGenObject::CreateAttributeDefinition(
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF pAttributeDefinition
    )
{
    RRETURN (E_NOTIMPL);
}

HRESULT
CNDSGenObject::WriteAttributeDefinition(
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF  pAttributeDefinition
    )
{
    RRETURN (E_NOTIMPL);
}

HRESULT
CNDSGenObject::DeleteAttributeDefinition(
    LPWSTR pszAttributeName
    )
{
    RRETURN (E_NOTIMPL);
}


HRESULT
CNDSGenObject::EnumClasses(
    LPWSTR * ppszClassNames,
    DWORD dwNumClasses,
    PADS_CLASS_DEF * ppClassDefinition,
    DWORD * pdwNumClasses
    )
{
    RRETURN (E_NOTIMPL);
}

HRESULT
CNDSGenObject::CreateClassDefinition(
    LPWSTR pszClassName,
    PADS_CLASS_DEF pClassDefinition
    )
{
    RRETURN (E_NOTIMPL);
}

HRESULT
CNDSGenObject::WriteClassDefinition(
    LPWSTR pszClassName,
    PADS_CLASS_DEF  pClassDefinition
    )
{
    RRETURN (E_NOTIMPL);
}

HRESULT
CNDSGenObject::DeleteClassDefinition(
    LPWSTR pszClassName
    )
{
    RRETURN (E_NOTIMPL);
}

HRESULT
ComputeADsAttrDefBufferSize(
    LPNDS_ATTR_DEF pAttributes,
    DWORD dwNumAttributes,
    PDWORD pdwSize
    )
{
    DWORD i = 0;
    DWORD dwSize = 0;

    dwSize = sizeof(ADS_ATTR_DEF) * dwNumAttributes;

    for (i = 0; i < dwNumAttributes; i++)
        dwSize += (wcslen(pAttributes[i].szAttributeName) + 1)*sizeof(WCHAR);

    *pdwSize = dwSize;

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cdsobj.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdsobj.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   01-10-97     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


HRESULT
CNDSGenObject::SetObjectAttributes(
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    DWORD *pdwNumAttributesModified
    )
{
    HRESULT hr = S_OK;

    NDS_BUFFER_HANDLE hOperationData = NULL;

    DWORD i = 0;
    PADS_ATTR_INFO pThisAttribute = NULL;

    DWORD dwStatus = 0;
    PNDSOBJECT pNdsDestObjects = NULL;
    DWORD dwNumNdsValues = 0;
    DWORD dwSyntaxId = 0;
    DWORD dwNumNDSAttributeReturn = 0;

    *pdwNumAttributesModified = 0;
    
    if (dwNumAttributes <= 0) {

        RRETURN(E_FAIL);
    }

    hr = ADsNdsCreateBuffer(
                        _hADsContext,
                        DSV_MODIFY_ENTRY,
                        &hOperationData
                        );             
    BAIL_ON_FAILURE(hr);

    for (i = 0; i < dwNumAttributes; i++) {

        pThisAttribute = pAttributeEntries + i;

        switch (pThisAttribute->dwControlCode) {        
        
        case ADS_ATTR_UPDATE:                           
               hr = AdsTypeToNdsTypeCopyConstruct(                      
                           pThisAttribute->pADsValues,                  
                           pThisAttribute->dwNumValues,                 
                           &pNdsDestObjects,                            
                           &dwNumNdsValues,                             
                           &dwSyntaxId                                  
                           );                                           
               CONTINUE_ON_FAILURE(hr);                                 
                                                                        
               hr = ADsNdsPutInBuffer(
                        _hADsContext,
                        hOperationData,
                        pThisAttribute->pszAttrName,             
                        dwSyntaxId,
                        NULL,
                        0,
                        DS_CLEAR_ATTRIBUTE
                        );
               BAIL_ON_FAILURE(hr);
       
               hr = ADsNdsPutInBuffer(
                        _hADsContext,
                        hOperationData,
                        pThisAttribute->pszAttrName,             
                        dwSyntaxId,
                        pNdsDestObjects,
                        dwNumNdsValues,
                        DS_ADD_ATTRIBUTE
                        );
               BAIL_ON_FAILURE(hr);
                                                                        
               dwNumNDSAttributeReturn++; 
               break;

        case ADS_ATTR_APPEND:                           
               hr = AdsTypeToNdsTypeCopyConstruct(                      
                           pThisAttribute->pADsValues,                  
                           pThisAttribute->dwNumValues,                 
                           &pNdsDestObjects,                            
                           &dwNumNdsValues,                             
                           &dwSyntaxId                                  
                           );                                           
               CONTINUE_ON_FAILURE(hr);                                 
                                                                        
               hr = ADsNdsPutInBuffer(
                        _hADsContext,
                        hOperationData,
                        pThisAttribute->pszAttrName,             
                        dwSyntaxId,
                        pNdsDestObjects,                            
                        dwNumNdsValues,
                        DS_ADD_VALUE
                        );
               BAIL_ON_FAILURE(hr);
       
               dwNumNDSAttributeReturn++; 
               break;

        case ADS_ATTR_DELETE:                           
               hr = AdsTypeToNdsTypeCopyConstruct(                      
                           pThisAttribute->pADsValues,                  
                           pThisAttribute->dwNumValues,                 
                           &pNdsDestObjects,                            
                           &dwNumNdsValues,                             
                           &dwSyntaxId                                  
                           );                                           
               CONTINUE_ON_FAILURE(hr);                                 
                                                                        
               hr = ADsNdsPutInBuffer(
                        _hADsContext,
                        hOperationData,
                        pThisAttribute->pszAttrName,             
                        dwSyntaxId,
                        pNdsDestObjects,                            
                        dwNumNdsValues,                             
                        DS_REMOVE_VALUE
                        );
               BAIL_ON_FAILURE(hr);
       
               dwNumNDSAttributeReturn++; 
               break;

        case ADS_ATTR_CLEAR:

           hr = ADsNdsPutInBuffer(
                    _hADsContext,
                    hOperationData,
                    pThisAttribute->pszAttrName,              
                    dwSyntaxId,
                    NULL,
                    0,
                    DS_CLEAR_ATTRIBUTE
                    );
           BAIL_ON_FAILURE(hr);

           dwNumNDSAttributeReturn++; 
           break;

        default:

            //
            // Ignore this attribute and move on.
            //
            break;

        }

        // Clean-up in preparation for next iteration.
        // Need to set pNdsDestObjects to NULL so we
        // don't try to free it again in exit code.
        if (pNdsDestObjects)
        {
            NdsTypeFreeNdsObjects(                     
                pNdsDestObjects, 
                dwNumNdsValues
                );

            pNdsDestObjects = NULL;
        }

    }

    hr = ADsNdsModifyObject(
                    _hADsContext,
                    _pszNDSDn,
                    hOperationData
                    );
    BAIL_ON_FAILURE(hr);

   *pdwNumAttributesModified = dwNumNDSAttributeReturn;

error:

    if (pNdsDestObjects) {

       NdsTypeFreeNdsObjects(                     
               pNdsDestObjects, 
               dwNumNdsValues
               );
    }


    if (hOperationData) {

        ADsNdsFreeBuffer(hOperationData);
    }

    RRETURN(hr);

}


HRESULT
CNDSGenObject::GetObjectAttributes(
    LPWSTR * pAttributeNames,
    DWORD dwNumberAttributes,
    PADS_ATTR_INFO *ppAttributeEntries,
    DWORD * pdwNumAttributesReturned
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD dwNdsSyntaxId = 0;
    DWORD dwNumValues = 0;

    NDS_BUFFER_HANDLE hOperationData = NULL;

    DWORD dwStatus = 0;
    HANDLE hObject = NULL;
    LPWSTR * pThisAttributeName = NULL;

    PADS_ATTR_INFO pAdsAttributes = NULL;
    PADS_ATTR_INFO pThisAttributeDef = NULL;
    DWORD dwAttrCount = 0;

    DWORD dwNumberOfEntries = 0;
    LPNDS_ATTR_INFO lpEntries = NULL;

    PADSVALUE pAdsDestValues = NULL;

    DWORD j = 0;

    PADS_ATTR_INFO pThisAdsSrcAttribute = NULL;
    PADS_ATTR_INFO pThisAdsTargAttribute = NULL;

    PADS_ATTR_INFO pAttrEntry = NULL;
    PADSVALUE pAttrValue  = NULL;

    DWORD dwMemSize = 0;

    LPBYTE pAttributeBuffer = NULL;
    LPBYTE pValueBuffer = NULL;
    LPBYTE pDataBuffer = NULL;

    PADSVALUE pThisAdsSrcValue = NULL;

    PADSVALUE pThisAdsTargValue = NULL;
    DWORD dwTotalValues = 0;


    hr = ADsNdsReadObject(
                _hADsContext,
                _pszNDSDn,
                DS_ATTRIBUTE_VALUES,
                pAttributeNames,
                dwNumberAttributes,
                NULL,
                &lpEntries,
                &dwNumberOfEntries
                );
    BAIL_ON_FAILURE(hr);

    //
    // Allocate an attribute buffer which is as large as the
    // number of attributes present
    //
    //

    pAdsAttributes = (PADS_ATTR_INFO)AllocADsMem(
                           sizeof(ADS_ATTR_INFO)*dwNumberOfEntries
                           );
    if (!pAdsAttributes){

        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);

    }


    for (i = 0; i < dwNumberOfEntries; i++) {

        pThisAttributeDef = pAdsAttributes + dwAttrCount;

        dwNumValues = lpEntries[i].dwNumberOfValues;

        hr = NdsTypeToAdsTypeCopyConstruct(
                    lpEntries[i].lpValue,
                    lpEntries[i].dwNumberOfValues,
                    &pAdsDestValues
                    );
        if (FAILED(hr)){
            continue;
        }

        pThisAttributeDef->pszAttrName =
                AllocADsStr(lpEntries[i].szAttributeName);

        pThisAttributeDef->pADsValues = pAdsDestValues;

        pThisAttributeDef->dwNumValues = dwNumValues;


        pThisAttributeDef->dwADsType  = g_MapNdsTypeToADsType[lpEntries[i].dwSyntaxId];

        dwAttrCount++;


    }

    //
    // Now package this data into a single contiguous buffer
    //

    hr =  ComputeAttributeBufferSize(
                pAdsAttributes,
                dwAttrCount,
                &dwMemSize
                );
    BAIL_ON_FAILURE(hr);

    hr = ComputeNumberofValues(
                pAdsAttributes,
                dwAttrCount,
                &dwTotalValues
                );
    BAIL_ON_FAILURE(hr);


    pAttributeBuffer = (LPBYTE)AllocADsMem(dwMemSize);

    if (!pAttributeBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pValueBuffer = pAttributeBuffer + dwAttrCount * (sizeof(ADS_ATTR_INFO));

    pDataBuffer = pValueBuffer + dwTotalValues * sizeof(ADSVALUE);

    pAttrEntry = (PADS_ATTR_INFO)pAttributeBuffer;

    pAttrValue  = (PADSVALUE)pValueBuffer;

    for (i = 0; i < dwAttrCount; i++) {

        pThisAdsSrcAttribute = pAdsAttributes + i;

        pThisAdsTargAttribute = pAttrEntry + i;

        pThisAdsTargAttribute->pADsValues = pAttrValue;

        pThisAdsTargAttribute->dwNumValues = pThisAdsSrcAttribute->dwNumValues;

        pThisAdsTargAttribute->dwADsType = pThisAdsSrcAttribute->dwADsType;

        dwNumValues = pThisAdsSrcAttribute->dwNumValues;

        pThisAdsSrcValue = pThisAdsSrcAttribute->pADsValues;

        pThisAdsTargValue = pAttrValue;

        for (j = 0; j < dwNumValues; j++) {

            pDataBuffer = AdsTypeCopy(
                                pThisAdsSrcValue,
                                pThisAdsTargValue,
                                pDataBuffer
                                );
            pAttrValue++;
            pThisAdsTargValue = pAttrValue;
            pThisAdsSrcValue++;

        }

        pDataBuffer = AdsCopyAttributeName(
                                pThisAdsSrcAttribute,
                                pThisAdsTargAttribute,
                                pDataBuffer
                                );

    }

    hr = S_OK;

    *ppAttributeEntries = (PADS_ATTR_INFO)pAttributeBuffer;
    *pdwNumAttributesReturned = dwAttrCount;

cleanup:

    //
    // Clean up the header based Ods structures
    //

    FreeNdsAttrInfo( lpEntries, dwNumberOfEntries );

    if (pAdsAttributes) {

        for (i = 0; i < dwAttrCount; i++)
        {
            pThisAttributeDef = pAdsAttributes + i;

            if (pThisAttributeDef->pszAttrName)
                FreeADsStr(pThisAttributeDef->pszAttrName);

            AdsFreeAdsValues(
                pThisAttributeDef->pADsValues,
                pThisAttributeDef->dwNumValues
                );

            FreeADsMem(pThisAttributeDef->pADsValues);
        }

        FreeADsMem(pAdsAttributes);
    }

    RRETURN(hr);

error:

    if (pAttributeBuffer) {
        FreeADsMem(pAttributeBuffer);
    }

    *ppAttributeEntries = (PADS_ATTR_INFO) NULL;
    *pdwNumAttributesReturned = 0;

    goto cleanup;
}


HRESULT
CNDSGenObject::CreateDSObject(
    LPWSTR pszRDNName,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR *pszNDSTreeName = NULL;
    WCHAR *pszNDSDn = NULL;

    NDS_BUFFER_HANDLE hOperationData = NULL;

    DWORD i = 0;
    PADS_ATTR_INFO pThisAttribute = NULL;

    DWORD dwStatus = 0;
    PNDSOBJECT pNdsDestObjects = NULL;
    DWORD dwNumNdsValues = 0;
    DWORD dwSyntaxId = 0;
    IADs *pADs = NULL;
    TCHAR szADsClassName[64];
    BSTR bstrChildPath = NULL;

    hr = BuildADsPath(
                _ADsPath,
                pszRDNName,
                &bstrChildPath
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath2(
                bstrChildPath,
                &pszNDSTreeName,
                &pszNDSDn
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsCreateBuffer(
                        _hADsContext,
                        DSV_ADD_ENTRY,
                        &hOperationData
                        );             
    BAIL_ON_FAILURE(hr);

    for (i = 0; i < dwNumAttributes; i++) {

        pThisAttribute = pAttributeEntries + i;

        hr = AdsTypeToNdsTypeCopyConstruct(
                    pThisAttribute->pADsValues,
                    pThisAttribute->dwNumValues,
                    &pNdsDestObjects,
                    &dwNumNdsValues,
                    &dwSyntaxId
                    );
        CONTINUE_ON_FAILURE(hr);

        hr = ADsNdsPutInBuffer(
                 _hADsContext,
                 hOperationData,
                 pThisAttribute->pszAttrName,
                 dwSyntaxId,
                 pNdsDestObjects,
                 dwNumNdsValues,
                 DS_ADD_ATTRIBUTE
                 );
        BAIL_ON_FAILURE(hr);

        if (pNdsDestObjects) {

            NdsTypeFreeNdsObjects(                     
                   pNdsDestObjects, 
                   dwNumNdsValues
                   );

            pNdsDestObjects = NULL;
        }

    }

    hr = ADsNdsAddObject(
                    _hADsContext,
                    pszNDSDn,
                    hOperationData
                    );
    BAIL_ON_FAILURE(hr);


    for (i = 0; i < dwNumAttributes; i++) {
        pThisAttribute = pAttributeEntries + i;
        if ( _tcsicmp( pThisAttribute->pszAttrName,
                       TEXT("Object Class")) == 0 ) {
            _tcscpy( szADsClassName, 
                     (LPTSTR)pThisAttribute->pADsValues->CaseIgnoreString);
            break;
        }
    }

    //
    // If the object is a user object, we set the initial password to NULL.
    //
    if (_wcsicmp(szADsClassName, L"user") == 0) {
        hr = ADsNdsGenObjectKey(_hADsContext,
                                pszNDSDn);     
        BAIL_ON_FAILURE(hr);
    }
    
    hr = CNDSGenObject::CreateGenericObject(
                    _ADsPath,
                    pszRDNName,
                    szADsClassName,
                    _Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IADs,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);


    hr = InstantiateDerivedObject(
                    pADs,
                    _Credentials,
                    IID_IDispatch,
                    (void **)ppObject
                    );

    if (FAILED(hr)) {
        hr = pADs->QueryInterface(
                        IID_IDispatch,
                        (void **)ppObject
                        );
        BAIL_ON_FAILURE(hr);
    }


error:

    if (pADs) {
        pADs->Release();
    }
    
    if (pNdsDestObjects) {

        NdsTypeFreeNdsObjects(                     
               pNdsDestObjects, 
               dwNumNdsValues
               );
    }


    if (pszNDSTreeName) {

        FreeADsStr(pszNDSTreeName);
    }

    if (pszNDSDn) {

        FreeADsStr(pszNDSDn);
    }

    if (bstrChildPath) {
        SysFreeString(bstrChildPath);
    }

    if (hOperationData) {

        ADsNdsFreeBuffer(hOperationData);
    }

    RRETURN(hr);

}


HRESULT
CNDSGenObject::DeleteDSObject(
    LPWSTR pszRDNName
    )
{
    WCHAR *pszNDSTreeName = NULL, *pszNDSDn = NULL ;
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;
    BSTR bstrChildPath = NULL;

    hr = BuildADsPath(
                _ADsPath,
                pszRDNName,
                &bstrChildPath
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath2(
                bstrChildPath,
                &pszNDSTreeName,
                &pszNDSDn
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsRemoveObject(
             _hADsContext,
             pszNDSDn
             );
    BAIL_ON_FAILURE(hr);


error:
    if (bstrChildPath) {
        SysFreeString(bstrChildPath);
    }

    if (pszNDSTreeName) {
        FreeADsStr(pszNDSTreeName);

    }

    if (pszNDSDn) {
        FreeADsStr(pszNDSDn);

    }

    RRETURN(hr);
}

HRESULT
ComputeAttributeBufferSize(
    PADS_ATTR_INFO pAdsAttributes,
    DWORD dwNumAttributes,
    PDWORD pdwSize
    )
{
    DWORD i = 0;
    DWORD j = 0;
    PADS_ATTR_INFO pThisAttribute = NULL;
    PADSVALUE pAdsSrcValues = NULL;
    DWORD dwSize = 0;
    DWORD dwVarSz = 0;
    DWORD dwNumValues = 0;
    HRESULT hr = S_OK;


    for (i = 0; i < dwNumAttributes; i++) {

        pThisAttribute = pAdsAttributes + i;

        dwNumValues = pThisAttribute->dwNumValues;

        pAdsSrcValues = pThisAttribute->pADsValues;

        for (j = 0; j < dwNumValues; j++) {

            dwVarSz = AdsTypeSize(pAdsSrcValues + j);

            dwSize += dwVarSz;

            dwSize += sizeof(ADSVALUE);

        }

        dwSize += sizeof(ADS_ATTR_INFO);

        dwSize += (wcslen(pThisAttribute->pszAttrName) + 1)*sizeof(WCHAR);
    }

    *pdwSize = dwSize;

    RRETURN(S_OK);
}


HRESULT
ComputeNumberofValues(
    PADS_ATTR_INFO pAdsAttributes,
    DWORD dwNumAttributes,
    PDWORD pdwNumValues
    )
{
    DWORD i = 0;
    PADS_ATTR_INFO pThisAttribute = NULL;
    DWORD dwNumValues = 0;
    DWORD dwTotalNumValues = 0;

    for (i = 0; i < dwNumAttributes; i++) {

        pThisAttribute = pAdsAttributes + i;

        dwNumValues = pThisAttribute->dwNumValues;

        dwTotalNumValues += dwNumValues;

    }

    *pdwNumValues = dwTotalNumValues;

    RRETURN(S_OK);
}


DWORD
ComputeObjectInfoSize(
    PADS_OBJECT_INFO pObjectInfo
    )
{
    DWORD dwLen = 0;

    dwLen += (wcslen(pObjectInfo->pszRDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszObjectDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszParentDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszSchemaDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszClassName) + 1) * sizeof(WCHAR);


    dwLen += sizeof(ADS_OBJECT_INFO);

    return(dwLen);
}




LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD *DestOffsets,
    LPBYTE pEnd
    );

//
// This assumes that addr is an LPBYTE type.
//
#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((DWORD)addr & ~1))

DWORD ObjectInfoStrings[] =

                             {
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszRDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszObjectDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszParentDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszSchemaDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszClassName),
                             0xFFFFFFFF
                             };


HRESULT
MarshallObjectInfo(
    PADS_OBJECT_INFO pSrcObjectInfo,
    LPBYTE pDestObjectInfo,
    LPBYTE pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(ADS_OBJECT_INFO)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;

    memset(SourceStrings, 0, sizeof(ADS_OBJECT_INFO));
    *pSourceStrings++ = pSrcObjectInfo->pszRDN;
    *pSourceStrings++ = pSrcObjectInfo->pszObjectDN;
    *pSourceStrings++ = pSrcObjectInfo->pszParentDN;
    *pSourceStrings++ = pSrcObjectInfo->pszSchemaDN;
    *pSourceStrings++ = pSrcObjectInfo->pszClassName;

    pEnd = PackStrings(
                SourceStrings,
                pDestObjectInfo,
                ObjectInfoStrings,
                pEnd
                );

    RRETURN(S_OK);
}



HRESULT
CNDSGenObject::GetObjectInformation(
    THIS_ PADS_OBJECT_INFO  *  ppObjInfo
    )
{

    ADS_OBJECT_INFO ObjectInfo;
    PADS_OBJECT_INFO pObjectInfo = &ObjectInfo;
    LPBYTE  pBuffer = NULL;
    DWORD dwSize = 0;

    HRESULT hr = S_OK;

    pObjectInfo->pszRDN = _Name;
    pObjectInfo->pszObjectDN = _ADsPath;
    pObjectInfo->pszParentDN = _Parent;
    pObjectInfo->pszSchemaDN = _Schema;
    pObjectInfo->pszClassName = _ADsClass;

    dwSize = ComputeObjectInfoSize(pObjectInfo);

    pBuffer = (LPBYTE)AllocADsMem(dwSize);
    if (!pBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr  = MarshallObjectInfo(
                pObjectInfo,
                pBuffer,
                pBuffer + dwSize
                );
    BAIL_ON_FAILURE(hr);

    *ppObjInfo = (PADS_OBJECT_INFO)pBuffer;

error:

    RRETURN(hr);
}



LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD *DestOffsets,
    LPBYTE pEnd
    )
{
    DWORD cbStr;
    WORD_ALIGN_DOWN(pEnd);

    while (*DestOffsets != -1) {
        if (*pSource) {
            cbStr = wcslen(*pSource)*sizeof(WCHAR) + sizeof(WCHAR);
            pEnd -= cbStr;
            CopyMemory( pEnd, *pSource, cbStr);
            *(LPWSTR *)(pDest+*DestOffsets) = (LPWSTR)pEnd;
        } else {
            *(LPWSTR *)(pDest+*DestOffsets)=0;
        }
        pSource++;
        DestOffsets++;
    }
    return pEnd;
}


LPBYTE
AdsCopyAttributeName(
    PADS_ATTR_INFO pThisAdsSrcAttribute,
    PADS_ATTR_INFO pThisAdsTargAttribute,
    LPBYTE pDataBuffer
    )
{

    LPWSTR pCurrentPos = (LPWSTR)pDataBuffer;

    wcscpy(pCurrentPos, pThisAdsSrcAttribute->pszAttrName);

    pThisAdsTargAttribute->pszAttrName = pCurrentPos;

    pDataBuffer = pDataBuffer + (wcslen(pThisAdsSrcAttribute->pszAttrName) + 1)*sizeof(WCHAR);

    return(pDataBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cdssrch.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdssrch.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   03-02-97     ShankSh    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

const int NO_NDS_RESULT_HANDLES = 32;
const int NO_UNCACHED_RESULTS_TO_KEEP = 3;

static 
HRESULT
NdsValueToADsColumn(
    LPWSTR      pszColumnName,
    DWORD       dwSyntaxId,
    DWORD       dwValues,
    LPBYTE      lpValue,
    ADS_SEARCH_COLUMN * pColumn
    );

static
HRESULT
NdsValueToADsColumnAppend(
    DWORD       dwSyntaxId,
    DWORD       dwValues,
    LPBYTE      lpObject,
    ADS_SEARCH_COLUMN * pColumn
    );

//
// Sets the appropriate search preferences. 
//
HRESULT 
CNDSGenObject::SetSearchPreference(
    IN PADS_SEARCHPREF_INFO pSearchPrefs,
    IN DWORD   dwNumPrefs
    ) 
{   
    HRESULT hr = S_OK;
    BOOL fWarning = FALSE;
    DWORD i;

    if (!pSearchPrefs && dwNumPrefs > 0) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    for (i=0; i<dwNumPrefs; i++) {

        pSearchPrefs[i].dwStatus = ADS_STATUS_S_OK;

        switch(pSearchPrefs[i].dwSearchPref) {
        case ADS_SEARCHPREF_ASYNCHRONOUS:
        case ADS_SEARCHPREF_SIZE_LIMIT:
        case ADS_SEARCHPREF_TIME_LIMIT:
        case ADS_SEARCHPREF_TIMEOUT:
        case ADS_SEARCHPREF_PAGESIZE:
        case ADS_SEARCHPREF_PAGED_TIME_LIMIT:
        case ADS_SEARCHPREF_CHASE_REFERRALS:
            //
            // Can't be set
            //
            pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
            fWarning = TRUE;
            continue;
        
        case ADS_SEARCHPREF_DEREF_ALIASES:
            if (pSearchPrefs[i].vValue.dwType != ADSTYPE_INTEGER) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }
        
            switch (pSearchPrefs[i].vValue.Integer) {
            case ADS_DEREF_NEVER:
                _SearchPref._fDerefAliases = FALSE;
                break;
        
            case ADS_DEREF_ALWAYS:
                _SearchPref._fDerefAliases = TRUE;
                break;
        
            default:
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }
            break;
    
        case ADS_SEARCHPREF_ATTRIBTYPES_ONLY:
            if (pSearchPrefs[i].vValue.dwType != ADSTYPE_BOOLEAN) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }
            _SearchPref._fAttrsOnly = pSearchPrefs[i].vValue.Boolean;
            break;
    
        case ADS_SEARCHPREF_CACHE_RESULTS:
            if (pSearchPrefs[i].vValue.dwType != ADSTYPE_BOOLEAN) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }
            _SearchPref._fCacheResults = pSearchPrefs[i].vValue.Boolean;
            break;

        case ADS_SEARCHPREF_SEARCH_SCOPE: 
            if (pSearchPrefs[i].vValue.dwType != ADSTYPE_INTEGER) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }
        
            switch (pSearchPrefs[i].vValue.Integer) {
            case ADS_SCOPE_BASE:
                _SearchPref._dwSearchScope = DS_SEARCH_ENTRY;
                break;
        
            case ADS_SCOPE_ONELEVEL:
                _SearchPref._dwSearchScope = DS_SEARCH_SUBORDINATES;
                break;
        
            case ADS_SCOPE_SUBTREE:
                _SearchPref._dwSearchScope = DS_SEARCH_SUBTREE;
                break;
        
            default:
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }
            break;

        default:
            pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
            fWarning = TRUE;
            continue;

        }
    }

    RRETURN (fWarning ? S_ADS_ERRORSOCCURRED : S_OK);

}


HRESULT
CNDSGenObject::ExecuteSearch(
    IN LPWSTR pszSearchFilter,
    IN LPWSTR * pAttributeNames,
    IN DWORD dwNumberAttributes,
    OUT PADS_SEARCH_HANDLE phSearchHandle
    )
{
    PNDS_SEARCHINFO phSearchInfo = NULL;
    LPWSTR szCurrAttr = NULL;
    DWORD dwAttrNamesLen = 0;
    HRESULT hr = S_OK;
    ULONG i, j;
    LPWSTR pszAttrNameBuffer = NULL, *ppszAttrs = NULL;

    if (!phSearchHandle) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    //
    // Allocate search handle
    //
    phSearchInfo = (PNDS_SEARCHINFO) AllocADsMem(sizeof(NDS_SEARCHINFO));
    if(!phSearchInfo) 
        BAIL_ON_FAILURE (hr = E_OUTOFMEMORY);

    hr = AdsNdsGenerateFilterBuffer( 
             _hADsContext,
             pszSearchFilter,
             &phSearchInfo->_pFilterBuf 
             );
    BAIL_ON_FAILURE(hr);

    phSearchInfo->_fADsPathPresent = FALSE;
    phSearchInfo->_fADsPathReturned = FALSE;

    if (dwNumberAttributes == -1) {
        //
        // Specifies returning all attributes
        //

        phSearchInfo->_ppszAttrs = NULL;
        phSearchInfo->_pszAttrNameBuffer = NULL;
        phSearchInfo->_fADsPathPresent = TRUE;
        phSearchInfo->_nAttrs = (DWORD) -1;

    }
    else {
        ppszAttrs = (LPWSTR *) AllocADsMem(
                                  sizeof(LPWSTR) * 
                                  (dwNumberAttributes)
                                  );
        if (!ppszAttrs) 
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        for (i = 0; i < dwNumberAttributes; i++) 
            dwAttrNamesLen+= (wcslen(pAttributeNames[i]) + 1) * sizeof(WCHAR);

        pszAttrNameBuffer = (LPWSTR) AllocADsMem(
                                         dwAttrNamesLen
                                         );
        if (!pszAttrNameBuffer) 
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        szCurrAttr = pszAttrNameBuffer;
        for (i = 0, j = 0; i < dwNumberAttributes; i++) {
            wcscpy(szCurrAttr, pAttributeNames[i]);
            ppszAttrs[j] = szCurrAttr;
            szCurrAttr += wcslen(ppszAttrs[j]) + 1;

            if(_wcsicmp(ppszAttrs[j], L"ADsPath") == 0) {
                //
                // ADsPath need not be sent
                // 

                phSearchInfo->_fADsPathPresent = TRUE;
            }
            else  {

                j++;
            }

        }

        phSearchInfo->_ppszAttrs = ppszAttrs;
        phSearchInfo->_nAttrs = j;
        phSearchInfo->_pszAttrNameBuffer = pszAttrNameBuffer;
    }

    phSearchInfo->_lIterationHandle = NO_MORE_ITERATIONS;
    phSearchInfo->_pSearchResults = NULL;
    phSearchInfo->_cSearchResults = 0;
    phSearchInfo->_dwCurrResult = 0;
    phSearchInfo->_cResultPrefetched = 0;
    phSearchInfo->_fCheckForDuplicates = TRUE;
    phSearchInfo->_dwCurrAttr = 0;
    phSearchInfo->_SearchPref = _SearchPref;

    *phSearchHandle = phSearchInfo;

    RRETURN(S_OK);

error:

    if(phSearchInfo) {

        if(phSearchInfo->_ppszAttrs) 
            FreeADsMem(phSearchInfo->_ppszAttrs);

        if(phSearchInfo->_pszAttrNameBuffer) 
            FreeADsMem(phSearchInfo->_pszAttrNameBuffer);

        FreeADsMem(phSearchInfo);
    }

    RRETURN (hr);

}


HRESULT
CNDSGenObject::AbandonSearch(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CNDSGenObject::CloseSearchHandle (
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;

    if (!phSearchInfo)
        RRETURN (E_ADS_BAD_PARAMETER);

    if (phSearchInfo->_pFilterBuf) {
        ADsNdsFreeBuffer(phSearchInfo->_pFilterBuf);
    }

    if(phSearchInfo->_ppszAttrs) 
        FreeADsMem(phSearchInfo->_ppszAttrs);

    if(phSearchInfo->_pszAttrNameBuffer) 
        FreeADsMem(phSearchInfo->_pszAttrNameBuffer);

    if (phSearchInfo->_pSearchResults) {

        for (DWORD i=0; i < phSearchInfo->_cSearchResults; i++) {

            // If we're not caching all results, these may already have been freed
            // and set to NULL, but this is okay --- ADsNdsFreeBuffer and 
            // ADsNdsFreeNdsObjInfoList will catch this.

            ADsNdsFreeBuffer(phSearchInfo->_pSearchResults[i]._hSearchResult);
            
            ADsNdsFreeNdsObjInfoList(phSearchInfo->_pSearchResults[i]._pObjects,
                phSearchInfo->_pSearchResults[i]._dwObjects);
            
        }
        FreeADsMem(phSearchInfo->_pSearchResults);
    }

    FreeADsMem(phSearchInfo);
    RRETURN (hr);
}


HRESULT
CNDSGenObject::GetFirstRow(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CNDSGenObject::GetNextRow(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr;
    DWORD dwStatus = NO_ERROR;
    PNDS_SEARCH_RESULT pResult, pNextResult, pEvictedResult;
    PADSNDS_OBJECT_INFO   pObject, pNextObject;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;
    DWORD dwType;
    DWORD nObjectsSearched;
    DWORD i;

    if (!phSearchInfo) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }                                
    
    if (phSearchInfo->_fCheckForDuplicates) {
        phSearchInfo->_dwCurrAttr = 0;
    }

    //
    // dwCurrResult indexes the location of the array where we have already got
    // information from. If it is < 0, it indicates that there is no information
    // in this searchinfo at all
    //
    if (phSearchInfo->_dwCurrResult < 0)
        RRETURN(S_ADS_NOMORE_ROWS);

    if (phSearchInfo->_pSearchResults) {
        pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);

        // 
        // If next object is available in current result
        //
        if (pResult->_pObjects &&
            ((pResult->_dwObjectCurrent+1) < pResult->_dwObjects)) {
            pResult->_dwObjectCurrent++;
            RRETURN(S_OK);
        }
        if (pResult->_dwObjectCurrent+1 == pResult->_dwObjects &&
            (phSearchInfo->_cResultPrefetched > 0)) {
            pNextResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult+1]);
            pNextResult->_dwObjectCurrent = 0;
            phSearchInfo->_cResultPrefetched--;

            //
            // If next object points to NULL, it means we have no objects in
            // the next row
            //
            if (!pNextResult->_pObjects)
                RRETURN(S_ADS_NOMORE_ROWS);

            if(phSearchInfo->_fCheckForDuplicates) {
                pObject = pResult->_pObjects + pResult->_dwObjectCurrent;
                pNextObject = pNextResult->_pObjects + pNextResult->_dwObjectCurrent;
                if (!_wcsicmp(pObject->szObjectName, pNextObject->szObjectName)) {
                    //
                    // Duplicates; Skip one more result
                    //
                    //if (pNextResult->_dwObjectCurrent+1 < pNextResult->_dwObjects)
                        pNextResult->_dwObjectCurrent++;
                    //else
                    //    RRETURN(S_ADS_NOMORE_ROWS);
                }
            }
            if( pNextResult->_dwObjectCurrent >= pNextResult->_dwObjects &&
                 phSearchInfo->_lIterationHandle == NO_MORE_ITERATIONS) {
                RRETURN(S_ADS_NOMORE_ROWS);
            }
            else {
                //
                // We have successfully moved onto the next value in the array
                //
                phSearchInfo->_dwCurrResult++;

                if ( (phSearchInfo->_dwCurrResult >= NO_UNCACHED_RESULTS_TO_KEEP) &&
                     !phSearchInfo->_SearchPref._fCacheResults ) {
                    // Not caching --- evict the old result
                    pEvictedResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult-NO_UNCACHED_RESULTS_TO_KEEP]);

                    ADsNdsFreeBuffer(pEvictedResult->_hSearchResult);
                    ADsNdsFreeNdsObjInfoList(pEvictedResult->_pObjects, pEvictedResult->_dwObjects);

                    pEvictedResult->_hSearchResult = NULL;
                    pEvictedResult->_pObjects = NULL;
                    pEvictedResult->_dwObjects = 0;
                    pEvictedResult->_fInUse = FALSE;
                }

                if ( pNextResult->_dwObjectCurrent >= pNextResult->_dwObjects) {
                    // phSearchInfo->_lIterationHandle != NO_MORE_ITERATIONS

                    // We have incremented pNextResult->_dwObjectCurrent past the number
                    // of objects in pNextResult, but there are more iterations left to go.
                    // This can occur if there was exactly one object in pNextResult, that
                    // object is a duplicate of the last object in pResult, and there are
                    // more objects left to retrieve.  (This same case can also occur later
                    // in this function, after calling AdsNdsSearch to get a new result set,
                    // and code was added there as well to handle it.)
                    //
                    // We make it look like we've exhausted the results in pNextResult (which
                    // we have) and recursively get the next row to get the next
                    // result set (which may either be prefetched or retrieved from the server
                    // via AdsNdsSearch).  Since _dwCurrResult has already been
                    // incremented, our pNextResult will be the recursive call's pResult,
                    // it will look like we've exhausted the objects in the result,
                    // and it will fetch the next result.
                    //
                    // We do this here, after the cache eviction code, so that we evict the
                    // _dwCurrentResult-NO_UNCACHED_RESULTS_TO_KEEP result before going on
                    // to _dwCurrentResult+1

                    pNextResult->_dwObjectCurrent = pNextResult->_dwObjects-1;
                    RRETURN(GetNextRow(hSearchHandle));
                }
                else {
                    // We haven't exhausted pNextResult, so we're done
                    RRETURN(S_OK);
                }
            }
        }
        else if( pResult->_dwObjectCurrent+1 == pResult->_dwObjects &&
                 phSearchInfo->_lIterationHandle == NO_MORE_ITERATIONS)
            RRETURN(S_ADS_NOMORE_ROWS);
    }

    if (!phSearchInfo->_pFilterBuf) {
        //
        // querynode not setup yet
        //
        RRETURN (E_FAIL);
    }

    if(!phSearchInfo->_pSearchResults) {
        //
        // Allocate an array of handles to Search Handles
        //
        phSearchInfo->_pSearchResults = (PNDS_SEARCH_RESULT) AllocADsMem(
                                             sizeof(NDS_SEARCH_RESULT) *
                                             NO_NDS_RESULT_HANDLES);
        if(!phSearchInfo->_pSearchResults) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        phSearchInfo->_dwCurrResult = 0;
        phSearchInfo->_cSearchResults = NO_NDS_RESULT_HANDLES;

        for (i=0; i < phSearchInfo->_cSearchResults; i++) {
            phSearchInfo->_pSearchResults[i]._fInUse = 0;
            phSearchInfo->_pSearchResults[i]._hSearchResult = NULL;
            phSearchInfo->_pSearchResults[i]._pObjects = NULL;
            phSearchInfo->_pSearchResults[i]._dwObjects = 0;
        }

    }
    else {
        phSearchInfo->_dwCurrResult++;
        if (phSearchInfo->_dwCurrResult >= (LONG) phSearchInfo->_cSearchResults) {
            //
            // Need to allocate more memory for handles
            //

            phSearchInfo->_pSearchResults = (PNDS_SEARCH_RESULT) ReallocADsMem(
                                                 (void *) phSearchInfo->_pSearchResults,
                                                 sizeof(NDS_SEARCH_RESULT) *
                                                 phSearchInfo->_cSearchResults,
                                                 sizeof(NDS_SEARCH_RESULT) *
                                                 (phSearchInfo->_cSearchResults +
                                                  NO_NDS_RESULT_HANDLES)
                                                 );
            if(!phSearchInfo->_pSearchResults) {
                hr = E_OUTOFMEMORY;
                goto error;
            }

            for (i=phSearchInfo->_cSearchResults; i < phSearchInfo->_cSearchResults + NO_NDS_RESULT_HANDLES; i++) {
                phSearchInfo->_pSearchResults[i]._fInUse = 0;
                phSearchInfo->_pSearchResults[i]._hSearchResult = NULL;
                phSearchInfo->_pSearchResults[i]._pObjects = NULL;
                phSearchInfo->_pSearchResults[i]._dwObjects = 0;
            }


            phSearchInfo->_cSearchResults += NO_NDS_RESULT_HANDLES;

        }
    }

    pNextResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
    ADsNdsFreeNdsObjInfoList(pNextResult->_pObjects, pNextResult->_dwObjects);
    pNextResult->_dwObjects = 0;
    pNextResult->_pObjects = NULL;
    pNextResult->_dwObjectCurrent = 0;
    pNextResult->_hSearchResult = NULL;
    pNextResult->_fInUse = TRUE;

    hr = ADsNdsSearch(
             _hADsContext,
             _pszNDSDn,
             _SearchPref._dwSearchScope,
             _SearchPref._fDerefAliases,
             phSearchInfo->_pFilterBuf,
             0,
             _SearchPref._fAttrsOnly ? 
                 DS_ATTRIBUTE_NAMES : DS_ATTRIBUTE_VALUES,
             phSearchInfo->_ppszAttrs,
             phSearchInfo->_nAttrs,
             0,
             &nObjectsSearched,
             &pNextResult->_hSearchResult,
             &phSearchInfo->_lIterationHandle
             );
    BAIL_ON_FAILURE(hr);

   hr = ADsNdsGetObjectListFromBuffer(
                   _hADsContext,
                   pNextResult->_hSearchResult,
                   (PDWORD)&pNextResult->_dwObjects,
                   &pNextResult->_pObjects
                   );
   BAIL_ON_FAILURE(hr);

    if (pNextResult->_dwObjects > 0) {
        pNextResult->_dwObjectCurrent = 0;
        if(phSearchInfo->_fCheckForDuplicates && phSearchInfo->_dwCurrResult > 0) {
            pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult-1]);
            pObject = pResult->_pObjects + pResult->_dwObjectCurrent;
            pNextObject = pNextResult->_pObjects + pNextResult->_dwObjectCurrent;
            if (!_wcsicmp(pObject->szObjectName, pNextObject->szObjectName)) {
                //
                // Duplicates; Skip one more result
                //
                pNextResult->_dwObjectCurrent++;
            }
        }
        if( pNextResult->_dwObjectCurrent >= pNextResult->_dwObjects &&
             phSearchInfo->_lIterationHandle == NO_MORE_ITERATIONS) {
            phSearchInfo->_dwCurrResult--;
            RRETURN(S_ADS_NOMORE_ROWS);
        }

        if ( !phSearchInfo->_SearchPref._fCacheResults &&
             (phSearchInfo->_dwCurrResult >= NO_UNCACHED_RESULTS_TO_KEEP) ) {
            // Not caching --- evict the old result
            pEvictedResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult-NO_UNCACHED_RESULTS_TO_KEEP]);

            ADsNdsFreeBuffer(pEvictedResult->_hSearchResult);
            ADsNdsFreeNdsObjInfoList(pEvictedResult->_pObjects, pEvictedResult->_dwObjects);

            pEvictedResult->_hSearchResult = NULL;
            pEvictedResult->_pObjects = NULL;
            pEvictedResult->_dwObjects = 0;
            pEvictedResult->_fInUse = FALSE;
        }

        // Above, we test if we have incremented _dwObjectCurrent past the last
        // object in the result AND there are no more iterations.  This would happen
        // if there is exactly one object in this result, and that object is a duplicate
        // of the last object in the previous result (i.e., the _wcsicmp above is executed
        // and returns 0), and there are no more results (no more iterations to go).
        //
        // But, suppose the above conditions are true, EXCEPT that there are still more
        // iterations to go.  Then the above test wouldn't succeed, and we'd return with
        // _dwObjectCurrent == _dwObjects, an invalid condition.
        //
        // In this case, we've exhausted the result and must fetch the next one.
        // We do this by calling GetNextRow again.  Since _dwCurrResult has already been
        // incremented, our pNextResult will be the recursive call's pResult, it will look
        // like we've exhausted the objects in the result, and it will fetch the next result.
        //
        // Note that we do this recursive call after the caching code so that we evict the
        // _dwCurrResult-NO_UNCACHED_RESULTS_TO_KEEP entry before going on to _dwCurrResult+1.
        if( pNextResult->_dwObjectCurrent >= pNextResult->_dwObjects) {
            // phSearchInfo->_lIterationHandle != NO_MORE_ITERATIONS
            pNextResult->_dwObjectCurrent = pNextResult->_dwObjects-1;
            RRETURN(GetNextRow(hSearchHandle));
        }
    

        RRETURN(S_OK);
    }
    else {
        phSearchInfo->_dwCurrResult--;
        RRETURN(S_ADS_NOMORE_ROWS);
    }

error:
    RRETURN(hr);
}

HRESULT
CNDSGenObject::GetPreviousRow(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    PNDS_SEARCH_RESULT pResult, pPrevResult;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;

    if(!phSearchInfo || !phSearchInfo->_pSearchResults)
        RRETURN(E_FAIL);

    if (phSearchInfo->_fCheckForDuplicates) {
        phSearchInfo->_dwCurrAttr = 0;
    }

    if (phSearchInfo->_dwCurrResult < 0)
        RRETURN(S_ADS_NOMORE_ROWS);

    pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);

    if (pResult->_dwObjectCurrent > 0)
        pResult->_dwObjectCurrent--;
    else if (phSearchInfo->_dwCurrResult > 0) {
        pPrevResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult-1]);

        // Make sure the previous result hasn't been evicted from the cache
        if (!pPrevResult->_fInUse)
            RRETURN(S_ADS_NOMORE_ROWS);

        pPrevResult->_dwObjectCurrent = pPrevResult->_dwObjects-1;
        phSearchInfo->_cResultPrefetched++;
        phSearchInfo->_dwCurrResult--;


        // Check for duplicates
        if (phSearchInfo->_fCheckForDuplicates) {

            PADSNDS_OBJECT_INFO pObject, pPrevObject;

            pPrevObject = pPrevResult->_pObjects + pPrevResult->_dwObjectCurrent;
            pObject = pResult->_pObjects + pResult->_dwObjectCurrent;

            if (!_wcsicmp(pPrevObject->szObjectName, pObject->szObjectName)) {
                // dupe
                RRETURN(GetPreviousRow(hSearchHandle));
            }
        
        }

        
    }
    else if(0 == pResult->_dwObjectCurrent)
    // we are at the very beginning of the result set
        pResult->_dwObjectCurrent--;
    else
        RRETURN(S_ADS_NOMORE_ROWS);

    RRETURN(S_OK);

}


HRESULT
CNDSGenObject::GetColumn(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN LPWSTR pszColumnName,
    OUT PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    LPNDS_ATTR_INFO pAttribute;
    PNDS_SEARCH_RESULT pResult, pNextResult;
    PADSNDS_OBJECT_INFO   pObject, pNextObject;
    DWORD cAttr;
    BOOL fRowAdvanced = FALSE;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;

    LPWSTR pszNDSDn = NULL;
    LPWSTR pszNDSTreeName = NULL;
    LPWSTR szADsPath = NULL;


    if( !pColumn ||
        !phSearchInfo ||
        !phSearchInfo->_pSearchResults )
        RRETURN (E_ADS_BAD_PARAMETER);

    pColumn->pszAttrName = NULL;
    pColumn->dwADsType = ADSTYPE_INVALID;
    pColumn->pADsValues = NULL;
    pColumn->dwNumValues = 0;
    pColumn->hReserved = NULL;

    if (phSearchInfo->_dwCurrResult < 0)
        RRETURN(S_ADS_NOMORE_ROWS);

    pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);

    if( pResult->_dwObjectCurrent < 0 )
        RRETURN (E_ADS_BAD_PARAMETER);

    if ((pResult->_dwObjects == 0) || (!pResult->_pObjects))
        RRETURN (S_ADS_NOMORE_COLUMNS);

    pObject = pResult->_pObjects + pResult->_dwObjectCurrent;

    pColumn->pszAttrName = AllocADsStr(pszColumnName);
    if (!pColumn->pszAttrName) 
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    if(!_wcsicmp (pszColumnName, L"ADsPath")) {

        //
        // Build the ADsPathName
        //

        hr = BuildNDSPathFromADsPath2(
                    _ADsPath,
                    &pszNDSTreeName,
                    &pszNDSDn
                    );
        BAIL_ON_FAILURE(hr);

        hr = BuildADsPathFromNDSPath(
                 pszNDSTreeName,
                 pObject->szObjectName,
                 &szADsPath
                 );
        BAIL_ON_FAILURE(hr);

        if(*szADsPath) {
            pColumn->pADsValues = (PADSVALUE) AllocADsMem(sizeof(ADSVALUE));
            if (!pColumn->pADsValues) 
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            pColumn->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
            pColumn->dwNumValues = 1;
            pColumn->pADsValues[0].dwType = ADSTYPE_CASE_IGNORE_STRING;

            pColumn->pADsValues[0].CaseIgnoreString = AllocADsStr(szADsPath);
            if (!pColumn->pADsValues[0].CaseIgnoreString)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            pColumn->hReserved = pColumn->pADsValues[0].CaseIgnoreString;
        }

        if (szADsPath) {
            FreeADsMem(szADsPath);
        }
        
        if (pszNDSDn) {
            FreeADsMem(pszNDSDn);
        }
        
        if (pszNDSTreeName) {
            FreeADsMem(pszNDSTreeName);
        }

        RRETURN(S_OK);
    }

    if (phSearchInfo->_SearchPref._fAttrsOnly) {
        //
        // Only Names got. So, don't return any values
        //
        RRETURN (S_OK);
    }

    pAttribute = (LPNDS_ATTR_INFO)pObject->lpAttribute;

    for (cAttr=0;cAttr<pObject->dwNumAttributes;cAttr++,pAttribute++) {
        if (_wcsicmp(
                pAttribute->szAttributeName,
                pszColumnName
                ) == 0)
            break;
    }
    if (cAttr == pObject->dwNumAttributes) {
        if(pResult->_dwObjectCurrent+1 != pResult->_dwObjects ||
           (phSearchInfo->_lIterationHandle == NO_MORE_ITERATIONS &&
            (phSearchInfo->_cResultPrefetched == 0))) {
            //
            // No need to look in the next result set;             
            //
            BAIL_ON_FAILURE(hr = E_ADS_COLUMN_NOT_SET);
        }
        else {
            //
            // There is a chance that the column may come in the next
            // result set. So, fetch the next set of results.
            //
            // Since this isn't actually the user causing the row to be advanced,
            // we don't want to do any cache evictions
            phSearchInfo->_fCheckForDuplicates = FALSE;
            BOOL fCurrentCachingStatus = phSearchInfo->_SearchPref._fCacheResults;
            phSearchInfo->_SearchPref._fCacheResults = TRUE;
            hr = GetNextRow(
                     phSearchInfo
                     );
            phSearchInfo->_fCheckForDuplicates = TRUE;
            phSearchInfo->_SearchPref._fCacheResults = fCurrentCachingStatus;
            BAIL_ON_FAILURE(hr);

            if (hr == S_ADS_NOMORE_ROWS) {
                BAIL_ON_FAILURE(hr = E_ADS_COLUMN_NOT_SET);
            }

            fRowAdvanced = TRUE;

            pNextResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
            pNextObject = pNextResult->_pObjects + pNextResult->_dwObjectCurrent;
            if (_wcsicmp(pObject->szObjectName, pNextObject->szObjectName)) {
                //
                // No need to look in the next object; 
                //
                BAIL_ON_FAILURE(hr = E_ADS_COLUMN_NOT_SET);
            }
            else {
                //
                // Look in the next object
                //
                pAttribute = (LPNDS_ATTR_INFO)pNextObject->lpAttribute;
                for (cAttr=0;cAttr<pNextObject->dwNumAttributes;cAttr++,pAttribute++) {
                    if (_wcsicmp(
                            pAttribute->szAttributeName,
                            pszColumnName
                            ) == 0)
                        break;
                }
                if (cAttr == pNextObject->dwNumAttributes) {
                    //
                    // Didn't find in the next result set containing the row too
                    //
                    BAIL_ON_FAILURE(hr = E_ADS_COLUMN_NOT_SET);
                }
            }
        }
    }

    hr = NdsValueToADsColumn(
             pszColumnName,
             pAttribute->dwSyntaxId,
             pAttribute->dwNumberOfValues,
             (LPBYTE) pAttribute->lpValue,
             pColumn
             );
    BAIL_ON_FAILURE(hr);

    //
    // Added in to support the case when one multivalue attribute is split into 2 packets. The 
    // following case checks 
    // 1) if we haven't advanced the row, if we have advanced already, the whole
    //    Attribute will already be completely residing in the second packet
    // 2) the attribute was the last attribute from the last packet, thus 
    //    the next attribute, (the first attribute of the next row) might be
    //    the same.
    //
    if ((!fRowAdvanced) &&
            (cAttr == (pObject->dwNumAttributes - 1))) {

        //
        // If there is indeed a need to try out an extra packet
        //
        if(pResult->_dwObjectCurrent+1 != pResult->_dwObjects ||
           (phSearchInfo->_lIterationHandle  == NDS_NO_MORE_ITERATIONS &&
            (phSearchInfo->_cResultPrefetched == 0))) {
            //
            // No need to look in the next result set;
            //
            hr = S_OK;
            goto done;
        }
        else {
            //
            // There is a chance that the column may come in the next
            // result set. So, fetch the next set of results.
            //
            // Since this isn't actually the user causing the row to be advanced,
            // we don't want to do any cache evictions
            phSearchInfo->_fCheckForDuplicates = FALSE;
            BOOL fCurrentCachingStatus = phSearchInfo->_SearchPref._fCacheResults;
            phSearchInfo->_SearchPref._fCacheResults = TRUE;
            hr = GetNextRow(
                     phSearchInfo
                     );
            phSearchInfo->_fCheckForDuplicates = TRUE;
            phSearchInfo->_SearchPref._fCacheResults = fCurrentCachingStatus;
            BAIL_ON_FAILURE(hr);

            if (hr == S_ADS_NOMORE_ROWS) {
                hr = S_OK;
                goto done;
            }

            fRowAdvanced = TRUE;

            pNextResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
            pNextObject = pNextResult->_pObjects + pNextResult->_dwObjectCurrent;
            if (_wcsicmp(pObject->szObjectName, pNextObject->szObjectName)) {
                //
                // No need to look in the next object, since objname is different
                //
                hr = S_OK;
                goto done;
            }
            else {
                //
                // Look in the next object, look for the same attribute
                //
                pAttribute = (LPNDS_ATTR_INFO)pNextObject->lpAttribute;
                for (cAttr=0;cAttr<pNextObject->dwNumAttributes;cAttr++,pAttribute++) {
                    if (_wcsicmp(
                            pAttribute->szAttributeName,
                            pszColumnName
                            ) == 0)
                        break;
                }
                if (cAttr == pNextObject->dwNumAttributes) {
                    //
                    // Didn't find in the next result set containing the row too
                    //
                    hr = S_OK;
                    goto done;
                }
            }
        }

        // 
        // If found, we'll append it to the last column
        //
        hr = NdsValueToADsColumnAppend(
                         pAttribute->dwSyntaxId,
                         pAttribute->dwNumberOfValues,
                         (LPBYTE) pAttribute->lpValue,
                         pColumn
                         );
        BAIL_ON_FAILURE(hr);
    }
done:

    if (fRowAdvanced) {
        phSearchInfo->_fCheckForDuplicates = FALSE;
        GetPreviousRow(phSearchInfo);
        phSearchInfo->_fCheckForDuplicates = TRUE;
    }

    if (szADsPath) {
        FreeADsMem(szADsPath);
    }
    
    if (pszNDSDn) {
        FreeADsMem(pszNDSDn);
    }
    
    if (pszNDSTreeName) {
        FreeADsMem(pszNDSTreeName);
    }

    RRETURN(S_OK);

error:

    if (fRowAdvanced) {
        phSearchInfo->_fCheckForDuplicates = FALSE;
        GetPreviousRow(phSearchInfo);
        phSearchInfo->_fCheckForDuplicates = TRUE;
    }

    if (szADsPath) {
        FreeADsMem(szADsPath);
    }
    
    if (pszNDSDn) {
        FreeADsMem(pszNDSDn);
    }
    
    if (pszNDSTreeName) {
        FreeADsMem(pszNDSTreeName);
    }

    FreeColumn(pColumn);

    RRETURN (hr);
}



HRESULT
CNDSGenObject::GetNextColumnName(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT LPWSTR * ppszColumnName
    )
{
    HRESULT hr = S_OK;
    LPNDS_ATTR_INFO pAttribute;
    LPNDS_ATTR_INFO pAttributeOld = NULL;
    LPNDS_NAME_ONLY pNameOnlyAttr;
    PNDS_SEARCH_RESULT pResult, pNextResult;
    PADSNDS_OBJECT_INFO   pObject, pNextObject;
    BOOL fRowAdvanced = FALSE;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;

    if( !phSearchInfo ||
        !phSearchInfo->_pSearchResults ||
        !ppszColumnName)
        RRETURN (E_ADS_BAD_PARAMETER);

    *ppszColumnName = NULL;

    if (phSearchInfo->_dwCurrResult < 0)
        RRETURN(S_ADS_NOMORE_ROWS);

    pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);

    if( pResult->_dwObjectCurrent < 0 )
        RRETURN (E_ADS_BAD_PARAMETER);

    if ((pResult->_dwObjects == 0) || (!pResult->_pObjects))
        RRETURN (S_ADS_NOMORE_COLUMNS);

    pObject = pResult->_pObjects + pResult->_dwObjectCurrent;

    pNameOnlyAttr = (LPNDS_NAME_ONLY)pObject->lpAttribute + 
                    phSearchInfo->_dwCurrAttr;
    pAttribute = (LPNDS_ATTR_INFO)pObject->lpAttribute + 
                 phSearchInfo->_dwCurrAttr;

    //
    // Get the last attribute's name to test it to avoid getting duplicate 
    // column names. This will happen if a multi-value got divided into two 
    // packets. In that case, both attribute names would be the same.
    // We are only getting the last attribute if this object has greater than
    // 1 object, or else if this attribute is the first attribute, there would
    // not be a one before
    //
    if (phSearchInfo->_dwCurrAttr > 0) {
        pAttributeOld = pAttribute - 1;
    }

    if (phSearchInfo->_dwCurrAttr >= pObject->dwNumAttributes) {
        if(pResult->_dwObjectCurrent+1 != pResult->_dwObjects ||
           (phSearchInfo->_lIterationHandle == NO_MORE_ITERATIONS &&
            (phSearchInfo->_cResultPrefetched == 0))) {
            //
            // No need to look in the next result set;             
            //
            hr = S_ADS_NOMORE_COLUMNS;
            goto error;
        }
        else {
            //
            // There is a chance that the column may come in the next
            // result set. So, fetch the next set of results.
            //
            // Since this isn't actually the user causing the row to be advanced,
            // we don't want to do any cache evictions
            phSearchInfo->_fCheckForDuplicates = FALSE;
            BOOL fCurrentCachingStatus = phSearchInfo->_SearchPref._fCacheResults;
            phSearchInfo->_SearchPref._fCacheResults = TRUE;
            hr = GetNextRow(
                     phSearchInfo
                     );
            phSearchInfo->_fCheckForDuplicates = TRUE;
            phSearchInfo->_SearchPref._fCacheResults = fCurrentCachingStatus;

            BAIL_ON_FAILURE(hr);

            if (hr == S_ADS_NOMORE_ROWS) {
                hr = S_ADS_NOMORE_COLUMNS;
                goto error;
            }
    
            fRowAdvanced = TRUE;
    
            pNextResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
            pNextObject = pNextResult->_pObjects + pNextResult->_dwObjectCurrent;
            if (_wcsicmp(pObject->szObjectName, pNextObject->szObjectName)) {
                //
                // No need to look in the next object; 
                //
                hr = S_ADS_NOMORE_COLUMNS;
                goto error;
            }
            else {
                //
                // Look in the next object
                //
                pNameOnlyAttr = (LPNDS_NAME_ONLY)pNextObject->lpAttribute + 
                                 phSearchInfo->_dwCurrAttr - 
                                  pObject->dwNumAttributes;
                pAttribute = (LPNDS_ATTR_INFO)pNextObject->lpAttribute + 
                                 phSearchInfo->_dwCurrAttr - 
                                  pObject->dwNumAttributes;
                //
                // If the new attribute is after the first attribute in the new object,
                // we'll reset AttributeOld to point to the attribute before this.
                // Because the old attribute will be the one before the current one
                // in this case.
                //
                if ((phSearchInfo->_dwCurrAttr - pObject->dwNumAttributes) > 0) {
                    pAttributeOld = pAttribute - 1;
                }

                if (phSearchInfo->_dwCurrAttr >= (pObject->dwNumAttributes + 
                                          pNextObject->dwNumAttributes)) {
                    //
                    // Didn't find in the next result set 
                    // containing the row too
                    //
                    hr = S_ADS_NOMORE_COLUMNS;
                    goto error;
                }

                //
                // If it is a duplicate column, go on to the next one
                //
                if (pAttributeOld) {
                    if(wcscmp(pAttribute->szAttributeName, 
                              pAttributeOld->szAttributeName) == 0) {
                        phSearchInfo->_dwCurrAttr++;
                        if (phSearchInfo->_dwCurrAttr >= (pObject->dwNumAttributes +
                                                          pNextObject->dwNumAttributes)) {
                            //
                            // Didn't find in the next result set
                            // containing the row too
                            //
                            hr = S_ADS_NOMORE_COLUMNS;
                            goto error;
                        }
                        pNameOnlyAttr = (LPNDS_NAME_ONLY)pNextObject->lpAttribute +
                                 phSearchInfo->_dwCurrAttr -
                                     pObject->dwNumAttributes;
                        pAttribute = (LPNDS_ATTR_INFO)pNextObject->lpAttribute +
                                     phSearchInfo->_dwCurrAttr -
                                     pObject->dwNumAttributes;
                    }
                }

            }
        }
    }

    if (phSearchInfo->_SearchPref._fAttrsOnly) 
    *ppszColumnName = AllocADsStr(
                          pNameOnlyAttr->szName
                          );
    else 
    *ppszColumnName = AllocADsStr(
                          pAttribute->szAttributeName
                          );

    phSearchInfo->_dwCurrAttr++;

    if (fRowAdvanced) {
        phSearchInfo->_fCheckForDuplicates = FALSE;
        GetPreviousRow(phSearchInfo);
        phSearchInfo->_fCheckForDuplicates = TRUE;
    }

    RRETURN(S_OK);

error:

    if (fRowAdvanced) {
        phSearchInfo->_fCheckForDuplicates = FALSE;
        GetPreviousRow(phSearchInfo);
        phSearchInfo->_fCheckForDuplicates = TRUE;
    }

    if (*ppszColumnName) 
        FreeADsStr(*ppszColumnName);


    if (hr == S_ADS_NOMORE_COLUMNS && phSearchInfo->_fADsPathPresent) {

        //
        // If ADsPath was specified, return it as the last column in the row
        //

        if (!phSearchInfo->_fADsPathReturned) {

            *ppszColumnName = AllocADsStr(L"ADsPath");
            phSearchInfo->_fADsPathReturned = TRUE;
            hr = S_OK;
        }
        else {

            // 
            // We need to reset it back so that we return it for the next
            // row
            //

            phSearchInfo->_fADsPathReturned = FALSE;
            hr = S_ADS_NOMORE_COLUMNS;
        }

    }

    RRETURN (hr);
}


HRESULT
CNDSGenObject::FreeColumn(
    IN PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr = S_OK;

    if(!pColumn)
        RRETURN (E_ADS_BAD_PARAMETER);

    if (pColumn->pszAttrName) 
        FreeADsStr(pColumn->pszAttrName);
    
    if (pColumn->pADsValues) {
        AdsFreeAdsValues(pColumn->pADsValues, pColumn->dwNumValues);
        FreeADsMem(pColumn->pADsValues);
    }

    RRETURN(hr);
}


HRESULT
NdsValueToADsColumn(
    LPWSTR      pszColumnName,
    DWORD       dwSyntaxId,
    DWORD       dwValues,
    LPBYTE      lpObject,
    ADS_SEARCH_COLUMN * pColumn
    )
{
    HRESULT hr = S_OK;
    LPNDS_ASN1_TYPE_1 lpNDS_ASN1_1;
    LPNDS_ASN1_TYPE_7 lpNDS_ASN1_7;
    LPNDS_ASN1_TYPE_8 lpNDS_ASN1_8;
    LPNDS_ASN1_TYPE_9 lpNDS_ASN1_9;
    LPNDS_ASN1_TYPE_11 lpNDS_ASN1_11;
    LPNDS_ASN1_TYPE_14 lpNDS_ASN1_14;
    LPNDS_ASN1_TYPE_18 lpNDS_ASN1_18;
    LPNDS_ASN1_TYPE_20 lpNDS_ASN1_20;
    LPNDS_ASN1_TYPE_24 lpNDS_ASN1_24;
    DWORD i, j, dwValuesAllocated = 0;
    LPBYTE lpValue = NULL;
    PNDSOBJECT lpNdsObject = NULL;

    if(!pszColumnName || !pColumn || !lpObject)
        RRETURN(E_ADS_BAD_PARAMETER);

    lpNdsObject = (PNDSOBJECT) lpObject;

    pColumn->hReserved = NULL;
    pColumn->dwNumValues = dwValues;
    pColumn->pADsValues = (PADSVALUE) AllocADsMem(
                                          sizeof(ADSVALUE) * dwValues
                                          );
    if (!pColumn->pADsValues) 
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);


    if (dwSyntaxId >= g_cMapNdsTypeToADsType) 
        pColumn->dwADsType = ADSTYPE_INVALID;
    else 
        pColumn->dwADsType = g_MapNdsTypeToADsType[dwSyntaxId];

    switch (dwSyntaxId) {
        // WIDE STRING
        case NDS_SYNTAX_ID_1:
        case NDS_SYNTAX_ID_2:
        case NDS_SYNTAX_ID_3:
        case NDS_SYNTAX_ID_4:
        case NDS_SYNTAX_ID_5:
        case NDS_SYNTAX_ID_10:
            for (i=0; i < dwValues; i++) {
                lpNDS_ASN1_1 = (LPNDS_ASN1_TYPE_1) &((lpNdsObject + i)->NdsValue);
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[i].CaseIgnoreString = AllocADsStr(lpNDS_ASN1_1->DNString);
                
                if (!(pColumn->pADsValues[i].CaseIgnoreString))
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

                dwValuesAllocated++;
            }
            break;
            
        case NDS_SYNTAX_ID_20:
            for (i=0; i < dwValues; i++) {
                lpNDS_ASN1_20 = (LPNDS_ASN1_TYPE_20) &((lpNdsObject + i)->NdsValue);
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[i].ClassName = AllocADsStr(lpNDS_ASN1_20->ClassName);
                
                if (!(pColumn->pADsValues[i].ClassName))
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

                dwValuesAllocated++;
            }
            break;

        // EMAIL                
        case NDS_SYNTAX_ID_14 :
            for (i=0; i < dwValues; i++) {
                lpNDS_ASN1_14 = (LPNDS_ASN1_TYPE_14) &((lpNdsObject + i)->NdsValue);
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[i].Email.Address = AllocADsStr(lpNDS_ASN1_14->Address);
                pColumn->pADsValues[i].Email.Type = lpNDS_ASN1_14->Type;
                
                if (!(pColumn->pADsValues[i].Email.Address))
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

                dwValuesAllocated++;
            }
            break;
            
        // BYTE STREAM
        case NDS_SYNTAX_ID_9:
            for (i=0; i < dwValues; i++) {
                lpNDS_ASN1_9 = (LPNDS_ASN1_TYPE_9) &((lpNdsObject + i)->NdsValue);
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                
                if (lpNDS_ASN1_9->Length)
                {
                    LPBYTE lpByte = (LPBYTE)AllocADsMem(lpNDS_ASN1_9->Length);
                    if (!lpByte)
                        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                    
                    if (lpNDS_ASN1_9->OctetString)
                        memcpy(lpByte, lpNDS_ASN1_9->OctetString, lpNDS_ASN1_9->Length);
                    
                    pColumn->pADsValues[i].OctetString.dwLength =lpNDS_ASN1_9->Length;
                    pColumn->pADsValues[i].OctetString.lpValue = lpByte;
                }
                else
                {
                    pColumn->pADsValues[i].OctetString.dwLength = 0;
                    pColumn->pADsValues[i].OctetString.lpValue = NULL;
                }

                dwValuesAllocated++;
            }
            break;
            
        // BOOLEAN
        case NDS_SYNTAX_ID_7:
            for (i=0; i < dwValues; i++) {
                lpNDS_ASN1_7 = (LPNDS_ASN1_TYPE_7) &((lpNdsObject + i)->NdsValue);
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[i].Boolean = lpNDS_ASN1_7->Boolean;
            }

            dwValuesAllocated = dwValues;   // no intermediate failures possible
            break;
            
        // INTEGER
        case NDS_SYNTAX_ID_8:
        case NDS_SYNTAX_ID_22:
        case NDS_SYNTAX_ID_27:
            for (i=0; i < dwValues; i++) {
                lpNDS_ASN1_8 = (LPNDS_ASN1_TYPE_8) &((lpNdsObject + i)->NdsValue);
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[i].Integer = lpNDS_ASN1_8->Integer;
            }

            dwValuesAllocated = dwValues;   // no intermediate failures possible
            break;
            
        // TIME
        case NDS_SYNTAX_ID_24 :
            for (i=0; i < dwValues; i++) {
                lpNDS_ASN1_24 = (LPNDS_ASN1_TYPE_24) &((lpNdsObject + i)->NdsValue);
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                hr = ConvertDWORDtoSYSTEMTIME(
                    lpNDS_ASN1_24->Time,
                    &(pColumn->pADsValues[i].UTCTime)
                    );
                BAIL_ON_FAILURE(hr);

                dwValuesAllocated++;
            }
            break;

        // FAX NUMBER
        case NDS_SYNTAX_ID_11 :
            for (i=0; i < dwValues; i++) {
                lpNDS_ASN1_11 = (LPNDS_ASN1_TYPE_11) &((lpNdsObject + i)->NdsValue);

                pColumn->pADsValues[i].dwType = pColumn->dwADsType;

                pColumn->pADsValues[i].pFaxNumber = (PADS_FAXNUMBER)AllocADsMem(sizeof(ADS_FAXNUMBER));
                if (!pColumn->pADsValues[i].pFaxNumber) {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }

                pColumn->pADsValues[i].pFaxNumber->TelephoneNumber =
                                        AllocADsStr(lpNDS_ASN1_11->TelephoneNumber);

                if (!pColumn->pADsValues[i].pFaxNumber->TelephoneNumber) {
                    FreeADsMem(pColumn->pADsValues[i].pFaxNumber);
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }

                hr = CopyOctetString(lpNDS_ASN1_11->NumberOfBits,
                                     lpNDS_ASN1_11->Parameters,
                                     &pColumn->pADsValues[i].pFaxNumber->NumberOfBits,
                                     &pColumn->pADsValues[i].pFaxNumber->Parameters);
                if (FAILED(hr)) {
                    FreeADsStr(pColumn->pADsValues[i].pFaxNumber->TelephoneNumber);
                    FreeADsMem(pColumn->pADsValues[i].pFaxNumber);
                    BAIL_ON_FAILURE(hr);
                }

                dwValuesAllocated++;
            }
            break;

        // POSTAL ADDRESS
        case NDS_SYNTAX_ID_18 :
            for (i=0; i<dwValues; i++) {
                lpNDS_ASN1_18 = (LPNDS_ASN1_TYPE_18) &((lpNdsObject + i)->NdsValue);
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                
                pColumn->pADsValues[i].pPostalAddress = (PADS_POSTALADDRESS)AllocADsMem(sizeof(ADS_POSTALADDRESS));
                if (!pColumn->pADsValues[i].pPostalAddress) {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }
                
                for (j=0;j<6;j++) {
                    if (lpNDS_ASN1_18->PostalAddress[j]) {
                        pColumn->pADsValues[i].pPostalAddress->PostalAddress[j] =
                            AllocADsStr(
                            lpNDS_ASN1_18->PostalAddress[j]
                            );
                    }
                    else {
                        pColumn->pADsValues[i].pPostalAddress->PostalAddress[j] =
                            AllocADsStr(
                            L""
                            );
                    }
                    if (!pColumn->pADsValues[i].pPostalAddress->PostalAddress[j]) {
                        hr = E_OUTOFMEMORY;
                        while (j>0) {
                            FreeADsStr(pColumn->pADsValues[i].pPostalAddress->PostalAddress[j-1]);
                            j--;
                        }
                        FreeADsMem(pColumn->pADsValues[i].pPostalAddress);
                        BAIL_ON_FAILURE(hr);
                    }
                }

                dwValuesAllocated++;
            }
            break;

        case NDS_SYNTAX_ID_6 :
        case NDS_SYNTAX_ID_12 :
        case NDS_SYNTAX_ID_13 :
        case NDS_SYNTAX_ID_15 :
        case NDS_SYNTAX_ID_16 :
        case NDS_SYNTAX_ID_17 :
        case NDS_SYNTAX_ID_19 :
        case NDS_SYNTAX_ID_21 :
        case NDS_SYNTAX_ID_23 :
        case NDS_SYNTAX_ID_25 :
        case NDS_SYNTAX_ID_26 :
        default:
            for (i=0; i < dwValues; i++) {
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[i].ProviderSpecific.dwLength =0;
                pColumn->pADsValues[i].ProviderSpecific.lpValue = NULL;
            }

            dwValuesAllocated = dwValues;   // no intermediate failures possible
            break;
    }
    RRETURN(hr);

error:

    if (pColumn->pADsValues) {
        AdsFreeAdsValues(pColumn->pADsValues, dwValuesAllocated);

        FreeADsMem(pColumn->pADsValues);
        pColumn->pADsValues = NULL;
        pColumn->dwNumValues = 0;
    }

    RRETURN(hr);
}

HRESULT
NdsValueToADsColumnAppend(
    DWORD       dwSyntaxId,
    DWORD       dwValues,
    LPBYTE      lpObject,
    ADS_SEARCH_COLUMN * pColumn
    )
{
    HRESULT hr = S_OK;
    LPNDS_ASN1_TYPE_1 lpNDS_ASN1_1;
    LPNDS_ASN1_TYPE_7 lpNDS_ASN1_7;
    LPNDS_ASN1_TYPE_8 lpNDS_ASN1_8;
    LPNDS_ASN1_TYPE_9 lpNDS_ASN1_9;
    LPNDS_ASN1_TYPE_11 lpNDS_ASN1_11;
    LPNDS_ASN1_TYPE_14 lpNDS_ASN1_14;
    LPNDS_ASN1_TYPE_18 lpNDS_ASN1_18;
    LPNDS_ASN1_TYPE_20 lpNDS_ASN1_20;
    LPNDS_ASN1_TYPE_24 lpNDS_ASN1_24;
    DWORD i, j, dwValuesAllocated;
    PNDSOBJECT lpNdsObject = NULL;
    PADSVALUE pADsValuesNew = NULL;
    DWORD dwValuesBase;

    if(!pColumn || !lpObject)
        RRETURN(E_ADS_BAD_PARAMETER);

    dwValuesBase = pColumn->dwNumValues;
    dwValuesAllocated = pColumn->dwNumValues;
    lpNdsObject = (PNDSOBJECT) lpObject;

    //
    // Allocate memory for new values + old values
    //
    pADsValuesNew = (PADSVALUE) AllocADsMem(
                          sizeof(ADSVALUE) * (pColumn->dwNumValues + dwValues)
                          );
    if (!pADsValuesNew) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Copy old values into new array, and free the old one
    //
    memcpy(pADsValuesNew,
           pColumn->pADsValues,
           sizeof(ADSVALUE) * dwValuesBase);
    FreeADsMem(pColumn->pADsValues);
    pColumn->pADsValues = pADsValuesNew;

    switch (dwSyntaxId) {
        // WIDE STRING
        case NDS_SYNTAX_ID_1:
        case NDS_SYNTAX_ID_2:
        case NDS_SYNTAX_ID_3:
        case NDS_SYNTAX_ID_4:
        case NDS_SYNTAX_ID_5:
        case NDS_SYNTAX_ID_10:
            for (i=0; i < dwValues; i++) {
                lpNDS_ASN1_1 = (LPNDS_ASN1_TYPE_1) &((lpNdsObject + i)->NdsValue);
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].CaseIgnoreString = AllocADsStr(lpNDS_ASN1_1->DNString);

                if (!(pColumn->pADsValues[dwValuesBase+i].CaseIgnoreString))
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

                dwValuesAllocated++;
            }
            break;

        case NDS_SYNTAX_ID_20:
            for (i=0; i < dwValues; i++) {
                lpNDS_ASN1_20 = (LPNDS_ASN1_TYPE_20) &((lpNdsObject + i)->NdsValue);
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].ClassName = AllocADsStr(lpNDS_ASN1_20->ClassName);
                
                if (!(pColumn->pADsValues[dwValuesBase+i].ClassName))
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                
                dwValuesAllocated++;
            }
            break;
         
        // EMAIL    
        case NDS_SYNTAX_ID_14 :
            for (i=0; i < dwValues; i++) {
                lpNDS_ASN1_14 = (LPNDS_ASN1_TYPE_14) &((lpNdsObject + i)->NdsValue);
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].Email.Address = AllocADsStr(lpNDS_ASN1_14->Address);
                pColumn->pADsValues[dwValuesBase+i].Email.Type = lpNDS_ASN1_14->Type;
                
                if (!(pColumn->pADsValues[dwValuesBase+i].Email.Address))
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                
                dwValuesAllocated++;
            }
            break;

        // BYTE STREAM
        case NDS_SYNTAX_ID_9:
            for (i=0; i < dwValues; i++) {
                lpNDS_ASN1_9 = (LPNDS_ASN1_TYPE_9) &((lpNdsObject + i)->NdsValue);
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;

                if (lpNDS_ASN1_9->Length)
                {
                    LPBYTE lpByte = (LPBYTE)AllocADsMem(lpNDS_ASN1_9->Length);
                    if (!lpByte)
                        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

                    if (lpNDS_ASN1_9->OctetString)
                        memcpy(lpByte, lpNDS_ASN1_9->OctetString, lpNDS_ASN1_9->Length);

                    pColumn->pADsValues[dwValuesBase+i].OctetString.dwLength =lpNDS_ASN1_9->Length;
                    pColumn->pADsValues[dwValuesBase+i].OctetString.lpValue = lpByte;
                }
                else
                {
                    pColumn->pADsValues[dwValuesBase+i].OctetString.dwLength = 0;
                    pColumn->pADsValues[dwValuesBase+i].OctetString.lpValue = NULL;
                }

                dwValuesAllocated++;
            }
            break;

        // BOOLEAN
        case NDS_SYNTAX_ID_7:
            for (i=0; i < dwValues; i++) {
                lpNDS_ASN1_7 = (LPNDS_ASN1_TYPE_7) &((lpNdsObject + i)->NdsValue);
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].Boolean = lpNDS_ASN1_7->Boolean;
            }

            dwValuesAllocated += dwValues;  // no intermediate failures possible
            break;

        // INTEGER
        case NDS_SYNTAX_ID_8:
        case NDS_SYNTAX_ID_22:
        case NDS_SYNTAX_ID_27:
            for (i=0; i < dwValues; i++) {
                lpNDS_ASN1_8 = (LPNDS_ASN1_TYPE_8) &((lpNdsObject + i)->NdsValue);
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].Integer = lpNDS_ASN1_8->Integer;
            }

            dwValuesAllocated += dwValues;  // no intermediate failures possible
            break;

        // TIME
        case NDS_SYNTAX_ID_24 :
            for (i=0; i < dwValues; i++) {
                lpNDS_ASN1_24 = (LPNDS_ASN1_TYPE_24) &((lpNdsObject + i)->NdsValue);
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                hr = ConvertDWORDtoSYSTEMTIME(
                            lpNDS_ASN1_24->Time,
                            &(pColumn->pADsValues[dwValuesBase+i].UTCTime)
                            );
                BAIL_ON_FAILURE(hr);

                dwValuesAllocated++;
            }
            break;

        // FAX NUMBER
        case NDS_SYNTAX_ID_11 :
            for (i=0; i < dwValues; i++) {
                lpNDS_ASN1_11 = (LPNDS_ASN1_TYPE_11) &((lpNdsObject + i)->NdsValue);

                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;

                pColumn->pADsValues[dwValuesBase+i].pFaxNumber = (PADS_FAXNUMBER)AllocADsMem(sizeof(ADS_FAXNUMBER));
                if (!pColumn->pADsValues[dwValuesBase+i].pFaxNumber) {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }

                pColumn->pADsValues[dwValuesBase+i].pFaxNumber->TelephoneNumber =
                                        AllocADsStr(lpNDS_ASN1_11->TelephoneNumber);

                if (!pColumn->pADsValues[dwValuesBase+i].pFaxNumber->TelephoneNumber) {
                    FreeADsMem(pColumn->pADsValues[dwValuesBase+i].pFaxNumber);
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }

                hr = CopyOctetString(lpNDS_ASN1_11->NumberOfBits,
                                     lpNDS_ASN1_11->Parameters,
                                     &pColumn->pADsValues[dwValuesBase+i].pFaxNumber->NumberOfBits,
                                     &pColumn->pADsValues[dwValuesBase+i].pFaxNumber->Parameters);
                if (FAILED(hr)) {
                    FreeADsStr(pColumn->pADsValues[dwValuesBase+i].pFaxNumber->TelephoneNumber);
                    FreeADsMem(pColumn->pADsValues[dwValuesBase+i].pFaxNumber);
                    BAIL_ON_FAILURE(hr);
                }

                dwValuesAllocated++;
            }
            break;

        // POSTAL ADDRESS
        case NDS_SYNTAX_ID_18 :
            for (i=0; i<dwValues; i++) {
                lpNDS_ASN1_18 = (LPNDS_ASN1_TYPE_18) &((lpNdsObject + i)->NdsValue);
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                
                pColumn->pADsValues[dwValuesBase+i].pPostalAddress = (PADS_POSTALADDRESS)AllocADsMem(sizeof(ADS_POSTALADDRESS));
                if (!pColumn->pADsValues[dwValuesBase+i].pPostalAddress) {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }
                
                for (j=0;j<6;j++) {
                    if (lpNDS_ASN1_18->PostalAddress[j]) {
                        pColumn->pADsValues[dwValuesBase+i].pPostalAddress->PostalAddress[j] =
                            AllocADsStr(
                            lpNDS_ASN1_18->PostalAddress[j]
                            );
                    }
                    else {
                        pColumn->pADsValues[dwValuesBase+i].pPostalAddress->PostalAddress[j] =
                            AllocADsStr(
                            L""
                            );
                    }
                    if (!pColumn->pADsValues[dwValuesBase+i].pPostalAddress->PostalAddress[j]) {
                        hr = E_OUTOFMEMORY;
                        while (j>0) {
                            FreeADsStr(pColumn->pADsValues[dwValuesBase+i].pPostalAddress->PostalAddress[j-1]);
                            j--;
                        }
                        FreeADsMem(pColumn->pADsValues[dwValuesBase+i].pPostalAddress);
                        BAIL_ON_FAILURE(hr);
                    }
                }

                dwValuesAllocated++;
            }
            break;

        case NDS_SYNTAX_ID_6 :
        case NDS_SYNTAX_ID_12 :
        case NDS_SYNTAX_ID_13 :
        case NDS_SYNTAX_ID_15 :
        case NDS_SYNTAX_ID_16 :
        case NDS_SYNTAX_ID_17 :
        case NDS_SYNTAX_ID_19 :
        case NDS_SYNTAX_ID_21 :
        case NDS_SYNTAX_ID_23 :
        case NDS_SYNTAX_ID_25 :
        case NDS_SYNTAX_ID_26 :
        default:
            for (i=0; i < dwValues; i++) {
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].ProviderSpecific.dwLength =0;
                pColumn->pADsValues[dwValuesBase+i].ProviderSpecific.lpValue = NULL;
            }

            dwValuesAllocated += dwValues;
            break;
    }
    pColumn->dwNumValues = pColumn->dwNumValues + dwValues;
    
    RRETURN(hr);

error:

    if (pColumn->pADsValues) {
        AdsFreeAdsValues(pColumn->pADsValues, dwValuesAllocated);

        FreeADsMem(pColumn->pADsValues);
        pColumn->pADsValues = NULL;
        pColumn->dwNumValues = 0;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cenumcls.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumsch.cxx
//
//  Contents:  NDS Class Enumeration Code
//
//             CNDSClassEnum::CNDSClassEnum()
//             CNDSClassEnum::CNDSClassEnum
//             CNDSClassEnum::EnumObjects
//             CNDSClassEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNDSClassEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSClassEnum::Create(
    CNDSClassEnum FAR* FAR* ppenumvariant,
    BSTR bstrADsPath,
    BSTR bstrName,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CNDSClassEnum FAR* penumvariant = NULL;
    LPWSTR pszDn = NULL;

    if (!ppenumvariant) {
        RRETURN(E_FAIL);
    }
    *ppenumvariant = NULL;

    penumvariant = new CNDSClassEnum();
    if (!penumvariant)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildNDSPathFromADsPath2(
                bstrADsPath,
                &penumvariant->_pszNDSTreeName,
                &pszDn
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsOpenContext(
             penumvariant->_pszNDSTreeName,
             Credentials,
             &penumvariant->_hADsContext
             );
    BAIL_ON_FAILURE(hr);
 
    hr = ADsAllocString( bstrADsPath, &penumvariant->_bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrName, &penumvariant->_bstrName);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    delete penumvariant;

    RRETURN(hr);
}

CNDSClassEnum::CNDSClassEnum()
    : _bstrADsPath( NULL ),
      _bstrName( NULL ),
      _pszNDSTreeName( NULL ),
      _pObjList( NULL ),
      _dwCurrentEntry( 0 ),
      _pPropNameList( NULL),
      _pCurrentEntry( NULL ),
      _bNoMore(FALSE)
{
    _hOperationData = NULL;
    _hADsContext = NULL;
    _lpClassDefs = NULL;

    _dwObjectCurrentEntry = 0;
    _dwObjectReturned = 0;

    _dwInfoType =  DS_EXPANDED_CLASS_DEFS;
}

CNDSClassEnum::~CNDSClassEnum()
{
   ADsFreeString( _bstrName );
   ADsFreeString( _bstrADsPath );
   ADsFreeString( _pszNDSTreeName );

   ADsNdsFreeClassDefList(_lpClassDefs, _dwObjectReturned);
   ADsNdsFreeBuffer(_hOperationData);

   if (_hADsContext) {
       ADsNdsCloseContext(_hADsContext);
   }


   if ( _pObjList != NULL )
   {
       delete _pObjList;
       _pObjList = NULL;
   }
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSClassEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   yihsins     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSClassEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumProperties(
                cElements,
                pvar,
                &cElementFetched
                );

    if ( pcElementFetched )
        *pcElementFetched = cElementFetched;

    RRETURN(hr);
}

HRESULT
CNDSClassEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    switch (ObjectType)
    {
        case NDS_PROPERTY_ID:
            RRETURN (EnumProperties(cElements, pvar, pcElementFetched));

        default:
            RRETURN(S_FALSE);
    }
}

HRESULT
CNDSClassEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)
        VariantInit(&pvar[i]);

    cRequested = cElements;

    while (  SUCCEEDED( _pObjList->GetCurrentObject(&ObjectType))
          && ((hr = EnumObjects( ObjectType,
                                 cRequested,
                                 pPathvar,
                                 &cFetchedByPath)) == S_FALSE )
          )
    {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if ( FAILED(_pObjList->Next()) )
        {
            if ( pcElementFetched )
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

        _dwCurrentEntry = 0;
    }

    if ( pcElementFetched )
        *pcElementFetched = cTotalFetched + cFetchedByPath;

    RRETURN(hr);
}

HRESULT
CNDSClassEnum::EnumProperties(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetPropertyObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNDSClassEnum::GetPropertyObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    PNDS_CLASS_DEF lpCurrentObject = NULL;

    *ppDispatch = NULL;

    if (!_hOperationData || (_dwObjectCurrentEntry == _dwObjectReturned)) {

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        if (_hOperationData) {

            ADsNdsFreeClassDefList(_lpClassDefs, _dwObjectReturned);
            _lpClassDefs = NULL;
        }

        if (_bNoMore) {

            hr = S_FALSE;
            goto error;
        }

        hr = ADsNdsReadClassDef(
                        _hADsContext,
                        DS_EXPANDED_CLASS_DEFS, 
                        &_bstrName,
                        (DWORD) 1,
                        &_hOperationData
                        );
        BAIL_ON_FAILURE(hr);

        if (hr == S_ADS_NOMORE_ROWS) {
            _bNoMore = TRUE;
        }

        hr = ADsNdsGetClassDefListFromBuffer(
                        _hADsContext,
                        _hOperationData,
                        &_dwObjectReturned,
                        &_dwInfoType,
                        &_lpClassDefs
                        );
        BAIL_ON_FAILURE(hr);

        if (_dwObjectReturned == 0 ) {

            RRETURN (S_FALSE);
            goto error;
        }
        //
        // Assert to check that we returned only 1 object
        //
    
        ADsAssert(_dwObjectReturned == 1);
    
    
        _pPropNameList = GeneratePropertyList(
                            _lpClassDefs->lpMandatoryAttributes,
                            _lpClassDefs->lpOptionalAttributes
                            );
        if (!_pPropNameList) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }
    
        _pCurrentEntry  = _pPropNameList;
    }


    if (_pCurrentEntry) {

        //
        // Now send back the current object
        //

        hr = CNDSProperty::CreateProperty(
                            _bstrADsPath,
                            _pCurrentEntry->pszPropName,
                            _hOperationData,
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
        BAIL_ON_FAILURE(hr);

        _pCurrentEntry = _pCurrentEntry->pNext;
        RRETURN(S_OK);
    }
error:
    RRETURN(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cenumns.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumvar.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//             CNDSNamespaceEnum::Create
//             CNDSNamespaceEnum::CNDSNamespaceEnum
//             CNDSNamespaceEnum::~CNDSNamespaceEnum
//             CNDSNamespaceEnum::Next
//             CNDSNamespaceEnum::FetchObjects
//             CNDSNamespaceEnum::FetchNextObject
//             CNDSNamespaceEnum::PrepBuffer
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop

#define ENUM_BUFFER_SIZE (1024 * 16)

//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSNamespaceEnum::Create(
    CNDSNamespaceEnum FAR* FAR* ppenumvariant,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CNDSNamespaceEnum FAR* penumvariant = NULL;
    DWORD dwStatus;

    penumvariant = new CNDSNamespaceEnum();

    if (penumvariant == NULL){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    if (penumvariant) {
        delete penumvariant;
    }
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::CNDSNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNDSNamespaceEnum::CNDSNamespaceEnum()
{
    _dwEntriesRead = 0;
    _dwCurrentEntry = 0;
    _pBuffer = NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::~CNDSNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNDSNamespaceEnum::~CNDSNamespaceEnum()
{

    if (_pBuffer)
        FreeADsMem(_pBuffer);

}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::Next
//
//  Synopsis:   Returns cElements number of requested ADs objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSNamespaceEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = FetchObjects(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN(hr);
}


HRESULT
CNDSNamespaceEnum::FetchObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = FetchNextObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::FetchNextObject
//
//  Synopsis:   Gets IDispatch pointer of next object in namespace.
//
//  Arguments:  [ppDispatch] -- Pointer to where to return IDispatch pointer.
//
//  Returns:    HRESULT -- S_OK if got the next object
//                      -- S_FALSE if not
//
//  Modifies:   [*ppDispatch]
//
//  History:    31-Jul-96   t-danal   Use Multiple Network Provider for enum
//
//----------------------------------------------------------------------------
HRESULT
CNDSNamespaceEnum::FetchNextObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr;
    DWORD dwStatus;
    LPTSTR lpTreeName ;

    *ppDispatch = NULL;

    //
    // Ensure that the buffer is valid
    //

    hr = PrepBuffer();
    BAIL_ON_FAILURE(hr);

    //
    // Grab next (tree) name out of the buffer
    //

    lpTreeName = (LPWSTR)_pBuffer + (_dwCurrentEntry++  * OBJ_NAME_SIZE) ;


    //
    // Now create and send back the current object
    //

    hr = CNDSTree::CreateTreeObject(
                L"NDS:",
                lpTreeName,
                L"Top",
                _Credentials,
                ADS_OBJECT_BOUND,
                IID_IDispatch,
                (void **)ppDispatch
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_ENUM_STATUS(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::PrepBuffer
//
//  Synopsis:   Ensures that the enumeration buffer has something
//
//  Arguments:  none
//
//  Returns:    HRESULT -- S_OK if the buffer is ready to be used
//                      -- an error if not
//
//  Modifies:   _pBuffer, _dwCurrentEntry, _dwEntriesRead
//
//  History:    31-Jul-96   t-danal   Created
//
//----------------------------------------------------------------------------
HRESULT
CNDSNamespaceEnum::PrepBuffer()
{

    HRESULT       hr = S_OK;
    DWORD         cb = ENUM_BUFFER_SIZE;
    DWORD         dwIter = 0, i;
    BOOL          fFound ;
    LPWSTR        lpString = NULL;
    WCHAR         pszObjectName[OBJ_NAME_SIZE];

    NWDSCCODE     ccode;
    nuint32       connRef = 0;
    nstr8         aObjectName[OBJ_NAME_SIZE];
    nuint32       objectID = 0xFFFFFFFF;  /* -1 */
    nuint16       objectType;
    nuint8        objectHasProperties;
    nuint8        objectFlag;
    nuint8        objectSecurity;
    NWCCConnInfo  connInfo;
    NWCONN_HANDLE connHandle;
    nstr8         searchObjectName[48] = "*";
    nuint16       searchObjectType = OT_TREE_NAME;

    //
    // Fill buffer as need. In theory we can get called to refill.
    // But since we need get everything to remove dups in
    // th case of TREEs, we dont allow this case. Ie. we get all
    // and there should be no more. So if _dwCurrentEntry is not
    // 0 and we need read more - then its time to bail.
    //

    if ( (_dwCurrentEntry < _dwEntriesRead) ) {
        //
        // Buffer still good
        //
        ADsAssert(_pBuffer) ;
        return(S_OK) ;
    }

    if (_dwCurrentEntry != 0) {
        return (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
    }

    //
    // Allocate buffer, if needed
    //

    if (!_pBuffer) {
        _pBuffer = AllocADsMem(cb);
        if (!_pBuffer) {
            hr = E_OUTOFMEMORY;
            RRETURN(hr);
        }
        lpString = (LPWSTR) _pBuffer ;
        _pBufferEnd = (LPBYTE)_pBuffer + cb ;
    }

    //
    // Get handle
    //
    ccode = NWCCGetPrimConnRef(
                &connRef
                );
 
    ccode = NWCCOpenConnByRef(
                connRef,
                NWCC_OPEN_UNLICENSED,
                NWCC_RESERVED,
                &connHandle
                );

    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    ccode = NWCCGetAllConnInfo(
                connHandle,
                NWCC_INFO_VERSION_1,
                &connInfo
                );
 
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    _dwEntriesRead = 0 ;

    do {

        //
        // Scan bindery for NDS tree objects
        //

        ccode = NWScanObject(connHandle,        
                             searchObjectName,    
                             searchObjectType,    
                             &objectID,           
                             aObjectName,          
                             &objectType,         
                             &objectHasProperties,
                             &objectFlag,         
                             &objectSecurity);
    
        if ( ccode ) {
            if (_dwEntriesRead > 0)
                hr = S_OK ;
            break ;
        }

        AnsiToUnicodeString(
           aObjectName,
           pszObjectName,
           NULL_TERMINATED
           );

        //
        // Remove any trailing '_' upto 32 chars. This is standard NDS tree
        // naming stuff.
        //

        dwIter = 31;
        while (pszObjectName[dwIter] == L'_' && dwIter > 0 ) {
            dwIter--;
        }
        pszObjectName[dwIter + 1] = L'\0';

        //
        // Scan for duplicates. We are doing linear everytime, but then again,
        // there shouldnt be many trees.
        //

        fFound = FALSE ;
        for (i = 0; i < _dwEntriesRead; i++) {

            if (_wcsicmp(
                    pszObjectName,
                    (LPWSTR)_pBuffer + (i * OBJ_NAME_SIZE)) == 0) {

                fFound = TRUE ;
                break ;
            }
        }

        //
        // Copy this unique tree name into the buffer
        //

        if (!fFound) {

            //
            // Check that we have enough space.
            //
            if ((lpString + OBJ_NAME_SIZE) >= _pBufferEnd) {

                cb = (LPBYTE)_pBufferEnd - (LPBYTE)_pBuffer ;
                _pBuffer = ReallocADsMem(
                               _pBuffer,
                               cb,
                               2 * cb
                               );

                if (!_pBuffer) {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }

                lpString = (LPWSTR)_pBuffer + (_dwEntriesRead * OBJ_NAME_SIZE) ;
                _pBufferEnd = (LPBYTE) _pBuffer + (2 * cb) ;
            }

            //
            // Assume fixed size (max NW name). Yes, its more than
            // we really need but keeps things simpler.
            //

            wcscpy(lpString, pszObjectName);
            lpString += OBJ_NAME_SIZE ;

            _dwEntriesRead++ ;
        }


    } while (TRUE) ;


error:
    
    if (connHandle) {
        NWCCCloseConn(
             connHandle
             );
    }

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cenumgrp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  Windows NT 3.5 GroupCollection Enumeration Code
//
//              CNDSGroupCollectionEnum::CNDSGroupCollectionEnum()
//              CNDSGroupCollectionEnum::CNDSGroupCollectionEnum
//              CNDSGroupCollectionEnum::EnumObjects
//              CNDSGroupCollectionEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSGroupCollectionEnum::Create(
    BSTR bstrGroupName,
    CCredentials& Credentials,
    CNDSGroupCollectionEnum FAR* FAR* ppenumvariant,
    VARIANT var
    )
{
    HRESULT hr = NOERROR;
    CNDSGroupCollectionEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CNDSGroupCollectionEnum();


    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    hr = ADsAllocString(bstrGroupName, &(penumvariant->_bstrGroupName));
    BAIL_ON_FAILURE(hr);

    hr = penumvariant->ValidateVariant(
                    var
                    );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN(hr);
}

CNDSGroupCollectionEnum::CNDSGroupCollectionEnum():
        _dwSLBound(0),
        _dwSUBound(0),
        _dwIndex(0),
        _dwMultiple(0),
        _bstrGroupName(0)
{
    VariantInit(&_vMembers);
}



CNDSGroupCollectionEnum::~CNDSGroupCollectionEnum()
{
    VariantClear(&_vMembers);
    if (_bstrGroupName) {
        ADsFreeString(_bstrGroupName);
    }
}

HRESULT
CNDSGroupCollectionEnum::EnumGroupMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    *pcElementFetched = 0;

    while (i < cElements) {


        if (_dwMultiple == MULTIPLE) {
            hr = GetGroupMultipleMemberObject(&pDispatch);
        }else if (_dwMultiple == SINGLE){
            hr = GetGroupSingleMemberObject(&pDispatch);
        }else {
            hr = S_FALSE;
        }

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);
}

HRESULT
CNDSGroupCollectionEnum::GetGroupMultipleMemberObject(
    IDispatch ** ppDispatch
    )
{

    VARIANT v;
    HRESULT hr = S_OK;
    LPWSTR szADsPathName = NULL;
    LPWSTR pszNDSTreeName = NULL, pszNDSDn = NULL;

    *ppDispatch = NULL;

    if (_dwIndex > _dwSUBound) {
        RRETURN(S_FALSE);
    }

    VariantInit(&v);

    hr = SafeArrayGetElement(
                V_ARRAY(&_vMembers),
                (long FAR *)&_dwIndex,
                &v
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath2(
                _bstrGroupName,
                &pszNDSTreeName,
                &pszNDSDn
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsPathFromNDSPath(
            pszNDSTreeName,
            v.bstrVal,
            &szADsPathName
            );
    BAIL_ON_FAILURE(hr);

    hr = CNDSGenObject::CreateGenericObject(
                        szADsPathName,
                        L"user",
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwIndex++;


error:

    VariantClear(&v);

    if (FAILED(hr)) {
        hr = S_FALSE;
    }

    if (szADsPathName) {
        FreeADsMem(szADsPathName);
    }

    if (pszNDSDn) {
        FreeADsMem(pszNDSDn);
    }

    if (pszNDSTreeName) {
        FreeADsMem(pszNDSTreeName);
    }

    RRETURN(hr);
}

HRESULT
CNDSGroupCollectionEnum::GetGroupSingleMemberObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPWSTR szADsPathName = NULL;
    LPWSTR pszNDSTreeName = NULL, pszNDSDn = NULL;

    *ppDispatch = NULL;

    if (_dwIndex == 1) {
        RRETURN(S_FALSE);
    }

    hr = BuildNDSPathFromADsPath2(
                _bstrGroupName,
                &pszNDSTreeName,
                &pszNDSDn
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsPathFromNDSPath(
            pszNDSTreeName,
            _vMembers.bstrVal,
            &szADsPathName
            );
    BAIL_ON_FAILURE(hr);

    hr = CNDSGenObject::CreateGenericObject(
                        szADsPathName,
                        L"user",
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwIndex++;


error:

    if (FAILED(hr)) {
        hr = S_FALSE;
    }

    if (szADsPathName) {
        FreeADsMem(szADsPathName);
    }

    if (pszNDSDn) {
        FreeADsMem(pszNDSDn);
    }

    if (pszNDSTreeName) {
        FreeADsMem(pszNDSTreeName);
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CNDSGroupCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSGroupCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGroupMembers(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN(hr);
}


HRESULT
CNDSGroupCollectionEnum::ValidateVariant(
    VARIANT var
    )
{

    if (V_VT(&var) == (VT_VARIANT|VT_ARRAY)) {

        _dwMultiple = MULTIPLE;
        RRETURN(ValidateMultipleVariant(var));

    }else if (V_VT(&var) == VT_BSTR){

        _dwMultiple = SINGLE;
        RRETURN(ValidateSingleVariant(var));
    }else if (V_VT(&var) == VT_EMPTY){

        _dwMultiple = EMPTY;
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}

HRESULT
CNDSGroupCollectionEnum::ValidateMultipleVariant(
    VARIANT var
    )
{

    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;


    if (!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(
                V_ARRAY(&var),
                1,
                (long FAR *)&dwSLBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(
                V_ARRAY(&var),
                1,
                (long FAR *)&dwSUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy(&_vMembers, &var);
    BAIL_ON_FAILURE(hr);

    _dwSUBound = dwSUBound;
    _dwSLBound = dwSLBound;
    _dwIndex =  dwSLBound;


error:

    RRETURN(hr);
}



HRESULT
CNDSGroupCollectionEnum::ValidateSingleVariant(
    VARIANT var
    )
{
    HRESULT hr = S_OK;

    if(!( V_VT(&var) == VT_BSTR)){
        return(E_FAIL);
    }

    hr = VariantCopy(&_vMembers, &var);
    BAIL_ON_FAILURE(hr);

    _dwIndex =  0;

error:

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cexsyncf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 NDS Security Class Factory Code
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

STDMETHODIMP
CCaseIgnoreListCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CCaseIgnoreList::CreateCaseIgnoreList(
                iid,
                ppv
                );

    RRETURN(hr);
}
STDMETHODIMP
CFaxNumberCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CFaxNumber::CreateFaxNumber(
                iid,
                ppv
                );

    RRETURN(hr);
}


STDMETHODIMP
CNetAddressCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CNetAddress::CreateNetAddress(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
COctetListCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = COctetList::CreateOctetList(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
CEmailCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CEmail::CreateEmail(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
CPathCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CPath::CreatePath(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
CReplicaPointerCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CReplicaPointer::CreateReplicaPointer(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
CTimestampCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CTimestamp::CreateTimestamp(
                iid,
                ppv
                );

    RRETURN(hr);
}
STDMETHODIMP
CPostalAddressCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CPostalAddress::CreatePostalAddress(
                iid,
                ppv
                );

    RRETURN(hr);
}
STDMETHODIMP
CBackLinkCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CBackLink::CreateBackLink(
                iid,
                ppv
                );

    RRETURN(hr);
}


STDMETHODIMP
CTypedNameCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CTypedName::CreateTypedName(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
CHoldCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CHold::CreateHold(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cenumobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumdom.cxx
//
//  Contents:  NDS Object Enumeration Code
//
//              CNDSGenObjectEnum::CNDSGenObjectEnum()
//              CNDSGenObjectEnum::CNDSGenObjectEnum
//              CNDSGenObjectEnum::EnumObjects
//              CNDSGenObjectEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSGenObjectEnum::Create(
    CNDSGenObjectEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CNDSGenObjectEnum FAR* penumvariant = NULL;

    if (!ppenumvariant) {
        RRETURN(E_FAIL);
    }
    *ppenumvariant = NULL;

    penumvariant = new CNDSGenObjectEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSFilterArray(
                var,
                (LPBYTE *)&penumvariant->_pNdsFilterList
                );
    if (FAILED(hr)) {
        penumvariant->_pNdsFilterList = NULL;
    }

    /*
    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);
    */

    penumvariant->_Credentials = Credentials;

    hr = BuildNDSPathFromADsPath2(
                ADsPath,
                &penumvariant->_pszTreeName,
                &penumvariant->_pszDn
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsOpenContext(
             penumvariant->_pszTreeName,
             Credentials,
             &penumvariant->_hADsContext
             );

    *ppenumvariant = penumvariant;


    RRETURN(hr);

error:

    if (penumvariant) {

        delete penumvariant;
        *ppenumvariant = NULL;
    }
    RRETURN(hr);
}


CNDSGenObjectEnum::CNDSGenObjectEnum():
                    _ADsPath(NULL), _pszTreeName(NULL), _pszDn(NULL)
{
    _pObjList = NULL;
    _dwObjectReturned = 0;
    _dwObjectCurrentEntry = 0;
    _hOperationData = NULL;
    _lpObjects = NULL;
    _pNdsFilterList = NULL;

    _bNoMore = FALSE;
}


CNDSGenObjectEnum::~CNDSGenObjectEnum()
{
    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_pszTreeName) {
        FreeADsStr(_pszTreeName);
    }

    if (_pszDn) {
        FreeADsStr(_pszDn);
    }

    if (_pNdsFilterList) {
        FreeFilterList((LPBYTE)_pNdsFilterList);
    }

    if (_hADsContext) {
        ADsNdsCloseContext(_hADsContext);
    }
 
    ADsNdsFreeNdsObjInfoList(_lpObjects, _dwObjectReturned);
}

HRESULT
CNDSGenObjectEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{

    //
    // Multi-level detection of Objects may not be necessary for NDS code
    //

    RRETURN(EnumGenericObjects(cElements, pvar, pcElementFetched));


    //
    // BugBug- commenting out this layer of code
    //

    /*
    switch (ObjectType) {

    default:
        RRETURN(EnumObjects(cElements, pvar, pcElementFetched));

    } */
}

HRESULT
CNDSGenObjectEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while (SUCCEEDED(_pObjList->GetCurrentObject(&ObjectType)) &&
            ((hr = EnumObjects(ObjectType,
                               cRequested,
                               pPathvar,
                               &cFetchedByPath)) == S_FALSE )) {

        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (FAILED(_pObjList->Next())){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN(hr);
}

HRESULT
CNDSGenObjectEnum::EnumGenericObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements ) {

        hr = GetGenObject(&pDispatch);
        if (FAILED(hr)) {
            continue;
        }

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


HRESULT
CNDSGenObjectEnum::GetGenObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    PADSNDS_OBJECT_INFO lpCurrentObject = NULL;
    IADs * pADs = NULL;


    *ppDispatch = NULL;

    if (!_hOperationData || (_dwObjectCurrentEntry == _dwObjectReturned)) {

        if (_hOperationData) {

            ADsNdsFreeNdsObjInfoList(_lpObjects, _dwObjectReturned);
            _lpObjects = NULL;
        }

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        if (_bNoMore) {

            hr = S_FALSE;
            goto error;
        }

        
        hr = ADsNdsListObjects(
                 _hADsContext,
                 _pszDn,
                 L"", 
                 L"",
                 NULL,
                 FALSE,
                 &_hOperationData
                 );

        BAIL_ON_FAILURE(hr);

        if (hr == S_ADS_NOMORE_ROWS) {
            _bNoMore = TRUE;
        }

        hr = ADsNdsGetObjectListFromBuffer(
                 _hADsContext,   
                 _hOperationData,
                 &_dwObjectReturned,
                 &_lpObjects
                 );
        BAIL_ON_FAILURE(hr);

        if (_dwObjectReturned == 0 ) {

            RRETURN (S_FALSE);
            goto error;
        }

    }

    //
    // Now send back the current object
    //

    lpCurrentObject = _lpObjects + _dwObjectCurrentEntry;

    //
    // Bump up the object count. The instantiation of this object
    // may fail; if we come into this function again, we do not want
    // to pick up the same object.
    //

    _dwObjectCurrentEntry++;

    hr = CNDSGenObject::CreateGenericObject(
                        _ADsPath,
                        lpCurrentObject->szObjectName,
                        lpCurrentObject->szObjectClass,
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **)&pADs
                        );
    BAIL_ON_FAILURE(hr);


    //
    // InstantiateDerivedObject should addref this pointer for us.
    //

    hr = InstantiateDerivedObject(
                    pADs,
                    _Credentials,
                    IID_IDispatch,
                    (void **)ppDispatch
                    );

    if (FAILED(hr)) {
        hr = pADs->QueryInterface(
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
        BAIL_ON_FAILURE(hr);
    }


error:

    if (hr == S_FALSE) {
        ADsNdsFreeBuffer(_hOperationData);
        _hOperationData = NULL;
    }

    //
    // Free the intermediate pADs pointer.
    //
    if (pADs) {
        pADs->Release();
    }


    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSGenObjectEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSGenObjectEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGenericObjects(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN(hr);
}


HRESULT
BuildNDSFilterArray(
    VARIANT var,
    LPBYTE * ppContigFilter
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    HRESULT hr = S_OK;

    LPNDS_FILTER_LIST pNdsFilterList = NULL;
    LPBYTE pContigFilter = NULL;

    if(!((V_VT(&var) &  VT_VARIANT) &&  V_ISARRAY(&var))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);


    pContigFilter = (LPBYTE)AllocADsMem(
                            sizeof(NDS_FILTER_LIST)
                            - sizeof(NDS_FILTER)
                            );
    if (!pContigFilter) {

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }

        //
        //  Create an entry in the filter block
        //  Append it to the existing block
        //

        pContigFilter = CreateAndAppendFilterEntry(
                            pContigFilter,
                            V_BSTR(&v)
                            );

        VariantClear(&v);
        
        if (!pContigFilter) {

            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

    }

    pNdsFilterList = (LPNDS_FILTER_LIST)pContigFilter;

    if (!pNdsFilterList->dwNumberOfFilters){

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    *ppContigFilter = pContigFilter;

    RRETURN(S_OK);

error:

    if (pContigFilter){

        FreeFilterList(
               pContigFilter
               );

    }

    *ppContigFilter = NULL;

    RRETURN(hr);
}


LPBYTE
CreateAndAppendFilterEntry(
    LPBYTE pContigFilter,
    LPWSTR lpObjectClass
    )
{
    LPWSTR pszFilter = NULL;
    LPNDS_FILTER_LIST pNdsFilterList = NULL;
    DWORD dwFilterCount = 0;
    LPBYTE pNewContigFilter = NULL;
    LPNDS_FILTER pNewEntry = NULL;


    pszFilter = (LPWSTR)AllocADsStr(lpObjectClass);
    if (!pszFilter) {
        return(pContigFilter);
    }

    pNdsFilterList = (LPNDS_FILTER_LIST)pContigFilter;

    dwFilterCount = pNdsFilterList->dwNumberOfFilters;

    pNewContigFilter = (LPBYTE)ReallocADsMem(
                                    pContigFilter,

                                    sizeof(NDS_FILTER_LIST) +
                                    (dwFilterCount - 1)* sizeof(NDS_FILTER),

                                    sizeof(NDS_FILTER_LIST)
                                    + dwFilterCount * sizeof(NDS_FILTER)
                                    );
    if (!pNewContigFilter) {
        return(pContigFilter);
    }

    pNewEntry = (LPNDS_FILTER)(pNewContigFilter + sizeof(NDS_FILTER_LIST)
                        + (dwFilterCount - 1)* sizeof(NDS_FILTER));

    pNewEntry->szObjectClass = pszFilter;

    pNdsFilterList = (LPNDS_FILTER_LIST)pNewContigFilter;

    pNdsFilterList->dwNumberOfFilters = dwFilterCount + 1;

    return(pNewContigFilter);
}

void
FreeFilterList(
    LPBYTE lpContigFilter
    )
{
    LPNDS_FILTER_LIST lpNdsFilterList = (LPNDS_FILTER_LIST)lpContigFilter;
    DWORD dwNumFilters = 0;
    LPNDS_FILTER lpNdsFilter = NULL;
    DWORD i = 0;

    dwNumFilters = lpNdsFilterList->dwNumberOfFilters;

    if (dwNumFilters){

        lpNdsFilter = (LPNDS_FILTER)(lpContigFilter  + sizeof(NDS_FILTER_LIST)
                                      - sizeof(NDS_FILTER));

        for (i = 0; i < dwNumFilters; i++) {

            FreeADsStr((lpNdsFilter + i)->szObjectClass);
        }

    }

    FreeADsMem(lpContigFilter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cenumsch.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumsch.cxx
//
//  Contents:  NDS Schema Enumeration Code
//
//             CNDSSchemaEnum::CNDSSchemaEnum()
//             CNDSSchemaEnum::CNDSSchemaEnum
//             CNDSSchemaEnum::EnumObjects
//             CNDSSchemaEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNDSSchemaEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSSchemaEnum::Create(
    CNDSSchemaEnum FAR* FAR* ppenumvariant,
    BSTR bstrNDSTreeName,
    BSTR bstrADsPath,
    BSTR bstrName,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CNDSSchemaEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CNDSSchemaEnum();
    if (!penumvariant)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( bstrNDSTreeName, &penumvariant->_bstrNDSTreeName);
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsOpenContext(
             penumvariant->_bstrNDSTreeName,
             Credentials,
             &penumvariant->_hADsContext
             );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrADsPath, &penumvariant->_bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrName, &penumvariant->_bstrName);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    delete penumvariant;

    RRETURN(hr);
}

CNDSSchemaEnum::CNDSSchemaEnum()
    : _bstrADsPath( NULL ),
      _bstrName( NULL ),
      _bstrNDSTreeName( NULL ),
      _pObjList( NULL ),
      _dwCurrentEntry( 0 ),
      _dwSyntaxCurrentEntry( 0 )
{
    _hOperationData = NULL;
    _hADsContext = NULL;
    _lpClassDefs = NULL;

    _dwObjectCurrentEntry = 0;
    _dwObjectReturned = 0;

    _dwInfoType = 0;


    _dwPropCurrentEntry = 0;

    _hPropOperationData = NULL;
    _lpAttrDefs = NULL;

    _dwPropObjectCurrentEntry = 0;
    _dwPropObjectReturned = 0;
    _dwPropInfoType = 0;

    _bNoMore = FALSE;
    _bNoMoreProp = FALSE;

}

CNDSSchemaEnum::~CNDSSchemaEnum()
{
   ADsFreeString( _bstrName );
   ADsFreeString( _bstrADsPath );
   ADsFreeString( _bstrNDSTreeName );

   ADsNdsFreeClassDefList(_lpClassDefs, _dwObjectReturned);
   ADsNdsFreeAttrDefList(_lpAttrDefs, _dwPropObjectReturned);

   ADsNdsFreeBuffer( _hOperationData );
   ADsNdsFreeBuffer( _hPropOperationData );

   if (_hADsContext) {
       ADsNdsCloseContext(_hADsContext);
   }


   if ( _pObjList != NULL )
   {
       delete _pObjList;
       _pObjList = NULL;
   }
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSSchemaEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   yihsins     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSSchemaEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects(
                cElements,
                pvar,
                &cElementFetched
                );

    if ( pcElementFetched )
        *pcElementFetched = cElementFetched;

    RRETURN(hr);
}

HRESULT
CNDSSchemaEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    switch (ObjectType)
    {
        case NDS_CLASS_ID:
            RRETURN (EnumClasses(cElements, pvar, pcElementFetched));

        case NDS_PROPERTY_ID:
            RRETURN (EnumProperties(cElements, pvar, pcElementFetched));

    case NDS_SYNTAX_ID:
            RRETURN(EnumSyntaxes(cElements, pvar, pcElementFetched));

        default:
            RRETURN(S_FALSE);
    }
}

HRESULT
CNDSSchemaEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)
        VariantInit(&pvar[i]);

    cRequested = cElements;

    while (  SUCCEEDED( _pObjList->GetCurrentObject(&ObjectType))
          && ((hr = EnumObjects( ObjectType,
                                 cRequested,
                                 pPathvar,
                                 &cFetchedByPath)) == S_FALSE )
          )
    {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if ( FAILED(_pObjList->Next()) )
        {
            if ( pcElementFetched )
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

        _dwCurrentEntry = 0;
    }

    if ( pcElementFetched )
        *pcElementFetched = cTotalFetched + cFetchedByPath;

    RRETURN(hr);
}

HRESULT
CNDSSchemaEnum::EnumClasses(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetClassObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNDSSchemaEnum::GetClassObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    PNDS_CLASS_DEF lpCurrentObject = NULL;

    if (!_hOperationData || (_dwObjectCurrentEntry == _dwObjectReturned)) {

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        if (_hOperationData) {

            ADsNdsFreeClassDefList(_lpClassDefs, _dwObjectReturned);
            _lpClassDefs = NULL;
        }

        if (_bNoMore) {

            hr = S_FALSE;
            goto error;
        }

        hr = ADsNdsReadClassDef(
                        _hADsContext,
                        DS_CLASS_DEFS,
                        NULL,
                        (DWORD) -1,
                        &_hOperationData
                        );
        BAIL_ON_FAILURE(hr);

        if (hr == S_ADS_NOMORE_ROWS) {
            _bNoMore = TRUE;
        }

        hr = ADsNdsGetClassDefListFromBuffer(
                        _hADsContext,
                        _hOperationData,
                        &_dwObjectReturned,
                        &_dwInfoType,
                        &_lpClassDefs
                        );
        BAIL_ON_FAILURE(hr);

        if (_dwObjectReturned == 0 ) {

            RRETURN (S_FALSE);
            goto error;
        }
    }

    if (_dwObjectCurrentEntry < _dwObjectReturned) {

        //
        // Now send back the current object
        //

        lpCurrentObject = _lpClassDefs + _dwObjectCurrentEntry;

        hr = CNDSClass::CreateClass(
                            _bstrADsPath,
                            lpCurrentObject->szClassName,
                            lpCurrentObject,
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
        BAIL_ON_FAILURE(hr);
        _dwObjectCurrentEntry++;

        RRETURN(S_OK);

    }

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}



HRESULT
CNDSSchemaEnum::EnumProperties(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetPropertyObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNDSSchemaEnum::GetPropertyObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPNDS_ATTR_DEF lpCurrentPropObject = NULL;
    DWORD dwStatus;

    if (!_hPropOperationData || (_dwPropObjectCurrentEntry == _dwPropObjectReturned)) {

        _dwPropObjectCurrentEntry = 0;
        _dwPropObjectReturned = 0;

        if (_hPropOperationData) {

            ADsNdsFreeAttrDefList(_lpAttrDefs, _dwPropObjectReturned);
            _lpAttrDefs = NULL;
        }

        if (_bNoMoreProp) {

            hr = S_FALSE;
            goto error;
        }

        hr = ADsNdsReadAttrDef(
                        _hADsContext,
                        DS_ATTR_DEFS,
                        NULL,
                        (DWORD) -1,
                        &_hPropOperationData
                        );
        BAIL_ON_FAILURE(hr);

        if (hr == S_ADS_NOMORE_COLUMNS) {
            _bNoMoreProp = TRUE;
        }

        hr = ADsNdsGetAttrDefListFromBuffer(
                        _hADsContext,
                        _hPropOperationData,
                        &_dwPropObjectReturned,
                        &_dwInfoType,
                        &_lpAttrDefs
                        );
        BAIL_ON_FAILURE(hr);

        if (_dwPropObjectReturned == 0 ) {

            RRETURN (S_FALSE);
            goto error;
        }

    }

    if (_dwPropObjectCurrentEntry < _dwPropObjectReturned) {

        //
        // Now send back the current object
        //

        lpCurrentPropObject = _lpAttrDefs + _dwPropObjectCurrentEntry;

        hr = CNDSProperty::CreateProperty(
                            _bstrADsPath,
                            lpCurrentPropObject->szAttributeName,
                            lpCurrentPropObject,
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
        BAIL_ON_FAILURE(hr);
        _dwPropObjectCurrentEntry++;

        RRETURN(S_OK);

    }

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}




HRESULT
CNDSSchemaEnum::EnumSyntaxes(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetSyntaxObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNDSSchemaEnum::GetSyntaxObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current object
    //
    if ( _dwSyntaxCurrentEntry >= g_cNDSSyntax )
        goto error;

    hr = CNDSSyntax::CreateSyntax(
                        _bstrADsPath,
                        &g_aNDSSyntax[_dwSyntaxCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwSyntaxCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cenumusr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumUserCollection.cxx
//
//  Contents:  Windows NT 3.5 UserCollection Enumeration Code
//
//              CNDSUserCollectionEnum::CNDSUserCollectionEnum()
//              CNDSUserCollectionEnum::CNDSUserCollectionEnum
//              CNDSUserCollectionEnum::EnumObjects
//              CNDSUserCollectionEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSUserCollectionEnum::Create(
    BSTR bstrUserName,
    CNDSUserCollectionEnum FAR* FAR* ppenumvariant,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CNDSUserCollectionEnum FAR* penumvariant = NULL;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;

    *ppenumvariant = NULL;

    penumvariant = new CNDSUserCollectionEnum();


    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    hr = ADsAllocString(bstrUserName, &(penumvariant->_bstrUserName));
    BAIL_ON_FAILURE(hr);

    hr = penumvariant->ValidateVariant(
                    var
                    );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN(hr);

}

CNDSUserCollectionEnum::CNDSUserCollectionEnum():
        _dwSLBound(0),
        _dwSUBound(0),
        _dwIndex(0),
        _bstrUserName(0),
        _dwMultiple(0)
{
    VariantInit(&_vMembers);
}



CNDSUserCollectionEnum::~CNDSUserCollectionEnum()
{
    VariantClear(&_vMembers);
}

HRESULT
CNDSUserCollectionEnum::EnumUserMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        if (_dwMultiple == MULTIPLE) {
            hr = GetUserMultipleMemberObject(&pDispatch);
        }else if (_dwMultiple == SINGLE){
            hr = GetUserSingleMemberObject(&pDispatch);
        }else {
            hr = S_FALSE;
        }

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);
}


HRESULT
CNDSUserCollectionEnum::GetUserMultipleMemberObject(
    IDispatch ** ppDispatch
    )
{

    VARIANT v;
    HRESULT hr = S_OK;
    LPWSTR szADsPathName = NULL;
    LPWSTR pszNDSTreeName = NULL, pszNDSDn = NULL;

    *ppDispatch = NULL;

    if (_dwIndex > _dwSUBound) {
        RRETURN(S_FALSE);
    }

    VariantInit(&v);

    hr = SafeArrayGetElement(
                V_ARRAY(&_vMembers),
                (long FAR *)&_dwIndex,
                &v
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath2(
                _bstrUserName,
                &pszNDSTreeName,
                &pszNDSDn
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsPathFromNDSPath(
            pszNDSTreeName,
            v.bstrVal,
            &szADsPathName
            );
    BAIL_ON_FAILURE(hr);

    hr = CNDSGenObject::CreateGenericObject(
                        szADsPathName,
                        L"group",
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwIndex++;


error:

    VariantClear(&v);

    if (FAILED(hr)) {
        hr = S_FALSE;
    }

    if (szADsPathName) {
        FreeADsMem(szADsPathName);
    }

    if (pszNDSDn) {
        FreeADsMem(pszNDSDn);
    }

    if (pszNDSTreeName) {
        FreeADsMem(pszNDSTreeName);
    }

    RRETURN(hr);
}

HRESULT
CNDSUserCollectionEnum::GetUserSingleMemberObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPWSTR szADsPathName = NULL;
    LPWSTR pszNDSTreeName = NULL, pszNDSDn = NULL;

    *ppDispatch = NULL;

    if (_dwIndex == 1) {
        RRETURN(S_FALSE);
    }

    hr = BuildNDSPathFromADsPath2(
                _bstrUserName,
                &pszNDSTreeName,
                &pszNDSDn
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsPathFromNDSPath(
            pszNDSTreeName,
            _vMembers.bstrVal,
            &szADsPathName
            );
    BAIL_ON_FAILURE(hr);

    hr = CNDSGenObject::CreateGenericObject(
                        szADsPathName,
                        L"group",
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwIndex++;

error:

    if (FAILED(hr)) {
        hr = S_FALSE;
    }

    if (szADsPathName) {
        FreeADsMem(szADsPathName);
    }

    if (pszNDSDn) {
        FreeADsMem(pszNDSDn);
    }

    if (pszNDSTreeName) {
        FreeADsMem(pszNDSTreeName);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSUserCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSUserCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumUserMembers(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN(hr);
}



HRESULT
CNDSUserCollectionEnum::ValidateVariant(
    VARIANT var
    )
{

    if (V_VT(&var) == (VT_VARIANT|VT_ARRAY)) {

        _dwMultiple = MULTIPLE;
        RRETURN(ValidateMultipleVariant(var));

    }else if (V_VT(&var) == VT_BSTR){

        _dwMultiple = SINGLE;
        RRETURN(ValidateSingleVariant(var));
    }else if (V_VT(&var) == VT_EMPTY){

        _dwMultiple = EMPTY;
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}

HRESULT
CNDSUserCollectionEnum::ValidateMultipleVariant(
    VARIANT var
    )
{

    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;


    if (!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(
                V_ARRAY(&var),
                1,
                (long FAR *)&dwSLBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(
                V_ARRAY(&var),
                1,
                (long FAR *)&dwSUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy(&_vMembers, &var);
    BAIL_ON_FAILURE(hr);

    _dwSUBound = dwSUBound;
    _dwSLBound = dwSLBound;
    _dwIndex =  dwSLBound;


error:

    RRETURN(hr);
}



HRESULT
CNDSUserCollectionEnum::ValidateSingleVariant(
    VARIANT var
    )
{
    HRESULT hr = S_OK;

    if(!( V_VT(&var) == VT_BSTR)){
        return(E_FAIL);
    }

    hr = VariantCopy(&_vMembers, &var);
    BAIL_ON_FAILURE(hr);

    _dwIndex =  0;

error:

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cenumt.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumdom.cxx
//
//  Contents:  NDS Object Enumeration Code
//
//              CNDSTreeEnum::CNDSTreeEnum()
//              CNDSTreeEnum::CNDSTreeEnum
//              CNDSTreeEnum::EnumObjects
//              CNDSTreeEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSTreeEnum::Create(
    CNDSTreeEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CNDSTreeEnum FAR* penumvariant = NULL;
    WCHAR szObjectFullName[MAX_PATH];
    WCHAR szObjectClassName[MAX_PATH];
    LPWSTR pszTreeName = NULL, pszDn = NULL;
    DWORD dwModificationTime = 0L;
    DWORD dwNumberOfEntries = 0L;
    DWORD dwStatus = 0L;

    *ppenumvariant = NULL;

    penumvariant = new CNDSTreeEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSFilterArray(
                var,
                (LPBYTE *)&penumvariant->_pNdsFilterList
                );
    if (FAILED(hr)) {
        penumvariant->_pNdsFilterList = NULL;
    }

    /*
    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);
    */
    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    hr = BuildNDSPathFromADsPath2(
                ADsPath,
                &pszTreeName,
                &pszDn
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsOpenContext(
             pszTreeName,
             Credentials,
             &penumvariant->_hADsContext
             );

    if (pszTreeName) {
        FreeADsStr(pszTreeName);
    }

    if (pszDn) {
        FreeADsStr(pszDn);
    }

    RRETURN(hr);

error:

    if (penumvariant) {

    }

    delete penumvariant;
    *ppenumvariant = NULL;

    if (pszTreeName) {

        FreeADsStr(pszTreeName);
    }

    if (pszDn) {

        FreeADsStr(pszDn);
    }

    RRETURN(hr);
}

CNDSTreeEnum::CNDSTreeEnum():
                    _ADsPath(NULL)
{
    _pObjList = NULL;
    _dwObjectReturned = 0;
    _dwObjectCurrentEntry = 0;
    _dwObjectTotal = 0;
    _hADsContext = NULL;
    _hOperationData = NULL;
    _lpObjects = NULL;
    _pNdsFilterList = NULL;

    _fSchemaReturned = NULL;
    _bNoMore = FALSE;
}


CNDSTreeEnum::~CNDSTreeEnum()
{
    if (_ADsPath) {
            ADsFreeString(_ADsPath);
    }

    if (_pNdsFilterList) {
        FreeFilterList((LPBYTE)_pNdsFilterList);
    }

    if (_hADsContext) {
        ADsNdsCloseContext(_hADsContext);
    }

    ADsNdsFreeNdsObjInfoList(_lpObjects, _dwObjectReturned);
 
}

HRESULT
CNDSTreeEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{

    //
    // Multi-level detection of Objects may not be necessary for NDS code
    //

    RRETURN(EnumGenericObjects(cElements, pvar, pcElementFetched));


    //
    // BugBug- commenting out this layer of code
    //

    /*
    switch (ObjectType) {

    default:
        RRETURN(EnumObjects(cElements, pvar, pcElementFetched));

    } */
}

HRESULT
CNDSTreeEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while (SUCCEEDED(_pObjList->GetCurrentObject(&ObjectType)) &&
            ((hr = EnumObjects(ObjectType,
                               cRequested,
                               pPathvar,
                               &cFetchedByPath)) == S_FALSE )) {

        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (FAILED(_pObjList->Next())){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN(hr);
}

HRESULT
CNDSTreeEnum::EnumGenericObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetGenObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


HRESULT
CNDSTreeEnum::GetGenObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus = 0L;
    PADSNDS_OBJECT_INFO lpCurrentObject = NULL;
    IADs * pADs = NULL;

    *ppDispatch = NULL;

    if (!_hOperationData || (_dwObjectCurrentEntry == _dwObjectReturned)) {

        if (_hOperationData) {

            ADsNdsFreeNdsObjInfoList(_lpObjects, _dwObjectReturned);
            _lpObjects = NULL;
        }

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        if (_bNoMore) {

            hr = S_FALSE;
            goto error;
        }

        
        hr = ADsNdsListObjects(
                 _hADsContext,
                 L"[Root]",
                 L"", 
                 L"",
                 NULL,
                 FALSE,
                 &_hOperationData
                 );

        BAIL_ON_FAILURE(hr);

        if (hr == S_ADS_NOMORE_ROWS) {
            _bNoMore = TRUE;
        }

        hr = ADsNdsGetObjectListFromBuffer(
                 _hADsContext,   
                 _hOperationData,
                 &_dwObjectReturned,
                 &_lpObjects
                 );
        BAIL_ON_FAILURE(hr);

        if (_dwObjectReturned == 0 ) {

            RRETURN (S_FALSE);
            goto error;
        }

    }

    //
    // Now send back the current object
    //

    lpCurrentObject = _lpObjects + _dwObjectCurrentEntry;

    //
    // Bump up the object count. The instantiation of this object
    // may fail; if we come into this function again, we do not want
    // to pick up the same object.
    //

    _dwObjectCurrentEntry++;

    hr = CNDSGenObject::CreateGenericObject(
                        _ADsPath,
                        lpCurrentObject->szObjectName,
                        lpCurrentObject->szObjectClass,
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **)&pADs
                        );
    BAIL_ON_FAILURE(hr);


    //
    // InstantiateDerivedObject should addref this pointer for us.
    //

    hr = InstantiateDerivedObject(
                    pADs,
                    _Credentials,
                    IID_IDispatch,
                    (void **)ppDispatch
                    );

    if (FAILED(hr)) {
        hr = pADs->QueryInterface(
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
        BAIL_ON_FAILURE(hr);
    }


error:

    if (hr == S_FALSE) {
        ADsNdsFreeBuffer(_hOperationData);
        _hOperationData = NULL;
    }

    //
    // GetGenObject returns only S_FALSE
    //

    if (FAILED(hr)) {
        hr = S_FALSE;
    }

    //
    // Free the intermediate pADs pointer.
    //
    if (pADs) {
        pADs->Release();
    }


    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSTreeEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSTreeEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGenericObjects(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN(hr);
}


HRESULT
CNDSTreeEnum::EnumSchema(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
)
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;

    if ( _fSchemaReturned )
        RRETURN(S_FALSE);

    if ( cElements > 0 )
    {
        hr = CNDSSchema::CreateSchema(
                  _ADsPath,
                  TEXT("Schema"),
                  _Credentials,
                  ADS_OBJECT_BOUND,
                  IID_IDispatch,
                  (void **)&pDispatch
                  );

        if ( hr == S_OK )
        {
            VariantInit(&pvar[0]);
            pvar[0].vt = VT_DISPATCH;
            pvar[0].pdispVal = pDispatch;
            (*pcElementFetched)++;
            _fSchemaReturned = TRUE;
        }
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cexsyn.cxx ===
#include "nds.hxx"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////
HRESULT
ConvertStringArrayToSafeBstrArray(
    LPWSTR *prgszArray,
    DWORD dwNumElement,
    VARIANT *pvarSafeArray
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    BSTR bstrAddress;

    if ((!prgszArray) || (!pvarSafeArray)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    aBound.lLbound = 0;
    aBound.cElements = dwNumElement;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long)dwNumElement; i++ ) {
        VARIANT v;
        VariantInit(&v);

        v.vt = VT_BSTR;
        hr = ADsAllocString(
                prgszArray[i],
                &v.bstrVal
                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v);
        BAIL_ON_FAILURE(hr);
        VariantClear(&v);
    }

    V_VT(pvarSafeArray) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarSafeArray) = aList;

    RRETURN(hr);

error:
    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    RRETURN(hr);
}

HRESULT
ConvertSafeBstrArrayToStringArray(
    VARIANT varSafeArray,
    LPWSTR **prgszArray,
    PDWORD pdwNumElement
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD dwNumVariants = 0;
    DWORD i = 0;
    LPWSTR* rgszArray = NULL;
    SAFEARRAY * pArray = NULL;

    if ((!prgszArray ) || (!pdwNumElement)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    *pdwNumElement = 0;
    *prgszArray = NULL;

    if(!((V_VT(&varSafeArray) & VT_VARIANT) && V_ISARRAY(&varSafeArray)))
        RRETURN(E_FAIL);

    //
    // This handles by-ref and regular SafeArrays.
    //
    if (V_VT(&varSafeArray) & VT_BYREF)
        pArray = *(V_ARRAYREF(&varSafeArray));
    else
        pArray = V_ARRAY(&varSafeArray);

    //
    // Check that there is only one dimension in this array
    //
    if (pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (pArray->rgsabound[0].cElements == 0){
        RRETURN(S_OK);  // Return success and null array
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(pArray,
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(pArray,
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    dwNumVariants = dwSUBound - dwSLBound + 1;
    rgszArray = (LPWSTR*)AllocADsMem(
                                sizeof(LPWSTR)*dwNumVariants
                                );
    if (!rgszArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    if ((V_VT(&varSafeArray) & VT_VARIANT) == VT_BSTR) {
        BSTR bstrElement;
        for (i = dwSLBound; i <= dwSUBound; i++) {
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    &bstrElement
                                    );
            BAIL_ON_FAILURE(hr);

            rgszArray[i-dwSLBound] = AllocADsStr(bstrElement);
            if (!rgszArray[i-dwSLBound]) {
                hr = E_OUTOFMEMORY;
            }
            BAIL_ON_FAILURE(hr);
        }
    }
    else {
        VARIANT varElement;
        for (i = dwSLBound; i <= dwSUBound; i++) {
            VariantInit(&varElement);
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    &varElement
                                    );
            BAIL_ON_FAILURE(hr);

            rgszArray[i-dwSLBound] = AllocADsStr(V_BSTR(&varElement));
            if (!rgszArray[i-dwSLBound]) {
                hr = E_OUTOFMEMORY;
            }
            BAIL_ON_FAILURE(hr);
            VariantClear(&varElement);
        }
    }

    *prgszArray = rgszArray;
    *pdwNumElement = dwNumVariants;
    RRETURN(hr);

error:
    if (rgszArray) {
        FreeADsMem(rgszArray);
    }
    RRETURN(hr);
}

HRESULT
ConvertBinaryArrayToSafeVariantArray(
    POctetString *prgArray,
    DWORD dwNumElement,
    VARIANT *pvarSafeArray
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    VARIANT var;

    if ((!prgArray) || (!pvarSafeArray)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    aBound.lLbound = 0;
    aBound.cElements = dwNumElement;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long)dwNumElement; i++ )
    {
        hr = BinaryToVariant(
                                (prgArray[i])->Length,
                                (prgArray[i])->Value,
                                &var);
        BAIL_ON_FAILURE(hr);
        hr = SafeArrayPutElement( aList, &i, &var);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(pvarSafeArray) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarSafeArray) = aList;

    RRETURN(hr);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}

HRESULT
ConvertSafeVariantArrayToBinaryArray(
    VARIANT varSafeArray,
    POctetString **prgArray,
    PDWORD pdwNumElement
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    LONG  cIterations = 0; 
    DWORD dwNumVariants = 0;
    DWORD i = 0;
    POctetString *rgArray = NULL;
    SAFEARRAY * pArray = NULL;
    VARIANT var;

    if ((!prgArray ) || (!pdwNumElement)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    *pdwNumElement = 0;
    *prgArray = NULL;

    if(!((V_VT(&varSafeArray) & VT_VARIANT) && V_ISARRAY(&varSafeArray)))
        RRETURN(E_FAIL);

    //
    // This handles by-ref and regular SafeArrays.
    //
    if (V_VT(&varSafeArray) & VT_BYREF)
        pArray = *(V_ARRAYREF(&varSafeArray));
    else
        pArray = V_ARRAY(&varSafeArray);

    //
    // Check that there is only one dimension in this array
    //
    if (pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (pArray->rgsabound[0].cElements == 0){
        RRETURN(S_OK);  // Return success and null array
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(pArray,
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(pArray,
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    dwNumVariants = dwSUBound - dwSLBound + 1;
    rgArray = (POctetString*)AllocADsMem(
                                sizeof(POctetString)*dwNumVariants
                                );
    if (!rgArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {

        rgArray[i-dwSLBound] = (POctetString)AllocADsMem(sizeof(OctetString));
        if (!rgArray[i-dwSLBound]) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        
        rgArray[i-dwSLBound]->Value = NULL;
        cIterations++;
        
        VariantInit(&var);
        hr = SafeArrayGetElement(pArray,
                                (long FAR *)&i,
                                &var
                                );
        BAIL_ON_FAILURE(hr);
        hr = VariantToBinary(
                &var,
                &(rgArray[i-dwSLBound]->Length),
                &(rgArray[i-dwSLBound]->Value));
        BAIL_ON_FAILURE(hr);
    }

    *prgArray = rgArray;
    *pdwNumElement = dwNumVariants;
    RRETURN(hr);
error:
    if (rgArray) {

        for (i = dwSLBound; i < dwSLBound + cIterations; i++) {
            if (rgArray[i-dwSLBound]) {

                if (rgArray[i-dwSLBound]->Value)
                    FreeADsMem(rgArray[i-dwSLBound]->Value);

                FreeADsMem(rgArray[i-dwSLBound]);
            }
        }

        FreeADsMem(rgArray);
    }
    RRETURN(hr);
}
DEFINE_IDispatch_Implementation(CCaseIgnoreList)

CCaseIgnoreList::CCaseIgnoreList():
        _pDispMgr(NULL),
        _rgszCaseIgnoreList(NULL),
        _dwNumElement(0)
{
    ENLIST_TRACKING(CCaseIgnoreList);
}


HRESULT
CCaseIgnoreList::CreateCaseIgnoreList(
    REFIID riid,
    void **ppvObj
    )
{
    CCaseIgnoreList FAR * pCaseIgnoreList = NULL;
    HRESULT hr = S_OK;

    hr = AllocateCaseIgnoreListObject(&pCaseIgnoreList);
    BAIL_ON_FAILURE(hr);

    hr = pCaseIgnoreList->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pCaseIgnoreList->Release();

    RRETURN(hr);

error:
    delete pCaseIgnoreList;

    RRETURN(hr);

}


CCaseIgnoreList::~CCaseIgnoreList( )
{
    delete _pDispMgr;
    if (_rgszCaseIgnoreList) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgszCaseIgnoreList[i]) {
                FreeADsStr(_rgszCaseIgnoreList[i]);
            }
        }
        FreeADsMem(_rgszCaseIgnoreList);
    }
}

STDMETHODIMP
CCaseIgnoreList::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsCaseIgnoreList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsCaseIgnoreList))
    {
        *ppv = (IADsCaseIgnoreList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsCaseIgnoreList FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CCaseIgnoreList::AllocateCaseIgnoreListObject(
    CCaseIgnoreList ** ppCaseIgnoreList
    )
{
    CCaseIgnoreList FAR * pCaseIgnoreList = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pCaseIgnoreList = new CCaseIgnoreList();
    if (pCaseIgnoreList == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsCaseIgnoreList,
                (IADsCaseIgnoreList *)pCaseIgnoreList,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pCaseIgnoreList->_pDispMgr = pDispMgr;
    *ppCaseIgnoreList = pCaseIgnoreList;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CCaseIgnoreList::get_CaseIgnoreList(THIS_ VARIANT FAR * pVarDestObject)
{
    HRESULT hr = S_OK;
    hr = ConvertStringArrayToSafeBstrArray(
                                    _rgszCaseIgnoreList,
                                    _dwNumElement,
                                    pVarDestObject);
    RRETURN(hr);
}

STDMETHODIMP
CCaseIgnoreList::put_CaseIgnoreList(THIS_ VARIANT VarSrcObject)
{
    HRESULT hr = S_OK;
    if (_rgszCaseIgnoreList) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgszCaseIgnoreList[i]) {
                FreeADsStr(_rgszCaseIgnoreList[i]);
            }
        }
        FreeADsMem(_rgszCaseIgnoreList);
        _rgszCaseIgnoreList = NULL;
        _dwNumElement = 0;
    }
    hr = ConvertSafeBstrArrayToStringArray(
                                    VarSrcObject,
                                    &_rgszCaseIgnoreList,
                                    &_dwNumElement);
    RRETURN(hr);
}

DEFINE_IDispatch_Implementation(CFaxNumber)

CFaxNumber::CFaxNumber():
        _pDispMgr(NULL),
        _szTelephoneNumber(NULL),
        _NumberOfBits(0),
        _Parameters(NULL)
{
    ENLIST_TRACKING(CFaxNumber);
}


HRESULT
CFaxNumber::CreateFaxNumber(
    REFIID riid,
    void **ppvObj
    )
{
    CFaxNumber FAR * pFaxNumber = NULL;
    HRESULT hr = S_OK;

    hr = AllocateFaxNumberObject(&pFaxNumber);
    BAIL_ON_FAILURE(hr);

    hr = pFaxNumber->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pFaxNumber->Release();

    RRETURN(hr);

error:
    delete pFaxNumber;

    RRETURN(hr);

}


CFaxNumber::~CFaxNumber( )
{
    delete _pDispMgr;
    if (_szTelephoneNumber) {
        FreeADsStr(_szTelephoneNumber);
    }
    if (_Parameters) {
        FreeADsMem(_Parameters);
    }
}

STDMETHODIMP
CFaxNumber::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsFaxNumber FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsFaxNumber))
    {
        *ppv = (IADsFaxNumber FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsFaxNumber FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CFaxNumber::AllocateFaxNumberObject(
    CFaxNumber ** ppFaxNumber
    )
{
    CFaxNumber FAR * pFaxNumber = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pFaxNumber = new CFaxNumber();
    if (pFaxNumber == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsFaxNumber,
                (IADsFaxNumber *)pFaxNumber,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pFaxNumber->_pDispMgr = pDispMgr;
    *ppFaxNumber = pFaxNumber;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CFaxNumber::get_Parameters(THIS_ VARIANT FAR * pVarDestObject)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    aBound.lLbound = 0;
    aBound.cElements = _NumberOfBits;
    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList,
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray,
            _Parameters,
            aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(pVarDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(pVarDestObject) = aList;

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    RRETURN(hr);
}

STDMETHODIMP
CFaxNumber::put_Parameters(THIS_ VARIANT VarSrcObject)
{

    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;
    VARIANT *pVarSrcObject = &VarSrcObject;

    if (_Parameters) {
        FreeADsMem(_Parameters);
    }

    if( pVarSrcObject->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    _Parameters =
        (BYTE*) AllocADsMem( dwSUBound - dwSLBound + 1);
    if ( _Parameters == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _NumberOfBits = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(pVarSrcObject),
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( _Parameters,
            pArray,
            _NumberOfBits);

    SafeArrayUnaccessData( V_ARRAY(pVarSrcObject) );

error:

    RRETURN(hr);
}

STDMETHODIMP
CFaxNumber::get_TelephoneNumber(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;
    hr = ADsAllocString(_szTelephoneNumber,
                        retval);
    RRETURN(hr);

}

STDMETHODIMP
CFaxNumber::put_TelephoneNumber(THIS_ BSTR bstrTelephoneNumber)
{
    if (_szTelephoneNumber) {
        FreeADsStr(_szTelephoneNumber);
    }

    _szTelephoneNumber = AllocADsStr(bstrTelephoneNumber);

    if (!_szTelephoneNumber) {
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(S_OK);
}

DEFINE_IDispatch_Implementation(CNetAddress)

CNetAddress::CNetAddress():
        _pDispMgr(NULL),
        _dwAddressType(0),
        _dwAddressLength(0),
        _pbAddress(NULL)
{
    ENLIST_TRACKING(CNetAddress);
}


HRESULT
CNetAddress::CreateNetAddress(
    REFIID riid,
    void **ppvObj
    )
{
    CNetAddress FAR * pNetAddress = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNetAddressObject(&pNetAddress);
    BAIL_ON_FAILURE(hr);

    hr = pNetAddress->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNetAddress->Release();

    RRETURN(hr);

error:
    delete pNetAddress;

    RRETURN(hr);

}


CNetAddress::~CNetAddress( )
{
    delete _pDispMgr;
    if (_pbAddress) {
        FreeADsMem(_pbAddress);
    }
}

STDMETHODIMP
CNetAddress::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsNetAddress FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsNetAddress))
    {
        *ppv = (IADsNetAddress FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsNetAddress FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNetAddress::AllocateNetAddressObject(
    CNetAddress ** ppNetAddress
    )
{
    CNetAddress FAR * pNetAddress = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNetAddress = new CNetAddress();
    if (pNetAddress == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsNetAddress,
                (IADsNetAddress *)pNetAddress,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pNetAddress->_pDispMgr = pDispMgr;
    *ppNetAddress = pNetAddress;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CNetAddress::get_AddressType(THIS_ long FAR * retval)
{
    *retval = _dwAddressType;
    RRETURN(S_OK);
}

STDMETHODIMP
CNetAddress::put_AddressType(THIS_ long lnAddressType)
{
    _dwAddressType = lnAddressType;
    RRETURN(S_OK);
}


STDMETHODIMP
CNetAddress::get_Address(THIS_ VARIANT FAR * pVarDestObject)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    aBound.lLbound = 0;
    aBound.cElements = _dwAddressLength;
    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray,
            _pbAddress,
            aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(pVarDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(pVarDestObject) = aList;

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    RRETURN(hr);
}

STDMETHODIMP
CNetAddress::put_Address(THIS_ VARIANT VarSrcObject)
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;
    VARIANT *pVarSrcObject = &VarSrcObject;

    if (_pbAddress) {
        FreeADsMem(_pbAddress);
    }

    if( pVarSrcObject->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    _pbAddress =
        (BYTE*) AllocADsMem( dwSUBound - dwSLBound + 1);

    if ( _pbAddress == NULL)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _dwAddressLength = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(pVarSrcObject),
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( _pbAddress,
            pArray,
            _dwAddressLength );
    SafeArrayUnaccessData( V_ARRAY(pVarSrcObject) );
error:
    RRETURN(hr);
}

DEFINE_IDispatch_Implementation(COctetList)

COctetList::COctetList():
        _pDispMgr(NULL),
        _rgOctetList(NULL)
{
    ENLIST_TRACKING(COctetList);
}


HRESULT
COctetList::CreateOctetList(
    REFIID riid,
    void **ppvObj
    )
{
    COctetList FAR * pOctetList = NULL;
    HRESULT hr = S_OK;

    hr = AllocateOctetListObject(&pOctetList);
    BAIL_ON_FAILURE(hr);

    hr = pOctetList->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pOctetList->Release();

    RRETURN(hr);

error:
    delete pOctetList;

    RRETURN(hr);

}


COctetList::~COctetList( )
{
    delete _pDispMgr;
    if (_rgOctetList) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgOctetList[i]) {
                FreeADsMem(_rgOctetList[i]);
            }
        }
        FreeADsMem(_rgOctetList);
    }
}

STDMETHODIMP
COctetList::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsOctetList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsOctetList))
    {
        *ppv = (IADsOctetList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsOctetList FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
COctetList::AllocateOctetListObject(
    COctetList ** ppOctetList
    )
{
    COctetList FAR * pOctetList = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pOctetList = new COctetList();
    if (pOctetList == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsOctetList,
                (IADsOctetList *)pOctetList,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pOctetList->_pDispMgr = pDispMgr;
    *ppOctetList = pOctetList;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
COctetList::get_OctetList(THIS_ VARIANT FAR * pVarDestObject)
{
    HRESULT hr = S_OK;
    hr = ConvertBinaryArrayToSafeVariantArray(
                                    _rgOctetList,
                                    _dwNumElement,
                                    pVarDestObject);
    RRETURN(hr);
}

STDMETHODIMP
COctetList::put_OctetList(THIS_ VARIANT VarSrcObject)
{
    HRESULT hr = S_OK;
    if (_rgOctetList) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgOctetList[i]) {
                FreeADsMem(_rgOctetList[i]);
            }
        }
        FreeADsMem(_rgOctetList);
    }
    hr = ConvertSafeVariantArrayToBinaryArray(
                                    VarSrcObject,
                                    &_rgOctetList,
                                    &_dwNumElement);
    RRETURN(hr);
}

DEFINE_IDispatch_Implementation(CEmail)

CEmail::CEmail():
        _pDispMgr(NULL),
        _szAddress(NULL),
        _dwType(0)
{
    ENLIST_TRACKING(CEmail);
}


HRESULT
CEmail::CreateEmail(
    REFIID riid,
    void **ppvObj
    )
{
    CEmail FAR * pEmail = NULL;
    HRESULT hr = S_OK;

    hr = AllocateEmailObject(&pEmail);
    BAIL_ON_FAILURE(hr);

    hr = pEmail->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pEmail->Release();

    RRETURN(hr);

error:
    delete pEmail;

    RRETURN(hr);

}


CEmail::~CEmail( )
{
    delete _pDispMgr;
    if (_szAddress) {
        FreeADsStr(_szAddress);
    }
}

STDMETHODIMP
CEmail::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsEmail FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsEmail))
    {
        *ppv = (IADsEmail FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsEmail FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CEmail::AllocateEmailObject(
    CEmail ** ppEmail
    )
{
    CEmail FAR * pEmail = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pEmail = new CEmail();
    if (pEmail == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsEmail,
                (IADsEmail *)pEmail,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pEmail->_pDispMgr = pDispMgr;
    *ppEmail = pEmail;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CEmail::get_Address(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_szAddress, retval);
    RRETURN(hr);

}

STDMETHODIMP
CEmail::put_Address(THIS_ BSTR bstrAddress)
{
    if (!bstrAddress) {
        RRETURN(E_FAIL);
    }

    if (_szAddress) {
        FreeADsStr(_szAddress);
    }

    _szAddress = AllocADsStr(bstrAddress);
    if (!_szAddress) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CEmail::get_Type(THIS_ long FAR * retval)
{
    *retval = _dwType;
    RRETURN(S_OK);
}

STDMETHODIMP
CEmail::put_Type(THIS_ long lnType)
{
    _dwType = lnType;
    RRETURN(S_OK);
}



DEFINE_IDispatch_Implementation(CPath)

CPath::CPath():
        _pDispMgr(NULL),
        _dwType(0),
        _lpVolumeName(NULL),
        _lpPath(NULL)
{
    ENLIST_TRACKING(CPath);
}


HRESULT
CPath::CreatePath(
    REFIID riid,
    void **ppvObj
    )
{
    CPath FAR * pPath = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePathObject(&pPath);
    BAIL_ON_FAILURE(hr);

    hr = pPath->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pPath->Release();

    RRETURN(hr);

error:
    delete pPath;

    RRETURN(hr);

}


CPath::~CPath( )
{
    delete _pDispMgr;
    if (_lpVolumeName) {
        FreeADsStr(_lpVolumeName);
    }
    if (_lpPath) {
        FreeADsStr(_lpPath);
    }
}

STDMETHODIMP
CPath::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsPath FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPath))
    {
        *ppv = (IADsPath FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsPath FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CPath::AllocatePathObject(
    CPath ** ppPath
    )
{
    CPath FAR * pPath = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pPath = new CPath();
    if (pPath == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPath,
                (IADsPath *)pPath,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pPath->_pDispMgr = pDispMgr;
    *ppPath = pPath;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CPath::get_Type(THIS_ long FAR * retval)
{
    *retval = _dwType;
    RRETURN(S_OK);
}

STDMETHODIMP
CPath::put_Type(THIS_ long lnType)
{
    _dwType = lnType;
    RRETURN(S_OK);
}


STDMETHODIMP
CPath::get_VolumeName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpVolumeName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CPath::put_VolumeName(THIS_ BSTR bstrVolumeName)
{

    if (!bstrVolumeName) {
        RRETURN(E_FAIL);
    }

    if (_lpVolumeName) {
        FreeADsStr(_lpVolumeName);
    }

    _lpVolumeName= AllocADsStr(bstrVolumeName);

    if (!_lpVolumeName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CPath::get_Path(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpPath, retval);
    RRETURN(hr);

}

STDMETHODIMP
CPath::put_Path(THIS_ BSTR bstrPath)
{
    if (!bstrPath) {
        RRETURN(E_FAIL);
    }

    if (_lpPath) {
        FreeADsStr(_lpPath);
    }

    _lpPath= AllocADsStr(bstrPath);

    if (!_lpPath) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);
}

//////////////////////////////////////////////////////////////////////////
DEFINE_IDispatch_Implementation(CReplicaPointer)

CReplicaPointer::CReplicaPointer():
        _pDispMgr(NULL),
        _lpServerName(NULL),
        _dwReplicaType(0),
        _dwReplicaNumber(0),
        _dwCount(0)
{
    ENLIST_TRACKING(CReplicaPointer);
    _ReplicaAddressHints.AddressType = 0;
    _ReplicaAddressHints.AddressLength = 0;
    _ReplicaAddressHints.Address = NULL;
}


HRESULT
CReplicaPointer::CreateReplicaPointer(
    REFIID riid,
    void **ppvObj
    )
{
    CReplicaPointer FAR * pReplicaPointer = NULL;
    HRESULT hr = S_OK;

    hr = AllocateReplicaPointerObject(&pReplicaPointer);
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pReplicaPointer->Release();

    RRETURN(hr);

error:
    delete pReplicaPointer;

    RRETURN(hr);
}


CReplicaPointer::~CReplicaPointer( )
{
    delete _pDispMgr;
    if (_lpServerName) {
        FreeADsStr(_lpServerName);
    }
    if (_ReplicaAddressHints.Address) {
        FreeADsMem(_ReplicaAddressHints.Address);
    }
}

STDMETHODIMP
CReplicaPointer::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsReplicaPointer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsReplicaPointer))
    {
        *ppv = (IADsReplicaPointer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsReplicaPointer FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CReplicaPointer::AllocateReplicaPointerObject(
    CReplicaPointer ** ppReplicaPointer
    )
{
    CReplicaPointer FAR * pReplicaPointer = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pReplicaPointer = new CReplicaPointer();
    if (pReplicaPointer == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsReplicaPointer,
                (IADsReplicaPointer *)pReplicaPointer,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pReplicaPointer->_pDispMgr = pDispMgr;
    *ppReplicaPointer = pReplicaPointer;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CReplicaPointer::get_ReplicaType(THIS_ long FAR * retval)
{
    *retval = _dwReplicaType;
    RRETURN(S_OK);
}

STDMETHODIMP
CReplicaPointer::put_ReplicaType(THIS_ long lnReplicaType)
{
    _dwReplicaType = lnReplicaType;
    RRETURN(S_OK);
}

STDMETHODIMP
CReplicaPointer::get_ReplicaNumber(THIS_ long FAR * retval)
{
    *retval = _dwReplicaNumber;
    RRETURN(S_OK);
}

STDMETHODIMP
CReplicaPointer::put_ReplicaNumber(THIS_ long lnReplicaNumber)
{
    _dwReplicaNumber = lnReplicaNumber;
    RRETURN(S_OK);
}

STDMETHODIMP
CReplicaPointer::get_Count(THIS_ long FAR * retval)
{
    *retval = _dwCount;
    RRETURN(S_OK);
}

STDMETHODIMP
CReplicaPointer::put_Count(THIS_ long lnCount)
{

    _dwCount = lnCount;
    RRETURN(S_OK);
}


STDMETHODIMP
CReplicaPointer::get_ServerName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpServerName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CReplicaPointer::put_ServerName(THIS_ BSTR bstrServerName)
{

    if (!bstrServerName) {
        RRETURN(E_FAIL);
    }

    if (_lpServerName) {
        FreeADsStr(_lpServerName);
    }

    _lpServerName= AllocADsStr(bstrServerName);

    if (!_lpServerName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CReplicaPointer::get_ReplicaAddressHints(THIS_ VARIANT* pValAddress)
{
    HRESULT hr = S_OK;
    NDSOBJECT object;

    memcpy(&object.NdsValue.value_12,
           &_ReplicaAddressHints,
           sizeof(NDS_ASN1_TYPE_12));

    hr = NdsTypeToVarTypeCopyNDSSynId12(
                            &object,
                            pValAddress
                            );
    RRETURN(hr);
}

STDMETHODIMP
CReplicaPointer::put_ReplicaAddressHints(THIS_ VARIANT ValAddress)
{
    HRESULT hr;
    NDSOBJECT object;

    if (_ReplicaAddressHints.Address) {
        FreeADsMem(_ReplicaAddressHints.Address);
    }

    hr = VarTypeToNdsTypeCopyNDSSynId12(
                            &ValAddress,
                            &object
                            );
    BAIL_ON_FAILURE(hr);
    memcpy(&_ReplicaAddressHints,
           &object.NdsValue.value_12,
           sizeof(NDS_ASN1_TYPE_12));
error:
    RRETURN(hr);
}

DEFINE_IDispatch_Implementation(CTimestamp)

CTimestamp::CTimestamp():
        _pDispMgr(NULL),
        _dwWholeSeconds(0),
        _dwEventID(0)
{
    ENLIST_TRACKING(CTimestamp);
}


HRESULT
CTimestamp::CreateTimestamp(
    REFIID riid,
    void **ppvObj
    )
{
    CTimestamp FAR * pTime = NULL;
    HRESULT hr = S_OK;

    hr = AllocateTimestampObject(&pTime);
    BAIL_ON_FAILURE(hr);

    hr = pTime->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pTime->Release();

    RRETURN(hr);

error:
    delete pTime;

    RRETURN(hr);

}


CTimestamp::~CTimestamp( )
{
    delete _pDispMgr;
}

STDMETHODIMP
CTimestamp::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsTimestamp FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsTimestamp))
    {
        *ppv = (IADsTimestamp FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsTimestamp FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CTimestamp::AllocateTimestampObject(
    CTimestamp ** ppTime
    )
{
    CTimestamp FAR * pTime = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pTime = new CTimestamp();
    if (pTime == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsTimestamp,
                (IADsTimestamp *)pTime,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pTime->_pDispMgr = pDispMgr;
    *ppTime = pTime;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CTimestamp::get_WholeSeconds(THIS_ long FAR * retval)
{
    *retval = _dwWholeSeconds;
    RRETURN(S_OK);
}

STDMETHODIMP
CTimestamp::put_WholeSeconds(THIS_ long lnWholeSeconds)
{
    _dwWholeSeconds = lnWholeSeconds;
    RRETURN(S_OK);
}

STDMETHODIMP
CTimestamp::get_EventID(THIS_ long FAR * retval)
{
    *retval = _dwEventID;
    RRETURN(S_OK);
}

STDMETHODIMP
CTimestamp::put_EventID(THIS_ long lnEventID)
{
    _dwEventID = lnEventID;
    RRETURN(S_OK);
}


DEFINE_IDispatch_Implementation(CPostalAddress)

CPostalAddress::CPostalAddress():
        _pDispMgr(NULL),
        _rgszPostalAddress(NULL),
        _dwNumElement(0)
{
    ENLIST_TRACKING(CPostalAddress);
}


HRESULT
CPostalAddress::CreatePostalAddress(
    REFIID riid,
    void **ppvObj
    )
{
    CPostalAddress FAR * pPostalAddress = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePostalAddressObject(&pPostalAddress);
    BAIL_ON_FAILURE(hr);

    hr = pPostalAddress->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pPostalAddress->Release();

    RRETURN(hr);

error:
    delete pPostalAddress;

    RRETURN(hr);

}


CPostalAddress::~CPostalAddress( )
{
    delete _pDispMgr;
    if (_rgszPostalAddress) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgszPostalAddress[i]) {
                FreeADsStr(_rgszPostalAddress[i]);
            }
        }
        FreeADsMem(_rgszPostalAddress);
    }
}

STDMETHODIMP
CPostalAddress::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsPostalAddress FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPostalAddress))
    {
        *ppv = (IADsPostalAddress FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsPostalAddress FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CPostalAddress::AllocatePostalAddressObject(
    CPostalAddress ** ppPostalAddress
    )
{
    CPostalAddress FAR * pPostalAddress = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pPostalAddress = new CPostalAddress();
    if (pPostalAddress == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPostalAddress,
                (IADsPostalAddress *)pPostalAddress,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pPostalAddress->_pDispMgr = pDispMgr;
    *ppPostalAddress = pPostalAddress;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CPostalAddress::get_PostalAddress(THIS_ VARIANT FAR * pVarDestObject)
{
    HRESULT hr = S_OK;
    hr = ConvertStringArrayToSafeBstrArray(
                                    _rgszPostalAddress,
                                    _dwNumElement,
                                    pVarDestObject);
    RRETURN(hr);
}

STDMETHODIMP
CPostalAddress::put_PostalAddress(THIS_ VARIANT VarSrcObject)
{
    HRESULT hr = S_OK;
    SAFEARRAY * pArray = NULL;

    if (_rgszPostalAddress) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgszPostalAddress[i]) {
                FreeADsStr(_rgszPostalAddress[i]);
            }
        }
        FreeADsMem(_rgszPostalAddress);
    }

    //
    // Make sure it has 6 elements
    //
    if(!((V_VT(&VarSrcObject) & VT_VARIANT) && V_ISARRAY(&VarSrcObject)))
        RRETURN(E_FAIL);

    if (V_VT(&VarSrcObject) & VT_BYREF)
        pArray = *(V_ARRAYREF(&VarSrcObject));
    else
        pArray = V_ARRAY(&VarSrcObject);

    if ((pArray->rgsabound[0].cElements > 6) || (pArray->rgsabound[0].cElements <= 0)){
        RRETURN(E_FAIL);
    }

    hr = ConvertSafeBstrArrayToStringArray(
                                    VarSrcObject,
                                    &_rgszPostalAddress,
                                    &_dwNumElement);
    RRETURN(hr);
}

//////////////////////////////////////////////////////////////////////////
DEFINE_IDispatch_Implementation(CBackLink)

CBackLink::CBackLink():
        _pDispMgr(NULL),
        _lpObjectName(NULL),
        _dwRemoteID(0)
{
    ENLIST_TRACKING(CBackLink);
}


HRESULT
CBackLink::CreateBackLink(
    REFIID riid,
    void **ppvObj
    )
{
    CBackLink FAR * pBackLink = NULL;
    HRESULT hr = S_OK;

    hr = AllocateBackLinkObject(&pBackLink);
    BAIL_ON_FAILURE(hr);

    hr = pBackLink->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pBackLink->Release();

    RRETURN(hr);

error:
    delete pBackLink;

    RRETURN(hr);

}


CBackLink::~CBackLink( )
{
    delete _pDispMgr;
    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }
}

STDMETHODIMP
CBackLink::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsBackLink FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsBackLink))
    {
        *ppv = (IADsBackLink FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsBackLink FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CBackLink::AllocateBackLinkObject(
    CBackLink ** ppBackLink
    )
{
    CBackLink FAR * pBackLink = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pBackLink = new CBackLink();
    if (pBackLink == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsBackLink,
                (IADsBackLink *)pBackLink,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pBackLink->_pDispMgr = pDispMgr;
    *ppBackLink = pBackLink;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CBackLink::get_RemoteID(THIS_ long FAR * retval)
{
    *retval = _dwRemoteID;
    RRETURN(S_OK);
}

STDMETHODIMP
CBackLink::put_RemoteID(THIS_ long lnRemoteID)
{
    _dwRemoteID = lnRemoteID;
    RRETURN(S_OK);
}


STDMETHODIMP
CBackLink::get_ObjectName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpObjectName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CBackLink::put_ObjectName(THIS_ BSTR bstrObjectName)
{

    if (!bstrObjectName) {
        RRETURN(E_FAIL);
    }

    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }

    _lpObjectName= AllocADsStr(bstrObjectName);

    if (!_lpObjectName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

//////////////////////////////////////////////////////////////////////////
DEFINE_IDispatch_Implementation(CTypedName)

CTypedName::CTypedName():
        _pDispMgr(NULL),
        _lpObjectName(NULL),
        _dwLevel(0),
        _dwInterval(0)
{
    ENLIST_TRACKING(CTypedName);
}


HRESULT
CTypedName::CreateTypedName(
    REFIID riid,
    void **ppvObj
    )
{
    CTypedName FAR * pTypedName = NULL;
    HRESULT hr = S_OK;

    hr = AllocateTypedNameObject(&pTypedName);
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pTypedName->Release();

    RRETURN(hr);

error:
    delete pTypedName;

    RRETURN(hr);

}


CTypedName::~CTypedName( )
{
    delete _pDispMgr;
    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }
}

STDMETHODIMP
CTypedName::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsTypedName FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsTypedName))
    {
        *ppv = (IADsTypedName FAR *) this;
 