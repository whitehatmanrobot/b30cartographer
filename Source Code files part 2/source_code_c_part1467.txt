MQ_S_SECURITY_ATRRIBUTE[] = L"nTSecurityDescriptor";   //PROPID_S_SECURITY
const WCHAR MQ_S_FULL_NAME_ATTRIBUTE[] = L"distinguishedName";     //PROPID_S_FULL_NAME
const WCHAR MQ_S_NT4_STUB_ATTRIBUTE[] = L"mSMQNt4Stub";            //PROPID_S_NT4_STUB
const WCHAR MQ_S_FOREIGN_ATTRIBUTE[] = L"mSMQSiteForeign";         //PROPID_S_FOREIGN
const WCHAR MQ_S_INTERVAL1[] = L"mSMQInterval1";                   //PROPID_S_INTERVAL1
const WCHAR MQ_S_INTERVAL2[] = L"mSMQInterval2";                   //PROPID_S_INTERVAL2

const ADSTYPE MQ_S_NAME_ADSTYPE  =  ADSTYPE_CASE_IGNORE_STRING;
const ADSTYPE MQ_S_ID_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_S_SECURITY_ADSTYPE = ADSTYPE_NT_SECURITY_DESCRIPTOR;
const ADSTYPE MQ_S_FULL_NAME_ADSTYPE = ADSTYPE_DN_STRING;
const ADSTYPE MQ_S_NT4_STUB_ADSTYPE = ADSTYPE_INTEGER;
const ADSTYPE MQ_S_FOREIGN_ADSTYPE = ADSTYPE_BOOLEAN;
const ADSTYPE MQ_S_INTERVAL1_ADSTYPE = ADSTYPE_INTEGER;
const ADSTYPE MQ_S_INTERVAL2_ADSTYPE = ADSTYPE_INTEGER;

//-----------------------------------------------------
//      Server
//-----------------------------------------------------
const WCHAR MSMQ_SERVER_CLASS_NAME[] = L"server";

const WCHAR x_ServerCategoryName[] = L"CN=Server";
const DWORD x_ServerCategoryLength = (sizeof( x_ServerCategoryName)/sizeof(WCHAR)) - 1;

const WCHAR MQ_SRV_NAME_ATTRIBUTE[] = L"cn";                      //PROPID_SRV_NAME
const WCHAR MQ_SRV_ID_ATTRIBUTE[] = L"objectGUID";              //PROPID_SRV_ID
const WCHAR MQ_SRV_FULL_PATH_ATTRIBUTE[] = L"distinguishedName";            //PROPID_SRV_FULL_PATH

const ADSTYPE MQ_SRV_NAME_ADSTYPE = ADSTYPE_DN_STRING;
const ADSTYPE MQ_SRV_ID_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_SRV_FULL_PATH_ADSTYPE = ADSTYPE_DN_STRING;

//-----------------------------------------------------
//      MSMQ setting
//-----------------------------------------------------
const WCHAR MSMQ_SETTING_CLASS_NAME[] = L"mSMQSettings";

const WCHAR x_SettingsCategoryName[] = L"CN=MSMQ-Settings";
const DWORD x_SettingsCategoryLength = (sizeof( x_SettingsCategoryName)/sizeof(WCHAR)) - 1;


const WCHAR MQ_SET_NAME_ATTRIBUTE[] = L"cn";                  //PROPID_SET_NAME
const WCHAR MQ_SET_SERVICE_ATTRIBUTE[] = L"mSMQServices";     //PROPID_SET_SERVICE  //[adsrv] keeping for migration: PROPID_SET_OLDSERVICE
const WCHAR MQ_SET_SERVICE_ROUTING_ATTRIBUTE[]   = L"mSMQRoutingService";         // PROPID_SET_SERVICE_ROUTING
const WCHAR MQ_SET_SERVICE_DSSERVER_ATTRIBUTE[]  = L"mSMQDsService";              // PROPID_SET_SERVICE_DSSERVER
const WCHAR MQ_SET_SERVICE_DEPCLIENTS_ATTRIBUTE[] = L"mSMQDependentClientService"; // PROPID_SET_SERVICE_DEPCLIENTS

const WCHAR MQ_SET_QM_ID_ATTRIBUTE[] = L"mSMQQMID";           //PROPID_SET_QM_ID
const WCHAR MQ_SET_APPLICATION_ATTRIBUTE[] = L"applicationName"; //PROPID_SET_APPLICATION
const WCHAR MQ_SET_FULL_PATH_ATTRIBUTE[] = L"distinguishedName"; // PROPID_SET_FULL_PATH
const WCHAR MQ_SET_NT4_ATTRIBUTE[] = L"mSMQNT4Flags";            //PROPID_SET_NT4
const WCHAR MQ_SET_MASTERID_ATTRIBUTE[] = L"mSMQOwnerID"; //PROPID_SET_MASTERID
const WCHAR MQ_SET_SITENAME_ATTRIBUTE[] = L"mSMQSiteNameEx"; //PROPID_SET_SITENAME


const ADSTYPE MQ_SET_NAME_ADSTYPE = ADSTYPE_DN_STRING;
const ADSTYPE MQ_SET_SERVICE_ADSTYPE = ADSTYPE_INTEGER;  //[adsrv]  keeping for migration only
const ADSTYPE MQ_SET_SERVICE_ROUTING_ADSTYPE = ADSTYPE_BOOLEAN;
const ADSTYPE MQ_SET_SERVICE_DSSERVER_ADSTYPE = ADSTYPE_BOOLEAN;
const ADSTYPE MQ_SET_SERVICE_DEPCLIENTS_ADSTYPE = ADSTYPE_BOOLEAN;
const ADSTYPE MQ_SET_QM_ID_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_SET_APPLICATION_ADSTYPE = ADSTYPE_CASE_IGNORE_STRING;
const ADSTYPE MQ_SET_FULL_PATH_ADSTYPE = ADSTYPE_DN_STRING;
const ADSTYPE MQ_SET_NT4_ADSTYPE = ADSTYPE_INTEGER;
const ADSTYPE MQ_SET_MASTERID_ADSTYPE = ADSTYPE_OCTET_STRING ;
const ADSTYPE MQ_SET_SITENAME_ADSTYPE = ADSTYPE_CASE_IGNORE_STRING ;

//-----------------------------------------------------
//      Computer
//-----------------------------------------------------

const WCHAR MSMQ_COMPUTER_CLASS_NAME[] = L"computer";

const WCHAR x_ComputerCategoryName[] = L"CN=Computer";
const DWORD x_ComputerCategoryLength = (sizeof( x_ComputerCategoryName)/sizeof(WCHAR)) - 1;


const WCHAR MQ_COM_FULL_PATH_ATTRIBUTE[] = L"distinguishedName";        // PROPID_COM_FULL_PATH
const WCHAR MQ_COM_SAM_ACCOUNT_ATTRIBUTE[] = L"sAMAccountName";         // PROPID_COM_SAM_ACCOUNT
const WCHAR MQ_COM_ACCOUNT_CONTROL_ATTRIBUTE[] = L"userAccountControl"; // PROPID_COM_ACCOUNT_CONTROL
const WCHAR MQ_COM_DNS_HOSTNAME_ATTRIBUTE[] = L"dNSHostName";           // PROPID_COM_DNS_HOSTNAME
const WCHAR MQ_COM_SID_ATTRIBUTE[] = L"objectSid";                      // PROPID_COM_SID
const WCHAR MQ_COM_SIGN_CERT_ATTRIBUTE[] = L"mSMQSignCertificates";     // PROPID_COM_SIGN_CERT
const WCHAR MQ_COM_DIGEST_ATTRIBUTE[] = L"mSMQDigests";                 // PROPID_COM_DIGEST
const WCHAR MQ_COM_ID_ATTRIBUTE[] = L"objectGUID";                      // PROPID_COM_ID
const WCHAR MQ_COM_VERSION_ATTRIBUTE[] = L"operatingSystemVersion";     // PROPID_COM_VERSION

const WCHAR MQ_COM_FULL_PATH_DESC[] = L"distingushed-name";
const WCHAR MQ_COM_SAM_ACCOUNT_DESC[] = L"sam-account-name";
const WCHAR MQ_COM_ACCOUNT_CONTROL_DESC[] = L"user-account-contorl-name";

const ADSTYPE MQ_COM_FULL_PATH_ADSTYPE = ADSTYPE_DN_STRING;
const ADSTYPE MQ_COM_SAM_ACCOUNT_ADSTYPE = ADSTYPE_DN_STRING;
const ADSTYPE MQ_COM_ACCOUNT_CONTROL_ADSTYPE = ADSTYPE_INTEGER;
const ADSTYPE MQ_COM_DNS_HOSTNAME_ADSTYPE = ADSTYPE_DN_STRING;
const ADSTYPE MQ_COM_SID_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_COM_SIGN_CERT_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_COM_DIGEST_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_COM_ID_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_COM_VERSION_ADSTYPE = ADSTYPE_DN_STRING;


//-----------------------------------------------------
//      DL
//-----------------------------------------------------
const WCHAR MSMQ_DL_CLASS_NAME[] = L"group";
const WCHAR MQ_DL_ID_ATTRIBUTE[] = L"objectGUID";
const ADSTYPE MQ_DL_ID_ADSTYPE = ADSTYPE_OCTET_STRING;


//-----------------------------------------------------
//     Alias queue
//-----------------------------------------------------
const WCHAR MSMQ_QALIAS_CLASS_NAME[] = L"msMQ-Custom-Recipient";
const WCHAR MQ_QALIAS_FORMAT_NAME_ATTRIBUTE[] = L"msMQ-Recipient-FormatName";
const ADSTYPE MQ_QALIAS_FORMAT_NAME_ADSTYPE = ADSTYPE_CASE_IGNORE_STRING;


#endif  //  __mqattrib_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\mqschema.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mqschema.h

Abstract:

    Definition of routines to update the schema of NT ActiveDS
    with MSMQ info

Author:

    Raanan Harari (raananh)


--*/

#ifndef __MQSCHEMA_H
#define __MQSCHEMA_H

//
// Class to report progress
//
#define MSMQ_ADD_SCHEMA_CLASS           1
#define MSMQ_ADD_SCHEMA_ATTRIBUTE       2
#define MSMQ_GET_SCHEMA_CONTAINER       3
#define MSMQ_UPDATE_SCHEMA_CACHE        4
class CMsmqSchemaProgress
{
public:
    CMsmqSchemaProgress() {};
    virtual ~CMsmqSchemaProgress() {};
    virtual void Doing(WORD wObjectType, LPCWSTR pwszName) {};
    virtual void Done(WORD wObjectType, LPCWSTR pwszName, HRESULT hrStatus) {};
};
typedef CMsmqSchemaProgress * LPCMsmqSchemaProgress;


//
// Update the schema with MSMQ objects
//
HRESULT PopulateMSMQInActiveDSSchema(IN LPCWSTR pwszDSSuffix,
                                     IN const BOOL fUpdateSchemaCache,
                                     IN LPCMsmqSchemaProgress pProgress);

#endif //__MQSCHEMA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\mqiscol.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    mqis.h

Abstract:
    MQIS database column definition


--*/

#ifndef __MQISCOL_H__
#define __MQISCOL_H__

/*-----------------------------------------------------
   Name of Tables
-------------------------------------------------------*/

#define DELETED_TABLE_NAME 	"MQDeleted"
#define ENTERPRISE_TABLE_NAME	"Enterprise"
#define SITE_TABLE_NAME    	"Site"
#define LINK_TABLE_NAME    	"SiteLink"
#define MACHINE_TABLE_NAME    "Machine"
#define MACHINE_CN_TABLE_NAME "MachineCNs"
#define CN_TABLE_NAME      	"CNs"
#define QUEUE_TABLE_NAME   	"Queue"
#define USER_TABLE_NAME    	"MQUser"
#define PURGE_TABLE_NAME    "MQPurge"
#define BSCACK_TABLE_NAME   "BscAck"

/*-----------------------------------------------------
    Tables' column strings
-------------------------------------------------------*/
//
//  Queue table
//
#define Q_INSTANCE_COL      "Instance"
#define Q_TYPE_COL          "Type"
#define Q_LABEL_COL         "qLabel"
#define Q_PATHNAME1_COL     "PathName1"
#define Q_PATHNAME2_COL     "PathName2"
#define Q_JOURNAL_COL       "qJournal"
#define Q_QUOTA_COL         "Quota"
#define Q_BASEPRIORITY_COL  "BasePriority"
#define Q_JQUOTA_COL        "JQuota"
#define Q_QMID_COL          "QMId"
#define Q_SCOPE_COL         "Scope"
#define Q_OWNERID_COL       "OwnerId"
#define Q_SEQNUM_COL        "SeqNum"
#define Q_HKEY_COL          "HKey"
#define Q_SECURITY1_COL     "Security1"
#define Q_SECURITY2_COL     "Security2"
#define Q_SECURITY3_COL     "Security3"
#define Q_CTIME_COL         "CreateTime"
#define Q_MTIME_COL         "ModifyTime"
#define Q_AUTH_COL          "Authenticate"
#define Q_PRIVLVL_COL       "PrivLevel"
#define Q_TRAN_COL          "Xaction"
#define Q_LABELHKEY_COL     "LabelHKey"

#define Q_INSTANCE_CTYPE    MQDB_FIXBINARY
#define Q_TYPE_CTYPE        MQDB_FIXBINARY
#define Q_LABEL_CTYPE       MQDB_FIXBINARY
#define Q_PATHNAME1_CTYPE   MQDB_FIXBINARY
#define Q_PATHNAME2_CTYPE   MQDB_VARBINARY
#define Q_JOURNAL_CTYPE     MQDB_SHORT
#define Q_QUOTA_CTYPE       MQDB_LONG
#define Q_BASEPRIORITY_CTYPE MQDB_SHORT
#define Q_JQUOTA_CTYPE      MQDB_LONG
#define Q_QMID_CTYPE        MQDB_FIXBINARY
#define Q_SCOPE_CTYPE       MQDB_SHORT
#define Q_OWNERID_CTYPE     MQDB_FIXBINARY
#define Q_SEQNUM_CTYPE      MQDB_FIXBINARY
#define Q_HKEY_CTYPE        MQDB_LONG
#define Q_SECURITY1_CTYPE   MQDB_FIXBINARY
#define Q_SECURITY2_CTYPE   MQDB_FIXBINARY
#define Q_SECURITY3_CTYPE   MQDB_VARBINARY
#define Q_CTIME_CTYPE       MQDB_LONG
#define Q_MTIME_CTYPE       MQDB_LONG
#define Q_AUTH_CTYPE        MQDB_SHORT
#define Q_PRIVLVL_CTYPE     MQDB_LONG
#define Q_TRAN_CTYPE        MQDB_SHORT
#define Q_LABELHKEY_CTYPE   MQDB_LONG


#define Q_INSTANCE_CLEN     16
#define Q_TYPE_CLEN         16
#define Q_LABEL_CLEN        ((MQ_MAX_Q_LABEL_LEN+1) * sizeof(TCHAR))
#if (((MQ_MAX_Q_LABEL_LEN+1) * 2) > 255)
#error "(Q_LABEL_CLEN > 255)"
#endif
#define Q_PATHNAME1_CLEN    255
#define Q_PATHNAME2_CLEN    0
#define Q_JOURNAL_CLEN      2
#define Q_QUOTA_CLEN        4
#define Q_BASEPRIORITY_CLEN 2
#define Q_JQUOTA_CLEN       4
#define Q_QMID_CLEN         16
#define Q_SCOPE_CLEN        2
#define Q_OWNERID_CLEN      16
#define Q_SEQNUM_CLEN       8
#define Q_HKEY_CLEN         4
#define Q_SECURITY1_CLEN    255
#define Q_SECURITY2_CLEN    255
#define Q_SECURITY3_CLEN    0
#define Q_CTIME_CLEN        4
#define Q_MTIME_CLEN        4
#define Q_AUTH_CLEN         2
#define Q_PRIVLVL_CLEN      4
#define Q_TRAN_CLEN         2
#define Q_LABELHKEY_CLEN    4


//
//  Deleted objects table
//
#define D_IDENTIFIER_COL    "Identifier"
#define D_OBJECTTYPE_COL    "ObjectType"
#define D_SCOPE_COL         "Scope"
#define D_OWNERID_COL       "OwnerId"
#define D_SEQNUM_COL        "SeqNum"
#define D_TIME_COL		    "Time"

#define D_IDENTIFIER_CTYPE  MQDB_FIXBINARY
#define D_OBJECTTYPE_CTYPE  MQDB_SHORT
#define D_SCOPE_CTYPE       MQDB_SHORT
#define D_OWNERID_CTYPE     MQDB_FIXBINARY
#define D_SEQNUM_CTYPE      MQDB_FIXBINARY
#define D_TIME_CTYPE       MQDB_LONG

#define D_IDENTIFIER_CLEN   16
#define D_OBJECTTYPE_CLEN   2
#define D_SCOPE_CLEN        2
#define D_OWNERID_CLEN      16
#define D_SEQNUM_CLEN       8
#define D_TIME_CLEN         4


//
//  Machine table
//
#define M_NAME1_COL         "Name1"
#define M_NAME2_COL         "Name2"
#define M_HKEY_COL          "HKey"
#define M_ADDRESS1_COL      "Address1"
#define M_ADDRESS2_COL      "Address2"
#define M_OUTFRS1_COL       "OutFrs1"
#define M_OUTFRS2_COL       "OutFrs2"
#define M_OUTFRS3_COL       "OutFrs3"
#define M_INFRS1_COL        "InFrs1"
#define M_INFRS2_COL        "InFrs2"
#define M_INFRS3_COL        "InFrs3"
#define M_SITE_COL          "Site"
#define M_QMID_COL          "QMId"
#define M_SERVICES_COL      "Services"
#define M_OWNERID_COL       "OwnerId"
#define M_SEQNUM_COL        "SeqNum"
#define M_SECURITY1_COL     "Security1"
#define M_SECURITY2_COL     "Security2"
#define M_SECURITY3_COL     "Security3"
#define M_SIGNCRT1_COL      "SignCrt1"
#define M_SIGNCRT2_COL      "SignCrt2"
#define M_ENCRPTCRT1_COL    "EncrptCrt1"
#define M_ENCRPTCRT2_COL    "EncrptCrt2"
#define M_QUOTA_COL         "Quota"
#define M_JQUOTA_COL        "JQuota"
#define M_MTYPE_COL         "MType"
#define M_CTIME_COL         "CreateTime"
#define M_MTIME_COL         "ModifyTime"
#define M_FOREIGN_COL       "MQForeign"
#define M_OS_COL            "OperatingSystem"

#define M_NAME1_CTYPE       MQDB_FIXBINARY
#define M_NAME2_CTYPE       MQDB_VARBINARY
#define M_HKEY_CTYPE        MQDB_LONG
#define M_ADDRESS1_CTYPE    MQDB_FIXBINARY
#define M_ADDRESS2_CTYPE    MQDB_VARBINARY
#define M_OUTFRS1_CTYPE     MQDB_FIXBINARY
#define M_OUTFRS2_CTYPE     MQDB_FIXBINARY
#define M_OUTFRS3_CTYPE     MQDB_FIXBINARY
#define M_INFRS1_CTYPE      MQDB_FIXBINARY
#define M_INFRS2_CTYPE      MQDB_FIXBINARY
#define M_INFRS3_CTYPE      MQDB_FIXBINARY
#define M_SITE_CTYPE        MQDB_FIXBINARY
#define M_QMID_CTYPE        MQDB_FIXBINARY
#define M_SERVICES_CTYPE    MQDB_LONG
#define M_OWNERID_CTYPE     MQDB_FIXBINARY
#define M_SEQNUM_CTYPE      MQDB_FIXBINARY
#define M_SECURITY1_CTYPE   MQDB_FIXBINARY
#define M_SECURITY2_CTYPE   MQDB_FIXBINARY
#define M_SECURITY3_CTYPE   MQDB_VARBINARY
#define M_SIGNCRT1_CTYPE    MQDB_FIXBINARY
#define M_SIGNCRT2_CTYPE    MQDB_VARBINARY
#define M_ENCRPTCRT1_CTYPE  MQDB_FIXBINARY
#define M_ENCRPTCRT2_CTYPE  MQDB_VARBINARY
#define M_QUOTA_CTYPE       MQDB_LONG
#define M_JQUOTA_CTYPE      MQDB_LONG
#define M_MTYPE_CTYPE       MQDB_FIXBINARY
#define M_CTIME_CTYPE       MQDB_LONG
#define M_MTIME_CTYPE       MQDB_LONG
#define M_FOREIGN_CTYPE     MQDB_SHORT
#define M_OS_CTYPE          MQDB_LONG

#define M_NAME1_CLEN        255
#define M_NAME2_CLEN        0
#define M_HKEY_CLEN         4
#define M_ADDRESS1_CLEN     120
#define M_ADDRESS2_CLEN     0
#define M_OUTFRS1_CLEN      16
#define M_OUTFRS2_CLEN      16
#define M_OUTFRS3_CLEN      16
#define M_INFRS1_CLEN       16
#define M_INFRS2_CLEN       16
#define M_INFRS3_CLEN       16
#define M_SITE_CLEN         16
#define M_QMID_CLEN         16
#define M_SERVICES_CLEN     4
#define M_OWNERID_CLEN      16
#define M_SEQNUM_CLEN       8
#define M_SECURITY1_CLEN    255
#define M_SECURITY2_CLEN    255
#define M_SECURITY3_CLEN    0
#define M_SIGNCRT1_CLEN     130
#define M_SIGNCRT2_CLEN     0
#define M_ENCRPTCRT1_CLEN   130
#define M_ENCRPTCRT2_CLEN   0
#define M_QUOTA_CLEN        4
#define M_JQUOTA_CLEN       4
#define M_MTYPE_CLEN        154
#define M_CTIME_CLEN        4
#define M_MTIME_CLEN        4
#define M_FOREIGN_CLEN      2
#define M_OS_CLEN           4

//
// Machine CN table
//

#define MCN_QMID_COL  		"QMId"
#define MCN_CNVAL_COL		"CNVal"
#define MCN_OWNERID_COL    "OwnerId"

#define MCN_QMID_CTYPE		MQDB_FIXBINARY
#define MCN_CNVAL_CTYPE		MQDB_FIXBINARY
#define MCN_OWNERID_CTYPE   MQDB_FIXBINARY

#define MCN_QMID_CLEN		16
#define MCN_CNVAL_CLEN		16
#define MCN_OWNERID_CLEN    16



//
//  Site table
//
#define S_NAME_COL          "Name"
#define S_ID_COL            "SiteId"
#define S_GATES_COL         "SiteGates"
#define S_PSC_COL           "PSC"
#define S_INTREVAL1_COL     "Repl1Interval"
#define S_INTERVAL2_COL     "Repl2Interval"
#define S_OWNERID_COL       "OwnerId"
#define S_SEQNUM_COL        "SeqNum"
#define S_SECURITY1_COL     "Security1"
#define S_SECURITY2_COL     "Security2"
#define S_SECURITY3_COL     "Security3"
#define S_PSCSIGNCPK1_COL   "SignCrt1"
#define S_PSCSIGNCPK2_COL   "SignCrt2"


#define S_NAME_CTYPE        MQDB_FIXBINARY
#define S_ID_CTYPE          MQDB_FIXBINARY
#define S_GATES_CTYPE       MQDB_VARBINARY
#define S_PSC_CTYPE         MQDB_VARBINARY
#define S_INTREVAL1_CTYPE   MQDB_SHORT
#define S_INTERVAL2_CTYPE   MQDB_SHORT
#define S_OWNERID_CTYPE     MQDB_FIXBINARY
#define S_SEQNUM_CTYPE      MQDB_FIXBINARY
#define S_SECURITY1_CTYPE   MQDB_FIXBINARY
#define S_SECURITY2_CTYPE   MQDB_FIXBINARY
#define S_SECURITY3_CTYPE   MQDB_VARBINARY
#define S_PSCSIGNCPK1_CTYPE MQDB_FIXBINARY
#define S_PSCSIGNCPK2_CTYPE MQDB_VARBINARY

#define S_NAME_CLEN         64
#define S_ID_CLEN           16
#define S_GATES_CLEN        1024
#define S_PSC_CLEN          255
#define S_INTREVAL1_CLEN    2
#define S_INTERVAL2_CLEN    2
#define S_OWNERID_CLEN      16
#define S_SEQNUM_CLEN       8
#define S_SECURITY1_CLEN    255
#define S_SECURITY2_CLEN    255
#define S_SECURITY3_CLEN    0
#define S_PSCSIGNCPK1_CLEN  130
#define S_PSCSIGNCPK2_CLEN  0

//
// CN table
//
#define CN_PROTOCOLID_COL   "ProtocolId"
#define CN_NAME_COL         "Name"
#define CN_VAL_COL          "CNVal"
#define CN_OWNERID_COL      "OwnerId"
#define CN_SEQNUM_COL       "SeqNum"
#define CN_SECURITY_COL     "Security"

#define CN_PROTOCOLID_CTYPE MQDB_SHORT
#define CN_NAME_CTYPE       MQDB_FIXBINARY
#define CN_VAL_CTYPE        MQDB_FIXBINARY
#define CN_OWNERID_CTYPE    MQDB_FIXBINARY
#define CN_SEQNUM_CTYPE     MQDB_FIXBINARY
#define CN_SECURITY_CTYPE   MQDB_VARBINARY

#define CN_PROTOCOLID_CLEN  2
#define CN_NAME_CLEN        255
#define CN_VAL_CLEN         16
#define CN_OWNERID_CLEN     16
#define CN_SEQNUM_CLEN      8
#define CN_SECURITY_CLEN    1024

//
//  Enterprise table
//
#define E_NAME_COL          "Name"
#define E_NAMESTYLE_COL     "NameStyle"
#define E_CSP_NAME_COL      "CspName"
#define E_PECNAME_COL       "PecName"
#define E_SINTERVAL1_COL    "SInterval1"
#define E_SINTERVAL2_COL    "SInterval2"
#define E_SECURITY_COL      "Security"
#define E_OWNERID_COL       "OwnerId"
#define E_SEQNUM_COL        "SeqNum"
#define E_ID_COL            "EnterpriseId"
#define E_CRL_COL           "CRL"
#define E_CSP_TYPE_COL      "CspType"
#define E_ENCRYPTALG_COL    "EncryptAlg"
#define E_HASHALG_COL       "HashAlg"
#define E_SIGNALG_COL       "SignAlg"
#define E_CIPHERMODE_COL    "CipherMode"
#define E_LONGLIVE_COL      "LongLive"
#define E_VERSION_COL       "MQISVersion"

#define E_NAME_CTYPE        MQDB_FIXBINARY
#define E_NAMESTYLE_CTYPE   MQDB_SHORT
#define E_CSP_NAME_CTYPE    MQDB_VARBINARY
#define E_PECNAME_CTYPE     MQDB_VARBINARY
#define E_SINTERVAL1_CTYPE  MQDB_SHORT
#define E_SINTERVAL2_CTYPE  MQDB_SHORT
#define E_SECURITY_CTYPE    MQDB_VARBINARY
#define E_OWNERID_CTYPE     MQDB_FIXBINARY
#define E_SEQNUM_CTYPE      MQDB_FIXBINARY
#define E_ID_CTYPE          MQDB_FIXBINARY
#define E_CRL_CTYPE         MQDB_VARBINARY
#define E_CSP_TYPE_CTYPE    MQDB_LONG
#define E_ENCRYPTALG_CTYPE  MQDB_LONG
#define E_HASHALG_CTYPE     MQDB_LONG
#define E_SIGNALG_CTYPE     MQDB_LONG
#define E_CIPHERMODE_CTYPE  MQDB_LONG
#define E_LONGLIVE_CTYPE    MQDB_LONG
#define E_VERSION_CTYPE     MQDB_SHORT



#define E_NAME_CLEN         255
#define E_NAMESTYLE_CLEN    2
#define E_CSP_NAME_CLEN     1024
#define E_PECNAME_CLEN      1024
#define E_SINTERVAL1_CLEN   2
#define E_SINTERVAL2_CLEN   2
#define E_SECURITY_CLEN     1024
#define E_OWNERID_CLEN      16
#define E_SEQNUM_CLEN       8
#define E_ID_CLEN           16
#define E_CRL_CLEN          0
#define E_CSP_TYPE_CLEN     4
#define E_ENCRYPTALG_CLEN   4
#define E_HASHALG_CLEN      4
#define E_SIGNALG_CLEN      4
#define E_CIPHERMODE_CLEN   4
#define E_LONGLIVE_CLEN     4
#define E_VERSION_CLEN      2

//
//  User table
//
#define U_SID_COL           "SID"
#define U_SIGN_CERT_COL     "SignCert"
#define U_OWNERID_COL       "OwnerId"
#define U_SEQNUM_COL        "SeqNum"
#define U_DIGEST_COL        "Digest"
#define U_ID_COL            "UserId"

#define U_SID_CTYPE         MQDB_FIXBINARY
#define U_SIGN_CERT_CTYPE   MQDB_VARBINARY
#define U_OWNERID_CTYPE     MQDB_FIXBINARY
#define U_SEQNUM_CTYPE      MQDB_FIXBINARY
#define U_DIGEST_CTYPE      MQDB_FIXBINARY
#define U_ID_CTYPE          MQDB_FIXBINARY

#define U_SID_CLEN          128
#define U_SIGN_CERT_CLEN    1024
#define U_OWNERID_CLEN      16
#define U_SEQNUM_CLEN       8
#define U_DIGEST_CLEN       16
#define U_ID_CLEN           16

//
// Link table
//
#define L_ID_COL            "LinkId"	
#define L_NEIGHBOR1_COL     "Neighbor1"
#define L_NEIGHBOR2_COL     "Neighbor2"
#define L_COST_COL          "LinkCost"
#define L_OWNERID_COL       "OwnerId"
#define L_SEQNUM_COL        "SeqNum"

#define L_ID_CTYPE          MQDB_FIXBINARY	
#define L_NEIGHBOR1_CTYPE   MQDB_FIXBINARY
#define L_NEIGHBOR2_CTYPE   MQDB_FIXBINARY
#define L_COST_CTYPE        MQDB_LONG
#define L_OWNERID_CTYPE     MQDB_FIXBINARY
#define L_SEQNUM_CTYPE      MQDB_FIXBINARY

#define L_ID_CLEN           16	
#define L_NEIGHBOR1_CLEN    16
#define L_NEIGHBOR2_CLEN    16
#define L_COST_CLEN         4
#define L_OWNERID_CLEN      16
#define L_SEQNUM_CLEN       8

//
//  Purge table
//
#define P_OWNERID_COL       "OwnerId"
#define P_PURGEDSN_COL      "PurgedSN"
#define P_ALLOWEDSN_COL     "AllowedSN"
#define P_ACKEDSN_COL       "AckedSN"
#define P_ACKEDSNPEC_COL    "AckedSnPec"
#define P_STATE_COL			"PurgeState"

#define P_OWNERID_CTYPE     MQDB_FIXBINARY
#define P_PURGEDSN_CTYPE    MQDB_FIXBINARY
#define P_ALLOWEDSN_CTYPE   MQDB_FIXBINARY
#define P_ACKEDSN_CTYPE     MQDB_FIXBINARY
#define P_ACKEDSNPEC_CTYPE  MQDB_FIXBINARY
#define P_STATE_CTYPE		MQDB_SHORT

#define P_OWNERID_CLEN      16
#define P_PURGEDSN_CLEN     8   
#define P_ALLOWEDSN_CLEN    8
#define P_ACKEDSN_CLEN      8
#define P_ACKEDSNPEC_CLEN   8
#define P_STATE_CLEN		2

//
// BscAck table
//
#define B_BSCID_COL         "BscId"
#define B_ACKTIME_COL       "AckTime"

#define B_BSCID_CTYPE       MQDB_FIXBINARY
#define B_ACKTIME_CTYPE     MQDB_LONG

#define B_BSCID_CLEN        16
#define B_ACKTIME_CLEN      4


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\servlist.h ===
//
// File: SERVLIST.H
//

#define  NEW_SITE_IN_REG_FLAG_CHR   L'\\'
#define  NEW_SITE_IN_REG_FLAG_STR   L"\\"

//
// Length of buffer for servers list.
//
#define  WSZSERVERS_LEN  1024
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\notify.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
	notify.h

Abstract:
    declaration of notifications to owners of changed objects

Author:
    RaananH

--*/

#ifndef __NOTIFY_H__
#define __NOTIFY_H__
#include "mqads.h"

//
// describes where to take the notification value for update notification props
//
struct MQDS_NotifyTable
{
    WORD  wValueLocation;  // in original update props or in requested props
    ULONG  idxValue;       // index in appropriate props array
};
//
// queue properties that are needed for create queue notification
//
extern const PROPID g_rgNotifyCreateQueueProps[];
extern const ULONG g_cNotifyCreateQueueProps;
extern const ULONG g_idxNotifyCreateQueueInstance;
//
// QM properties that are needed for notifications
//
extern const PROPID g_rgNotifyQmProps[];
extern const ULONG g_cNotifyQmProps;

HRESULT NotifyCreateQueue(IN const MQDS_OBJ_INFO_REQUEST * pQueueInfoRequest,
                          IN const MQDS_OBJ_INFO_REQUEST * pQmInfoRequest,
                          IN LPCWSTR                       pwcsPathName);

HRESULT NotifyDeleteQueue(IN const MQDS_OBJ_INFO_REQUEST * pQmInfoRequest,
                          IN LPCWSTR                       pwcsPathName,
                          IN const GUID *                  pguidIdentifier);

HRESULT NotifyUpdateObj(IN DWORD                         dwObjectType,
                        IN const MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
                        IN LPCWSTR                       pwcsPathName,
                        IN const GUID *                  pguidIdentifier,
                        IN ULONG                         cUpdProps,    /*debug only*/
                        IN const PROPID *                rgUpdPropIDs, /*debug only*/
                        IN const PROPVARIANT *           rgUpdPropVars,
                        IN ULONG                         cNotifyProps,
                        IN const PROPID *                rgNotifyPropIDs,
                        IN const MQDS_NotifyTable *      rgNotifyPropTbl);

HRESULT RetreiveQueueInstanceFromNotificationInfo(
                          IN  const MQDS_OBJ_INFO_REQUEST * pQueueInfoRequest,
                          IN  ULONG                         idxQueueGuid,
                          OUT GUID *                        pguidObject);

HRESULT GetNotifyUpdateObjProps(IN DWORD dwObjectType,
                                IN ULONG cUpdProps,
                                IN const PROPID * rgUpdPropIDs,
                                OUT ULONG * pcObjRequestProps,
                                OUT PROPID ** prgObjRequestPropIDs,
                                OUT ULONG * pcNotifyProps,
                                OUT PROPID ** prgNotifyPropIDs,
                                OUT MQDS_NotifyTable ** prgNotifyPropTbl);

HRESULT RetreiveObjectIdFromNotificationInfo(
                          IN  const MQDS_OBJ_INFO_REQUEST * pObjectInfoRequest,
                          IN  ULONG                         idxObjectGuid,
                          OUT GUID *                        pguidObject);

HRESULT ConvertToNT4Props(ULONG cProps,
                          const PROPID * rgPropIDs,
                          const PROPVARIANT * rgPropVars,
                          ULONG * pcNT4Props,
                          PROPID ** prgNT4PropIDs,
                          PROPVARIANT ** prgNT4PropVars);

PROPVARIANT * FindPropInArray(PROPID propid,
                              ULONG cProps,
                              const PROPID * rgPropIDs,
                              PROPVARIANT * rgPropVars);

HRESULT GetNT4CreateQueueProps(ULONG cProps,
                               const PROPID * rgPropIDs,
                               const PROPVARIANT * rgPropVars,
                               ULONG * pcNT4CreateProps,
                               PROPID ** prgNT4CreatePropIDs,
                               PROPVARIANT ** prgNT4CreatePropVars);

void GetThisMqDsInfo(GUID * pguidSiteId,
                     LPWSTR * ppwszServerName);

#endif //__NOTIFY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\adnotify_c_.c ===
#pragma warning(push, 3)
#include <adnotify_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\spec.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    spec.h

Abstract:

    CDSPropSpec Class : builds PROPSPEC according to PROPID

	NOTE : this class raise an exception, when fails to allocate memory!!

Author:

    Ronit Hartmann (ronith)

--*/
#ifndef __SPEC_H__
#define __SPEC_H__

extern struct _PROP_INFO g_PropInfoTable[];


class CDSPropSpec
{
	public:
	inline CDSPropSpec( DWORD cp, PROPID aProp[]);
	inline ~CDSPropSpec();

	inline DSPROPSPEC * GetPropSpec();

	private:
	inline void FillPropSpec(PROPID prop, DSPROPSPEC * pps);
	DWORD m_cp;				// number of property specs
	DSPROPSPEC * m_pps;		//  pointer to DSPROPSPEC;
};


inline CDSPropSpec::CDSPropSpec( DWORD cp, PROPID aProp[])
{
	DWORD i;
	DSPROPSPEC * pps;

	ASSERT(cp>0);
	ASSERT(aProp != NULL);
	m_pps = (DSPROPSPEC *) new char [sizeof(DSPROPSPEC) * cp];
	if ( NULL == m_pps)
	{
		RaiseException( MQ_ALLOC_FAIL, 0,0,0);
		m_cp = 0;
	}
	else
	{
		m_cp = cp;

		// fill the property spec
		pps = m_pps;
		for ( i = 0; i < cp; i++, aProp++, pps++)
		{
			FillPropSpec(*aProp, pps);	
		}
	}

}


inline CDSPropSpec::~CDSPropSpec()
{
	delete [] m_pps;
}

inline DSPROPSPEC * CDSPropSpec::GetPropSpec()
{
	ASSERT(m_pps != NULL);
	return(m_pps);
}

inline void CDSPropSpec::FillPropSpec(PROPID prop, DSPROPSPEC * pps)
{
	PROP_INFO * pPropInfo = &g_PropInfoTable[0];
	BOOL bFound = FALSE;
	// find the property parameters in the table

	while ( pPropInfo->prop != 0)
	{
		if (pPropInfo->prop == prop)
		{
			bFound = TRUE;
			break;
		}
		pPropInfo++;
	}
	if (bFound)
	{
#ifdef _DEBUG
		pps->pszName = pPropInfo->pszName;
#endif
		pps->iPropSetNum = pPropInfo->iPropSetNum;
	}

    pps->ps.ulKind = PRSPEC_PROPID;
	pps->ps.propid = prop;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\ads.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
	dsads.h

Abstract:
	CAdsi class - encapsulates work with ADSI

Author:
    ronith


--*/


#ifndef __ADS_H__
#define __ADS_H__

#include "ds_stdh.h"
#include "baseobj.h"
#include "activeds.h"
#include "oledb.h"
#include "oledberr.h"
#include "mqads.h"
#include "adsiutil.h"

//-----------------------------
//  Misc types
//-----------------------------

enum AD_PROVIDER {
        //
        //  For set, crate and delete operations of queue,user and machine
        //  objects.
        //  The operation will be performed by the owning DC.
        //
        //  For all access operation of objects that are in the
        //  configuration container.
        //
        //  And first trial to retrieve information of queue, user and
        //  machine objects.
        //
        //
     adpDomainController,
        //
        //  For locate operation of queue, user and machine objects.
        //  And when retrieving information of these objects after
        //  failing to find them in the local domain controller.
        //
     adpGlobalCatalog,
};

enum AD_SEARCH_LEVEL {
    searchOneLevel,
    searchSubTree
} ;


struct MultiplAppearance
{
public:
    inline MultiplAppearance();
    DWORD dwIndex;
};
inline MultiplAppearance::MultiplAppearance():
           dwIndex(x_NoPropertyFirstAppearance)
{
}


//----------------------------------------
//  CAdsi:: ADSI encapsulation class
//----------------------------------------

class CAdsi
{
public:
    CAdsi();

    ~CAdsi();

    HRESULT LocateBegin(
            IN  AD_SEARCH_LEVEL      eSearchLevel,       
            IN  AD_PROVIDER          eProvider, 
            IN  DS_CONTEXT           eContext, 
            IN  CBasicObjectType*    pObject,
            IN  const GUID *         pguidSearchBase, 
            IN  LPCWSTR              pwcsSearchFilter,   
            IN  const MQSORTSET *    pDsSortkey,       
            IN  const DWORD          cp,              
            IN  const PROPID *       pPropIDs,       
            OUT HANDLE *             phResult
            );       

    HRESULT LocateNext(
            IN     HANDLE          hResult,        
            IN OUT DWORD          *pcp,         
            OUT    MQPROPVARIANT  *pPropVars
            );    

    HRESULT LocateEnd(
            IN HANDLE phResult
            );            

    HRESULT GetObjectProperties(
            IN  AD_PROVIDER         eProvider,
            IN  CBasicObjectType*   pObject,
            IN  const DWORD			cPropIDs,           
            IN  const PROPID *		pPropIDs,           
            OUT MQPROPVARIANT *		pPropVars
            );        

    HRESULT SetObjectProperties(
            IN  AD_PROVIDER          eProvider,
            IN  CBasicObjectType*    pObject,
            IN  const DWORD          cp,                 
            IN  const PROPID *       pPropIDs,     
            IN  const MQPROPVARIANT *pPropVars,        
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            ); 

    HRESULT CreateObject(
            IN AD_PROVIDER          eProvider,		 
            IN CBasicObjectType*    pObject,
            IN LPCWSTR              pwcsChildName,  
            IN LPCWSTR              pwcsParentPathName,
            IN const DWORD          cp,                 
            IN const PROPID *       pPropIDs,       
            IN const MQPROPVARIANT * pPropVars,      
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,    
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            ); 

    HRESULT DeleteObject(
            IN AD_PROVIDER      eProvider,	
            IN CBasicObjectType* pObject,
            IN LPCWSTR          pwcsPathName,   
            IN const GUID *     pguidUniqueId,  
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,     
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );

    HRESULT DeleteContainerObjects(
            IN AD_PROVIDER      eProvider,
            IN DS_CONTEXT       eContext,
            IN LPCWSTR          pwcsDomainController,
            IN bool             fServerName,
            IN LPCWSTR          pwcsContainerName,
            IN const GUID *     pguidContainerId,
            IN LPCWSTR          pwcsObjectClass
            );

    HRESULT GetParentName(
            IN  AD_PROVIDER      eProvider,		    
            IN  DS_CONTEXT       eContext,
            IN  LPCWSTR          pwcsDomainController,
            IN  bool             fServerName,
            IN  const GUID *     pguidUniqueId,     
            OUT LPWSTR *         ppwcsParentName
            );

    HRESULT GetParentName(
            IN  AD_PROVIDER     eProvider,		 
            IN  DS_CONTEXT      eContext,
            IN  LPCWSTR         pwcsDomainController,
            IN  bool            fServerName,
            IN  LPCWSTR         pwcsChildName,  
            OUT LPWSTR *        ppwcsParentName
            );

	HRESULT 
	GetLocalDsRoot(
			IN LPCWSTR pwcsDomainController, 
			IN bool fServerName,
			OUT LPWSTR* ppwcsLocalDsRoot,
			OUT AP<WCHAR>& pwcsLocalDsRootToFree
			);

    HRESULT GetRootDsName(
            OUT LPWSTR *        ppwcsRootName,
            OUT LPWSTR *        ppwcsLocalRootName,
			OUT LPWSTR *        ppwcsSchemaNamingContext
            );

    HRESULT DoesObjectExists(
        IN  AD_PROVIDER     eProvider,
        IN  DS_CONTEXT      eContext,
        IN  LPCWSTR         pwcsObjectName
        );

    HRESULT FindComputerObjectFullPath(
            IN  AD_PROVIDER             eProvider,
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN  ComputerObjType         eComputerObjType,
			IN  LPCWSTR                 pwcsComputerDnsName,
            IN  const MQRESTRICTION *   pRestriction,
            OUT LPWSTR *                ppwcsFullPathName
            );

    HRESULT GetObjectSecurityProperty(
            IN  AD_PROVIDER             eProvider,
            IN  CBasicObjectType*       pObject,
            IN  SECURITY_INFORMATION    seInfo,           
            IN  const PROPID 		    prop,           
            OUT MQPROPVARIANT *		    pVar
            );        

    HRESULT SetObjectSecurityProperty(
            IN  AD_PROVIDER             eProvider,
            IN  CBasicObjectType*       pObject,
            IN  SECURITY_INFORMATION    seInfo,           
            IN  const PROPID 		    prop,           
            IN  const MQPROPVARIANT *	pVar,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );        

    HRESULT GetADsPathInfo(
            IN  LPCWSTR                 pwcsADsPath,
            OUT PROPVARIANT *           pVar,
            OUT eAdsClass *             pAdsClass
            );

protected:
    HRESULT BindToObject(
            IN AD_PROVIDER      eProvider,		    
            IN DS_CONTEXT       eContext,  
            IN LPCWSTR          pwcsDomainController,
            IN bool             fServerName,
            IN LPCWSTR          pwcsPathName,
            IN const GUID*      pguidUniqueId,
            IN REFIID           riid,     
            OUT void           *ppIUnk
            );

    HRESULT BindToGUID(
        IN AD_PROVIDER         eProvider,	
        IN DS_CONTEXT          eContext,
        IN LPCWSTR             pwcsDomainController,
        IN bool				   fServerName,
        IN const GUID *        pguidObjectId,
        IN REFIID              riid,       
        OUT VOID*              ppIUnk
        );


    HRESULT BindForSearch(
            IN AD_PROVIDER         eProvider,	
            IN DS_CONTEXT          eContext,         
            IN  LPCWSTR            pwcsDomainController,
			IN bool				   fServerName,
            IN const GUID *        pguidObjectId,
            IN BOOL                fSorting,
            OUT VOID *             ppIUnk
            );

    HRESULT FindObjectFullNameFromGuid(
        IN  AD_PROVIDER      eProvider,	
        IN  DS_CONTEXT       eContext,   
        IN  LPCWSTR          pwcsDomainController,
        IN  bool			 fServerName,
        IN  const GUID *     pguidObjectId,
        IN  BOOL             fTryGCToo,
        OUT WCHAR **         pwcsFullName,
        OUT AD_PROVIDER *    pFoundObjectProvider
        );


private:

	HRESULT 
	GetLocalDsRootName(
		IN  LPCWSTR			pwcsDomainController,
		IN  bool			fServerName,
		OUT LPWSTR *        ppwcsLocalRootName
		);

	HRESULT
	GetDefaultNamingContext(
		IN IADs*     pADs,
		OUT LPWSTR*  ppwcsLocalRootName
		);

	HRESULT GetObjSecurityFromDS(
        IN  IADs                 *pIADs,      
        IN  BSTR                  bs,        
        IN  const PROPID          propid, 
        IN  SECURITY_INFORMATION  seInfo,  
        OUT MQPROPVARIANT        *pPropVar
        ); 

    BOOL    NeedToConvertSecurityDesc( PROPID propID ) ;

    HRESULT SetObjectSecurity(
        IN  IADs                *pIADs,  
		IN  const BSTR			 bs,	
        IN  const MQPROPVARIANT *pMqVar,
        IN  ADSTYPE              adstype,	
        IN  const DWORD          dwObjectType, 
        IN  SECURITY_INFORMATION seInfo,        
        IN  PSID                 pComputerSid
        );  


    HRESULT GetObjectPropsCached(
        IN  IADs            *pIADs,        
        IN  CBasicObjectType* pObject,
        IN  DWORD            cp,         
        IN  const PROPID    *pPropIDs,      
        OUT MQPROPVARIANT   *pPropVars
        );    

    HRESULT SetObjectPropsCached(
        IN LPCWSTR         pwcsDomainController,
		IN bool			   fServerName,
        IN IADs            *pIADs,       
        IN DWORD            cp,               
        IN const PROPID    *pPropID,        
        IN const MQPROPVARIANT   *pPropVar
        );      


    HRESULT MqPropVal2AdsiVal(
          OUT ADSTYPE       *pAdsType,
          OUT DWORD         *pdwNumValues,
          OUT PADSVALUE     *ppADsValue,
          IN  PROPID         propID,
          IN  const MQPROPVARIANT *pPropVar,
          IN  PVOID          pvMainAlloc
          );

    HRESULT AdsiVal2MqPropVal(
              OUT MQPROPVARIANT *pPropVar,
              IN  PROPID        propID,
              IN  ADSTYPE       AdsType,
              IN  DWORD         dwNumValues,
              IN  PADSVALUE     pADsValue
              );

    HRESULT FillAttrNames(
            OUT LPWSTR    *          ppwszAttributeNames,  
            OUT DWORD *              pcRequestedFromDS,   
            IN  DWORD                cPropIDs,           
            IN  const PROPID    *    pPropIDs
            );         


    HRESULT FillSearchPrefs(
            OUT ADS_SEARCHPREF_INFO *pPrefs,   
            OUT DWORD               *pdw,       
            IN  AD_SEARCH_LEVEL      eSearchLevel,
            IN  const MQSORTSET *    pDsSortkey, 
            OUT      ADS_SORTKEY *  pSortKeys
            );	

    HRESULT CopyDefaultValue(
           IN const MQPROPVARIANT *   pvarDefaultValue,
           OUT MQPROPVARIANT *        pvar
           );

    HRESULT LocateObjectFullName(
            IN AD_PROVIDER       eProvider,	
            IN DS_CONTEXT        eContext,    
            IN  LPCWSTR          pwcsDomainController,
	        IN  bool			 fServerName,
            IN  const GUID *     pguidObjectId,
            OUT WCHAR **         ppwcsFullName
            );

    HRESULT BindRootOfForest(
            OUT void           *ppIUnk);

    HRESULT GetParentInfo(
                       IN CBasicObjectType *           pObject,
                       IN LPWSTR                       pwcsFullParentPath,
                       IN IADsContainer               *pContainer,
                       IN OUT MQDS_OBJ_INFO_REQUEST   *pParentInfoRequest
                       );

    HRESULT  GetParentInfo(
                       IN CBasicObjectType *          pObject,
                       IN IADs *                      pADsObject,
                       IN OUT MQDS_OBJ_INFO_REQUEST  *pParentInfoRequest
                       );

	HRESULT CreateIDirectoryObject(
            IN CBasicObjectType*    pObject,
            IN LPCWSTR				pwcsObjectClass,	
            IN IDirectoryObject *	pDirObj,
			IN LPCWSTR				pwcsFullChildPath,
            IN const DWORD			cPropIDs,
            IN const PROPID *		pPropIDs,
            IN const MQPROPVARIANT * pPropVar,
			IN const AD_OBJECT		eObject,
            OUT IDispatch **		pDisp
			);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\adsihq.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
	adsihq.h

Abstract:
	Internal definitions for CADSI class implementation

Author:
    AlexDad
--*/
#ifndef __ADSIHQ_H__
#define __ADSIHQ_H__

#include "activeds.h"
#include "mqads.h"
#include "baseobj.h"

//---------------------------------------------------------
//
// CADSSearch: Internal object encapsulating ongoing search
//
//---------------------------------------------------------

class CADSearch
{
public:
    CADSearch( IDirectorySearch  *      pIDirSearch, 
               const PROPID      *      pPropIDs,    
               DWORD                    cPropIDs,          
               DWORD                    cRequestedFromDS,
               CBasicObjectType *       pObject,               
               ADS_SEARCH_HANDLE        hSearch
			   );
    ~CADSearch();

    bool               Verify();
    IDirectorySearch  *pDSSearch();
    ADS_SEARCH_HANDLE  hSearch();
    PROPID             PropID(DWORD i);
    DWORD              NumPropIDs();
    DWORD              NumRequestedFromDS();

    void               SetNoMoreResult();
    bool               WasLastResultReturned();

    void GetObjXlateInfo(
                 IN  LPCWSTR                pwcsObjectDN,
                 IN  const GUID*            pguidObject,
                 OUT CObjXlateInfo**        ppcObjXlateInfo
				 );


private:
    IDirectorySearch  *m_pDSSearch;     //IDirectorySearch interface captured;
    ADS_SEARCH_HANDLE  m_hSearch;       // ADSI search handle 
    PROPID            *m_pPropIDs;      // array of column PropIDs
    DWORD              m_cPropIDs;      // counter of columns requested in PropIDs
    DWORD              m_cRequestedFromDS; // counter of columns passed to DS (with Dn & Guid)
    R<CBasicObjectType> m_pObject;  
    bool               m_fNoMoreResults;
};



inline IDirectorySearch  *CADSearch::pDSSearch()
{
    return m_pDSSearch;
}
    
inline ADS_SEARCH_HANDLE CADSearch::hSearch()
{
    return  m_hSearch;
}

inline  PROPID CADSearch::PropID(DWORD i)
{
    ASSERT(i < m_cPropIDs);
    return m_pPropIDs[i];
}

inline DWORD CADSearch::NumPropIDs()
{
    return m_cPropIDs;
}

inline DWORD CADSearch::NumRequestedFromDS()
{
    return m_cRequestedFromDS;
}

inline void CADSearch::SetNoMoreResult()
{
    m_fNoMoreResults = true;
}
inline bool CADSearch::WasLastResultReturned()
{
    return( m_fNoMoreResults);
}


void CADSearch::GetObjXlateInfo(
                 IN  LPCWSTR                pwcsObjectDN,
                 IN  const GUID*            pguidObject,
                 OUT CObjXlateInfo**        ppcObjXlateInfo)
{
    m_pObject->GetObjXlateInfo( pwcsObjectDN,
                                pguidObject,
                                ppcObjXlateInfo
								);
}  

#endif

STATIC HRESULT GetDNGuidFromSearchObj(IN IDirectorySearch  *pSearchObj,
                                      ADS_SEARCH_HANDLE  hSearch,
                                      OUT LPWSTR * ppwszObjectDN,
                                      OUT GUID ** ppguidObjectGuid
									  );
STATIC HRESULT GetDNGuidFromIADs(IN IADs * pIADs,
                                 OUT LPWSTR * ppwszObjectDN,
                                 OUT GUID ** ppguidObjectGuid
								 );

static HRESULT VerifyObjectCategory( IN IADs * pIADs,
                                  IN const WCHAR * pwcsExpectedCategory
                                 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\ads.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dsads.cpp

Abstract:

    Implementation of CAdsi class, encapsulating work with ADSI.

Author:

    ronith

--*/

#include "ds_stdh.h"
#include "adtempl.h"
#include "dsutils.h"
#include "adsihq.h"
#include "ads.h"
#include "utils.h"
#include "mqads.h"
#include "mqadglbo.h"
#include "mqadp.h"
#include "mqattrib.h"
#include "_propvar.h"
#include "mqdsname.h"
#include "mqsec.h"
#include "traninfo.h"


#include "ads.tmh"

static WCHAR *s_FN=L"mqad/ads";

#ifdef _DEBUG
extern "C"
{
__declspec(dllimport)
ULONG __cdecl LdapGetLastError( VOID );
}
#endif

//
CAdsi::CAdsi()
/*++
    Abstract:

    Parameters:

    Returns:

--*/
{
}

CAdsi::~CAdsi()
/*++
    Abstract:

    Parameters:

    Returns:

--*/
{
}


HRESULT CAdsi::LocateBegin(
            IN  AD_SEARCH_LEVEL      eSearchLevel,       
            IN  AD_PROVIDER          eProvider, 
            IN  DS_CONTEXT           eContext, 
            IN  CBasicObjectType*    pObject,
            IN  const GUID *         pguidSearchBase, 
            IN  LPCWSTR              pwcsSearchFilter,   
            IN  const MQSORTSET *    pDsSortkey,       
            IN  const DWORD          cp,              
            IN  const PROPID *       pPropIDs,       
            OUT HANDLE *             phResult) 	    // result handle
/*++
    Abstract:
	Initiate a search in Active Directory

    Parameters:

    Returns:

--*/
{
	*phResult = NULL;
    HRESULT hr;
    ADS_SEARCH_HANDLE   hSearch;

    BOOL fSorting = FALSE;
    if (pDsSortkey && (pDsSortkey->cCol >= 1))
    {
        fSorting = TRUE ;
    }

    R<IDirectorySearch> pDSSearch = NULL;
    hr = BindForSearch(
                    eProvider,
                    eContext,
                    pObject->GetDomainController(),
                    pObject->IsServerName(),
                    pguidSearchBase,
                    fSorting,
                    (VOID *)&pDSSearch
                    );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }

    //
    //  Prepare search and sort data
    //

    ADS_SEARCHPREF_INFO prefs[15];
    AP<ADS_SORTKEY> pSortKeys = new ADS_SORTKEY[(pDsSortkey ? pDsSortkey->cCol : 1)];
    DWORD dwPrefs = 0;

    hr = FillSearchPrefs(prefs,
                         &dwPrefs,
                         eSearchLevel,
                         pDsSortkey,
                         pSortKeys);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }

	//
    // Translate MQPropIDs to ADSI Names
	//
    DWORD   cRequestedFromDS = cp + 2; //request also dn & guid

    PVP<LPWSTR> pwszAttributeNames = (LPWSTR *)PvAlloc(sizeof(LPWSTR) * cRequestedFromDS);

    hr = FillAttrNames( pwszAttributeNames,
                        &cRequestedFromDS,
                        cp,
                        pPropIDs);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50);
    }

    //
    //  Set search preferences
    //
    if (dwPrefs)
    {
        hr = pDSSearch->SetSearchPreference( prefs,
                                             dwPrefs
											 );
        ASSERT(SUCCEEDED(hr)) ; // we don't expect this to fail.
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 60);
        }
    }

    //
    //  Really execute search
    //
    hr = pDSSearch->ExecuteSearch(
                         const_cast<WCHAR*>(pwcsSearchFilter),
                         pwszAttributeNames,
                         cRequestedFromDS,
                        &hSearch);
    LogTraceQuery(const_cast<WCHAR*>(pwcsSearchFilter), s_FN, 69);
    if (FAILED(hr))
    {
		TrERROR(mqad, "failed to ExecuteSearch, hr = 0x%x, pwcsSearchFilter = %ls", hr, pwcsSearchFilter);
        return LogHR(hr, s_FN, 70);
    }
	//
    // Capturing search interface and handle in the internal search object
	//
    CADSearch *pSearchInt = new CADSearch(
                        pDSSearch.get(),
                        pPropIDs,
                        cp,
                        cRequestedFromDS,
                        pObject,
                        hSearch
						);
	//
    // Returning handle-casted internal object pointer
	//
    *phResult = (HANDLE)pSearchInt;

    return MQ_OK;
}

HRESULT CAdsi::LocateNext(
            IN     HANDLE          hSearchResult,   // result handle
            IN OUT DWORD          *pcPropVars,      // IN num of variants; OUT num of results
            OUT    MQPROPVARIANT  *pPropVars)       // MQPROPVARIANT array
/*++
    Abstract:
	Retrieve results of a search

    Parameters:

    Returns:

--*/
{
    HRESULT hr = MQ_OK;
    CADSearch *pSearchInt = (CADSearch *)hSearchResult;
    DWORD cPropsRequested = *pcPropVars;
    *pcPropVars = 0;

    IDirectorySearch  *pSearchObj = pSearchInt->pDSSearch();

    //
    //  Did we get S_ADS_NOMORE_ROWS in this query
    //
    if (  pSearchInt->WasLastResultReturned())
    {
        *pcPropVars = 0;
        return MQ_OK;
    }
	//
    // Compute number of full rows to return
	//
    DWORD cRowsToReturn = cPropsRequested / pSearchInt->NumPropIDs();

    // got to request at least one row
    ASSERT(cRowsToReturn > 0);

    // pointer to next prop to be filled
    MQPROPVARIANT *pPropVarsProp = pPropVars;

    // number of returned props
    DWORD cPropVars = 0;
	//
    // loop on requested rows
	//
    for (DWORD dwRow = 0; dwRow < cRowsToReturn; dwRow++)
    {
        //  Get next row
        hr = pSearchObj->GetNextRow(pSearchInt->hSearch());
        //
        //  BUGBUG - sometimes gets E_ADS_LDAP_INAPPROPRIATE_MATCHING,
        //  to investgate more!!
        //
        if ( hr == HRESULT_FROM_WIN32(ERROR_DS_INAPPROPRIATE_MATCHING))
            break;
		
		// BUGBUG: sometimes gets E_ADS_LDAP_UNAVAILABLE_CRIT_EXTENSION on empty search
		// See example tests\sortnull (was repro) - to investigate more
		//
		if ( hr == HRESULT_FROM_WIN32(ERROR_DS_UNAVAILABLE_CRIT_EXTENSION))
		{
			hr = S_ADS_NOMORE_ROWS;
		}

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 90);
        }
        if (hr == S_ADS_NOMORE_ROWS)
        {
            *pcPropVars = cPropVars;
            pSearchInt->SetNoMoreResult();
            return MQ_OK;
        }
        //
        // Get object translate info
        //
        AP<WCHAR> pwszObjectDN;
        P<GUID> pguidObjectGuid;
        P<CObjXlateInfo> pcObjXlateInfo;

        // Get dn & guid from object (got to be there, because we asked for them)
        hr = GetDNGuidFromSearchObj(pSearchObj, pSearchInt->hSearch(), &pwszObjectDN, &pguidObjectGuid);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 105);
        }

        // Get translate info object
        pSearchInt->GetObjXlateInfo(pwszObjectDN, pguidObjectGuid,  &pcObjXlateInfo);

        // Tell the translate info object about the search object to use in order to get necessary DS props
        pcObjXlateInfo->InitGetDsProps(pSearchObj, pSearchInt->hSearch());

        // Loop by requested properties
        for (DWORD dwProp=0; dwProp < pSearchInt->NumPropIDs(); dwProp++, pPropVarsProp++, cPropVars++)
        {
            //
            //  vartype of all PROPVARIANT should be VT_NULL.
            //  ( user cannot specify buffers for results).
            //
            pPropVarsProp->vt = VT_NULL;

            //
            //  First check if the next property is in the DS
            //
            //
            // Get property info
            //
            const translateProp *pTranslate;
            if(!g_PropDictionary.Lookup( pSearchInt->PropID(dwProp), pTranslate))
            {
                ASSERT(0);
                return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1000);
            }

            // Maybe it is one of the known things?
            if (pTranslate->wcsPropid)
            {
                // We already know objectGuid, no need to ask once more
                if (wcscmp(pTranslate->wcsPropid, const_cast<LPWSTR>(x_AttrDistinguishedName)) == 0)
                {
                    pPropVarsProp->vt      = VT_LPWSTR;
                    pPropVarsProp->pwszVal = new WCHAR[wcslen(pwszObjectDN) + 1];
                    wcscpy(pPropVarsProp->pwszVal, pwszObjectDN);
                    continue;
                }

                // We already know objectGuid, no need to ask once more
                if (wcscmp(pTranslate->wcsPropid, const_cast<LPWSTR>(x_AttrObjectGUID)) == 0)
                {
                    if (pPropVarsProp->vt != VT_CLSID)
                    {
                        ASSERT(((pPropVarsProp->vt == VT_NULL) || (pPropVarsProp->vt == VT_EMPTY)));
                        pPropVarsProp->vt    = VT_CLSID;
                        pPropVarsProp->puuid = new GUID;
                    }
                    else if ( pPropVarsProp->puuid == NULL)
                    {
                        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 1010);
                    }

                    *pPropVarsProp->puuid = *pguidObjectGuid;
                    continue;
                }
            }

            //
            // if the property is not in the DS, call its retrieve routine
            //
            if (pTranslate->vtDS == ADSTYPE_INVALID)
            {
                if (pTranslate->RetrievePropertyHandle)
                {
                    //
                    //  Calculate its value
                    //
                    hr = pTranslate->RetrievePropertyHandle(
                            pcObjXlateInfo,
                            NULL,   //BUGBUG pwcsDomainController
							false,	// fServerName
                            pPropVarsProp
                            );
                    if (FAILED(hr))
                    {
                        return LogHR(hr, s_FN, 121);
                    }
                    continue;
                }
                else
                {
                    //
                    // return error if no retrieve routine
                    //
                    ASSERT(0);
                    return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1020);
                }
            }

            ADS_SEARCH_COLUMN Column;

            // Ask for the column itself
            hr = pSearchObj->GetColumn(
                         pSearchInt->hSearch(),
                         (LPWSTR)pTranslate->wcsPropid,
                         &Column);

            if (hr == E_ADS_COLUMN_NOT_SET)
            {
                //  The requested column has no value in DS
                hr = CopyDefaultValue(
                       pTranslate->pvarDefaultValue,
                       pPropVarsProp);
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 131);
                }
                continue;
            }
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 141);
            }

            hr = AdsiVal2MqPropVal(pPropVarsProp,
                                   pSearchInt->PropID(dwProp),
                                   Column.dwADsType,
                                   Column.dwNumValues,
                                   Column.pADsValues);
            pSearchObj->FreeColumn(&Column);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 150);
            }
        }
    }

    *pcPropVars = cPropVars;
    return MQ_OK;
}


HRESULT CAdsi::LocateEnd(
        IN HANDLE phResult)     // result handle
/*++
    Abstract:
	Completes a search 

    Parameters:

    Returns:

--*/
{
    CADSearch *pSearchInt = (CADSearch *)phResult;

    delete pSearchInt;      // inside: release interface and handle

    return MQ_OK;
}

HRESULT CAdsi::GetObjectProperties(
            IN  AD_PROVIDER         eProvider,
            IN  CBasicObjectType*   pObject,
            IN  const DWORD			cPropIDs,           
            IN  const PROPID *		pPropIDs,           
            OUT MQPROPVARIANT *		pPropVars)
/*++
    Abstract:
	retrieves object properties from the AD

    Parameters:

    Returns:

--*/
{
    HRESULT               hr;
    R<IADs>   pAdsObj        = NULL;

    // Bind to the object either by GUID or by name
    hr = BindToObject(
                eProvider,
                pObject->GetADContext(),
                pObject->GetDomainController(),
                pObject->IsServerName(),
                pObject->GetObjectDN(),
                pObject->GetObjectGuid(),
                IID_IADs,
                (VOID *)&pAdsObj
                );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 180);
    }
    if ( eProvider == adpDomainController)
    {
        pObject->ObjectWasFoundOnDC();
    }
    //
    //  verify that the bounded object is of the correct category
    //
    hr = VerifyObjectCategory( pAdsObj.get(),  pObject->GetObjectCategory());
    if (FAILED(hr))
    {
        return LogHR( hr, s_FN, 117);
    }

    // Get properies
    hr = GetObjectPropsCached(
                        pAdsObj.get(),
                        pObject,
                        cPropIDs,
                        pPropIDs,
                        pPropVars);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 190);
    }


    return MQ_OK;
}

HRESULT CAdsi::SetObjectProperties(
            IN  AD_PROVIDER        eProvider,
            IN  CBasicObjectType*  pObject,
            IN  DWORD               cPropIDs,         // number of attributes to set
            IN  const PROPID         *pPropIDs,           // attributes to set
            IN  const MQPROPVARIANT  *pPropVars,          // attribute values
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            )
/*++
    Abstract:
	sets object properties in AD

    Parameters:

    Returns:

--*/
{
    HRESULT               hr;
    ASSERT( eProvider != adpGlobalCatalog);

    // Working through cache
    R<IADs>   pAdsObj = NULL;

    hr = BindToObject(
                eProvider,
                pObject->GetADContext(),
                pObject->GetDomainController(),
                pObject->IsServerName(),
                pObject->GetObjectDN(),
                pObject->GetObjectGuid(),
                IID_IADs,
                (VOID *)&pAdsObj
                );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 210);
    }
    if ( eProvider == adpDomainController)
    {
        pObject->ObjectWasFoundOnDC();
    }

    // Set properies
    hr = SetObjectPropsCached(
                        pObject->GetDomainController(),
                        pObject->IsServerName(),
                        pAdsObj.get(),
                        cPropIDs,
                        pPropIDs,
                        pPropVars);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 220);
    }

    // Finilize changes
    hr = pAdsObj->SetInfo();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 230);
    }

    //
    // get object info if requested. don't fail if the request fails,
    // just mark the failure in the request's status
    //
    if (pObjInfoRequest != NULL)
    {
        pObjInfoRequest->hrStatus =
              GetObjectPropsCached( pAdsObj.get(),
                                    pObject,
                                    pObjInfoRequest->cProps,
                                    pObjInfoRequest->pPropIDs,
                                    pObjInfoRequest->pPropVars
                                    );
    }

    if (pParentInfoRequest != NULL)
    {
        pParentInfoRequest->hrStatus =
            GetParentInfo(
                pObject,
                pAdsObj.get(),
                pParentInfoRequest
                );
            
    }

    return MQ_OK;
}


HRESULT  CAdsi::GetParentInfo(
                       IN CBasicObjectType *          pObject,
                       IN IADs *                      pADsObject,
                       IN OUT MQDS_OBJ_INFO_REQUEST  *pParentInfoRequest
                       )
/*++
    Abstract:

    Parameters:

    Returns:

--*/

{
    R<IADs> pCleanAds;
    IADs * pADsAccordingToName = pADsObject;

    if ( pObject->GetObjectGuid() != NULL)
    {
        //
        //  GetParent of object bound according to GUID doesn't work
        //  That is why we translate it to pathname
        //
        AP<WCHAR>  pwcsFullPath;
        AD_PROVIDER prov;
        HRESULT hr;
        hr = FindObjectFullNameFromGuid(
				adpDomainController,	
				pObject->GetADContext(),    
				pObject->GetDomainController(),
				pObject->IsServerName(),
				pObject->GetObjectGuid(),
				1,              // fTryGCToo
				&pwcsFullPath,
				&prov
				);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 1181);
        }

        // Bind to by name

        hr = BindToObject(
                prov,
                pObject->GetADContext(),
                pObject->GetDomainController(),
                pObject->IsServerName(),
                pwcsFullPath,
                NULL,
                IID_IADs,
                (VOID *)&pADsAccordingToName
                );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 1191);
        }
        pCleanAds = pADsAccordingToName;
    }

    //
    //  Get the parent from the object
    //
    BSTR  bs;
    HRESULT hr;
    hr = pADsAccordingToName->get_Parent(&bs);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 362);
    }
    BS  bstrParentADsPath(bs);
    SysFreeString(bs);

    // Get the parent object.

    R<IADs> pIADsParent;
    hr = ADsOpenObject( bstrParentADsPath,
                        NULL,
                        NULL,
						ADS_SECURE_AUTHENTICATION,
                        IID_IADs,
                        (void**)&pIADsParent);
    LogTraceQuery(bstrParentADsPath, s_FN, 368);
    if (FAILED(hr))
    {
		TrERROR(mqad, "ADsOpenObject failed, hr = 0x%x, AdsPath = %ls", hr, bstrParentADsPath);
        return LogHR(hr, s_FN, 375);
    }

    hr = GetObjectPropsCached( pIADsParent.get(),
                                  pObject,
                                  pParentInfoRequest->cProps,
                                  pParentInfoRequest->pPropIDs,
                                  pParentInfoRequest->pPropVars );

    return LogHR(hr, s_FN, 1071);
}


HRESULT  CAdsi::GetParentInfo(
                       IN CBasicObjectType *          pObject,
                       IN LPWSTR                      /* pwcsFullParentPath */,
                       IN IADsContainer              *pContainer,
                       IN OUT MQDS_OBJ_INFO_REQUEST  *pParentInfoRequest
                       )
/*++
    Abstract:

    Parameters:

    Returns:

--*/

{
    R<IADs> pIADsParent;
    HRESULT hrTmp = pContainer->QueryInterface( IID_IADs,
                                                  (void **)&pIADsParent);
    if (FAILED(hrTmp))
    {
        return LogHR(hrTmp, s_FN, 1030);
    }

    hrTmp = GetObjectPropsCached( pIADsParent.get(),
                                  pObject,
                                  pParentInfoRequest->cProps,
                                  pParentInfoRequest->pPropIDs,
                                  pParentInfoRequest->pPropVars );
    return LogHR(hrTmp, s_FN, 1040);

}

HRESULT CAdsi::CreateIDirectoryObject(
            IN CBasicObjectType*    pObject,
            IN LPCWSTR				pwcsObjectClass,	
            IN IDirectoryObject *	pDirObj,
			IN LPCWSTR				pwcsFullChildPath,
            IN const DWORD			cPropIDs,
            IN const PROPID *		pPropIDs,
            IN const MQPROPVARIANT * pPropVar,
			IN const AD_OBJECT		eObject,
            OUT IDispatch **		pDisp
			)
/*++
    Abstract:
	Creates an object in AD

    Parameters:

    Returns:

--*/
{
    HRESULT hr;

    R<IADsObjectOptions> pObjOptions = NULL ;

    //
    // Translate MQPROPVARIANT properties to ADSTYPE attributes
    //

    DWORD cAdsAttrs = 0;
	P<BYTE> pSD = NULL ;
	DWORD dwSDSize = 0 ;
	DWORD dwSDIndex = 0;
    AP<ADS_ATTR_INFO> AttrInfo = new ADS_ATTR_INFO[cPropIDs + 1];
	PVP<PADSVALUE> pAdsVals = (PADSVALUE *)PvAlloc( sizeof(PADSVALUE) * (cPropIDs + 1));

    //
    // The first attribute is the "objectClass"
    //
	pAdsVals[cAdsAttrs] = (ADSVALUE *)PvAllocMore( sizeof(ADSVALUE), pAdsVals);
    pAdsVals[cAdsAttrs]->dwType = ADSTYPE_CASE_IGNORE_STRING ;
    pAdsVals[cAdsAttrs]->CaseIgnoreString = const_cast<LPWSTR>(pwcsObjectClass) ;

    AttrInfo[cAdsAttrs].pszAttrName   = L"objectClass" ;
    AttrInfo[cAdsAttrs].dwControlCode = ADS_ATTR_UPDATE ;
    AttrInfo[cAdsAttrs].dwADsType     = ADSTYPE_CASE_IGNORE_STRING ;
    AttrInfo[cAdsAttrs].pADsValues    = pAdsVals[cAdsAttrs];
    AttrInfo[cAdsAttrs].dwNumValues   = 1;

    cAdsAttrs++;

    for (DWORD i = 0; i < cPropIDs; i++)
	{
        DWORD dwNumValues = 0;
		//
		//	Ignore the computer SID property when creating object.
		//	This is just a hack to pass in computer sid for SD translation
		//
		if ( pPropIDs[i] == PROPID_COM_SID)
		{
			continue;
		}
		//
		// Get property info
		//	
		const translateProp *pTranslate;
		if(!g_PropDictionary.Lookup(pPropIDs[i], pTranslate))
		{
			ASSERT(0);
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1080);
		}

		PROPID	propidToCreate = pPropIDs[i];
		const PROPVARIANT *	pvarToCrate = &pPropVar[i];
		CMQVariant propvarToCreate;
	
		if (pTranslate->vtDS == ADSTYPE_INVALID)
		{	
			//
			//	The property is not kept in the DS as is. If it has a set routine,
			//	use it to get the new property & value for create.
			//
			if ( pTranslate->CreatePropertyHandle == NULL)
			{
				continue;
			}
			hr = pTranslate->CreatePropertyHandle(
									&pPropVar[i],
                                    pObject->GetDomainController(),
			                        pObject->IsServerName(),
									&propidToCreate,
									propvarToCreate.CastToStruct()
									);
			if (FAILED(hr))
			{
                 return LogHR(hr, s_FN, 1090);
			}
			ASSERT( propidToCreate != 0);
			pvarToCrate = propvarToCreate.CastToStruct();
			//
			//	Get replaced property info
			//
			if ( !g_PropDictionary.Lookup( propidToCreate, pTranslate))
			{
				ASSERT(0);
                return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1100);
			}
								
		}
		if ( pTranslate->vtDS == ADSTYPE_NT_SECURITY_DESCRIPTOR )
		{	
            pAdsVals[cAdsAttrs] = (ADSVALUE *)PvAllocMore( sizeof(ADSVALUE), pAdsVals);
            pAdsVals[cAdsAttrs]->dwType = pTranslate->vtDS;

			PSID pComputerSid = NULL;

			for ( DWORD j = 0; j < cPropIDs; j++)
			{
				if ( pPropIDs[j] == PROPID_COM_SID)
				{
					pComputerSid = (PSID) pPropVar[j].blob.pBlobData;
					ASSERT(IsValidSid(pComputerSid));
					break;
				}
			}

			SECURITY_INFORMATION seInfo =  MQSEC_SD_ALL_INFO;

            if ( eObject == eMQUSER)
            {
                //
                // For the migrated user, we provide only the dacl.
                // we let DS to add the other components.
                //
			    seInfo =  DACL_SECURITY_INFORMATION ;
            }
            else
            {
    			//
	    		//	If the caller did not explicitely specify SACL info
                //	don't try to set it
			    //
                PACL  pAcl = NULL ;
                BOOL  bPresent = FALSE ;
                BOOL  bDefaulted ;

                BOOL bRet = GetSecurityDescriptorSacl(
                         (SECURITY_DESCRIPTOR*)pvarToCrate->blob.pBlobData,
                                                  &bPresent,
                                                  &pAcl,
                                                  &bDefaulted );
                DBG_USED(bRet);
                ASSERT(bRet);

                if (!bPresent)
                {
			    	seInfo &= ~SACL_SECURITY_INFORMATION ; // turn off.
    			}
			}

            //
			// Get IADsObjectOptions interface pointer and
		    // set ObjectOption, specifying the SECURITY_INFORMATION we want to set.
		    //
			hr = pDirObj->QueryInterface (IID_IADsObjectOptions,(LPVOID *) &pObjOptions);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 250);
            }
	
			VARIANT var ;
			var.vt = VT_I4 ;
			var.ulVal = (ULONG) seInfo ;
	
			hr = pObjOptions->SetOption( ADS_OPTION_SECURITY_MASK, var ) ;
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 260);
            }
	
			//
			// Convert security descriptor to NT5 format.
			//
			BYTE   *pBlob = pvarToCrate->blob.pBlobData;
			DWORD   dwSize = pvarToCrate->blob.cbSize;
	
			hr = MQSec_ConvertSDToNT5Format( pObject->GetMsmq1ObjType(),
										     (SECURITY_DESCRIPTOR*)pBlob,
										     &dwSDSize,
										     (SECURITY_DESCRIPTOR **)&pSD,
                                             e_MakeDaclNonDefaulted,
											 pComputerSid ) ;
			if (FAILED(hr))
			{
                return LogHR(hr, s_FN, 1110);
			}
			else if (hr != MQSec_I_SD_CONV_NOT_NEEDED)
			{
				pBlob = pSD ;
				dwSize = dwSDSize ;
			}
			else
			{
				ASSERT(pSD == NULL) ;
			}

			if (pSD && !IsValidSecurityDescriptor(pSD))
			{
                return LogHR(MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR, s_FN, 1120);
			}
			//
			// Set property
			//
            dwNumValues = 1 ;
			pAdsVals[cAdsAttrs]->SecurityDescriptor.dwLength = dwSize ;
			pAdsVals[cAdsAttrs]->SecurityDescriptor.lpValue  = pBlob ;
			dwSDIndex = cAdsAttrs;
		}
        else
        {
			if ( ( pvarToCrate->vt & VT_VECTOR && pvarToCrate->cauuid.cElems == 0) || // counted array with 0 elements
				 ( pvarToCrate->vt == VT_BLOB && pvarToCrate->blob.cbSize == 0) || // an empty blob
				 ( pvarToCrate->vt == VT_LPWSTR && wcslen( pvarToCrate->pwszVal) == 0) || // an empty string
                 ( pvarToCrate->vt == VT_EMPTY ))   // an empty variant
			{
				//
				//  ADSI doesn't allow to create an object while specifing
				//  some of its attributes as not-available. Therefore on
				//  create we ignore the "empty" properties
				//
				continue;	
			}
            hr = MqVal2AdsiVal( pTranslate->vtDS,
					            &dwNumValues,
								&pAdsVals[cAdsAttrs],
								pvarToCrate,
                                pAdsVals);
            if (FAILED(hr))
			{
                return LogHR(hr, s_FN, 1130);
			}
        }

		ASSERT(dwNumValues > 0) ;
		AttrInfo[cAdsAttrs].pszAttrName   = const_cast<LPWSTR>(pTranslate->wcsPropid) ;
		AttrInfo[cAdsAttrs].dwControlCode = ADS_ATTR_UPDATE ;
		AttrInfo[cAdsAttrs].dwADsType     = pAdsVals[cAdsAttrs]->dwType ;
		AttrInfo[cAdsAttrs].pADsValues    = pAdsVals[cAdsAttrs] ;
		AttrInfo[cAdsAttrs].dwNumValues   = dwNumValues ;

		cAdsAttrs++ ;
	}

    //
    // Create the object.
    //

    HRESULT hr2 = pDirObj->CreateDSObject(
						const_cast<WCHAR *>(pwcsFullChildPath),
                        AttrInfo,
                        cAdsAttrs,
                        pDisp
						);
    LogTraceQuery(const_cast<WCHAR *>(pwcsFullChildPath), s_FN, 1139);
    return LogHR(hr2, s_FN, 1140);
}

HRESULT CAdsi::CreateObject(
            IN AD_PROVIDER      eProvider,		   
            IN CBasicObjectType* pObject,
            IN LPCWSTR          pwcsChildName,    
            IN LPCWSTR          pwsParentPathName, 
            IN DWORD            cPropIDs,                
            IN const PROPID          *pPropIDs,       
            IN const MQPROPVARIANT   *pPropVars,         
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,    // optional request for object info
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest) // optional request for parent info
/*++
    Abstract:

    Parameters:

    Returns:

--*/
{
    HRESULT             hr;
    ASSERT( eProvider != adpGlobalCatalog);
    //
    //  Add LDAP:// prefix to the parent name
    //
    DWORD len = wcslen(pwsParentPathName);

    DWORD lenDC = ( pObject->GetDomainController() != NULL) ? wcslen(pObject->GetDomainController()) : 0;


    AP<WCHAR> pwcsFullParentPath = new WCHAR [  len + lenDC + x_providerPrefixLength + 2];

    switch (eProvider)
    {
    case adpDomainController:
        if (pObject->GetDomainController() != NULL)
        {
            //
            // Add the known GC name to path.
            //
            swprintf( pwcsFullParentPath,
                      L"%s%s/",
                      x_LdapProvider,
                      pObject->GetDomainController() );
        }
        else
        {
            wcscpy(pwcsFullParentPath, x_LdapProvider);
        }
        break;

    default:
        ASSERT(0);
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1150);
    }

    wcscat(pwcsFullParentPath, pwsParentPathName);

    //
    //  Add CN= to the child name
    //
    len = wcslen(pwcsChildName);
    AP<WCHAR> pwcsFullChildPath = new WCHAR[ len + x_CnPrefixLen + 1];

    swprintf(
        pwcsFullChildPath,
        L"CN=%s",
        pwcsChildName
        );

	//
    // First, we must bind to the parent container
	//
	R<IDirectoryObject> pParentDirObj = NULL;

	DWORD Flags = ADS_SECURE_AUTHENTICATION;
    if (pObject->IsServerName() && (pObject->GetDomainController() != NULL))
	{
		Flags |= ADS_SERVER_BIND;
	}
    hr = ADsOpenObject(
                pwcsFullParentPath,
                NULL,
                NULL,
                Flags,
                IID_IDirectoryObject,
                (void**) &pParentDirObj
				);

    LogTraceQuery(pwcsFullParentPath, s_FN, 269);
    if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE))
    {
        //
        //  Most likely that this indicates that access is denied.
        //  LDAP doesn't return an access denied error in order not
        //  to have a security breach since the caller doesn't have
        //  permission to know that this attribute even exists.
        //
		TrERROR(mqad, "ADsOpenObject failed with ERROR_DS_NO_ATTRIBUTE_OR_VALUE");
        hr = HRESULT_FROM_WIN32(MQ_ERROR_ACCESS_DENIED);
    }

    if (FAILED(hr))
    {
		TrERROR(mqad, "ADsOpenObject failed, hr = 0x%x, AdsPath = %ls, Flags = 0x%x", hr, pwcsFullParentPath, Flags);
        return LogHR(hr, s_FN, 270);
    }

    R<IADsContainer>  pContainer  = NULL;
	hr = pParentDirObj->QueryInterface( IID_IADsContainer, (LPVOID *) &pContainer);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 280);
    }
	//
    // Now we may create a child object
	//
    R<IDispatch> pDisp = NULL;
	hr = CreateIDirectoryObject(
                 pObject,
				 pObject->GetClass(),
				 pParentDirObj.get(),
				 pwcsFullChildPath,
				 cPropIDs,
                 pPropIDs,
                 pPropVars,
				 pObject->GetObjectType(),
				 &pDisp.ref());

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 290);
    }

    R<IADs> pChild  = NULL;


    if (pObjInfoRequest || pParentInfoRequest)
    {
        hr = pDisp->QueryInterface (IID_IADs,(LPVOID *) &pChild);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 300);
        }
    }

    //
    // get object info if requested. don't fail if the request fails,
    // just mark the failure in the request's status
    //
    if (pObjInfoRequest)
    {
        pObjInfoRequest->hrStatus =
            GetObjectPropsCached(pChild.get(),
                                 pObject,
                                 pObjInfoRequest->cProps,
                                 pObjInfoRequest->pPropIDs,
                                 pObjInfoRequest->pPropVars
                                 );
    }

    //
    // get parent info if requested. don't fail if the request fails,
    // just mark the failure in the request's status
    //
    if (pParentInfoRequest)
    {
        pParentInfoRequest->hrStatus = GetParentInfo( 
                                                      pObject,
                                                      pwcsFullParentPath,
                                                      pContainer.get(),
                                                      pParentInfoRequest
                                                     );
    }

    return MQ_OK;
}


HRESULT CAdsi::DeleteObject(
        IN AD_PROVIDER      eProvider,		
        IN CBasicObjectType* pObject,
        IN LPCWSTR          pwcsPathName,      // object name
        IN const GUID *		pguidUniqueId,      // unique id of object
        IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,    // optional request for object info
        IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest) // optional request for parent info
/*++
    Abstract:

    Parameters:

    Returns:

--*/
{
    HRESULT               hr;
    BSTR                  bs;
    R<IADs>               pIADs       = NULL;
    R<IADsContainer>      pContainer  = NULL;
    ASSERT( eProvider != adpGlobalCatalog);
    const WCHAR *   pPath =  pwcsPathName;

    AP<WCHAR> pwcsFullPath;
    if ( pguidUniqueId != NULL)
    {
        //
        //  GetParent of object bound according to GUID doesn't work
        //  That is why we translate it to pathname
        //
        AD_PROVIDER prov;
        hr = FindObjectFullNameFromGuid(
					eProvider,		// local DC or GC
					pObject->GetADContext(),    
					pObject->GetDomainController(),
					pObject->IsServerName(),
					pguidUniqueId,
					1,              // fTryGCToo
					&pwcsFullPath,
					&prov
					);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 1180);
        }
        pPath = pwcsFullPath;
    }


    // Bind to the object either by GUID or by name

    hr = BindToObject(
            eProvider,
            pObject->GetADContext(),
            pObject->GetDomainController(),
            pObject->IsServerName(),
            pPath,
            NULL,
            IID_IADs,
            (VOID *)&pIADs
            );
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 1190);
        return( MQDS_OBJECT_NOT_FOUND);
    }

    //
    // get object info if requested. don't fail if the request fails,
    // just mark the failure in the request's status
    //
    if (pObjInfoRequest)
    {
        pObjInfoRequest->hrStatus =
            GetObjectPropsCached(pIADs.get(),
                                 pObject,
                                 pObjInfoRequest->cProps,
                                 pObjInfoRequest->pPropIDs,
                                 pObjInfoRequest->pPropVars
                                 );
    }

    // Get parent ADSPath

    hr = pIADs->get_Parent(&bs);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 360);
    }
    BS  bstrParentADsPath(bs);
    SysFreeString(bs);

    // Get the container object.

    hr = ADsOpenObject( 
				bstrParentADsPath,
				NULL,
				NULL,
				ADS_SECURE_AUTHENTICATION,
				IID_IADsContainer,
				(void**)&pContainer
				);
    LogTraceQuery(bstrParentADsPath, s_FN, 369);
    if (FAILED(hr))
    {
		TrERROR(mqad, "ADsOpenObject failed, hr = 0x%x, AdsPath = %ls", hr, bstrParentADsPath);
        return LogHR(hr, s_FN, 370);
    }

    // Get the object relative name in container

    hr = pIADs->get_Name(&bs);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 380);
    }
    BS  bstrRDN(bs);
    SysFreeString(bs);

    // Get the object schema class

    hr = pIADs->get_Class(&bs);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 390);
    }
    BS  bstrClass(bs);
    SysFreeString(bs);


    // Release the object itself
    // NB: important to do it before deleting the underlying DS object
    IADs *pIADs1 = pIADs.detach();
    pIADs1->Release();

    // Finally, delete the object.

    hr = pContainer->Delete(bstrClass, bstrRDN);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 400);
    }

    //
    // get parent info if requested. don't fail if the request fails,
    // just mark the failure in the request's status
    //
    if (pParentInfoRequest)
    {
        pParentInfoRequest->hrStatus = GetParentInfo( 
                                                      pObject,
                                                      bstrParentADsPath,
                                                      pContainer.get(),
                                                      pParentInfoRequest
                                                      );
    }

    return MQ_OK;
}

HRESULT CAdsi::DeleteContainerObjects(
            IN AD_PROVIDER      eProvider,
            IN DS_CONTEXT       eContext,
            IN LPCWSTR          pwcsDomainController,
            IN bool             fServerName,
            IN LPCWSTR          pwcsContainerName,
            IN const GUID *     pguidContainerId,
            IN LPCWSTR          pwcsObjectClass)
/*++
    Abstract:
	Deletes all the objects of the specified class from a container

    Parameters:

    Returns:

--*/
{
    HRESULT               hr;
    R<IADsContainer>      pContainer  = NULL;
    ASSERT( eProvider != adpGlobalCatalog);
    //
    // Get container interface
    //
    const WCHAR * pwcsContainer = pwcsContainerName;
    AP<WCHAR> pCleanContainer;

    if ( pguidContainerId != NULL)
    {
        ASSERT(pwcsContainerName == NULL);

        //
        // BUGBUG - this is a workaround to ADSI problem
        //          when a container is bounded according 
        //          to its id, get_parent() failes
        //
        AD_PROVIDER prov;

        hr = FindObjectFullNameFromGuid(
				eProvider,	
				eContext,    
				pwcsDomainController,
				fServerName,
				pguidContainerId,
				1,              // fTryGCToo
				&pCleanContainer,
				&prov
				);
         if (FAILED(hr))
         {
             return hr;
         }
         pwcsContainer = pCleanContainer.get();

    }

    hr = BindToObject(
            eProvider,
            eContext,
            pwcsDomainController,
            fServerName,
            pwcsContainer,
            NULL,   //pguidContainerId,
            IID_IADsContainer,
            (void**)&pContainer
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 410);
    }
    //
    //  Bind to IDirectorySearch interface of the requested container
    //
    R<IDirectorySearch> pDSSearch = NULL;
    ADS_SEARCH_HANDLE   hSearch;

    hr = BindToObject(
            eProvider,
            eContext,
            pwcsDomainController,
            fServerName,
            pwcsContainerName,
            pguidContainerId,
            IID_IDirectorySearch,
            (VOID *)&pDSSearch
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 420);
    }
    ADSVALUE adsv1;
    adsv1.dwType  = ADSTYPE_BOOLEAN;
    adsv1.Boolean = FALSE;

    ADS_SEARCHPREF_INFO pref;
    pref.dwSearchPref   = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
    pref.dwStatus       = ADS_STATUS_S_OK;
    CopyMemory(&pref.vValue, &adsv1, sizeof(ADSVALUE));

    hr = pDSSearch->SetSearchPreference(&pref, 1);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 430);
    }

    //
    //  Search for all the objects of the requested class
    //
    WCHAR pwszSearchFilter[200];

    swprintf(
         pwszSearchFilter,
         L"%s%s%s",
         x_ObjectClassPrefix,
         pwcsObjectClass,
         x_ObjectClassSuffix
         );
    LPWSTR pwcsAttribute =  const_cast<WCHAR*>(x_AttrCN);
    hr = pDSSearch->ExecuteSearch(
            pwszSearchFilter,
            &pwcsAttribute,
            1,
            &hSearch);
    LogTraceQuery(pwszSearchFilter, s_FN, 439);
    if (FAILED(hr))
    {
		TrERROR(mqad, "failed to ExecuteSearch, hr = 0x%x, pwcsSearchFilter = %ls", hr, pwszSearchFilter);
        return LogHR(hr, s_FN, 440);
    }

    CAutoCloseSearchHandle cCloseSearchHandle(pDSSearch.get(), hSearch);

    BS bstrClass(pwcsObjectClass);

    while ( SUCCEEDED(hr = pDSSearch->GetNextRow( hSearch))
          && ( hr != S_ADS_NOMORE_ROWS))
    {

        ADS_SEARCH_COLUMN Column;
        //
        // Ask for the column itself
        //
        hr = pDSSearch->GetColumn(
                     hSearch,
                     const_cast<WCHAR *>(x_AttrCN),
                     &Column);

        if (FAILED(hr))       //e.g.E_ADS_COLUMN_NOT_SET
        {
            //
            //  continue with deleting other objects in the container
            //
            continue;
        }

        CAutoReleaseColumn CleanColumn( pDSSearch.get(), &Column);

        DWORD dwNameLen = wcslen( Column.pADsValues->DNString);
        DWORD len = dwNameLen*2 + x_CnPrefixLen + 1;
        AP<WCHAR> pwcsRDN = new WCHAR[ len];

        wcscpy(pwcsRDN, x_CnPrefix);
        FilterSpecialCharacters(Column.pADsValues->DNString, dwNameLen, pwcsRDN + x_CnPrefixLen);

        BS bstrRDN( pwcsRDN);
        //
        //  delete the object
        //
        hr = pContainer->Delete(bstrClass, bstrRDN);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 450);
        }

    }
    return LogHR(hr, s_FN, 1200);
}



HRESULT CAdsi::GetParentName(
            IN  AD_PROVIDER     eProvider,		    // local DC or GC
            IN  DS_CONTEXT      eContext,
            IN  LPCWSTR         pwcsDomainController,
            IN  bool            fServerName,
            IN  const GUID *    pguidUniqueId,      // unique id of object
            OUT LPWSTR *        ppwcsParentName
            )
/*++
    Abstract:
	Retrieve the parent name of the object ( specified by its guid)

    Parameters:

    Returns:

--*/
{
    *ppwcsParentName = NULL;

    HRESULT               hr;
    BSTR                  bs;
    R<IADs>               pIADs       = NULL;
    R<IADsContainer>      pContainer  = NULL;

    // Bind to the object by GUID

    hr = BindToObject(
            eProvider,
            eContext,
            pwcsDomainController,
            fServerName,
            NULL,
            pguidUniqueId,
            IID_IADs,
            (VOID *)&pIADs
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 460);
    }

    // Get parent ADSPath

    hr = pIADs->get_Parent(&bs);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 470);
    }
    PBSTR pClean( &bs);
    //
    //  Calculate the parent name length, allocate and copy
    //  without the LDAP:/ prefix
    //
    WCHAR * pwcs = bs;
    while ( *pwcs != L'/')
    {
        pwcs++;
    }
    pwcs += 2;

    DWORD len = lstrlen(pwcs);
    *ppwcsParentName = new WCHAR[ len + 1];
    wcscpy( *ppwcsParentName, pwcs);

    return( MQ_OK);
}

HRESULT CAdsi::GetParentName(
            IN  AD_PROVIDER     eProvider,		     // local DC or GC
            IN  DS_CONTEXT      eContext,
            IN  LPCWSTR         pwcsDomainController,
            IN  bool            fServerName,
            IN  LPCWSTR         pwcsChildName,       //
            OUT LPWSTR *        ppwcsParentName
            )
/*++
    Abstract:
	Retrieve the parent name of an object specified by its name

    Parameters:

    Returns:

--*/
{
    *ppwcsParentName = NULL;

    HRESULT               hr;
    BSTR                  bs;
    R<IADs>               pIADs       = NULL;
    R<IADsContainer>      pContainer  = NULL;

    // Bind to the object by GUID

    hr = BindToObject(
            eProvider,
            eContext,
            pwcsDomainController,
            fServerName,
            pwcsChildName,
            NULL,
            IID_IADs,
            (VOID *)&pIADs
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 480);
    }

    // Get parent ADSPath

    hr = pIADs->get_Parent(&bs);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 490);
    }
    PBSTR pClean( &bs);
    //
    //  Calculate the parent name length, allocate and copy
    //  without the LDAP:/ prefix
    //
    WCHAR * pwcs = bs;
    while ( *pwcs != L'/')
    {
        pwcs++;
    }
    pwcs += 2;

    DWORD len = lstrlen(pwcs);
    *ppwcsParentName = new WCHAR[ len + 1];
    wcscpy( *ppwcsParentName, pwcs);

    return( MQ_OK);
}

HRESULT CAdsi::BindRootOfForest(
                        OUT void           *ppIUnk)
/*++
    Abstract:

    Parameters:

    Returns:

--*/
{
    HRESULT hr;
    R<IADsContainer> pDSConainer = NULL;

	hr = ADsOpenObject(
            const_cast<WCHAR *>(x_GcRoot),
			NULL,
			NULL,
			ADS_SECURE_AUTHENTICATION, 
            IID_IADsContainer,
            (void**)&pDSConainer
			);

    LogTraceQuery(const_cast<WCHAR *>(x_GcRoot), s_FN, 1209);
    if FAILED((hr))
    {
        TrERROR(mqad, "failed to get object 0x%x", hr);
        return LogHR(hr, s_FN, 1210);
    }
    R<IUnknown> pUnk = NULL;
    hr =  pDSConainer->get__NewEnum(
            (IUnknown **)&pUnk);
    if FAILED((hr))
    {
        TrERROR(mqad, "failed to get enum 0x%x", hr);
        return LogHR(hr, s_FN, 1220);
    }

    R<IEnumVARIANT> pEnumerator = NULL;
    hr = pUnk->QueryInterface(
                    IID_IEnumVARIANT,
                    (void **)&pEnumerator);

    CAutoVariant varOneElement;
    ULONG cElementsFetched;
    hr =  ADsEnumerateNext(
            pEnumerator.get(),  //Enumerator object
            1,             //Number of elements requested
            &varOneElement,           //Array of values fetched
            &cElementsFetched  //Number of elements fetched
            );
    if (FAILED(hr))
    {
        TrERROR(mqad, "failed to enumerate next 0x%x", hr);
        return LogHR(hr, s_FN, 1230);
    }
    if ( cElementsFetched == 0)
    {
		TrERROR(mqad, "Failed binding root of forest");
        return LogHR(MQ_ERROR_DS_BIND_ROOT_FOREST, s_FN, 1240);
    }

    hr = ((VARIANT &)varOneElement).punkVal->QueryInterface(
            IID_IDirectorySearch,
            (void**)ppIUnk);

    return LogHR(hr, s_FN, 1250);

}
HRESULT CAdsi::BindToObject(
            IN AD_PROVIDER      eProvider,		    
            IN DS_CONTEXT       eContext,    
            IN LPCWSTR          pwcsDomainController,
            IN bool             fServerName,
            IN LPCWSTR          pwcsPathName,
            IN const GUID*      pguidUniqueId,
            IN REFIID           riid,     
            OUT void*           ppIUnk
            )
/*++

Routine Description:
    The routine binds to an object, either by name or by GUID.

Arguments:

Return Value:
--*/

{
    //
    //  Validating that caller provided exactly one specifier of the object
    //
    if (pguidUniqueId == NULL && pwcsPathName == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1260);
    }

    BOOL fBindRootOfForestForSearch = FALSE;

    HRESULT hr;
    if (pguidUniqueId != NULL)
    {
        hr = BindToGUID(
                eProvider,
                eContext,
                pwcsDomainController,
				fServerName,
                pguidUniqueId,
                riid,
                ppIUnk
                );

        return LogHR(hr, s_FN, 1270);
    }

    ASSERT(pwcsPathName != NULL);

	DWORD lenServer = (pwcsDomainController != NULL) ? wcslen(pwcsDomainController) : 0;
    const WCHAR * pwcsProvider;
    switch (eProvider)
    {
        case adpDomainController:
			pwcsProvider = x_LdapProvider;
			break;

        case adpGlobalCatalog:
            pwcsProvider = x_GcProvider;

            if (riid ==  IID_IDirectorySearch)
            {
                fBindRootOfForestForSearch = TRUE;
                //
                // Query against GC is performed only when application
                // locates queues, and there it cannot specify the server name.
                //
                ASSERT(pwcsDomainController == NULL);
            }

			//
			// For GC always use serverless binding.
			// this server may not be a GC (it surely Ldap). 
			// using server binding with this server will fail in case this server is not GC
			//
			lenServer = 0;

            break;

        default:
            ASSERT(0);
            return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1300);
            break;
    }

    if (fBindRootOfForestForSearch)
    {
        hr = BindRootOfForest((void**)ppIUnk);
	    return LogHR(hr, s_FN, 1315);
    }

	DWORD len = wcslen(pwcsPathName);

	//
	//  Add provider prefix
	//
	AP<WCHAR> pwdsADsPath = new
		WCHAR [len + lenServer + x_providerPrefixLength + 3];

	if (lenServer != 0)
	{
		swprintf(
			pwdsADsPath,
			L"%s%s/%s",
			pwcsProvider,
			pwcsDomainController,
			pwcsPathName
			);
	}
	else
	{
		swprintf(
			pwdsADsPath,
			L"%s%s",
			pwcsProvider,
			pwcsPathName
			);
	}

	DWORD Flags = ADS_SECURE_AUTHENTICATION;
	if(fServerName && (lenServer != 0))
	{
		Flags |= ADS_SERVER_BIND;
	}

	hr = ADsOpenObject(
			pwdsADsPath,
			NULL,
			NULL,
			Flags, 
			riid,
			(void**)ppIUnk
			);

    LogTraceQuery(pwdsADsPath, s_FN, 1319);

    if (FAILED(hr))
    {
		TrERROR(mqad, "ADsOpenObject failed, hr = 0x%x, AdsPath = %ls, Flags = 0x%x", hr, pwdsADsPath, Flags);
    }

    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE))
    {
        //
        //  Most likely that this indicates that access is denied.
        //  LDAP doesn't return an access denied error in order not
        //  to have a security breach since the caller doesn't have
        //  permission to know that this attribute even exists.
        //
        //  The best that we can do is to return an object not found error
        //
        hr = HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT);
    }
    return LogHR(hr, s_FN, 1320);

}


HRESULT CAdsi::BindToGUID(
        IN AD_PROVIDER         eProvider,	
        IN DS_CONTEXT          /* eContext*/,
        IN LPCWSTR             pwcsDomainController,
        IN bool				   fServerName,
        IN const GUID *        pguidObjectId,
        IN REFIID              riid,       
        OUT VOID*              ppIUnk
        )
/*++

Routine Description:
    This routine handles bind to an object according to its guid.

Arguments:

Return Value:
--*/
{
    HRESULT             hr;
    //
    // bind to object by GUID using the GUID format
    //
    // BUGBUG : is there isuue with NT4 clients, when binding
    //          without specifying server name ???
    //

    DWORD lenDC = (pwcsDomainController != NULL) ? wcslen(pwcsDomainController) : 0;
    const WCHAR * pwcsProvider;

    switch (eProvider)
    {
        case adpGlobalCatalog:
            pwcsProvider = x_GcProvider;

			//
			// For GC always use serverless binding.
			// this server may not be a GC (it surely Ldap). 
			// using server binding with this server will fail in case this server is not GC
			//
			lenDC = 0;
            break;

        case adpDomainController:
           pwcsProvider =  x_LdapProvider;
            break;

        default:
            ASSERT(0);
            return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1360);
            break;
    }

    //
    //  prepare the ADS string provider prefix
    //
    AP<WCHAR> pwdsADsPath = new
      WCHAR [STRLEN(x_GuidPrefix) +(2 * sizeof(GUID)) + lenDC + x_providerPrefixLength + 4];

    if (lenDC != 0)
    {
        swprintf(
        pwdsADsPath,
        L"%s%s/",
        pwcsProvider,
        pwcsDomainController
        );
    }
    else
    {
        wcscpy(pwdsADsPath, pwcsProvider);
    }

    //
    //  prepare the guid string
    //
    WCHAR wcsGuid[1 + STRLEN(x_GuidPrefix) + 2 * sizeof(GUID) + 1];
    unsigned char * pTmp = (unsigned char *)pguidObjectId;
    wsprintf(  wcsGuid,
               L"%s%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%s",
               x_GuidPrefix,
               pTmp[0], pTmp[1], pTmp[2], pTmp[3], pTmp[4], pTmp[5], pTmp[6], pTmp[7],
               pTmp[8], pTmp[9], pTmp[10], pTmp[11], pTmp[12], pTmp[13], pTmp[14], pTmp[15],
               L">"
                );
    ASSERT(wcslen(wcsGuid) + 1 <= ARRAY_SIZE(wcsGuid));
    wcscat( pwdsADsPath, wcsGuid);

	DWORD Flags = ADS_SECURE_AUTHENTICATION;
	if(fServerName && (lenDC != 0))
	{
		Flags |= ADS_SERVER_BIND;
	}

	hr = ADsOpenObject(
			pwdsADsPath,
			NULL,
			NULL,
			Flags, 
			riid,
			(void**)ppIUnk
			);

    LogTraceQuery(pwdsADsPath, s_FN, 1379);

    if (FAILED(hr))
    {
		TrERROR(mqad, "ADsOpenObject failed, hr = 0x%x, AdsPath = %ls, Flags = 0x%x", hr, pwdsADsPath, Flags);
    }

    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE))
    {
        //
        //  Most likely that this indicates that access is denied.
        //  LDAP doesn't return an access denied error in order not
        //  to have a security breach since the caller doesn't have
        //  permission to know that this attribute even exists.
        //
        //  The best that we can do is to return an object not found error
        //
        hr = HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT);
    }

    return LogHR(hr, s_FN, 1380);
}



HRESULT CAdsi::BindForSearch(
        IN AD_PROVIDER         eProvider,		// local DC or GC
        IN DS_CONTEXT          eContext,         // DS context
        IN  LPCWSTR            pwcsDomainController,
        IN bool				   fServerName,
        IN const GUID *        pguidUniqueId,
        IN BOOL                /* fSorting*/,
        OUT VOID *             ppIUnk
        )
/*++

Routine Description:
    This routine handles bind when the requested interface is IDirectorySearch

Arguments:

Return Value:
--*/

{
    HRESULT hr;

    //
    //  If the search starts at a specific object, bind to it
    //
    if (pguidUniqueId != NULL)
    {
        hr = BindToGUID(
                    eProvider,
                    eContext,
                    pwcsDomainController,
				    fServerName,
                    pguidUniqueId,
                    IID_IDirectorySearch,
                    ppIUnk
                    );

        return LogHR(hr, s_FN, 1390);
    }
    ASSERT( pguidUniqueId == NULL);

    DWORD lenDC = (pwcsDomainController != NULL) ? wcslen(pwcsDomainController) : 0;

	AP<WCHAR> pwcsLocalDsRootToFree;
	LPWSTR pwcsLocalDsRoot = g_pwcsLocalDsRoot;
	if((eProvider == adpDomainController) && (eContext == e_RootDSE))
	{
		//
		// In this case (adpDomainController, e_RootDSE) we need to get
		// the correct LocalDsRoot.
		//
		hr = g_AD.GetLocalDsRoot(
					pwcsDomainController, 
					fServerName,
					&pwcsLocalDsRoot,
					pwcsLocalDsRootToFree
					);

		if(FAILED(hr))
		{
			TrERROR(mqad, "Failed to get Local Ds Root, hr = 0x%x", hr);
			return LogHR(hr, s_FN, 1410);
		}
	}

    DWORD len = wcslen(pwcsLocalDsRoot) + wcslen(g_pwcsMsmqServiceContainer);

    //
    //  Add provider prefix
    //
    WCHAR * pwcsFullPathName = NULL;
    BOOL fBindRootOfForestForSearch = FALSE;

    AP<WCHAR> pwdsADsPath = new
      WCHAR [ (2 * len) + lenDC + x_providerPrefixLength + 2];

    switch(eProvider)
    {
		case adpGlobalCatalog:

			fBindRootOfForestForSearch = TRUE;
			break;

		case adpDomainController:
		{
			//
			//  The contaner name is resolved according to the context
			//
			switch (eContext)
			{
				case e_RootDSE:
					pwcsFullPathName = pwcsLocalDsRoot;
					break;
				case e_ConfigurationContainer:
					pwcsFullPathName = g_pwcsConfigurationContainer;
					break;
				case e_SitesContainer:
					pwcsFullPathName = g_pwcsSitesContainer;
					break;
				case e_MsmqServiceContainer:
					pwcsFullPathName = g_pwcsMsmqServiceContainer;
					break;
				case e_ServicesContainer:
					pwcsFullPathName = g_pwcsServicesContainer;
					break;
				default:
					ASSERT(0);
					break;
			}
			if (pwcsDomainController != NULL)
			{
				swprintf(
					pwdsADsPath,
					 L"%s%s/",
					x_LdapProvider,
					pwcsDomainController
					);
			}
			else
			{
				wcscpy(pwdsADsPath, x_LdapProvider);
			}
			}
			break;  

		default:
			ASSERT(0);
			return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1400);
			break;
    }

    if (fBindRootOfForestForSearch)
    {
        hr = BindRootOfForest( (void**)ppIUnk );
    }
    else
    {
        if (pwcsFullPathName != NULL)
        {
            wcscat(pwdsADsPath,pwcsFullPathName);
        }

		DWORD Flags = ADS_SECURE_AUTHENTICATION;
		if(fServerName && (pwcsDomainController != NULL))
		{
			Flags |= ADS_SERVER_BIND;
		}

		hr = ADsOpenObject(
					pwdsADsPath,
					NULL,
					NULL,
					Flags, 
					IID_IDirectorySearch,
					(void**)ppIUnk
					);

        LogTraceQuery(pwdsADsPath, s_FN, 1419);
		if (FAILED(hr))
		{
			TrERROR(mqad, "ADsOpenObject failed, hr = 0x%x, AdsPath = %ls, Flags = 0x%x", hr, pwdsADsPath, Flags);
		}
    }
    return LogHR(hr, s_FN, 1420);
}


HRESULT CAdsi::SetObjectPropsCached(
        IN LPCWSTR               pwcsDomainController,
        IN  bool				 fServerName,
        IN IADs *                pIADs,                  // object's pointer
        IN DWORD                 cPropIDs,               // number of attributes
        IN const PROPID *        pPropIDs,               // name of attributes
        IN const MQPROPVARIANT * pPropVars)              // attribute values
/*++
    Abstract:
	Sets properties of and opened IADs object (i.e. in cache)

    Parameters:

    Returns:

--*/
{
    HRESULT           hr;

    for (DWORD i = 0; i<cPropIDs; i++)
    {
        VARIANT vProp;

        //
        // Get property info
        //
        const translateProp *pTranslate;
        if(!g_PropDictionary.Lookup(pPropIDs[i], pTranslate))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1430);
        }

        CMQVariant    propvarToSet;
        const PROPVARIANT * ppvarToSet;
        PROPID        dwPropidToSet;
        //
        // if the property is in the DS, set the given property with given value
        //
        if (pTranslate->vtDS != ADSTYPE_INVALID)
        {
            ppvarToSet = &pPropVars[i];
            dwPropidToSet = pPropIDs[i];
            //
            //  In addition if set routine is configured for this property call it
            //
            if (pTranslate->SetPropertyHandle) 
            {
                hr = pTranslate->SetPropertyHandle(pIADs, pwcsDomainController, fServerName, &pPropVars[i], &dwPropidToSet, propvarToSet.CastToStruct());
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 500);
                }
            }
       }
        else if (pTranslate->SetPropertyHandle)
        {
            //
            // the property is not in the DS, but has a set routine, use it
            // to get the new property & value to set
            //
            hr = pTranslate->SetPropertyHandle(pIADs, pwcsDomainController, fServerName, &pPropVars[i], &dwPropidToSet, propvarToSet.CastToStruct());
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 510);
            }
            ASSERT( dwPropidToSet != 0);
            ppvarToSet = propvarToSet.CastToStruct();
            //
            // Get replaced property info
            //
            if(!g_PropDictionary.Lookup(dwPropidToSet, pTranslate))
            {
                ASSERT(0);
                return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1440);
            }
        }
        else
        {
            //
            // the property is not in the DS, and doesn't have a set routine.
            // ignore it.
            //
            continue;
        }

        BS bsPropName(pTranslate->wcsPropid);

        if ( ( ppvarToSet->vt & VT_VECTOR && ppvarToSet->cauuid.cElems == 0) || // counted array with 0 elements
             ( ppvarToSet->vt == VT_BLOB && ppvarToSet->blob.cbSize == 0) || // an empty blob
             ( ppvarToSet->vt == VT_LPWSTR && wcslen( ppvarToSet->pwszVal) == 0) || // an empty string
             ( ppvarToSet->vt == VT_EMPTY) ) // an empty variant
        {
            vProp.vt = VT_EMPTY;
            hr = pIADs->PutEx( ADS_PROPERTY_CLEAR,
                               bsPropName,
                               vProp);
            LogTraceQuery(bsPropName, s_FN, 519);
            if (FAILED(hr))
            {
				TrERROR(mqad, "failed to clear property %ls, hr = 0x%x", bsPropName, hr);
                return LogHR(hr, s_FN, 520);
            }
        }
        else if (pTranslate->vtDS == ADSTYPE_NT_SECURITY_DESCRIPTOR)
        {
            //
			// Security is not supposed to be set together with other
            // properties.
            //
            ASSERT(0);
		}
        else
        {
            hr = MqVal2Variant(&vProp, ppvarToSet, pTranslate->vtDS);
            if (FAILED(hr))
            {
				TrERROR(mqad, "MqVal2Variant failed, property %ls, hr = 0x%x", bsPropName, hr);
                return LogHR(hr, s_FN, 530);
            }

            hr = pIADs->Put(bsPropName, vProp);
            if (FAILED(hr))
            {
				TrERROR(mqad, "failed to set property %ls, hr = 0x%x", bsPropName, hr);
                return LogHR(hr, s_FN, 540);
            }

            VariantClear(&vProp);
        }
    }

    return MQ_OK;
}


HRESULT CAdsi::GetObjectPropsCached(
        IN  IADs            *pIADs,                  // object's pointer
        IN  CBasicObjectType* pObject,
        IN  DWORD            cPropIDs,               // number of attributes
        IN  const PROPID    *pPropIDs,               // name of attributes
        OUT MQPROPVARIANT   *pPropVars)              // attribute values
/*++
    Abstract:
	Retrieve properties of an object opened via IADs ( i.e. from cache)

    Parameters:

    Returns:

--*/
{
    HRESULT           hr;
    VARIANT           var;


    //
    // Get DN & guid of object
    //
    AP<WCHAR>         pwszObjectDN;
    P<GUID>          pguidObjectGuid;
    hr = GetDNGuidFromIADs(pIADs, &pwszObjectDN, &pguidObjectGuid);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 570);
    }

    //
    // Get translate info object
    //
    P<CObjXlateInfo> pcObjXlateInfo;
    pObject->GetObjXlateInfo(pwszObjectDN, pguidObjectGuid, &pcObjXlateInfo);

    // Tell the translate info object about the IADs object to use in order to get necessary DS props
    pcObjXlateInfo->InitGetDsProps(pIADs);

    //
    // Get properties one by one
    //
    for (DWORD dwProp=0; dwProp<cPropIDs; dwProp++)
    {
        //
        // Get property info
        //
        const translateProp *pTranslate;
        if(!g_PropDictionary.Lookup(pPropIDs[dwProp], pTranslate))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1470);
        }

        //
        // if the property is not in the DS, call its retrieve routine
        //
        if (pTranslate->vtDS == ADSTYPE_INVALID)
        {
            if (pTranslate->RetrievePropertyHandle)
            {
                //
                //  Calculate its value
                //
                hr = pTranslate->RetrievePropertyHandle(
                        pcObjXlateInfo,
                        pObject->GetDomainController(),
                        pObject->IsServerName(),
                        pPropVars + dwProp
                        );
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 600);
                }
                continue;
            }
            else
            {
                //
                // return error if no retrieve routine
                //
                ASSERT(0);
                return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1480);
            }
        }

        BS bsName(pTranslate->wcsPropid);
        VariantInit(&var);
		BOOL fConvNeeed = TRUE;

        if (pTranslate->fMultiValue)
        {
            hr = pIADs->GetEx(bsName, &var);
            LogTraceQuery(bsName, s_FN, 609);
        }
        else if (pTranslate->vtDS == ADSTYPE_NT_SECURITY_DESCRIPTOR)
        {
            //
            //  Not suppose to retrive security attribute with 
            //  other attributes
            //
            //  BUGBUG - remember to remove this "if" after enough testing
            //  
            ASSERT(0);
        }
        else
        {
            hr = pIADs->Get(bsName, &var);
            LogTraceQuery(bsName, s_FN, 619);
        }

        if ( hr == E_ADS_PROPERTY_NOT_FOUND)
        {
            //
            //  No value set for this property,
            //  return the default value
            //
            if (pTranslate->pvarDefaultValue != NULL)
            {
                hr =CopyDefaultValue(
                       pTranslate->pvarDefaultValue,
                       pPropVars + dwProp
                        );
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 620);
                }           
                continue;
            }
            else if (pTranslate->RetrievePropertyHandle)
            {
                //
                //  No default value, try to calculate its value
                //
                hr = pTranslate->RetrievePropertyHandle(
                        pcObjXlateInfo,
                        pObject->GetDomainController(),
                        pObject->IsServerName(),
                        pPropVars + dwProp
                        );
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 630);
                }
                continue;
            }
           return LogHR(hr, s_FN, 1490);
        }

        // Translate OLE variant into MQ property
		if (fConvNeeed)
		{
			hr = Variant2MqVal(pPropVars + dwProp, &var, pTranslate->vtDS, pTranslate->vtMQ);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 640);
            }
		}

        VariantClear(&var);
    }
    return MQ_OK;
}

HRESULT CAdsi::FillAttrNames(
            OUT LPWSTR    *          ppwszAttributeNames,  // Names array
            OUT DWORD *              pcRequestedFromDS,    // Number of attributes to pass to DS
            IN  DWORD                cPropIDs,             // Number of Attributes to translate
            IN  const PROPID *       pPropIDs)             // Attributes to translate
/*++
    Abstract:
	Allocates with PV and fills array of attribute names

    Parameters:

    Returns:

--*/
{
    DWORD   cRequestedFromDS = 0;
    ULONG   ul;
    BOOL fRequestedDN = FALSE;
    BOOL fRequestedGUID = FALSE;

    for (DWORD i=0; i<cPropIDs; i++)
    {
        //
        // Get property info
        //
        const translateProp *pTranslate;
        if(!g_PropDictionary.Lookup(pPropIDs[i], pTranslate))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1500);
        }

        if (pTranslate->vtDS != ADSTYPE_INVALID)
        {
            // Allocate and fill individual name memory
            ul = (wcslen(pTranslate->wcsPropid) + 1) * sizeof(WCHAR);
            ppwszAttributeNames[cRequestedFromDS] = (LPWSTR)PvAllocMore(ul, ppwszAttributeNames);
            wcscpy(ppwszAttributeNames[cRequestedFromDS], pTranslate->wcsPropid);
            cRequestedFromDS++;
            if (wcscmp(x_AttrDistinguishedName, pTranslate->wcsPropid) == 0)
            {
                fRequestedDN = TRUE;
            }
            else if (wcscmp(x_AttrObjectGUID, pTranslate->wcsPropid) == 0)
            {
                fRequestedGUID = TRUE;
            }
        }
    }

    //
    // Add request for dn if not requested already
    //
    if (!fRequestedDN)
    {
        LPCWSTR pwName = x_AttrDistinguishedName;
        ul = (wcslen(pwName) + 1) * sizeof(WCHAR);
        ppwszAttributeNames[cRequestedFromDS] = (LPWSTR)PvAllocMore(ul, ppwszAttributeNames);
        wcscpy(ppwszAttributeNames[cRequestedFromDS++], pwName);
    }

    //
    // Add request for guid if not requested already
    //
    if (!fRequestedGUID)
    {
        LPCWSTR pwName = x_AttrObjectGUID;
        ul = (wcslen(pwName) + 1) * sizeof(WCHAR);
        ppwszAttributeNames[cRequestedFromDS] = (LPWSTR)PvAllocMore(ul, ppwszAttributeNames);
        wcscpy(ppwszAttributeNames[cRequestedFromDS++], pwName);
    }

    *pcRequestedFromDS = cRequestedFromDS;
    return MQ_OK;
}


HRESULT CAdsi::FillSearchPrefs(
            OUT ADS_SEARCHPREF_INFO *pPrefs,        // preferences array
            OUT DWORD               *pdwPrefs,      // preferences counter
            IN  AD_SEARCH_LEVEL     eSearchLevel,	// flat / 1 level / subtree
            IN  const MQSORTSET *   pDsSortkey,     // sort keys array
			OUT      ADS_SORTKEY *  pSortKeys)		// sort keys array in ADSI  format
/*++
    Abstract:
	Fills the caller provided ADS_SEARCHPREF_INFO structure

    Parameters:

    Returns:

--*/
{
    ADS_SEARCHPREF_INFO *pPref = pPrefs;

    //  Search preferences: Attrib types only = NO

    pPref->dwSearchPref   = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
    pPref->vValue.dwType  = ADSTYPE_BOOLEAN;
    pPref->vValue.Boolean = FALSE;

    pPref->dwStatus       = ADS_STATUS_S_OK;
    (*pdwPrefs)++;
	pPref++;

    //  Asynchronous

    pPref->dwSearchPref   = ADS_SEARCHPREF_ASYNCHRONOUS;
    pPref->vValue.dwType  = ADSTYPE_BOOLEAN;
    pPref->vValue.Boolean = TRUE;

    pPref->dwStatus       = ADS_STATUS_S_OK;
    (*pdwPrefs)++;
	pPref++;

    // Do not chase referrals

    pPref->dwSearchPref   = ADS_SEARCHPREF_CHASE_REFERRALS;
    pPref->vValue.dwType  = ADSTYPE_INTEGER;
    pPref->vValue.Integer = ADS_CHASE_REFERRALS_NEVER;

    pPref->dwStatus       = ADS_STATUS_S_OK;
    (*pdwPrefs)++;
	pPref++;

    // Search preferences: Scope

    pPref->dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE; //ADS_SEARCHPREF
    pPref->vValue.dwType= ADSTYPE_INTEGER;
    switch (eSearchLevel)
    {
    case searchOneLevel:
        pPref->vValue.Integer = ADS_SCOPE_ONELEVEL;
        break;
    case searchSubTree:
        pPref->vValue.Integer = ADS_SCOPE_SUBTREE;
        break;
    default:
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1510);
        break;
    }

    pPref->dwStatus = ADS_STATUS_S_OK;
    (*pdwPrefs)++;
	pPref++;

	// Search preferences: sorting
	if (pDsSortkey && pDsSortkey->cCol)
	{
		for (DWORD i=0; i<pDsSortkey->cCol; i++)
		{
			const translateProp *pTranslate;
			if(!g_PropDictionary.Lookup(pDsSortkey->aCol[i].propColumn, pTranslate))
			{
				ASSERT(0);			// Ask to sort on unexisting property
                return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1520);
			}

			if (pTranslate->vtDS == ADSTYPE_INVALID)
			{
				ASSERT(0);			// Ask to sort on non-ADSI property
                return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1530);
			}

			pSortKeys[i].pszAttrType = (LPWSTR) pTranslate->wcsPropid;
			pSortKeys[i].pszReserved   = NULL;
			pSortKeys[i].fReverseorder = (pDsSortkey->aCol[i].dwOrder == QUERY_SORTDESCEND);
                                        // Interpreting Descend as Reverse - is it correct?
		}

	    pPref->dwSearchPref  = ADS_SEARCHPREF_SORT_ON;
        pPref->vValue.dwType = ADSTYPE_PROV_SPECIFIC;
        pPref->vValue.ProviderSpecific.dwLength = sizeof(ADS_SORTKEY) * pDsSortkey->cCol;
        pPref->vValue.ProviderSpecific.lpValue =  (LPBYTE)pSortKeys;

	    pPref->dwStatus = ADS_STATUS_S_OK;
		(*pdwPrefs)++;
		pPref++;
	}
    else
    {
        //
        // Bug 299178, page size and sorting are note compatible.
        //
        pPref->dwSearchPref   = ADS_SEARCHPREF_PAGESIZE;
        pPref->vValue.dwType  = ADSTYPE_INTEGER;
        pPref->vValue.Integer = 12;

        pPref->dwStatus       = ADS_STATUS_S_OK;
        (*pdwPrefs)++;
    	pPref++;
    }

    return MQ_OK;
}

HRESULT CAdsi::MqPropVal2AdsiVal(
      OUT ADSTYPE       *pAdsType,
      OUT DWORD         *pdwNumValues,
      OUT PADSVALUE     *ppADsValue,
      IN  PROPID         propID,
      IN  const MQPROPVARIANT *pPropVar,
      IN  PVOID          pvMainAlloc)
/*++
    Abstract:
	Translate mqpropvariant to adsi value

    Parameters:

    Returns:

--*/
{
    // Find out resulting ADSI type
    //
    // Get property info
    //
    const translateProp *pTranslate;
    if(!g_PropDictionary.Lookup(propID, pTranslate))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1540);
    }

    VARTYPE vtSource = pTranslate->vtMQ;
    DBG_USED(vtSource);
    ASSERT( vtSource == pPropVar->vt );

    *pAdsType        = pTranslate->vtDS;

    HRESULT hr2 = MqVal2AdsiVal(
      *pAdsType,
      pdwNumValues,
      ppADsValue,
      pPropVar,
      pvMainAlloc);

    return LogHR(hr2, s_FN, 1550);

}

HRESULT CAdsi::AdsiVal2MqPropVal(
      OUT MQPROPVARIANT *pPropVar,
      IN  PROPID        propID,
      IN  ADSTYPE       AdsType,
      IN  DWORD         dwNumValues,
      IN  PADSVALUE     pADsValue)
/*++
    Abstract:
	Translate adsi value to mqpropvariant

    Parameters:

    Returns:

--*/
{

    // Find out target type
    //
    // Get property info
    //
    const translateProp *pTranslate;
    if(!g_PropDictionary.Lookup(propID, pTranslate))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1560);
    }

    ASSERT(pTranslate->vtDS == AdsType);

    ASSERT( (dwNumValues == 1) ||
            (dwNumValues >  1) && pTranslate->fMultiValue );

    VARTYPE vtTarget = pTranslate->vtMQ;

    HRESULT hr2 = AdsiVal2MqVal(pPropVar, vtTarget, AdsType, dwNumValues, pADsValue);
    return LogHR(hr2, s_FN, 1570);
}


HRESULT CAdsi::LocateObjectFullName(
        IN AD_PROVIDER       eProvider,		// local DC or GC
        IN DS_CONTEXT        eContext,         // DS context
        IN  LPCWSTR          pwcsDomainController,
        IN  bool			 fServerName,
        IN  const GUID *     pguidObjectId,
        OUT WCHAR **         ppwcsFullName
        )
/*++
    Abstract:

    Parameters:

    Returns:

--*/
{
    R<IDirectorySearch> pDSSearch = NULL;
    ADS_SEARCH_HANDLE   hSearch;

    HRESULT hr = BindForSearch(
                      eProvider,
                      eContext,
                      pwcsDomainController,
					  fServerName,
                      NULL,
                      FALSE,
                      (VOID *)&pDSSearch
                      );
    if (FAILED(hr))                       // e.g. base object does not support search
    {
        return LogHR(hr, s_FN, 1600);
    }

    //
    //  Search the object according to its unique id
    //
    AP<WCHAR>   pwszVal;

    MQPROPVARIANT var;
    var.vt = VT_CLSID;
    var.puuid = const_cast<GUID *>(pguidObjectId);
    hr = MqPropVal2String(&var,
                          ADSTYPE_OCTET_STRING,
                          &pwszVal);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 660);
    }

    ADS_SEARCHPREF_INFO prefs[15];
    DWORD dwNumPrefs = 0;
    hr = FillSearchPrefs(prefs,
                         &dwNumPrefs,
                         searchSubTree,
                         NULL,
                         NULL);

    hr = pDSSearch->SetSearchPreference( prefs, dwNumPrefs);
    ASSERT(SUCCEEDED(hr)) ;  // we don't expect this one to fail.
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 670);
    }

    WCHAR pwszSearchFilter[200];   // assuming - object-guid-id string is less than 200

    swprintf(
         pwszSearchFilter,
         L"(objectGUID="
         L"%s"
         L")\0",
         pwszVal
         );
    LPWSTR pwcsAttributes[] =  {const_cast<WCHAR*>(x_AttrDistinguishedName),
                                const_cast<WCHAR*>(x_AttrCN)};

    hr = pDSSearch->ExecuteSearch(
            pwszSearchFilter,
            pwcsAttributes,
            2,
            &hSearch);
    LogTraceQuery(pwszSearchFilter, s_FN, 679);
    if (FAILED(hr))
    {
		TrERROR(mqad, "failed to ExecuteSearch, hr = 0x%x, pwcsSearchFilter = %ls", hr, pwszSearchFilter);
        return LogHR(hr, s_FN, 680);
    }

    CAutoCloseSearchHandle cCloseSearchHandle(pDSSearch.get(), hSearch);

    //  Get next row
    hr = pDSSearch->GetNextRow( hSearch);
    if ( hr ==  S_ADS_NOMORE_ROWS)
    {
        hr = HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT);
    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 690);
    }

    //
    // Ask for the common name
    //
    ADS_SEARCH_COLUMN ColumnCN;
    hr = pDSSearch->GetColumn(
                 hSearch,
                 const_cast<WCHAR *>(x_AttrCN),
                 &ColumnCN);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 700);
    }

    CAutoReleaseColumn cAutoReleaseColumnCN(pDSSearch.get(), &ColumnCN);

    WCHAR * pwszCommonName = ColumnCN.pADsValues->DNString;
    if (pwszCommonName == NULL)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1610);
    }

    //
    // Ask for the Distinguished name
    //
    ADS_SEARCH_COLUMN ColumnDN;
    hr = pDSSearch->GetColumn(
                 hSearch,
                 const_cast<WCHAR *>(x_AttrDistinguishedName),
                 &ColumnDN);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 710);
    }

    CAutoReleaseColumn cAutoReleaseColumnDN(pDSSearch.get(), &ColumnDN);

    WCHAR * pwszDistinguishedName = ColumnDN.pADsValues->DNString;
    if (pwszDistinguishedName == NULL)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1620);
    }

    //
    // Filter special characters in the common name part of
    // the distinuished name
    //

    //
    // Length of the final buffer: Distinguished Name format is
    // CN=<common name>,....
    // When filtering it, we may add up to <length of common name> characters
    //
    *ppwcsFullName = new WCHAR[ wcslen(pwszDistinguishedName) + wcslen(pwszCommonName) + 1];

    LPWSTR pwstrOut = *ppwcsFullName;
    LPWSTR pwstrIn = pwszDistinguishedName;

    ASSERT(_wcsnicmp(pwstrIn, x_CnPrefix, x_CnPrefixLen) == 0); // "CN="

    wcsncpy(pwstrOut, pwstrIn, x_CnPrefixLen);

    //
    // Skip the prefix after copy
    //
    pwstrOut += x_CnPrefixLen;
    pwstrIn += x_CnPrefixLen;

    //
    // Take the name after the prefix, and filter the special characters out
    //
    DWORD_PTR dwCharactersProcessed;
    FilterSpecialCharacters(pwstrIn, wcslen(pwszCommonName), pwstrOut, &dwCharactersProcessed);
    pwstrOut += wcslen(pwstrOut);
    pwstrIn += dwCharactersProcessed;

    //
    // Copy the remainder of the distinguished name as is
    //
    wcscpy(pwstrOut, pwstrIn);

    return LogHR(hr, s_FN, 1630);
}

HRESULT CAdsi::FindComputerObjectFullPath(
            IN  AD_PROVIDER             eProvider,
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN  ComputerObjType         eComputerObjType,
			IN  LPCWSTR                 pwcsComputerDnsName,
            IN  const MQRESTRICTION *   pRestriction,
            OUT LPWSTR *                ppwcsFullPathName
            )
/*++
    Abstract:

    Parameters:
	pwcsComputerDnsName : if the caller pass the computer DNS name,
						  (the search itself is according to the computer Netbios
                         name), then for each result, we verify if the dns name match.
    fServerName - flag that indicate if the pwcsDomainController string is a server name

    Returns:
	HRESULT

--*/
{

    DWORD lenDC = (pwcsDomainController != NULL) ? wcslen(pwcsDomainController) : 0;
    const WCHAR * pwcsProvider;

    switch (eProvider)
    {
		case adpDomainController:
			pwcsProvider = x_LdapProvider;
			break; 

		case adpGlobalCatalog:
			pwcsProvider = x_GcProvider;

			//
			// For GC always use serverless binding.
			// this server may not be a GC (it surely Ldap). 
			// using server binding with this server will fail in case this server is not GC
			//
			lenDC = 0;
			break;

		default:
			ASSERT(0);
			return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1640);
    }

    DWORD dwLen = x_providerPrefixLength + lenDC + 10;
    AP<WCHAR>  wszProvider = new WCHAR[dwLen];

    if(lenDC != 0)
    {
        swprintf(
             wszProvider,
             L"%s%s/",
            pwcsProvider,
            pwcsDomainController
            );
    }
    else
    {
        wcscpy(wszProvider, pwcsProvider);
    }

    R<IDirectorySearch> pDSSearch;
    HRESULT hr;
    hr = BindForSearch(
                eProvider,
                e_RootDSE,  
                pwcsDomainController,
				fServerName,
                NULL,    //  pguidUniqueId 
                FALSE,   // fSorting 
                &pDSSearch);
    if (FAILED(hr))
    {
		TrERROR(mqad, "Failed binding for search, hr = 0x%x", hr);
        return LogHR(hr, s_FN, 2100);
    }

    ADS_SEARCH_HANDLE   hSearch;

    //
    //  Search the object according to the given restriction
    //
    P<CComputerObject> pObject = new CComputerObject(NULL, NULL, pwcsDomainController, fServerName);

    AP<WCHAR> pwszSearchFilter;
    hr = MQADpRestriction2AdsiFilter(
            pRestriction,
            pObject->GetObjectCategory(),
            pObject->GetClass(),
            &pwszSearchFilter
            );
    if (FAILED(hr))
    {
		TrERROR(mqad, "MQADpRestriction2AdsiFilter failed, hr = 0x%x", hr);
        return LogHR(hr, s_FN, 1650);
    }

    AP<WCHAR>   pwszVal;

    LPWSTR pwcsAttributes[] =  {const_cast<WCHAR*>(x_AttrDistinguishedName),
                                const_cast<WCHAR*>(MQ_COM_DNS_HOSTNAME_ATTRIBUTE)};

	DWORD numAttributes = ( pwcsComputerDnsName == NULL) ? 1 : 2;
    hr = pDSSearch->ExecuteSearch(
            pwszSearchFilter,
            pwcsAttributes,
            numAttributes,
            &hSearch);
    LogTraceQuery(pwszSearchFilter, s_FN, 719);
    if (FAILED(hr))
    {
		TrERROR(mqad, "failed to ExecuteSearch, hr = 0x%x", hr);
        return LogHR(hr, s_FN, 720);
    }

    CAutoCloseSearchHandle cCloseSearchHandle(pDSSearch.get(), hSearch);

    hr = MQDS_OBJECT_NOT_FOUND ; // prepare return error.
    //
    //  Get first row from search.
    //
    HRESULT hrRow = pDSSearch->GetFirstRow( hSearch);

    while (SUCCEEDED(hrRow) && (hrRow !=  S_ADS_NOMORE_ROWS))
    {
        ADS_SEARCH_COLUMN Column;
        //
        // Ask for the column itself
        //
        hr = pDSSearch->GetColumn(
                      hSearch,
                      const_cast<WCHAR *>(x_AttrDistinguishedName),
                     &Column);
        if (FAILED(hr))
        {
			TrERROR(mqad, "failed to GetColumn, hr = 0x%x", hr);
            return LogHR(hr, s_FN, 730);
        }

        CAutoReleaseColumn cAutoReleaseColumnDN(pDSSearch.get(), &Column);

        WCHAR * pwsz = Column.pADsValues->DNString;
        if (pwsz == NULL)
        {
            ASSERT(0);
			TrERROR(mqad, "NULL string");
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 2101);
        }

		if ( pwcsComputerDnsName != NULL)
		{
			ASSERT( numAttributes == 2);
			//
			//	verify that the DNS host name of the computer match
			// 
			ADS_SEARCH_COLUMN ColumnDns;

			hr = pDSSearch->GetColumn(
						  hSearch,
						  const_cast<WCHAR *>(MQ_COM_DNS_HOSTNAME_ATTRIBUTE),
						 &ColumnDns);
			if (FAILED(hr))
			{
				hrRow = pDSSearch->GetNextRow( hSearch );
				continue;
			}

			CAutoReleaseColumn cAutoReleaseColumnDNS(pDSSearch.get(), &ColumnDns);
			WCHAR * pwszDns = ColumnDns.pADsValues->DNString;
			if ( (pwszDns == NULL) || 
				 (_wcsicmp( pwcsComputerDnsName,  pwszDns) != 0))
			{
				hrRow = pDSSearch->GetNextRow( hSearch );
				continue;
			}
		}


        if (eComputerObjType ==  eRealComputerObject)
        {
            //
            // Return the distingushed name.
            // When looking for the "real" computer object, we return
            // the first one found, even if it does not contain the
            // msmqConfiguration object. In most cases, this will indeed
            // be the object we want. Especially for domain controllers
            // that look for their own computer object in local replica.
            //
            *ppwcsFullPathName = new WCHAR[ wcslen(pwsz) + 1];
            wcscpy(*ppwcsFullPathName, pwsz);
            return  MQ_OK ;
        }

        //
        // OK, we have the name of the computer. Let's see if it own a msmq
        // object. If not, let search for another computer with the same name.
        // This may happen if more than one computer object with same name
        // exist in different domains. This will happen in mix-mode scenario,
        // where many computers objects are create by the upgrade wizard in the
        // PEC domain, although the computers belong to different nt4 domains.
        // After such a nt4 domain upgrade to win2k, computers objects will be
        // created in the newly upgraded domain while the msmq object still
        // live under similar computer name in the PEC object.
        // This problem may also happen when a computer move between domains
        // but the msmqConfiguration object is still in the old domain.
        // Bind with ADS_SECURE_AUTHENTICATION to make sure that a real binding
        // is done with server. ADS_FAST_BIND won't really go to the server
        // when calling AdsOpenObject.
        //
        dwLen = wcslen(pwsz)                   +
                wcslen(wszProvider)            +
                x_MsmqComputerConfigurationLen +
                10 ;
        P<WCHAR> wszFullName = new WCHAR[ dwLen ] ;
        wsprintf(wszFullName, L"%s%s=%s,%s", wszProvider,
                                             x_AttrCN,
                                             x_MsmqComputerConfiguration,
                                             pwsz ) ;
        R<IDirectoryObject> pDirObj = NULL ;

		DWORD Flags = ADS_SECURE_AUTHENTICATION;
		if(fServerName && (lenDC != 0))
		{
			Flags |= ADS_SERVER_BIND;
		}

        hr = ADsOpenObject( 
				wszFullName,
				NULL,
				NULL,
				Flags,
				IID_IDirectoryObject,
				(void**) &pDirObj 
				);

        LogTraceQuery(wszFullName, s_FN, 1659);
        if (FAILED(hr))
        {
			TrERROR(mqad, "ADsOpenObject failed to bind %ls, hr = 0x%x, Flags = 0x%x", wszFullName, hr, Flags);
            WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                             e_LogDS,
                             LOG_DS_CROSS_DOMAIN,
                     L"DSCore: FindComputer() failed, hr- %lxh, Path- %s",
                              hr,
                              wszFullName )) ;

            if (eProvider == adpDomainController)
            {
                //
                // No luck in local domain controller. Each domain can have
                // only one computer object with a given name, so don't
                // look for other objects.
                // We'll be called again to search in GC.
                //
                LogHR(hr, s_FN, 1660);
                return MQDS_OBJECT_NOT_FOUND ; // keep this error for compatibility.
            } 
        }
        else
        {
            //
            // Return the distingushed name.
            // When looking for the "real" computer object, we return
            // the first one found, even if it does not contain the
            // msmqConfiguration object. In most cases, this will indeed
            // be the object we want.
            //
            *ppwcsFullPathName = new WCHAR[ wcslen(pwsz) + 1];
            wcscpy(*ppwcsFullPathName, pwsz);
            return  MQ_OK ;
        }

        hrRow = pDSSearch->GetNextRow( hSearch );
    }

    LogHR(hr, s_FN, 1670);
    return MQDS_OBJECT_NOT_FOUND ; // keep this error for compatibility.
}



HRESULT CAdsi::FindObjectFullNameFromGuid(
        IN  AD_PROVIDER      eProvider,		// local DC or GC
        IN  DS_CONTEXT       eContext,         // DS context
        IN  LPCWSTR          pwcsDomainController,
        IN  bool			 fServerName,
        IN  const GUID *     pguidObjectId,
        IN  BOOL             fTryGCToo,
        OUT WCHAR **         ppwcsFullName,
        OUT AD_PROVIDER *    pFoundObjectProvider
        )
/*++
    Abstract:
	Finds distingushed name of object according to its unique id

    Parameters:

    Returns:
	HRESULT
--*/
{
    //
    //  Locate the object according to its unique id
    //
    *ppwcsFullName = NULL;

    AD_PROVIDER dsProvider = eProvider;

    LPCWSTR pwcsContext;
    switch( eContext)
    {
        case e_RootDSE:
                pwcsContext = g_pwcsDsRoot;
             break;

        case e_ConfigurationContainer:
             pwcsContext = g_pwcsConfigurationContainer;
             break;

        case e_SitesContainer:
             pwcsContext = g_pwcsSitesContainer;
             break;

        case e_MsmqServiceContainer:
            pwcsContext = g_pwcsMsmqServiceContainer;
            break;

        case e_ServicesContainer:
            pwcsContext = g_pwcsServicesContainer;
            break;

        default:
            ASSERT(0);
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1680);
    }
    *pFoundObjectProvider = dsProvider;

    HRESULT hr = LocateObjectFullName(
					dsProvider,	
					eContext,         // DS context
					pwcsDomainController,
					fServerName,
					pguidObjectId,
					ppwcsFullName
					);

    if (!fTryGCToo)
    {
        return LogHR(hr, s_FN, 1690);
    }

    //
    //  For queues, machines and users : for set and delete operations
    //  which are performed against the domain controller, we try
    //  again this time against the GC.
    //
    //
    if (FAILED(hr) &&
       (eProvider == adpDomainController))
    {
        //
        //  Try again this time against the GC
        //
        hr = LocateObjectFullName(
				adpGlobalCatalog,
				e_RootDSE,
				pwcsDomainController,
				fServerName,
				pguidObjectId,
				ppwcsFullName
				);
        *pFoundObjectProvider = adpGlobalCatalog;
    }
    return LogHR(hr, s_FN, 1700);
}


static AP<WCHAR> s_pwcsDomainController;
static AP<WCHAR> s_pwcsLocalDsRoot; 
CCriticalSection s_csLocalDsRootCache;


HRESULT 
CAdsi::GetLocalDsRoot(
		IN LPCWSTR pwcsDomainController, 
		IN bool fServerName,
		OUT LPWSTR* ppwcsLocalDsRoot,
		OUT AP<WCHAR>& pwcsLocalDsRootToFree
		)
/*++
Routine Description:
	Get the local DS root for the specific pwcsDomainController.

Arguments:
    pwcsDomainController - the DC name against the AD access should be performed.
    fServerName - flag that indicate if the pwcsDomainController string is a server name
	ppwcsLocalDsRoot - the LocalDsRoot string.
	pwcsLocalDsRootToFree - the LocalDsRoot string to be freed.

Returned Value:
	HRESULT.

--*/
{
	if(pwcsDomainController == NULL)
	{
		*ppwcsLocalDsRoot = g_pwcsLocalDsRoot;
		TrTRACE(mqad, "using the default LocalDsRoot, g_pwcsLocalDsRoot = %ls", g_pwcsLocalDsRoot);
		return MQ_OK;
	}

	{
		//
		// Critical section for getting the cached strings
		//
		CS lock(s_csLocalDsRootCache);
		if((s_pwcsDomainController != NULL) && (wcscmp(s_pwcsDomainController, pwcsDomainController) == 0))
		{
			//
			// The DomainController match the cashed one, return the cached LocalDsRoot
			//
			pwcsLocalDsRootToFree = newwcs(s_pwcsLocalDsRoot);
			*ppwcsLocalDsRoot = pwcsLocalDsRootToFree;
			TrTRACE(mqad, "using the cached LocalDsRoot, pwcsDomainController = %ls, s_pwcsLocalDsRoot = %ls", pwcsDomainController, s_pwcsLocalDsRoot);
			return MQ_OK;
		}
	}

    AP<WCHAR> pwcsLocalDsRoot;
	HRESULT hr = GetLocalDsRootName(
					pwcsDomainController,
					fServerName,
					&pwcsLocalDsRoot
					);

    if (FAILED(hr))
    {
		TrERROR(mqad, "Failed to get LocalDsRoot, hr = 0x%x", hr);
        return hr;
    }

	{
		//
		// Critical section for updating the cached strings
		//
		CS lock(s_csLocalDsRootCache);

		//
		// Initialize/reinitialize the cache
		//
		s_pwcsLocalDsRoot.free();
		s_pwcsLocalDsRoot = newwcs(pwcsLocalDsRoot);
		s_pwcsDomainController.free();
		s_pwcsDomainController = newwcs(pwcsDomainController);

	}

	pwcsLocalDsRootToFree = pwcsLocalDsRoot.detach();
	*ppwcsLocalDsRoot = pwcsLocalDsRootToFree;
	TrTRACE(mqad, "Initialized LocalDsRoot cache: pwcsDomainController = %ls, pwcsLocalDsRoot = %ls", pwcsDomainController, *ppwcsLocalDsRoot);
	return MQ_OK;
}


HRESULT 
CAdsi::GetLocalDsRootName(
		IN  LPCWSTR			pwcsDomainController,
        IN  bool			fServerName,
        OUT LPWSTR *        ppwcsLocalRootName
        )
/*++
Routine Description:
	Finds the name of local DS root

Arguments:
    pwcsDomainController - the DC name against the AD access should be performed.
    fServerName - flag that indicate if the pwcsDomainController string is a server name
	ppwcsLocalRootName - [out] Local Ds Root Name.

Returned Value:
	HRESULT

--*/
{
	ASSERT(pwcsDomainController != NULL);

    //
    // Bind to the RootDSE to obtain information about the Local Ds Root.
    //

    DWORD lenDC = wcslen(pwcsDomainController);

    AP<WCHAR> pwcsRootDSE = new WCHAR [x_providerPrefixLength  + x_RootDSELength + 2 + lenDC];

    swprintf(
        pwcsRootDSE,
        L"%s%s/%s",
        x_LdapProvider,
		pwcsDomainController,
		x_RootDSE
        );

	ASSERT(lenDC != 0);

	DWORD Flags = ADS_SECURE_AUTHENTICATION;
	if(fServerName)
	{
		Flags |= ADS_SERVER_BIND;
	}

    R<IADs> pADs;
	HRESULT hr = ADsOpenObject(
						pwcsRootDSE,
						NULL,
						NULL,
						Flags, 
						IID_IADs,
						(void**)&pADs
						);

    LogTraceQuery(pwcsRootDSE, s_FN, 1710);
    if (FAILED(hr))
    {
	    TrERROR(mqad, "ADsOpenObject() failed binding %ls, hr = 0x%x, Flags = 0x%x", pwcsRootDSE, hr, Flags);
		swprintf(
			pwcsRootDSE,
			L"%s%s/%s",
			x_GcProvider,
			pwcsDomainController,
			x_RootDSE
			);

		hr = ADsOpenObject(
				pwcsRootDSE,
				NULL,
				NULL,
				Flags, 
				IID_IADs,
				(void**)&pADs
				);

        if (FAILED(hr))
        {
		    TrERROR(mqad, "ADsOpenObject() failed binding %ls, hr = 0x%x, Flags = 0x%x", pwcsRootDSE, hr, Flags);
            return LogHR(hr, s_FN, 1720);
        }
    }

    TrTRACE(mqad, "succeeded binding %ls", pwcsRootDSE);

	hr = GetDefaultNamingContext(pADs.get(), ppwcsLocalRootName);
    if (FAILED(hr))
    {
        TrERROR(mqad, "Failed to get DefaultNamingContext, hr = 0x%x", hr);
        return LogHR(hr, s_FN, 1730);
    }

    return(MQ_OK);
}


HRESULT 
CAdsi::GetRootDsName(
        OUT LPWSTR *        ppwcsRootName,
        OUT LPWSTR *        ppwcsLocalRootName,
        OUT LPWSTR *        ppwcsSchemaNamingContext
        )
/*++
    Abstract:
	Finds the name of root DS

    Parameters:

    Returns:
	HRESULT

--*/
{
    HRESULT hr;
    R<IADs> pADs;

    //
    // Bind to the RootDSE to obtain information about the schema container
	//	( specify local server, to avoid access of remote server during setup)
    //

    AP<WCHAR> pwcsRootDSE = new WCHAR [x_providerPrefixLength  + x_RootDSELength + 2];

	swprintf(
		pwcsRootDSE,
		 L"%s%s",
		x_LdapProvider,
		x_RootDSE
		);

	hr = ADsOpenObject(
            pwcsRootDSE,
			NULL,
			NULL,
			ADS_SECURE_AUTHENTICATION, 
            IID_IADs,
            (void**)&pADs
			);

    LogTraceQuery(pwcsRootDSE, s_FN, 1799);
    if (FAILED(hr))
    {
	    TrERROR(mqad, "ADsOpenObject() failed binding %ls, hr = 0x%x", pwcsRootDSE, hr);
		swprintf(
			pwcsRootDSE,
			 L"%s%s",
			x_GcProvider,
			x_RootDSE
			);

		hr = ADsOpenObject(
				pwcsRootDSE,
				NULL,
				NULL,
				ADS_SECURE_AUTHENTICATION, 
				IID_IADs,
				(void**)&pADs
				);

        if (FAILED(hr))
        {
		    TrERROR(mqad, "ADsOpenObject() failed binding %ls, hr = 0x%x", pwcsRootDSE, hr);
            return LogHR(hr, s_FN, 1800);
        }
    }

    TrTRACE(mqad, "succeeded binding %ls", pwcsRootDSE);

    //
    // Setting value to BSTR Root domain
    //
    BS bstrRootDomainNamingContext( L"rootDomainNamingContext");

    //
    // Reading the root domain name property
    //
    CAutoVariant    varRootDomainNamingContext;

    hr = pADs->Get(bstrRootDomainNamingContext, &varRootDomainNamingContext);
    LogTraceQuery(bstrRootDomainNamingContext, s_FN, 1809);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CAdsi::GetRootDsName(RootNamingContext)=%lx"), hr));
        return LogHR(hr, s_FN, 1810);
    }
    ASSERT(((VARIANT &)varRootDomainNamingContext).vt == VT_BSTR);
    //
    //  calculate length, allocate and copy the string
    //
    DWORD len = wcslen( ((VARIANT &)varRootDomainNamingContext).bstrVal);
    if ( len == 0)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1820);
    }
    *ppwcsRootName = new WCHAR[ len + 1];
    wcscpy( *ppwcsRootName, ((VARIANT &)varRootDomainNamingContext).bstrVal);


	hr = GetDefaultNamingContext(pADs.get(), ppwcsLocalRootName);
    if (FAILED(hr))
    {
        TrERROR(mqad, "Failed to get DefaultNamingContext, hr = 0x%x", hr);
        return LogHR(hr, s_FN, 1825);
    }

    //
    // Setting value to BSTR schema naming context
    //
    BS bstrSchemaNamingContext( L"schemaNamingContext");

    //
    // Reading the schema name property
    //
    CAutoVariant    varSchemaNamingContext;

    hr = pADs->Get(bstrSchemaNamingContext, &varSchemaNamingContext);
    LogTraceQuery(bstrSchemaNamingContext, s_FN, 1859);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CAdsi::GetRootDsName(SchemaNamingContext)=%lx"), hr));
        return LogHR(hr, s_FN, 1850);
    }
    ASSERT(((VARIANT &)varSchemaNamingContext).vt == VT_BSTR);
    //
    //  calculate length, allocate and copy the string
    //
    len = wcslen( ((VARIANT &)varSchemaNamingContext).bstrVal);
    if (len == 0)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1860);
    }
    *ppwcsSchemaNamingContext = new WCHAR[ len + 1];
    wcscpy( *ppwcsSchemaNamingContext, ((VARIANT &)varSchemaNamingContext).bstrVal);

    return(MQ_OK);
}


HRESULT
CAdsi::GetDefaultNamingContext(
	IN IADs*     pADs,
    OUT LPWSTR*  ppwcsLocalRootName
	)
/*++
Routine Description:
	Get the name of local DS root - DefaultNamingContext

Arguments:
    pADs - IADs pointer.
	ppwcsLocalRootName - [out] Local Ds Root Name.

Returned Value:
	HRESULT

--*/
{    
	//
    // Setting value to BSTR default naming context
    //
    BS bstrDefaultNamingContext(L"DefaultNamingContext");

    //
    // Reading the default name property
    //
    CAutoVariant    varDefaultNamingContext;

    HRESULT hr = pADs->Get(bstrDefaultNamingContext, &varDefaultNamingContext);
    LogTraceQuery(bstrDefaultNamingContext, s_FN, 1839);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CAdsi::GetRootDsName(DefaultNamingContext)=%lx"), hr));
        return LogHR(hr, s_FN, 1830);
    }
    ASSERT(((VARIANT &)varDefaultNamingContext).vt == VT_BSTR);
    //
    //  calculate length, allocate and copy the string
    //
    DWORD len = wcslen( ((VARIANT &)varDefaultNamingContext).bstrVal);
    if ( len == 0)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1840);
    }
    *ppwcsLocalRootName = new WCHAR[len + 1];
    wcscpy( *ppwcsLocalRootName, ((VARIANT &)varDefaultNamingContext).bstrVal);
	return MQ_OK;
}

HRESULT   CAdsi::CopyDefaultValue(
           IN const MQPROPVARIANT *   pvarDefaultValue,
           OUT MQPROPVARIANT *        pvar
           )
/*++
    Abstract:
	Copy property's default value into user's mqpropvariant

    Parameters:

    Returns:
	HRESULT

--*/
{
    if ( pvarDefaultValue == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1870);
    }
    switch ( pvarDefaultValue->vt)
    {
        case VT_I2:
        case VT_I4:
        case VT_I1:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_EMPTY:
            //
            //  copy as is
            //
            *pvar = *pvarDefaultValue;
            break;

        case VT_LPWSTR:
            {
                DWORD len = wcslen( pvarDefaultValue->pwszVal);
                pvar->pwszVal = new WCHAR[ len + 1];
                wcscpy( pvar->pwszVal, pvarDefaultValue->pwszVal);
                pvar->vt = VT_LPWSTR;
            }
            break;
        case VT_BLOB:
            {
                DWORD len = pvarDefaultValue->blob.cbSize;
                if ( len > 0)
                {
                    pvar->blob.pBlobData = new unsigned char[ len];
                    memcpy(  pvar->blob.pBlobData,
                             pvarDefaultValue->blob.pBlobData,
                             len);
                }
                else
                {
                    pvar->blob.pBlobData = NULL;
                }
                pvar->blob.cbSize = len;
                pvar->vt = VT_BLOB;
            }
            break;

        case VT_CLSID:
            //
            //  This is a special case where we do not necessarily allocate the memory for the guid
            //  in puuid. The caller may already have puuid set to a guid, and this is indicated by the
            //  vt member on the given propvar. It could be VT_CLSID if guid already allocated, otherwise
            //  we allocate it (and vt should be VT_NULL (or VT_EMPTY))
            //
            if ( pvar->vt != VT_CLSID)
            {
                ASSERT(((pvar->vt == VT_NULL) || (pvar->vt == VT_EMPTY)));
                pvar->puuid = new GUID;
                pvar->vt = VT_CLSID;
            }
            else if ( pvar->puuid == NULL)
            {
                return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 1880);
            }
            *pvar->puuid = *pvarDefaultValue->puuid;
            break;

        case VT_VECTOR|VT_CLSID:
            {
                DWORD len = pvarDefaultValue->cauuid.cElems;
                if ( len > 0)
                {
                    pvar->cauuid.pElems = new GUID[ len];
                    memcpy( pvar->cauuid.pElems,
                           pvarDefaultValue->cauuid.pElems,
                           len*sizeof(GUID));
                }
                else
                {
                    pvar->cauuid.pElems = NULL;
                }
                pvar->cauuid.cElems = len;
                pvar->vt = VT_VECTOR|VT_CLSID;
            }
            break;

        case VT_VECTOR|VT_LPWSTR:
            {
                DWORD len = pvarDefaultValue->calpwstr.cElems;
                if ( len > 0)
                {
                    pvar->calpwstr.pElems = new LPWSTR[ len];
					for (DWORD i = 0; i < len; i++)
					{
						DWORD strlen = wcslen(pvarDefaultValue->calpwstr.pElems[i]) + 1;
						pvar->calpwstr.pElems[i] = new WCHAR[ strlen];
						wcscpy( pvar->calpwstr.pElems[i], pvarDefaultValue->calpwstr.pElems[i]);
					}
                }
                else
                {
                    pvar->calpwstr.pElems = NULL;
                }
                pvar->calpwstr.cElems = len;
                pvar->vt = VT_VECTOR|VT_LPWSTR;
            }
            break;


        default:
            ASSERT(0);
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1890);

    }
    return(MQ_OK);
}


HRESULT CAdsi::DoesObjectExists(
    IN  AD_PROVIDER     eProvider,
    IN  DS_CONTEXT      eContext,
    IN  LPCWSTR         pwcsObjectName
    )
/*++
    Abstract:
	Binds to an object in order to verify its existance

    Parameters:

    Returns:

--*/
{
    R<IADs>   pAdsObj        = NULL;

    // Bind to the object
    HRESULT hr = BindToObject(
                eProvider,
                eContext,
                NULL,   // BUGBUG pwcsDomainController: do we wnat to specify
				false,	// fServerName
                pwcsObjectName,
                NULL,
                IID_IADs,
                (VOID *)&pAdsObj
                );

    return LogHR(hr, s_FN, 1910);
}





CADSearch::CADSearch(
    IDirectorySearch  *pIDirSearch,
    const PROPID      *pPropIDs,
    DWORD             cPropIDs,
    DWORD             cRequestedFromDS,
    CBasicObjectType *       pObject,               
    ADS_SEARCH_HANDLE hSearch
    ) :
    m_pObject(SafeAddRef(pObject))
/*++
    Abstract:
	Constructor for search-capturing class

    Parameters:

    Returns:

--*/
{
    m_pDSSearch = pIDirSearch;      // capturing interface
    m_pDSSearch->AddRef();
    m_cPropIDs       = cPropIDs;
    m_cRequestedFromDS = cRequestedFromDS;
    m_fNoMoreResults = false;
    m_pPropIDs = new PROPID[ cPropIDs];
    CopyMemory(m_pPropIDs, pPropIDs, sizeof(PROPID) * cPropIDs);

    m_hSearch = hSearch;            // keeping handle
}


CADSearch::~CADSearch()
/*++
    Abstract:
	Destructor for search-capturing class

    Parameters:

    Returns:

--*/
{
    // Closing search handle
    m_pDSSearch->CloseSearchHandle(m_hSearch);

    // Releasinf IDirectorySearch interface itself
    m_pDSSearch->Release();

    // Freeing propid array
    delete [] m_pPropIDs;

}


/*====================================================
    static helper functions
=====================================================*/

STATIC HRESULT GetDNGuidFromAdsval(IN const ADSVALUE * padsvalDN,
                                   IN const ADSVALUE * padsvalGuid,
                                   OUT LPWSTR * ppwszObjectDN,
                                   OUT GUID **  ppguidObjectGuid)
/*++
    given adsvalue for DN & GUID, returns the appropriate values
--*/
{
    AP<WCHAR> pwszObjectDN;
    P<GUID>  pguidObjectGuid;

    //
    // copy dn
    //
    if ((padsvalDN->dwType != ADSTYPE_DN_STRING) ||
        (!padsvalDN->DNString))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1920);
    }
    pwszObjectDN = new WCHAR[ 1+wcslen(padsvalDN->DNString)];
    wcscpy(pwszObjectDN, padsvalDN->DNString);

    //
    // copy guid
    //
    if ((padsvalGuid->dwType != ADSTYPE_OCTET_STRING) ||
        (padsvalGuid->OctetString.dwLength != sizeof(GUID)))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1930);
    }
    pguidObjectGuid = new GUID;
    memcpy(pguidObjectGuid, padsvalGuid->OctetString.lpValue, sizeof(GUID));

    //
    // return values
    //
    *ppwszObjectDN    = pwszObjectDN.detach();
    *ppguidObjectGuid = pguidObjectGuid.detach();
    return MQ_OK;
}


STATIC HRESULT GetDNGuidFromSearchObj(IN IDirectorySearch  *pSearchObj,
                                      ADS_SEARCH_HANDLE  hSearch,
                                      OUT LPWSTR * ppwszObjectDN,
                                      OUT GUID **  ppguidObjectGuid)
/*++
    Given a search object and handle, returns the DN & GUID of object in current row
    It is assumed that these props were requested in the search.
--*/
{
    AP<WCHAR> pwszObjectDN;
    P<GUID>  pguidObjectGuid;
    ADS_SEARCH_COLUMN columnDN, columnGuid;
    HRESULT hr;

    //
    // Get DN
    //
    hr = pSearchObj->GetColumn(hSearch, const_cast<LPWSTR>(x_AttrDistinguishedName), &columnDN);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 740);
    }
    //
    // Make sure the column is freed eventually
    //
    CAutoReleaseColumn cAutoReleaseColumnDN(pSearchObj, &columnDN);

    //
    // Get GUID
    //
    hr = pSearchObj->GetColumn(hSearch, const_cast<LPWSTR>(x_AttrObjectGUID), &columnGuid);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 750);
    }
    //
    // Make sure the column is freed eventually
    //
    CAutoReleaseColumn cAutoReleaseColumnGuid(pSearchObj, &columnGuid);

    //
    // get the DN & guid from the ADSVALUE structs
    //
    hr = GetDNGuidFromAdsval(columnDN.pADsValues,
                             columnGuid.pADsValues,
                             &pwszObjectDN,
                             &pguidObjectGuid);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 760);
    }

    //
    // return values
    //
    *ppwszObjectDN    = pwszObjectDN.detach();
    *ppguidObjectGuid = pguidObjectGuid.detach();
    return MQ_OK;
}


STATIC HRESULT GetDNGuidFromIADs(IN IADs * pIADs,
                                 OUT LPWSTR * ppwszObjectDN,
                                 OUT GUID **  ppguidObjectGuid)
/*++
    Given an IADs object, returns the DN & GUID of the object
--*/
{
    AP<WCHAR> pwszObjectDN;
    P<GUID>   pguidObjectGuid;
    CAutoVariant varDN, varGuid;
    HRESULT hr;
    BS bsName;

    //
    // Get DN
    //
    bsName = x_AttrDistinguishedName;
    hr = pIADs->Get(bsName, &varDN);
    LogTraceQuery(bsName, s_FN, 769);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 770);
    }

    //
    // Get GUID
    //
    bsName = x_AttrObjectGUID;
    hr = pIADs->Get(bsName, &varGuid);
    LogTraceQuery(bsName, s_FN, 779);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 780);
    }

    //
    // copy DN
    //
    VARIANT * pvarTmp = &varDN;
    if ((pvarTmp->vt != VT_BSTR) ||
        (!pvarTmp->bstrVal))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1940);
    }
    pwszObjectDN = new WCHAR[  1+wcslen(pvarTmp->bstrVal)];
    wcscpy(pwszObjectDN, pvarTmp->bstrVal);

    //
    // copy GUID
    //
    pvarTmp = &varGuid;
    if ((pvarTmp->vt != (VT_ARRAY | VT_UI1)) ||
        (!pvarTmp->parray))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1950);
    }
    else if (SafeArrayGetDim(pvarTmp->parray) != 1)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1960);
    }
    LONG lLbound, lUbound;
    if (FAILED(SafeArrayGetLBound(pvarTmp->parray, 1, &lLbound)) ||
        FAILED(SafeArrayGetUBound(pvarTmp->parray, 1, &lUbound)))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1970);
    }
    if (lUbound - lLbound + 1 != sizeof(GUID))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1980);
    }
    pguidObjectGuid = new GUID;
    LPBYTE pTmp = (LPBYTE)((GUID *)pguidObjectGuid);
    for (LONG lTmp = lLbound; lTmp <= lUbound; lTmp++)
    {
        hr = SafeArrayGetElement(pvarTmp->parray, &lTmp, pTmp);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 790);
        }
        pTmp++;
    }

    //
    // return values
    //
    *ppwszObjectDN    = pwszObjectDN.detach();
    *ppguidObjectGuid = pguidObjectGuid.detach();
    return MQ_OK;
}

static HRESULT VerifyObjectCategory( IN IADs * pIADs,
                                  IN const WCHAR * pwcsExpectedCategory
                                 )
/*++
    Given an IADs object, verify that its category is the same as the expected one
--*/
{
    CAutoVariant varCategory;
    HRESULT hr;
    BS bsName;

    //
    // Get the object caegory
    //
    bsName = x_AttrObjectCategory;
    hr = pIADs->Get(bsName, &varCategory);
    if (FAILED(hr))
    {
        return hr;
    }


    VARIANT * pvarTmp = &varCategory;
    if ((pvarTmp->vt != VT_BSTR) ||
        (!pvarTmp->bstrVal))
    {
        ASSERT(("Wrong object category variant", 0));
        return MQ_ERROR_DS_ERROR;
    }
    if ( 0 != _wcsicmp(pvarTmp->bstrVal, pwcsExpectedCategory))
    {
        return MQ_ERROR_NOT_A_CORRECT_OBJECT_CLASS;
    }
    return MQ_OK;

}


//
//BUGBUG: Need to add logic of translation routine
//          And fix logic of returning props
//
HRESULT CAdsi::SetObjectSecurity(
        IN  IADs                *pIADs,             // object's IADs pointer
		IN  const BSTR			 bs,			 	// property name
        IN  const MQPROPVARIANT *pMqVar,		 	// value in MQ PROPVAL format
        IN  ADSTYPE              adstype,		 	// required NTDS type
        IN  const DWORD          dwObjectType,      // MSMQ1.0 obj type
        IN  SECURITY_INFORMATION seInfo,            // security information
        IN  PSID                 pComputerSid )     // SID of computer object.
/*++
    Abstract:

    Parameters:

    Returns:

--*/
{
    HRESULT  hr;
    R<IDirectoryObject> pDirObj = NULL;
    R<IADsObjectOptions> pObjOptions = NULL ;

	ASSERT(wcscmp(bs, L"nTSecurityDescriptor") == 0);
	ASSERT(adstype == ADSTYPE_NT_SECURITY_DESCRIPTOR);
    ASSERT(seInfo != 0) ;

	// Get IDirectoryObject interface pointer
    hr = pIADs->QueryInterface (IID_IDirectoryObject,(LPVOID *) &pDirObj);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }

	//
    // Get IADsObjectOptions interface pointer and
    // set ObjectOption, specifying the SECURITY_INFORMATION we want to set.
    //
    hr = pDirObj->QueryInterface (IID_IADsObjectOptions,(LPVOID *) &pObjOptions);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 170);
    }

    VARIANT var ;
    var.vt = VT_I4 ;
    var.ulVal = (ULONG) seInfo ;

    hr = pObjOptions->SetOption( ADS_OPTION_SECURITY_MASK, var ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 181);
    }

    //
    // Convert security descriptor to NT5 format.
    //
    BYTE   *pBlob = pMqVar->blob.pBlobData;
    DWORD   dwSize = pMqVar->blob.cbSize;

#if 0
    //
    // for future checkin of replication service cross domains.
    //
    PSID  pLocalReplSid = NULL ;
    if ((dwObjectType == MQDS_QUEUE) || (dwObjectType == MQDS_MACHINE))
    {
        hr = GetMyComputerSid( FALSE, //   fQueryADS
                               (BYTE **) &pLocalReplSid ) ;
        //
        // Ignore return value.
        //
        if (FAILED(hr))
        {
            ASSERT(0) ;
            pLocalReplSid = NULL ;
        }
    }
#endif

    P<BYTE>  pSD = NULL ;
    DWORD    dwSDSize = 0 ;
    hr = MQSec_ConvertSDToNT5Format( dwObjectType,
                                     (SECURITY_DESCRIPTOR*) pBlob,
                                     &dwSDSize,
                                     (SECURITY_DESCRIPTOR **) &pSD,
                                     e_DoNotChangeDaclDefault,
                                     pComputerSid /*,
                                     pLocalReplSid*/ ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 32);
    }
    else if (hr != MQSec_I_SD_CONV_NOT_NEEDED)
    {
        pBlob = pSD ;
        dwSize = dwSDSize ;
    }
    else
    {
        ASSERT(pSD == NULL) ;
    }

    // Set properties
	ADSVALUE adsval;
	adsval.dwType   = ADSTYPE_NT_SECURITY_DESCRIPTOR;
	adsval.SecurityDescriptor.dwLength = dwSize ;
    adsval.SecurityDescriptor.lpValue  = pBlob ;

    ADS_ATTR_INFO AttrInfo;
	DWORD  dwNumAttributesModified = 0;

    AttrInfo.pszAttrName   = bs;
    AttrInfo.dwControlCode = ADS_ATTR_UPDATE;
    AttrInfo.dwADsType     = adstype;
    AttrInfo.pADsValues    = &adsval;
    AttrInfo.dwNumValues   = 1;

    hr = pDirObj->SetObjectAttributes(
                    &AttrInfo,
					1,
					&dwNumAttributesModified);

    if (1 != dwNumAttributesModified)
    {
        hr = MQ_ERROR_ACCESS_DENIED;
    }

    return LogHR(hr, s_FN, 40);
}




BOOL  CAdsi::NeedToConvertSecurityDesc( PROPID propID )
/*++
    Abstract:

    Parameters:

    Returns:

--*/
{
    if (propID == PROPID_Q_OBJ_SECURITY)
    {
        return FALSE ;
    }
    else if (propID == PROPID_QM_OBJ_SECURITY)
    {
        return FALSE ;
    }

    return TRUE ;
}

HRESULT CAdsi::GetObjSecurityFromDS(
        IN  IADs                 *pIADs,        // object's IADs pointer
		IN  BSTR        	      bs,		    // property name
		IN  const PROPID	      propid,	    // property ID
        IN  SECURITY_INFORMATION  seInfo,       // security information
        OUT MQPROPVARIANT        *pPropVar )     // attribute values
/*++
    Abstract:
	Use IDirectoryObject to retrieve security descriptor from ADS.
	Only this interface return it in the good old SECURITY_DESCRIPTOR
	format.

    Parameters:

    Returns:

--*/
{
    ASSERT(seInfo != 0) ;

    HRESULT  hr;
    R<IDirectoryObject> pDirObj = NULL;
    R<IADsObjectOptions> pObjOptions = NULL ;

	// Get IDirectoryObject interface pointer
    hr = pIADs->QueryInterface (IID_IDirectoryObject,(LPVOID *) &pDirObj);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100);
    }

	//
    // Get IADsObjectOptions interface pointer and
    // set ObjectOption, specifying the SECURITY_INFORMATION we want to get.
    //
    hr = pDirObj->QueryInterface (IID_IADsObjectOptions,(LPVOID *) &pObjOptions);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 110);
    }

    VARIANT var ;
    var.vt = VT_I4 ;
    var.ulVal = (ULONG) seInfo ;

    hr = pObjOptions->SetOption( ADS_OPTION_SECURITY_MASK, var ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 120);
    }

    // Get properties
	PADS_ATTR_INFO pAttr;
	DWORD  cp2;

    hr = pDirObj->GetObjectAttributes(
                    &bs,
                    1,
                    &pAttr,
                    &cp2);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 130);
    }
	ADsFreeAttr pClean( pAttr);

    if (1 != cp2)
    {
        return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 10);
    }

    // Translate property values to MQProps
    hr = AdsiVal2MqPropVal(pPropVar,
                           propid,
                           pAttr->dwADsType,
                           pAttr->dwNumValues,
                           pAttr->pADsValues);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 140);
    }

    return MQ_OK;
}


HRESULT CAdsi::GetObjectSecurityProperty(
            IN  AD_PROVIDER             eProvider,
            IN  CBasicObjectType*       pObject,
            IN  SECURITY_INFORMATION    seInfo,           
            IN  const PROPID 		    prop,           
            OUT MQPROPVARIANT *		    pVar
            )
{
    HRESULT   hr;
    R<IADs>   pAdsObj;

    //
    // Bind to the object either by GUID or by name
    //
    hr = BindToObject(
                eProvider,
                pObject->GetADContext(),
                pObject->GetDomainController(),
                pObject->IsServerName(),
                pObject->GetObjectDN(),
                pObject->GetObjectGuid(),
                IID_IADs,
                (VOID *)&pAdsObj
                );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 185);
    }
    if ( eProvider == adpDomainController)
    {
        pObject->ObjectWasFoundOnDC();
    }

    //
    // Get property info
    //
    const translateProp *pTranslate;
    if(!g_PropDictionary.Lookup(prop, pTranslate))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1475);
    }

    //
    // Get the security property
    //
    BS bsName(pTranslate->wcsPropid);

    hr = GetObjSecurityFromDS(
                        pAdsObj.get(),
                        bsName,
                        prop,
                        seInfo,
                        pVar);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 191);
    }
    if (NeedToConvertSecurityDesc(prop))
    {
        //
        // Translate security descriptor into NT4 format.
        //
        DWORD dwSD4Len = 0 ;
        SECURITY_DESCRIPTOR *pSD4 ;
        hr = MQSec_ConvertSDToNT4Format(
                      pObject->GetMsmq1ObjType(),
                     (SECURITY_DESCRIPTOR*) pVar->blob.pBlobData,
                      &dwSD4Len,
                      &pSD4,
                      seInfo ) ;
        ASSERT(SUCCEEDED(hr)) ;

        if (SUCCEEDED(hr) && (hr != MQSec_I_SD_CONV_NOT_NEEDED))
        {
            delete [] pVar->blob.pBlobData;
            pVar->blob.pBlobData = (BYTE*) pSD4 ;
            pVar->blob.cbSize = dwSD4Len ;
            pSD4 = NULL ;
        }
        else
        {
            ASSERT(pSD4 == NULL) ;
        }
    }

    return LogHR(hr, s_FN, 1476);
}

        
HRESULT CAdsi::SetObjectSecurityProperty(
            IN  AD_PROVIDER             eProvider,
            IN  CBasicObjectType*       pObject,
            IN  SECURITY_INFORMATION    seInfo,           
            IN  const PROPID 		    prop,           
            IN  const MQPROPVARIANT *	pVar,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            )
{
    HRESULT               hr;
    ASSERT( eProvider != adpGlobalCatalog);

    R<IADs>   pAdsObj = NULL;

    hr = BindToObject(
                eProvider,
                pObject->GetADContext(),
                pObject->GetDomainController(),
                pObject->IsServerName(),
                pObject->GetObjectDN(),
                pObject->GetObjectGuid(),
                IID_IADs,
                (VOID *)&pAdsObj
                );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 2210);
    }
    if ( eProvider == adpDomainController)
    {
        pObject->ObjectWasFoundOnDC();
    }
    //
    // Get current security info of the object in W2K format
    //
    const translateProp *pTranslate;
    if(!g_PropDictionary.Lookup(prop, pTranslate))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 2475);
    }
    //
    //  Get current object security value
    //
    BS bsName(pTranslate->wcsPropid);
    MQPROPVARIANT varOldSecurity;

    hr = GetObjSecurityFromDS(
                pAdsObj.get(),
                bsName,
                prop,
                seInfo,
                &varOldSecurity
                );
    if ( FAILED(hr))
    {
        return LogHR(hr, s_FN, 381);
    }

    AP<BYTE> pObjSD = varOldSecurity.blob.pBlobData;

    ASSERT(pObjSD && IsValidSecurityDescriptor(pObjSD));
    AP<BYTE> pOutSec;

    //
    // Merge the input descriptor with object descriptor.
    // Replace the old components in obj descriptor  with new ones from
    // input descriptor.
    //
    hr = MQSec_MergeSecurityDescriptors(
            pObject->GetMsmq1ObjType(),
            seInfo,
            pVar->blob.pBlobData,
            (PSECURITY_DESCRIPTOR)pObjSD,
            (PSECURITY_DESCRIPTOR*)&pOutSec
            );

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 401);
    }
    ASSERT(pOutSec && IsValidSecurityDescriptor(pOutSec));

    PROPVARIANT PropVar;

    PropVar.vt = VT_BLOB;
    PropVar.blob.pBlobData = pOutSec ;
    PropVar.blob.cbSize = GetSecurityDescriptorLength(pOutSec);

    //
	// Set the security property
    //
    hr = SetObjectSecurity(
                pAdsObj.get(),          
		        bsName,			 
                &PropVar,		 	
                pTranslate->vtDS,	
                pObject->GetMsmq1ObjType(),    
                seInfo,     
                NULL            // pComputerSid
                );  
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 2240);
    }
    //
    // get object info if requested. don't fail if the request fails,
    // just mark the failure in the request's status
    //
    if (pObjInfoRequest)
    {
        pObjInfoRequest->hrStatus =
              GetObjectPropsCached( pAdsObj.get(),
                                    pObject,
                                    pObjInfoRequest->cProps,
                                    pObjInfoRequest->pPropIDs,
                                    pObjInfoRequest->pPropVars );
    }

    if (pParentInfoRequest != NULL)
    {
        pParentInfoRequest->hrStatus =
            GetParentInfo(
                pObject,
                pAdsObj.get(),
                pParentInfoRequest
                );
            
    }

    return MQ_OK;

}


HRESULT CAdsi::GetADsPathInfo(
            IN  LPCWSTR                 pwcsADsPath,
            OUT PROPVARIANT *           pVar,
            OUT eAdsClass *             pAdsClass
            )
/*++

Routine Description:
    The routine gets some format-name related info about the specified 
    object

Arguments:
	LPCWSTR                 pwcsADsPath - object pathname
	const PROPVARIANT       pVar - property values
    eAdsClass *             pAdsClass - indication about the object class

Return Value
	HRESULT

--*/
{
    //
    // Bind to object
    //
    R<IADs> pIADs;
    HRESULT hr = ADsOpenObject( 
					pwcsADsPath,
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**)&pIADs.ref()
					);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_TRACE, TEXT("GetADsPathInfo:ADsOpenObject()=%lx"), hr));
        return LogHR(hr, s_FN, 1141);
    }
    //
    // Get object class
    //
    BSTR bstrClass;
    hr = pIADs->get_Class(&bstrClass);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_TRACE, TEXT("GetADsPathInfo:get_Class()=%lx"), hr));
        return LogHR(hr, s_FN, 1142);
    }
    PBSTR pCleanClass(&bstrClass);
    //
    // Check object type
    //
    const WCHAR* pwcsPropName = NULL;
    ADSTYPE     adstype;
    VARTYPE     vartype;

    if (_wcsicmp(bstrClass, MSMQ_QUEUE_CLASS_NAME) == 0)
    {
        //
        // MSMQ Queue object
        //
        pwcsPropName = MQ_Q_INSTANCE_ATTRIBUTE;
        adstype = MQ_Q_INSTANCE_ADSTYPE;
        vartype = VT_CLSID;
        *pAdsClass = eQueue;
    }
    else if (_wcsicmp(bstrClass, MSMQ_DL_CLASS_NAME) == 0)
    {
        //
        // MSMQ DL object
        //
        pwcsPropName = MQ_DL_ID_ATTRIBUTE;
        adstype = MQ_DL_ID_ADSTYPE;
        vartype = VT_CLSID;
        *pAdsClass = eGroup;
	}
    else if (_wcsicmp(bstrClass, MSMQ_QALIAS_CLASS_NAME) == 0)
    {
        //
        // Queue Alias object
        //
        pwcsPropName =  MQ_QALIAS_FORMAT_NAME_ATTRIBUTE;
        adstype = MQ_QALIAS_FORMAT_NAME_ADSTYPE;
        vartype = VT_LPWSTR;
        *pAdsClass = eAliasQueue;
    }
    else
    {
        //
        //  Other objects are not supported
        //
        return  MQ_ERROR_UNSUPPORTED_CLASS;
    }

    CAutoVariant varResult;
    BS bsProp = pwcsPropName;

    hr = pIADs->Get(bsProp, &varResult);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_TRACE, TEXT("GetADsPathInfo:pIADs->Get()/GetEx()=%lx"), hr));
        return LogHR(hr, s_FN, 41);
    }

    //
    // translate to propvariant 
    //
    hr = Variant2MqVal(pVar, &varResult, adstype, vartype);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetADsPathInfo:Variant2MqVal()=%lx"), hr));
        return LogHR(hr, s_FN, 42);
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\adtempl.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    adtempl.h

Abstract:
    Useful templates 

Author:
    ronit hartmann (ronith)

Revision History:
--*/

#ifndef _ADTEMPL_H
#define _ADTEMPL_H

#include "ads.h"
#include "mqadglbo.h"
#include "mqadp.h"


//-----------------------------
//
//  Close AD query handle
//
class CAdQueryHandle
{
public:
    CAdQueryHandle( ): m_Handle(0) 
	{}
	~CAdQueryHandle(); 
    HANDLE * GetPtr();
    HANDLE GetHandle();
    void   SetHandle( IN HANDLE handle);
	
private:
    HANDLE       m_Handle;

};

inline CAdQueryHandle::~CAdQueryHandle()
{
    if ( m_Handle)
    {
        g_AD.LocateEnd( m_Handle);
    }
}

inline void CAdQueryHandle::SetHandle( IN HANDLE handle)
{
    ASSERT( m_Handle == 0);
    m_Handle = handle;
}

inline HANDLE * CAdQueryHandle::GetPtr()
{
    return(&m_Handle);
}
inline HANDLE  CAdQueryHandle::GetHandle()
{
    return(m_Handle);
}


//#pragma warning(disable: 4284)

//-----------------------------
//
//  Auto delete BSTR
//
class PBSTR {
private:
    BSTR * m_p;

public:
    PBSTR() : m_p(0)            {}
    PBSTR(BSTR* p) : m_p(p)     {}
   ~PBSTR()                     {if ( m_p != 0) SysFreeString(*m_p); }

    operator BSTR*() const    { return m_p; }
    //T** operator&()         { return &m_p;}
    //T* operator->() const   { return m_p; }
    //P<T>& operator=(T* p)   { m_p = p; return *this; }
    BSTR* detach()            { BSTR* p = m_p; m_p = 0; return p; }
};


//-----------------------------
//
//  Auto delete of ADs allocated attributes
//
class ADsFreeAttr {
private:
   PADS_ATTR_INFO m_p;

public:
    ADsFreeAttr();
    ADsFreeAttr(PADS_ATTR_INFO p);
   ~ADsFreeAttr();
    // ADsFreeMem is recommended, but only FreeADsMem is defined in adshlp.h

    operator PADS_ATTR_INFO() const   { return m_p; }
    PADS_ATTR_INFO* operator&()       { return &m_p;}
    PADS_ATTR_INFO operator->() const { return m_p; }
};
inline ADsFreeAttr::ADsFreeAttr() : m_p(0)
{}
inline ADsFreeAttr::ADsFreeAttr(PADS_ATTR_INFO p)
             : m_p(p)
{}

inline ADsFreeAttr::~ADsFreeAttr()
{
    if (m_p)
    {
        FreeADsMem(m_p);
    }
}
//-----------------------------
//
//  Auto delete of ADs allocated string
//
class ADsFree {
private:
    WCHAR * m_p;

public:
    ADsFree() : m_p(0)            {}
    ADsFree(WCHAR* p) : m_p(p)    {}
   ~ADsFree()                     {FreeADsStr(m_p);}

    operator WCHAR*() const   { return m_p; }
    WCHAR** operator&()       { return &m_p;}
    WCHAR* operator->() const { return m_p; }
};

//--------------------------------
//
//  Auto delete of ADS_SEARCH_COLUMN array
//
class ADsSearchColumnsFree {
private:
    ADS_SEARCH_COLUMN **m_ppColumns;
    DWORD               m_dwNum;
    IDirectorySearch  * m_pIDirectorySearch;
public:
    ADsSearchColumnsFree( 
            IDirectorySearch * pIDirectorySearch,
            DWORD              dwNum);
    ~ADsSearchColumnsFree();
    ADS_SEARCH_COLUMN * Allocate( DWORD index);
    ADS_SEARCH_COLUMN * Get( DWORD index);
};

inline  ADsSearchColumnsFree::ADsSearchColumnsFree(
            IDirectorySearch * pIDirectorySearch,
            DWORD              dwNum) : 
            m_pIDirectorySearch(pIDirectorySearch)
{
    m_ppColumns = new ADS_SEARCH_COLUMN *[dwNum];
    ADS_SEARCH_COLUMN ** ppColumn = m_ppColumns;
    for (DWORD i = 0 ; i < dwNum; i++, ppColumn++)
    {
        *ppColumn = NULL;    
    }
    m_dwNum = dwNum;
}
inline  ADsSearchColumnsFree::~ADsSearchColumnsFree()
{
    ADS_SEARCH_COLUMN ** ppColumn = m_ppColumns;
    HRESULT hr;
    for (DWORD i = 0; i < m_dwNum; i++, ppColumn++)
    {
        if ( *ppColumn != NULL)
        {
            hr = m_pIDirectorySearch->FreeColumn( *ppColumn);
            ASSERT(SUCCEEDED(hr));       //e.g.wrong column data

            delete *ppColumn;
        }
    }
    delete [] m_ppColumns;
}
inline ADS_SEARCH_COLUMN * ADsSearchColumnsFree::Allocate( DWORD index)
{
    ASSERT( index < m_dwNum);
    ASSERT( m_ppColumns[ index] == NULL);
    ADS_SEARCH_COLUMN * pColumn = new ADS_SEARCH_COLUMN;
    m_ppColumns[ index] = pColumn;
    return pColumn;
}

inline ADS_SEARCH_COLUMN * ADsSearchColumnsFree::Get( DWORD index)
{
    if ( index == x_NoPropertyFirstAppearance)
    {
        return(NULL);
    }
    ASSERT( index < m_dwNum);
    return m_ppColumns[ index];
}



//-----------------------------
//
//  Auto delete of array of strings
//
class CWcsArray {
private:
    DWORD         m_numWcs;
    WCHAR **      m_ppWcs;
    BOOL          m_fNeedRelease;

public:
    CWcsArray(IN DWORD    numWcs,
              IN WCHAR ** ppWcs);

   ~CWcsArray();
   void detach(void)    { m_fNeedRelease = FALSE;}  
};

inline CWcsArray::CWcsArray( IN DWORD    numWcs,
                      IN WCHAR ** ppWcs)
                      : m_numWcs( numWcs),
                        m_ppWcs( ppWcs),
                        m_fNeedRelease( TRUE)
{
    for ( DWORD i = 0 ; i < m_numWcs; i++)
    {
        m_ppWcs[i] = NULL;
    }
}
inline CWcsArray::~CWcsArray()
{
    if (  m_fNeedRelease)
    {
        for (DWORD i = 0; i < m_numWcs; i++)
        {
            delete [] m_ppWcs[i];
        }
    }
}



//
// The CADHResult class is used in order to automatically convert the various
// error codes to Falcon error codes. This is done by defining the assignment
// operator of this class so it converts whatever error code that is assigned
// to objects of this class to a Falcon error code. The casting operator
// from this class to HRESULT, returns the converted error code.
//
class CADHResult
{
public:
    CADHResult(AD_OBJECT eObject);      // Default constructor.
    CADHResult(const CADHResult &);     // Copy constructor
    CADHResult& operator =(HRESULT);    // Assignment operator.
    operator HRESULT();                 // Casting operator to HRESULT type.
    HRESULT GetReal();                  // A method that returns the real error code.

private:
    HRESULT m_hr;           // The converted error code.
    HRESULT m_real;         // The real error code.
    AD_OBJECT m_eObject;    // The type of object .
};

//---------- CADHResult implementation ----------------------------------

inline CADHResult::CADHResult(AD_OBJECT eObject)
                    :m_eObject(eObject)
{
}

inline CADHResult::CADHResult(const CADHResult &hr)
{
    m_hr = hr.m_hr;
    m_real = hr.m_real;
    m_eObject = hr.m_eObject;
}

inline CADHResult& CADHResult::operator =(HRESULT hr)
{
    m_hr = MQADpConvertToMQCode(hr, m_eObject);
    m_real = hr;

    return *this;
}

inline CADHResult::operator HRESULT()
{
    return m_hr;
}

inline HRESULT CADHResult::GetReal()
{
    return m_real;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\confobj.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation 

Module Name:

    confobj.cpp

Abstract:

    Implementation of CMqConfigurationObject class.

Author:

    ronith

--*/
#include "ds_stdh.h"
#include "baseobj.h"
#include "mqattrib.h"
#include "mqadglbo.h"
#include "adtempl.h"
#include "dsutils.h"
#include "mqsec.h"
#include <lmaccess.h>
#include "sndnotif.h"

#include "confobj.tmh"

static WCHAR *s_FN=L"mqad/confobj";

DWORD CMqConfigurationObject::m_dwCategoryLength = 0;
AP<WCHAR> CMqConfigurationObject::m_pwcsCategory = NULL;


CMqConfigurationObject::CMqConfigurationObject( 
                    LPCWSTR         pwcsPathName,
                    const GUID *    pguidObject,
					LPCWSTR			pwcsDomainController,
					bool		    fServerName
                    ) : CBasicObjectType( 
								pwcsPathName, 
								pguidObject,
								pwcsDomainController,
								fServerName
								)
/*++
    Abstract:
	constructor of msmq-configuration object

    Parameters:
    LPCWSTR       pwcsPathName - the object MSMQ name
    const GUID *  pguidObject  - the object unique id
    LPCWSTR       pwcsDomainController - the DC name against
	                             which all AD access should be performed
    bool		  fServerName - flag that indicate if the pwcsDomainController
							     string is a server name

    Returns:
	none

--*/
{
    //
    //  don't assume that the object can be found on DC
    //
    m_fFoundInDC = false;
    //
    //  Keep an indication that never tried to look for
    //  the object in AD ( and therefore don't really know if it can be found
    //  in DC or not)
    //
    m_fTriedToFindObject = false;
    m_fCanBeRetrievedFromGC = true;
}

CMqConfigurationObject::~CMqConfigurationObject()
/*++
    Abstract:
	destructor of site object

    Parameters:
	none

    Returns:
	none
--*/
{
	//
	// nothing to do ( everything is released with automatic pointers
	//
}

HRESULT CMqConfigurationObject::ComposeObjectDN()
/*++
    Abstract:
	Composed distinguished name of the msmq-configuration object

    Parameters:
	none

    Returns:
	none
--*/
{
    if (m_pwcsDN != NULL)
    {
        return MQ_OK;
    }

	HRESULT hr = ComposeFatherDN();
	if (FAILED(hr))
	{
        return LogHR(hr, s_FN, 10);
	}
	ASSERT(m_pwcsParentDN != NULL);


    DWORD Length =
        x_CnPrefixLen +                   // "CN="
        x_MsmqComputerConfigurationLen + 
        1 +                               //","
        wcslen(m_pwcsParentDN) +          
        1;                                // '\0'

    m_pwcsDN= new WCHAR[Length];

    DWORD dw = swprintf(
        m_pwcsDN,
         L"%s%s,%s",   
        x_CnPrefix,
        x_MsmqComputerConfiguration,
        m_pwcsParentDN
        );
    DBG_USED(dw);
    ASSERT(dw < Length);

    return MQ_OK;
}

HRESULT CMqConfigurationObject::ComposeFatherDN()
/*++
    Abstract:
	Composed distinguished name of the parent of msmq-configurtion object

    Parameters:
	none

    Returns:
	none
--*/
{
    //
    //  verify that it wasn't calculated before
    //
    if (m_pwcsParentDN != NULL)
    {
        return MQ_OK;
    }

    ASSERT(m_pwcsPathName != NULL);
    CComputerObject object(m_pwcsPathName, NULL, m_pwcsDomainController, m_fServerName);
    //
    //  we are intrestead in the computer under which there
    //  is an msmq-configuration object.
    //
    object.SetComputerType(eMsmqComputerObject);
    HRESULT hr;
    hr = object.ComposeObjectDN();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }

    DWORD len = wcslen(object.GetObjectDN()) + 1;
    m_pwcsParentDN = new WCHAR[ len];
    wcscpy(m_pwcsParentDN, object.GetObjectDN()); 
    //
    //  set where the object was found according to where
    //  computer object was found.
    //
    m_fFoundInDC = object.ToAccessDC();
    m_fTriedToFindObject = true;

    return MQ_OK;
}

LPCWSTR CMqConfigurationObject::GetRelativeDN()
/*++
    Abstract:
	return the RDN of the msmq-configuration object

    Parameters:
	none

    Returns:
	LPCWSTR msmq-configuration RDN
--*/
{
    return x_MsmqComputerConfiguration;
}

DS_CONTEXT CMqConfigurationObject::GetADContext() const
/*++
    Abstract:
	Returns the AD context where msmq-configuration object should be looked for

    Parameters:
	none

    Returns:
	DS_CONTEXT
--*/
{
    return e_RootDSE;
}

bool CMqConfigurationObject::ToAccessDC() const
/*++
    Abstract:
	returns whether to look for the object in DC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	true or false
--*/
{
    if (!m_fTriedToFindObject)
    {
        return true;
    }
    return m_fFoundInDC;
}

bool CMqConfigurationObject::ToAccessGC() const
/*++
    Abstract:
	returns whether to look for the object in GC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	true or false 
--*/
{   
    if (!m_fTriedToFindObject)
    {
        return m_fCanBeRetrievedFromGC;
    }
    return (!m_fFoundInDC && m_fCanBeRetrievedFromGC);
}

void CMqConfigurationObject::ObjectWasFoundOnDC()
/*++
    Abstract:
	The object was found on DC, set indication not to
    look for it on GC


    Parameters:
	none

    Returns:
	none
--*/
{
    m_fTriedToFindObject = true;
    m_fFoundInDC = true;
}

inline LPCWSTR CMqConfigurationObject::GetObjectCategory() 
/*++
    Abstract:
	prepares and retruns the object category string

    Parameters:
	none

    Returns:
	LPCWSTR object category string
--*/
{
    if (CMqConfigurationObject::m_pwcsCategory == NULL)
    {
        DWORD len = wcslen(g_pwcsSchemaContainer) + wcslen(x_ComputerConfigurationCategoryName) + 2;

		AP<WCHAR> pwcsCategory = new WCHAR[len];
        DWORD dw = swprintf(
			 pwcsCategory,
             L"%s,%s",
             x_ComputerConfigurationCategoryName,
             g_pwcsSchemaContainer
            );
        DBG_USED(dw);
        ASSERT(dw < len);

        if (NULL == InterlockedCompareExchangePointer(
                              &CMqConfigurationObject::m_pwcsCategory.ref_unsafe(), 
                              pwcsCategory.get(),
                              NULL
                              ))
        {
            pwcsCategory.detach();
            CMqConfigurationObject::m_dwCategoryLength = len;
        }
    }

    return CMqConfigurationObject::m_pwcsCategory;
}




DWORD   CMqConfigurationObject::GetObjectCategoryLength()
/*++
    Abstract:
	prepares and retruns the length object category string

    Parameters:
	none

    Returns:
	DWORD object category string length
--*/
{
	//
	//	call GetObjectCategory in order to initailaze category string
	//	and length
	//
	GetObjectCategory();

    return CMqConfigurationObject::m_dwCategoryLength;
}

AD_OBJECT CMqConfigurationObject::GetObjectType() const
/*++
    Abstract:
	returns the object type

    Parameters:
	none

    Returns:
	AD_OBJECT
--*/
{
    return eMACHINE;
}

LPCWSTR CMqConfigurationObject::GetClass() const
/*++
    Abstract:
	returns a string represinting the object class in AD

    Parameters:
	none

    Returns:
	LPCWSTR object class string
--*/
{
    return MSMQ_COMPUTER_CONFIGURATION_CLASS_NAME;
}

DWORD CMqConfigurationObject::GetMsmq1ObjType() const
/*++
    Abstract:
	returns the object type in MSMQ 1.0 terms

    Parameters:
	none

    Returns:
	DWORD 
--*/
{
    return MQDS_MACHINE;
}

bool CMqConfigurationObject::DecideProviderAccordingToRequestedProps(
             IN  const DWORD   cp,
             IN  const PROPID  aProp[  ]
             )
/*++

Routine Description:
    The routine decides to retrieve the msmq-configuration
    properties from the domain-controller or the
    global catalog.

Arguments:
    cp :    number of propids on aProp parameter
    aProp : array of PROPIDs

Return Value:
    true - if the object properties can be retrieved from GC
    false - otherwise

--*/
{
    const translateProp *pTranslate;
    const PROPID * pProp = aProp;

    for ( DWORD i = 0; i < cp; i++, pProp++)
    {
        if (g_PropDictionary.Lookup( *pProp, pTranslate))
        {
            if ((!pTranslate->fPublishInGC) &&
                 (pTranslate->vtDS != ADSTYPE_INVALID))
            {
                return( false);
            }
        }
        else
        {
            ASSERT(0);
        }
    }
    return( true);
}


HRESULT CMqConfigurationObject::GetObjectProperties(
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT  PROPVARIANT         apVar[]
                )
/*++
    Abstract:
	This  routine for retrieves msmq-configuration object properties
	from AD.

    Parameters:
    DWORD        cp			- number of properties
    PROPID       aProp		- the requested properties
    PROPVARIANT  apVar		- the retrieved values

    Returns:
	HRESULT
--*/
{
    //
    //  Decide provider according to requested properties
    //
    m_fCanBeRetrievedFromGC = DecideProviderAccordingToRequestedProps( cp, aProp);

    return CBasicObjectType::GetObjectProperties( cp, aProp, apVar);
}

HRESULT CMqConfigurationObject::DeleteObject(
            MQDS_OBJ_INFO_REQUEST * /* pObjInfoRequest*/,
            MQDS_OBJ_INFO_REQUEST * /* pParentInfoRequest*/
        )
/*++
    Abstract:
	This routine deletes msmq-configuration object.

    Parameters:
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - infomation about the object
    MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - information about the object's parent

    Returns:
	HRESULT
--*/
{
    //
    //  If the computer is MSMQ server, then delete MSMQ-setting
    //  of that computer also.
    //
    HRESULT hr;
    GUID guidComputerId;
    BOOL fServer;

    if ( m_pwcsPathName)
    {
        ASSERT( m_guidObject == GUID_NULL);
        hr = GetUniqueIdOfConfigurationObject(
                    &guidComputerId,
                    &fServer);

        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("CMqConfigurationObject::DeleteObject : cannot find computer %ls"),m_pwcsPathName));
            return LogHR(hr, s_FN, 34);
        }
    }
    else
    {
        ASSERT( m_pwcsPathName == NULL);
        guidComputerId = m_guidObject;
        //
        //  Assume it is a server
        //
        fServer = TRUE;
    }
    //
    //  BUGBUG - transaction !!!
    //

    //
    //  First delete queues
    //
    hr = g_AD.DeleteContainerObjects(
            adpDomainController,
            e_RootDSE,
            m_pwcsDomainController,
            m_fServerName,
            NULL,
            &guidComputerId,
            MSMQ_QUEUE_CLASS_NAME);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 44);
    }

    //
    //  delete MSMQ-configuration object
    //

    hr = g_AD.DeleteObject(
                    adpDomainController,
                    this,
                    NULL,   // lpwcsPathName 
                    &guidComputerId,
                    NULL,	// pObjInfoRequest
                    NULL);	//pParentInfoRequest

    if (FAILED(hr))
    {
        if ( hr == HRESULT_FROM_WIN32(ERROR_DS_CANT_ON_NON_LEAF))
        {
            return LogHR(MQDS_E_MSMQ_CONTAINER_NOT_EMPTY, s_FN, 49);
        }
        return LogHR(hr, s_FN, 53);
    }
    //
    //  delete MSMQ-setting
    //
    if ( fServer)
    {
        hr = DeleteMsmqSetting(
                        &guidComputerId
                        );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 60);
        }
    }
    return(MQ_OK);
}

HRESULT CMqConfigurationObject::GetUniqueIdOfConfigurationObject(
                OUT GUID* const         pguidId,
                OUT BOOL* const         pfServer
                )
/*++

Routine Description:
	The routine retrieves the object guid & if it is a routing or
	DS server

Arguments:
    GUID* const   pguidId - the object guid
    BOOL* const   pfServer - indication if it is arouting or DS server

Return Value:
--*/
{
    ASSERT( m_pwcsPathName != NULL);
    HRESULT hr;


    //
    //  Read the following  properties
    //
    PROPID  prop[] = {PROPID_QM_MACHINE_ID,
                      PROPID_QM_SERVICE_ROUTING,
                      PROPID_QM_SERVICE_DSSERVER};   // [adsrv] PROPID_QM_SERVICE
    const DWORD x_count = sizeof(prop)/sizeof(prop[0]);

    MQPROPVARIANT var[x_count];
    var[0].vt = VT_NULL;
    var[1].vt = VT_NULL;
    var[2].vt = VT_NULL;

    hr = GetObjectProperties(
                x_count,
                prop,
                var);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 70);
    }

    ASSERT( prop[0] == PROPID_QM_MACHINE_ID);
    P<GUID> pClean = var[0].puuid;
    *pguidId = *var[0].puuid;
    ASSERT( prop[1] == PROPID_QM_SERVICE_ROUTING);   
    ASSERT( prop[2] == PROPID_QM_SERVICE_DSSERVER);
    *pfServer = ( (var[1].bVal!=0) || (var[2].bVal!=0)); 
    return(MQ_OK);
}


HRESULT  CMqConfigurationObject::DeleteMsmqSetting(
                IN const GUID *     pguidQMid
              )
/*++

Routine Description:
	This routine deletes all msmq-settings objects associated with
	this configuration object.

Arguments:
    const GUID *  pguidQMid - the object guid of the mq-configuration object

Return Value:
	HRESULT
--*/
{
    //
    //  Find the distinguished name of the msmq-setting
    //
    ADsFree  pwcsConfigurationId;
    HRESULT hr;

    hr = ADsEncodeBinaryData(
        (unsigned char *)pguidQMid,
        sizeof(GUID),
        &pwcsConfigurationId
        );
    if (FAILED(hr))
    {
      return LogHR(hr, s_FN, 80);
    }
    R<CSettingObject> pObject = new CSettingObject( NULL, NULL, m_pwcsDomainController, m_fServerName);
                          
    DWORD dwFilterLen = x_ObjectCategoryPrefixLen +
                        pObject->GetObjectCategoryLength() +
                        x_ObjectCategorySuffixLen + 
                        wcslen(MQ_SET_QM_ID_ATTRIBUTE) +
                        wcslen(pwcsConfigurationId) +
                        13;

    AP<WCHAR> pwcsSearchFilter = new WCHAR[ dwFilterLen];

    DWORD dw = swprintf(
        pwcsSearchFilter,
        L"(&%s%s%s(%s=%s))",
        x_ObjectCategoryPrefix,
        pObject->GetObjectCategory(),
        x_ObjectCategorySuffix,
        MQ_SET_QM_ID_ATTRIBUTE,
        pwcsConfigurationId
        );
    DBG_USED(dw);
    ASSERT(dw < dwFilterLen);


    PROPID prop = PROPID_SET_FULL_PATH;
    CAdQueryHandle hQuery;

    hr = g_AD.LocateBegin(
            searchSubTree,	
            adpDomainController,
            e_SitesContainer,
            pObject.get(),
            NULL,   // pguidSearchBase 
            pwcsSearchFilter,
            NULL,   // pDsSortKey 
            1,
            &prop,
            hQuery.GetPtr());

    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADpDeleteMsmqSetting : Locate begin failed %lx"),hr));
        return LogHR(hr, s_FN, 90);
    }
    //
    //  Read the results ( choose the first one)
    //

    DWORD cp = 1;
    MQPROPVARIANT var;
	HRESULT hr1 = MQ_OK;


    while (SUCCEEDED(hr))
	{
		var.vt = VT_NULL;

		hr  = g_AD.LocateNext(
					hQuery.GetHandle(),
					&cp,
					&var
					);
		if (FAILED(hr))
		{
			DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADpDeleteMsmqSetting : Locate next failed %lx"),hr));
            return LogHR(hr, s_FN, 100);
		}
		if ( cp == 0)
		{
			//
			//  Not found -> nothing to delete.
			//
			return(MQ_OK);
		}
		AP<WCHAR> pClean = var.pwszVal;
		//
		//  delete the msmq-setting object
		//
		hr1 = g_AD.DeleteObject(
						adpDomainController,
                        pObject.get(),
						var.pwszVal,
						NULL,	// pguidUniqueId 
						NULL,	//pObjInfoRequest
						NULL	//pParentInfoRequest
						);


		if (FAILED(hr1))
		{
			//
			//	just report it, and continue to next object
			//
			DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADpDeleteMsmqSetting : failed to delete %ls, hr = %lx"),var.pwszVal,hr1));
		}
	}

    return LogHR(hr1, s_FN, 110);
}

void CMqConfigurationObject::PrepareObjectInfoRequest(
              MQDS_OBJ_INFO_REQUEST** ppObjInfoRequest
              ) const
/*++
    Abstract:
	Prepares a list of properties that should be retrieved from
	AD while creating the object ( for notification or returning 
	the object GUID).

    Parameters:
	OUT  MQDS_OBJ_INFO_REQUEST** ppObjInfoRequest

    Returns:
	none
--*/
{
    //
    //  Override the default routine, for queue returning
    //  of the created object id is supported
    //

    P<MQDS_OBJ_INFO_REQUEST> pObjectInfoRequest = new MQDS_OBJ_INFO_REQUEST;
    CAutoCleanPropvarArray cCleanObjectPropvars;

    
    static PROPID sMachineGuidProps[] = {PROPID_QM_MACHINE_ID, PROPID_QM_FOREIGN};
    pObjectInfoRequest->cProps = ARRAY_SIZE(sMachineGuidProps);
    pObjectInfoRequest->pPropIDs = sMachineGuidProps;
    pObjectInfoRequest->pPropVars =
       cCleanObjectPropvars.allocClean(ARRAY_SIZE(sMachineGuidProps));

    cCleanObjectPropvars.detach();
    *ppObjInfoRequest = pObjectInfoRequest.detach();
}

HRESULT CMqConfigurationObject::RetreiveObjectIdFromNotificationInfo(
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            OUT GUID*                         pObjGuid
            ) const
/*++
    Abstract:
	This  routine, for gets the object guid from
	the MQDS_OBJ_INFO_REQUEST

    Parameters:
    const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
    OUT GUID*                         pObjGuid

    Returns:
--*/
{
    ASSERT(pObjectInfoRequest->pPropIDs[0] == PROPID_QM_MACHINE_ID);

    //
    // bail if info requests failed
    //
    if (FAILED(pObjectInfoRequest->hrStatus))
    {
        LogHR(pObjectInfoRequest->hrStatus, s_FN, 120);
        return MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }
    *pObjGuid = *pObjectInfoRequest->pPropVars[0].puuid;
    return MQ_OK;
}




HRESULT CMqConfigurationObject::CreateInAD(
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN OUT MQDS_OBJ_INFO_REQUEST * pObjectInfoRequest,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
                 )
/*++
    Abstract:
    This routine creates MQDS_MACHINE.
    For independent clients: msmqConfiguration is created under the computer object.
    For servers: in addition to msmqConfiguration, msmqSettings is created under site\servers

    Parameters:
    const DWORD   cp - number of properties        
    const PROPID  *aProp - the propperties
    const MQPROPVARIANT *apVar - properties value
    PSECURITY_DESCRIPTOR    pSecurityDescriptor - SD of the object
    OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - properties to 
							retrieve while creating the object 
    OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - properties 
						to retrieve about the object's parent
    Returns:
	HRESULT
--*/
{
    HRESULT hr ;
    DBG_USED(pParentInfoRequest);
    ASSERT(pParentInfoRequest == NULL) ; // not used at present.

    //
    // Find out the type of service provided by this QM service and
    // the machine's sites
    //
    BOOL fServer = FALSE;
    DWORD dwOldService = SERVICE_NONE;
    const GUID * pSite = NULL;
    DWORD dwNumSites = 0;

    BOOL fRouter = FALSE;
    BOOL fDSServer = FALSE;
    BOOL fDepClServer = FALSE;
    BOOL fSetQmOldService = FALSE;


    bool fForeign = false;

#define MAX_NEW_PROPS  31

    //
    // We will reformat properties to include new server type control and
    // maybe SITE_IDS and maybe computer SID. and QM_SECURITY.
    //
    ASSERT((cp + 6)   < MAX_NEW_PROPS);

    DWORD        cp1 = 0 ;
    PROPID       aProp1[ MAX_NEW_PROPS ];
    PROPVARIANT  apVar1[ MAX_NEW_PROPS ];

    //
    //  We need to handle both new and old setups.
    //  Some may pass PROPID_QM_SITE_ID and some
    //  PROPID_QM_SITE_IDS
    //

    for ( DWORD i = 0; i< cp ; i++)
    {
        switch (aProp[i])
        {
        case PROPID_QM_SERVICE_ROUTING:
            fRouter = (apVar[i].bVal != 0);
            break;

        case PROPID_QM_SERVICE_DSSERVER:
            fDSServer  = (apVar[i].bVal != 0);
            break;

        case PROPID_QM_SERVICE_DEPCLIENTS:
            fDepClServer = (apVar[i].bVal != 0);
            break;

        case PROPID_QM_SITE_IDS:
            pSite = apVar[i].cauuid.pElems;
            dwNumSites = apVar[i].cauuid.cElems;
            break;

        case PROPID_QM_OLDSERVICE:
            dwOldService = apVar[i].ulVal;
            fSetQmOldService  = TRUE;
            break;  

        case PROPID_QM_FOREIGN:
            fForeign = (apVar[i].bVal != 0);
            break;

        default:
            break;

        }
        // Copy property to the new array
        aProp1[cp1] = aProp[i];
        apVar1[cp1] = apVar[i];  // yes, there may be ptrs, but no problem - apVar is here
        cp1++;

    }

    if (fRouter || fDSServer)
    {
        fServer = TRUE; 
    }


    DWORD dwNumofProps = cp1 ;


    CComputerObject objectComputer(m_pwcsPathName, NULL, m_pwcsDomainController, m_fServerName);
    hr = objectComputer.ComposeObjectDN();
    if ( (hr == MQDS_OBJECT_NOT_FOUND) &&
          fForeign)
    {
        hr = CreateForeignComputer(
                    m_pwcsPathName
                    );
        LogHR(hr, s_FN, 128);
        if (SUCCEEDED(hr))
        {
            hr = objectComputer.ComposeObjectDN();
            LogHR(hr, s_FN, 129);
        }
    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 130);
    }

    //
    //  set where the object was found according to where
    //  computer object was found.
    //
    m_fFoundInDC = objectComputer.ToAccessDC();
    m_fTriedToFindObject = true;

    //
    //  Create Computer-MSMQ-Configuration under the computer
    //
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest = NULL;
    MQDS_OBJ_INFO_REQUEST  sMachineInfoRequest;
    CAutoCleanPropvarArray cCleanQmPropvars;
    PROPID sMachineGuidProps[] = {PROPID_QM_MACHINE_ID};

    if (pObjectInfoRequest)
    {
        ASSERT(pObjectInfoRequest->pPropIDs[0] == sMachineGuidProps[0]);

        pObjInfoRequest = pObjectInfoRequest;
    }
    else if (fServer)
    {
        //
        // fetch the QM id while creating it
        //
        sMachineInfoRequest.cProps = ARRAY_SIZE(sMachineGuidProps);
        sMachineInfoRequest.pPropIDs = sMachineGuidProps;
        sMachineInfoRequest.pPropVars =
                 cCleanQmPropvars.allocClean(ARRAY_SIZE(sMachineGuidProps));

        pObjInfoRequest = &sMachineInfoRequest;
    }

    //
    // After msmqConfiguration object is created, Grant the computer account
    // read/write rights on the object. That's necessary in order for the
    // MSMQ service (on the new machine) to be able to update its type and
    // other properties, while it's talking with a domain controller from a
    // different domain.
    //
    // First, read computer object SID from ActiveDirectory.
    //
    PROPID propidSid = PROPID_COM_SID ;
    MQPROPVARIANT   PropVarSid ;
    PropVarSid.vt = VT_NULL ;
    PropVarSid.blob.pBlobData = NULL ;
    P<BYTE> pSid = NULL ;

    hr = objectComputer.GetObjectProperties( 
                                   1,    // cPropIDs
                                   &propidSid,
                                   &PropVarSid ) ;
    if (SUCCEEDED(hr))
    {
        pSid = PropVarSid.blob.pBlobData ;
        aProp1[ dwNumofProps ] = PROPID_COM_SID ;
        apVar1[ dwNumofProps ] = PropVarSid ;
        dwNumofProps++ ;
    }

    //
    // Time to create the default security descriptor.
    //
    P<BYTE> pMachineSD = NULL ;
    hr = SetDefaultMachineSecurity( pSid,
                                   &dwNumofProps,
                                    aProp1,
                                    apVar1,
                                    (PSECURITY_DESCRIPTOR*) &pMachineSD ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 140);
    }
    ASSERT(dwNumofProps < MAX_NEW_PROPS);

    hr = g_AD.CreateObject(
            adpDomainController,
            this,
            x_MsmqComputerConfiguration,     // object name
            objectComputer.GetObjectDN(),   
            dwNumofProps,
            aProp1,
            apVar1,
            pObjInfoRequest,
            NULL	//pParentInfoRequest
			);


    if ( !fServer )
    {
        return LogHR(hr, s_FN, 151);
    }

    //
    //  For servers only!
    //  Find all sites which match this server addresses and create the
    //  MSMQSetting object.
    //

    GUID guidObject;

    if (FAILED(hr))
    {
        if ( hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) ||       // BUGBUG: alexdad
             hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS))  // to throw away after transition
        {
            //
            // The MSMQConfiguration object already exist. So create the
            // MSMQSetting objects. This case may happen, for example, if
            // server setup was terminated before its end.
            // First step, get the MSMQConfiguration guid.
            //
            PROPID       aProp[1] = {PROPID_QM_MACHINE_ID} ;
            PROPVARIANT  apVar[1] ;

            apVar[0].vt = VT_CLSID ;
            apVar[0].puuid = &guidObject ;
            hr =  GetObjectProperties(                                     
                                      1,
                                      aProp,
                                      apVar ) ;
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 160);
            }
        }
        else
        {
            return LogHR(hr, s_FN, 170);
        }
    }
    else
    {
        ASSERT(pObjInfoRequest) ;
        hr = RetreiveObjectIdFromNotificationInfo( pObjInfoRequest,
                                                   &guidObject );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 180);
        }
    }

    hr = CreateMachineSettings(
            dwNumSites,
            pSite,
            fRouter,           
            fDSServer,
            fDepClServer,
            fSetQmOldService,
            dwOldService,
            &guidObject
            );

    return LogHR(hr, s_FN, 190);

#undef MAX_NEW_PROPS
}



HRESULT  CMqConfigurationObject::SetDefaultMachineSecurity(
                                    IN  PSID            pComputerSid,
                                    IN OUT DWORD       *pcp,
                                    IN OUT PROPID       aProp[  ],
                                    IN OUT PROPVARIANT  apVar[  ],
                                    OUT PSECURITY_DESCRIPTOR* ppMachineSD )
/*++
    Abstract:

    Parameters:

    Returns:
	HRESULT
--*/
{
    //
    // If the computer sid is null, then most probably the setup will fail.
    // (that is, if we can't retrieve the computer sid, why would we be able
    // to create the msmqConfiguration object under the computer object.
    // failing to retrieve the sid may be the result of broken trust or because
    // the computer object really does not exist or was not yet replicated).
    // The "good" solution is to completely fail setup right now. But to
    // reduce risks and avoid regressions, let's build a security descriptor
    // without the computer sid and proceed with setup.
    // If setup do succeed, then the msmq service on the machine that run
    // setup may fail to update its own properties, if it need to update them.
    // the admin can always use mmc and add the computer account to the dacl.
    // bug 4950.
    //
    ASSERT(pComputerSid) ;

    //
    // If PROPID_QM_SECURITY already present, then return. This happen
    // in Migration code.
    //
    for (DWORD j = 0 ; j < *pcp ; j++ )
    {
        if (aProp[j] == PROPID_QM_SECURITY)
        {
            return MQ_OK ;
        }
    }

    //
    // See if caller supply a Owner SID. If yes, then this SID is granted
    // full control on the msmq configuration object.
    // This "owner" is usually the user SID that run setup. The "owner" that
    // is retrieved below from the default security descriptor is usually
    // (for clients) the SID of the computer object, as the msmqConfiguration
    // object is created by the msmq service (on client machines).
    //
    PSID pUserSid = NULL ;
    PSID pOwner = pComputerSid;
    for ( j = 0 ; j < *pcp ; j++ )
    {
        if (aProp[j] == PROPID_QM_OWNER_SID)
        {
            aProp[j] = PROPID_QM_DONOTHING ;
            pUserSid = apVar[j].blob.pBlobData ;
            ASSERT(IsValidSid(pUserSid));
            break ;
        }
    }

    AP<BYTE> pCleanUserSid;

    if (pUserSid == NULL)
    {
        HRESULT hr;
        hr = MQSec_GetThreadUserSid(FALSE, (PSID*) &pUserSid, NULL);
        if (hr == HRESULT_FROM_WIN32(ERROR_NO_TOKEN))
        {
            //
            //  Try the process, if the thread doesn't have a token
            //
            hr = MQSec_GetProcessUserSid((PSID*) &pUserSid, NULL);
        }
        if (FAILED(hr))
        {
            LogHR(hr, s_FN, 63);
            return MQ_ERROR_ILLEGAL_USER;
        }
        ASSERT(IsValidSid(pUserSid));
        pCleanUserSid = (BYTE*)pUserSid;
    }
    HRESULT hr;

    PSID pWorldSid = MQSec_GetWorldSid() ;
    ASSERT(IsValidSid(pWorldSid)) ;

    //
    // Build the default machine DACL.
    //
    DWORD dwAclSize = sizeof(ACL)                                +
              (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))) +
              GetLengthSid(pWorldSid)                            +
              GetLengthSid(pOwner) ;

    if (pComputerSid)
    {
        dwAclSize += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                      GetLengthSid(pComputerSid) ;
    }
    if (pUserSid)
    {
        dwAclSize += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                      GetLengthSid(pUserSid) ;
    }

    AP<char> DACL_buff = new char[ dwAclSize ];
    PACL pDacl = (PACL)(char*)DACL_buff;
    InitializeAcl(pDacl, dwAclSize, ACL_REVISION);

    //
    // See if it's a foreign machine. If yes, then allow everyone to create
    // queue. a foreign machine is not a real msmq machine, so there is no
    // msmq service that can create queues on behalf of users that run on
    // that machine.
    // Similarly, check if it's a group on a cluster machine.
    //
    BOOL fAllowEveryoneCreateQ = FALSE ;

    for ( j = 0 ; j < *pcp ; j++ )
    {
        if (aProp[j] == PROPID_QM_FOREIGN)
        {
            if (apVar[j].bVal == FOREIGN_MACHINE)
            {
                fAllowEveryoneCreateQ = TRUE ;
                break ;
            }
        }
        else if (aProp[j] == PROPID_QM_GROUP_IN_CLUSTER)
        {
            if (apVar[j].bVal == MSMQ_GROUP_IN_CLUSTER)
            {
                aProp[j] = PROPID_QM_DONOTHING ;
                fAllowEveryoneCreateQ = TRUE ;
                break ;
            }
        }
    }

    DWORD dwWorldAccess = 0 ;

    if (fAllowEveryoneCreateQ)
    {
        dwWorldAccess = MQSEC_MACHINE_GENERIC_WRITE;
    }
    else
    {
        switch (GetMsmq1ObjType())
        {
        case MQDS_MACHINE:
            dwWorldAccess = MQSEC_MACHINE_WORLD_RIGHTS ;
            break;

        default:
            ASSERT(0);
            break;
        }
    }

    ASSERT(dwWorldAccess != 0) ;

    BOOL fAdd = AddAccessAllowedAce( pDacl,
                                     ACL_REVISION,
                                     dwWorldAccess,
                                     pWorldSid );
    ASSERT(fAdd) ;

    //
    // Add the owner with full control.
    //
    fAdd = AddAccessAllowedAce( pDacl,
                                ACL_REVISION,
                                MQSEC_MACHINE_GENERIC_ALL,
                                pOwner);
    ASSERT(fAdd) ;

    //
    // Add the computer account.
    //
    if (pComputerSid)
    {
        fAdd = AddAccessAllowedAce( pDacl,
                                    ACL_REVISION,
                                    MQSEC_MACHINE_SELF_RIGHTS,
                                    pComputerSid);
        ASSERT(fAdd) ;
    }

    if (pUserSid)
    {
        fAdd = AddAccessAllowedAce( pDacl,
                                    ACL_REVISION,
                                    MQSEC_MACHINE_GENERIC_ALL,
                                    pUserSid);
        ASSERT(fAdd) ;
    }

    //
    // build absolute security descriptor.
    //
    SECURITY_DESCRIPTOR  sd ;
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    BOOL bRet;

    bRet = SetSecurityDescriptorDacl(&sd, TRUE, pDacl, TRUE);
    ASSERT(bRet);

    //
    // Convert the descriptor to a self relative format.
    //
    DWORD dwSDLen = 0;
    hr = MQSec_MakeSelfRelative( (PSECURITY_DESCRIPTOR) &sd,
                                  ppMachineSD,
                                 &dwSDLen ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 24);
    }
    ASSERT(dwSDLen != 0) ;

    aProp[ *pcp ] = PROPID_QM_SECURITY;
    apVar[ *pcp ].vt = VT_BLOB;
    apVar[ *pcp ].blob.cbSize = dwSDLen;
    apVar[ *pcp ].blob.pBlobData = (BYTE*) *ppMachineSD ;
    (*pcp)++ ;

    //
    //  specify that the SD contains only DACL info
    //
    aProp[ *pcp ] = PROPID_QM_SECURITY_INFORMATION ;
    apVar[ *pcp ].vt = VT_UI4 ;
    apVar[ *pcp ].ulVal = DACL_SECURITY_INFORMATION ;
    (*pcp)++ ;

    return MQ_OK ;
}


HRESULT CMqConfigurationObject::CreateMachineSettings(
            IN DWORD                dwNumSites,
            IN const GUID *         pSite,
            IN BOOL                 fRouter,
            IN BOOL                 fDSServer,
            IN BOOL                 fDepClServer,
            IN BOOL                 fSetQmOldService,
            IN DWORD                dwOldService,
            IN  const GUID *        pguidObject
            )
/*++

Routine Description:
    This routine creates settings object in each of the server's sites.

Arguments:

Return Value:
--*/
{
    HRESULT hr;
    //
    //  Prepare the attributes of the setting object
    //
    DWORD dwNumofProps = 0 ;
    PROPID aSetProp[20];
    MQPROPVARIANT aSetVar[20];


    aSetProp[ dwNumofProps ] = PROPID_SET_QM_ID;
    aSetVar[ dwNumofProps ].vt = VT_CLSID;
    aSetVar[ dwNumofProps ].puuid =  const_cast<GUID *>(pguidObject);
    dwNumofProps++ ;

    aSetProp[dwNumofProps] = PROPID_SET_SERVICE_ROUTING;
    aSetVar[dwNumofProps].vt   = VT_UI1;
    aSetVar[dwNumofProps].bVal = (UCHAR)fRouter;
    dwNumofProps++;

    aSetProp[dwNumofProps] = PROPID_SET_SERVICE_DSSERVER;
    aSetVar[dwNumofProps].vt   = VT_UI1;
    aSetVar[dwNumofProps].bVal = (UCHAR)fDSServer;
    dwNumofProps++;

    aSetProp[dwNumofProps] = PROPID_SET_SERVICE_DEPCLIENTS;
    aSetVar[dwNumofProps].vt   = VT_UI1;
    aSetVar[dwNumofProps].bVal = (UCHAR)fDepClServer;
    dwNumofProps++;

    if (fSetQmOldService)
    {
        aSetProp[dwNumofProps] = PROPID_SET_OLDSERVICE;
        aSetVar[dwNumofProps].vt   = VT_UI4;
        aSetVar[dwNumofProps].ulVal = dwOldService;
        dwNumofProps++;
    }

    ASSERT(dwNumofProps <= 20) ;

    WCHAR *pwcsServerNameNB = m_pwcsPathName;
    AP<WCHAR> pClean;
    //
    //  Is the computer name specified in DNS format ?
    //  If so, find the NetBios name and create the server object with
    //  "netbios" name, to be compatible with the way servers objects
    //  are created by dcpromo.
    //
    WCHAR * pwcsEndMachineName = wcschr( m_pwcsPathName, L'.');
    if ( pwcsEndMachineName != NULL)
    {
        pClean = new WCHAR[ pwcsEndMachineName - m_pwcsPathName + 1 ];
        wcsncpy( pClean, m_pwcsPathName, pwcsEndMachineName - m_pwcsPathName);
        pClean[pwcsEndMachineName - m_pwcsPathName] = L'\0';
        pwcsServerNameNB = pClean;
    }


    //
    //  Create a settings object in each of the server's sites
    //
    ASSERT(dwNumSites > 0);
    for ( DWORD i = 0; i < dwNumSites ; i++)
    {
        PROPVARIANT varSite;
        varSite.vt = VT_NULL;
        PROPID propSite = PROPID_S_FULL_NAME;
        AP<WCHAR> pwcsSiteName;
        //
        //  Translate site-id to site name
        //
        CSiteObject objectSite(NULL, &pSite[i], m_pwcsDomainController, m_fServerName);
        hr = objectSite.GetObjectProperties(
            1,
            &propSite,
            &varSite
            );
        if (FAILED(hr))
        {
            //
            //  BUGBUG - to clean computer configuration & server objects
            //
            return LogHR(hr, s_FN, 23);
        }
        pwcsSiteName = varSite.pwszVal;
        DWORD len = wcslen(pwcsSiteName);
        const WCHAR x_wcsCnServers[] =  L"CN=Servers,";
        const DWORD x_wcsCnServersLength = (sizeof(x_wcsCnServers)/sizeof(WCHAR)) -1;
        AP<WCHAR> pwcsServersContainer =  new WCHAR [ len + x_wcsCnServersLength + 1];
        swprintf(
             pwcsServersContainer,
             L"%s%s",
             x_wcsCnServers,
             pwcsSiteName
             );

        //
        //  create MSMQ-Setting & server in the site container
        //
        PROPID prop = PROPID_SRV_NAME;
        MQPROPVARIANT var;
        var.vt = VT_LPWSTR;
        var.pwszVal = pwcsServerNameNB;
        CServerObject objectServer(NULL, NULL, m_pwcsDomainController, m_fServerName);

        hr = g_AD.CreateObject(
                adpDomainController,
                &objectServer,
                pwcsServerNameNB,        // object name (server netbiod name).
                pwcsServersContainer,    // parent name
                1,
                &prop,
                &var,
                NULL, // pObjInfoRequest
                NULL  // pParentInfoRequest
				);

        if (FAILED(hr) && ( hr != HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) &&   //BUGBUG alexdad: to throw after transition
                          ( hr != HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS))    ) // if server object exists it is ok
        {
            //
            //  BUGBUG - to clean computer configuration
            //
            return LogHR(hr, s_FN, 33);
        }

        AP<WCHAR> pwcsServerNameDN; // full distinguished name of server.
        hr = MQADpComposeName(
                            pwcsServerNameNB,
                            pwcsServersContainer,
                            &pwcsServerNameDN);
        if (FAILED(hr))
        {
            //
            //  BUGBUG - to clean computer configuration & server objects
            //
           return LogHR(hr, s_FN, 43);
        }

        CSettingObject objectSetting(NULL, NULL, m_pwcsDomainController, m_fServerName);
        hr = g_AD.CreateObject(
                adpDomainController,
                &objectSetting,
                x_MsmqSettingName,         // object name
                pwcsServerNameDN,          // parent name
                dwNumofProps,
                aSetProp,
                aSetVar,
                NULL, //pObjInfoRequest
                NULL  //pParentInfoRequest
				);

        //
        //  If the object exists :Delete the object, and re-create it
        //  ( this can happen, if msmq-configuration was deleted and
        //   msmq-settings was not)
        //
        if ( hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS))
        {
            DWORD dwSettingLen =  wcslen(pwcsServerNameDN) +
                                  x_MsmqSettingNameLen     +
                                  x_CnPrefixLen + 2 ;
            AP<WCHAR> pwcsSettingObject = new WCHAR[ dwSettingLen ] ;
            DWORD dw = swprintf(
                 pwcsSettingObject,
                 L"%s%s,%s",
                 x_CnPrefix,
                 x_MsmqSettingName,
                 pwcsServerNameDN
                 );
            DBG_USED(dw);
            ASSERT( dw < dwSettingLen);

            hr = g_AD.DeleteObject(
                    adpDomainController,
                    &objectSetting,
                    pwcsSettingObject,
                    NULL,
                    NULL,
                    NULL);

            if (SUCCEEDED(hr))
            {
                hr = g_AD.CreateObject(
                        adpDomainController,
                        &objectSetting,
                        x_MsmqSettingName,         // object name
                        pwcsServerNameDN,          // parent name
                        dwNumofProps,
                        aSetProp,
                        aSetVar,
                        NULL, //pObjInfoRequest
                        NULL  //pParentInfoRequest
						);
            }
        }
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 50);
        }

    }

    return MQ_OK;
}

HRESULT CMqConfigurationObject::CreateForeignComputer(
                IN  LPCWSTR         pwcsPathName
                                    )
/*++

Routine Description:
    This routine creates computer object for a specific MSMQ-machine.

Arguments:
	LPCWSTR	pwcsPathName - the computer object name

Return Value:
--*/
{

    //
    // The PROPID_COM_SAM_ACCOUNT contains the first MAX_COM_SAM_ACCOUNT_LENGTH (19)
    // characters of the computer name, as unique ID. (6295 - ilanh - 03-Jan-2001)
    //
	DWORD len = __min(wcslen(pwcsPathName), MAX_COM_SAM_ACCOUNT_LENGTH);
    AP<WCHAR> pwcsMachineNameWithDollar = new WCHAR[len + 2];
	wcsncpy(pwcsMachineNameWithDollar, pwcsPathName, len);
	pwcsMachineNameWithDollar[len] = L'$';
	pwcsMachineNameWithDollar[len + 1] = L'\0';

    const DWORD xNumCreateCom = 2;
    PROPID propCreateComputer[xNumCreateCom];
    PROPVARIANT varCreateComputer[xNumCreateCom];
    DWORD j = 0;
    propCreateComputer[ j] = PROPID_COM_SAM_ACCOUNT;
    varCreateComputer[j].vt = VT_LPWSTR;
    varCreateComputer[j].pwszVal = pwcsMachineNameWithDollar;
    j++;

    propCreateComputer[j] = PROPID_COM_ACCOUNT_CONTROL ;
    varCreateComputer[j].vt = VT_UI4 ;
    varCreateComputer[j].ulVal = DEFAULT_COM_ACCOUNT_CONTROL ;
    j++;
    ASSERT(j == xNumCreateCom);


    CComputerObject object(pwcsPathName, NULL, m_pwcsDomainController, m_fServerName);
    HRESULT hr;
    hr = object.ComposeFatherDN();
	if (FAILED(hr))
	{
        return LogHR(hr, s_FN, 20);
	}
    hr = g_AD.CreateObject(
            adpDomainController,
            &object,
            pwcsPathName,
            object.GetObjectParentDN(),
            j,
            propCreateComputer,
            varCreateComputer,
            NULL, // pObjInfoRequest
            NULL  // pParentInfoRequest
			);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }
    //
    //  Get full path name again
    //
    hr = object.ComposeObjectDN();
    if (SUCCEEDED(hr))
    {
        //
        // Grant the user creating the computer account the permission to
        // create child object (msmqConfiguration). that was done by the
        // DS itself by default up to beta3, and then disabled.
        // Ignore errors. If caller is admin, then the security setting
        // is not needed. If he's a non-admin, then you can always use
        // mmc and grant this permission manually. so go on even if this
        // call fail.
        //
        HRESULT hr1 = MQADpCoreSetOwnerPermission( const_cast<WCHAR*>(object.GetObjectDN()),
                        (ACTRL_DS_CREATE_CHILD | ACTRL_DS_DELETE_CHILD) ) ;
        ASSERT(SUCCEEDED(hr1)) ;
        LogHR(hr1, s_FN, 48);
    }

    return LogHR(hr, s_FN, 40);

}



HRESULT CMqConfigurationObject::SetObjectProperties(
            IN DWORD                  cp,        
            IN const PROPID          *aProp, 
            IN const MQPROPVARIANT   *apVar, 
            IN PSECURITY_DESCRIPTOR    /* pSecurityDescriptor*/,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest, 
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            )
/*++
    Abstract:
	This sets msmq-configuration object properties
	in AD

    Parameters:
    DWORD                  cp - number of properties to set        
    const PROPID *         aProp - the properties ids
    const MQPROPVARIANT*   apVar- properties value
    OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - info to retrieve about the object 
    OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - info to retrieveabout the object's parent

    Returns:
	HRESULT
--*/
{
    HRESULT hr;
    ASSERT(pParentInfoRequest == NULL);
    if (m_pwcsPathName != NULL)
    {
        hr = ComposeObjectDN();
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_TRACE,TEXT("CBasicObjectType::SetObjectProperties : failed to compose full path name %lx"),hr));
            return LogHR(hr, s_FN, 260);
        }
    }

    BOOL    fQmChangedSites = FALSE;
    DWORD   dwSiteIdsIndex = cp;

    for (DWORD i=0; i<cp; i++)
    {
        //
        //  Detect if the QM had change sites, for servers we need to take care of
        //  msmq-settings objects
        //
        if (aProp[i] == PROPID_QM_SITE_IDS)
        {
            fQmChangedSites = TRUE;
            dwSiteIdsIndex = i;
            break;
        }
    }

    if ( fQmChangedSites)
    {
        ASSERT( dwSiteIdsIndex < cp);
        HRESULT hr = SetMachinePropertiesWithSitesChange(
                            cp,
                            aProp,
                            apVar,
                            dwSiteIdsIndex
                            );
        return LogHR(hr, s_FN, 270);
    }

    hr = g_AD.SetObjectProperties(
                    adpDomainController,
                    this,
                    cp,
                    aProp,
                    apVar,
                    pObjInfoRequest,
                    pParentInfoRequest
                    );


    return LogHR(hr, s_FN, 280);
}

HRESULT CMqConfigurationObject::SetMachinePropertiesWithSitesChange(
            IN  const DWORD          cp,
            IN  const PROPID *       pPropIDs,
            IN  const MQPROPVARIANT *pPropVars,
            IN  DWORD                dwSiteIdsIndex
            )
/*++

Routine Description:
    This routine creates a site.

Arguments:

Return Value:
--*/
{
    //
    //  First let's verify that this is a server and the
    //  current sites it belongs to
    //
    const DWORD cNum = 6;
    PROPID prop[cNum] = { PROPID_QM_SERVICE_DSSERVER,
                          PROPID_QM_SERVICE_ROUTING,
                          PROPID_QM_SITE_IDS,
                          PROPID_QM_MACHINE_ID,
                          PROPID_QM_PATHNAME,
                          PROPID_QM_OLDSERVICE};
    PROPVARIANT var[cNum];
    var[0].vt = VT_NULL;
    var[1].vt = VT_NULL;
    var[2].vt = VT_NULL;
    var[3].vt = VT_NULL;
    var[4].vt = VT_NULL;
    var[5].vt = VT_NULL;

    HRESULT hr1 =  GetObjectProperties(
            cNum,
            prop,
            var);
    if (FAILED(hr1))
    {
        return LogHR(hr1, s_FN, 710);
    }
    AP<GUID> pguidOldSiteIds = var[2].cauuid.pElems;
    DWORD dwNumOldSites = var[2].cauuid.cElems;
    P<GUID> pguidMachineId = var[3].puuid;
    AP<WCHAR> pwcsMachineName = var[4].pwszVal;
    BOOL fNeedToOrganizeSettings = FALSE;

    if ( var[0].bVal > 0 ||   // ds server
         var[1].bVal > 0)     // routing server
    {
        fNeedToOrganizeSettings = TRUE;
    }

    //
    //  Set the machine properties
    //
    HRESULT hr;
    hr = CBasicObjectType::SetObjectProperties(
                    cp,
                    pPropIDs,
                    pPropVars,
                    NULL,
                    NULL
                    );


    if ( FAILED(hr) ||
         !fNeedToOrganizeSettings)
    {
        return LogHR(hr, s_FN, 720);
    }

    //
    //  Compare the old and new site lists
    //  and delete or create msmq-settings accordingly
    //
    GUID * pguidNewSiteIds = pPropVars[dwSiteIdsIndex].cauuid.pElems;
    DWORD dwNumNewSites = pPropVars[dwSiteIdsIndex].cauuid.cElems;

    for (DWORD i = 0; i <  dwNumNewSites; i++)
    {
        //
        //  Is it a new site
        //
        BOOL fOldSite = FALSE;
        for (DWORD j = 0; j < dwNumOldSites; j++)
        {
            if (pguidNewSiteIds[i] == pguidOldSiteIds[j])
            {
                fOldSite = TRUE;
                //
                // to indicate that msmq-setting should be left in this site
                //
                pguidOldSiteIds[j] = GUID_NULL;
                break;
            }
        }
        if ( !fOldSite)
        {
            //
            //  create msmq-setting in this new site
            //
            hr1 = CreateMachineSettings(
                        1,  // number sites
                        &pguidNewSiteIds[i], // site guid
                        var[1].bVal > 0, // fRouter
                        var[0].bVal > 0, // fDSServer
                        TRUE,            // fDepClServer
                        TRUE,            // fSetQmOldService
                        var[5].ulVal,    // dwOldService
                        pguidMachineId
                        );


            //
            //  ignore the error
			//	
			//	For foreign site this operation will always fail, because
			//	we don't create servers container and server objects for foreign sites.
			//
			//	For non-foreign sites, we just try the best we can.
            //
        }
    }
    //
    //  Go over th list of old site and for each old site that
    //  is not in-use, delete the msmq-settings
    //
    for ( i = 0; i < dwNumOldSites; i++)
    {
        if (pguidOldSiteIds[i] != GUID_NULL)
        {
            PROPID propSite = PROPID_S_PATHNAME;
            PROPVARIANT varSite;
            varSite.vt = VT_NULL;
            CSiteObject objectSite(NULL, &pguidOldSiteIds[i], m_pwcsDomainController, m_fServerName); 

            hr1 = objectSite.GetObjectProperties(
                        1,
                        &propSite,
                        &varSite);
            if (FAILED(hr1))
            {
                ASSERT(SUCCEEDED(hr1));
                LogHR(hr1, s_FN, 1611);
                continue;
            }
            AP<WCHAR> pCleanSite = varSite.pwszVal;

            //
            //  delete the msmq-setting in this site
            //
            hr1 = DeleteMsmqSettingOfServerInSite(
                        pguidMachineId,
                        varSite.pwszVal
                        );
            ASSERT(SUCCEEDED(hr1));
            LogHR(hr1, s_FN, 1612);

        }
    }

    return MQ_OK;
}

HRESULT  CMqConfigurationObject::DeleteMsmqSettingOfServerInSite(
              IN const GUID *        pguidComputerId,
              IN const WCHAR *       pwcsSite
              )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{

    //
    //  Find the distinguished name of the msmq-setting
    //
    ADsFree  pwcsConfigurationId;
    HRESULT hr;

    hr = ADsEncodeBinaryData(
        (unsigned char *)pguidComputerId,
        sizeof(GUID),
        &pwcsConfigurationId
        );
    if (FAILED(hr))
    {
      return LogHR(hr, s_FN, 940);
    }
    R<CSettingObject> pObject = new CSettingObject(NULL, NULL, m_pwcsDomainController, m_fServerName);
                          
    DWORD dwFilterLen = x_ObjectCategoryPrefixLen +
                        pObject->GetObjectCategoryLength() +
                        x_ObjectCategorySuffixLen + 
                        wcslen(MQ_SET_QM_ID_ATTRIBUTE) +
                        wcslen(pwcsConfigurationId) +
                        13;

    AP<WCHAR> pwcsSearchFilter = new WCHAR[ dwFilterLen];

    DWORD dw = swprintf(
        pwcsSearchFilter,
        L"(&%s%s%s(%s=%s))",
        x_ObjectCategoryPrefix,
        pObject->GetObjectCategory(),
        x_ObjectCategorySuffix,
        MQ_SET_QM_ID_ATTRIBUTE,
        pwcsConfigurationId
        );
    DBG_USED( dw);
    ASSERT( dw < dwFilterLen);

    PROPID prop = PROPID_SET_FULL_PATH;
    CAdQueryHandle hQuery;

    hr = g_AD.LocateBegin(
            searchSubTree,	
            adpDomainController,
            e_SitesContainer,
            pObject.get(),
            NULL,   // pguidSearchBase 
            pwcsSearchFilter,
            NULL,   // pDsSortKey 
            1,
            &prop,
            hQuery.GetPtr());
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADpDeleteMsmqSetting : Locate begin failed %lx"),hr));
        return LogHR(hr, s_FN, 680);
    }
    //
    //  Read the results ( choose the first one)
    //
    while ( SUCCEEDED(hr))
    {
        DWORD cp = 1;
        MQPROPVARIANT var;
        var.vt = VT_NULL;

        hr = g_AD.LocateNext(
                    hQuery.GetHandle(),
                    &cp,
                    &var
                    );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 690);
        }
        if ( cp == 0)
        {
            //
            //  Not found -> nothing to delete.
            //
            return(MQ_OK);
        }
        AP<WCHAR> pClean = var.pwszVal;
        //
        //  Get the parent, which is the server object
        //
        AP<WCHAR> pwcsServerName;
        hr = g_AD.GetParentName(
            adpDomainController,
            e_SitesContainer,
            m_pwcsDomainController,
            m_fServerName,
            var.pwszVal,
            &pwcsServerName);
        if (FAILED(hr))
        {
            continue;
        }
        AP<WCHAR> pwcsServer;

        hr = g_AD.GetParentName(
            adpDomainController,
            e_SitesContainer,
            m_pwcsDomainController,
            m_fServerName,
            pwcsServerName,
            &pwcsServer);
        if (FAILED(hr))
        {
            continue;
        }
        //
        //  Get site name
        //
        AP<WCHAR> pwcsSiteDN;

        hr = g_AD.GetParentName(
            adpDomainController,
            e_SitesContainer,
            m_pwcsDomainController,
            m_fServerName,
            pwcsServer,
            &pwcsSiteDN);
        if (FAILED(hr))
        {
			LogHR( hr, s_FN, 200);
            continue;
        }

        //
        //  Is it the correct site
        //
        DWORD len = wcslen(pwcsSite);
        if ( (!wcsncmp( pwcsSiteDN + x_CnPrefixLen, pwcsSite, len)) &&
             ( pwcsSiteDN[ x_CnPrefixLen + len] == L',') )
        {

            //
            //  delete the msmq-setting object
            //
            CSettingObject objectSetting(NULL, NULL, m_pwcsDomainController, m_fServerName);

            hr = g_AD.DeleteObject(
                            adpDomainController,
                            &objectSetting,
                            var.pwszVal,
                            NULL,
                            NULL, //pObjInfoRequest
                            NULL  //pParentInfoRequest
                            );
            break;
        }
    }

    return LogHR(hr, s_FN, 700);
}


void CMqConfigurationObject::ChangeNotification(
            IN LPCWSTR                        pwcsDomainController,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest
            ) const
/*++
    Abstract:
	Notify QM about an update of QM properties.
    The QM should verify if the queue belongs to the local QM.

    Parameters:
    LPCWSTR                        pwcsDomainController - DC agains which operation was performed
    const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest - information about the QM

    Returns:
	void
--*/
{
    //
    //  make sure that we got the required information for sending 
    //  notification. In case we don't, there is nothing to do
    //
    if (FAILED(pObjectInfoRequest->hrStatus))
    {
        LogHR(pObjectInfoRequest->hrStatus, s_FN, 150);
        return;
    }
    DBG_USED(pObjectParentInfoRequest);
    ASSERT( pObjectParentInfoRequest == NULL);

    ASSERT(pObjectInfoRequest->pPropIDs[1] == PROPID_QM_FOREIGN);

    //
    //  Verify if that it is not a foreign QM
    //
    if (pObjectInfoRequest->pPropVars[1].bVal > 0)
    {
        //
        //  notifications are not sent to foreign computers
        //
        return;
    }
    ASSERT(pObjectInfoRequest->pPropIDs[0] == PROPID_QM_MACHINE_ID);

    g_Notification.NotifyQM(
        neChangeMachine,
        pwcsDomainController,
        pObjectInfoRequest->pPropVars[0].puuid,
        pObjectInfoRequest->pPropVars[0].puuid
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\baseobj.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation 

Module Name:

    Baseobj.cpp

Abstract:

    Implementation of CBasicObjectType class.

Author:

    ronith

--*/
#include "ds_stdh.h"
#include "baseobj.h"
#include "mqadglbo.h"

#include "baseobj.tmh"

static WCHAR *s_FN=L"mqad/baseobj";



LPCWSTR CBasicObjectType::GetObjectDN() const
/*++
    Abstract:
	returns the object distinguished name ( if it was calculated 
	before by calling ComposedObjectDN(), or set).

    Parameters:
	none

    Returns:
	LPCWSTR or NULL
--*/
{
    return m_pwcsDN;
}

LPCWSTR CBasicObjectType::GetObjectParentDN() const 
/*++
    Abstract:
	returns the distinguished name of the object's parent ( if it
	was calculated before by calling ComposedObjectParentDN())

    Parameters:
	none

    Returns:
	LPCWSTR or NULL
--*/
{
    return m_pwcsParentDN;
}

const GUID * CBasicObjectType::GetObjectGuid() const
/*++
    Abstract:
	returns the object unique identifier if it is known

    Parameters:
	none

    Returns:
	const GUID * or NULL
--*/
{
	//
	//	was the object guid set or calculated?
	//
    if( m_guidObject == GUID_NULL)
    {
        return NULL;
    }
    return &m_guidObject;
}

void CBasicObjectType::PrepareObjectInfoRequest(
                        OUT  MQDS_OBJ_INFO_REQUEST** ppObjInfoRequest
						) const
/*++
    Abstract:
	Prepares a list of properties that should be retrieved from
	AD while creating the object ( for notification or returning 
	the object GUID).
	This routine implements the default for most objects

    Parameters:
	OUT  MQDS_OBJ_INFO_REQUEST** ppObjInfoRequest

    Returns:
	none
--*/
{
    //
    //  The default is no information is requested
    //
    *ppObjInfoRequest = NULL;
}

void CBasicObjectType::PrepareObjectParentRequest(
                          MQDS_OBJ_INFO_REQUEST** ppParentInfoRequest) const
/*++
    Abstract:
	Prepares a list of properties that should be retrieved from
	AD while creating the object regarding its parent (for
	notification) 
	This routine implements the default for most objects

    Parameters:
	OUT  MQDS_OBJ_INFO_REQUEST** ppParentInfoRequest

    Returns:
	none
--*/
{
    //
    // The default is no information is reuqested
    //
    *ppParentInfoRequest = NULL;
}



void CBasicObjectType::GetObjXlateInfo(
             IN  LPCWSTR                pwcsObjectDN,
             IN  const GUID*            pguidObject,
             OUT CObjXlateInfo**        ppcObjXlateInfo)
/*++
    Abstract:
        Routine to get a default translate object that will be passed to
        translation routines to all properties of the translated object

    Parameters:
        pwcsObjectDN        - DN of the translated object
        pguidObject         - GUID of the translated object
        ppcObjXlateInfo     - Where the translate object is put

    Returns:
      HRESULT
--*/
{
    *ppcObjXlateInfo = new CObjXlateInfo(
                                        pwcsObjectDN,
                                        pguidObject
                                        );
}


CBasicObjectType::CBasicObjectType( 
				IN  LPCWSTR         pwcsPathName,
				IN  const GUID *    pguidObject,
				IN  LPCWSTR         pwcsDomainController,
				IN  bool		    fServerName
                ) : 
				m_fServerName(fServerName)
/*++
    Abstract:
	Constructor- copies the input parameters

    Parameters:
    LPCWSTR       pwcsPathName - the object MSMQ name
    const GUID *  pguidObject  - the object unique id
    LPCWSTR       pwcsDomainController - the DC name against
	                             which all AD access should be performed
    bool		  fServerName - flag that indicate if the pwcsDomainController
							     string is a server name

    Returns:
	none
--*/
{
    if (pwcsPathName != NULL)
    {
        m_pwcsPathName = new WCHAR[wcslen(pwcsPathName) +1];
        wcscpy(m_pwcsPathName, pwcsPathName);
    }

    if (pwcsDomainController != NULL)
    {
        m_pwcsDomainController = new WCHAR[wcslen(pwcsDomainController) +1];
        wcscpy(m_pwcsDomainController, pwcsDomainController);
    }

    if (pguidObject != NULL)
    {
		m_guidObject = *pguidObject;
    }
    else
    {
        m_guidObject = GUID_NULL;
    }


}

void CBasicObjectType::SetObjectDN(
			IN LPCWSTR pwcsObjectDN)
/*++
    Abstract:
	Sets the object distinguished name

    Parameters:
	LPCWSTR pwcsObjectDN - the object distinguished name

    Returns:
--*/
{
    ASSERT(m_pwcsDN == NULL);
    m_pwcsDN = new WCHAR[ wcslen(pwcsObjectDN) + 1];
    wcscpy(m_pwcsDN, pwcsObjectDN);
}

HRESULT CBasicObjectType::DeleteObject(
            IN MQDS_OBJ_INFO_REQUEST * /* pObjInfoRequest */,
            IN MQDS_OBJ_INFO_REQUEST * /* pParentInfoRequest*/
                                       )
/*++
    Abstract:
	This is the default implementation for deleting an object.

    Parameters:
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - infomation about the object
    MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - information about the object's parent

    Returns:
	HRESULT
--*/
{
    //
    //  by default delete operations are not supported.
    //
    //  This will be override by specific object ( like queue or machine)
    //  where the operation is supported.
    //
    return MQ_ERROR_FUNCTION_NOT_SUPPORTED;
}

HRESULT CBasicObjectType::GetObjectProperties(
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT  PROPVARIANT         apVar[]
                )
/*++
    Abstract:
	This is the default routine for retrieving object properties
	from AD.

    Parameters:
    DWORD        cp			- number of properties
    PROPID       aProp		- the requested properties
    PROPVARIANT  apVar		- the retrieved values

    Returns:
	HRESULT
--*/
{
    HRESULT hr;
    if (m_pwcsPathName)
    {
        //
        // Expand msmq pathname into ActiveDirectory DN
        //
        hr = ComposeObjectDN();
        if (FAILED(hr))
        {
            return(hr);
        }
    }

    hr = HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT);

    //
    //  retreive the requested properties from Active Directory
    //
    //  First try a any domain controller and only then a GC,
    //  unless the caller had specified a specific domain controller.
    //
    //  NOTE - which DC\GC to access will be based on previous AD
    //  ====   access regarding this object
    //
    if ( ToAccessDC() || 
         m_pwcsDomainController != NULL)
    {
        hr = g_AD.GetObjectProperties(
                        adpDomainController,
                        this,
                        cp,
                        aProp,
                        apVar
                        );

        if (SUCCEEDED(hr) ||
            m_pwcsDomainController != NULL)
        {
            return(hr);
        }

    }


    if ( ToAccessGC())
    {
        //ASSERT( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT));

        hr = g_AD.GetObjectProperties(
                        adpGlobalCatalog,	
                        this,
                        cp,
                        aProp,
                        apVar
                        );
    }

    return hr;
}


HRESULT CBasicObjectType::RetreiveObjectIdFromNotificationInfo(
            IN const MQDS_OBJ_INFO_REQUEST*   /* pObjectInfoRequest*/,
            OUT GUID*                         /* pObjGuid*/
            ) const
/*++
    Abstract:
	This is the default routine, for getting the object guid from
	the MQDS_OBJ_INFO_REQUEST

    Parameters:
    const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
    OUT GUID*                         pObjGuid

    Returns:
--*/
{
    //
    //  this is a default routing for all object where returning the
    //  created object guid is not supported.
    //
    ASSERT(0);
    LogIllegalPoint(s_FN, 81);
    return MQ_ERROR_DS_ERROR;
}

HRESULT CBasicObjectType::CreateObject(
            IN const DWORD				cp,        
            IN const PROPID *			aProp, 
            IN const MQPROPVARIANT *	apVar, 
            IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest, 
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            )
/*++
    Abstract:
	The routine first verify the specified properties and add required properties,
	the it creates the object in AD with the specified attributes
	values

    Parameters:
    const DWORD    cp - number of properties        
    const PROPID  *aProp - the propperties
    const MQPROPVARIANT *apVar - properties value
    PSECURITY_DESCRIPTOR    pSecurityDescriptor - SD of the object
    OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - properties to 
							retrieve while creating the object 
    OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - properties 
						to retrieve about the object's parent
    Returns:
	HRESULT
--*/
{
    //
    //  Verify props and add additional
    //
    DWORD cpNew;
    AP<PROPID> pPropNew = NULL;
    AP< PROPVARIANT> pVarNew = NULL;

    HRESULT hr = VerifyAndAddProps(
                            cp,
                            aProp,
                            apVar,
                            pSecurityDescriptor,
                            &cpNew,
                            &pPropNew,
                            &pVarNew
                            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    return CreateInAD( cpNew,
                       pPropNew,
                       pVarNew,
                       pObjInfoRequest,
                       pParentInfoRequest);
}

HRESULT CBasicObjectType::CreateInAD(
        IN const DWORD            cp,        
        IN const PROPID  *        aProp, 
        IN const MQPROPVARIANT *  apVar, 
        IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest, 
        IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
        )
/*++
    Abstract:
	The routine creates the object in AD with the specified attributes
	values

    Parameters:
    const DWORD   cp - number of properties        
    const PROPID  *aProp - the propperties
    const MQPROPVARIANT *apVar - properties value
    PSECURITY_DESCRIPTOR    pSecurityDescriptor - SD of the object
    OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - properties to 
							retrieve while creating the object 
    OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - properties 
						to retrieve about the object's parent
    Returns:
	HRESULT
--*/
{
    HRESULT hr;

    hr = ComposeFatherDN();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 11);
    }

    hr = g_AD.CreateObject(
            adpDomainController,
            this,
            GetRelativeDN(),    
            GetObjectParentDN(),
            cp,
            aProp,
            apVar,
            pObjInfoRequest,
            pParentInfoRequest);


   return LogHR(hr, s_FN, 20);

}

HRESULT CBasicObjectType::VerifyAndAddProps(
            IN  const DWORD            cp,        
            IN  const PROPID *         aProp, 
            IN  const MQPROPVARIANT *  apVar, 
            IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
            OUT DWORD*                 pcpNew,
            OUT PROPID**               ppPropNew,
            OUT MQPROPVARIANT**        ppVarNew
            )
/*++
    Abstract:
	This is the default routine, it doesn't perform any verfication
	of the supplied properties and just copy them as is

    Parameters:
    const DWORD            cp - number of props        
    const PROPID *         aProp - props ids
    const MQPROPVARIANT *  apVar - properties value
    PSECURITY_DESCRIPTOR   pSecurityDescriptor - SD for the object
    DWORD*                 pcpNew - new number of props
    PROPID**               ppPropNew - new prop ids
    OMQPROPVARIANT**       ppVarNew - new properties values

    Returns:
	HRESULT
--*/
{
    //
    // The only instance when msmq application can create objects with
    // explicit security descriptor is when calling MQCreateQueue().
    // All other calls to this function are from msmq admin tools or
    // setup. These calls never pass a security descriptor.
	// The code below is for the default object ( where security
	// descriptor is not specified)
    //
    ASSERT(pSecurityDescriptor == NULL) ;
    if (pSecurityDescriptor != NULL)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 30);
    }

    //
    // Security property should never be supplied.
    //
    PROPID pSecId = GetObjectSecurityPropid();
    for ( DWORD i = 0; i < cp ; i++ )
    {
        if (pSecId == aProp[i])
        {
            ASSERT(0) ;
            return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 40);
        }
    }

    //
    //  Just copy the properties as is
    //
    AP<PROPVARIANT> pAllPropvariants;
    AP<PROPID> pAllPropids;
    ASSERT( cp > 0);

    if ( cp > 0)
    {
        pAllPropvariants = new PROPVARIANT[cp];
        pAllPropids = new PROPID[cp];
        memcpy (pAllPropvariants, apVar, sizeof(PROPVARIANT) * cp);
        memcpy (pAllPropids, aProp, sizeof(PROPID) * cp);
    }
    *pcpNew = cp;
    *ppPropNew = pAllPropids.detach();
    *ppVarNew = pAllPropvariants.detach();
    return MQ_OK;
}


HRESULT CBasicObjectType::SetObjectProperties(
            IN DWORD                  cp,        
            IN const PROPID          *aProp, 
            IN const MQPROPVARIANT   *apVar, 
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest, 
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            )
/*++
    Abstract:
	This is the default routine for setting object properties
	in AD

    Parameters:
    DWORD                  cp - number of properties to set        
    const PROPID *         aProp - the properties ids
    const MQPROPVARIANT*   apVar- properties value
    OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - info to retrieve about the object 
    OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - info to retrieveabout the object's parent

    Returns:
	HRESULT
--*/
{
    HRESULT hr;
    if (m_pwcsPathName != NULL)
    {
        hr = ComposeObjectDN();
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_TRACE,TEXT("CBasicObjectType::SetObjectProperties : failed to compose full path name %lx"),hr));
            return LogHR(hr, s_FN, 50);
        }
    }


    hr = g_AD.SetObjectProperties(
                    adpDomainController,
                    this,
                    cp,
                    aProp,
                    apVar,
                    pObjInfoRequest,
                    pParentInfoRequest
                    );


    return LogHR(hr, s_FN, 60);

}


LPCWSTR CBasicObjectType::GetDomainController()
/*++
    Abstract:
	return the nsme of the domsin controller against which
	the operation should be performed

    Parameters:
	none

    Returns:
	LPCWSTR or NULL
--*/
{
    return m_pwcsDomainController;
}


bool CBasicObjectType::IsServerName()
/*++
    Abstract:
	return true if the domain controller string is server name

    Parameters:
	none

    Returns:
	true if domain controller string is server name, false otherwise.
--*/
{
    return m_fServerName;
}


void CBasicObjectType::CreateNotification(
            IN LPCWSTR                        /* pwcsDomainController */,
            IN const MQDS_OBJ_INFO_REQUEST*   /* pObjectInfoRequest*/,
            IN const MQDS_OBJ_INFO_REQUEST*   /* pObjectParentInfoRequest*/
            ) const
/*++
    Abstract:
	Notify QM about an object create.
    The QM should verify if the object is local or not

    Parameters:
    LPCWSTR                        pwcsDomainController - DC agains which operation was performed
    const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest - information about the object
    const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest - information about object parent

    Returns:
	void
--*/
{
    //
    //  Default behavior : do nothing
    //
    return;
}

void CBasicObjectType::ChangeNotification(
            IN LPCWSTR                        /* pwcsDomainController*/,
            IN const MQDS_OBJ_INFO_REQUEST*   /* pObjectInfoRequest*/,
            IN const MQDS_OBJ_INFO_REQUEST*   /* pObjectParentInfoRequest*/
            ) const
/*++
    Abstract:
	Notify QM about an object update.
    The QM should verify if the object is local or not

    Parameters:
    LPCWSTR                        pwcsDomainController - DC agains which operation was performed
    const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest - information about the object
    const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest - information about object parent

    Returns:
	void
--*/
{
    //
    //  Default behavior : do nothing
    //
    return;
}

void CBasicObjectType::DeleteNotification(
            IN LPCWSTR                        /* pwcsDomainController*/,
            IN const MQDS_OBJ_INFO_REQUEST*   /* pObjectInfoRequest*/,
            IN const MQDS_OBJ_INFO_REQUEST*   /* pObjectParentInfoRequest*/
            ) const
/*++
    Abstract:
	Notify QM about an object deletion.
    The QM should verify if the object is local or not

    Parameters:
    LPCWSTR                        pwcsDomainController - DC agains which operation was performed
    const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest - information about the object
    const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest - information about object parent

    Returns:
	void
--*/
{
    //
    //  Default behavior : do nothing
    //
    return;
}


HRESULT CBasicObjectType::GetObjectSecurity(
            IN  SECURITY_INFORMATION    RequestedInformation,
            IN  const PROPID            prop,
            IN OUT  PROPVARIANT *       pVar
            )
/*++

Routine Description:
    The routine retrieves an object security from AD 

Arguments:
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	PROPVARIANT             pVar - property values

Return Value
	HRESULT

--*/
{
    HRESULT hr = MQ_ERROR_DS_ERROR;
    if (m_pwcsPathName)
    {
        //
        // Expand msmq pathname into ActiveDirectory DN
        //
        hr = ComposeObjectDN();
        if (FAILED(hr))
        {
            return(hr);
        }
    }

    //
    //  retreive the requested properties from Active Directory
    //
    //  First try a any domain controller and only then a GC,
    //  unless the caller had specified a specific domain controller.
    //
    //  NOTE - which DC\GC to access will be based on previous AD
    //  ====   access regarding this object
    //
    if ( ToAccessDC() || 
         m_pwcsDomainController != NULL)
    {
        hr = g_AD.GetObjectSecurityProperty(
                        adpDomainController,
                        this,
                        RequestedInformation,
                        prop,
                        pVar
                        );


        if (SUCCEEDED(hr) ||
            m_pwcsDomainController != NULL)
        {
            return(hr);
        }

    }


    if ( ToAccessGC())
    {
        hr = g_AD.GetObjectSecurityProperty(
                        adpGlobalCatalog,	
                        this,
                        RequestedInformation,
                        prop,
                        pVar
                        );
    }

    return hr;

}

HRESULT CBasicObjectType::SetObjectSecurity(
            IN  SECURITY_INFORMATION        RequestedInformation,
            IN  const PROPID                prop,
            IN  const PROPVARIANT *         pVar,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pObjInfoRequest, 
            IN OUT MQDS_OBJ_INFO_REQUEST *  pParentInfoRequest
            )
/*++

Routine Description:
    The routine sets object security in AD 

Arguments:
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - infomation about the object
    MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - information about the object's parent

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    if (m_pwcsPathName != NULL)
    {
        hr = ComposeObjectDN();
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_TRACE,TEXT("CBasicObjectType::SetObjectSecurity : failed to compose full path name %lx"),hr));
            return LogHR(hr, s_FN, 150);
        }
    }


    hr = g_AD.SetObjectSecurityProperty(
                    adpDomainController,
                    this,
                    RequestedInformation,
                    prop,
                    pVar,
                    pObjInfoRequest,
                    pParentInfoRequest
                    );

    return LogHR(hr, s_FN, 160);
}

HRESULT CBasicObjectType::GetComputerVersion(
                OUT PROPVARIANT *           /*pVar*/
                )
/*++

Routine Description:
    The routine reads the version of computer 

Arguments:
	PROPVARIANT             pVar - version property value

Return Value
	HRESULT

--*/
{
    //
    //  by default this API is not supported.
    //
    //  This will be override by specific object ( like queue or machine)
    //  where the operation is supported.
    //
    return MQ_ERROR_FUNCTION_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\compobj.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    compobj.cpp

Abstract:

    Implementation of CComputerObject class.

Author:

    ronith

--*/
#include "ds_stdh.h"
#include "baseobj.h"
#include "mqattrib.h"
#include "mqadglbo.h"
#include <lmaccess.h>
#include "mqadp.h"

#include "compobj.tmh"

static WCHAR *s_FN=L"mqad/compobj";

DWORD CComputerObject::m_dwCategoryLength = 0;
AP<WCHAR> CComputerObject::m_pwcsCategory = NULL;


CComputerObject::CComputerObject( 
                    LPCWSTR         pwcsPathName,
                    const GUID *    pguidObject,
                    LPCWSTR         pwcsDomainController,
					bool		    fServerName
                    ) : CBasicObjectType( 
								pwcsPathName, 
								pguidObject,
								pwcsDomainController,
								fServerName
								),
						m_eComputerObjType(eRealComputerObject)
/*++
    Abstract:
	constructor of computer object

    Parameters:
    LPCWSTR       pwcsPathName - the object MSMQ name
    const GUID *  pguidObject  - the object unique id
    LPCWSTR       pwcsDomainController - the DC name against
	                             which all AD access should be performed
    bool		  fServerName - flag that indicate if the pwcsDomainController
							     string is a server name

    Returns:
	none

--*/
{
    //
    //  don't assume that the object can be found on DC
    //
    m_fFoundInDC = false;
    //
    //  Keep an indication that never tried to look for
    //  the object in AD ( and therefore don't really know if it can be found
    //  in DC or not)
    //
    m_fTriedToFindObject = false;
}

CComputerObject::~CComputerObject()
/*++
    Abstract:
	destructor of site object

    Parameters:
	none

    Returns:
	none
--*/
{
	//
	// nothing to do ( everything is released with automatic pointers
	//
}

HRESULT CComputerObject::ComposeObjectDN()
/*++
    Abstract:
	Composed distinguished name of the computer

    m_eComputerObjType - indicates which computer object we're looking for.
      There is a "built-in" problem in mix-mode, or when a computer move
      between domains, that you may find two computers objects that represent
      the same single physical computer. In most cases, the msmqConfiguration
      object will be found under the computer object that was the first one
      created in the active directory forest.
      In that case, sometimes we need the object that contain the
      msmqConfiguration object and some other times we need the "real"
      computer object that represent the "real" physical computer in its
      present domain.
      For example- when looking for the "trust-for-delegation" bit, we want
      the "real" object, while when creating queues, we look for the computer
      object that contain the msmqConfiguration object.


    Parameters:
	none

    Returns:
	HRESULT
--*/
{
    HRESULT hr;
    ASSERT(m_pwcsPathName != NULL);
    if (m_pwcsDN != NULL)
    {
        return MQ_OK;
    }

    const WCHAR * pwcsFullDNSName = NULL;
    AP<WCHAR> pwcsNetbiosName;
    //
    //   If computer name is specified in DNS format:
    //      perform a query according to the Netbios part of the computer
	//		dns name
    //
    //	 In both cases the query is comparing the netbios name + $
	//	to the samAccountName attribute of computer objects

    WCHAR * pwcsEndMachineCN = wcschr(m_pwcsPathName, L'.');
    //
    //  Is the computer name is specified in DNS format
    //
    DWORD len, len1;
    if (pwcsEndMachineCN != NULL)
    {
        pwcsFullDNSName = m_pwcsPathName;
        len1 = numeric_cast<DWORD>(pwcsEndMachineCN - m_pwcsPathName);
    }
	else
    {
		len1 = wcslen(m_pwcsPathName);
    }

    //
    // The PROPID_COM_SAM_ACCOUNT contains the first MAX_COM_SAM_ACCOUNT_LENGTH (19)
    // characters of the computer name, as unique ID. (6295 - ilanh - 03-Jan-2001)
    //
    len = __min(len1, MAX_COM_SAM_ACCOUNT_LENGTH);

	pwcsNetbiosName = new WCHAR[len + 2];
	wcsncpy(pwcsNetbiosName, m_pwcsPathName, len);
	pwcsNetbiosName[len] = L'$';
	pwcsNetbiosName[len + 1] = L'\0';

    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;
    propRestriction.prval.vt = VT_LPWSTR;
	propRestriction.prval.pwszVal = pwcsNetbiosName;
    propRestriction.prop = PROPID_COM_SAM_ACCOUNT;

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;

	TrTRACE(mqad, "Searcing for: ComputerPathName = %ls, SamAccountName = %ls", m_pwcsPathName, pwcsNetbiosName);

	//
    //  First perform the operation against the local domain controller
    //  then against the global catalog.
    //
    //  The purpose of this is to be able to "find" queue or machine
    //  that were created or modified on the local domain, and not
    //  yet replicated to the global catalog.
    //
    hr = g_AD.FindComputerObjectFullPath(
					adpDomainController,
					m_pwcsDomainController,
					m_fServerName,
					m_eComputerObjType,
					pwcsFullDNSName,
					&restriction,
					&m_pwcsDN
					);

    m_fTriedToFindObject = true;

    if (SUCCEEDED(hr))
    {
		TrTRACE(mqad, "Found computer %ls in local DC, computer DN = %ls", pwcsNetbiosName, m_pwcsDN);
        m_fFoundInDC = true;
		return hr;
    }

	TrERROR(mqad, "Failed to find computer %ls in local DC, hr = 0x%x", pwcsNetbiosName, hr);

    if (m_pwcsDomainController == NULL)
    {
		HRESULT hrDC = hr;
        hr = g_AD.FindComputerObjectFullPath(
						adpGlobalCatalog,
						m_pwcsDomainController,
						m_fServerName,
						m_eComputerObjType,
						pwcsFullDNSName,
						&restriction,
						&m_pwcsDN
						);
		
		if (SUCCEEDED(hr))
		{
			TrTRACE(mqad, "Found computer %ls in GC, computer DN = %ls", pwcsNetbiosName, m_pwcsDN);
			return hr;
		}

		TrERROR(mqad, "Failed to find computer %ls in GC, hr = 0x%x", pwcsNetbiosName, hr);
		if((hr == MQ_ERROR_DS_BIND_ROOT_FOREST) && MQADpIsDSOffline(hrDC))
		{
			//
			// When offline, we will fail both in DC and GC operations.
			// For some reason binding to the GC is ok and we will get MQ_ERROR_DS_BIND_ROOT_FOREST
			// If the DC eror is offline, the offline error is more accurate in this case.
			// Override the GC error with the offline error from the DC in this case.
			//
			hr = hrDC;
		}
    }

	return LogHR(hr, s_FN, 10);
}

void CComputerObject::SetComputerType(
                ComputerObjType  eComputerObjType)
/*++
    Abstract:
	This routine enables to change the type of computer object
	that is being looked after in AD

    Parameters:
	none

    Returns:
	none
--*/
{
    m_eComputerObjType = eComputerObjType;
}

HRESULT CComputerObject::ComposeFatherDN()
/*++
    Abstract:
	Composed distinguished name of the parent of computer object

    Parameters:
	none

    Returns:
	none
--*/
{
    //
    //  verify that it wasn't calculated before
    //
    if (m_pwcsParentDN != NULL)
    {
        return MQ_OK;
    }
    if ( m_pwcsParentDN == NULL)
    {
		AP<WCHAR> pwcsLocalDsRootToFree;
		LPWSTR pwcsLocalDsRoot = NULL;
		HRESULT hr = g_AD.GetLocalDsRoot(
							m_pwcsDomainController, 
							m_fServerName,
							&pwcsLocalDsRoot,
							pwcsLocalDsRootToFree
							);

		if(FAILED(hr))
		{
			TrERROR(mqad, "Failed to get Local Ds Root, hr = 0x%x", hr);
			return LogHR(hr, s_FN, 20);
		}

        DWORD len = wcslen(pwcsLocalDsRoot) + x_ComputersContainerPrefixLength + 2;
        m_pwcsParentDN = new WCHAR [len];
        DWORD dw = swprintf(
            m_pwcsParentDN,
            L"%s"             // "CN=Computers"
            TEXT(",")
            L"%s",            // g_pwcsDsRoot
            x_ComputersContainerPrefix,
            pwcsLocalDsRoot
            );
        DBG_USED(dw);
        ASSERT(dw < len);
    }
    return MQ_OK;
}

LPCWSTR CComputerObject::GetRelativeDN()
/*++
    Abstract:
	return the RDN of the computer object

    Parameters:
	none

    Returns:
	LPCWSTR computer RDN
--*/
{
    return m_pwcsPathName;
}

DS_CONTEXT CComputerObject::GetADContext() const
/*++
    Abstract:
	Returns the AD context where computer object should be looked for

    Parameters:
	none

    Returns:
	DS_CONTEXT
--*/
{
    return e_RootDSE;
}

bool CComputerObject::ToAccessDC() const
/*++
    Abstract:
	returns whether to look for the object in DC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	true or false
--*/
{
    if (!m_fTriedToFindObject)
    {
        return true;
    }
    return m_fFoundInDC;
}

bool CComputerObject::ToAccessGC() const
/*++
    Abstract:
	returns whether to look for the object in GC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	true or false 
--*/
{
    if (!m_fTriedToFindObject)
    {
        return true;
    }
    return !m_fFoundInDC;
}

void CComputerObject::ObjectWasFoundOnDC()
/*++
    Abstract:
	The object was found on DC, set indication not to
    look for it on GC


    Parameters:
	none

    Returns:
	none
--*/
{
    m_fTriedToFindObject = true;
    m_fFoundInDC = true;
}


LPCWSTR CComputerObject::GetObjectCategory() 
/*++
    Abstract:
	prepares and retruns the object category string

    Parameters:
	none

    Returns:
	LPCWSTR object category string
--*/
{
    if (CComputerObject::m_pwcsCategory == NULL)
    {
        DWORD len = wcslen(g_pwcsSchemaContainer) + wcslen(x_ComputerCategoryName) + 2;

        AP<WCHAR> pwcsCategory = new WCHAR[len];
        DWORD dw = swprintf(
			 pwcsCategory,
             L"%s,%s",
             x_ComputerCategoryName,
             g_pwcsSchemaContainer
            );
        DBG_USED(dw);
        ASSERT(dw  < len);

        if (NULL == InterlockedCompareExchangePointer(
                              &CComputerObject::m_pwcsCategory.ref_unsafe(), 
                              pwcsCategory.get(),
                              NULL
                              ))
        {
            pwcsCategory.detach();
            CComputerObject::m_dwCategoryLength = len;
        }
    }
    return CComputerObject::m_pwcsCategory;
}

DWORD   CComputerObject::GetObjectCategoryLength()
/*++
    Abstract:
	prepares and retruns the length object category string

    Parameters:
	none

    Returns:
	DWORD object category string length
--*/
{
	//
	//	call GetObjectCategory in order to initailaze category string
	//	and length
	//
	GetObjectCategory();

    return CComputerObject::m_dwCategoryLength;
}

AD_OBJECT CComputerObject::GetObjectType() const
/*++
    Abstract:
	returns the object type

    Parameters:
	none

    Returns:
	AD_OBJECT
--*/
{
    return eCOMPUTER;
}

LPCWSTR CComputerObject::GetClass() const
/*++
    Abstract:
	returns a string represinting the object class in AD

    Parameters:
	none

    Returns:
	LPCWSTR object class string
--*/
{
    return MSMQ_COMPUTER_CLASS_NAME;
}

DWORD CComputerObject::GetMsmq1ObjType() const
/*++
    Abstract:
	returns the object type in MSMQ 1.0 terms

    Parameters:
	none

    Returns:
	DWORD 
--*/
{
    ASSERT(0);
    return 0;
}

HRESULT CComputerObject::VerifyAndAddProps(
            IN  const DWORD            cp,        
            IN  const PROPID *         aProp, 
            IN  const MQPROPVARIANT *  apVar, 
            IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
            OUT DWORD*                 pcpNew,
            OUT PROPID**               ppPropNew,
            OUT MQPROPVARIANT**        ppVarNew
            )
/*++
    Abstract:
    Add additional properties required when creating a computer object

    Parameters:
    const DWORD            cp - number of props        
    const PROPID *         aProp - props ids
    const MQPROPVARIANT *  apVar - properties value
    PSECURITY_DESCRIPTOR   pSecurityDescriptor - SD for the object
    DWORD*                 pcpNew - new number of props
    PROPID**               ppPropNew - new prop ids
    OMQPROPVARIANT**       ppVarNew - new properties values

    Returns:
	HRESULT
--*/
{

    ASSERT( cp == 1);
    ASSERT( aProp[0] == PROPID_COM_SAM_ACCOUNT);
    DBG_USED(pSecurityDescriptor);
    ASSERT( pSecurityDescriptor == NULL);

    const DWORD xNumCreateCom = 1;

    AP<PROPVARIANT> pAllPropvariants = new PROPVARIANT[cp + xNumCreateCom];
    AP<PROPID> pAllPropids = new PROPID[cp + xNumCreateCom];

    //
    //  Just copy the caller supplied properties as is
    //
    if ( cp > 0)
    {
        memcpy (pAllPropvariants, apVar, sizeof(PROPVARIANT) * cp);
        memcpy (pAllPropids, aProp, sizeof(PROPID) * cp);
    }
    DWORD next = cp;

    pAllPropids[ next] = PROPID_COM_ACCOUNT_CONTROL ;
    pAllPropvariants[ next].vt = VT_UI4 ;
    pAllPropvariants[ next].ulVal = DEFAULT_COM_ACCOUNT_CONTROL ;
    next++;
    ASSERT(next == cp + xNumCreateCom);

    *pcpNew = next;
    *ppPropNew = pAllPropids.detach();
    *ppVarNew = pAllPropvariants.detach();
    return MQ_OK;
}


HRESULT CComputerObject::CreateInAD(
			IN const DWORD            cp,        
            IN const PROPID          *aProp, 
            IN const MQPROPVARIANT   *apVar, 
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest, 
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            )
/*++
    Abstract:
	The routine creates computer object in AD with the specified attributes
	values

    Parameters:
    const DWORD   cp - number of properties        
    const PROPID  *aProp - the propperties
    const MQPROPVARIANT *apVar - properties value
    OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - properties to 
							retrieve while creating the object 
    OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - properties 
						to retrieve about the object's parent
    Returns:
	HRESULT
--*/
{

    //
    //  Create the computer object
    //
    HRESULT hr = CBasicObjectType::CreateInAD(
            cp,        
            aProp, 
            apVar, 
            pObjInfoRequest, 
            pParentInfoRequest
            );
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CComputerObject::CreateInAD- failed to create(%lx)"), hr));
        return LogHR(hr, s_FN, 110);
    }
    //
    //  Get full path name again
    //
    m_eComputerObjType = eRealComputerObject;
    hr = ComposeObjectDN();
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CComputerObject::CreateInAD- failed to compose computer DN(%lx)"), hr));
        return LogHR(hr, s_FN, 40);
    }
    //
    // Grant the user creating the computer account the permission to
    // create child object (msmqConfiguration). 
    // Ignore errors. If caller is admin, then the security setting
    // is not needed. If he's a non-admin, then you can always use
    // mmc and grant this permission manually. so go on even if this
    // call fail.
    //
    hr = MQADpCoreSetOwnerPermission( 
                    const_cast<WCHAR*>(GetObjectDN()),
                    (ACTRL_DS_CREATE_CHILD | ACTRL_DS_DELETE_CHILD)
                    );
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CComputerObject::CreateInAD- failed to set owner permission(%lx)"), hr));
        LogHR(hr, s_FN, 48);
    }
    return MQ_OK;

}

HRESULT CComputerObject::SetObjectSecurity(
            IN  SECURITY_INFORMATION        /*RequestedInformation*/,
            IN  const PROPID                /*prop*/,
            IN  const PROPVARIANT *         /*pVar*/,
            IN OUT MQDS_OBJ_INFO_REQUEST *  /*pObjInfoRequest*/, 
            IN OUT MQDS_OBJ_INFO_REQUEST *  /*pParentInfoRequest*/
            )
/*++

Routine Description:
    The routine sets object security in AD 

Arguments:
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - infomation about the object
    MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - information about the object's parent

Return Value
	HRESULT

--*/
{
    //
    //  This operation is not supported
    //
    return MQ_ERROR_FUNCTION_NOT_SUPPORTED;
}

HRESULT CComputerObject::GetComputerVersion(
                OUT PROPVARIANT *           pVar
                )
/*++

Routine Description:
    The routine reads the version of computer 

Arguments:
	PROPVARIANT             pVar - version property value

Return Value
	HRESULT

--*/
{
    //
    //  Do not use GetObjectProperties API. because PROPID_COM_VERSION
    //  is not replicated to GC
    //
    HRESULT hr;
    if (m_pwcsPathName)
    {
        //
        // Expand msmq pathname into ActiveDirectory DN
        //
        hr = ComposeObjectDN();
        if (FAILED(hr))
        {
            return(hr);
        }
    }

    PROPID prop = PROPID_COM_VERSION;

    hr = g_AD.GetObjectProperties(
                    adpDomainController,
                    this,
                    1,
                    &prop,
                    pVar
                    );
    return LogHR(hr, s_FN, 1823);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\delqn.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    delqn.h

Abstract:
    a class that "handles" queue delete notification when performed by MMC.

Author:

    Ronit Hartmann (ronith)

--*/
#ifndef _DELQN_H_
#define _DELQN_H_

#include "mqad.h"
#include "dsutils.h"



class CQueueDeletionNotification 
{
public:
    CQueueDeletionNotification();
    ~CQueueDeletionNotification();

    HRESULT ObtainPreDeleteInformation(
        IN   LPCWSTR		pwcsQueueName,
		IN   LPCWSTR		pwcsDomainController,
		IN   bool			fServerName
        );
    void PerformPostDeleteOperations();

	bool Verify();

private:
    enum Signature {validSignature = 0x7891, nonvalidSignature };

    Signature		  m_Signature;

    GUID			  m_guidQueue;
    GUID              m_guidQmId;
    BOOL              m_fForeignQm;
	AP<WCHAR>	      m_pwcsDomainController;
	bool			  m_fServerName;

};

inline CQueueDeletionNotification::CQueueDeletionNotification(
				):
				m_Signature(CQueueDeletionNotification::validSignature),
				m_fServerName(false)
{
}

inline CQueueDeletionNotification::~CQueueDeletionNotification()
{
    m_Signature = CQueueDeletionNotification::nonvalidSignature;
}

inline void CQueueDeletionNotification::PerformPostDeleteOperations()
/*++

Routine Description:
    Send notification about deleted queue, using queue information read
    before the queue was deleted

Arguments:
    NONE

Return Value
	HRESULT

--*/
{
    CQueueObject queueObject(NULL, &m_guidQueue, m_pwcsDomainController, m_fServerName);

	MQDS_OBJ_INFO_REQUEST * pObjInfoRequest;
    MQDS_OBJ_INFO_REQUEST * pParentInfoRequest;
    queueObject.PrepareObjectInfoRequest( &pObjInfoRequest);
    queueObject.PrepareObjectParentRequest( &pParentInfoRequest);

    //
    //  Fill in Queue relevant varaints
    //
    ASSERT( pObjInfoRequest->cProps == 1);
    ASSERT( pObjInfoRequest->pPropIDs[ 0] ==  PROPID_Q_INSTANCE);
	pObjInfoRequest->hrStatus = MQ_OK;
    pObjInfoRequest->pPropVars[0].vt = VT_CLSID;
    pObjInfoRequest->pPropVars[0].puuid = &m_guidQueue;

    //
    //  Fill in QM relevant varaints
    //
    ASSERT( pParentInfoRequest->cProps == 2);
    ASSERT( pParentInfoRequest->pPropIDs[ 0] ==  PROPID_QM_MACHINE_ID);
    ASSERT( pParentInfoRequest->pPropIDs[ 1] ==  PROPID_QM_FOREIGN);
	pParentInfoRequest->hrStatus = MQ_OK;
    pParentInfoRequest->pPropVars[0].vt = VT_CLSID;
    pParentInfoRequest->pPropVars[0].puuid = &m_guidQmId;
    pParentInfoRequest->pPropVars[1].vt = VT_UI1;
    pParentInfoRequest->pPropVars[1].bVal = (UCHAR)((m_fForeignQm) ? 1 : 0);

    queueObject.DeleteNotification(
            m_pwcsDomainController,
            pObjInfoRequest, 
            pParentInfoRequest
			);

}

inline HRESULT CQueueDeletionNotification::ObtainPreDeleteInformation(
        IN   LPCWSTR		pwcsQueueName,
		IN   LPCWSTR		pwcsDomainController,
		IN   bool			fServerName
        )
/*++

Routine Description:
    Obtain queue information that is reuqired for sending notification

Arguments:
    LPCWSTR                 pwcsQueueName - MSMQ queue name
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							     string is a server name

Return Value
	HRESULT

--*/
{
    HRESULT hr;

    //
    // start with getting PROPID_Q_QMID and its unique id
    //
	const DWORD cNum = 2;
    PROPID aPropQ[cNum] = {PROPID_Q_QMID, PROPID_Q_INSTANCE};
    PROPVARIANT varQ[cNum];

    varQ[0].vt = VT_CLSID;
    varQ[0].puuid = &m_guidQmId;
    varQ[1].vt = VT_CLSID;
	varQ[1].puuid = &m_guidQueue;

    hr = MQADGetObjectProperties(
						eQUEUE,
						pwcsDomainController,
						fServerName,
                        pwcsQueueName,
                        cNum,
                        aPropQ,
                        varQ);

    if ( FAILED(hr))
    {
        //
        //  Failed to gather information... no use to continue
        //
        return hr;
    }
    //
    //  read if QM is foreign
    //
    PROPID propQm[] = {  PROPID_QM_FOREIGN};
    PROPVARIANT varQM[sizeof(propQm) / sizeof(PROPID)];

    varQM[0].vt = VT_NULL;

    hr = MQADGetObjectPropertiesGuid(
						eMACHINE,
                        pwcsDomainController,
						fServerName,
                        &m_guidQmId,
                        sizeof(propQm) / sizeof(PROPID),
                        propQm,
                        varQM);
    if (FAILED(hr))
    {
        //
        //  Failed to gather information... no use to continue
        //
        return hr;
    }
    m_fForeignQm =  varQM[0].bVal;

	//
	//	Keep the DC name ( we want to pass it as part of the
	//  notification)
	//
	if ( pwcsDomainController != NULL)
	{
		m_pwcsDomainController = new WCHAR[wcslen(pwcsDomainController) +1];
		wcscpy(m_pwcsDomainController, pwcsDomainController);
		m_fServerName = fServerName;
	}


    return MQ_OK;
}

inline bool CQueueDeletionNotification::Verify()
{
    return (m_Signature == CQueueDeletionNotification::validSignature);
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\dsadssec.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dsads.cpp

Abstract:

    Implementation of CADSI class, encapsulating work with ADSI.

Author:

    Alexander Dadiomov (AlexDad)

--*/

#include "ds_stdh.h"
#include "adtempl.h"
#include "dsutils.h"
#include "utils.h"
#include "mqads.h"
#include <winldap.h>
#include <aclapi.h>
#include <autoreln.h>
#include "..\..\mqsec\inc\permit.h"

#include "dsadssec.tmh"

static WCHAR *s_FN=L"mqad/dsadssec";


//+--------------------------------------------------------------
//
//  HRESULT MQADpCoreSetOwnerPermission()
//
//+--------------------------------------------------------------

HRESULT MQADpCoreSetOwnerPermission( WCHAR *pwszPath,
                                  DWORD  dwPermissions )
{
    PSECURITY_DESCRIPTOR pSD = NULL ;
    SECURITY_INFORMATION  SeInfo = OWNER_SECURITY_INFORMATION |
                                   DACL_SECURITY_INFORMATION ;
    PACL pDacl = NULL ;
    PSID pOwnerSid = NULL ;

    //
    // Obtain owner and present DACL.
    //
    DWORD dwErr = GetNamedSecurityInfo( pwszPath,
                                        SE_DS_OBJECT_ALL,
                                        SeInfo,
                                       &pOwnerSid,
                                        NULL,
                                       &pDacl,
                                        NULL,
                                       &pSD ) ;
    CAutoLocalFreePtr pFreeSD = (BYTE*) pSD ;
    if (dwErr != ERROR_SUCCESS)
    {
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
              "DSCoreSetOwnerPermission(): fail to GetNamed(%ls), %lut"),
                                                     pwszPath, dwErr)) ;

        return LogHR(HRESULT_FROM_WIN32(dwErr), s_FN, 80);
    }

    ASSERT(pSD && IsValidSecurityDescriptor(pSD)) ;
    ASSERT(pOwnerSid && IsValidSid(pOwnerSid)) ;
    ASSERT(pDacl && IsValidAcl(pDacl)) ;

    //
    // Create ace for the owner, granting him the permissions.
    //
    EXPLICIT_ACCESS expAcss ;
    memset(&expAcss, 0, sizeof(expAcss)) ;

    expAcss.grfAccessPermissions =  dwPermissions ;
    expAcss.grfAccessMode = GRANT_ACCESS ;

    expAcss.Trustee.pMultipleTrustee = NULL ;
    expAcss.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE ;
    expAcss.Trustee.TrusteeForm = TRUSTEE_IS_SID ;
    expAcss.Trustee.TrusteeType = TRUSTEE_IS_USER ;
    expAcss.Trustee.ptstrName = (WCHAR*) pOwnerSid ;

    //
    // Obtai new DACL, that merge present one with new ace.
    //
    PACL  pNewDacl = NULL ;
    dwErr = SetEntriesInAcl( 1,
                            &expAcss,
                             pDacl,
                            &pNewDacl ) ;

    CAutoLocalFreePtr pFreeDacl = (BYTE*) pNewDacl ;
    LogNTStatus(dwErr, s_FN, 1639);

    if (dwErr == ERROR_SUCCESS)
    {
        ASSERT(pNewDacl && IsValidAcl(pNewDacl)) ;
        SeInfo = DACL_SECURITY_INFORMATION ;

        //
        // Change security descriptor of object.
        //
        dwErr = SetNamedSecurityInfo( pwszPath,
                                      SE_DS_OBJECT_ALL,
                                      SeInfo,
                                      NULL,
                                      NULL,
                                      pNewDacl,
                                      NULL ) ;
        LogNTStatus(dwErr, s_FN, 1638);
        if (dwErr != ERROR_SUCCESS)
        {
            DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
              "DSCoreSetOwnerPermission(): fail to SetNamed(%ls), %lut"),
                                                     pwszPath, dwErr)) ;
        }
    }
    else
    {
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
              "DSCoreSetOwnerPermissions(): fail to SetEmtries(), %lut"),
                                                               dwErr)) ;
    }

    return LogHR(HRESULT_FROM_WIN32(dwErr), s_FN, 90);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\baseobj.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
	baseobj.h

Abstract:
	Basic object type class.

Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __BASEOBJ_H__
#define __BASEOBJ_H__
#include <mqaddef.h>
#include "ds_stdh.h"
#include "mqads.h"
#include "tr.h"
#include "ref.h"
#include "traninfo.h"
#include "mqattrib.h"

const PROPID  ILLEGAL_PROPID_VALUE = 0xFFFFFFFF;


//-----------------------------------------------------------------------------------
//
//      CBasicObjectType
//
//  Virtual class, encapsulates operations performed on different object types.
//
//-----------------------------------------------------------------------------------
class CBasicObjectType : public CReference
{
public:
    CBasicObjectType(
			IN LPCWSTR         pwcsPathName,
			IN const GUID *    pguidObject,
			IN LPCWSTR         pwcsDomainController,
			IN bool		       fServerName
			);

    virtual ~CBasicObjectType() {};

    virtual HRESULT ComposeObjectDN() = 0;
    LPCWSTR GetObjectDN() const;

    virtual HRESULT ComposeFatherDN() = 0;
    LPCWSTR GetObjectParentDN() const;

    virtual LPCWSTR GetRelativeDN() = 0;

    const GUID * GetObjectGuid() const;

    LPCWSTR GetDomainController();

    bool IsServerName();

    virtual DS_CONTEXT GetADContext() const = 0;

    virtual bool ToAccessDC() const = 0;
    virtual bool ToAccessGC() const = 0;
    virtual void ObjectWasFoundOnDC() = 0;

    virtual LPCWSTR GetObjectCategory() = 0;
    virtual DWORD   GetObjectCategoryLength() = 0;


    virtual void PrepareObjectInfoRequest(
		     OUT MQDS_OBJ_INFO_REQUEST** ppObjInfoRequest
			 ) const;
    virtual void PrepareObjectParentRequest(
		     OUT MQDS_OBJ_INFO_REQUEST**  ppParentInfoRequest
			 ) const;


    virtual AD_OBJECT GetObjectType() const = 0;
    virtual LPCWSTR GetClass() const = 0;
    virtual DWORD GetMsmq1ObjType() const = 0;


    virtual void GetObjXlateInfo(
             IN  LPCWSTR                pwcsObjectDN,
             IN  const GUID*            pguidObject,
             OUT CObjXlateInfo**        ppcObjXlateInfo
			 );

    void SetObjectDN(
		     IN LPCWSTR pwcsObjectDN
			 );

    virtual HRESULT DeleteObject(
            IN MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );

    virtual HRESULT GetObjectProperties(
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT  PROPVARIANT         apVar[]
                );

    virtual HRESULT CreateInAD(
	        IN const DWORD            cp,
            IN const PROPID          *aProp,
            IN const MQPROPVARIANT   *apVar,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );

    virtual HRESULT RetreiveObjectIdFromNotificationInfo(
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            OUT GUID*                         pObjGuid
            ) const;

    HRESULT CreateObject(
            IN DWORD                  cp,
            IN const PROPID          *aProp,
            IN const MQPROPVARIANT   *apVar,
            IN PSECURITY_DESCRIPTOR    pSecurityDescriptor,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );

    virtual HRESULT VerifyAndAddProps(
            IN  const DWORD            cp,
            IN  const PROPID *         aProp,
            IN  const MQPROPVARIANT *  apVar,
            IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
            OUT DWORD*                 pcpNew,
            OUT PROPID**               ppPropNew,
            OUT MQPROPVARIANT**        ppVarNew
            );
    virtual PROPID GetObjectSecurityPropid() const = 0;

    virtual HRESULT SetObjectProperties(
            IN DWORD                  cp,
            IN const PROPID          *aProp,
            IN const MQPROPVARIANT   *apVar,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );

    virtual void CreateNotification(
            IN LPCWSTR                        pwcsDomainController,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest
            ) const;

    virtual void ChangeNotification(
            IN LPCWSTR                        pwcsDomainController,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest
            ) const;

    virtual void DeleteNotification(
            IN LPCWSTR                        pwcsDomainController,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest
            ) const;

    virtual HRESULT GetObjectSecurity(
            IN  SECURITY_INFORMATION    RequestedInformation,
            IN  const PROPID            prop,
            IN OUT  PROPVARIANT *       pVar
            );

    virtual HRESULT SetObjectSecurity(
            IN  SECURITY_INFORMATION        RequestedInformation,
            IN  const PROPID                prop,
            IN  const PROPVARIANT *         pVar,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pParentInfoRequest
            );

    virtual HRESULT GetComputerVersion(
                OUT PROPVARIANT *           pVar
                );


protected:
    AP<WCHAR>   m_pwcsDN;
    AP<WCHAR>   m_pwcsParentDN;
    AP<WCHAR>   m_pwcsPathName;
    AP<WCHAR>   m_pwcsDomainController;
    bool		m_fServerName;
    GUID        m_guidObject;

};

//-----------------------------------------------------------------------------------
//
//      CQueueObject
//
//  encapsulates operations performed on queues.
//
//-----------------------------------------------------------------------------------
class CQueueObject : public CBasicObjectType
{
public:
    CQueueObject(
			IN  LPCWSTR         pwcsPathName,
			IN  const GUID *    pguidObject,
			IN LPCWSTR          pwcsDomainController,
			IN  bool		    fServerName
            );

	~CQueueObject();
    virtual HRESULT ComposeObjectDN();
    virtual HRESULT ComposeFatherDN();
    virtual LPCWSTR GetRelativeDN();

    virtual DS_CONTEXT GetADContext() const;
    virtual bool ToAccessDC() const;
    virtual bool ToAccessGC() const;
    virtual void ObjectWasFoundOnDC();

    virtual LPCWSTR GetObjectCategory();
    virtual DWORD   GetObjectCategoryLength();
    virtual AD_OBJECT GetObjectType() const;
    virtual LPCWSTR GetClass() const;
    virtual DWORD GetMsmq1ObjType() const;


    virtual HRESULT DeleteObject(
            IN MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );

    virtual HRESULT RetreiveObjectIdFromNotificationInfo(
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            OUT GUID*                         pObjGuid
            ) const;

    virtual void PrepareObjectInfoRequest(
		        OUT MQDS_OBJ_INFO_REQUEST** ppObjInfoRequest
				) const;

    virtual void PrepareObjectParentRequest(
		     OUT MQDS_OBJ_INFO_REQUEST**  ppParentInfoRequest
			 ) const;

    virtual PROPID GetObjectSecurityPropid() const { return PROPID_Q_SECURITY;};

    virtual HRESULT VerifyAndAddProps(
            IN  const DWORD            cp,
            IN  const PROPID *         aProp,
            IN  const MQPROPVARIANT *  apVar,
            IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
            OUT DWORD*                 pcpNew,
            OUT PROPID**               ppPropNew,
            OUT MQPROPVARIANT**        ppVarNew
            );

    virtual HRESULT SetObjectProperties(
            IN DWORD                  cp,
            IN const PROPID          *aProp,
            IN const MQPROPVARIANT   *apVar,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );

    virtual void CreateNotification(
            IN LPCWSTR                        pwcsDomainController,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest
            ) const;

    virtual void ChangeNotification(
            IN LPCWSTR                        pwcsDomainController,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest
            ) const;

    virtual void DeleteNotification(
            IN LPCWSTR                        pwcsDomainController,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest
            ) const;

    virtual HRESULT CreateInAD(
	        IN const DWORD            cp,
            IN const PROPID          *aProp,
            IN const MQPROPVARIANT   *apVar,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );

    virtual HRESULT GetComputerVersion(
                OUT PROPVARIANT *           pVar
                );

private:
    HRESULT SplitAndFilterQueueName(
                IN  LPCWSTR             pwcsPathName,
                OUT LPWSTR *            ppwcsMachineName,
                OUT LPWSTR *            ppwcsQueueName
                );

    DWORD CalHashKey( IN LPCWSTR pwcsPathName);


private:
    bool m_fTriedToFindObject;
    bool m_fFoundInDC;
    static AP<WCHAR>   m_pwcsCategory;
    static DWORD  m_dwCategoryLength;
    AP<WCHAR>   m_pwcsQueueName;
    AP<WCHAR>   m_pwcsQueueNameSuffix;
    AP<BYTE>    m_pDefaultSecurityDescriptor;


};

//-----------------------------------------------------------------------------------
//
//      CMqConfigurationObject
//
//  encapsulates operations performed on msmq-configuration objects.
//
//-----------------------------------------------------------------------------------
class CMqConfigurationObject : public CBasicObjectType
{
public:
    CMqConfigurationObject(
                    IN LPCWSTR         pwcsPathName,
                    IN const GUID *    pguidObject,
                    IN LPCWSTR         pwcsDomainController,
			        IN  bool		   fServerName
                    );

	~CMqConfigurationObject();
    virtual HRESULT ComposeObjectDN();
    virtual HRESULT ComposeFatherDN();
    virtual LPCWSTR GetRelativeDN();

    virtual DS_CONTEXT GetADContext() const;
    virtual bool ToAccessDC() const;
    virtual bool ToAccessGC() const;
    virtual void ObjectWasFoundOnDC();


    virtual LPCWSTR GetObjectCategory();
    virtual DWORD   GetObjectCategoryLength();
    virtual AD_OBJECT GetObjectType() const;
    virtual LPCWSTR GetClass() const;
    virtual DWORD GetMsmq1ObjType() const;

    virtual HRESULT DeleteObject(
            IN MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );

    virtual HRESULT GetObjectProperties(
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT  PROPVARIANT         apVar[]
                );

    virtual HRESULT RetreiveObjectIdFromNotificationInfo(
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            OUT GUID*                         pObjGuid
            ) const;
    virtual void PrepareObjectInfoRequest(
		        OUT MQDS_OBJ_INFO_REQUEST** ppObjInfoRequest
				) const;
    virtual PROPID GetObjectSecurityPropid() const { return PROPID_QM_SECURITY;};
    virtual HRESULT CreateInAD(
			IN const DWORD            cp,
            IN const PROPID          *aProp,
            IN const MQPROPVARIANT   *apVar,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );

    virtual HRESULT SetObjectProperties(
            IN DWORD                  cp,
            IN const PROPID          *aProp,
            IN const MQPROPVARIANT   *apVar,
            IN PSECURITY_DESCRIPTOR    pSecurityDescriptor,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );

    virtual void ChangeNotification(
            IN LPCWSTR                        pwcsDomainController,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest
            ) const;

private:
    bool DecideProviderAccordingToRequestedProps(
                 IN  const DWORD   cp,
                 IN  const PROPID  aProp[  ]
                 );

    HRESULT GetUniqueIdOfConfigurationObject(
                OUT GUID* const         pguidId,
                OUT BOOL* const         pfServer
                );
    HRESULT  DeleteMsmqSetting(
                IN const GUID *     pguidQMid
                );


    HRESULT  SetDefaultMachineSecurity(
                IN  PSID            pComputerSid,
                IN OUT DWORD       *pcp,
                IN OUT PROPID       aProp[  ],
                IN OUT PROPVARIANT  apVar[  ],
                OUT PSECURITY_DESCRIPTOR* ppMachineSD
                );
    HRESULT CreateMachineSettings(
                IN DWORD                dwNumSites,
                IN const GUID *         pSite,
                IN BOOL                 fRouter,
                IN BOOL                 fDSServer,
                IN BOOL                 fDepClServer,
                IN BOOL                 fSetQmOldService,
                IN DWORD                dwOldService,
                IN  const GUID *        pguidObject
                );

    HRESULT CreateForeignComputer(
                IN  LPCWSTR         pwcsPathName
                );


    HRESULT SetMachinePropertiesWithSitesChange(
            IN  const DWORD          cp,
            IN  const PROPID *       pPropIDs,
            IN  const MQPROPVARIANT *pPropVars,
            IN  DWORD                dwSiteIdsIndex
            );

    HRESULT DeleteMsmqSettingOfServerInSite(
              IN const GUID *        pguidComputerId,
              IN const WCHAR *       pwcsSite
              );

private:
    bool m_fTriedToFindObject;
    bool m_fFoundInDC;
    bool m_fCanBeRetrievedFromGC;
    static AP<WCHAR>   m_pwcsCategory;
    static DWORD  m_dwCategoryLength;

};

//-----------------------------------------------------------------------------------
//
//      CSiteObject
//
//  encapsulates operations performed on site objects.
//
//-----------------------------------------------------------------------------------
class CSiteObject : public CBasicObjectType
{
public:
    CSiteObject(
			IN  LPCWSTR         pwcsPathName,
			IN  const GUID *    pguidObject,
			IN  LPCWSTR         pwcsDomainController,
			IN  bool		    fServerName
			);

	~CSiteObject();
    virtual HRESULT ComposeObjectDN();
    virtual HRESULT ComposeFatherDN();
    virtual LPCWSTR GetRelativeDN();

    virtual DS_CONTEXT GetADContext() const;
    virtual bool ToAccessDC() const;
    virtual bool ToAccessGC() const;
    virtual void ObjectWasFoundOnDC();

    virtual LPCWSTR GetObjectCategory();
    virtual DWORD   GetObjectCategoryLength();
    virtual AD_OBJECT GetObjectType() const;
    virtual LPCWSTR GetClass() const;
    virtual DWORD GetMsmq1ObjType() const;
    virtual PROPID GetObjectSecurityPropid() const { return PROPID_S_SECURITY;};

    virtual HRESULT VerifyAndAddProps(
            IN  const DWORD            cp,
            IN  const PROPID *         aProp,
            IN  const MQPROPVARIANT *  apVar,
            IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
            OUT DWORD*                 pcpNew,
            OUT PROPID**               ppPropNew,
            OUT MQPROPVARIANT**        ppVarNew
            );

    virtual HRESULT SetObjectSecurity(
            IN  SECURITY_INFORMATION        RequestedInformation,
            IN  const PROPID                prop,
            IN  const PROPVARIANT *         pVar,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pParentInfoRequest
            );

private:
    static AP<WCHAR>   m_pwcsCategory;
    static DWORD  m_dwCategoryLength;
    AP<BYTE>      m_pDefaultSecurityDescriptor;

};

//-----------------------------------------------------------------------------------
//
//      CEnterpriseObject
//
//  encapsulates operations performed on enterprise object.
//
//-----------------------------------------------------------------------------------
class CEnterpriseObject : public CBasicObjectType
{
public:
    CEnterpriseObject(
			IN LPCWSTR         pwcsPathName,
			IN const GUID *    pguidObject,
			IN LPCWSTR         pwcsDomainController,
			IN bool			   fServerName
			);

	~CEnterpriseObject();
    virtual HRESULT ComposeObjectDN();
    virtual HRESULT ComposeFatherDN();
    virtual LPCWSTR GetRelativeDN();

    virtual DS_CONTEXT GetADContext() const;
    virtual bool ToAccessDC() const;
    virtual bool ToAccessGC() const;
    virtual void ObjectWasFoundOnDC();

    virtual LPCWSTR GetObjectCategory();
    virtual DWORD   GetObjectCategoryLength();
    virtual AD_OBJECT GetObjectType() const;
    virtual LPCWSTR GetClass() const;
    virtual DWORD GetMsmq1ObjType() const;
    virtual HRESULT CreateInAD(
			IN const DWORD            cp,
            IN const PROPID          *aProp,
            IN const MQPROPVARIANT   *apVar,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );
    virtual PROPID GetObjectSecurityPropid() const { return PROPID_E_SECURITY;};

    virtual HRESULT SetObjectSecurity(
            IN  SECURITY_INFORMATION        RequestedInformation,
            IN  const PROPID                prop,
            IN  const PROPVARIANT *         pVar,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pParentInfoRequest
            );

private:
    static AP<WCHAR>   m_pwcsCategory;
    static DWORD  m_dwCategoryLength;

};

//-----------------------------------------------------------------------------------
//
//      CUserObject
//
//  encapsulates operations performed on user objects.
//
//-----------------------------------------------------------------------------------
class CUserObject : public CBasicObjectType
{
public:
    CUserObject(
			IN  LPCWSTR         pwcsPathName,
			IN  const GUID *    pguidObject,
			IN  LPCWSTR         pwcsDomainController,
			IN  bool		    fServerName
			);

	~CUserObject();
    virtual HRESULT ComposeObjectDN();
    virtual HRESULT ComposeFatherDN();
    virtual LPCWSTR GetRelativeDN();

    virtual DS_CONTEXT GetADContext() const;
    virtual bool ToAccessDC() const;
    virtual bool ToAccessGC() const;
    virtual void ObjectWasFoundOnDC();

    virtual LPCWSTR GetObjectCategory();
    virtual DWORD   GetObjectCategoryLength();
    virtual AD_OBJECT GetObjectType() const;
    virtual LPCWSTR GetClass() const;
    virtual DWORD GetMsmq1ObjType() const;

    virtual HRESULT DeleteObject(
            IN MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );

    virtual HRESULT GetObjectProperties(
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT  PROPVARIANT         apVar[]
                );

    virtual HRESULT CreateInAD(
			IN const DWORD            cp,
            IN const PROPID          *aProp,
            IN const MQPROPVARIANT   *apVar,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );
    virtual PROPID GetObjectSecurityPropid() const { return ILLEGAL_PROPID_VALUE;};// not relvant

    virtual HRESULT VerifyAndAddProps(
            IN  const DWORD            cp,
            IN  const PROPID *         aProp,
            IN  const MQPROPVARIANT *  apVar,
            IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
            OUT DWORD*                 pcpNew,
            OUT PROPID**               ppPropNew,
            OUT MQPROPVARIANT**        ppVarNew
            );

    virtual HRESULT GetObjectSecurity(
            IN  SECURITY_INFORMATION    RequestedInformation,
            IN  const PROPID            prop,
            IN OUT  PROPVARIANT *       pVar
            );

    virtual HRESULT SetObjectSecurity(
            IN  SECURITY_INFORMATION        RequestedInformation,
            IN  const PROPID                prop,
            IN  const PROPVARIANT *         pVar,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pParentInfoRequest
            );

private:
    HRESULT _DeleteUserObject(
                            IN  AD_OBJECT           eObject,
                            IN const GUID *         pDigest,
                            IN  PROPID             *propIDs,
                            IN  LPCWSTR             pwcsDigest);

    HRESULT FindUserAccordingToDigest(
                    IN  BOOL            fOnlyInDC,
                    IN  AD_OBJECT       eObject,
                    IN  const GUID *    pguidDigest,
                    IN  LPCWSTR         pwcsDigest,
                    IN  DWORD           dwNumProps,
                    IN  const PROPID *  propToRetrieve,
                    IN OUT PROPVARIANT* varResults
                    );

    HRESULT _GetUserProperties(
               IN  AD_OBJECT     eObject,
               IN  LPCWSTR       pwcsDigest,
               IN  DWORD         cp,
               IN  const PROPID  aProp[],
               OUT PROPVARIANT  apVar[]
               );

    HRESULT  _CreateUserObject(
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ]
                 );

    HRESULT FindUserAccordingToSid(
                IN  BOOL            fOnlyInDC,
                IN  BOOL            fOnlyInGC,
                IN  AD_OBJECT       eObject,
                IN  BLOB *          pblobUserSid,
                IN  LPCWSTR         pwcsSID,
                IN  DWORD           dwNumProps,
                IN  const PROPID *  propToRetrieve,
                IN OUT PROPVARIANT* varResults
                );


private:
    bool m_fTriedToFindObject;
    bool m_fFoundInDC;
    static AP<WCHAR>   m_pwcsCategory;
    static DWORD  m_dwCategoryLength;
    AP<BYTE> m_pUserSid;

};

//-----------------------------------------------------------------------------------
//
//      CRoutingLinkObject
//
//  encapsulates operations performed on routing-link objects.
//
//-----------------------------------------------------------------------------------
class CRoutingLinkObject : public CBasicObjectType
{
public:
    CRoutingLinkObject(
			IN LPCWSTR         pwcsPathName,
			IN const GUID *    pguidObject,
			IN LPCWSTR         pwcsDomainController,
			IN bool		       fServerName
			);

	~CRoutingLinkObject();
    virtual HRESULT ComposeObjectDN();
    virtual HRESULT ComposeFatherDN();
    virtual LPCWSTR GetRelativeDN();

    virtual DS_CONTEXT GetADContext() const;
    virtual bool ToAccessDC() const;
    virtual bool ToAccessGC() const;
    virtual void ObjectWasFoundOnDC();

    virtual LPCWSTR GetObjectCategory();
    virtual DWORD   GetObjectCategoryLength();
    virtual AD_OBJECT GetObjectType() const;
    virtual LPCWSTR GetClass() const;
    virtual DWORD GetMsmq1ObjType() const;

    virtual HRESULT RetreiveObjectIdFromNotificationInfo(
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            OUT GUID*                         pObjGuid
            ) const;
    virtual void PrepareObjectInfoRequest(
		       OUT MQDS_OBJ_INFO_REQUEST** ppObjInfoRequest
			   ) const;

    virtual HRESULT CreateInAD(
			IN const DWORD            cp,
            IN const PROPID          *aProp,
            IN const MQPROPVARIANT   *apVar,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );
    virtual PROPID GetObjectSecurityPropid() const { return ILLEGAL_PROPID_VALUE;};

    virtual HRESULT SetObjectSecurity(
            IN  SECURITY_INFORMATION        RequestedInformation,
            IN  const PROPID                prop,
            IN  const PROPVARIANT *         pVar,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pParentInfoRequest
            );


private:
    static AP<WCHAR>   m_pwcsCategory;
    static DWORD  m_dwCategoryLength;

};

//-----------------------------------------------------------------------------------
//
//      CServerObject
//
//  encapsulates operations performed on server objects.
//
//-----------------------------------------------------------------------------------
class CServerObject : public CBasicObjectType
{
public:
    CServerObject(
			IN LPCWSTR         pwcsPathName,
			IN const GUID *    pguidObject,
			IN LPCWSTR         pwcsDomainController,
			IN bool			   fServerName
			);

	~CServerObject();
    virtual HRESULT ComposeObjectDN();
    virtual HRESULT ComposeFatherDN();
    virtual LPCWSTR GetRelativeDN();

    virtual DS_CONTEXT GetADContext() const;
    virtual bool ToAccessDC() const;
    virtual bool ToAccessGC() const;
    virtual void ObjectWasFoundOnDC();

    virtual LPCWSTR GetObjectCategory();
    virtual DWORD   GetObjectCategoryLength();
    virtual AD_OBJECT GetObjectType() const;
    virtual LPCWSTR GetClass() const;
    virtual DWORD GetMsmq1ObjType() const;
    virtual PROPID GetObjectSecurityPropid() const { return ILLEGAL_PROPID_VALUE;};

    virtual HRESULT SetObjectSecurity(
            IN  SECURITY_INFORMATION        RequestedInformation,
            IN  const PROPID                prop,
            IN  const PROPVARIANT *         pVar,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pParentInfoRequest
            );


private:
    static AP<WCHAR>   m_pwcsCategory;
    static DWORD  m_dwCategoryLength;


};

//-----------------------------------------------------------------------------------
//
//      CSettingObject
//
//  encapsulates operations performed on msmq-setting objects.
//
//-----------------------------------------------------------------------------------
class CSettingObject : public CBasicObjectType
{
public:
    CSettingObject(
			IN LPCWSTR         pwcsPathName,
			IN const GUID *    pguidObject,
			IN LPCWSTR         pwcsDomainController,
			IN bool			   fServerName
			);

	~CSettingObject();
    virtual HRESULT ComposeObjectDN();
    virtual HRESULT ComposeFatherDN();
    virtual LPCWSTR GetRelativeDN();

    virtual DS_CONTEXT GetADContext() const;
    virtual bool ToAccessDC() const;
    virtual bool ToAccessGC() const;
    virtual void ObjectWasFoundOnDC();

    virtual LPCWSTR GetObjectCategory();
    virtual DWORD   GetObjectCategoryLength();
    virtual AD_OBJECT GetObjectType() const;
    virtual LPCWSTR GetClass() const;
    virtual DWORD GetMsmq1ObjType() const;
    virtual PROPID GetObjectSecurityPropid() const { return ILLEGAL_PROPID_VALUE;};

    virtual HRESULT SetObjectSecurity(
            IN  SECURITY_INFORMATION        RequestedInformation,
            IN  const PROPID                prop,
            IN  const PROPVARIANT *         pVar,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pParentInfoRequest
            );

private:
    static AP<WCHAR>   m_pwcsCategory;
    static DWORD  m_dwCategoryLength;

};

//-----------------------------------------------------------------------------------
//
//      CComputerObject
//
//  encapsulates operations performed on computer objects.
//
//-----------------------------------------------------------------------------------
class CComputerObject : public CBasicObjectType
{
public:
    CComputerObject(
			IN LPCWSTR         pwcsPathName,
			IN const GUID *    pguidObject,
			IN LPCWSTR         pwcsDomainController,
			IN bool		       fServerName
			);

	~CComputerObject();
    virtual HRESULT ComposeObjectDN();
    virtual HRESULT ComposeFatherDN();
    virtual LPCWSTR GetRelativeDN();

    virtual DS_CONTEXT GetADContext() const;
    virtual bool ToAccessDC() const;
    virtual bool ToAccessGC() const;
    virtual void ObjectWasFoundOnDC();

    virtual LPCWSTR GetObjectCategory();
    virtual DWORD   GetObjectCategoryLength();
    virtual AD_OBJECT GetObjectType() const;
    virtual LPCWSTR GetClass() const;
    virtual DWORD GetMsmq1ObjType() const;

    void SetComputerType(ComputerObjType  eComputerObjType);
    virtual PROPID GetObjectSecurityPropid() const { return ILLEGAL_PROPID_VALUE;};

    virtual HRESULT VerifyAndAddProps(
            IN  const DWORD            cp,
            IN  const PROPID *         aProp,
            IN  const MQPROPVARIANT *  apVar,
            IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
            OUT DWORD*                 pcpNew,
            OUT PROPID**               ppPropNew,
            OUT MQPROPVARIANT**        ppVarNew
            );

    virtual HRESULT CreateInAD(
			IN const DWORD            cp,
            IN const PROPID          *aProp,
            IN const MQPROPVARIANT   *apVar,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );

    virtual HRESULT SetObjectSecurity(
            IN  SECURITY_INFORMATION        RequestedInformation,
            IN  const PROPID                prop,
            IN  const PROPVARIANT *         pVar,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pParentInfoRequest
            );

    virtual HRESULT GetComputerVersion(
                OUT PROPVARIANT *           pVar
                );

private:
    bool m_fTriedToFindObject;
    bool m_fFoundInDC;
    static AP<WCHAR>   m_pwcsCategory;
    static DWORD  m_dwCategoryLength;
    ComputerObjType  m_eComputerObjType;
};

//-----------------------------------------------------------------------------------
//
//      CMqUserObject
//
//  encapsulates operations performed on msmq-user objects.
//
//-----------------------------------------------------------------------------------
class CMqUserObject : public CBasicObjectType
{
public:
    CMqUserObject(
			IN LPCWSTR         pwcsPathName,
			IN const GUID *    pguidObject,
			IN LPCWSTR         pwcsDomainController,
			IN bool		       fServerName
			);

	~CMqUserObject();
    virtual HRESULT ComposeObjectDN();
    virtual HRESULT ComposeFatherDN();
    virtual LPCWSTR GetRelativeDN();

    virtual DS_CONTEXT GetADContext() const;
    virtual bool ToAccessDC() const;
    virtual bool ToAccessGC() const;
    virtual void ObjectWasFoundOnDC();

    virtual LPCWSTR GetObjectCategory();
    virtual AD_OBJECT GetObjectType() const;
    virtual DWORD   GetObjectCategoryLength();
    virtual LPCWSTR GetClass() const;
    virtual DWORD GetMsmq1ObjType() const;

    virtual HRESULT CreateInAD(
		    IN const DWORD            cp,
            IN const PROPID          *aProp,
            IN const MQPROPVARIANT   *apVar,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            );

    virtual PROPID GetObjectSecurityPropid() const { return PROPID_MQU_SECURITY;};
private:
    HRESULT PrepareUserName(
                IN  PSID        pSid,
                OUT WCHAR **    ppwcsUserName
                );
    BOOL GetTextualSid(
            IN      PSID pSid,
            IN      LPTSTR TextualSid,
            IN OUT  LPDWORD lpdwBufferLen
            );

    void  _PrepareCert(
            IN  PROPVARIANT * pvar,
            IN  const GUID *  pguidDigest,
            IN  const GUID *  pguidId,
            OUT BYTE**        ppbAllocatedCertBlob
            );

    HRESULT _CreateMQUser(
            IN LPCWSTR              pwcsUserName,
            IN LPCWSTR              pwcsParentPathName,
            IN const DWORD          cPropIDs,
            IN const PROPID        *pPropIDs,
            IN const MQPROPVARIANT *pPropVars
            );

    virtual HRESULT SetObjectSecurity(
            IN  SECURITY_INFORMATION        RequestedInformation,
            IN  const PROPID                prop,
            IN  const PROPVARIANT *         pVar,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST *  pParentInfoRequest
            );

private:
    bool m_fTriedToFindObject;
    bool m_fFoundInDC;
    static AP<WCHAR>   m_pwcsCategory;
    static DWORD  m_dwCategoryLength;

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\ds_stdh.h ===
#ifndef _MQADSTDH_H
#define _MQADSTDH_H
#include "..\h\ds_stdh.h"
#include <mqmacro.h>

enum ComputerObjType
{
    eRealComputerObject,
    eMsmqComputerObject
} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\midluser.cpp ===
#include "ds_stdh.h"
#include "..\..\common\midluser.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\linkobj.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    link.cpp

Abstract:

    Implementation of CRoutingLinkObject class.

Author:

    ronith

--*/
#include "ds_stdh.h"
#include "baseobj.h"
#include "mqattrib.h"
#include "mqadglbo.h"
#include "dsutils.h"

#include "linkobj.tmh"

static WCHAR *s_FN=L"mqad/linkobj";

DWORD CRoutingLinkObject::m_dwCategoryLength = 0;
AP<WCHAR> CRoutingLinkObject::m_pwcsCategory = NULL;

CRoutingLinkObject::CRoutingLinkObject(
                    LPCWSTR         pwcsPathName,
                    const GUID *    pguidObject,
                    LPCWSTR         pwcsDomainController,
					bool		    fServerName
                    ) : CBasicObjectType(
								pwcsPathName,
								pguidObject,
								pwcsDomainController,
								fServerName
								)
/*++
    Abstract:
	constructor of routing-link object

    Parameters:
    LPCWSTR       pwcsPathName - the object MSMQ name
    const GUID *  pguidObject  - the object unique id
    LPCWSTR       pwcsDomainController - the DC name against
	                             which all AD access should be performed
    bool		   fServerName - flag that indicate if the pwcsDomainController
							     string is a server name

    Returns:
	none

--*/
{
}

CRoutingLinkObject::~CRoutingLinkObject()
/*++
    Abstract:
	destructor of site object

    Parameters:
	none

    Returns:
	none
--*/
{
	//
	// nothing to do ( everything is released with automatic pointers
	//
}

HRESULT CRoutingLinkObject::ComposeObjectDN()
/*++
    Abstract:
	Composed distinguished name of the routing-link object

    Parameters:
	none

    Returns:
	none
--*/
{
    if (m_pwcsDN != NULL)
    {
        return MQ_OK;
    }
    ASSERT(m_pwcsPathName != NULL);
    ASSERT(g_pwcsMsmqServiceContainer != NULL);

    DWORD Length =
            x_CnPrefixLen +                     // "CN="
            wcslen(m_pwcsPathName) +            // the routing-link name
            1 +                                 //","
            wcslen(g_pwcsMsmqServiceContainer)+ // "enterprise object"
            1;                                  // '\0'

    m_pwcsDN = new WCHAR[Length];

    DWORD dw = swprintf(
        m_pwcsDN,
        L"%s"             // "CN="
        L"%s"             // "the routing-link name"
        TEXT(",")
        L"%s",            // "enterprise object"
        x_CnPrefix,
        m_pwcsPathName,
        g_pwcsMsmqServiceContainer
        );
    DBG_USED(dw);
    ASSERT( dw < Length);

    return MQ_OK;
}

HRESULT CRoutingLinkObject::ComposeFatherDN()
/*++
    Abstract:
	Composed distinguished name of the parent of routing-link object

    Parameters:
	none

    Returns:
	none
--*/
{
    if (m_pwcsParentDN != NULL)
    {
        return MQ_OK;
    }

    ASSERT(g_pwcsMsmqServiceContainer != NULL);

    DWORD Length =
            wcslen(g_pwcsMsmqServiceContainer)+ // "enterprise object"
            1;                                  // '\0'

    m_pwcsParentDN = new WCHAR[Length];

    wcscpy( m_pwcsParentDN, g_pwcsMsmqServiceContainer);
    return MQ_OK;
}

LPCWSTR CRoutingLinkObject::GetRelativeDN()
/*++
    Abstract:
	return the RDN of the routing-link object

    Parameters:
	none

    Returns:
	LPCWSTR routing-link RDN
--*/
{
    ASSERT(m_pwcsPathName != NULL);
    return m_pwcsPathName;
}


DS_CONTEXT CRoutingLinkObject::GetADContext() const
/*++
    Abstract:
	Returns the AD context where routing-link object should be looked for

    Parameters:
	none

    Returns:
	DS_CONTEXT
--*/
{
    return e_MsmqServiceContainer;
}

bool CRoutingLinkObject::ToAccessDC() const
/*++
    Abstract:
	returns whether to look for the object in DC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	true (i.e. to look for the object in any DC)
--*/
{
    //
    //  configuration container is on every DC
    //
    return true;
}

bool CRoutingLinkObject::ToAccessGC() const
/*++
    Abstract:
	returns whether to look for the object in GC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	false
--*/
{
    //
    //  configuration container is on every DC, no use in going to GC
    //
    return false;
}

void CRoutingLinkObject::ObjectWasFoundOnDC()
/*++
    Abstract:
	The object was found on DC, this is not relevent for routing-links
    objects. They are always looked for on DC only.


    Parameters:
	none

    Returns:
	none
--*/
{
}



LPCWSTR CRoutingLinkObject::GetObjectCategory()
/*++
    Abstract:
	prepares and retruns the object category string

    Parameters:
	none

    Returns:
	LPCWSTR object category string
--*/
{
    if (CRoutingLinkObject::m_pwcsCategory == NULL)
    {
        DWORD len = wcslen(g_pwcsSchemaContainer) + wcslen(x_LinkCategoryName) + 2;

        AP<WCHAR> pwcsCategory = new WCHAR[len];
        DWORD dw = swprintf(
             pwcsCategory,
             L"%s,%s",
             x_LinkCategoryName,
             g_pwcsSchemaContainer
            );
        DBG_USED(dw);
        ASSERT( dw< len);

        if (NULL == InterlockedCompareExchangePointer(
                              &CRoutingLinkObject::m_pwcsCategory.ref_unsafe(),
                              pwcsCategory.get(),
                              NULL
                              ))
        {
            pwcsCategory.detach();
            CRoutingLinkObject::m_dwCategoryLength = len;
        }
    }
    return CRoutingLinkObject::m_pwcsCategory;
}

DWORD   CRoutingLinkObject::GetObjectCategoryLength()
/*++
    Abstract:
	prepares and retruns the length object category string

    Parameters:
	none

    Returns:
	DWORD object category string length
--*/
{
	//
	//	call GetObjectCategory in order to initailaze category string
	//	and length
	//
	GetObjectCategory();

    return CRoutingLinkObject::m_dwCategoryLength;
}

AD_OBJECT CRoutingLinkObject::GetObjectType() const
/*++
    Abstract:
	returns the object type

    Parameters:
	none

    Returns:
	AD_OBJECT
--*/
{
    return eROUTINGLINK;
}

LPCWSTR CRoutingLinkObject::GetClass() const
/*++
    Abstract:
	returns a string represinting the object class in AD

    Parameters:
	none

    Returns:
	LPCWSTR object class string
--*/
{
    return MSMQ_SITELINK_CLASS_NAME;
}

DWORD CRoutingLinkObject::GetMsmq1ObjType() const
/*++
    Abstract:
	returns the object type in MSMQ 1.0 terms

    Parameters:
	none

    Returns:
	DWORD
--*/
{
    return MQDS_SITELINK;
}

void CRoutingLinkObject::PrepareObjectInfoRequest(
                          MQDS_OBJ_INFO_REQUEST** ppObjInfoRequest) const
/*++
    Abstract:
	Prepares a list of properties that should be retrieved from
	AD while creating the object ( for notification or returning
	the object GUID).

    Parameters:
	OUT  MQDS_OBJ_INFO_REQUEST** ppObjInfoRequest

    Returns:
	none
--*/
{
    //
    //  Override the default routine, for routing link returning
    //  of the created object id is supported
    //
    P<MQDS_OBJ_INFO_REQUEST> pObjectInfoRequest = new MQDS_OBJ_INFO_REQUEST;
    CAutoCleanPropvarArray cCleanObjectPropvars;


    static PROPID sLinkGuidProps[] = {PROPID_L_ID};
    pObjectInfoRequest->cProps = ARRAY_SIZE(sLinkGuidProps);
    pObjectInfoRequest->pPropIDs = sLinkGuidProps;
    pObjectInfoRequest->pPropVars =
       cCleanObjectPropvars.allocClean(ARRAY_SIZE(sLinkGuidProps));
    //
    // ask for link info only back
    //
    cCleanObjectPropvars.detach();
    *ppObjInfoRequest = pObjectInfoRequest.detach();
}


HRESULT CRoutingLinkObject::RetreiveObjectIdFromNotificationInfo(
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            OUT GUID*                         pObjGuid
            ) const
/*++
    Abstract:
	This  routine, for gets the object guid from
	the MQDS_OBJ_INFO_REQUEST

    Parameters:
    const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
    OUT GUID*                         pObjGuid

    Returns:
--*/
{
    ASSERT(pObjectInfoRequest->pPropIDs[0] == PROPID_L_ID);

    //
    // bail if info requests failed
    //
    if (FAILED(pObjectInfoRequest->hrStatus))
    {
        LogHR(pObjectInfoRequest->hrStatus, s_FN, 10);
        return MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }
    *pObjGuid = *pObjectInfoRequest->pPropVars[0].puuid;
    return MQ_OK;
}

HRESULT CRoutingLinkObject::CreateInAD(
			IN const DWORD            cp,
            IN const PROPID          *aProp,
            IN const MQPROPVARIANT   *apVar,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            )
/*++
    Abstract:
	The routine creates routing link object in AD with the specified attributes
	values

    Parameters:
    const DWORD   cp - number of properties
    const PROPID  *aProp - the propperties
    const MQPROPVARIANT *apVar - properties value
    PSECURITY_DESCRIPTOR    pSecurityDescriptor - SD of the object
    OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - properties to
							retrieve while creating the object
    OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - properties
						to retrieve about the object's parent
    Returns:
	HRESULT
--*/
{

    ASSERT( m_pwcsPathName == NULL);

    //
    //  The link path name will be composed
    //  from the ids of the sites it links.
    //
    GUID * pguidNeighbor1 = NULL;
    GUID * pguidNeighbor2 = NULL;
    DWORD dwToFind = 2;
    for (DWORD i = 0; i < cp; i++)
    {
        if ( aProp[i] == PROPID_L_NEIGHBOR1)
        {
            pguidNeighbor1 = apVar[i].puuid;
            if ( --dwToFind == 0)
            {
                break;
            }
        }
        if ( aProp[i] == PROPID_L_NEIGHBOR2)
        {
            pguidNeighbor2 = apVar[i].puuid;
            if ( --dwToFind == 0)
            {
                break;
            }
        }
    }
    ASSERT( pguidNeighbor1 != NULL);
    ASSERT( pguidNeighbor2 != NULL);
    //
    //  cn has a size limit of 64.
    //  Therefore guid format is without '-'
    //

const WCHAR x_GUID_FORMAT[] = L"%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x";
const DWORD x_GUID_STR_LENGTH = (8 + 4 + 4 + 4 + 12 + 1);

    WCHAR strUuidSite1[x_GUID_STR_LENGTH];
    WCHAR strUuidSite2[x_GUID_STR_LENGTH];

    _snwprintf(
        strUuidSite1,
        x_GUID_STR_LENGTH,
        x_GUID_FORMAT,
        pguidNeighbor1->Data1, pguidNeighbor1->Data2, pguidNeighbor1->Data3,
        pguidNeighbor1->Data4[0], pguidNeighbor1->Data4[1],
        pguidNeighbor1->Data4[2], pguidNeighbor1->Data4[3],
        pguidNeighbor1->Data4[4], pguidNeighbor1->Data4[5],
        pguidNeighbor1->Data4[6], pguidNeighbor1->Data4[7]
        );
    strUuidSite1[ TABLE_SIZE(strUuidSite1) - 1 ] = L'\0';

    _snwprintf(
        strUuidSite2,
        x_GUID_STR_LENGTH,
        x_GUID_FORMAT,
        pguidNeighbor2->Data1, pguidNeighbor2->Data2, pguidNeighbor2->Data3,
        pguidNeighbor2->Data4[0], pguidNeighbor2->Data4[1],
        pguidNeighbor2->Data4[2], pguidNeighbor2->Data4[3],
        pguidNeighbor2->Data4[4], pguidNeighbor2->Data4[5],
        pguidNeighbor2->Data4[6], pguidNeighbor2->Data4[7]
        );
    strUuidSite2[ TABLE_SIZE(strUuidSite2) - 1 ] = L'\0' ;


    //
    //  The link name will start with the smaller site id
    //
    m_pwcsPathName = new WCHAR[2 * x_GUID_STR_LENGTH + 1];
    if ( wcscmp( strUuidSite1, strUuidSite2) < 0)
    {
        swprintf(
             m_pwcsPathName,
             L"%s%s",
             strUuidSite1,
             strUuidSite2
             );

    }
    else
    {
        swprintf(
             m_pwcsPathName,
             L"%s%s",
             strUuidSite2,
             strUuidSite1
             );
    }
    //
    //  Create the link object under msmq-service
    //
    HRESULT hr = CBasicObjectType::CreateInAD(
            cp,
            aProp,
            apVar,
            pObjInfoRequest,
            pParentInfoRequest
            );

    return LogHR(hr, s_FN, 20);
}

HRESULT CRoutingLinkObject::SetObjectSecurity(
            IN  SECURITY_INFORMATION        /*RequestedInformation*/,
            IN  const PROPID                /*prop*/,
            IN  const PROPVARIANT *         /*pVar*/,
            IN OUT MQDS_OBJ_INFO_REQUEST *  /*pObjInfoRequest*/,
            IN OUT MQDS_OBJ_INFO_REQUEST *  /*pParentInfoRequest*/
            )
/*++

Routine Description:
    The routine sets object security in AD

Arguments:
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - infomation about the object
    MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - information about the object's parent

Return Value
	HRESULT

--*/
{
    //
    //  This operation is not supported
    //
    return MQ_ERROR_FUNCTION_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\entrobj.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    confobj.cpp

Abstract:

    Implementation of CEnterpriseObject class.

Author:

    ronith

--*/
#include "ds_stdh.h"
#include "baseobj.h"
#include "mqattrib.h"
#include "mqadglbo.h"

#include "entrobj.tmh"

static WCHAR *s_FN=L"mqad/entrobj";

DWORD CEnterpriseObject::m_dwCategoryLength = 0;
AP<WCHAR> CEnterpriseObject::m_pwcsCategory = NULL;

CEnterpriseObject::CEnterpriseObject( 
                    LPCWSTR         pwcsPathName,
                    const GUID *    pguidObject,
                    LPCWSTR         pwcsDomainController,
					bool		    fServerName
                    ) : CBasicObjectType( 
								pwcsPathName, 
								pguidObject,
								pwcsDomainController,
								fServerName
								)
/*++
    Abstract:
	constructor of enterprise object

    Parameters:
    LPCWSTR       pwcsPathName - the object MSMQ name
    const GUID *  pguidObject  - the object unique id
    LPCWSTR       pwcsDomainController - the DC name against
	                             which all AD access should be performed
    bool		   fServerName - flag that indicate if the pwcsDomainController
							     string is a server name

    Returns:
	none

--*/
{
}

CEnterpriseObject::~CEnterpriseObject()
/*++
    Abstract:
	destructor of site object

    Parameters:
	none

    Returns:
	none
--*/
{
	//
	// nothing to do ( everything is released with automatic pointers
	//
}

HRESULT CEnterpriseObject::ComposeObjectDN()
/*++
    Abstract:
	Composed distinguished name of the enterprise object

    Parameters:
	none

    Returns:
	none
--*/
{
    if (m_pwcsDN != NULL)
    {
        return MQ_OK;
    }
    ASSERT(g_pwcsMsmqServiceContainer != NULL);
    DWORD len = wcslen( g_pwcsMsmqServiceContainer);
    m_pwcsDN = new WCHAR[ len + 1];
    wcscpy( m_pwcsDN,  g_pwcsMsmqServiceContainer);
    return MQ_OK;
}

HRESULT CEnterpriseObject::ComposeFatherDN()
/*++
    Abstract:
	Composed distinguished name of the parent of enterpise object

    Parameters:
	none

    Returns:
	none
--*/
{
	//
	//	not supposed to be called
	//
	ASSERT(0);
    LogIllegalPoint(s_FN, 81);
    return MQ_ERROR_DS_ERROR;
}

LPCWSTR CEnterpriseObject::GetRelativeDN()
/*++
    Abstract:
	return the RDN of the enterprise object

    Parameters:
	none

    Returns:
	LPCWSTR enterprise RDN
--*/
{
    return x_MsmqServicesName;
}


DS_CONTEXT CEnterpriseObject::GetADContext() const
/*++
    Abstract:
	Returns the AD context where enterprise object should be looked for

    Parameters:
	none

    Returns:
	DS_CONTEXT
--*/
{
    return e_ServicesContainer;
}

bool CEnterpriseObject::ToAccessDC() const
/*++
    Abstract:
	returns whether to look for the object in DC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	true (i.e. to look for the object in any DC)
--*/
{
    //
    //  configuration container is on every DC
    //
    return true;
}

bool CEnterpriseObject::ToAccessGC() const
/*++
    Abstract:
	returns whether to look for the object in GC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	false 
--*/
{
    //
    //  configuration container is on every DC no use in going to GC
    //
    return false;
}

void CEnterpriseObject::ObjectWasFoundOnDC()
/*++
    Abstract:
	The object was found on DC, it is not relevant for enterprise object
    it is always looked only on DC.


    Parameters:
	none

    Returns:
	none
--*/
{
}



LPCWSTR CEnterpriseObject::GetObjectCategory() 
/*++
    Abstract:
	prepares and retruns the object category string

    Parameters:
	none

    Returns:
	LPCWSTR object category string
--*/
{
    if (CEnterpriseObject::m_pwcsCategory == NULL)
    {
        DWORD len = wcslen(g_pwcsSchemaContainer) + wcslen(x_ServiceCategoryName) + 2;

        AP<WCHAR> pwcsCategory = new WCHAR[len];
        DWORD dw = swprintf(
             pwcsCategory,
             L"%s,%s",
             x_ServiceCategoryName,
             g_pwcsSchemaContainer
            );
        DBG_USED(dw);
        ASSERT( dw < len);

        if (NULL == InterlockedCompareExchangePointer(
                              &CEnterpriseObject::m_pwcsCategory.ref_unsafe(), 
                              pwcsCategory.get(),
                              NULL
                              ))
        {
            pwcsCategory.detach();
            CEnterpriseObject::m_dwCategoryLength = len;
        }
    }
    return CEnterpriseObject::m_pwcsCategory;
}

DWORD   CEnterpriseObject::GetObjectCategoryLength()
/*++
    Abstract:
	prepares and retruns the length object category string

    Parameters:
	none

    Returns:
	DWORD object category string length
--*/
{
	//
	//	call GetObjectCategory in order to initailaze category string
	//	and length
	//
	GetObjectCategory();

    return CEnterpriseObject::m_dwCategoryLength;
}

AD_OBJECT CEnterpriseObject::GetObjectType() const
/*++
    Abstract:
	returns the object type

    Parameters:
	none

    Returns:
	AD_OBJECT
--*/
{
    return eENTERPRISE;
}

LPCWSTR CEnterpriseObject::GetClass() const
/*++
    Abstract:
	returns a string represinting the object class in AD

    Parameters:
	none

    Returns:
	LPCWSTR object class string
--*/
{
    return MSMQ_SERVICE_CLASS_NAME;
}

DWORD CEnterpriseObject::GetMsmq1ObjType() const
/*++
    Abstract:
	returns the object type in MSMQ 1.0 terms

    Parameters:
	none

    Returns:
	DWORD 
--*/
{
    return MQDS_ENTERPRISE;
}

HRESULT CEnterpriseObject::CreateInAD(
			IN const DWORD            /* cp*/,        
            IN const PROPID*          /* aProp*/, 
            IN const MQPROPVARIANT *  /* apVar*/, 
            IN OUT MQDS_OBJ_INFO_REQUEST * /* pObjInfoRequest*/, 
            IN OUT MQDS_OBJ_INFO_REQUEST * /* pParentInfoRequest*/
            )
/*++
    Abstract:
	creating an enterprise object is not supported ( it is there by default)

    Parameters:
    const DWORD   cp - number of properties        
    const PROPID  *aProp - the propperties
    const MQPROPVARIANT *apVar - properties value
    PSECURITY_DESCRIPTOR    pSecurityDescriptor - SD of the object
    OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - properties to 
							retrieve while creating the object 
    OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - properties 
						to retrieve about the object's parent
    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_FUNCTION_NOT_SUPPORTED;
}

HRESULT CEnterpriseObject::SetObjectSecurity(
            IN  SECURITY_INFORMATION        /*RequestedInformation*/,
            IN  const PROPID                /*prop*/,
            IN  const PROPVARIANT *         /*pVar*/,
            IN OUT MQDS_OBJ_INFO_REQUEST *  /*pObjInfoRequest*/, 
            IN OUT MQDS_OBJ_INFO_REQUEST *  /*pParentInfoRequest*/
            )
/*++

Routine Description:
    The routine sets object security in AD 

Arguments:
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - infomation about the object
    MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - information about the object's parent

Return Value
	HRESULT

--*/
{
    //
    //  This operation is not supported
    //
    return MQ_ERROR_FUNCTION_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\mqadp.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mqadp.cpp

Abstract:

    MQAD DLL private internal functions for
    DS queries, etc.

Author:

    ronit hartmann ( ronith)

--*/

#include "ds_stdh.h"
#include <mqaddef.h>
#include "baseobj.h"
#include "mqadglbo.h"
#include "siteinfo.h"
#include "mqattrib.h"
#include "utils.h"
#include "adtempl.h"
#include "dsutils.h"
#include "mqadp.h"
#include "queryh.h"
#include "delqn.h"

#include "mqadp.tmh"

static WCHAR *s_FN=L"mqad/mqadp";



void MQADpAllocateObject(
                AD_OBJECT           eObject,
                LPCWSTR             pwcsDomainController,
				bool				fServerName,
                LPCWSTR             pwcsObjectName,
                const GUID *        pguidObject,
                CBasicObjectType**   ppObject
                )
{

    switch( eObject)
    {
    case eQUEUE:
        *ppObject = new CQueueObject(
                                    pwcsObjectName,
                                    pguidObject,
                                    pwcsDomainController,
									fServerName
                                    );
        break;

    case eMACHINE:
        *ppObject = new CMqConfigurationObject(
                                    pwcsObjectName,
                                    pguidObject,
                                    pwcsDomainController,
									fServerName
                                    );
        break;

    case eSITE:
        *ppObject = new CSiteObject(
                                    pwcsObjectName,
                                    pguidObject,
                                    pwcsDomainController,
									fServerName
                                    );
        break;

    case eENTERPRISE:
        *ppObject = new CEnterpriseObject(
                                    pwcsObjectName,
                                    pguidObject,
                                    pwcsDomainController,
									fServerName
                                    );
        break;

    case eUSER:
        *ppObject = new CUserObject(
                                    pwcsObjectName,
                                    pguidObject,
                                    pwcsDomainController,
									fServerName
                                    );
        break;

    case eROUTINGLINK:
        *ppObject = new CRoutingLinkObject(
                                    pwcsObjectName,
                                    pguidObject,
                                    pwcsDomainController,
									fServerName
                                    );
        break;

    case eSERVER:
        *ppObject = new CServerObject(
                                    pwcsObjectName,
                                    pguidObject,
                                    pwcsDomainController,
									fServerName
                                    );
        break;

    case eSETTING:
        *ppObject = new CSettingObject(
                                    pwcsObjectName,
                                    pguidObject,
                                    pwcsDomainController,
									fServerName
                                    );
        break;

    case eCOMPUTER:
        *ppObject = new CComputerObject(
                                    pwcsObjectName,
                                    pguidObject,
                                    pwcsDomainController,
									fServerName
                                    );
        break;

    case eMQUSER:
        *ppObject = new CMqUserObject(
                                    pwcsObjectName,
                                    pguidObject,
                                    pwcsDomainController,
									fServerName
                                    );
        break;


    default:
        ASSERT(0);
        *ppObject = NULL;
        break;
    }
}


const WCHAR x_limitedChars[] = {L'\n',L'/',L'#',L'>',L'<', L'=', 0x0a, 0};
const DWORD x_numLimitedChars = sizeof(x_limitedChars)/sizeof(WCHAR) - 1;

/*====================================================
    FilterSpecialCharaters()
    Pares the object (queue) name and add escape character before limited chars

    If pwcsOutBuffer is NULL, the function allocates a new buffer and return it as
    return value. Otherwise, it uses pwcsOutBuffer, and return it. If pwcsOutBuffer is not
    NULL, it should point to a buffer of lenght dwNameLength*2 +1, at least.

  NOTE: dwNameLength does not contain existing escape characters, if any
=====================================================*/
WCHAR * FilterSpecialCharacters(
            IN     LPCWSTR          pwcsObjectName,
            IN     const DWORD      dwNameLength,
            IN OUT LPWSTR pwcsOutBuffer /* = 0 */,
            OUT    DWORD_PTR* pdwCharactersProcessed /* = 0 */)

{
    AP<WCHAR> pBufferToRelease;
    LPWSTR pname;

    if (pwcsOutBuffer != 0)
    {
        pname = pwcsOutBuffer;
    }
    else
    {
        pBufferToRelease = new WCHAR[ (dwNameLength *2) + 1];
        pname = pBufferToRelease;
    }

    const WCHAR * pInChar = pwcsObjectName;
    WCHAR * pOutChar = pname;
    for ( DWORD i = 0; i < dwNameLength; i++, pInChar++, pOutChar++)
    {
        //
        // Ignore current escape characters
        //
        if (*pInChar == L'\\')
        {
            *pOutChar = *pInChar;
            pOutChar++;
            pInChar++;
        }
        else
        {
            //
            // Add backslash before special characters, unless it was there
            // already.
            //
            if ( 0 != wcschr(x_limitedChars, *pInChar))
            {
                *pOutChar = L'\\';
                pOutChar++;
            }
        }

        *pOutChar = *pInChar;
    }
    *pOutChar = L'\0';

    pBufferToRelease.detach();

    if (pdwCharactersProcessed != 0)
    {
        *pdwCharactersProcessed = pInChar - pwcsObjectName;
    }
    return( pname);
}

CCriticalSection s_csInitialization;

HRESULT 
MQADInitialize(
    IN  bool    fIncludingVerify
    )
/*++

Routine Description:
    Initialize MQAD

Arguments:
    fIncludingVerify - indication if initialization of update-allowed is
                       required for the performed operation

Return Value
	HRESULT

--*/
{

    if (fIncludingVerify)
    {
        HRESULT hr = g_VerifyUpdate.Initialize(); 
        if (FAILED(hr))
        {
			TrERROR(mqad, "g_VerifyUpdate.Initialize failed, create/delete/update operation will not be allowed, hr = 0x%x", hr);
            return LogHR(hr, s_FN, 20);
        }
    }

    if (g_fInitialized)
    {
        return MQ_OK;
    }

    //
    //  Postponding initialization to the point where Active
    //  Directory access is really needed
    //

    //
    //  Access AD without holding critical section
    //
    AP<WCHAR> pwcsDsRoot;
    AP<WCHAR> pwcsLocalDsRoot;
    AP<WCHAR> pwcsSchemaContainer;

    HRESULT hr = g_AD.GetRootDsName(
                    &pwcsDsRoot,
                    &pwcsLocalDsRoot,
                    &pwcsSchemaContainer
                    );

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    {
        CS lock(s_csInitialization);
        if (g_fInitialized)
        {
            return MQ_OK;
        }

		//
		// Initialize global constant strings, done only once
		//
		
		ASSERT(g_pwcsDsRoot.get() == NULL);

        g_pwcsDsRoot = pwcsDsRoot.detach();
		TrTRACE(mqad, "DsRoot = %ls", g_pwcsDsRoot.get());  

        g_pwcsLocalDsRoot = pwcsLocalDsRoot.detach();
		TrTRACE(mqad, "LocalDsRoot = %ls", g_pwcsLocalDsRoot.get());  

        g_pwcsSchemaContainer = pwcsSchemaContainer.detach();
		TrTRACE(mqad, "SchemaContainer = %ls", g_pwcsSchemaContainer.get());  

        MQADpInitPropertyTranslationMap();

        //
        //  build services, sites and msmq-service path names
        //
        DWORD len = wcslen(g_pwcsDsRoot);

        g_pwcsConfigurationContainer = new WCHAR[len +  x_ConfigurationPrefixLen + 2];
        swprintf(
            g_pwcsConfigurationContainer,
             L"%s"
             TEXT(",")
             L"%s",
            x_ConfigurationPrefix,
            g_pwcsDsRoot
            );

		TrTRACE(mqad, "ConfigurationContainer = %ls", g_pwcsConfigurationContainer.get());  

        g_pwcsServicesContainer = new WCHAR[len +  x_ServiceContainerPrefixLen + 2];
        swprintf(
            g_pwcsServicesContainer,
             L"%s"
             TEXT(",")
             L"%s",
            x_ServicesContainerPrefix,
            g_pwcsDsRoot
            );

		TrTRACE(mqad, "ServicesContainer = %ls", g_pwcsServicesContainer.get());  

        g_pwcsMsmqServiceContainer = new WCHAR[len + x_MsmqServiceContainerPrefixLen + 2];
        swprintf(
            g_pwcsMsmqServiceContainer,
             L"%s"
             TEXT(",")
             L"%s",
            x_MsmqServiceContainerPrefix,
            g_pwcsDsRoot
            );

		TrTRACE(mqad, "MsmqServiceContainer = %ls", g_pwcsMsmqServiceContainer.get());  

        g_pwcsSitesContainer = new WCHAR[len +  x_SitesContainerPrefixLen + 2];

        swprintf(
            g_pwcsSitesContainer,
             L"%s"
             TEXT(",")
             L"%s",
            x_SitesContainerPrefix,
            g_pwcsDsRoot
            );

		TrTRACE(mqad, "SitesContainer = %ls", g_pwcsSitesContainer.get());  

        g_fInitialized = true;
    }
    return MQ_OK;
}

//+------------------------------------------
//
//  HRESULT MQADpQueryNeighborLinks()
//
//+------------------------------------------

HRESULT MQADpQueryNeighborLinks(
                        IN  LPCWSTR            pwcsDomainController,
						IN  bool			   fServerName,
                        IN  eLinkNeighbor      LinkNeighbor,
                        IN  LPCWSTR            pwcsNeighborDN,
                        IN OUT CSiteGateList * pSiteGateList
                        )

/*++

Routine Description:

Arguments:
        eLinkNeighbor :  specify according to which neighbor property, to perform
                         the locate ( PROPID_L_NEIGHBOR1 or PROPID_L_NEIGHBOR2)
        pwcsNeighborDN : the DN name of the site

        CSiteGateList : list of site-gates

Return Value:
--*/
{
    //
    //  Query the gates on all the links of a specific site ( pwcsNeighborDN).
    //  But only on links where the site is specified as
    //  neighbor-i ( 1 or 2)
    //
    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;

    const WCHAR * pwcsAttribute = NULL;

    if ( LinkNeighbor == eLinkNeighbor1)
    {
        pwcsAttribute = MQ_L_NEIGHBOR1_ATTRIBUTE;
    }
    else
    {
        pwcsAttribute = MQ_L_NEIGHBOR2_ATTRIBUTE;
    }
    ASSERT( pwcsAttribute != NULL);


    AP<WCHAR> pwcsFilteredNeighborDN;
    StringToSearchFilter( pwcsNeighborDN,
                          &pwcsFilteredNeighborDN
                          );
    R<CRoutingLinkObject> pObject = new CRoutingLinkObject(NULL,NULL, pwcsDomainController, fServerName);
                          
    DWORD dwFilterLen = x_ObjectCategoryPrefixLen +
                        pObject->GetObjectCategoryLength() +
                        x_ObjectCategorySuffixLen + 
                        wcslen(pwcsAttribute) +
                        wcslen(pwcsFilteredNeighborDN) +
                        13;

    AP<WCHAR> pwcsSearchFilter = new WCHAR[ dwFilterLen];

    DWORD dw = swprintf(
        pwcsSearchFilter,
        L"(&%s%s%s(%s=%s))",
        x_ObjectCategoryPrefix,
        pObject->GetObjectCategory(),
        x_ObjectCategorySuffix,
        pwcsAttribute,
        pwcsFilteredNeighborDN
        );
    DBG_USED( dw);
	ASSERT( dw < dwFilterLen);


    PROPID prop = PROPID_L_GATES_DN;

    CAdQueryHandle hQuery;
    HRESULT hr;

    hr = g_AD.LocateBegin(
            searchOneLevel,	
            adpDomainController,
            e_MsmqServiceContainer,
            pObject.get(),
            NULL,   //pguidSearchBase
            pwcsSearchFilter,
            NULL,   // pDsSortkey 
            1,
            &prop,
            hQuery.GetPtr());

    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADpQueryNeighborLinks : MsmqServices not found %lx"),hr));
        return(MQ_OK);
    }
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADpQueryNeighborLinks : Locate begin failed %lx"),hr));
        return LogHR(hr, s_FN, 190);
    }
    //
    //  Read the results one by one
    //

    DWORD cp = 1;

    while (SUCCEEDED(hr))
    {
        cp = 1;
        CMQVariant var;
        var.SetNULL();

        hr = g_AD.LocateNext(
                    hQuery.GetHandle(),
                    &cp,
                    var.CastToStruct()
                    );
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADpQueryNeighborLinks : Locate next failed %lx"),hr));
            return LogHR(hr, s_FN, 200);
        }
        if ( cp == 0)
        {
            //
            //  no more results
            //
            break;
        }
        //
        //  Add to list
        //

        if ( var.GetCALPWSTR()->cElems > 0)
        {
            AP<GUID> pguidGates;
            DWORD    dwNumGates;
            HRESULT hr1 = MQADpTranslateGateDn2Id(
								pwcsDomainController,
								fServerName,
								var.CastToStruct(),
								&pguidGates,
								&dwNumGates
								);

			//
			// There might be a success with dwNumGates	= 0
			// in case of deleted objects
			//
            if (SUCCEEDED(hr1) && (dwNumGates > 0))
            {
                pSiteGateList->AddSiteGates(
                         dwNumGates,
                         pguidGates
                         );
            }
        }
    }

    return(MQ_OK);
}


HRESULT MQADpTranslateGateDn2Id(
        IN  LPCWSTR             pwcsDomainController,
		IN  bool				fServerName,
        IN  const PROPVARIANT*  pvarGatesDN,
        OUT GUID **      ppguidLinkSiteGates,
        OUT DWORD *      pdwNumLinkSiteGates
        )
/*++

Routine Description:
    This routine translate PROPID_L_GATES_DN into unique-id array
    of the gates.

Arguments:
    pvarGatesDN -   varaint containing PROPID_L_GATES_DN

Return Value:
--*/
{
    //
    //  For each gate translate its DN to unique id
    //
    if ( pvarGatesDN->calpwstr.cElems == 0)
    {
        *pdwNumLinkSiteGates = 0;
        *ppguidLinkSiteGates = NULL;
        return( MQ_OK);
    }
    //
    //  there are gates
    //
    AP<GUID> pguidGates = new GUID[ pvarGatesDN->calpwstr.cElems];
    PROPID prop = PROPID_QM_MACHINE_ID;
    DWORD  dwNextToFill = 0;
    PROPVARIANT var;
    var.vt = VT_CLSID;
    HRESULT hr = MQ_OK;
    for ( DWORD i = 0; i < pvarGatesDN->calpwstr.cElems; i++)
    {
        var.puuid = &pguidGates[ dwNextToFill];
        CMqConfigurationObject object(NULL, NULL, pwcsDomainController, fServerName);
        object.SetObjectDN( pvarGatesDN->calpwstr.pElems[i]);

        hr = g_AD.GetObjectProperties(
                    adpGlobalCatalog,
                    &object,
                    1,
                    &prop,
                    &var);

        if ( SUCCEEDED(hr))
        {
            dwNextToFill++;
        }


    }
    if ( dwNextToFill > 0)
    {
        //
        //  succeeded to translate some or all gates, return them
        //
        *pdwNumLinkSiteGates = dwNextToFill;
        *ppguidLinkSiteGates = pguidGates.detach();
        return( MQ_OK);

    }
    //
    //  Failed to translate gates
    //
    *pdwNumLinkSiteGates = 0;
    *ppguidLinkSiteGates = NULL;
    return MQ_OK;
}

/*====================================================

RoutineName: InitPropertyTranslationMap

Arguments:  initialize property translation map

Return Value: none

=====================================================*/
void MQADpInitPropertyTranslationMap()
{
    //
    // Populate  g_PropDictionary
    //

    DWORD i;
    const translateProp * pProperty = QueueTranslateInfo;
    for (i = 0; i < ARRAY_SIZE(QueueTranslateInfo); i++, pProperty++)
    {
        g_PropDictionary.SetAt(pProperty->propid, pProperty);
    }

    pProperty = MachineTranslateInfo;
    for (i = 0; i < ARRAY_SIZE(MachineTranslateInfo); i++, pProperty++)
    {
        g_PropDictionary.SetAt(pProperty->propid, pProperty);
    }

    pProperty = EnterpriseTranslateInfo;
    for (i = 0; i < ARRAY_SIZE(EnterpriseTranslateInfo); i++, pProperty++)
    {
        g_PropDictionary.SetAt(pProperty->propid, pProperty);
    }

    pProperty = SiteLinkTranslateInfo;
    for (i = 0; i < ARRAY_SIZE(SiteLinkTranslateInfo); i++, pProperty++)
    {
        g_PropDictionary.SetAt(pProperty->propid, pProperty);
    }

    pProperty = UserTranslateInfo;
    for (i = 0; i < ARRAY_SIZE(UserTranslateInfo); i++, pProperty++)
    {
        g_PropDictionary.SetAt(pProperty->propid, pProperty);
    }

    pProperty = MQUserTranslateInfo;
    for (i = 0; i < ARRAY_SIZE(MQUserTranslateInfo); i++, pProperty++)
    {
        g_PropDictionary.SetAt(pProperty->propid, pProperty);
    }

    pProperty = SiteTranslateInfo;
    for (i = 0; i < ARRAY_SIZE(SiteTranslateInfo); i++, pProperty++)
    {
        g_PropDictionary.SetAt(pProperty->propid, pProperty);
    }

    pProperty = ServerTranslateInfo;
    for (i = 0; i < ARRAY_SIZE(ServerTranslateInfo); i++, pProperty++)
    {
        g_PropDictionary.SetAt(pProperty->propid, pProperty);
    }

    pProperty = SettingTranslateInfo;
    for (i = 0; i < ARRAY_SIZE(SettingTranslateInfo); i++, pProperty++)
    {
        g_PropDictionary.SetAt(pProperty->propid, pProperty);
    }

    pProperty = ComputerTranslateInfo;
    for (i = 0; i < ARRAY_SIZE(ComputerTranslateInfo
        
        ); i++, pProperty++)
    {
        g_PropDictionary.SetAt(pProperty->propid, pProperty);
    }


}


bool MQADpIsDSOffline(
        IN HRESULT      hr
        )
/*++

Routine Description:
    The routine check if the return code 
    indicates no connectivity to ActiveDirectory. 

Arguments:
    HRESULT hr - return code of last operation

Return Value
	true   - if no connectivity to ActiveDirectory
    false  - oterwise

--*/
{
    switch (hr)
    {
    case HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN):
	case HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN):
    case MQ_ERROR_NO_DS:
        return true;
        break;
    default:
        return false;
        break;
    }
}

HRESULT MQADpConvertToMQCode(
                         IN HRESULT   hr,
                         IN AD_OBJECT eObject)
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    if (hr == MQ_OK)                                
    {
        return hr;
    }

	if(IsLocalUser())
	{
	    return MQ_ERROR_DS_LOCAL_USER;
	}

    if (MQADpIsDSOffline(hr))
    {
        return MQ_ERROR_NO_DS;
    }
    switch ( hr)
    {
        case HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS):
        case HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS):  //BUGBUG alexdad to throw after transition
        {
        //
        //  Object exists
        //
            switch( eObject)
            {
            case eQUEUE:
                return MQ_ERROR_QUEUE_EXISTS;
                break;
            case eROUTINGLINK:
                return MQDS_E_SITELINK_EXISTS;
                break;
            case eUSER:
                return MQ_ERROR_INTERNAL_USER_CERT_EXIST;
                break;
            case eMACHINE:
                return MQ_ERROR_MACHINE_EXISTS;
                break;
            case eCOMPUTER:
                return MQDS_E_COMPUTER_OBJECT_EXISTS;
                break;
            default:
                return hr;
                break;
            }
        }
        break;

        case HRESULT_FROM_WIN32(ERROR_DS_DECODING_ERROR):
        case HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT):
        {
        //
        //  Object not found
        //
            switch( eObject)
            {
            case eQUEUE:
                return MQ_ERROR_QUEUE_NOT_FOUND;
                break;
           case eMACHINE:
                return MQ_ERROR_MACHINE_NOT_FOUND;
                break;
            default:
                return MQDS_OBJECT_NOT_FOUND;
                break;
            }
        }
        break;

        case E_ADS_BAD_PATHNAME:
        {
            //
            //  wrong pathname
            //
            switch( eObject)
            {
            case eQUEUE:
                //
                // creating queue with not allowed chars
                //
                return MQ_ERROR_ILLEGAL_QUEUE_PATHNAME;
                break;

            default:
                return hr;
                break;
            }

        }
        break;

        case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
            return MQ_ERROR_ACCESS_DENIED;

            break;

        //
        // This is an internal warning that should not be returned out of the DS.
		// every warning will convert into error in the RunTime. ilanh 05-Sep-2000 (bug 6035)
		//
        case MQSec_I_SD_CONV_NOT_NEEDED:
            return(MQ_OK);
            break;

        default:
            return hr;
            break;
    }
}


HRESULT MQADpComposeName(
               IN  LPCWSTR   pwcsPrefix,
               IN  LPCWSTR   pwcsSuffix,
               OUT LPWSTR * pwcsFullName
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    //
    //  compose a distinguished name of an object
    //  format : CN=prefix, suffix
    //

    DWORD LenSuffix = lstrlen(pwcsSuffix);
    DWORD LenPrefix = lstrlen(pwcsPrefix);
    DWORD Length =
            x_CnPrefixLen +                   // "CN="
            LenPrefix +                       // "pwcsPrefix"
            1 +                               //","
            LenSuffix +                       // "pwcsSuffix"
            1;                                // '\0'

    *pwcsFullName = new WCHAR[Length];

    DWORD dw = swprintf(
        *pwcsFullName,
         L"%s"             // "CN="
         L"%s"             // "pwcsPrefix"
         TEXT(",")
         L"%s",            // "pwcsSuffix"
        x_CnPrefix,
        pwcsPrefix,
        pwcsSuffix
        );
    DBG_USED( dw);
	ASSERT( dw < Length);

    return(MQ_OK);


}


/*====================================================
    CAdsi::CompareDefaultValue()
    check the user property val + rel indicates that the
    query should return objects with default values
=====================================================*/
STATIC BOOL CompareDefaultValue(
           IN const ULONG           rel,
           IN const MQPROPVARIANT * pvarUser,
           IN const MQPROPVARIANT * pvarDefaultValue
           )
{
    if ( pvarDefaultValue == NULL)
    {
        return(FALSE);
    }
    if ( pvarUser->vt != pvarDefaultValue->vt )
    {
        return(FALSE);
    }
    switch ( pvarDefaultValue->vt)
    {
        case VT_EMPTY:
            if ( rel == PREQ)
            {
                return TRUE;
            }
            return(FALSE);
            break;

        case VT_I2:
            if ( rel == PREQ)
            {
                return( pvarDefaultValue->iVal == pvarUser->iVal);
            }
            if ( rel == PRNE)
            {
                return( pvarDefaultValue->iVal != pvarUser->iVal);
            }
            if (rel == PRGT)
            {
                 return( pvarDefaultValue->iVal > pvarUser->iVal);
            }
            if (rel == PRGE)
            {
                 return( pvarDefaultValue->iVal >= pvarUser->iVal);
            }
            if (rel == PRLT)
            {
                 return( pvarDefaultValue->iVal < pvarUser->iVal);
            }
            if (rel == PRLE)
            {
                 return( pvarDefaultValue->iVal <= pvarUser->iVal);
            }
            return(FALSE);
            break;

        case VT_I4:
            if ( rel == PREQ)
            {
                return( pvarDefaultValue->lVal == pvarUser->lVal);
            }
            if ( rel == PRNE)
            {
                return( pvarDefaultValue->lVal != pvarUser->lVal);
            }
            if (rel == PRGT)
            {
                 return( pvarDefaultValue->lVal > pvarUser->lVal);
            }
            if (rel == PRGE)
            {
                 return( pvarDefaultValue->lVal >= pvarUser->lVal);
            }
            if (rel == PRLT)
            {
                 return( pvarDefaultValue->lVal < pvarUser->lVal);
            }
            if (rel == PRLE)
            {
                 return( pvarDefaultValue->lVal <= pvarUser->lVal);
            }
            return(FALSE);
            break;

        case VT_UI1:
            if ( rel == PREQ)
            {
                return( pvarDefaultValue->bVal == pvarUser->bVal);
            }
            if ( rel == PRNE)
            {
                return( pvarDefaultValue->bVal != pvarUser->bVal);
            }
            if (rel == PRGT)
            {
                 return( pvarDefaultValue->bVal > pvarUser->bVal);
            }
            if (rel == PRGE)
            {
                 return( pvarDefaultValue->bVal >= pvarUser->bVal);
            }
            if (rel == PRLT)
            {
                 return( pvarDefaultValue->bVal < pvarUser->bVal);
            }
            if (rel == PRLE)
            {
                 return( pvarDefaultValue->bVal <= pvarUser->bVal);
            }
            return(FALSE);
            break;

        case VT_UI2:
            if ( rel == PREQ)
            {
                return( pvarDefaultValue->uiVal == pvarUser->uiVal);
            }
            if ( rel == PRNE)
            {
                return( pvarDefaultValue->uiVal != pvarUser->uiVal);
            }
            if (rel == PRGT)
            {
                 return( pvarDefaultValue->uiVal > pvarUser->uiVal);
            }
            if (rel == PRGE)
            {
                 return( pvarDefaultValue->uiVal >= pvarUser->uiVal);
            }
            if (rel == PRLT)
            {
                 return( pvarDefaultValue->uiVal < pvarUser->uiVal);
            }
            if (rel == PRLE)
            {
                 return( pvarDefaultValue->uiVal <= pvarUser->uiVal);
            }
            return(FALSE);
            break;

        case VT_UI4:
            if ( rel == PREQ)
            {
                return( pvarDefaultValue->ulVal == pvarUser->ulVal);
            }
            if ( rel == PRNE)
            {
                return( pvarDefaultValue->ulVal != pvarUser->ulVal);
            }
            if (rel == PRGT)
            {
                 return( pvarDefaultValue->ulVal > pvarUser->ulVal);
            }
            if (rel == PRGE)
            {
                 return( pvarDefaultValue->ulVal >= pvarUser->ulVal);
            }
            if (rel == PRLT)
            {
                 return( pvarDefaultValue->ulVal < pvarUser->ulVal);
            }
            if (rel == PRLE)
            {
                 return( pvarDefaultValue->ulVal <= pvarUser->ulVal);
            }
            return(FALSE);
            break;

        case VT_LPWSTR:
            if ( rel == PREQ)
            {
                return ( !wcscmp( pvarDefaultValue->pwszVal, pvarUser->pwszVal));
            }
            if ( rel == PRNE)
            {
                return ( wcscmp( pvarDefaultValue->pwszVal, pvarUser->pwszVal));
            }
            return(FALSE);
            break;

        case VT_BLOB:
            ASSERT( rel == PREQ);
            if ( pvarDefaultValue->blob.cbSize != pvarUser->blob.cbSize)
            {
                return(FALSE);
            }
            return( !memcmp( pvarDefaultValue->blob.pBlobData,
                             pvarUser->blob.pBlobData,
                             pvarUser->blob.cbSize));
            break;

        case VT_CLSID:
            if ( rel == PREQ)
            {
                return( *pvarDefaultValue->puuid == *pvarUser->puuid);
            }
            if ( rel == PRNE)
            {
                 return( *pvarDefaultValue->puuid != *pvarUser->puuid);
            }
            return(FALSE);
            break;


        default:
            ASSERT(0);
            return(FALSE);
            break;

    }
}




HRESULT MQADpRestriction2AdsiFilter(
        IN  const MQRESTRICTION * pMQRestriction,
        IN  LPCWSTR               pwcsObjectCategory,
        IN  LPCWSTR               pwszObjectClass,
        OUT LPWSTR   *            ppwszSearchFilter
        )
{
    HRESULT hr;
    *ppwszSearchFilter = new WCHAR[1000];   //BUGBUG

    if ((pMQRestriction == NULL) || (pMQRestriction->cRes == 0))
    {
        swprintf(
            *ppwszSearchFilter,
             L"%s%s%s",
            x_ObjectCategoryPrefix,
            pwcsObjectCategory,
            x_ObjectCategorySuffix
            );

        return MQ_OK;
    }
    LPWSTR pw = *ppwszSearchFilter;

    wcscpy(pw, L"(&");
    pw += wcslen(L"(&");
    //
    //  add the object class restriction
    //
    swprintf(
        pw,
         L"%s%s%s",
        x_ObjectCategoryPrefix,
        pwcsObjectCategory,
        x_ObjectCategorySuffix
        );
    pw += x_ObjectCategoryPrefixLen + wcslen(pwcsObjectCategory)+ x_ObjectClassSuffixLen;

    BOOL fNeedToCheckDefaultValues = FALSE;
    //
    //  For queue properties, there is special handling
    //  incase of default values
    //
    if (!wcscmp( MSMQ_QUEUE_CLASS_NAME, pwszObjectClass))
    {
        fNeedToCheckDefaultValues = TRUE;
    }

    for (DWORD iRes = 0; iRes < pMQRestriction->cRes; iRes++)
    {

        //
        // Get property info
        //
        const translateProp *pTranslate;
        if(!g_PropDictionary.Lookup(pMQRestriction->paPropRes[iRes].prop, pTranslate))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1580);
        }

        AP<WCHAR> pwszVal;

        // Get property value, string representation
        hr = MqPropVal2String(&pMQRestriction->paPropRes[iRes].prval,
                              pTranslate->vtDS,
                              &pwszVal);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 650);
        }

        //
        //  Is the property compared to its default value
        //
        BOOL    fAddPropertyNotPresent = FALSE;
        if ( fNeedToCheckDefaultValues)
        {
            fAddPropertyNotPresent = CompareDefaultValue(
                        pMQRestriction->paPropRes[iRes].rel,
                        &pMQRestriction->paPropRes[iRes].prval,
                        pTranslate->pvarDefaultValue);
        }
        DWORD dwBracks = 0;
        if ( fAddPropertyNotPresent)
        {
            //
            //  Add additional restriction that locate all object where
            //  the property is not present.
            //
            swprintf(
                pw,
                L"%s%s%s",
                x_AttributeNotIncludedPrefix,
                pTranslate->wcsPropid,
                x_AttributeNotIncludedSuffix
                );
            pw += x_AttributeNotIncludedPrefixLen + wcslen(pTranslate->wcsPropid) + x_AttributeNotIncludedSuffixLen;
            dwBracks++;
        }
        // Prefix part
        wcscpy(pw, x_PropertyPrefix);
        pw += x_PropertyPrefixLen;

        // Prefix part
        WCHAR wszRel[10];

        switch(pMQRestriction->paPropRes[iRes].rel)
        {
        case PRLT:
            wcscpy(pw, L"!(");
            pw += wcslen(L"!(");
            wcscpy(wszRel, L">=");
            dwBracks++;
            break;

        case PRLE:
            wcscpy(wszRel, L"<=");
            break;

        case PRGT:
            wcscpy(pw, L"!(");
            pw += wcslen(L"!(");
            wcscpy(wszRel, L"<=");
            dwBracks++;
            break;

        case PRGE:
            wcscpy(wszRel, L">=");
            break;

        case PREQ:
            wcscpy(wszRel, L"=");
            break;

        case PRNE:
            wcscpy(pw, L"!(");
            pw += wcslen(L"!(");
            wcscpy(wszRel, L"=");
            dwBracks++;
            break;

        default:
            return LogHR(MQ_ERROR_ILLEGAL_RELATION, s_FN, 1590);
        }

        // Property name
        wcscpy(pw, pTranslate->wcsPropid);
        pw += wcslen(pTranslate->wcsPropid);

        // Property condition
        wcscpy(pw, wszRel);
        pw += wcslen(wszRel);

        // Property value
        wcscpy(pw, pwszVal);
        pw += wcslen(pwszVal);

        // Property suffix
        for (DWORD is=0; is < dwBracks; is++)
        {
            wcscpy(pw, x_PropertySuffix);
            pw += x_PropertySuffixLen;
        }

        // Relation closing bracket
        wcscpy(pw, x_PropertySuffix);
        pw += x_PropertySuffixLen;
    }

    wcscpy(pw, x_PropertySuffix);
    pw += x_PropertySuffixLen;

    return MQ_OK;
}


void MQADpCheckAndNotifyOffline(
            IN HRESULT      hr
            )
/*++

Routine Description:
    The routine check if the return code of the last operation
    indicates no connectivity to ActiveDirectory, and if so informs
    the application (if requested to do so)

Arguments:
    HRESULT hr - return code of last operation

Return Value
	none

--*/
{
    //
    //  Have we been requested to inform about offline state
    //
    if (g_pLookDS == NULL)
    {
        return;
    }

    //
    //  Does the return-code of the last operation indicat 
    //  an offline state
    //
    if (MQADpIsDSOffline(hr))
    {
        g_pLookDS( 0, 1);
    }

}


CBasicQueryHandle *
MQADpProbQueryHandle(
        IN HANDLE hQuery)
/*++

Routine Description:
    The routine routine verifies the query handle

Arguments:
    HANDLE hQuery

Return Value
	CBasicQueryHandle * or for invalid handles it raise exception.

--*/
{
    CBasicQueryHandle * phQuery = reinterpret_cast<CBasicQueryHandle *>(hQuery);
    //
    // Verify the handle
    //
    __try           
    {
        if (phQuery->Verify())
            return phQuery;

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //NULL
    }

    RaiseException((DWORD)STATUS_INVALID_HANDLE, 0, 0, 0);
    return NULL;
}

CQueueDeletionNotification *
MQADpProbQueueDeleteNotificationHandle(
        IN HANDLE hQuery)
/*++

Routine Description:
    The routine routine verifies the queue delete notification handle

Arguments:
    HANDLE hQuery

Return Value
	CQueueDeletionNotification * or for invalid handles it raise exception.

--*/
{
    CQueueDeletionNotification * phNotification = reinterpret_cast<CQueueDeletionNotification *>(hQuery);
    //
    // Verify the handle
    //
    __try           
    {
        if (phNotification->Verify())
            return phNotification;

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //NULL
    }

    RaiseException((DWORD)STATUS_INVALID_HANDLE, 0, 0, 0);
    return NULL;
}


HRESULT
MQADpCheckSortParameter(
    IN const MQSORTSET* pSort)
/*++

Routine Description:
    This routine verifies that the sort parameter doesn't
    contain the same property with conflicting sort-order.
    In MSMQ 1.0  ODBC\SQL returned an error in such case.
    NT5 ignores it.
    This check is added on the server side, in order to
    support old clients.

Arguments:

Return Value:
    MQ_OK - if sort parameter doesn't contain conflicting sort-order of the same property
    MQ_ERROR_ILLEGAL_SORT - otherwise
--*/
{

    if ( pSort == NULL)
    {
        return(MQ_OK);
    }


    const MQSORTKEY * pSortKey = pSort->aCol;
    for ( DWORD i = 0; i < pSort->cCol; i++, pSortKey++)
    {
        const MQSORTKEY * pPreviousSortKey = pSort->aCol;
        for ( DWORD j = 0; j< i; j++, pPreviousSortKey++)
        {
            if ( pPreviousSortKey->propColumn == pSortKey->propColumn)
            {
                //
                //  is it the same sorting order?
                //
                if (pPreviousSortKey->dwOrder !=  pSortKey->dwOrder)
                {
                    return LogHR(MQ_ERROR_ILLEGAL_SORT, s_FN, 420);
                }
            }
        }
    }
    return(MQ_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\mqadp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
	mqadp.h

Abstract:
    MQAD DLL private internal functions for
    DS queries, etc.

Author:
    ronith


--*/


#ifndef __MQADP_H__
#define __MQADP_H__
#include "mqaddef.h"
#include "baseobj.h"
#include "siteinfo.h"
#include "delqn.h"

void MQADpAllocateObject(
                AD_OBJECT           eObject,
                LPCWSTR             pwcsDomainController,
				bool				fServerName,
                LPCWSTR             pwcsObjectName,
                const GUID *        pguidObject,
                CBasicObjectType**   ppObject
                );


WCHAR * FilterSpecialCharacters(
            IN     LPCWSTR          pwcsObjectName,
            IN     const DWORD      dwNameLength,
            IN OUT LPWSTR pwcsOutBuffer = 0,
            OUT    DWORD_PTR* pdwCharactersProcessed = 0);

HRESULT 
MQADInitialize(
    IN  bool    fIncludingVerify
    );


HRESULT LocateUser(
                 IN  LPCWSTR         pwcsDomainController,
				 IN  bool 			 fServerName,
                 IN  BOOL            fOnlyInDC,
                 IN  BOOL            fOnlyInGC,
                 IN  AD_OBJECT       eObject,
                 IN  LPCWSTR         pwcsAttribute,
                 IN  const BLOB *    pblobUserSid,
                 IN  const GUID *    pguidDigest,
                 IN  MQCOLUMNSET    *pColumns,
                 OUT PROPVARIANT    *pvar,
                 OUT DWORD          *pdwNumofProps = NULL,
                 OUT BOOL           *pfUserFound = NULL
                 );

HRESULT MQADpQueryNeighborLinks(
                        IN  LPCWSTR            pwcsDomainController,
						IN  bool 			   fServerName,
                        IN  eLinkNeighbor      LinkNeighbor,
                        IN  LPCWSTR            pwcsNeighborDN,
                        IN OUT CSiteGateList * pSiteGateList
                        );

HRESULT MQADpTranslateGateDn2Id(
        IN  LPCWSTR             pwcsDomainController,
		IN  bool 			    fServerName,
        IN  const PROPVARIANT*  pvarGatesDN,
        OUT GUID **      ppguidLinkSiteGates,
        OUT DWORD *      pdwNumLinkSiteGates
        );

void MQADpInitPropertyTranslationMap();

bool MQADpIsDSOffline(
        IN HRESULT      hr
        );

HRESULT MQADpConvertToMQCode(
        HRESULT   hr,
        AD_OBJECT m_eObject
        );

HRESULT MQADpComposeName(
               IN  LPCWSTR   pwcsPrefix,
               IN  LPCWSTR   pwcsSuffix,
               OUT LPWSTR * pwcsFullName
               );

HRESULT MQADpCoreSetOwnerPermission( WCHAR *pwszPath,
                                  DWORD  dwPermissions );


HRESULT MQADpRestriction2AdsiFilter(
        IN  const MQRESTRICTION * pMQRestriction,
        IN  LPCWSTR               pwcsObjectCategory,
        IN  LPCWSTR               pwszObjectClass,
        OUT LPWSTR   *            ppwszSearchFilter
        );

void MQADpCheckAndNotifyOffline(
            IN HRESULT      hr
            );

class CBasicQueryHandle;

CBasicQueryHandle * MQADpProbQueryHandle(
        IN HANDLE hQuery);

CQueueDeletionNotification *
MQADpProbQueueDeleteNotificationHandle(
        IN HANDLE hQuery);

HRESULT
MQADpCheckSortParameter(
    IN const MQSORTSET* pSort);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\mqadapi.cpp ===
/*++

Copyright (c) 1995-99  Microsoft Corporation

Module Name:

    mqadapi.cpp

Abstract:

    Implementation of  MQAD APIs.

    MQAD APIs implements client direct call to Active Directory

Author:

    ronit hartmann ( ronith)

--*/
#include "ds_stdh.h"
#include "dsproto.h"
#include "mqad.h"
#include "baseobj.h"
#include "mqadp.h"
#include "ads.h"
#include "mqadglbo.h"
#include "queryh.h"
#include "mqattrib.h"
#include "utils.h"
#include "mqsec.h"
#include "_secutil.h"
#include <lmcons.h>
#include <lmapibuf.h>
#include "autoreln.h"
#include "Dsgetdc.h"
#include "dsutils.h"
#include "delqn.h"

#include "mqadapi.tmh"

static WCHAR *s_FN=L"mqad/mqadapi";


HRESULT
MQAD_EXPORT
APIENTRY
MQADCreateObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[],
                OUT GUID*                   pObjGuid
                )
/*++

Routine Description:
    The routine validates the operation and then
	creates an object in Active Directory.

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
	PSECURITY_DESCRIPTOR    pSecurityDescriptor - object SD
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values
	GUID*                   pObjGuid - the created object unique id

Return Value
	HRESULT

--*/
{
    CADHResult hr(eObject);

    hr = MQADInitialize(true);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }

    //
    //  Verify if object creation is allowed (mixed mode)
    //
    P<CBasicObjectType> pObject;
    MQADpAllocateObject(
                    eObject,
                    pwcsDomainController,
					fServerName,
                    pwcsObjectName,
                    NULL,   // pguidObject
                    &pObject
                    );

    if ( !g_VerifyUpdate.IsCreateAllowed(
                               eObject,
                               pObject))
    {
	    TrERROR(mqad, "Create Object not allowed");
        return MQ_ERROR_CANNOT_DELETE_PSC_OBJECTS;
    }


    //
    // prepare info request
    //
    P<MQDS_OBJ_INFO_REQUEST> pObjInfoRequest;
    P<MQDS_OBJ_INFO_REQUEST> pParentInfoRequest;
    pObject->PrepareObjectInfoRequest( &pObjInfoRequest);
    pObject->PrepareObjectParentRequest( &pParentInfoRequest);

    CAutoCleanPropvarArray cCleanCreateInfoRequestPropvars;
    if (pObjInfoRequest != NULL)
    {
        cCleanCreateInfoRequestPropvars.attachClean(
                pObjInfoRequest->cProps,
                pObjInfoRequest->pPropVars
                );
    }
    CAutoCleanPropvarArray cCleanCreateParentInfoRequestPropvars;
    if (pParentInfoRequest != NULL)
    {
        cCleanCreateParentInfoRequestPropvars.attachClean(
                pParentInfoRequest->cProps,
                pParentInfoRequest->pPropVars
                );
    }

    //
    // create the object
    //
    hr = pObject->CreateObject(
            cp,
            aProp,
            apVar,
            pSecurityDescriptor,
            pObjInfoRequest,
            pParentInfoRequest);
    if (FAILED(hr))
    {
        MQADpCheckAndNotifyOffline( hr);
        return LogHR(hr, s_FN, 30);
    }

    //
    //  send notification
    //
    pObject->CreateNotification(
            pwcsDomainController,
            pObjInfoRequest, 
            pParentInfoRequest);


    //
    //  return pObjGuid
    //
    if (pObjGuid != NULL)
    {
        hr = pObject->RetreiveObjectIdFromNotificationInfo(
                       pObjInfoRequest,
                       pObjGuid);
        LogHR(hr, s_FN, 40);
    }

    return(hr);
}


static
HRESULT
_DeleteObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const GUID *            pguidObject
                )
/*++

Routine Description:
    Helper routine for deleting object from AD. The routine also verifies
    that the operation is allowed

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
	GUID*                   pguidObject - the unique id of the object

Return Value
	HRESULT

--*/
{
    CADHResult hr(eObject);
    hr = MQADInitialize(true);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 60);
    }
    P<CBasicObjectType> pObject;
    MQADpAllocateObject(
                    eObject,
                    pwcsDomainController,
					fServerName,
                    pwcsObjectName,
                    pguidObject,
                    &pObject
                    );

    //
    //  Verify if object deletion is allowed (mixed mode)
    //
    if (!g_VerifyUpdate.IsUpdateAllowed( eObject, pObject))
    {
	    TrERROR(mqad, "DeleteObject not allowed");
        return MQ_ERROR_CANNOT_DELETE_PSC_OBJECTS;
    }
    //
    // prepare info request
    //
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest;
    MQDS_OBJ_INFO_REQUEST * pParentInfoRequest;
    pObject->PrepareObjectInfoRequest( &pObjInfoRequest);
    pObject->PrepareObjectParentRequest( &pParentInfoRequest);

    CAutoCleanPropvarArray cDeleteSetInfoRequestPropvars;
    if (pObjInfoRequest != NULL)
    {
        cDeleteSetInfoRequestPropvars.attachClean(
                pObjInfoRequest->cProps,
                pObjInfoRequest->pPropVars
                );
    }
    CAutoCleanPropvarArray cCleanDeleteParentInfoRequestPropvars;
    if (pParentInfoRequest != NULL)
    {
        cCleanDeleteParentInfoRequestPropvars.attachClean(
                pParentInfoRequest->cProps,
                pParentInfoRequest->pPropVars
                );
    }
    //
    // delete the object
    //
    hr = pObject->DeleteObject( pObjInfoRequest,
                                pParentInfoRequest);
    if (FAILED(hr))
    {
        MQADpCheckAndNotifyOffline( hr);
        return LogHR(hr, s_FN, 70);
    }

    //
    //  send notification
    //
    pObject->DeleteNotification(
            pwcsDomainController,
            pObjInfoRequest, 
            pParentInfoRequest);

    return(hr);
}


HRESULT
MQAD_EXPORT
APIENTRY
MQADDeleteObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName
                )
/*++

Routine Description:
    Deletes object from Active Directory according to its msmq-name

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name

Return Value
	HRESULT

--*/
{
    ASSERT(eObject != eUSER);    // don't support user deletion according to name

    return( _DeleteObject( 
				eObject,
				pwcsDomainController,
				fServerName,
				pwcsObjectName,
				NULL     // pguidObject
				));
}

HRESULT
MQAD_EXPORT
APIENTRY
MQADDeleteObjectGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject
                )
/*++

Routine Description:
    Deletes an object from Active Directory according to its unqiue id

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	GUID*                   pguidObject - the unique id of the object

Return Value
	HRESULT

--*/
{
    return( _DeleteObject( 
					eObject,
					pwcsDomainController,
					fServerName,
					NULL,    // pwcsObjectName
					pguidObject
					));
}



STATIC
HRESULT
_GetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const GUID *            pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT  PROPVARIANT         apVar[]
                )
/*++

Routine Description:
    Helper routine for retrieving object properties from Active  Directory

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
    GUID *                  pguidObject - the object unique id
	PSECURITY_DESCRIPTOR    pSecurityDescriptor - object SD
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

Return Value
	HRESULT

--*/
{
    CADHResult hr(eObject);
    hr = MQADInitialize(false);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 90);
    }

    P<CBasicObjectType> pObject;
    MQADpAllocateObject(
                    eObject,
                    pwcsDomainController,
					fServerName,
                    pwcsObjectName,
                    pguidObject,
                    &pObject
                    );


    hr = pObject->GetObjectProperties(
                        cp,
                        aProp,
                        apVar
                        );


    MQADpCheckAndNotifyOffline( hr);
    return(hr);
}



HRESULT
MQAD_EXPORT
APIENTRY
MQADGetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT  PROPVARIANT         apVar[]
                )
/*++

Routine Description:
    Retrieves object properties from Active Directory according to its msmq name

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

Return Value
	HRESULT

--*/
{

    return( _GetObjectProperties(
                            eObject,
                            pwcsDomainController,
							fServerName,
                            pwcsObjectName,
                            NULL,   //pguidObject
                            cp,
                            aProp,
                            apVar
                            ));
}

HRESULT
MQAD_EXPORT
APIENTRY
MQADGetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT  PROPVARIANT         apVar[]
                )
/*++

Routine Description:
    Retrieves object properties from Active Directory according to its unique id

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	GUID *                  pguidObject -  object unique id
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

Return Value
	HRESULT

--*/
{
    return( _GetObjectProperties(
                            eObject,
                            pwcsDomainController,
							fServerName,
                            NULL,   // pwcsObjectName
                            pguidObject,
                            cp,
                            aProp,
                            apVar
                            ));
}


HRESULT
MQAD_EXPORT
APIENTRY
MQADQMGetObjectSecurity(
    IN  AD_OBJECT               eObject,
    IN  const GUID*             pguidObject,
    IN  SECURITY_INFORMATION    RequestedInformation,
    IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    IN  DWORD                   nLength,
    IN  LPDWORD                 lpnLengthNeeded,
    IN  DSQMChallengeResponce_ROUTINE
                                pfChallengeResponceProc,
    IN  DWORD_PTR               dwContext
    )
/*++

Routine Description:

Arguments:

Return Value
	HRESULT

--*/
{
    ASSERT(( eObject == eQUEUE) || (eObject == eMACHINE));
    CADHResult hr(eObject);

    if (RequestedInformation & SACL_SECURITY_INFORMATION)
    {
        //
        // We verified we're called from a remote MSMQ service.
        // We don't impersonate the call. So if remote msmq ask for SACL,
        // grant ourselves the SE_SECURITY privilege.
        //
        HRESULT hr1 = MQSec_SetPrivilegeInThread(SE_SECURITY_NAME, TRUE);
        ASSERT(SUCCEEDED(hr1)) ;
        LogHR(hr1, s_FN, 100);
    }

    //
    // Get the object's security descriptor.
    //
    PROPID PropId;
    PROPVARIANT PropVar;
    PropId = (eObject == eQUEUE) ?
                PROPID_Q_SECURITY :
                PROPID_QM_SECURITY;

    PropVar.vt = VT_NULL;
    hr = MQADGetObjectSecurityGuid(
            eObject,
            NULL,
			false,
            pguidObject,
            RequestedInformation,
            PropId,
            &PropVar
			);

    if (RequestedInformation & SACL_SECURITY_INFORMATION)
    {
        //
        // Remove the SECURITY privilege.
        //
        HRESULT hr1 = MQSec_SetPrivilegeInThread(SE_SECURITY_NAME, FALSE);
        ASSERT(SUCCEEDED(hr1)) ;
        LogHR(hr1, s_FN, 110);
    }

    if (FAILED(hr))
    {
        if (RequestedInformation & SACL_SECURITY_INFORMATION)
        {
            if ((hr == MQ_ERROR_ACCESS_DENIED) ||
                (hr == MQ_ERROR_MACHINE_NOT_FOUND))
            {
                //
                // change the error code, for compatibility with MSMQ1.0
                //
                hr = MQ_ERROR_PRIVILEGE_NOT_HELD ;
            }
        }
        return LogHR(hr, s_FN, 120);
    }

    AP<BYTE> pSD = PropVar.blob.pBlobData;
    ASSERT(IsValidSecurityDescriptor(pSD));
    SECURITY_DESCRIPTOR SD;
    BOOL bRet;

    //
    // Copy the security descriptor.
    //
    bRet = InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION);
    ASSERT(bRet);

    MQSec_CopySecurityDescriptor( &SD,
                                   pSD,
                                   RequestedInformation,
                                   e_DoNotCopyControlBits ) ;
    *lpnLengthNeeded = nLength;

    if (!MakeSelfRelativeSD(&SD, pSecurityDescriptor, lpnLengthNeeded))
    {
        ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);

        return LogHR(MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL, s_FN, 130);
    }

    ASSERT(IsValidSecurityDescriptor(pSecurityDescriptor));

    return (MQ_OK);
}


STATIC
HRESULT
_SetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const GUID *            pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                )
/*++

Routine Description:
    Helper routine for setting object properties, after validating
    that the operation is allowed

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
	GUID *                  pguidObject - unique id of the object
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

Return Value
	HRESULT

--*/
{
    CADHResult hr(eObject);
    hr = MQADInitialize(true);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }
    //
    //  Verify if object creation is allowed (mixed mode)
    //
    P<CBasicObjectType> pObject;
    MQADpAllocateObject(
                    eObject,
                    pwcsDomainController,
					fServerName,
                    pwcsObjectName,
                    pguidObject,
                    &pObject
                    );
    //
    // compose the DN of the object's father in ActiveDirectory
    //

    if ( !g_VerifyUpdate.IsUpdateAllowed(
                               eObject,
                               pObject))
    {
	    TrERROR(mqad, "SetObjectProperties not allowed");
        return MQ_ERROR_CANNOT_DELETE_PSC_OBJECTS;
    }


    //
    // prepare info request
    //
    P<MQDS_OBJ_INFO_REQUEST> pObjInfoRequest;
    P<MQDS_OBJ_INFO_REQUEST> pParentInfoRequest;
    pObject->PrepareObjectInfoRequest( &pObjInfoRequest);
    pObject->PrepareObjectParentRequest( &pParentInfoRequest);

    CAutoCleanPropvarArray cCleanSetInfoRequestPropvars;
    if (pObjInfoRequest != NULL)
    {
        cCleanSetInfoRequestPropvars.attachClean(
                pObjInfoRequest->cProps,
                pObjInfoRequest->pPropVars
                );
    }
    CAutoCleanPropvarArray cCleanSetParentInfoRequestPropvars;
    if (pParentInfoRequest != NULL)
    {
        cCleanSetParentInfoRequestPropvars.attachClean(
                pParentInfoRequest->cProps,
                pParentInfoRequest->pPropVars
                );
    }

    //
    // create the object
    //
    hr = pObject->SetObjectProperties(
            cp,
            aProp,
            apVar,
            pObjInfoRequest,
            pParentInfoRequest);
    if (FAILED(hr))
    {
        MQADpCheckAndNotifyOffline( hr);
        return LogHR(hr, s_FN, 170);
    }

    //
    //  send notification
    //
    pObject->ChangeNotification(
            pwcsDomainController,
            pObjInfoRequest, 
            pParentInfoRequest);

    return(hr);
}


HRESULT
MQAD_EXPORT
APIENTRY
MQADSetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                )
/*++

Routine Description:
    Sets object properties in Active Directory according to its msmq-name

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

Return Value
	HRESULT

--*/
{

    return( _SetObjectProperties(
                        eObject,
                        pwcsDomainController,
						fServerName,
                        pwcsObjectName,
                        NULL,   // pguidObject
                        cp,
                        aProp,
                        apVar
                        ));
}

HRESULT
MQAD_EXPORT
APIENTRY
MQADSetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                )
/*++

Routine Description:
    Sets object properties in Active Directory according to its unique id

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	GUID *                  pguidObject - the object unique id
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

Return Value
	HRESULT

--*/
{
    return( _SetObjectProperties(
                        eObject,
                        pwcsDomainController,
						fServerName,
                        NULL,   // pwcsObjectName
                        pguidObject,
                        cp,
                        aProp,
                        apVar
                        ));
}




HRESULT
MQAD_EXPORT
APIENTRY
MQADQMSetMachineProperties(
    IN  LPCWSTR				pwcsObjectName,
    IN  const DWORD			cp,
    IN  const PROPID		aProp[],
    IN  const PROPVARIANT	apVar[],
    IN  DSQMChallengeResponce_ROUTINE pfSignProc,
    IN  DWORD_PTR			dwContext
    )
/*++

Routine Description:

Arguments:

Return Value
	HRESULT

--*/
{
    CADHResult hr(eMACHINE);
    hr = MQADSetObjectProperties(
                eMACHINE,
                NULL,                   // pwcsDomainController,
				false,					// fServerName,
                pwcsObjectName,
                cp,
                aProp,
                apVar
                );

    return hr;

}

static LONG s_init = 0;

HRESULT
MQAD_EXPORT
APIENTRY
MQADInit(
		QMLookForOnlineDS_ROUTINE pLookDS,
        bool  fQMDll,
        LPCWSTR szServerName
        )
/*++

Routine Description:

Arguments:

Return Value
	HRESULT

--*/
{
    //
    //  At start up don't access the Active Directory.
    //  AD will be accessed only when it is actually needed.
    //

    //
    //  BUGBUG -
    //  For the time being MQADInit can be called several times by the same process
    //  ( for example QM and MQSEC) and we want to make sure that the parameters
    //  of the first call will be used.
    //
    LONG fInitialized = InterlockedExchange(&s_init, 1);
    if (fInitialized == 0)
    {
        g_pLookDS = pLookDS;
        g_fQMDll = fQMDll;
    }
	//
	//	Do not set g_fInitialized to false here!!!
	//
	//  This is requred for supporting multiple calls to MQADInit
	//  without performing multiple internal initializations
	//

    return(MQ_OK);
}

HRESULT
MQAD_EXPORT
APIENTRY
MQADSetupInit(
             IN    LPWSTR          pwcsPathName
             )
/*++

Routine Description:

Arguments:

Return Value
	HRESULT

--*/
{
	//
	//	Do not set g_fInitialized to false here!!!
	//
	//  This is requred for supporting multiple calls to MQADSetupInit
	//  without performing multiple internal initializations
	//

    return(MQ_OK);
}




HRESULT
MQAD_EXPORT
APIENTRY
MQADGetComputerSites(
            IN  LPCWSTR     pwcsComputerName,
            OUT DWORD  *    pdwNumSites,
            OUT GUID **     ppguidSites
            )
/*++

Routine Description:

Arguments:

Return Value
	HRESULT

--*/
{
    CADHResult hr(eSITE);
    hr = MQADInitialize(false);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 190);
    }

    //
    //  BUGBUG - currently supporting one site only
    //
    PNETBUF<WCHAR> pSiteName;
    DWORD dw =  DsGetSiteName(
                pwcsComputerName,
                &pSiteName
                );

	//
	// We will try query the DS directly with DsGetDCName
	// 
    PNETBUF<DOMAIN_CONTROLLER_INFO> pDcInfo;
	if(dw == ERROR_NO_SITENAME)
	{
		//
		// Try to get SiteName by quering the DS directly using DsGetDcName.
		// DsGetSiteName gets the site from the registry.
		// In join domain scenario this registry is not set yet by netlogon.
		// and we get the error ERROR_NO_SITENAME.
		// query the DS directly using DsGetDcName will work 
		//
		DWORD dw1 = DsGetDcName(
						NULL, 
						NULL, 
						NULL, 
						NULL, 
						DS_DIRECTORY_SERVICE_REQUIRED, 
						&pDcInfo
						);

		if (dw1 == NO_ERROR)
		{
			pSiteName.free();
			dw = NO_ERROR;
		}
	}

    hr = HRESULT_FROM_WIN32(dw);
    if (FAILED(hr))
    {
        if ( hr == HRESULT_FROM_WIN32(ERROR_NO_SITENAME))
        {
            //
            //  Such error indicates that subnets configuration is
            //  not complete.
            //
            hr = MQ_ERROR_CANT_RESOLVE_SITES;
        }
        return LogHR(hr, s_FN, 200);
    }
    //
    //  translate site-name into GUID
    //
    bool fFailedToResolveSites = false;
    LPWSTR pSite = NULL;
    if ( pSiteName != NULL)
    {
        pSite = pSiteName;
    }
    else if (pDcInfo->ClientSiteName != NULL)
    {
        pSite = pDcInfo->ClientSiteName;
    }
    else
    {
        fFailedToResolveSites = true;
        pSite = pDcInfo->DcSiteName;
    }
	ASSERT(pSite != NULL);
    CSiteObject objectSite(pSite, NULL, NULL, false);

    P<GUID> pguidSite = new GUID;;
    PROPID prop = PROPID_S_SITEID;
    MQPROPVARIANT var;
    var.vt= VT_CLSID;
    var.puuid = pguidSite;
    hr = objectSite.GetObjectProperties(
                            1,
                            &prop,
                            &var
                            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 210);
    }

    *ppguidSites = pguidSite.detach();
    *pdwNumSites = 1;

    if ( fFailedToResolveSites)
    {
        // 
        // if direct site resolution failed, return an indication to the caller
        //
        hr = MQDS_INFORMATION_SITE_NOT_RESOLVED;
    }
    return(hr);
}


HRESULT
MQAD_EXPORT
APIENTRY
MQADBeginDeleteNotification(
			IN AD_OBJECT				eObject,
			IN LPCWSTR                  pwcsDomainController,
			IN bool						fServerName,
			IN LPCWSTR					pwcsObjectName,
			OUT HANDLE *                phEnum
			)
/*++

Routine Description:
	The routine verifies if delete operation is allowed (i.e the object is not
	owned by a PSC).
	In adition for queue it sends notification message.

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    LPCWSTR					pwcsObjectName - MSMQ object name
    HANDLE *                phEnum - delete notification handle

Return Value
	HRESULT

--*/
{
    *phEnum = NULL;
    HRESULT hr;
    hr = MQADInitialize(true);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 230);
    }
    P<CBasicObjectType> pObject;
    MQADpAllocateObject(
                    eObject,
                    pwcsDomainController,
					fServerName,
                    pwcsObjectName,
                    NULL,   // pguidObject
                    &pObject
                    );
    //
    //  verify if the object is owned by PSC
    //
    if ( !g_VerifyUpdate.IsUpdateAllowed(
                                eObject,
                                pObject))
    {
	    TrERROR(mqad, "DeleteObject(with notification) not allowed");
        return MQ_ERROR_CANNOT_DELETE_PSC_OBJECTS;
    }

    //
    //	Keep information about the queue in order to be able to
    //	send notification about its deletion.
    //  ( MMC will not call MQDeleteQueue)
    //
    if (eObject != eQUEUE)
    {
	    return MQ_OK;
    }

    P<CQueueDeletionNotification>  pDelNotification;
    pDelNotification = new CQueueDeletionNotification();

    hr = pDelNotification->ObtainPreDeleteInformation(
                            pwcsObjectName,
                            pwcsDomainController,
							fServerName
                            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 240);
    }
    *phEnum = pDelNotification.detach();

    return MQ_OK;
}

HRESULT
MQAD_EXPORT
APIENTRY
MQADNotifyDelete(
        IN  HANDLE                  hEnum
	    )
/*++

Routine Description:
    The routine performs post delete actions ( i.e
    sending notification about queue deletion)

Arguments:
    HANDLE      hEnum - pointer to internal delete notification object

Return Value
	HRESULT

--*/
{
	ASSERT(g_fInitialized == true);

    CQueueDeletionNotification * phNotify = MQADpProbQueueDeleteNotificationHandle(hEnum);
	phNotify->PerformPostDeleteOperations();
    return MQ_OK;
}

HRESULT
MQAD_EXPORT
APIENTRY
MQADEndDeleteNotification(
        IN  HANDLE                  hEnum
        )
/*++

Routine Description:
    The routine cleans up delete-notifcation object

Arguments:
    HANDLE      hEnum - pointer to internal delete notification object

Return Value
	HRESULT

--*/
{
    ASSERT(g_fInitialized == true);

    CQueueDeletionNotification * phNotify = MQADpProbQueueDeleteNotificationHandle(hEnum);

    delete phNotify;

    return MQ_OK;
}



HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryMachineQueues(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID *            pguidMachine,
                IN  const MQCOLUMNSET*      pColumns,
                OUT PHANDLE                 phEnume
                )
/*++

Routine Description:
    Begin query of all queues that belongs to a specific computer

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID *            pguidMachine - the unqiue id of the computer
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

Return Value
	HRESULT

--*/
{
    *phEnume = NULL;
    CADHResult hr(eMACHINE);

    hr = MQADInitialize(false);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 280);
    }
    R<CQueueObject> pObject = new CQueueObject(NULL, NULL, pwcsDomainController, fServerName);

    HANDLE hCursor;
    AP<WCHAR> pwcsSearchFilter = new WCHAR[ x_ObjectCategoryPrefixLen +
                                            pObject->GetObjectCategoryLength() +
                                            x_ObjectCategorySuffixLen +
                                            1];

    swprintf(
        pwcsSearchFilter,
        L"%s%s%s",
        x_ObjectCategoryPrefix,
        pObject->GetObjectCategory(),
        x_ObjectCategorySuffix
        );

    hr = g_AD.LocateBegin(
                searchOneLevel,	
                adpDomainController,
                e_RootDSE,
                pObject.get(),
                pguidMachine,        // pguidSearchBase
                pwcsSearchFilter,
                NULL,                // pDsSortkey
                pColumns->cCol,      // attributes to be obtained
                pColumns->aCol,      // size of pAttributeNames array
                &hCursor);

    //
    //  BUGBUG - in case of failure, do we need to do the operation against
    //           Global Catalog also??
    //

    if (SUCCEEDED(hr))
    {
        CQueryHandle * phQuery = new CQueryHandle( hCursor,
                                                   pColumns->cCol,
                                                   pwcsDomainController,
												   fServerName
                                                   );
        *phEnume = (HANDLE)phQuery;
    }

    MQADpCheckAndNotifyOffline( hr);
    return(hr);

}


HRESULT
MQAD_EXPORT
APIENTRY
MQADQuerySiteServers(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN AD_SERVER_TYPE           eServerType,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                )
/*++

Routine Description:
    Begins query of all servers of a specific type in a specific site

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID *            pguidSite - the site id
    AD_SERVER_TYPE          eServerType- which type of server
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

Return Value
	HRESULT

--*/
{
    *phEnume = NULL;

    CADHResult hr(eMACHINE);
    hr = MQADInitialize(false);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 300);
    }


    PROPID  prop = PROPID_SET_QM_ID;

    HANDLE hCursor;
    R<CSettingObject> pObject = new CSettingObject(NULL, NULL, pwcsDomainController, fServerName);

    LPCWSTR pwcsAttribute;

    switch (eServerType)
    {
        case eRouter:
            pwcsAttribute = MQ_SET_SERVICE_ROUTING_ATTRIBUTE;
            break;

        case eDS:
            pwcsAttribute = MQ_SET_SERVICE_DSSERVER_ATTRIBUTE;
            break;

        default:
            ASSERT(0);
            return LogHR( MQ_ERROR_INVALID_PARAMETER, s_FN, 310);
            break;
    }

    DWORD dwFilterLen = x_ObjectCategoryPrefixLen +
                        pObject->GetObjectCategoryLength() +
                        x_ObjectCategorySuffixLen +
                        wcslen(pwcsAttribute) +
                        13;

    AP<WCHAR> pwcsSearchFilter = new WCHAR[ dwFilterLen];

    DWORD dw = swprintf(
        pwcsSearchFilter,
        L"(&%s%s%s(%s=TRUE))",
        x_ObjectCategoryPrefix,
        pObject->GetObjectCategory(),
        x_ObjectCategorySuffix,
        pwcsAttribute
        );
    DBG_USED( dw);
    ASSERT( dw < dwFilterLen);


    hr = g_AD.LocateBegin(
            searchSubTree,	
            adpDomainController,
            e_SitesContainer,
            pObject.get(),
            pguidSite,              // pguidSearchBase
            pwcsSearchFilter,
            NULL,
            1,
            &prop,
            &hCursor	        // result handle
            );

    if (FAILED(hr))
    {
        MQADpCheckAndNotifyOffline( hr);
        return LogHR(hr, s_FN, 315);
    }
    //
    // keep the result for lookup next
    //
    CRoutingServerQueryHandle * phQuery = new CRoutingServerQueryHandle(
                                              pColumns,
                                              hCursor,
                                              pObject.get(),
                                              pwcsDomainController,
											  fServerName
                                              );
    *phEnume = (HANDLE)phQuery;

    return(MQ_OK);

}


HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryUserCert(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const BLOB *             pblobUserSid,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                )
/*++

Routine Description:
    Begins query of all certificates that belong to a specific user

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const BLOB *            pblobUserSid - the user sid
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

Return Value
	HRESULT

--*/
{
    *phEnume = NULL;
    if (pColumns->cCol != 1)
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 320);
    }
    if (pColumns->aCol[0] != PROPID_U_SIGN_CERT)
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 330);
    }
    CADHResult hr(eUSER);

    hr = MQADInitialize(false);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 350);
    }

    //
    //  Get all the user certificates
    //  In NT5, a single attribute PROPID_U_SIGN_CERTIFICATE
    //  containes all the certificates
    //
    PROPVARIANT varNT5User;
    hr = LocateUser(
                 pwcsDomainController,
				 fServerName,
				 FALSE,  // fOnlyInDC
				 FALSE,  // fOnlyInGC
                 eUSER,
                 MQ_U_SID_ATTRIBUTE,
                 pblobUserSid,
                 NULL,      //pguidDigest
                 const_cast<MQCOLUMNSET*>(pColumns),
                 &varNT5User
                 );
    if (FAILED(hr))
    {
        MQADpCheckAndNotifyOffline( hr);
        return LogHR(hr, s_FN, 360);
    }
    //
    //  Get all the user certificates of MQUser
    //  A single attribute PROPID_MQU_SIGN_CERTIFICATE
    //  containes all the certificates
    //
    switch(pColumns->aCol[0])
    {
        case PROPID_U_SIGN_CERT:
            pColumns->aCol[0] = PROPID_MQU_SIGN_CERT;
            break;
        case PROPID_U_DIGEST:
            pColumns->aCol[0] = PROPID_MQU_DIGEST;
            break;
        default:
            ASSERT(0);
            break;
    }

    PROPVARIANT varMqUser;
    hr = LocateUser(
                 pwcsDomainController,
				 fServerName,
				 FALSE,  // fOnlyInDC
				 FALSE,  // fOnlyInGC
                 eMQUSER,
                 MQ_MQU_SID_ATTRIBUTE,
                 pblobUserSid,
                 NULL,      // pguidDigest
                 const_cast<MQCOLUMNSET*>(pColumns),
                 &varMqUser
                 );
    if (FAILED(hr))
    {
        MQADpCheckAndNotifyOffline( hr);
        return LogHR(hr, s_FN, 370);
    }

    AP<BYTE> pClean = varNT5User.blob.pBlobData;
    AP<BYTE> pClean1 = varMqUser.blob.pBlobData;
    //
    // keep the result for lookup next
    //
    CUserCertQueryHandle * phQuery = new CUserCertQueryHandle(
                                              &varNT5User.blob,
                                              &varMqUser.blob,
                                              pwcsDomainController,
											  fServerName
                                              );
    *phEnume = (HANDLE)phQuery;

    return(MQ_OK);
}

HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryConnectors(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                )
/*++

Routine Description:
    Begins query of all connectors of a specific site

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID *            pguidSite - the site id
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

Return Value
	HRESULT

--*/
{
    *phEnume = NULL;
    CADHResult hr(eMACHINE);

    hr = MQADInitialize(false);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 390);
    }

    //
    //  BUGBUG - the code handles one site only
    //
    P<CSiteGateList> pSiteGateList = new CSiteGateList;

    //
    //  Translate site guid into its DN name
    //
    PROPID prop = PROPID_S_FULL_NAME;
    PROPVARIANT var;
    var.vt = VT_NULL;
    CSiteObject object(NULL, pguidSite, pwcsDomainController, fServerName);

    hr = g_AD.GetObjectProperties(
                adpDomainController,
 	            &object,
                1,
                &prop,
                &var);

    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("QueryConnectors : Failed to retrieve the DN of the site %lx"),hr));
        return LogHR(hr, s_FN, 400);
    }
    AP<WCHAR> pwcsSiteDN = var.pwszVal;

    hr = MQADpQueryNeighborLinks(
				pwcsDomainController,
				fServerName,
				eLinkNeighbor1,
				pwcsSiteDN,
				pSiteGateList
				);
    if ( FAILED(hr))
    {
        MQADpCheckAndNotifyOffline( hr);
        DBGMSG((DBGMOD_DS,DBGLVL_TRACE,TEXT("QueryConnectors : Failed to query neighbor1 links %lx"),hr));
        return LogHR(hr, s_FN, 410);
    }

    hr = MQADpQueryNeighborLinks(
				pwcsDomainController,
				fServerName,
				eLinkNeighbor2,
				pwcsSiteDN,
				pSiteGateList
				);
    if ( FAILED(hr))
    {
        MQADpCheckAndNotifyOffline( hr);
        DBGMSG((DBGMOD_DS,DBGLVL_TRACE,TEXT("QueryConnectors : Failed to query neighbor2 links %lx"),hr));
        return LogHR(hr, s_FN, 420);
    }

    //
    // keep the results for lookup next
    //
    CConnectorQueryHandle * phQuery = new CConnectorQueryHandle(
												pColumns,
												pSiteGateList.detach(),
												pwcsDomainController,
												fServerName
												);
    *phEnume = (HANDLE)phQuery;

    return(MQ_OK);

}

HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryForeignSites(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                )
/*++

Routine Description:
    Begins query of all foreign sites

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

Return Value
	HRESULT

--*/
{
    *phEnume = NULL;
    CADHResult hr(eSITE);

    hr = MQADInitialize(false);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 440);
    }

    R<CSiteObject> pObject = new CSiteObject(NULL,NULL, pwcsDomainController, fServerName);
    DWORD dwFilterLen = x_ObjectCategoryPrefixLen +
                        pObject->GetObjectCategoryLength() +
                        x_ObjectCategorySuffixLen +
                        wcslen(MQ_S_FOREIGN_ATTRIBUTE) +
                        13;

    AP<WCHAR> pwcsSearchFilter = new WCHAR[ dwFilterLen];

    DWORD dw = swprintf(
        pwcsSearchFilter,
        L"(&%s%s%s(%s=TRUE))",
        x_ObjectCategoryPrefix,
        pObject->GetObjectCategory(),
        x_ObjectCategorySuffix,
        MQ_S_FOREIGN_ATTRIBUTE
        );
    DBG_USED( dw);
    ASSERT( dw < dwFilterLen);

    //
    //  Query all foreign sites
    //
    HANDLE hCursor;

    hr = g_AD.LocateBegin(
            searchOneLevel,	
            adpDomainController,
            e_SitesContainer,
            pObject.get(),
            NULL,				// pguidSearchBase
            pwcsSearchFilter,
            NULL,				// pDsSortkey
            pColumns->cCol,		// attributes to be obtained
            pColumns->aCol,		// size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CQueryHandle * phQuery = new CQueryHandle(
											hCursor,
											pColumns->cCol,
											pwcsDomainController,
											fServerName
											);
        *phEnume = (HANDLE)phQuery;
    }

    MQADpCheckAndNotifyOffline( hr);
    return LogHR(hr, s_FN, 450);
}

HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryLinks(
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN const GUID *             pguidSite,
            IN eLinkNeighbor            eNeighbor,
            IN const MQCOLUMNSET*       pColumns,
            OUT PHANDLE                 phEnume
            )
/*++

Routine Description:
    Begins query of all routing links to a specific site

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID *            pguidSite - the site id
    eLinkNeighbor           eNeighbor - which neighbour
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the
							results

Return Value
	HRESULT

--*/
{
    *phEnume = NULL;
    CADHResult hr(eROUTINGLINK);

    hr = MQADInitialize(false);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 470);
    }

    //
    //  Translate the site-id to the site DN
    //
    CSiteObject object(NULL, pguidSite, pwcsDomainController, fServerName);

    PROPID prop = PROPID_S_FULL_NAME;
    PROPVARIANT var;
    var.vt = VT_NULL;


    hr = g_AD.GetObjectProperties(
                adpDomainController,
                &object,
                1,
                &prop,
                &var);

    if (FAILED(hr))
    {
        MQADpCheckAndNotifyOffline( hr);
        return LogHR(hr, s_FN, 480);
    }

    AP<WCHAR> pwcsNeighborDN = var.pwszVal;
    //
    //  Prepare a query according to the neighbor DN
    //

    const WCHAR * pwcsAttribute;
    if ( eNeighbor == eLinkNeighbor1)
    {
        pwcsAttribute = MQ_L_NEIGHBOR1_ATTRIBUTE;
    }
    else
    {
        ASSERT( eNeighbor == eLinkNeighbor2);
        pwcsAttribute = MQ_L_NEIGHBOR2_ATTRIBUTE;
    }

    //
    //  Locate all the links
    //
    HANDLE hCursor;
    AP<WCHAR> pwcsFilteredNeighborDN;
    StringToSearchFilter( pwcsNeighborDN,
                          &pwcsFilteredNeighborDN
                          );
    R<CRoutingLinkObject> pObjectLink = new CRoutingLinkObject(NULL,NULL, pwcsDomainController, fServerName);

    DWORD dwFilterLen = x_ObjectCategoryPrefixLen +
                        pObjectLink->GetObjectCategoryLength() +
                        x_ObjectCategorySuffixLen +
                        wcslen(pwcsAttribute) +
                        wcslen(pwcsFilteredNeighborDN) +
                        13;

    AP<WCHAR> pwcsSearchFilter = new WCHAR[ dwFilterLen];

    DWORD dw = swprintf(
        pwcsSearchFilter,
        L"(&%s%s%s(%s=%s))",
        x_ObjectCategoryPrefix,
        pObjectLink->GetObjectCategory(),
        x_ObjectCategorySuffix,
        pwcsAttribute,
        pwcsFilteredNeighborDN
        );
    DBG_USED( dw);
    ASSERT( dw < dwFilterLen);


    hr = g_AD.LocateBegin(
            searchOneLevel,	
            adpDomainController,
            e_MsmqServiceContainer,
            pObjectLink.get(),
            NULL,				// pguidSearchBase
            pwcsSearchFilter,
            NULL,				// pDsSortKey
            pColumns->cCol,		// attributes to be obtained
            pColumns->aCol,		// size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CFilterLinkResultsHandle * phQuery = new CFilterLinkResultsHandle(
														hCursor,
														pColumns,
														pwcsDomainController,
														fServerName
														);
        *phEnume = (HANDLE)phQuery;
    }

    MQADpCheckAndNotifyOffline( hr);
    return LogHR(hr, s_FN, 490);
}

HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryAllLinks(
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN const MQCOLUMNSET*       pColumns,
            OUT PHANDLE                 phEnume
            )
/*++

Routine Description:
    Begins query of all routing links

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the
							results

Return Value
	HRESULT

--*/
{
    *phEnume = NULL;

    CADHResult hr(eROUTINGLINK);

    hr = MQADInitialize(false);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 510);
    }
    //
    //  Retrieve all routing links
    //
    //
    //  All the site-links are under the MSMQ-service container
    //

    HANDLE hCursor;

    R<CRoutingLinkObject> pObjectLink = new CRoutingLinkObject(NULL,NULL, pwcsDomainController, fServerName);

    DWORD dwFilterLen = x_ObjectCategoryPrefixLen +
                        pObjectLink->GetObjectCategoryLength() +
                        x_ObjectCategorySuffixLen +
                        1;

    AP<WCHAR> pwcsSearchFilter = new WCHAR[ dwFilterLen];

    DWORD dw = swprintf(
        pwcsSearchFilter,
        L"%s%s%s",
        x_ObjectCategoryPrefix,
        pObjectLink->GetObjectCategory(),
        x_ObjectCategorySuffix
        );
    DBG_USED( dw);
	ASSERT( dw < dwFilterLen);


    hr = g_AD.LocateBegin(
            searchOneLevel,	
            adpDomainController,
            e_MsmqServiceContainer,
            pObjectLink.get(),
            NULL,			// pguidSearchBase
            pwcsSearchFilter,
            NULL,			// pDsSortKey
            pColumns->cCol, // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	    // result handle
            );

    if (SUCCEEDED(hr))
    {
        CFilterLinkResultsHandle * phQuery = new CFilterLinkResultsHandle(
														hCursor,
														pColumns,
														pwcsDomainController,
														fServerName
														);
        *phEnume = (HANDLE)phQuery;
    }

    MQADpCheckAndNotifyOffline( hr);

    return LogHR(hr, s_FN, 520);
}

HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryAllSites(
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN const MQCOLUMNSET*       pColumns,
            OUT PHANDLE                 phEnume
            )
/*++

Routine Description:
    Begins query of all sites

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the
							results

Return Value
	HRESULT

--*/
{
    *phEnume = NULL;
    CADHResult hr(eSITE);

    hr = MQADInitialize(false);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 540);
    }
    HANDLE hCursor;
    PROPID prop[2] = { PROPID_S_SITEID, PROPID_S_PATHNAME};
    R<CSiteObject> pObject = new CSiteObject(NULL,NULL, pwcsDomainController, fServerName);

    DWORD dwFilterLen = x_ObjectCategoryPrefixLen +
                        pObject->GetObjectCategoryLength() +
                        x_ObjectCategorySuffixLen +
                        1;

    AP<WCHAR> pwcsSearchFilter = new WCHAR[ dwFilterLen];

    DWORD dw = swprintf(
        pwcsSearchFilter,
        L"%s%s%s",
        x_ObjectCategoryPrefix,
        pObject->GetObjectCategory(),
        x_ObjectCategorySuffix
        );
    DBG_USED( dw);
	ASSERT( dw < dwFilterLen);


    hr = g_AD.LocateBegin(
            searchOneLevel,	
            adpDomainController,
            e_SitesContainer,
            pObject.get(),
            NULL,       // pguidSearchBase
            pwcsSearchFilter,
            NULL,       // pDsSortKey
            2,
            prop,
            &hCursor	
            );


    if (SUCCEEDED(hr))
    {
        CSiteQueryHandle * phQuery = new CSiteQueryHandle(
												hCursor,
												pColumns,
												pwcsDomainController,
												fServerName
												);
        *phEnume = (HANDLE)phQuery;
    }

    MQADpCheckAndNotifyOffline( hr);
    return LogHR(hr, s_FN, 550);
}

HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryNT4MQISServers(
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN  DWORD                   dwServerType,
            IN  DWORD                   dwNT4,
            IN const MQCOLUMNSET*       pColumns,
            OUT PHANDLE                 phEnume
            )
/*++

Routine Description:
	Begin query of NT4 MQIS server ( this query is required
	only for mixed-mode support)

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	DWORD                   dwServerType - the type of server being looked for
	DWORD                   dwNT4 -
	const MQRESTRICTION*    pRestriction - query restriction
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the
							results

Return Value
	HRESULT

--*/
{
    *phEnume = NULL;
    CADHResult hr(eSETTING);

    hr = MQADInitialize(false);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 570);
    }
    //
    //  Query NT4 MQIS Servers (
    //
    R<CSettingObject> pObject = new CSettingObject(NULL,NULL, pwcsDomainController, fServerName);
    const DWORD x_NumberLength = 256;

    DWORD dwFilterLen = x_ObjectCategoryPrefixLen +
                        pObject->GetObjectCategoryLength() +
                        x_ObjectCategorySuffixLen +
                        wcslen(MQ_SET_SERVICE_ATTRIBUTE) +
                        x_NumberLength +
                        wcslen(MQ_SET_NT4_ATTRIBUTE) +
                        x_NumberLength +
                        11;

    AP<WCHAR> pwcsSearchFilter = new WCHAR[ dwFilterLen];

    DWORD dw = swprintf(
        pwcsSearchFilter,
        L"(&%s%s%s(%s=%d)(%s>=%d))",
        x_ObjectCategoryPrefix,
        pObject->GetObjectCategory(),
        x_ObjectCategorySuffix,
        MQ_SET_SERVICE_ATTRIBUTE,
        dwServerType,
        MQ_SET_NT4_ATTRIBUTE,
        dwNT4
        );
    DBG_USED( dw);
	ASSERT( dw < dwFilterLen);

    HANDLE hCursor;

    hr = g_AD.LocateBegin(
            searchSubTree,	
            adpDomainController,
            e_SitesContainer,
            pObject.get(),
            NULL,				// pguidSearchBase
            pwcsSearchFilter,
            NULL,				// pDsSortKey
            pColumns->cCol,		// attributes to be obtained
            pColumns->aCol,		// size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CQueryHandle * phQuery = new CQueryHandle(
											hCursor,
											pColumns->cCol,
											pwcsDomainController,
											fServerName
											);
        *phEnume = (HANDLE)phQuery;
    }

    MQADpCheckAndNotifyOffline( hr);
    return LogHR(hr, s_FN, 580);
}


HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryQueues(
                IN  LPCWSTR                 pwcsDomainController,
	            IN  bool					fServerName,
                IN  const MQRESTRICTION*    pRestriction,
                IN  const MQCOLUMNSET*      pColumns,
                IN  const MQSORTSET*        pSort,
                OUT PHANDLE                 phEnume
                )
/*++

Routine Description:
	Begin query of queues according to specified restriction
	and sort order

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const MQRESTRICTION*    pRestriction - query restriction
	const MQCOLUMNSET*      pColumns - result columns
	const MQSORTSET*        pSort - how to sort the results
	PHANDLE                 phEnume - query handle for retriving the
							results

Return Value
	HRESULT

--*/
{

    //
    //  Check sort parameter
    //
    HRESULT hr1 = MQADpCheckSortParameter( pSort);
    if (FAILED(hr1))
    {
        return LogHR(hr1, s_FN, 590);
    }

    CADHResult hr(eQUEUE);

    hr = MQADInitialize(false);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 610);
    }
    HANDLE hCursur;
    R<CQueueObject> pObject = new CQueueObject(NULL, NULL, pwcsDomainController, fServerName);

    AP<WCHAR> pwcsSearchFilter;
    hr = MQADpRestriction2AdsiFilter(
                            pRestriction,
                            pObject->GetObjectCategory(),
                            pObject->GetClass(),
                            &pwcsSearchFilter
                            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 620);
    }


    hr = g_AD.LocateBegin(
                searchSubTree,	
                adpGlobalCatalog,
                e_RootDSE,
                pObject.get(),
                NULL,        // pguidSearchBase
                pwcsSearchFilter,
                pSort,
                pColumns->cCol,
                pColumns->aCol,
                &hCursur);
    if ( SUCCEEDED(hr))
    {
        CQueryHandle * phQuery = new CQueryHandle( 
											hCursur,
											pColumns->cCol,
											pwcsDomainController,
											fServerName
											);
        *phEnume = (HANDLE)phQuery;
    }

    MQADpCheckAndNotifyOffline( hr);
    return LogHR(hr, s_FN, 630);
}

HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryResults(
                IN      HANDLE          hEnum,
                IN OUT  DWORD*          pcProps,
                OUT     PROPVARIANT     aPropVar[]
                )
/*++

Routine Description:
	retrieves another set of query results

Arguments:
	HANDLE          hEnum - query handle
	DWORD*          pcProps - number of results to return
	PROPVARIANT     aPropVar - result values

Return Value
	HRESULT

--*/
{
    if (hEnum == NULL)
    {
        return MQ_ERROR_INVALID_HANDLE;
    }
    CADHResult hr(eQUEUE);  //BUGBUG what is the best object to pass here?
    ASSERT( g_fInitialized == true);

    CBasicQueryHandle * phQuery = MQADpProbQueryHandle(hEnum);

    hr = phQuery->LookupNext(
                pcProps,
                aPropVar
                );

    MQADpCheckAndNotifyOffline( hr);
    return LogHR(hr, s_FN, 650);

}

HRESULT
MQAD_EXPORT
APIENTRY
MQADEndQuery(
            IN  HANDLE                  hEnum
            )
/*++

Routine Description:
	Cleanup after a query

Arguments:
	HANDLE    hEnum - the query handle

Return Value
	HRESULT

--*/
{
    if (hEnum == NULL)
    {
        return MQ_ERROR_INVALID_HANDLE;
    }

    CADHResult hr(eQUEUE);  //BUGBUG what is the best object to pass here?
    ASSERT(g_fInitialized == true);

    CBasicQueryHandle * phQuery = MQADpProbQueryHandle(hEnum);

    hr = phQuery->LookupEnd();

    MQADpCheckAndNotifyOffline( hr);
    return LogHR(hr, s_FN, 670);

}


STATIC
HRESULT
_GetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
	            IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const GUID *            pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                )
/*++

Routine Description:
    The routine retrieves an objectsecurity from AD by forwarding the 
    request to the relevant provider

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    LPCWSTR                 pwcsObjectName - msmq name of the object
    const GUID*             pguidObject - unique id of the object
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	PROPVARIANT             pVar - property values

Return Value
	HRESULT

--*/
{
    CADHResult hr(eObject);

    hr = MQADInitialize(false);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 690);
    }

    P<CBasicObjectType> pObject;
    MQADpAllocateObject( 
                    eObject,
                    pwcsDomainController,
					fServerName,
                    pwcsObjectName,
                    pguidObject,
                    &pObject
                    );


    hr = pObject->GetObjectSecurity(
                        RequestedInformation,
                        prop,
                        pVar
                        );


    MQADpCheckAndNotifyOffline( hr);
    return(hr);
}



HRESULT
MQAD_EXPORT
APIENTRY
MQADGetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
	            IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                )
/*++

Routine Description:
    The routine retrieves an objectsecurity from AD by forwarding the 
    request to the relevant provider

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    LPCWSTR                 pwcsObjectName - msmq name of the object
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	PROPVARIANT             pVar - property values

Return Value
	HRESULT

--*/
{
    return _GetObjectSecurity(
				eObject,
				pwcsDomainController,
				fServerName,
				pwcsObjectName,
				NULL,           // pguidObject
				RequestedInformation,
				prop,
				pVar
				);
}

HRESULT
MQAD_EXPORT
APIENTRY
MQADGetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
	            IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                )
/*++

Routine Description:
    The routine retrieves an objectsecurity from AD by forwarding the 
    request to the relevant provider

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID*             pguidObject - unique id of the object
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	PROPVARIANT             pVar - property values

Return Value
	HRESULT

--*/
{
    return _GetObjectSecurity(
				eObject,
				pwcsDomainController,
				fServerName,
				NULL,           // pwcsObjectName,
				pguidObject,
				RequestedInformation,
				prop,
				pVar
				);
}


STATIC
HRESULT
_SetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
	            IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                )
/*++

Routine Description:
    The routine sets object security in AD 

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
	const GUID *            pguidObject - object unique id
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values

Return Value
	HRESULT

--*/
{
    CADHResult hr(eObject);

    hr = MQADInitialize(true);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 710);
    }
    //
    //  Verify if object creation is allowed (mixed mode)
    //
    P<CBasicObjectType> pObject;
    MQADpAllocateObject( 
                    eObject,
                    pwcsDomainController,
					fServerName,
                    pwcsObjectName,
                    pguidObject,
                    &pObject
                    );

    if ( !g_VerifyUpdate.IsUpdateAllowed(
                               eObject,
                               pObject))
    {
	    TrERROR(mqad, "SetObjectSecurity not allowed");
        return MQ_ERROR_CANNOT_DELETE_PSC_OBJECTS;
    }


    //
    // prepare info request
    //
    P<MQDS_OBJ_INFO_REQUEST> pObjInfoRequest;
    P<MQDS_OBJ_INFO_REQUEST> pParentInfoRequest;
    pObject->PrepareObjectInfoRequest( &pObjInfoRequest);
    pObject->PrepareObjectParentRequest( &pParentInfoRequest);

    CAutoCleanPropvarArray cCleanSetInfoRequestPropvars;
    if (pObjInfoRequest != NULL)
    {
        cCleanSetInfoRequestPropvars.attachClean(
                pObjInfoRequest->cProps,
                pObjInfoRequest->pPropVars
                );
    }
    CAutoCleanPropvarArray cCleanSetParentInfoRequestPropvars;
    if (pParentInfoRequest != NULL)
    {
        cCleanSetParentInfoRequestPropvars.attachClean(
                pParentInfoRequest->cProps,
                pParentInfoRequest->pPropVars
                );
    }

    //
    // set the object security
    //
    hr = pObject->SetObjectSecurity(
            RequestedInformation,         
            prop,  
            pVar, 
            pObjInfoRequest, 
            pParentInfoRequest);
    if (FAILED(hr))
    {
        MQADpCheckAndNotifyOffline( hr);
        return LogHR(hr, s_FN, 720);
    }
    
    //
    //  send notification
    //
    pObject->ChangeNotification(
            pwcsDomainController,
            pObjInfoRequest, 
            pParentInfoRequest);

    return(MQ_OK);
}


HRESULT
MQAD_EXPORT
APIENTRY
MQADSetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
	            IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                )
/*++

Routine Description:
    The routine sets object security in AD 

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values

Return Value
	HRESULT

--*/
{
    return _SetObjectSecurity(
				eObject,
				pwcsDomainController,
				fServerName,
				pwcsObjectName,
				NULL,               // pguidObject
				RequestedInformation,
				prop,
				pVar
				);
}

HRESULT
MQAD_EXPORT
APIENTRY
MQADSetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
	            IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                )
/*++

Routine Description:
    The routine sets object security in AD 

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const GUID *            pguidObject - object unique id
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values

Return Value
	HRESULT

--*/
{
    return _SetObjectSecurity(
				eObject,
				pwcsDomainController,
				fServerName,
				NULL,               // pwcsObjectName,
				pguidObject,
				RequestedInformation,
				prop,
				pVar
				);
}

HRESULT
MQAD_EXPORT
APIENTRY
MQADGetADsPathInfo(
                IN  LPCWSTR                 pwcsADsPath,
                OUT PROPVARIANT *           pVar,
                OUT eAdsClass *             pAdsClass
                )
/*++

Routine Description:
    The routine gets some format-name related info about the specified 
    object

Arguments:
	LPCWSTR                 pwcsADsPath - object pathname
	const PROPVARIANT       pVar - property values
    eAdsClass *             pAdsClass - indication about the object class

Return Value
	HRESULT

--*/
{
    CADHResult hr(eCOMPUTER); // set a default that will not cause overwrite of errors to specific queue errors
 
    hr = MQADInitialize(true);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 710);
    }

    hr = g_AD.GetADsPathInfo(
                pwcsADsPath,
                pVar,
                pAdsClass
                );
    return hr;
}


HRESULT
MQAD_EXPORT
APIENTRY
MQADGetComputerVersion(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
	            IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const GUID*             pguidObject,
                OUT PROPVARIANT *           pVar
                )
/*++

Routine Description:
    The routine reads the version of computer 

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
	const GUID *            pguidObject - object unique id
	PROPVARIANT             pVar - version property value

Return Value
	HRESULT

--*/
{
    CADHResult hr(eObject);

    hr = MQADInitialize(false);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 717);
    }

    P<CBasicObjectType> pObject;
    MQADpAllocateObject( 
                    eObject,
                    pwcsDomainController,
					fServerName,
                    pwcsObjectName,
                    pguidObject,
                    &pObject
                    );

    hr = pObject->GetComputerVersion(
                pVar
                );

    if (FAILED(hr))
    {
        MQADpCheckAndNotifyOffline( hr);
    }
    return LogHR(hr, s_FN, 727);
}


void
MQAD_EXPORT
APIENTRY
MQADFreeMemory(
		IN  PVOID	pMemory
		)
{
	delete pMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\mqadglbo.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mqadglbo.cpp

Abstract:

    Declaration of Global Instances of MQAD dll.
    They are put in one place to ensure the order their constructors take place.

Author:

    ronit hartmann (ronith)

--*/
#include "ds_stdh.h"
#include "ads.h"
#include "updtallw.h"
#include "dsproto.h"
#include "traninfo.h"
#include "sndnotif.h"

#include "mqadglbo.tmh"

//
// single global object providing Active Directory access
//
CAdsi g_AD;

//
// single global object for verifying if object update is allowed
//
CVerifyObjectUpdate g_VerifyUpdate;

//
//  Single object for notifying the QM about AD changes
//
CSendNotification g_Notification;

//
//  Global DS pathnames
//
AP<WCHAR> g_pwcsServicesContainer;
AP<WCHAR> g_pwcsMsmqServiceContainer;
AP<WCHAR> g_pwcsDsRoot;
AP<WCHAR> g_pwcsSitesContainer;
AP<WCHAR> g_pwcsConfigurationContainer;
AP<WCHAR> g_pwcsLocalDsRoot;
AP<WCHAR> g_pwcsSchemaContainer;

bool g_fSetupMode = false;
bool g_fQMDll = false;
// translation information of properties
CMap<PROPID, PROPID, const translateProp*, const translateProp*&> g_PropDictionary;

QMLookForOnlineDS_ROUTINE g_pLookDS;
//
//  Initailization is not done when MQADInit is called, but when it is acually required becuase of
//  some API call
//
bool   g_fInitialized = false;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\mqadglbo.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mqadglbo.h

Abstract:

    Definition of Global Instances of the MQAD dll.
    They are put in one place to ensure the order their constructors take place.

Author:

    ronit hartmann (ronith)

--*/
#ifndef __MQADGLBO_H__
#define __MQADGLBO_H__

#include "ds_stdh.h"
#include "ads.h"
#include "updtallw.h"
#include "dsproto.h"
#include "traninfo.h"
#include "sndnotif.h"

//
// single global object providing Active Directory access
//
extern CAdsi g_AD;

//
// single global object for verifying if object update is allowed
//
extern CVerifyObjectUpdate g_VerifyUpdate;

//
//  Single object for notifying the QM about AD changes
//
extern CSendNotification g_Notification;

//
//  Global DS pathnames
//
extern AP<WCHAR> g_pwcsServicesContainer;
extern AP<WCHAR> g_pwcsMsmqServiceContainer;
extern AP<WCHAR> g_pwcsDsRoot;
extern AP<WCHAR> g_pwcsSitesContainer;
extern AP<WCHAR> g_pwcsConfigurationContainer;
extern AP<WCHAR> g_pwcsLocalDsRoot;
extern AP<WCHAR> g_pwcsSchemaContainer;

extern bool g_fSetupMode;
extern bool g_fQMDll;

// translation information of properties
extern CMap<PROPID, PROPID, const translateProp*, const translateProp*&> g_PropDictionary;

extern QMLookForOnlineDS_ROUTINE g_pLookDS;
//
//  Initailization is not done when MQADInit is called, but when it is acually required becuase of
//  some API call
//
extern bool   g_fInitialized;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\mqcuser.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mqcuser.cpp

Abstract:

    MQDSCORE library,
    private internal functions for DS operations of user objects.

Author:

    ronit hartmann (ronith)

--*/
#include "ds_stdh.h"
#include <_propvar.h>
#include "mqadp.h"
#include "ads.h"
#include "mqattrib.h"
#include "mqads.h"
#include "usercert.h"
#include "adtempl.h"
#include "mqadglbo.h"
#include "adserr.h"
#include "dsutils.h"
#include <aclapi.h>
#include "..\..\mqsec\inc\permit.h"

#include "mqcuser.tmh"

static WCHAR *s_FN=L"mqdscore/mqcuser";

//+-------------------------------------
//
//  HRESULT _LocateUserByProvider()
//
//+-------------------------------------

static 
HRESULT 
_LocateUserByProvider(
                 IN  LPCWSTR         pwcsDomainController,
				 IN  bool			 fServerName,
                 IN  AD_OBJECT       eObject,
                 IN  LPCWSTR         pwcsAttribute,
                 IN  const BLOB *    pblobUserSid,
                 IN  const GUID *    pguidDigest,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  AD_PROVIDER     eDSProvider,
                 OUT PROPVARIANT    *pvar,
                 OUT DWORD          *pdwNumofProps,
                 OUT BOOL           *pfUserFound 
				 )
{
    *pfUserFound = FALSE ;
    CAdQueryHandle hCursor;
    HRESULT hr;
    R<CBasicObjectType> pObject;
    MQADpAllocateObject( 
                    eObject,
                    pwcsDomainController,
					fServerName,
                    NULL,   // pwcsObjectName
                    NULL,   // pguidObject 
                    &pObject.ref()
                    );

    ADsFree  pwcsBlob;
    if ( pblobUserSid != NULL)
    {
        hr = ADsEncodeBinaryData(
            pblobUserSid->pBlobData,
            pblobUserSid->cbSize,
            &pwcsBlob
            );
        if (FAILED(hr))
        {
          return LogHR(hr, s_FN, 950);
        }
    }
    else
    {
        ASSERT(pguidDigest != NULL);
        hr = ADsEncodeBinaryData(
            (unsigned char *)pguidDigest,
            sizeof(GUID),
            &pwcsBlob
            );
        if (FAILED(hr))
        {
          return LogHR(hr, s_FN, 940);
        }
    }

    DWORD dwFilterLen = x_ObjectCategoryPrefixLen +
                        pObject->GetObjectCategoryLength() +
                        x_ObjectCategorySuffixLen + 
                        wcslen(pwcsAttribute) +
                        wcslen( pwcsBlob) +
                        13;

    AP<WCHAR> pwcsSearchFilter = new WCHAR[ dwFilterLen];

    DWORD dw = swprintf(
        pwcsSearchFilter,
        L"(&%s%s%s(%s=%s))",
        x_ObjectCategoryPrefix,
        pObject->GetObjectCategory(),
        x_ObjectCategorySuffix,
        pwcsAttribute,
        pwcsBlob
        );
    DBG_USED(dw);
	ASSERT( dw < dwFilterLen);


   hr = g_AD.LocateBegin(
            searchSubTree,	
            eDSProvider,
            e_RootDSE,
            pObject.get(),
            NULL,   //pguidSearchBase 
            pwcsSearchFilter,
            NULL,   // pDsSortKey 
            pColumns->cCol,
            pColumns->aCol,
            hCursor.GetPtr()
            );

    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
          "_LocateUserByProvider: LocateBegin(prov- %lut) failed, hr- %lx"),
                                          (ULONG) eDSProvider, hr)) ;
        return LogHR(hr, s_FN, 10);
    }
    //
    //  read the user certificate attribute
    //
    DWORD cp = 1;
    DWORD *pcp = pdwNumofProps ;
    if (!pcp)
    {
        pcp = &cp ;
    }

    pvar->vt = VT_NULL;

    hr =  g_AD.LocateNext(
                hCursor.GetHandle(),
                pcp,
                pvar
                );
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
            "_LocateUserByProvider: LocateNext() failed, hr- %lx"), hr));
        return LogHR(hr, s_FN, 20);
    }

	if (*pcp == 0)
	{
		//
		// Didn't find any certificate.
		//
		pvar->blob.cbSize = 0 ;
		pvar->blob.pBlobData = NULL ;
	}
    else
    {
        *pfUserFound = TRUE ;
    }

    return (MQ_OK);
}
//+------------------------------------------------------------------------
//
//  HRESULT LocateUser()
//
// Input Parameters:
//   IN  BOOL  fOnlyInDC- TRUE if caller want to locate the user object
//      only in  domain controller. that feature
//      is used when handling NT4 machines or users that do not support
//      Kerberos and can not delegate to other domain controllers.
//
//+------------------------------------------------------------------------

HRESULT LocateUser( 
                    IN  LPCWSTR            pwcsDomainController,
					IN  bool 			   fServerName,
                    IN  BOOL               fOnlyInDC,
                    IN  BOOL               fOnlyInGC,
                    IN  AD_OBJECT          eObject,
                    IN  LPCWSTR            pwcsAttribute,
                    IN  const BLOB *       pblobUserSid,
                    IN  const GUID *       pguidDigest,
                    IN  MQCOLUMNSET       *pColumns,
                    OUT PROPVARIANT       *pvar,
                    OUT DWORD             *pdwNumofProps,
                    OUT BOOL              *pfUserFound )
{
    //
    // first query in local domain conroller.
    //
    DWORD dwNumOfProperties = 0 ;
    if (pdwNumofProps)
    {
        dwNumOfProperties = *pdwNumofProps;
    }
    BOOL fUserFound ;
    BOOL *pfFound = pfUserFound ;
    if (!pfFound)
    {
        pfFound = &fUserFound ;
    }
    *pfFound = FALSE ;

    AD_PROVIDER  eDSProvider = adpDomainController ;
    if (fOnlyInGC)
    {
        eDSProvider = adpGlobalCatalog ;
    }

    HRESULT hr = _LocateUserByProvider(
                                        pwcsDomainController,
										fServerName,
                                        eObject,
                                        pwcsAttribute,
                                        pblobUserSid,
                                        pguidDigest,
                                        pColumns,
                                        eDSProvider,
                                        pvar,
                                        pdwNumofProps,
                                        pfFound ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }
    else if (*pfFound)
    {
        return LogHR(hr, s_FN, 40);
    }
    else if (fOnlyInDC || fOnlyInGC)
    {
        //
        // Don't look (again) in Global Catalog.
        // Search only in local domain controller, or ONLY in GC. done!
        //
        return LogHR(hr, s_FN, 50);
    }

    //
    // If user not found in local domain controller, then query GC.
    //
    if (pdwNumofProps)
    {
        *pdwNumofProps = dwNumOfProperties;
    }
    hr = _LocateUserByProvider(
                                pwcsDomainController,
								fServerName,
                                eObject,
                                pwcsAttribute,
                                pblobUserSid,
                                pguidDigest,
                                pColumns,
                                adpGlobalCatalog,
                                pvar,
                                pdwNumofProps,
                                pfFound ) ;
    return LogHR(hr, s_FN, 60);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\mqusrobj.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation 

Module Name:

    mqusrobj.cpp

Abstract:

    Implementation of CMqUserObject class.

Author:

    ronith

--*/
#include "ds_stdh.h"
#include "baseobj.h"
#include "mqattrib.h"
#include "mqadglbo.h"
#include "mqsec.h"
#include "usercert.h"

#include "mqusrobj.tmh"

static WCHAR *s_FN=L"mqad/mqusrobj";

DWORD CMqUserObject::m_dwCategoryLength = 0;
AP<WCHAR> CMqUserObject::m_pwcsCategory = NULL;


CMqUserObject::CMqUserObject( 
                    LPCWSTR         pwcsPathName,
                    const GUID *    pguidObject,
                    LPCWSTR         pwcsDomainController,
					bool		    fServerName
                    ) : CBasicObjectType( 
								pwcsPathName, 
								pguidObject,
								pwcsDomainController,
								fServerName
								)
/*++
    Abstract:
	constructor of msmq-user object

    Parameters:
    LPCWSTR       pwcsPathName - the object MSMQ name
    const GUID *  pguidObject  - the object unique id
    LPCWSTR       pwcsDomainController - the DC name against
	                             which all AD access should be performed
    bool		   fServerName - flag that indicate if the pwcsDomainController
							     string is a server name

    Returns:
	none

--*/
{
    //
    //  don't assume that the object can be found on DC
    //
    m_fFoundInDC = false;
    //
    //  Keep an indication that never tried to look for
    //  the object in AD ( and therefore don't really know if it can be found
    //  in DC or not)
    //
    m_fTriedToFindObject = false;
}

CMqUserObject::~CMqUserObject()
/*++
    Abstract:
	destructor of site object

    Parameters:
	none

    Returns:
	none
--*/
{
	//
	// nothing to do ( everything is released with automatic pointers
	//
}

HRESULT CMqUserObject::ComposeObjectDN()
/*++
    Abstract:
	Composed distinguished name of the msmq-user object

    Parameters:
	none

    Returns:
	none
--*/
{
    //
    //  Our code doesn't support access to user object according
    //  to pathname.
    //
    ASSERT(0);
    LogIllegalPoint(s_FN, 81);
    return MQ_ERROR_DS_ERROR;
}

HRESULT CMqUserObject::ComposeFatherDN()
/*++
    Abstract:
	Composed distinguished name of the parent of msmq-user object

    Parameters:
	none

    Returns:
	none
--*/
{
    //
    //  Our code doesn't support access to user object according
    //  to pathname.
    //
    ASSERT(0);
    LogIllegalPoint(s_FN, 82);
    return MQ_ERROR_DS_ERROR;
}

LPCWSTR CMqUserObject::GetRelativeDN()
/*++
    Abstract:
	return the RDN of the msmq-user object

    Parameters:
	none

    Returns:
	LPCWSTR msmq-user RDN
--*/
{
    //
    //  we never actually create a new user object
    //
    ASSERT(0);
    LogIllegalPoint(s_FN, 83);
    return NULL;
}


DS_CONTEXT CMqUserObject::GetADContext() const
/*++
    Abstract:
	Returns the AD context where mq user object should be looked for

    Parameters:
	none

    Returns:
	DS_CONTEXT
--*/
{
    return e_RootDSE;
}

bool CMqUserObject::ToAccessDC() const
/*++
    Abstract:
	returns whether to look for the object in DC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	true or false
--*/
{
    if (!m_fTriedToFindObject)
    {
        return true;
    }
    return m_fFoundInDC;
}

bool CMqUserObject::ToAccessGC() const
/*++
    Abstract:
	returns whether to look for the object in GC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	true or false 
--*/
{
    if (!m_fTriedToFindObject)
    {
        return true;
    }
    return !m_fFoundInDC;
}

void CMqUserObject::ObjectWasFoundOnDC()
/*++
    Abstract:
	The object was found on DC, set indication not to
    look for it on GC


    Parameters:
	none

    Returns:
	none
--*/
{
    m_fTriedToFindObject = true;
    m_fFoundInDC = true;
}


LPCWSTR CMqUserObject::GetObjectCategory() 
/*++
    Abstract:
	prepares and retruns the object category string

    Parameters:
	none

    Returns:
	LPCWSTR object category string
--*/
{
    if (CMqUserObject::m_pwcsCategory == NULL)
    {
        DWORD len = wcslen(g_pwcsSchemaContainer) + wcslen(x_MQUserCategoryName) + 2;

        AP<WCHAR> pwcsCategory = new WCHAR[len];
        DWORD dw = swprintf(
             pwcsCategory,
             L"%s,%s",
             x_MQUserCategoryName,
             g_pwcsSchemaContainer
            );
        DBG_USED(dw);
		ASSERT( dw < len);

        if (NULL == InterlockedCompareExchangePointer(
                              &CMqUserObject::m_pwcsCategory.ref_unsafe(), 
                              pwcsCategory.get(),
                              NULL
                              ))
        {
            pwcsCategory.detach();
            CMqUserObject::m_dwCategoryLength = len;
        }
    }
    return CMqUserObject::m_pwcsCategory;
}

DWORD   CMqUserObject::GetObjectCategoryLength()
/*++
    Abstract:
	prepares and retruns the length object category string

    Parameters:
	none

    Returns:
	DWORD object category string length
--*/
{
	//
	//	call GetObjectCategory in order to initailaze category string
	//	and length
	//
	GetObjectCategory();

    return CMqUserObject::m_dwCategoryLength;
}

AD_OBJECT CMqUserObject::GetObjectType() const
/*++
    Abstract:
	returns the object type

    Parameters:
	none

    Returns:
	AD_OBJECT
--*/
{
    return eMQUSER;
}

LPCWSTR CMqUserObject::GetClass() const
/*++
    Abstract:
	returns a string represinting the object class in AD

    Parameters:
	none

    Returns:
	LPCWSTR object class string
--*/
{
    return MSMQ_MQUSER_CLASS_NAME;
}

DWORD CMqUserObject::GetMsmq1ObjType() const
/*++
    Abstract:
	returns the object type in MSMQ 1.0 terms

    Parameters:
	none

    Returns:
	DWORD 
--*/
{
    return MQDS_MQUSER;
}


HRESULT  CMqUserObject::CreateInAD(
            IN  const DWORD        cp,
            IN  const PROPID       aProp[  ],
            IN  const PROPVARIANT  apVar[  ],
            IN OUT MQDS_OBJ_INFO_REQUEST * /* pObjInfoRequest*/, 
            IN OUT MQDS_OBJ_INFO_REQUEST * /* pParentInfoRequest*/
                                   )
/*++
    Abstract:
	The routine creates msmq-user object in AD with the specified attributes
	values

    Parameters:
    const DWORD   cp - number of properties        
    const PROPID  *aProp - the propperties
    const MQPROPVARIANT *apVar - properties value
    PSECURITY_DESCRIPTOR    pSecurityDescriptor - SD of the object
    OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - properties to 
							retrieve while creating the object 
    OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - properties 
						to retrieve about the object's parent
    Returns:
	HRESULT
--*/
{
    ASSERT( m_pwcsPathName == NULL);

    DWORD dwIndexSidProp = cp;
    DWORD dwIndexCertProp = cp;
    DWORD dwIndexDigestProp = cp;
    DWORD dwIndexIdProp = cp;
    for ( DWORD i=0; i<cp; i++)
    {
        switch ( aProp[i])
        {
            case PROPID_MQU_SID:
                dwIndexSidProp = i;
                break;
            case PROPID_MQU_SIGN_CERT:
                dwIndexCertProp = i;
                break;
            case PROPID_MQU_DIGEST:
                dwIndexDigestProp = i;
                break;
            case PROPID_MQU_ID:
                dwIndexIdProp = i;
                break;
            default:
                break;
        }
    }

    if ( (dwIndexSidProp == cp) || (dwIndexDigestProp == cp) ||
         (dwIndexIdProp == cp) ||  (dwIndexCertProp == cp))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CMqUserObject::CreateObject : Wrong input properties")));
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 330);
    }

    //
    //  translate the SID into a user name
    //
    PSID pUserSid = apVar[ dwIndexSidProp].blob.pBlobData ;
    ASSERT(IsValidSid(pUserSid)) ;

    AP<WCHAR> pwcsUserName;
    HRESULT hr =  PrepareUserName( pUserSid,
                                  &pwcsUserName ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }

	AP<WCHAR> pwcsLocalDsRootToFree;
	LPWSTR pwcsLocalDsRoot = NULL;
	hr = g_AD.GetLocalDsRoot(
				m_pwcsDomainController, 
				m_fServerName,
				&pwcsLocalDsRoot,
				pwcsLocalDsRootToFree
				);

	if(FAILED(hr))
	{
		TrERROR(mqad, "Failed to get Local Ds Root, hr = 0x%x", hr);
		return LogHR(hr, s_FN, 165);
	}
    
	AP<WCHAR> pwcsParentPathName =
              new WCHAR[wcslen(pwcsLocalDsRoot) + x_msmqUsersOULen + 2];
    swprintf(
        pwcsParentPathName,
        L"%s,%s",
        x_msmqUsersOU,
        pwcsLocalDsRoot 
		);
    //
    //  Prepare the certificate attribute
    //
    DWORD cNewProps = cp + 1 ;
    P<PROPID> pPropId = new PROPID[ cNewProps ] ;
    memcpy( pPropId, aProp, sizeof(PROPID) * cp);
    AP<PROPVARIANT> pvarTmp = new PROPVARIANT[ cNewProps ];
    memcpy( pvarTmp, apVar, sizeof(PROPVARIANT) * cp);

    AP<BYTE> pCleanBlob;
    _PrepareCert(
            &pvarTmp[dwIndexCertProp],
            pvarTmp[dwIndexDigestProp].puuid,
            pvarTmp[dwIndexIdProp].puuid,
            &pCleanBlob
            );

    //
    // Prepare security descriptor.
    // This code may be called from the upgrade wizard or replication service
    // so we can not impersonte in order to get user sid. Instead, we'll
    // create an input security descriptor that contain only the owner.
    //
    SECURITY_DESCRIPTOR sd ;
    BOOL fSec = InitializeSecurityDescriptor( &sd,
                                            SECURITY_DESCRIPTOR_REVISION ) ;
    ASSERT(fSec) ;
    fSec = SetSecurityDescriptorOwner( &sd, pUserSid, TRUE ) ;
    ASSERT(fSec) ;

    pPropId[ cp ] = PROPID_MQU_SECURITY ;
    PSECURITY_DESCRIPTOR psd = NULL ;

    hr =  MQSec_GetDefaultSecDescriptor( MQDS_MQUSER,
                                         &psd,
                                         FALSE, // fImpersonate 
                                         &sd,
                                         (OWNER_SECURITY_INFORMATION |
                                          GROUP_SECURITY_INFORMATION),
                                         e_UseDefaultDacl ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 170);
    }
    ASSERT(psd && IsValidSecurityDescriptor(psd)) ;
    P<BYTE> pAutoDef = (BYTE*) psd ;
    pvarTmp[ cp ].blob.pBlobData = (BYTE*) psd ;
    pvarTmp[ cp ].blob.cbSize = GetSecurityDescriptorLength(psd) ;

    hr = _CreateMQUser( pwcsUserName,
                        pwcsParentPathName,
                        cNewProps,
                        pPropId,
                        pvarTmp ) ;

    if (hr == HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM))
    {
        //
        // Ignore the object guid when creating the msmqMigratedUser object.
        // Why don't I change this property in the first call ?
        // to avoid regressions.
        // Using the object guid is fine if we're running on a GC. Migration
        // code (both wizard and replication service) run on GC so they
        // should be fine with first call. Only msmq server on non-GC domain
        // controllers will see this problem, when users will try to register
        // certificate for the first time (when this object doesn't yet
        // exist). So for these cases, try again without the guid.
        //
        pPropId[ dwIndexIdProp ] = PROPID_QM_DONOTHING  ;

        hr = _CreateMQUser( pwcsUserName,
                            pwcsParentPathName,
                            cNewProps,
                            pPropId,
                            pvarTmp ) ;
    }

    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
    {
        //
		//	We will not try to create msmqUsers OU.
		//	The user most likly doesn't have rights to 
		//	create such container, and will need admin help.
		//	This is relevant only for NT4 usrs running on Whistler 
		//	computer
		//
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CMqUserObject::no msmqUsers OU")));
       return LogHR(MQ_ERROR_NO_MQUSER_OU, s_FN, 175);
    }

    return LogHR(hr, s_FN, 180);
}


HRESULT CMqUserObject::PrepareUserName(
                IN  PSID        pSid,
                OUT WCHAR **    ppwcsUserName
                               )
/*++

Routine Description:
    The routine prepare a name string for a mq-user object
    according to its sid

Arguments:
    pSid        - the user SID
    ppwcsUserName  - name string

Return Value:

--*/
{
    //
    //  First try to translate sid to user name
    //
    const DWORD  cLen = 512;
    WCHAR  szTextualSid[cLen ];
    DWORD  dwTextualSidLen = cLen ;
    //
    //  Translate the SID into a string
    //
    if (GetTextualSid(
        pSid,
        szTextualSid,
        &dwTextualSidLen
        ))
    {
        //
        //  return to the user the last 64 WCHARs ( length limit of cn attribute)
        //
        if ( dwTextualSidLen < 64)
        {
            *ppwcsUserName = new WCHAR[dwTextualSidLen + 1];
            wcscpy( *ppwcsUserName, szTextualSid);
        }
        else
        {
            *ppwcsUserName = new WCHAR[64 + 1];
            wcscpy( *ppwcsUserName, &szTextualSid[dwTextualSidLen - 64 - 1]);
        }
        return(MQ_OK);
    }
    else
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 140);
    }
}

BOOL CMqUserObject::GetTextualSid(
    IN      PSID pSid,            // binary Sid
    IN      LPTSTR TextualSid,    // buffer for Textual representation of Sid
    IN OUT  LPDWORD lpdwBufferLen // required/provided TextualSid buffersize
    )
/*++

Routine Description:
    The routine translates a Sid to a textual string

Arguments:
    pSid        - the user SID
    TextualSid  - string buffer
    lpdwBufferLen - IN: buffer length, OUT string length

Return Value:

--*/
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    // Validate the binary SID.

    if(!IsValidSid(pSid)) return LogBOOL(FALSE, s_FN, 110);

    // Get the identifier authority value from the SID.

    psia = GetSidIdentifierAuthority(pSid);

    // Get the number of subauthorities in the SID.

    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    // Compute the buffer length.
    // S-SID_REVISION- + IdentifierAuthority- + subauthorities- + NULL

    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    // Check input buffer length.
    // If too small, indicate the proper size and set last error.

    if (*lpdwBufferLen < dwSidSize)
    {
        *lpdwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return LogBOOL(FALSE, s_FN, 120);
    }

    // Add 'S' prefix and revision number to the string.

    dwSidSize=wsprintf(TextualSid, TEXT("S-%lu-"), dwSidRev );

    // Add SID identifier authority to the string.

    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    }
    else
    {
        dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                    TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    // Add SID subauthorities to the string.
    //
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        dwSidSize+=wsprintf(TextualSid + dwSidSize, TEXT("-%lu"),
                    *GetSidSubAuthority(pSid, dwCounter) );
    }
    *lpdwBufferLen = dwSidSize;
    return TRUE;
}

void  CMqUserObject::_PrepareCert(
            IN OUT PROPVARIANT * pvar,
            IN  const GUID *     pguidDigest,
            IN  const GUID *     pguidId,
            OUT BYTE**           ppbAllocatedCertBlob
            )
/*++

Routine Description:
    The routine prepares the certificate blob according to the structure
    that we keep in the DS

Arguments:
	PROPVARIANT * pvar - the prepared certificate
	const GUID *     pguidDigest - the digest of the certificate
	const GUID *     pguidId - user id ( kept in cert blob)
	BYTE**           ppbAllocatedCertBlob

Return Value
	HRESULT

--*/
{
    ULONG ulUserCertBufferSize = CUserCert::CalcSize( pvar->blob.cbSize);
    AP<unsigned char> pBuffUserCert = new unsigned char[ ulUserCertBufferSize];

#ifdef _DEBUG
#undef new
#endif
    CUserCert * pUserCert = new(pBuffUserCert) CUserCert(
                                   *pguidDigest,
                                   *pguidId,
                                   pvar->blob.cbSize,
                                   pvar->blob.pBlobData);
    AP<BYTE> pbTmp;
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    pbTmp = new BYTE[ CUserCertBlob::CalcSize() + ulUserCertBufferSize ];
#ifdef _DEBUG
#undef new
#endif
    CUserCertBlob * pUserCertBlob = new(pbTmp) CUserCertBlob(
                                pUserCert);
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    pUserCertBlob->MarshaleIntoBuffer( pbTmp);
    pvar->blob.cbSize = CUserCertBlob::CalcSize() + ulUserCertBufferSize;
    *ppbAllocatedCertBlob = pbTmp;
    pvar->blob.pBlobData= pbTmp.detach();

}

HRESULT CMqUserObject::_CreateMQUser(
            IN LPCWSTR              pwcsUserName,      
            IN LPCWSTR              pwcsParentPathName,
            IN const DWORD          cPropIDs,  
            IN const PROPID        *pPropIDs, 
            IN const MQPROPVARIANT *pPropVars
			)  
/*++

Routine Description:
    The routine create the MQ-user in AD

Arguments:
	LPCWSTR              pwcsUserName - object name
	LPCWSTR              pwcsParentPathName - object parent name
	const DWORD          cPropIDs -  number of attributes
	const PROPID        *pPropIDs - attributes
	const MQPROPVARIANT *pPropVars - attribute values

Return Value
	HRESULT

--*/
{
    HRESULT hr = g_AD.CreateObject( adpDomainController,
                                    this,
                                    pwcsUserName,
                                    pwcsParentPathName,
                                    cPropIDs,
                                    pPropIDs,
                                    pPropVars,
                                    NULL,    // pObjInfoRequest
                                    NULL	 // pParentInfoRequest
									);
    return LogHR(hr, s_FN, 150);
}

HRESULT CMqUserObject::SetObjectSecurity(
            IN  SECURITY_INFORMATION        /*RequestedInformation*/,
            IN  const PROPID                /*prop*/,
            IN  const PROPVARIANT *         /*pVar*/,
            IN OUT MQDS_OBJ_INFO_REQUEST *  /*pObjInfoRequest*/, 
            IN OUT MQDS_OBJ_INFO_REQUEST *  /*pParentInfoRequest*/
            )
/*++

Routine Description:
    The routine sets object security in AD 

Arguments:
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - infomation about the object
    MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - information about the object's parent

Return Value
	HRESULT

--*/
{
    //
    //  This operation is not supported
    //
    return MQ_ERROR_FUNCTION_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\queryh.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
	hquery.cpp

Abstract:
	Implementation of different query handles
	
Author:

    Ronit Hartmann (ronith)

--*/
#include "ds_stdh.h"
#include "queryh.h"
#include "ads.h"
#include "mqadglbo.h"
#include "usercert.h"

#include "queryh.tmh"

static WCHAR *s_FN=L"mqad/queryh";

/*====================================================

CQueryHandle::LookupNext

Arguments:
      pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
      pbBuffer- a caller allocated buffer



Performs Locate next on the DS directly
=====================================================*/

HRESULT CQueryHandle::LookupNext(
                IN OUT DWORD  *             pdwSize,
                OUT    PROPVARIANT  *       pbBuffer)
{
        HRESULT hr;

    DWORD  NoOfRecords;

    //
    // Calculate the number of records ( == results) to be read
    //
    NoOfRecords = *pdwSize /  m_dwNoPropsInResult;

    if ( NoOfRecords == 0)
    {
        //
        //  Number of properties is not big enough to hold one result
        //
        *pdwSize = 0;
        return LogHR(MQ_ERROR_RESULT_BUFFER_TOO_SMALL, s_FN, 10);
    }

    hr =    g_AD.LocateNext(
            m_hCursor.GetHandle(),
            pdwSize ,
            pbBuffer
            );


    return LogHR(hr, s_FN, 20);

}

/*====================================================

CRoutingServerQueryHandle::LookupNext

Arguments:
      pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
      pbBuffer- a caller allocated buffer


=====================================================*/
HRESULT CRoutingServerQueryHandle::LookupNext(
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer)
{
    HRESULT hr;

    DWORD  NoOfRecords;
    DWORD NoResultRead = 0;

    //
    // Calculate the number of records ( == results) to be read
    //
    NoOfRecords = *pdwSize / m_cCol;

    if ( NoOfRecords == 0)
    {
        //
        //  Number of properties is not big enough to hold one result
        //
        *pdwSize = 0;
        return LogHR(MQ_ERROR_RESULT_BUFFER_TOO_SMALL, s_FN, 40);
    }
    //
    //  From the DS read the unique ids of the FRSs
    //
    DWORD cp = NoOfRecords;
    AP<MQPROPVARIANT> pvarFRSid = new MQPROPVARIANT[cp];


	
    bool fRetry;
    do
    {
		fRetry = false;
		hr = g_AD.LocateNext(
					m_hCursor.GetHandle(),
					&cp ,
					pvarFRSid
					);

		if (FAILED(hr))
		{
			//
			// BUGBUG - are there other indication to failure of Locate next?
			//
			return LogHR(hr, s_FN, 50);
		}

		//
		//  For each of the results, retreive the properties
		//  the user asked for in locate begin
		//
		MQPROPVARIANT * pvar = pbBuffer;
		for (DWORD j = 0; j < *pdwSize; j++, pvar++)
		{
			pvar->vt = VT_NULL;
		}
		pvar = pbBuffer;
		for (DWORD i = 0; i < cp; i++)
		{
			CMqConfigurationObject object(NULL, pvarFRSid[i].puuid, NULL, false); 

			hr = g_AD.GetObjectProperties(
						adpGlobalCatalog,	
						&object,
						m_cCol,
						m_aCol,
						pvar
						);

			delete pvarFRSid[i].puuid;
			if (FAILED(hr))
			{
				if((NoResultRead == 0) &&			// No result yet
				   ((i + 1) == cp) &&				// Loop exit condition
				   (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT)))	// Object not found
				{
					//
					// The msmq object with the guid was not found in the DS.
					// This is probably a leftover of routing server object.
					// We are in the exit condition with NoResultRead = 0
					// so we need to retry the next server in the list.
					// otherwise the calling function will assume that there are no more result to fetch
					//
					fRetry = true;
				}
				continue;
			}
			pvar+= m_cCol;
			NoResultRead++;
		}
    } while(fRetry);

    *pdwSize = NoResultRead * m_cCol;
    return(MQ_OK);
}

/*====================================================

CUserCertQueryHandle::LookupNext

Arguments:
      pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
      pbBuffer- a caller allocated buffer



simulates query functionality on array of user-signed-certificates.
=====================================================*/
HRESULT CUserCertQueryHandle::LookupNext(
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer)
{
    if ( m_blobNT5UserCert.pBlobData == NULL &&
         m_blobNT4UserCert.pBlobData == NULL)
    {
        *pdwSize = 0;
        return(MQ_OK);
    }
    //
    //   m_blobNT?UserCert contains all the user certificates
    //
    CUserCertBlob * pNT5UserCertBlob = reinterpret_cast<CUserCertBlob *>(m_blobNT5UserCert.pBlobData);
    CUserCertBlob * pNT4UserCertBlob = reinterpret_cast<CUserCertBlob *>(m_blobNT4UserCert.pBlobData);
    //
    //   return the requested amount of responses
    //
    DWORD dwNT5NuberOfUserCertificates = 0;
    if ( pNT5UserCertBlob != NULL)
    {
        dwNT5NuberOfUserCertificates= pNT5UserCertBlob->GetNumberOfCerts();
    }
    DWORD dwNT4NuberOfUserCertificates = 0;
    if ( pNT4UserCertBlob != NULL)
    {
        dwNT4NuberOfUserCertificates= pNT4UserCertBlob->GetNumberOfCerts();
    }
    DWORD dwNuberOfUserCertificates = dwNT5NuberOfUserCertificates + dwNT4NuberOfUserCertificates;
    if ( dwNuberOfUserCertificates - m_dwNoCertRead == 0)
    {
       //
       //   No more responses left
       //
       *pdwSize = 0;
       return(MQ_OK);
    }
    DWORD dwNumResponses = (dwNuberOfUserCertificates - m_dwNoCertRead) > *pdwSize?
                *pdwSize:  (dwNuberOfUserCertificates - m_dwNoCertRead);

    HRESULT hr = MQ_OK;
    for (DWORD i = 0; i < dwNumResponses; i++)
    {
        if ( m_dwNoCertRead + i + 1 <=  dwNT5NuberOfUserCertificates)
        {
            hr = pNT5UserCertBlob->GetCertificate(
                            i + m_dwNoCertRead,
                            &pbBuffer[ i]
                            );
        }
        else
        {
            hr = pNT4UserCertBlob->GetCertificate(
                            i + m_dwNoCertRead - dwNT5NuberOfUserCertificates,
                            &pbBuffer[ i]
                            );
        }
       if (FAILED(hr))
       {
           break;
       }
    }
    m_dwNoCertRead += dwNumResponses;
    return LogHR(hr, s_FN, 30);
}



/*====================================================

CConnectorQueryHandle::LookupNext

Arguments:
      pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
      pbBuffer- a caller allocated buffer

=====================================================*/
HRESULT CConnectorQueryHandle::LookupNext(
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer)
{
    HRESULT hr;

    DWORD NoOfRecords;
    DWORD NoResultRead = 0;

    //
    // Calculate the number of records ( == results) to be read
    //
    NoOfRecords = *pdwSize /  m_cCol;

    if ( NoOfRecords == 0)
    {
        //
        //  Number of properties is not big enough to hold one result
        //
        *pdwSize = 0;
        return LogHR(MQ_ERROR_RESULT_BUFFER_TOO_SMALL, s_FN, 90);
    }
    MQPROPVARIANT * pvar = pbBuffer;
    for (DWORD j = 0; j < *pdwSize; j++, pvar++)
    {
        pvar->vt = VT_NULL;
    }
    pvar = pbBuffer;


    while ( NoResultRead < NoOfRecords)
    {
        if ( m_dwNumGatesReturned == m_pSiteGateList->GetNumberOfGates())
        {
            //
            //  no more gates to return
            //
            break;
        }

        //
        //  Retreive the properties
        //  the user asked for in locate begin
        //
        CMqConfigurationObject object(
									NULL,
									m_pSiteGateList->GetSiteGate(m_dwNumGatesReturned),
									m_pwcsDomainController,
									m_fServerName
									);

        hr = g_AD.GetObjectProperties(
                    adpDomainController,
                    &object,
                    m_cCol,
                    m_aCol,
                    pvar);

        if (FAILED(hr))
        {
            //
            //  BUGBUG - what to do in case of failure ??
            //
            break;
        }
        m_dwNumGatesReturned++;

        NoResultRead++;
        pvar += m_cCol;
    }
    *pdwSize = NoResultRead * m_cCol;
    return(MQ_OK);
}

/*====================================================

CFilterLinkResultsHandle::LookupNext

Arguments:
      pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
      pbBuffer- a caller allocated buffer

=====================================================*/
HRESULT CFilterLinkResultsHandle::LookupNext(
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer)
{

    DWORD NoOfRecords;
    DWORD NoResultRead = 0;

    //
    // Calculate the number of records ( == results) to be read
    //
    NoOfRecords = *pdwSize /  m_cCol;

    if ( NoOfRecords == 0)
    {
        //
        //  Number of properties is not big enough to hold one result
        //
        *pdwSize = 0;
        return LogHR(MQ_ERROR_RESULT_BUFFER_TOO_SMALL, s_FN, 130);
    }

    //
    //  Read the results one by one and check the validity of the site-link
    //
    HRESULT hr;
    PROPVARIANT * pbNextResultToFill = pbBuffer;

    while ( NoResultRead < NoOfRecords)
    {
        DWORD dwOneResultSize = m_cCol;

        hr =  g_AD.LocateNext(
                m_hCursor.GetHandle(),
                &dwOneResultSize,
                pbNextResultToFill
                );
        if (FAILED(hr) || (dwOneResultSize == 0))
        {
            break;
        }
        //
        //  validate siteLink
        //
        if (m_indexNeighbor1Column != m_cCol)
        {
            if ((pbNextResultToFill+m_indexNeighbor1Column)->vt == VT_EMPTY)
            {
                continue;
            }
        }
        if (m_indexNeighbor2Column != m_cCol)
        {
            if ((pbNextResultToFill+m_indexNeighbor2Column)->vt == VT_EMPTY)
            {
                continue;
            }
        }
        NoResultRead++;
        pbNextResultToFill += m_cCol;
    }
    *pdwSize =  m_cCol * NoResultRead;

    return(MQ_OK);
}

HRESULT CSiteQueryHandle::FillInOneResponse(
                IN   const GUID *  pguidSiteId,
                IN   LPCWSTR       pwcsSiteName,
                OUT  PROPVARIANT *           pbBuffer)
{   
    AP<GUID> paSiteGates;
    HRESULT hr;


    //
    //  Fill in the values into the variant array
    //
    hr = MQ_OK;
    for (DWORD i = 0; i < m_cCol; i++)
    {
        switch  (m_aCol[i])
        {
            case PROPID_S_PATHNAME:
                {
                pbBuffer[i].vt = VT_LPWSTR;
                DWORD len = wcslen(pwcsSiteName);
                pbBuffer[i].pwszVal = new WCHAR[len + 1];
                wcscpy( pbBuffer[i].pwszVal, pwcsSiteName);
                }
                break;

            case PROPID_S_SITEID:
                pbBuffer[i].vt = VT_CLSID;
                pbBuffer[i].puuid = new GUID;
                *pbBuffer[i].puuid = *pguidSiteId;
                break;


            default:
                ASSERT(0);
                hr = MQ_ERROR_DS_ERROR;
                break;
        }
    } 
    return LogHR(hr, s_FN, 70);

}


/*====================================================

CSiteQueryHandle::LookupNext

Arguments:
      pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
      pbBuffer- a caller allocated buffer

Performs locate next of site objects ( need to make sure if it is an MSMQ site or not)
=====================================================*/
HRESULT CSiteQueryHandle::LookupNext(
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer)
{
    HRESULT hr;

    DWORD  NoOfRecords;
    DWORD NoResultRead = 0;

    //
    // Calculate the number of records ( == results) to be read
    //
    NoOfRecords = *pdwSize /  m_cCol;

    if ( NoOfRecords == 0)
    {
        //
        //  Number of properties is not big enough to hold one result
        //
        *pdwSize = 0;
        return LogHR(MQ_ERROR_RESULT_BUFFER_TOO_SMALL, s_FN, 80);
    }

    while ( NoResultRead < NoOfRecords)
    {
        //
        //  Retrieve the site id and name
        //
        DWORD cp = 2;
        MQPROPVARIANT var[2];
        var[0].vt = VT_NULL;
        var[1].vt = VT_NULL;

        hr = g_AD.LocateNext(
            m_hCursor.GetHandle(),
            &cp ,
            var
            );
        if (FAILED(hr) || ( cp == 0))
        {
            //
            //  no more sites
            //
            break;
        }
        P<GUID> pguidSiteId = var[0].puuid;
        AP<WCHAR> pwcsSiteName = var[1].pwszVal;

        hr =  FillInOneResponse(
                pguidSiteId,
                pwcsSiteName,
                &pbBuffer[ m_cCol * NoResultRead]);
        if (FAILED(hr))
        {
            //
            //  continue to next site
            //
            continue;
        }
        NoResultRead++;

    }
    *pdwSize = NoResultRead * m_cCol;
    return(MQ_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\queryh.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
	hquery.h

Abstract:
	query handle classes, for locate nect of different queries

Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __QUERYH_H__
#define __QUERYH_H__
#include "adtempl.h"
#include "baseobj.h"
#include "siteinfo.h"

//-----------------------------------------------------------------------------------
//
//      CBasicQueryHandle
//
//  Virtual class, all query-handle classes are derived from this class.
//
//-----------------------------------------------------------------------------------
class CBasicQueryHandle
{
public:
    CBasicQueryHandle(
                IN LPCWSTR  pwcsDomainController,
				IN bool		fServerName
                );

	~CBasicQueryHandle();
	virtual HRESULT LookupNext(
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer) = 0;
    virtual HRESULT LookupEnd() = 0;

    bool Verify();

private:
    enum Signature {validSignature = 0x1234, nonvalidSignature };

    Signature   m_Signature;

protected:
    AP<WCHAR>   m_pwcsDomainController;
	bool		m_fServerName;
};
inline     CBasicQueryHandle::CBasicQueryHandle(
                IN LPCWSTR  pwcsDomainController,
				IN bool		fServerName
                ) :
				m_Signature(CBasicQueryHandle::validSignature),
				m_fServerName(fServerName)
{
    if ( pwcsDomainController != NULL)
    {
        m_pwcsDomainController = new WCHAR[wcslen(pwcsDomainController) + 1];
        wcscpy(m_pwcsDomainController, pwcsDomainController);
    }
};
inline CBasicQueryHandle::~CBasicQueryHandle()
{
    m_Signature = CBasicQueryHandle::nonvalidSignature;
};

inline bool CBasicQueryHandle::Verify()
{
    return (m_Signature == CBasicQueryHandle::validSignature);
}



//-----------------------------------------------------------------------------------
//
//      CQueryHandle
//
//  This class is suitable for all queries, where locate next is referred 
//  directly to the DS (i.e. no additional translation or checking is required).
//
//-----------------------------------------------------------------------------------
class CQueryHandle : public CBasicQueryHandle
{
public:
    //
    //  CQueryHandle
    //
    //  hCursor             - a cursor returned from Locate Begin operation performed on the DS
    //  dwNoPropsInResult   - number of peroperties to be retrieve in each result
    CQueryHandle( 
               IN  HANDLE	hCursor,
               IN  DWORD	dwNoPropsInResult,
               IN LPCWSTR	pwcsDomainController,
			   IN bool		fServerName
               );

	~CQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    DWORD               m_dwNoPropsInResult;
    CAdQueryHandle      m_hCursor;

};

inline CQueryHandle::CQueryHandle( 
				IN  HANDLE	hCursor,
				IN  DWORD   dwNoPropsInResult,
				IN LPCWSTR  pwcsDomainController,
				IN bool		fServerName
               ):   CBasicQueryHandle(pwcsDomainController, fServerName),
                    m_dwNoPropsInResult( dwNoPropsInResult)
{
    m_hCursor.SetHandle( hCursor);
}

inline CQueryHandle::~CQueryHandle()
{
};

inline HRESULT CQueryHandle::LookupEnd()
{
    delete this;
    return(MQ_OK);
}


//-----------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------
class CRoutingServerQueryHandle : public CBasicQueryHandle
{
public:
    CRoutingServerQueryHandle(
				IN  const MQCOLUMNSET    *pColumns,
				IN  HANDLE hCursor,
				IN  CBasicObjectType *   pObject,
				IN  LPCWSTR pwcsDomainController,
				IN  bool	fServerName
               );

	~CRoutingServerQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    ULONG               m_cCol;
    PROPID *            m_aCol;
    CAdQueryHandle      m_hCursor;
    R<CBasicObjectType> m_pObject;
};


inline
CRoutingServerQueryHandle::CRoutingServerQueryHandle(
    IN  const MQCOLUMNSET    *pColumns,
    IN  HANDLE hCursor,
    IN  CBasicObjectType *    pObject,
	IN LPCWSTR  pwcsDomainController,
	IN bool		fServerName
    ):   CBasicQueryHandle(pwcsDomainController, fServerName),
    m_pObject(SafeAddRef(pObject))
{
        m_aCol = new PROPID[ pColumns->cCol];
        memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
        m_cCol = pColumns->cCol;
        m_hCursor.SetHandle( hCursor);
}


inline 	CRoutingServerQueryHandle::~CRoutingServerQueryHandle()
{
    delete []m_aCol;
}

inline DWORD  CRoutingServerQueryHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CRoutingServerQueryHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}

//-----------------------------------------------------------------------------------
//
//      CUserCertQueryHandle
//
//  This class simulates query functionality on array of user-signed-certificates.
//-----------------------------------------------------------------------------------
class CUserCertQueryHandle : public CBasicQueryHandle
{
public:
    //
    //  CUserCertQueryHandle
    //
    //  pblob - a blob containing user-signed-certificates.
    CUserCertQueryHandle(
                IN const BLOB * pblobNT5User,
                IN const BLOB * pblobNT4User,
				IN LPCWSTR  pwcsDomainController,
				IN bool		fServerName
               );

	~CUserCertQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    DWORD               m_dwNoCertRead;
    BLOB                m_blobNT5UserCert;
    BLOB                m_blobNT4UserCert;

};

inline  CUserCertQueryHandle::CUserCertQueryHandle(
                IN const BLOB * pblobNT5User,
                IN const BLOB * pblobNT4User,
				IN LPCWSTR  pwcsDomainController,
				IN bool		fServerName
               ):   CBasicQueryHandle(pwcsDomainController, fServerName),
                    m_dwNoCertRead(0)
{
    m_blobNT5UserCert.cbSize = pblobNT5User->cbSize;
    if ( m_blobNT5UserCert.cbSize != 0)
    {
        m_blobNT5UserCert.pBlobData = new BYTE[ m_blobNT5UserCert.cbSize];
        memcpy( m_blobNT5UserCert.pBlobData, pblobNT5User->pBlobData, m_blobNT5UserCert.cbSize);
    }
    else
    {
        m_blobNT5UserCert.pBlobData = NULL;
    }
    m_blobNT4UserCert.cbSize = pblobNT4User->cbSize;
    if ( m_blobNT4UserCert.cbSize != 0)
    {
        m_blobNT4UserCert.pBlobData = new BYTE[ m_blobNT4UserCert.cbSize];
        memcpy( m_blobNT4UserCert.pBlobData, pblobNT4User->pBlobData, m_blobNT4UserCert.cbSize);
    }
    else
    {
        m_blobNT4UserCert.pBlobData = NULL;
    }
}

inline CUserCertQueryHandle::~CUserCertQueryHandle()
{
    delete []m_blobNT5UserCert.pBlobData;
    delete []m_blobNT4UserCert.pBlobData;

}
inline HRESULT CUserCertQueryHandle::LookupEnd()
{
    delete this;
    return(MQ_OK);
}

//-------------------------------------------------------------------------
//
//        CConnectorQueryHandle
//
//
//  This query handle is used when locating a foreign
//  machine connectors.
//
//-------------------------------------------------------------------------


class CConnectorQueryHandle : public CBasicQueryHandle
{
public:
    CConnectorQueryHandle( 
				IN  const MQCOLUMNSET *		pColumns,
				IN  CSiteGateList *			pSiteGateList,
				IN LPCWSTR					pwcsDomainController,
				IN bool						fServerName
				);

	~CConnectorQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    ULONG               m_cCol; // number of columns the user asked
    PROPID *            m_aCol; // propids of the columns the user asked
    CAdQueryHandle      m_hCursor;  // DS query handle
    DWORD               m_dwNumGatesReturned;   // index of the last gates returned
    CSiteGateList *     m_pSiteGateList;
};


inline CConnectorQueryHandle::CConnectorQueryHandle(
				IN  const MQCOLUMNSET *    pColumns,
				IN  CSiteGateList *        pSiteGateList,
				IN LPCWSTR  pwcsDomainController,
				IN bool		fServerName
				):   CBasicQueryHandle(pwcsDomainController, fServerName),
				m_pSiteGateList( pSiteGateList),
				m_dwNumGatesReturned(0)

{
        m_aCol = new PROPID[ pColumns->cCol];
        memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
        m_cCol = pColumns->cCol;
}

inline 	CConnectorQueryHandle::~CConnectorQueryHandle()
{
    delete []m_aCol;
    delete m_pSiteGateList;
}

inline DWORD  CConnectorQueryHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CConnectorQueryHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}

//-------------------------------------------------------------------------
//
//        CFilterLinkResultsHandle
//
//
//  This query handle is used when locating site links.
//  It used to filter out site-links that are no longer valid.
//
//-------------------------------------------------------------------------


class CFilterLinkResultsHandle : public CBasicQueryHandle
{
public:
    CFilterLinkResultsHandle(
			IN  HANDLE                 hCursor,
			IN  const MQCOLUMNSET *    pColumns,
			IN LPCWSTR  pwcsDomainController,
			IN bool		fServerName
			);

	~CFilterLinkResultsHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    ULONG               m_cCol; // number of columns the user asked
    PROPID *            m_aCol; // propids of the columns the user asked
    CAdQueryHandle      m_hCursor;
    ULONG               m_indexNeighbor1Column;
    ULONG               m_indexNeighbor2Column;
};


inline CFilterLinkResultsHandle::CFilterLinkResultsHandle(
			IN  HANDLE                 hCursor,
			IN  const MQCOLUMNSET *    pColumns,
			IN LPCWSTR  pwcsDomainController,
			IN bool		fServerName
			):   CBasicQueryHandle(pwcsDomainController, fServerName)
{
    m_aCol = new PROPID[ pColumns->cCol];
    memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
    m_cCol = pColumns->cCol;
    m_hCursor.SetHandle( hCursor);
    m_indexNeighbor1Column = m_cCol;
    m_indexNeighbor2Column = m_cCol;
    
    for ( DWORD i = 0; i < m_cCol; i++)
    {
        if ( m_aCol[i] == PROPID_L_NEIGHBOR1)
        {
            m_indexNeighbor1Column = i;
            continue;
        }
        if ( m_aCol[i] == PROPID_L_NEIGHBOR2)
        {
            m_indexNeighbor2Column = i;
            continue;
        }
    }

}

inline 	CFilterLinkResultsHandle::~CFilterLinkResultsHandle()
{
    delete []m_aCol;
}

inline DWORD  CFilterLinkResultsHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CFilterLinkResultsHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}

//-----------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------

class CSiteQueryHandle : public CBasicQueryHandle
{
public:
    CSiteQueryHandle(
			IN  HANDLE hCursor,
			IN  const MQCOLUMNSET    *pColumns,
			IN LPCWSTR  pwcsDomainController,
			IN bool		fServerName
			);

	~CSiteQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:

    HRESULT FillInOneResponse(
                IN   const GUID *  pguidSiteId,
                IN   LPCWSTR       pwcsSiteName,
                OUT  PROPVARIANT * pbBuffer);


    CAdQueryHandle      m_hCursor;
    ULONG               m_cCol;
    PROPID *            m_aCol;
};


inline CSiteQueryHandle::CSiteQueryHandle(
			IN  HANDLE hCursor,
			IN  const MQCOLUMNSET    *pColumns,
			IN LPCWSTR  pwcsDomainController,
			IN bool		fServerName
			):   CBasicQueryHandle(pwcsDomainController, fServerName)
{
    m_aCol = new PROPID[ pColumns->cCol];
    memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
    m_cCol = pColumns->cCol;

    m_hCursor.SetHandle( hCursor);
}

inline 	CSiteQueryHandle::~CSiteQueryHandle()
{
    delete [] m_aCol;
}

inline DWORD  CSiteQueryHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CSiteQueryHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\siteinfo.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    siteinfo.h

Abstract:

    Site information Class definition

Author:

    ronit hartmann (ronith)


--*/
#ifndef __SITEINFO_H__
#define __SITEINFO_H__


class CSiteGateList
{
    public:
        CSiteGateList();
        ~CSiteGateList();
        HRESULT AddSiteGates(
                    IN const DWORD  num,
                    IN const GUID * pguidGates
                    );
        HRESULT CopySiteGates(
                OUT GUID **      ppguidLinkSiteGates,
                OUT DWORD *      pdwNumLinkSiteGates
                ) const;

        const GUID * GetSiteGate(
                IN  const DWORD  dwIndex
                ) const;

        DWORD GetNumberOfGates() const;

    private:
        DWORD   m_dwNumAllocated;
        DWORD   m_dwNumFilled;
        GUID *  m_pguidGates;

};

inline CSiteGateList::CSiteGateList() :
                      m_dwNumAllocated(0),
                      m_dwNumFilled(0),
                      m_pguidGates(NULL)
{
}

inline DWORD CSiteGateList::GetNumberOfGates() const
{
    return( m_dwNumFilled);
}


inline HRESULT CSiteGateList::AddSiteGates(
                    IN const DWORD  dwNum,
                    IN const GUID * pguidGates
                    )
{
    const DWORD cNumToAllocate = 20;

    //
    //  Not enough space allocated
    //
    if ( m_dwNumFilled + dwNum > m_dwNumAllocated)
    {
        DWORD dwToAllocate = ( m_dwNumFilled + dwNum > m_dwNumAllocated + cNumToAllocate) ?
            m_dwNumFilled + dwNum : m_dwNumAllocated + cNumToAllocate;
        GUID * pguidTmp = new GUID [dwToAllocate];
        //
        //  copy old list if exist
        //
        if ( m_pguidGates)
        {
            memcpy( pguidTmp, m_pguidGates,  m_dwNumFilled * sizeof(GUID));
            delete [] m_pguidGates;
        }
        m_pguidGates = pguidTmp;
        m_dwNumAllocated = dwToAllocate;
    }
    //
    //  add gates
    //
    memcpy( &m_pguidGates[ m_dwNumFilled], pguidGates, dwNum * sizeof(GUID));
    m_dwNumFilled += dwNum;
    return(MQ_OK);
}

inline HRESULT CSiteGateList::CopySiteGates(
                OUT GUID **      ppguidLinkSiteGates,
                OUT DWORD *      pdwNumLinkSiteGates
                ) const
{
    //
    //  allocate the output buffer and copy the site-gates
    //
    if ( m_dwNumFilled)
    {
        *ppguidLinkSiteGates = new GUID[ m_dwNumFilled];
        memcpy( *ppguidLinkSiteGates, m_pguidGates, m_dwNumFilled * sizeof(GUID));
        *pdwNumLinkSiteGates =  m_dwNumFilled;
    }
    return(MQ_OK);
}



inline CSiteGateList::~CSiteGateList()
{
    delete [] m_pguidGates;
}

inline const GUID * CSiteGateList::GetSiteGate(
                IN  const DWORD  dwIndex
                ) const
{
    ASSERT( dwIndex < m_dwNumFilled);
    return( &m_pguidGates[dwIndex]);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\sndnotif.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    notify.cpp

Abstract:

    Implementation of CNotify class.

Author:

    ronith

--*/
#include "ds_stdh.h"
#include "sndnotif.h"
#include "_mqini.h"
#include "adnotify.h"
#include "mqadglbo.h"
#include "pnotify.h"
#include "mqutil.h"
#include "_mqrpc.h"

#include "sndnotif.tmh"

static WCHAR *s_FN=L"mqad/sndnotif";


//
//  Helper class : for freeing RPC bind handle
//
class CAutoFreeRpcBindHandle
{
public:
    CAutoFreeRpcBindHandle(RPC_BINDING_HANDLE h =NULL) { m_h = h; };
    ~CAutoFreeRpcBindHandle() { if (m_h) RpcBindingFree(&m_h); };

public:
    CAutoFreeRpcBindHandle & operator =(RPC_BINDING_HANDLE h) { m_h = h; return(*this); };
    RPC_BINDING_HANDLE * operator &() { return &m_h; };
    operator RPC_BINDING_HANDLE() { return m_h; };

private:
    RPC_BINDING_HANDLE m_h;
};

WCHAR * CSendNotification::m_pwcsStringBinding = NULL;

CSendNotification::CSendNotification()
/*++
    Abstract:
	constructor of CSendNotification object

    Parameters:
	none

    Returns:
	none

--*/
{
}

CSendNotification::~CSendNotification()
/*++
    Abstract:
	destructor of CSendNotification object

    Parameters:
	none

    Returns:
	none

--*/
{
    //
    //  free rpc binding string
    //
    if (m_pwcsStringBinding != NULL)
    {
    	RPC_STATUS status;
        status = RpcStringFree(&m_pwcsStringBinding); 
 
        ASSERT(status == RPC_S_OK); 
    }

}


void CSendNotification::NotifyQM(
        IN  ENotificationEvent ne,
        IN  LPCWSTR     pwcsDomainCOntroller,
        IN  const GUID* pguidDestQM,
        IN  const GUID* pguidObject
        )
/*++
    Abstract:
	Inform a the local QM about a create/delete or set.
    It is the responsibility of the local QM to verify
    if the changed object is local or not, and to act accordingly

    Parameters:
    ENotificationEvent ne - type of notification
    LPCWSTR     pwcsDomainCOntroller - DC against which the operation was performed
	const GUID* pguidDestQM - the owner QM id
    const GUID* pguidQueue  - the queue id

    Returns:
	none

--*/
{
    RPC_BINDING_HANDLE h;
    InitRPC(&h);
    if (h == NULL)
    {
        //
        //  Notification failed, since the caller operation
        //  succeeded, no error is returned
        //
        return;
    }
    CAutoFreeRpcBindHandle hBind(h); 

    CallNotifyQM(
                hBind,
                ne,
                pwcsDomainCOntroller,
                pguidDestQM,
                pguidObject
                );

            
}


void CSendNotification::InitRPC(
        OUT RPC_BINDING_HANDLE * ph
        )
/*++
    Abstract:
    The routine prepares a binding string and binds RPC

    Parameters:
    RPC_BINDING_HANDLE * ph - rpc binding handle

    Returns:
	none

--*/
{
    *ph = NULL;
    RPC_STATUS status = RPC_S_OK;
 
    if (m_pwcsStringBinding == NULL)
    {
        AP<WCHAR> QmLocalEp;
        READ_REG_STRING(wzEndpoint, RPC_LOCAL_EP_REGNAME, RPC_LOCAL_EP);
        ComposeLocalEndPoint(wzEndpoint, &QmLocalEp);

	    status = RpcStringBindingCompose(
				    NULL,					//ObjUuid
                    RPC_LOCAL_PROTOCOL,				
                    NULL,					//NetworkAddr
                    QmLocalEp,			
                    NULL,					//Options
                    &m_pwcsStringBinding
                    );	

        if (status != RPC_S_OK) 
        {
            DBGMSG((DBGMOD_ADS, DBGLVL_TRACE, TEXT("CNotification::RpcStringBindingCompose()=%lx"), status));
            return;
        }
    }

    status = RpcBindingFromStringBinding(
				m_pwcsStringBinding,
                ph
                );
 
    if (status != RPC_S_OK) 
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_TRACE, TEXT("CNotification::RpcBindingFromStringBinding()=%lx"), status));
        return;
    }
}



void CSendNotification::CallNotifyQM(
        IN  RPC_BINDING_HANDLE  h,
        IN  ENotificationEvent  ne,
        IN  LPCWSTR     pwcsDomainCOntroller,
        IN  const GUID* pguidDestQM,
        IN  const GUID* pguidObject
        )
/*++
    Abstract:
    Perform the RPC call


    Parameters:
    RPC_BINDING_HANDLE h - rpc binding handle
    LPCWSTR     pwcsDomainCOntroller - DC against which the operation was performed
	const GUID* pguidDestQM - the owner QM id
    const GUID* pguidObject - the id of the "changed" object

    Returns:
	none

--*/
{
    RpcTryExcept
    {
        R_NotifyQM(
                h,
                ne,
                pwcsDomainCOntroller,
                pguidDestQM,
                pguidObject
                );
    }
    RpcExcept(1)
    {
        RPC_STATUS rpc_stat = RpcExceptionCode(); 
        LogRPCStatus( rpc_stat, s_FN, 20);
    }
    RpcEndExcept
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\queueobj.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    queueobj.cpp

Abstract:

    Implementation of CQueueObject class.

Author:

    ronith

--*/
#include "ds_stdh.h"
#include "baseobj.h"
#include "mqattrib.h"
#include "mqadglbo.h"
#include "mqadp.h"
#include "dsutils.h"
#include "mqsec.h"
#include "sndnotif.h"

#include "queueobj.tmh"

static WCHAR *s_FN=L"mqad/queueobj";

DWORD CQueueObject::m_dwCategoryLength = 0;
AP<WCHAR> CQueueObject::m_pwcsCategory = NULL;


CQueueObject::CQueueObject(
                    LPCWSTR         pwcsPathName,
                    const GUID *    pguidObject,
                    LPCWSTR         pwcsDomainController,
					bool		    fServerName
                    ) : CBasicObjectType(
								pwcsPathName,
								pguidObject,
								pwcsDomainController,
								fServerName
								)
/*++
    Abstract:
	constructor of queue object

    Parameters:
    LPCWSTR       pwcsPathName - the object MSMQ name
    const GUID *  pguidObject  - the object unique id
    LPCWSTR       pwcsDomainController - the DC name against
	                             which all AD access should be performed
    bool		   fServerName - flag that indicate if the pwcsDomainController
							     string is a server name
    Returns:
	none

--*/
{
    //
    //  don't assume that the object can be found on DC
    //
    m_fFoundInDC = false;
    //
    //  Keep an indication that never tried to look for
    //  the object in AD ( and therefore don't really know if it can be found
    //  in DC or not)
    //
    m_fTriedToFindObject = false;
}

CQueueObject::~CQueueObject()
/*++
    Abstract:
	destructor of site object

    Parameters:
	none

    Returns:
	none
--*/
{
	//
	// nothing to do ( everything is released with automatic pointers
	//
}

HRESULT CQueueObject::ComposeObjectDN()
/*++
    Abstract:
	Composed distinguished name of the queue object

    Parameters:
	none

    Returns:
	none
--*/
{
    if (m_pwcsDN != NULL)
    {
        return MQ_OK;
    }
    ASSERT(m_pwcsPathName != NULL);
    //
    //  Path name format is machine1\queue1.
    //  Split it into machine name and queue name
    //
    AP<WCHAR> pwcsMachineName;
    HRESULT hr;
    hr = SplitAndFilterQueueName(
                      m_pwcsPathName,
                      &pwcsMachineName,
                      &m_pwcsQueueName
                      );
    ASSERT( hr == MQ_OK);

    CMqConfigurationObject object(pwcsMachineName, NULL, m_pwcsDomainController, m_fServerName);

    hr = object.ComposeObjectDN();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }
    //
    //  set where the object was found according to where
    //  msmq-configuration object was found.
    //
    m_fFoundInDC = object.ToAccessDC();
    m_fTriedToFindObject = true;

    DWORD dwConfigurationLen = wcslen(object.GetObjectDN());

    //
    //  Does the queue-name exceeds the limit ?
    //
    DWORD len = wcslen(m_pwcsQueueName);

    if ( len == x_PrefixQueueNameLength + 1)
    {
        //
        //  Special case : we cannot differntiate
        //  if the original queue name was 64, or if this is
        //  the morphed queue name.
        //

        DWORD Length =
                x_CnPrefixLen +                // "CN="
                len +                          // "pwcsQueueName"
                1 +                            //","
                dwConfigurationLen +
                1;                             // '\0'
        m_pwcsDN = new WCHAR[Length];
        DWORD dw = swprintf(
        m_pwcsDN,
        L"%s%s,%s",
        x_CnPrefix,
        m_pwcsQueueName,
        object.GetObjectDN()
        );
        DBG_USED(dw);
		ASSERT( dw < Length);
        hr = g_AD.DoesObjectExists(
                    adpDomainController,
                    e_RootDSE,
                    m_pwcsDN
                    );
        if (SUCCEEDED(hr))
        {
            return(hr);
        }
        delete []m_pwcsDN.detach();

    }
    if (len > x_PrefixQueueNameLength )
    {
        //
        //  Queue name was splitted to two attributes
        //
        //  Calculate the prefix part ( ASSUMMING unique
        //  hash function)
        //
        DWORD dwHash = CalHashKey(m_pwcsQueueName);
        //
        //  Over-write the buffer
        _snwprintf(
        m_pwcsQueueName+( x_PrefixQueueNameLength + 1 - x_SplitQNameIdLength),
        x_SplitQNameIdLength,
        L"-%08x",
        dwHash
        );

        m_pwcsQueueName[x_PrefixQueueNameLength + 1 ] = '\0';

    }

    //
    //  concatenate  queue name
    //
    DWORD Length =
            x_CnPrefixLen +                // "CN="
            wcslen(m_pwcsQueueName) +      // "pwcsQueueName"
            1 +                            //","
            dwConfigurationLen +
            1;                             // '\0'
    m_pwcsDN = new WCHAR[Length];
    DWORD dw = _snwprintf(
            m_pwcsDN,
            Length,
            L"%s%s,%s",
            x_CnPrefix,
            m_pwcsQueueName,
            object.GetObjectDN()
            );
    m_pwcsDN[ Length-1 ] = 0 ;

    if (dw != (Length-1))
    {
		TrERROR(mqad, "failed to compose Queue DN, len- 0x%lx, dw- 0x%lx", Length, dw) ;
        return MQ_ERROR ;
    }

    return MQ_OK;
}

HRESULT CQueueObject::ComposeFatherDN()
/*++
    Abstract:
	Composed distinguished name of the parent of queue object

    Parameters:
	none

    Returns:
	none
--*/
{
    if (m_pwcsParentDN != NULL)
    {
        return MQ_OK;
    }

    ASSERT(m_pwcsPathName != NULL);
    //
    //  Path name format is machine1\queue1.
    //  Split it into machine name and queue name
    //
    AP<WCHAR> pwcsMachineName;
    AP<WCHAR> pwcsQueueName;    // since we don't perform all calculations on queue name-> don't keep it
    HRESULT hr;
    hr = SplitAndFilterQueueName(
                      m_pwcsPathName,
                      &pwcsMachineName,
                      &pwcsQueueName
                      );
    ASSERT( hr == MQ_OK);
    //
	//	compose the distinguished name of the msmq-configuration
	//  object from the machine name
	//
    CMqConfigurationObject object(pwcsMachineName, NULL, m_pwcsDomainController, m_fServerName);

    hr = object.ComposeObjectDN();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }
    //
    //  set where the object was found according to where
    //  msmq-configuration object was found.
    //
    m_fFoundInDC = object.ToAccessDC();
    m_fTriedToFindObject = true;

    DWORD dwConfigurationLen = wcslen(object.GetObjectDN());

    m_pwcsParentDN = new WCHAR[dwConfigurationLen + 1];
    wcscpy( m_pwcsParentDN, object.GetObjectDN());
    return MQ_OK;
}

LPCWSTR CQueueObject::GetRelativeDN()
/*++
    Abstract:
	return the RDN of the queue object

    Parameters:
	none

    Returns:
	LPCWSTR queue RDN
--*/
{
    if (m_pwcsQueueName != NULL)
    {
        return m_pwcsQueueName;
    }

    AP<WCHAR> pwcsMachineName;
    AP<WCHAR> pwcsQueueName;
    HRESULT hr;
    hr = SplitAndFilterQueueName(
                      m_pwcsPathName,
                      &pwcsMachineName,
                      &pwcsQueueName
                      );
    ASSERT( hr == MQ_OK);

    //
    //  Is the queue-name within the size limit of CN
    //
    DWORD len = wcslen(pwcsQueueName);

    if ( len > x_PrefixQueueNameLength)
    {
        //
        //  Split the queue name
        //
        m_pwcsQueueName = new WCHAR[ x_PrefixQueueNameLength + 1 + 1];
        DWORD dwSuffixLength =  len - ( x_PrefixQueueNameLength + 1 - x_SplitQNameIdLength);
        m_pwcsQueueNameSuffix = new WCHAR[ dwSuffixLength + 1];
        memcpy( m_pwcsQueueName, pwcsQueueName, (x_PrefixQueueNameLength + 1 - x_SplitQNameIdLength) * sizeof(WCHAR));
        DWORD dwHash = CalHashKey(pwcsQueueName);

        _snwprintf(
        m_pwcsQueueName+( x_PrefixQueueNameLength + 1 - x_SplitQNameIdLength),
        x_SplitQNameIdLength,
        L"-%08x",
        dwHash
        );

        m_pwcsQueueName[x_PrefixQueueNameLength + 1 ] = '\0';
        memcpy( m_pwcsQueueNameSuffix , (pwcsQueueName + x_PrefixQueueNameLength + 1 - x_SplitQNameIdLength), dwSuffixLength * sizeof(WCHAR));
        m_pwcsQueueNameSuffix[ dwSuffixLength] = '\0';


    }
    else
    {
        m_pwcsQueueName = pwcsQueueName.detach();
    }

    return m_pwcsQueueName;


}


DS_CONTEXT CQueueObject::GetADContext() const
/*++
    Abstract:
	Returns the AD context where queue object should be looked for

    Parameters:
	none

    Returns:
	DS_CONTEXT
--*/
{
    return e_RootDSE;
}

bool CQueueObject::ToAccessDC() const
/*++
    Abstract:
	returns whether to look for the object in DC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	true or false
--*/
{
    if (!m_fTriedToFindObject)
    {
        return true;
    }
    return m_fFoundInDC;
}

bool CQueueObject::ToAccessGC() const
/*++
    Abstract:
	returns whether to look for the object in GC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	true or false
--*/
{
    if (!m_fTriedToFindObject)
    {
        return true;
    }
    return !m_fFoundInDC;
}

void CQueueObject::ObjectWasFoundOnDC()
/*++
    Abstract:
	The object was found on DC, set indication not to
    look for it on GC


    Parameters:
	none

    Returns:
	none
--*/
{
    m_fTriedToFindObject = true;
    m_fFoundInDC = true;
}


LPCWSTR CQueueObject::GetObjectCategory()
/*++
    Abstract:
	prepares and retruns the object category string

    Parameters:
	none

    Returns:
	LPCWSTR object category string
--*/
{
    if (CQueueObject::m_pwcsCategory == NULL)
    {
        DWORD len = wcslen(g_pwcsSchemaContainer) + wcslen(x_QueueCategoryName) + 2;

        AP<WCHAR> pwcsCategory = new WCHAR[len];
        DWORD dw = swprintf(
             pwcsCategory,
             L"%s,%s",
             x_QueueCategoryName,
             g_pwcsSchemaContainer
            );
        DBG_USED(dw);
		ASSERT( dw < len);

        if (NULL == InterlockedCompareExchangePointer(
                              &CQueueObject::m_pwcsCategory.ref_unsafe(),
                              pwcsCategory.get(),
                              NULL
                              ))
        {
            pwcsCategory.detach();
            CQueueObject::m_dwCategoryLength = len;
        }
    }
    return CQueueObject::m_pwcsCategory;
}

DWORD CQueueObject::GetObjectCategoryLength()
/*++
    Abstract:
	prepares and retruns the length object category string

    Parameters:
	none

    Returns:
	DWORD object category string length
--*/
{
	//
	//	call GetObjectCategory in order to initailaze category string
	//	and length
	//
	GetObjectCategory();

    return CQueueObject::m_dwCategoryLength;
}

AD_OBJECT CQueueObject::GetObjectType() const
/*++
    Abstract:
	returns the object type

    Parameters:
	none

    Returns:
	AD_OBJECT
--*/
{
    return eQUEUE;
}

LPCWSTR CQueueObject::GetClass() const
/*++
    Abstract:
	returns a string represinting the object class in AD

    Parameters:
	none

    Returns:
	LPCWSTR object class string
--*/
{
    return MSMQ_QUEUE_CLASS_NAME;
}

DWORD CQueueObject::GetMsmq1ObjType() const
/*++
    Abstract:
	returns the object type in MSMQ 1.0 terms

    Parameters:
	none

    Returns:
	DWORD
--*/
{
    return MQDS_QUEUE;
}

HRESULT CQueueObject::SplitAndFilterQueueName(
                IN  LPCWSTR             pwcsPathName,
                OUT LPWSTR *            ppwcsMachineName,
                OUT LPWSTR *            ppwcsQueueName
                )
/*++
    Abstract:
	splits the machine1/queue1 msmq name into two strings:
	queue andmachine

    Parameters:
    LPCWSTR    pwcsPathName - msmq pathname of queue
    LPWSTR *   ppwcsMachineName - machine portion of the pathname
    LPWSTR *   ppwcsQueueName - queue portion of the pathname

    Returns:
	HRESULT
--*/
{
    DWORD dwLen = lstrlen( pwcsPathName);
    LPCWSTR pChar= pwcsPathName + dwLen;


    //
    //  Skip the queue name
    //
    for ( DWORD i = dwLen ; i  ; i--, pChar--)
    {
        if (*pChar == PN_DELIMITER_C)
        {
            break;
        }
    }
    ASSERT(i );

    AP<WCHAR> pwcsMachineName = new WCHAR [i + 1];

    memcpy( pwcsMachineName, pwcsPathName, sizeof(WCHAR)* i);
    pwcsMachineName[i] = '\0';

    AP<WCHAR> pwcsQueueName = FilterSpecialCharacters((pwcsPathName + i + 1), dwLen - i - 1);


    *ppwcsMachineName = pwcsMachineName.detach();
    *ppwcsQueueName = pwcsQueueName.detach();
    return(MQ_OK);
}


// this is the CRC table for the 5213724743 (0x136C32047) polynomial, seed(p/2)=9B619023
static const unsigned long CRCTable[256] = {
 0x00000000, 0x82E0FE45, 0x3302DCCD, 0xB1E22288, 0x6605B99A,	//   0 -   4
 0xE4E547DF, 0x55076557, 0xD7E79B12, 0xCC0B7334, 0x4EEB8D71,	//   5 -   9
 0xFF09AFF9, 0x7DE951BC, 0xAA0ECAAE, 0x28EE34EB, 0x990C1663,	//  10 -  14
 0x1BECE826, 0xAED5C62F, 0x2C35386A, 0x9DD71AE2, 0x1F37E4A7,	//  15 -  19
 0xC8D07FB5, 0x4A3081F0, 0xFBD2A378, 0x79325D3D, 0x62DEB51B,	//  20 -  24
 0xE03E4B5E, 0x51DC69D6, 0xD33C9793, 0x04DB0C81, 0x863BF2C4,	//  25 -  29
 0x37D9D04C, 0xB5392E09, 0x6B68AC19, 0xE988525C, 0x586A70D4,	//  30 -  34
 0xDA8A8E91, 0x0D6D1583, 0x8F8DEBC6, 0x3E6FC94E, 0xBC8F370B,	//  35 -  39
 0xA763DF2D, 0x25832168, 0x946103E0, 0x1681FDA5, 0xC16666B7,	//  40 -  44
 0x438698F2, 0xF264BA7A, 0x7084443F, 0xC5BD6A36, 0x475D9473,	//  45 -  49
 0xF6BFB6FB, 0x745F48BE, 0xA3B8D3AC, 0x21582DE9, 0x90BA0F61,	//  50 -  54
 0x125AF124, 0x09B61902, 0x8B56E747, 0x3AB4C5CF, 0xB8543B8A,	//  55 -  59
 0x6FB3A098, 0xED535EDD, 0x5CB17C55, 0xDE518210, 0xD6D15832,	//  60 -  64
 0x5431A677, 0xE5D384FF, 0x67337ABA, 0xB0D4E1A8, 0x32341FED,	//  65 -  69
 0x83D63D65, 0x0136C320, 0x1ADA2B06, 0x983AD543, 0x29D8F7CB,	//  70 -  74
 0xAB38098E, 0x7CDF929C, 0xFE3F6CD9, 0x4FDD4E51, 0xCD3DB014,	//  75 -  79
 0x78049E1D, 0xFAE46058, 0x4B0642D0, 0xC9E6BC95, 0x1E012787,	//  80 -  84
 0x9CE1D9C2, 0x2D03FB4A, 0xAFE3050F, 0xB40FED29, 0x36EF136C,	//  85 -  89
 0x870D31E4, 0x05EDCFA1, 0xD20A54B3, 0x50EAAAF6, 0xE108887E,	//  90 -  94
 0x63E8763B, 0xBDB9F42B, 0x3F590A6E, 0x8EBB28E6, 0x0C5BD6A3,	//  95 -  99
 0xDBBC4DB1, 0x595CB3F4, 0xE8BE917C, 0x6A5E6F39, 0x71B2871F,	// 100 - 104
 0xF352795A, 0x42B05BD2, 0xC050A597, 0x17B73E85, 0x9557C0C0,	// 105 - 109
 0x24B5E248, 0xA6551C0D, 0x136C3204, 0x918CCC41, 0x206EEEC9,	// 110 - 114
 0xA28E108C, 0x75698B9E, 0xF78975DB, 0x466B5753, 0xC48BA916,	// 115 - 119
 0xDF674130, 0x5D87BF75, 0xEC659DFD, 0x6E8563B8, 0xB962F8AA,	// 120 - 124
 0x3B8206EF, 0x8A602467, 0x0880DA22, 0x9B619023, 0x19816E66,	// 125 - 129
 0xA8634CEE, 0x2A83B2AB, 0xFD6429B9, 0x7F84D7FC, 0xCE66F574,	// 130 - 134
 0x4C860B31, 0x576AE317, 0xD58A1D52, 0x64683FDA, 0xE688C19F,	// 135 - 139
 0x316F5A8D, 0xB38FA4C8, 0x026D8640, 0x808D7805, 0x35B4560C,	// 140 - 144
 0xB754A849, 0x06B68AC1, 0x84567484, 0x53B1EF96, 0xD15111D3,	// 145 - 149
 0x60B3335B, 0xE253CD1E, 0xF9BF2538, 0x7B5FDB7D, 0xCABDF9F5,	// 150 - 154
 0x485D07B0, 0x9FBA9CA2, 0x1D5A62E7, 0xACB8406F, 0x2E58BE2A,	// 155 - 159
 0xF0093C3A, 0x72E9C27F, 0xC30BE0F7, 0x41EB1EB2, 0x960C85A0,	// 160 - 164
 0x14EC7BE5, 0xA50E596D, 0x27EEA728, 0x3C024F0E, 0xBEE2B14B,	// 165 - 169
 0x0F0093C3, 0x8DE06D86, 0x5A07F694, 0xD8E708D1, 0x69052A59,	// 170 - 174
 0xEBE5D41C, 0x5EDCFA15, 0xDC3C0450, 0x6DDE26D8, 0xEF3ED89D,	// 175 - 179
 0x38D9438F, 0xBA39BDCA, 0x0BDB9F42, 0x893B6107, 0x92D78921,	// 180 - 184
 0x10377764, 0xA1D555EC, 0x2335ABA9, 0xF4D230BB, 0x7632CEFE,	// 185 - 189
 0xC7D0EC76, 0x45301233, 0x4DB0C811, 0xCF503654, 0x7EB214DC,	// 190 - 194
 0xFC52EA99, 0x2BB5718B, 0xA9558FCE, 0x18B7AD46, 0x9A575303,	// 195 - 199
 0x81BBBB25, 0x035B4560, 0xB2B967E8, 0x305999AD, 0xE7BE02BF,	// 200 - 204
 0x655EFCFA, 0xD4BCDE72, 0x565C2037, 0xE3650E3E, 0x6185F07B,	// 205 - 209
 0xD067D2F3, 0x52872CB6, 0x8560B7A4, 0x078049E1, 0xB6626B69,	// 210 - 214
 0x3482952C, 0x2F6E7D0A, 0xAD8E834F, 0x1C6CA1C7, 0x9E8C5F82,	// 215 - 219
 0x496BC490, 0xCB8B3AD5, 0x7A69185D, 0xF889E618, 0x26D86408,	// 220 - 224
 0xA4389A4D, 0x15DAB8C5, 0x973A4680, 0x40DDDD92, 0xC23D23D7,	// 225 - 229
 0x73DF015F, 0xF13FFF1A, 0xEAD3173C, 0x6833E979, 0xD9D1CBF1,	// 230 - 234
 0x5B3135B4, 0x8CD6AEA6, 0x0E3650E3, 0xBFD4726B, 0x3D348C2E,	// 235 - 239
 0x880DA227, 0x0AED5C62, 0xBB0F7EEA, 0x39EF80AF, 0xEE081BBD,	// 240 - 244
 0x6CE8E5F8, 0xDD0AC770, 0x5FEA3935, 0x4406D113, 0xC6E62F56,	// 245 - 249
 0x77040DDE, 0xF5E4F39B, 0x22036889, 0xA0E396CC, 0x1101B444,	// 250 - 254
 0x93E14A01 };

DWORD CQueueObject::CalHashKey( IN LPCWSTR pwcsPathName)
/*++

Routine Description:
    Calculates a hash

Arguments:
    pwcsPathName - the string on which the hash is calculated

Return Value:
    hash value.

--*/
{
	unsigned long dwCrc = 0;
    WCHAR wcsLowChar[2];
    wcsLowChar[1] = '\0';
	unsigned char * pucLowCharBuf = ( unsigned char *)wcsLowChar;

	while( *pwcsPathName != '\0' )
	{
		wcsLowChar[0] = *pwcsPathName++;
		CharLower( wcsLowChar );	// convert one char to lowercase

		// compute the CRC on hi and lo bytes
		dwCrc = (dwCrc >> 8) ^ CRCTable[ (unsigned char)dwCrc ^ pucLowCharBuf[1] ];
		dwCrc = (dwCrc >> 8) ^ CRCTable[ (unsigned char)dwCrc ^ pucLowCharBuf[0] ];
	}

    return( dwCrc );
}

HRESULT CQueueObject::DeleteObject(
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
    MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
                                   )
/*++
    Abstract:
	This routine deletes a queue object.

    Parameters:
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - infomation about the object
    MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - information about the object's parent

    Returns:
	HRESULT
--*/
{
    HRESULT hr;

    if (m_pwcsPathName != NULL)
    {
        hr = ComposeObjectDN();
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 30);
        }
    }
    //
	//	delete operation should be performed against a DC
	//
    hr = g_AD.DeleteObject(
            adpDomainController,
            this,
            GetObjectDN(),
            GetObjectGuid(),
            pObjInfoRequest,
            pParentInfoRequest);

    return LogHR(hr, s_FN, 40);
}

void CQueueObject::PrepareObjectInfoRequest(
              MQDS_OBJ_INFO_REQUEST** ppObjInfoRequest
              ) const
/*++
    Abstract:
	Prepares a list of properties that should be retrieved from
	AD while creating the object ( for notification or returning
	the object GUID).

    Parameters:
	OUT  MQDS_OBJ_INFO_REQUEST** ppObjInfoRequest

    Returns:
	none
--*/
{
    //
    //  Override the default routine, for queue returning
    //  of the created object id is supported
    //

    P<MQDS_OBJ_INFO_REQUEST> pObjectInfoRequest = new MQDS_OBJ_INFO_REQUEST;
    CAutoCleanPropvarArray cCleanObjectPropvars;


    static PROPID sQueueGuidProps[] = {PROPID_Q_INSTANCE};
    pObjectInfoRequest->cProps = ARRAY_SIZE(sQueueGuidProps);
    pObjectInfoRequest->pPropIDs = sQueueGuidProps;
    pObjectInfoRequest->pPropVars =
       cCleanObjectPropvars.allocClean(ARRAY_SIZE(sQueueGuidProps));

    cCleanObjectPropvars.detach();
    *ppObjInfoRequest = pObjectInfoRequest.detach();
}

void CQueueObject::PrepareObjectParentRequest(
                          MQDS_OBJ_INFO_REQUEST** ppParentInfoRequest) const
/*++
    Abstract:
	Prepares a list of properties that should be retrieved from
	AD while creating the object regarding its parent (for
	notification)

    Parameters:
	OUT  MQDS_OBJ_INFO_REQUEST** ppParentInfoRequest

    Returns:
	none
--*/
{
    P<MQDS_OBJ_INFO_REQUEST> pParentInfoRequest = new MQDS_OBJ_INFO_REQUEST;
    CAutoCleanPropvarArray cCleanObjectPropvars;


    static PROPID sQmProps[] = {PROPID_QM_MACHINE_ID,PROPID_QM_FOREIGN};
    pParentInfoRequest->cProps = ARRAY_SIZE(sQmProps);
    pParentInfoRequest->pPropIDs = sQmProps;
    pParentInfoRequest->pPropVars =
       cCleanObjectPropvars.allocClean(ARRAY_SIZE(sQmProps));

    cCleanObjectPropvars.detach();
    *ppParentInfoRequest = pParentInfoRequest.detach();
}

HRESULT CQueueObject::RetreiveObjectIdFromNotificationInfo(
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            OUT GUID*                         pObjGuid
            ) const
/*++
    Abstract:
	This  routine, for gets the object guid from
	the MQDS_OBJ_INFO_REQUEST

    Parameters:
    const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
    OUT GUID*                         pObjGuid

    Returns:
--*/
{
    ASSERT(pObjectInfoRequest->pPropIDs[0] == PROPID_Q_INSTANCE);

    //
    // bail if info requests failed
    //
    if (FAILED(pObjectInfoRequest->hrStatus))
    {
        LogHR(pObjectInfoRequest->hrStatus, s_FN, 50);
        return MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }
    *pObjGuid = *pObjectInfoRequest->pPropVars[0].puuid;
    return MQ_OK;
}

HRESULT CQueueObject::VerifyAndAddProps(
            IN  const DWORD            cp,
            IN  const PROPID *         aProp,
            IN  const MQPROPVARIANT *  apVar,
            IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
            OUT DWORD*                 pcpNew,
            OUT PROPID**               ppPropNew,
            OUT MQPROPVARIANT**        ppVarNew
            )
/*++
    Abstract:
	verifies queue properties and add default SD and
	queue name suffex ( if needed)

    Parameters:
    const DWORD            cp - number of props
    const PROPID *         aProp - props ids
    const MQPROPVARIANT *  apVar - properties value
    PSECURITY_DESCRIPTOR   pSecurityDescriptor - SD for the object
    DWORD*                 pcpNew - new number of props
    PROPID**               ppPropNew - new prop ids
    OMQPROPVARIANT**       ppVarNew - new properties values

    Returns:
	HRESULT
--*/
{
    //
    // Security property should never be supplied as a property
    //
    PROPID pSecId = GetObjectSecurityPropid();
    for ( DWORD i = 0; i < cp ; i++ )
    {
        if (pSecId == aProp[i])
        {
            ASSERT(0) ;
            return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 41);
        }
    }
    //
    //  add default security and queue name ext ( if needed)
    //

    AP<PROPVARIANT> pAllPropvariants;
    AP<PROPID> pAllPropids;
    ASSERT( cp > 0);
    DWORD cpNew = cp + 3;
    DWORD next = cp;
    //
    //  Just copy the caller supplied properties as is
    //
    if ( cp > 0)
    {
        pAllPropvariants = new PROPVARIANT[cpNew];
        pAllPropids = new PROPID[cpNew];
        memcpy (pAllPropvariants, apVar, sizeof(PROPVARIANT) * cp);
        memcpy (pAllPropids, aProp, sizeof(PROPID) * cp);
    }
    //
    //  add default security
    //
    HRESULT hr;
    hr = MQSec_GetDefaultSecDescriptor( MQDS_QUEUE,
                                   (VOID **)&m_pDefaultSecurityDescriptor,
                                   FALSE,   //fImpersonate
                                   pSecurityDescriptor,
                                   (OWNER_SECURITY_INFORMATION |
                                    GROUP_SECURITY_INFORMATION),      // seInfoToRemove
                                   e_UseDefaultDacl ) ;
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 60);
        return MQ_ERROR_ACCESS_DENIED;
    }
    pAllPropvariants[ next ].blob.cbSize =
                       GetSecurityDescriptorLength( m_pDefaultSecurityDescriptor.get() );
    pAllPropvariants[ next ].blob.pBlobData =
                                     (unsigned char *) m_pDefaultSecurityDescriptor.get();
    pAllPropvariants[ next ].vt = VT_BLOB;
    pAllPropids[ next ] = PROPID_Q_SECURITY;
    next++;

    //
    //  specify that the SD contains only DACL info
    //
    pAllPropvariants[ next ].ulVal =  DACL_SECURITY_INFORMATION;
    pAllPropvariants[ next ].vt = VT_UI4;
    pAllPropids[ next ] = PROPID_Q_SECURITY_INFORMATION;
    next++;

    //
    //  Check and see if there is a need to split queue name, and if
    //  yes and the queue-name-suffix
    //
    GetRelativeDN();
    if ( m_pwcsQueueNameSuffix != NULL)
    {
        pAllPropids[ next] =  PROPID_Q_NAME_SUFFIX;
        pAllPropvariants[ next].vt = VT_LPWSTR;
        pAllPropvariants[ next].pwszVal = m_pwcsQueueNameSuffix;
        next++;
    }
    ASSERT(cpNew >= next);

    *pcpNew = next;
    *ppPropNew = pAllPropids.detach();
    *ppVarNew = pAllPropvariants.detach();
    return MQ_OK;

}


HRESULT CQueueObject::SetObjectProperties(
            IN DWORD                  cp,
            IN const PROPID          *aProp,
            IN const MQPROPVARIANT   *apVar,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            )
/*++
    Abstract:
	This is the default routine for setting object properties
	in AD

    Parameters:
    DWORD                  cp - number of properties to set
    const PROPID *         aProp - the properties ids
    const MQPROPVARIANT*   apVar- properties value
    OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - info to retrieve about the object
    OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - info to retrieveabout the object's parent

    Returns:
	HRESULT
--*/
{
    HRESULT hr;
    if (m_pwcsPathName == NULL)
    {
        //
        // Find queue path name.
        // We cannot set queue properties using GUID binding because it will
        // fail cross domains. See Windows bug 536738.
        // So first find queue path, then set guid to GUID_NULL.
        //
        PROPVARIANT  propVar ;
        propVar.vt = VT_NULL ;
        propVar.pwszVal = NULL ;
        PROPID propId =  PROPID_Q_PATHNAME ;

        hr = GetObjectProperties( 1,
                                 &propId,
                                 &propVar ) ;
        if (FAILED(hr))
        {
		    TrERROR(mqad, "failed to get queue path, hr- 0x%lx", hr) ;

            return LogHR(hr, s_FN, 2040);
        }

        AP<WCHAR> pClean = propVar.pwszVal ;
        m_pwcsPathName = newwcs(propVar.pwszVal) ;

        m_guidObject = GUID_NULL;
    }

    hr = ComposeObjectDN();
    if (FAILED(hr))
    {
        TrERROR(mqad, "failed to compose full path name, hr- 0x%lx", hr) ;

        return LogHR(hr, s_FN, 2050);
    }

    hr = g_AD.SetObjectProperties(
                    adpDomainController,
                    this,
                    cp,
                    aProp,
                    apVar,
                    pObjInfoRequest,
                    pParentInfoRequest
                    );


    return LogHR(hr, s_FN, 2060);
}


void CQueueObject::CreateNotification(
            IN LPCWSTR                        pwcsDomainController,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest
            ) const
/*++
    Abstract:
	Notify QM about an object create.
    The QM should verify if the object is local or not

    Parameters:
    LPCWSTR                        pwcsDomainController - DC agains which operation was performed
    const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest - information about the object
    const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest - information about object parent

    Returns:
	void
--*/
{
    //
    //  make sure that we got the required information for sending
    //  notification. In case we don't, there is nothing to do
    //
    if (FAILED(pObjectInfoRequest->hrStatus))
    {
        LogHR(pObjectInfoRequest->hrStatus, s_FN, 170);
        return;
    }
    if (FAILED(pObjectParentInfoRequest->hrStatus))
    {
        LogHR(pObjectParentInfoRequest->hrStatus, s_FN, 180);
        return;
    }

    ASSERT(pObjectParentInfoRequest->pPropIDs[1] == PROPID_QM_FOREIGN);

    //
    //  Verify if the queue belongs to foreign QM
    //
    if (pObjectParentInfoRequest->pPropVars[1].bVal > 0)
    {
        //
        //  notifications are not sent to foreign computers
        //
        return;
    }
    ASSERT(pObjectParentInfoRequest->pPropIDs[0] == PROPID_QM_MACHINE_ID);

    ASSERT(pObjectInfoRequest->pPropIDs[0] == PROPID_Q_INSTANCE);

    g_Notification.NotifyQM(
        neCreateQueue,
        pwcsDomainController,
        pObjectParentInfoRequest->pPropVars[0].puuid,
        pObjectInfoRequest->pPropVars[0].puuid
        );
    return;
}

void CQueueObject::ChangeNotification(
            IN LPCWSTR                        pwcsDomainController,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest
            ) const
/*++
    Abstract:
	Notify QM about a queue creation or update.
    The QM should verify if the queue belongs to the local QM.

    Parameters:
    LPCWSTR                        pwcsDomainController - DC agains which operation was performed
    const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest - information about the queue
    const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest - information about the QM

    Returns:
	void
--*/
{
    //
    //  make sure that we got the required information for sending
    //  notification. In case we don't, there is nothing to do
    //
    if (FAILED(pObjectInfoRequest->hrStatus))
    {
        LogHR(pObjectInfoRequest->hrStatus, s_FN, 150);
        return;
    }
    if (FAILED(pObjectParentInfoRequest->hrStatus))
    {
        LogHR(pObjectParentInfoRequest->hrStatus, s_FN, 160);
        return;
    }

    ASSERT(pObjectParentInfoRequest->pPropIDs[1] == PROPID_QM_FOREIGN);

    //
    //  Verify if the queue belongs to foreign QM
    //
    if (pObjectParentInfoRequest->pPropVars[1].bVal > 0)
    {
        //
        //  notifications are not sent to foreign computers
        //
        return;
    }
    ASSERT(pObjectParentInfoRequest->pPropIDs[0] == PROPID_QM_MACHINE_ID);

    ASSERT(pObjectInfoRequest->pPropIDs[0] == PROPID_Q_INSTANCE);

    g_Notification.NotifyQM(
        neChangeQueue,
        pwcsDomainController,
        pObjectParentInfoRequest->pPropVars[0].puuid,
        pObjectInfoRequest->pPropVars[0].puuid
        );
}

void CQueueObject::DeleteNotification(
            IN LPCWSTR                        pwcsDomainController,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest,
            IN const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest
            ) const
/*++
    Abstract:
	Notify QM about a queue deletion.
    The QM should verify if the queue belongs to the local QM.

    Parameters:
    LPCWSTR                        pwcsDomainController - DC agains which operation was performed
    const MQDS_OBJ_INFO_REQUEST*   pObjectInfoRequest - information about the queue
    const MQDS_OBJ_INFO_REQUEST*   pObjectParentInfoRequest - information about the QM

    Returns:
	void
--*/
{
    //
    //  make sure that we got the required information for sending
    //  notification. In case we don't, there is nothing to do
    //
    if (FAILED(pObjectInfoRequest->hrStatus))
    {
        LogHR(pObjectInfoRequest->hrStatus, s_FN, 151);
        return;
    }
    if (FAILED(pObjectParentInfoRequest->hrStatus))
    {
        LogHR(pObjectParentInfoRequest->hrStatus, s_FN, 161);
        return;
    }

    ASSERT(pObjectParentInfoRequest->pPropIDs[1] == PROPID_QM_FOREIGN);

    //
    //  Verify if the queue belongs to foreign QM
    //
    if (pObjectParentInfoRequest->pPropVars[1].bVal > 0)
    {
        //
        //  notifications are not sent to foreign computers
        //
        return;
    }
    ASSERT(pObjectParentInfoRequest->pPropIDs[0] == PROPID_QM_MACHINE_ID);
    ASSERT(pObjectInfoRequest->pPropIDs[0] == PROPID_Q_INSTANCE);

    g_Notification.NotifyQM(
        neDeleteQueue,
        pwcsDomainController,
        pObjectParentInfoRequest->pPropVars[0].puuid,
        pObjectInfoRequest->pPropVars[0].puuid
        );
}

HRESULT CQueueObject::CreateInAD(
			IN const DWORD            cp,
            IN const PROPID          *aProp,
            IN const MQPROPVARIANT   *apVar,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
            )
/*++
    Abstract:
	The routine creates queue object in AD with the specified attributes
	values

    Parameters:
    const DWORD   cp - number of properties
    const PROPID  *aProp - the propperties
    const MQPROPVARIANT *apVar - properties value
    PSECURITY_DESCRIPTOR    pSecurityDescriptor - SD of the object
    OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - properties to
							retrieve while creating the object
    OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - properties
						to retrieve about the object's parent
    Returns:
	HRESULT
--*/
{

    //
    //  Create the queue
    //
    HRESULT hr = CBasicObjectType::CreateInAD(
            cp,
            aProp,
            apVar,
            pObjInfoRequest,
            pParentInfoRequest
            );
    //
    //  override error codes, for backward compatability reasons
    //
    if ( hr == MQDS_OBJECT_NOT_FOUND)
    {
        return LogHR(MQ_ERROR_INVALID_OWNER, s_FN, 90);
    }

    return LogHR(hr, s_FN, 120);
}

HRESULT CQueueObject::GetComputerVersion(
                OUT PROPVARIANT *           pVar
                )
/*++

Routine Description:
    The routine reads the version of the queue's computer

Arguments:
	PROPVARIANT             pVar - version property value

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    LPCWSTR pwcsQueueName = m_pwcsPathName;
    AP<WCHAR> pClean;

    if (m_guidObject != GUID_NULL)
    {
        //
        //  Get the queue name
        //
        PROPID prop = PROPID_Q_PATHNAME;
        PROPVARIANT var;
        var.vt = VT_NULL;

        hr = g_AD.GetObjectProperties(
                        adpDomainController,
                        this,
                        1,
                        &prop,
                        &var
                        );
        if (FAILED(hr))
        {
            return hr;
        }
        pClean = var.pwszVal;
        pwcsQueueName = var.pwszVal;

    }
    //
    //  Get the computer name out of the queue pathname
    //
    AP<WCHAR> pwcsMachineName;
    hr = SplitAndFilterQueueName(
                      pwcsQueueName,
                      &pwcsMachineName,
                      &m_pwcsQueueName
                      );
    ASSERT( hr == MQ_OK);

    CComputerObject objComputer(pwcsMachineName, NULL, m_pwcsDomainController, m_fServerName);

    hr = objComputer.ComposeObjectDN();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    //
    //  Do not use GetObjectProperties API. because PROPID_COM_VERSION
    //  is not replicated to GC
    //

    PROPID prop = PROPID_COM_VERSION;

    hr = g_AD.GetObjectProperties(
                    adpDomainController,
                    &objComputer,
                    1,
                    &prop,
                    pVar
                    );
    return LogHR(hr, s_FN, 1823);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\siteobj.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    confobj.cpp

Abstract:

    Implementation of CSiteObject class.

Author:

    ronith

--*/
#include "ds_stdh.h"
#include "baseobj.h"
#include "mqattrib.h"
#include "mqadglbo.h"
#include "mqsec.h"

#include "siteobj.tmh"

static WCHAR *s_FN=L"mqad/siteobj";

DWORD CSiteObject::m_dwCategoryLength = 0;
AP<WCHAR> CSiteObject::m_pwcsCategory = NULL;


CSiteObject::CSiteObject( 
                  IN  LPCWSTR         pwcsPathName,
                  IN  const GUID *    pguidObject,
                    LPCWSTR         pwcsDomainController,
					bool		    fServerName
                    ) : CBasicObjectType( 
								pwcsPathName, 
								pguidObject,
								pwcsDomainController,
								fServerName
								)
/*++
    Abstract:
	constructor of site object

    Parameters:
    LPCWSTR       pwcsPathName - the object MSMQ name
    const GUID *  pguidObject  - the object unique id
    LPCWSTR       pwcsDomainController - the DC name against
	                             which all AD access should be performed
    bool		   fServerName - flag that indicate if the pwcsDomainController
							     string is a server name

    Returns:
	none

--*/
{
}

CSiteObject::~CSiteObject()
/*++
    Abstract:
	destructor of site object

    Parameters:
	none

    Returns:
	none
--*/
{
	//
	// nothing to do ( everything is released with automatic pointers
	//
}

HRESULT CSiteObject::ComposeObjectDN()
/*++
    Abstract:
	Composed distinguished name of the site

    Parameters:
	none

    Returns:
	none
--*/
{
    if (m_pwcsDN != NULL)
    {
        return MQ_OK;
    }
    ASSERT(m_pwcsPathName != NULL);
    ASSERT(g_pwcsSitesContainer != NULL);

    DWORD Length =
            x_CnPrefixLen +                   // "CN="
            wcslen(m_pwcsPathName) +          // site name
            1 +                               //","
            wcslen(g_pwcsSitesContainer) +    // site container
            1;                                // '\0'

    m_pwcsDN = new WCHAR[Length];

    DWORD dw = swprintf(
        m_pwcsDN,
         L"%s"             // "CN="
         L"%s"             // site name
         TEXT(",")
         L"%s",            // site container
        x_CnPrefix,
        m_pwcsPathName,
        g_pwcsSitesContainer
        );
    DBG_USED(dw);
	ASSERT( dw < Length);

    return MQ_OK;
}

HRESULT CSiteObject::ComposeFatherDN()
/*++
    Abstract:
	Composed distinguished name of the parent of site object

    Parameters:
	none

    Returns:
	none
--*/
{
    if (m_pwcsParentDN != NULL)
    {
        return MQ_OK;
    }

    ASSERT(g_pwcsSitesContainer != NULL);

    m_pwcsParentDN = new WCHAR[wcslen(g_pwcsSitesContainer) + 1];
	wcscpy(m_pwcsParentDN, g_pwcsSitesContainer);
    return MQ_OK;
}

LPCWSTR CSiteObject::GetRelativeDN()
/*++
    Abstract:
	return the RDN of the site object

    Parameters:
	none

    Returns:
	LPCWSTR site RDN
--*/
{
	ASSERT(m_pwcsPathName != NULL);
    return m_pwcsPathName;
}


DS_CONTEXT CSiteObject::GetADContext() const
/*++
    Abstract:
	Returns the AD context where site object should be looked for

    Parameters:
	none

    Returns:
	DS_CONTEXT
--*/
{
    return e_SitesContainer;
}

bool CSiteObject::ToAccessDC() const
/*++
    Abstract:
	returns whether to look for the object in DC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	true (i.e. to look for the object in any DC)
--*/
{
    //
    //  configuration container is on every DC
    //
    return true;
}

bool CSiteObject::ToAccessGC() const
/*++
    Abstract:
	returns whether to look for the object in GC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	false 
--*/
{
	//
	// the configurtion container exists on every DC
	//
    return false;
}

void CSiteObject::ObjectWasFoundOnDC()
/*++
    Abstract:
	The object was found on DC, this is not relevant for
    site objects.


    Parameters:
	none

    Returns:
	none
--*/
{
}


LPCWSTR CSiteObject::GetObjectCategory() 
/*++
    Abstract:
	prepares and retruns the object category string

    Parameters:
	none

    Returns:
	LPCWSTR object category string
--*/
{
    if (CSiteObject::m_pwcsCategory == NULL)
    {
        DWORD len = wcslen(g_pwcsSchemaContainer) + wcslen(x_SiteCategoryName) + 2;

        AP<WCHAR> pwcsCategory = new WCHAR[len];
        DWORD dw = swprintf(
             pwcsCategory,
             L"%s,%s",
             x_SiteCategoryName,
             g_pwcsSchemaContainer
            );
        DBG_USED(dw);
		ASSERT( dw < len);

        if (NULL == InterlockedCompareExchangePointer(
                              &CSiteObject::m_pwcsCategory.ref_unsafe(), 
                              pwcsCategory.get(),
                              NULL
                              ))
        {
            pwcsCategory.detach();
            CSiteObject::m_dwCategoryLength = len;
        }
    }
    return CSiteObject::m_pwcsCategory;
}

DWORD   CSiteObject::GetObjectCategoryLength()
/*++
    Abstract:
	prepares and retruns the length object category string

    Parameters:
	none

    Returns:
	DWORD object category string length
--*/
{
	//
	//	call GetObjectCategory in order to initailaze category string
	//	and length
	//
	GetObjectCategory();

    return CSiteObject::m_dwCategoryLength;
}

AD_OBJECT CSiteObject::GetObjectType() const
/*++
    Abstract:
	returns the object type

    Parameters:
	none

    Returns:
	AD_OBJECT
--*/
{
    return eSITE;
}

LPCWSTR CSiteObject::GetClass() const
/*++
    Abstract:
	returns a string represinting the object class in AD

    Parameters:
	none

    Returns:
	LPCWSTR object class string
--*/
{
    return MSMQ_SITE_CLASS_NAME;
}

DWORD CSiteObject::GetMsmq1ObjType() const
/*++
    Abstract:
	returns the object type in MSMQ 1.0 terms

    Parameters:
	none

    Returns:
	DWORD 
--*/
{
    return MQDS_SITE;
}

HRESULT CSiteObject::VerifyAndAddProps(
            IN  const DWORD            cp,        
            IN  const PROPID *         aProp, 
            IN  const MQPROPVARIANT *  apVar, 
            IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
            OUT DWORD*                 pcpNew,
            OUT PROPID**               ppPropNew,
            OUT MQPROPVARIANT**        ppVarNew
            )
/*++
    Abstract:
	verifies site properties and add default SD

    Parameters:
    const DWORD            cp - number of props        
    const PROPID *         aProp - props ids
    const MQPROPVARIANT *  apVar - properties value
    PSECURITY_DESCRIPTOR   pSecurityDescriptor - SD for the object
    DWORD*                 pcpNew - new number of props
    PROPID**               ppPropNew - new prop ids
    OMQPROPVARIANT**       ppVarNew - new properties values

    Returns:
	HRESULT
--*/
{
    //
    // Security property should never be supplied as a property
    //
    PROPID pSecId = GetObjectSecurityPropid();
    for ( DWORD i = 0; i < cp ; i++ )
    {
        if (pSecId == aProp[i])
        {
            ASSERT(0) ;
            return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 40);
        }
    }
    //
    //  add default security 
    //

    AP<PROPVARIANT> pAllPropvariants;
    AP<PROPID> pAllPropids;
    ASSERT( cp > 0);
    DWORD cpNew = cp + 2;
    DWORD next = cp;
    //
    //  Just copy the caller supplied properties as is
    //
    if ( cp > 0)
    {
        pAllPropvariants = new PROPVARIANT[cpNew];
        pAllPropids = new PROPID[cpNew];
        memcpy (pAllPropvariants, apVar, sizeof(PROPVARIANT) * cp);
        memcpy (pAllPropids, aProp, sizeof(PROPID) * cp);
    }
    //
    //  add default security
    //
    HRESULT hr;
    hr = MQSec_GetDefaultSecDescriptor( MQDS_SITE,
                                   (VOID **)&m_pDefaultSecurityDescriptor,
                                   FALSE,   //fImpersonate
                                   pSecurityDescriptor,
                                   (OWNER_SECURITY_INFORMATION |
                                    GROUP_SECURITY_INFORMATION),      // seInfoToRemove
                                   e_UseDefaultDacl ) ;
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 10);
        return MQ_ERROR_ACCESS_DENIED;
    }
    pAllPropvariants[ next ].blob.cbSize =
                       GetSecurityDescriptorLength( m_pDefaultSecurityDescriptor.get());
    pAllPropvariants[ next ].blob.pBlobData =
                                     (unsigned char *) m_pDefaultSecurityDescriptor.get();
    pAllPropvariants[ next ].vt = VT_BLOB;
    pAllPropids[ next ] = PROPID_S_SECURITY;
    next++;

    //
    //  specify that the SD contains only DACL info
    //
    pAllPropvariants[ next ].ulVal =  DACL_SECURITY_INFORMATION;
    pAllPropvariants[ next ].vt = VT_UI4;
    pAllPropids[ next ] = PROPID_S_SECURITY_INFORMATION;
    next++;

    ASSERT(cpNew == next);

    *pcpNew = next;
    *ppPropNew = pAllPropids.detach();
    *ppVarNew = pAllPropvariants.detach();
    return MQ_OK;

}

HRESULT CSiteObject::SetObjectSecurity(
            IN  SECURITY_INFORMATION        /*RequestedInformation*/,
            IN  const PROPID                /*prop*/,
            IN  const PROPVARIANT *         /*pVar*/,
            IN OUT MQDS_OBJ_INFO_REQUEST *  /*pObjInfoRequest*/, 
            IN OUT MQDS_OBJ_INFO_REQUEST *  /*pParentInfoRequest*/
            )
/*++

Routine Description:
    The routine sets object security in AD 

Arguments:
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - infomation about the object
    MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - information about the object's parent

Return Value
	HRESULT

--*/
{
    //
    //  This operation is not supported
    //
    return MQ_ERROR_FUNCTION_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\sndnotif.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    notify.h

Abstract:

    MQAD notification Class definition

Author:

    ronit hartmann (ronith)


--*/
#ifndef __SNDNOTIFY_H__
#define __SNDNOTIFY_H__

#include "adnotify.h"

class CSendNotification
{
public:
    CSendNotification();

    ~CSendNotification();


    void NotifyQM(
        IN  ENotificationEvent ne,
        IN  LPCWSTR     pwcsDomainCOntroller,
        IN  const GUID* pguidDestQM,
        IN  const GUID* pguidObject
        );

private:
    void CallNotifyQM(
        IN  RPC_BINDING_HANDLE  h,
        IN  ENotificationEvent  ne,
        IN  LPCWSTR     pwcsDomainCOntroller,
        IN  const GUID* pguidDestQM,
        IN  const GUID* pguidObject
        );


    void InitRPC(
        OUT RPC_BINDING_HANDLE * ph
        );




private:

    static WCHAR* m_pwcsStringBinding;

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\traninfo.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    traninfo.cpp

Abstract:

    Translation information of MSMQ 1.0 properties into MSMQ 2.0 attributes

Author:

    ronit hartmann ( ronith)

--*/
#include "ds_stdh.h"
#include "mqads.h"
#include "mqprops.h"
#include "mqattrib.h"
#include "_mqini.h"
#include "tranrout.h"
#include "xlatqm.h"
#include "traninfo.h"

#include "traninfo.tmh"

static WCHAR *s_FN=L"mqad/traninfo";
GUID guidNull = {0,0,0,{0,0,0,0,0,0,0,0}};

//----------------------------------------------------------
//  defaultVARIANT
//
//  This structure is equivalent in size and order of variables 
//  to MQPROPVARIANT.
//
//  MQPROPVARIANT contains a union, and the size first member of
//  the union is smaller than other members of the union.
//  Therefore MQPROVARIANT cannot be initialized at compile time
//  with union members other than the smallest one.
//
//----------------------------------------------------------
struct defaultVARIANT {
    VARTYPE vt;
    WORD wReserved1;
    WORD wReserved2;
    WORD wReserved3;
    ULONG_PTR l1;
    ULONG_PTR l2;
};

C_ASSERT(sizeof(defaultVARIANT) == sizeof(MQPROPVARIANT));
C_ASSERT(FIELD_OFFSET(defaultVARIANT, l1) == FIELD_OFFSET(MQPROPVARIANT, caub.cElems));
C_ASSERT(FIELD_OFFSET(defaultVARIANT, l2) == FIELD_OFFSET(MQPROPVARIANT, caub.pElems));

//
//      Default values for queue properties
//
const defaultVARIANT varDefaultQType = { VT_CLSID, 0,0,0, (LONG_PTR)&guidNull, 0};
const defaultVARIANT varDefaultQJournal = { VT_UI1, 0,0,0, DEFAULT_Q_JOURNAL, 0};
const defaultVARIANT varDefaultQQuota = { VT_UI4, 0,0,0, DEFAULT_Q_QUOTA, 0};
const defaultVARIANT varDefaultQBasePriority = { VT_I2, 0,0,0, DEFAULT_Q_BASEPRIORITY, 0};
const defaultVARIANT varDefaultQJQuota = { VT_UI4, 0,0,0, DEFAULT_Q_JOURNAL_QUOTA, 0};
const defaultVARIANT varDefaultQJLabel = { VT_LPWSTR, 0,0,0, (LONG_PTR)TEXT(""), 0};
const defaultVARIANT varDefaultQAuthenticate = { VT_UI1, 0,0,0, DEFAULT_Q_AUTHENTICATE, 0};
const defaultVARIANT varDefaultQPrivLevel = { VT_UI4, 0,0,0, DEFAULT_Q_PRIV_LEVEL, 0};
const defaultVARIANT varDefaultQTransaction = { VT_UI1, 0,0,0, DEFAULT_Q_TRANSACTION, 0};
const defaultVARIANT varDefaultQMulticastAddress = { VT_EMPTY, 0, 0, 0, 0, 0};

translateProp   QueueTranslateInfo[cQueueTranslateInfoSize] = {
// PROPID                | attribute-name               | vartype   | adstype                   | Translation routine                  | multivalue| InGC | default value                            | Set routine | Create routine | 
//-----------------------|------------------------------|-----------|---------------------------|--------------------------------------|-----------|------|------------------------------------------|-------------|----------------|
{PROPID_Q_INSTANCE       ,MQ_Q_INSTANCE_ATTRIBUTE       ,VT_CLSID   ,MQ_Q_INSTANCE_ADSTYPE      ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            },
{PROPID_Q_TYPE           ,MQ_Q_TYPE_ATTRIBUTE           ,VT_CLSID   ,MQ_Q_TYPE_ADSTYPE          ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQType          ,NULL         ,NULL            },
{PROPID_Q_PATHNAME       ,NULL                          ,VT_LPWSTR  ,ADSTYPE_INVALID            ,MQADpRetrieveQueueName                ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            },
{PROPID_Q_JOURNAL        ,MQ_Q_JOURNAL_ATTRIBUTE        ,VT_UI1     ,MQ_Q_JOURNAL_ADSTYPE       ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQJournal       ,NULL         ,NULL            },
{PROPID_Q_QUOTA          ,MQ_Q_QUOTA_ATTRIBUTE          ,VT_UI4     ,MQ_Q_QUOTA_ADSTYPE         ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQQuota         ,NULL         ,NULL            },
{PROPID_Q_BASEPRIORITY   ,MQ_Q_BASEPRIORITY_ATTRIBUTE   ,VT_I2      ,MQ_Q_BASEPRIORITY_ADSTYPE  ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQBasePriority  ,NULL         ,NULL            },
{PROPID_Q_JOURNAL_QUOTA  ,MQ_Q_JOURNAL_QUOTA_ATTRIBUTE  ,VT_UI4     ,MQ_Q_JOURNAL_QUOTA_ADSTYPE ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQJQuota        ,NULL         ,NULL            },
{PROPID_Q_LABEL          ,MQ_Q_LABEL_ATTRIBUTE          ,VT_LPWSTR  ,MQ_Q_LABEL_ADSTYPE         ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQJLabel        ,NULL         ,NULL            },
{PROPID_Q_CREATE_TIME    ,MQ_Q_CREATE_TIME_ATTRIBUTE    ,VT_I4      ,MQ_Q_CREATE_TIME_ADSTYPE   ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            },
{PROPID_Q_MODIFY_TIME    ,MQ_Q_MODIFY_TIME_ATTRIBUTE    ,VT_I4      ,MQ_Q_MODIFY_TIME_ADSTYPE   ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            },
{PROPID_Q_AUTHENTICATE   ,MQ_Q_AUTHENTICATE_ATTRIBUTE   ,VT_UI1     ,MQ_Q_AUTHENTICATE_ADSTYPE  ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQAuthenticate  ,NULL         ,NULL            },
{PROPID_Q_PRIV_LEVEL     ,MQ_Q_PRIV_LEVEL_ATTRIBUTE     ,VT_UI4     ,MQ_Q_PRIV_LEVEL_ADSTYPE    ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQPrivLevel     ,NULL         ,NULL            },
{PROPID_Q_TRANSACTION    ,MQ_Q_TRANSACTION_ATTRIBUTE    ,VT_UI1     ,MQ_Q_TRANSACTION_ADSTYPE   ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQTransaction   ,NULL         ,NULL            },
{PROPID_Q_QMID           ,NULL                          ,VT_CLSID   ,ADSTYPE_INVALID            ,MQADpRetrieveQueueQMid                ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            },
{PROPID_Q_MASTERID       ,MQ_Q_MASTERID_ATTRIBUTE       ,VT_CLSID   ,MQ_Q_MASTERID_ADSTYPE      ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            },
{PROPID_Q_SECURITY       ,MQ_Q_SECURITY_ATTRIBUTE       ,VT_BLOB    ,MQ_Q_SECURITY_ADSTYPE      ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            },
{PROPID_Q_NT4ID          ,MQ_Q_NT4ID_ATTRIBUTE          ,VT_CLSID   ,MQ_Q_NT4ID_ADSTYPE         ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            },
{PROPID_Q_DONOTHING      ,NULL                          ,VT_UI1     ,ADSTYPE_INVALID            ,NULL                                  ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            },
{PROPID_Q_FULL_PATH      ,MQ_Q_FULL_PATH_ATTRIBUTE      ,VT_LPWSTR  ,MQ_Q_FULL_PATH_ADSTYPE     ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            },            
{PROPID_Q_NAME_SUFFIX    ,MQ_Q_NAME_EXT                 ,VT_LPWSTR  ,MQ_Q_NAME_EXT_ADSTYPE      ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            },            
{PROPID_Q_OBJ_SECURITY   ,MQ_Q_SECURITY_ATTRIBUTE       ,VT_BLOB    ,MQ_Q_SECURITY_ADSTYPE      ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            },
{PROPID_Q_SECURITY_INFORMATION  ,NULL                   ,VT_UI1     ,ADSTYPE_INVALID            ,MQADpRetrieveNothing                  ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            },
{PROPID_Q_PATHNAME_DNS   ,NULL                          ,VT_LPWSTR  ,ADSTYPE_INVALID            ,MQADpRetrieveQueueDNSName             ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            },
{PROPID_Q_MULTICAST_ADDRESS,MQ_Q_MULTICAST_ADDRESS      ,VT_LPWSTR  ,MQ_Q_MULTICAST_ADDRESS_ADSTYPE,NULL                               ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMulticastAddress,NULL       ,NULL            },
{PROPID_Q_ADS_PATH       ,NULL                          ,VT_LPWSTR  ,ADSTYPE_INVALID            ,MQADpRetrieveQueueADSPath             ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            }
};

//
//      Default values for machine properties
//

const defaultVARIANT varDefaultQMService = { VT_UI4, 0,0,0, DEFAULT_N_SERVICE, 0};
const defaultVARIANT varDefaultQMServiceRout = { VT_UI1, 0,0,0, DEFAULT_N_SERVICE, 0};    //[adsrv]
const defaultVARIANT varDefaultQMServiceDs   = { VT_UI1, 0,0,0, DEFAULT_N_SERVICE, 0};
const defaultVARIANT varDefaultQMServiceDep  = { VT_UI1, 0,0,0, DEFAULT_N_SERVICE, 0};
const defaultVARIANT varDefaultQMInFrs = { VT_CLSID|VT_VECTOR, 0,0,0, 0, 0};
const defaultVARIANT varDefaultQMOutFrs = { VT_CLSID|VT_VECTOR, 0,0,0, 0, 0};
const defaultVARIANT varDefaultQMQuota = { VT_UI4, 0,0,0, DEFAULT_QM_QUOTA, 0};
const defaultVARIANT varDefaultQMJQuota = { VT_UI4, 0,0,0, DEFAULT_QM_JOURNAL_QUOTA, 0};
const defaultVARIANT varDefaultQMForeign = { VT_UI1, 0,0,0, DEFAULT_QM_FOREIGN, 0};
const defaultVARIANT varDefaultQMOs = { VT_UI4, 0,0,0, DEFAULT_QM_OS, 0};
const defaultVARIANT varDefaultQMMType = { VT_LPWSTR, 0,0,0, (LONG_PTR)TEXT(""), 0};
const defaultVARIANT varDefaultQMSignPk = { VT_BLOB, 0,0,0, 0, 0};
const defaultVARIANT varDefaultQMEncryptPk = { VT_BLOB, 0,0,0, 0, 0};
const defaultVARIANT varDefaultQMSiteIDs = { VT_CLSID|VT_VECTOR, 0,0,0, 0, 0};
const defaultVARIANT varDefaultQMDescription = { VT_LPWSTR, 0,0,0, (LONG_PTR)TEXT(""), 0};


translateProp   MachineTranslateInfo[cMachineTranslateInfoSize] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                         | Set routine            | Create routine          |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|---------------------------------------|------------------------|-------------------------|
{PROPID_QM_SITE_ID       ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,MQADpRetrieveMachineSite                ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     },
{PROPID_QM_MACHINE_ID    ,MQ_QM_ID_ATTRIBUTE            ,VT_CLSID           ,MQ_QM_ID_ADSTYPE           ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     },
{PROPID_QM_PATHNAME      ,MQ_QM_PATHNAME_ATTRIBUTE      ,VT_LPWSTR          ,ADSTYPE_INVALID            ,MQADpRetrieveMachineName                ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     },
{PROPID_QM_OUTFRS        ,NULL                          ,VT_CLSID|VT_VECTOR ,ADSTYPE_INVALID            ,MQADpRetrieveMachineOutFrs              ,FALSE      ,FALSE ,NULL                                   ,MQADpSetMachineOutFrss  ,MQADpCreateMachineOutFrss},
{PROPID_QM_INFRS         ,NULL                          ,VT_CLSID|VT_VECTOR ,ADSTYPE_INVALID            ,MQADpRetrieveMachineInFrs               ,FALSE      ,FALSE ,NULL                                   ,MQADpSetMachineInFrss   ,MQADpCreateMachineInFrss },
{PROPID_QM_SERVICE       ,MQ_QM_SERVICE_ATTRIBUTE       ,VT_UI4             ,ADSTYPE_INVALID,            MQADpRetrieveQMService                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMService   ,MQADpSetMachineService  ,NULL                     },  
{PROPID_QM_OLDSERVICE    ,MQ_QM_SERVICE_ATTRIBUTE       ,VT_UI4             ,MQ_QM_SERVICE_ADSTYPE      ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMService   ,MQADpSetMachineService  ,NULL                     },
{PROPID_QM_SERVICE_DSSERVER   ,MQ_QM_SERVICE_DSSERVER_ATTRIBUTE    ,VT_UI1,MQ_QM_SERVICE_DSSERVER_ADSTYPE   ,NULL                                ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMServiceDs ,MQADpSetMachineServiceDs,NULL                     },
{PROPID_QM_SERVICE_ROUTING    ,MQ_QM_SERVICE_ROUTING_ATTRIBUTE     ,VT_UI1,MQ_QM_SERVICE_ROUTING_ADSTYPE    ,NULL                                ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMServiceRout,MQADpSetMachineServiceRout,NULL                  },
{PROPID_QM_SERVICE_DEPCLIENTS ,MQ_QM_SERVICE_DEPCLIENTS_ATTRIBUTE  ,VT_UI1,MQ_QM_SERVICE_DEPCLIENTS_ADSTYPE ,NULL                                ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMServiceDep  ,NULL                  ,NULL                     },
{PROPID_QM_MASTERID      ,MQ_QM_MASTERID_ATTRIBUTE      ,VT_CLSID           ,MQ_QM_MASTERID_ADSTYPE     ,NULL						             ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     },
{PROPID_QM_QUOTA         ,MQ_QM_QUOTA_ATTRIBUTE         ,VT_UI4             ,MQ_QM_QUOTA_ADSTYPE        ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultQMQuota     ,NULL                    ,NULL                     },
{PROPID_QM_JOURNAL_QUOTA ,MQ_QM_JOURNAL_QUOTA_ATTRIBUTE ,VT_UI4             ,MQ_QM_JOURNAL_QUOTA_ADSTYPE,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultQMJQuota    ,NULL                    ,NULL                     },
{PROPID_QM_MACHINE_TYPE  ,MQ_QM_MACHINE_TYPE_ATTRIBUTE  ,VT_LPWSTR          ,MQ_QM_MACHINE_TYPE_ADSTYPE ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultQMMType     ,NULL                    ,NULL                     },
{PROPID_QM_CREATE_TIME   ,MQ_QM_CREATE_TIME_ATTRIBUTE   ,VT_I4              ,MQ_QM_CREATE_TIME_ADSTYPE  ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     },
{PROPID_QM_MODIFY_TIME   ,MQ_QM_MODIFY_TIME_ATTRIBUTE   ,VT_I4              ,MQ_QM_MODIFY_TIME_ADSTYPE  ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     },
{PROPID_QM_FOREIGN       ,MQ_QM_FOREIGN_ATTRIBUTE       ,VT_UI1             ,MQ_QM_FOREIGN_ADSTYPE      ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMForeign   ,NULL                    ,NULL                     },
{PROPID_QM_OS            ,MQ_QM_OS_ATTRIBUTE            ,VT_UI4             ,MQ_QM_OS_ADSTYPE           ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMOs        ,NULL                    ,NULL                     },
{PROPID_QM_SECURITY      ,MQ_QM_SECURITY_ATTRIBUTE      ,VT_BLOB            ,MQ_QM_SECURITY_ADSTYPE     ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     },
{PROPID_QM_SIGN_PK       ,MQ_QM_SIGN_PK_ATTRIBUTE       ,VT_BLOB            ,MQ_QM_SIGN_PK_ADSTYPE      ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMSignPk    ,NULL                    ,NULL                     },
{PROPID_QM_ENCRYPT_PK    ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,MQADpRetrieveMachineEncryptPk           ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMEncryptPk ,MQADpSetMachineEncryptPk,MQADpCreateMachineEncryptPk},
{PROPID_QM_FULL_PATH     ,MQ_QM_FULL_PATH_ATTRIBUTE     ,VT_LPWSTR          ,MQ_QM_FULL_PATH_ADSTYPE    ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     },
{PROPID_QM_SITE_IDS      ,MQ_QM_SITES_ATTRIBUTE         ,VT_CLSID|VT_VECTOR ,MQ_QM_SITES_ADSTYPE        ,NULL                                    ,TRUE       ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMSiteIDs   ,NULL                    ,NULL                     },
{PROPID_QM_OUTFRS_DN     ,MQ_QM_OUTFRS_ATTRIBUTE        ,VT_LPWSTR|VT_VECTOR,MQ_QM_OUTFRS_ADSTYPE       ,NULL                                    ,TRUE       ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMOutFrs    ,NULL                    ,NULL                     },
{PROPID_QM_INFRS_DN      ,MQ_QM_INFRS_ATTRIBUTE         ,VT_LPWSTR|VT_VECTOR,MQ_QM_OUTFRS_ADSTYPE       ,NULL                                    ,TRUE       ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMInFrs     ,NULL                    ,NULL                     },
{PROPID_QM_NT4ID         ,MQ_QM_NT4ID_ATTRIBUTE         ,VT_CLSID           ,MQ_QM_NT4ID_ADSTYPE        ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     },
{PROPID_QM_DONOTHING     ,NULL                          ,VT_UI1             ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     },
{PROPID_QM_OBJ_SECURITY  ,MQ_QM_SECURITY_ATTRIBUTE      ,VT_BLOB            ,MQ_QM_SECURITY_ADSTYPE     ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     },
{PROPID_QM_SECURITY_INFORMATION   ,NULL                 ,VT_UI1             ,ADSTYPE_INVALID            ,MQADpRetrieveNothing                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     },
{PROPID_QM_ENCRYPT_PKS   ,MQ_QM_ENCRYPT_PK_ATTRIBUTE    ,VT_BLOB            ,MQ_QM_ENCRYPT_PK_ADSTYPE   ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMEncryptPk ,NULL                    ,NULL                     },
{PROPID_QM_SIGN_PKS      ,MQ_QM_SIGN_PK_ATTRIBUTE       ,VT_BLOB            ,MQ_QM_SIGN_PK_ADSTYPE      ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMSignPk    ,NULL                    ,NULL                     },
{PROPID_QM_PATHNAME_DNS  ,NULL                          ,VT_LPWSTR          ,ADSTYPE_INVALID            ,MQADpRetrieveMachineDNSName             ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     },
{PROPID_QM_WORKGROUP_ID  ,MQ_QM_WORKGROUP_ID_ATTRIBUTE  ,VT_CLSID           ,MQ_QM_WORKGROUP_ID_ADSTYPE ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     },
{PROPID_QM_DESCRIPTION   ,MQ_QM_DESCRIPTION_ATTRIBUTE   ,VT_LPWSTR          ,MQ_QM_DESCRIPTION_ADSTYPE  ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMDescription ,NULL                  ,NULL                     }
};   

 

 
//
//      Default values for enterprise properties
//

const defaultVARIANT varDefaultENameStyle = { VT_UI1, 0,0,0, DEFAULT_E_NAMESTYLE, 0};
const defaultVARIANT varDefaultECspName = { VT_LPWSTR, 0,0,0, (LONG_PTR)DEFAULT_E_DEFAULTCSP, 0};
const defaultVARIANT varDefaultELongLive = { VT_UI4, 0,0,0, MSMQ_DEFAULT_LONG_LIVE, 0};
const defaultVARIANT varDefaultEVersion = { VT_UI2, 0,0,0, DEFAULT_E_VERSION, 0};
const defaultVARIANT varDefaultEInterval1 = { VT_UI2, 0,0,0, DEFAULT_S_INTERVAL1, 0};
const defaultVARIANT varDefaultEInterval2 = { VT_UI2, 0,0,0, DEFAULT_S_INTERVAL2, 0};
                                                                                                                                                                                                                         
translateProp   EnterpriseTranslateInfo[cEnterpriseTranslateInfoSize] = {
// PROPID                | attribute-name               | vartype           | adstype                    | Translation routine                    | multivalue| InGC | default value                         | Set routine | Create routine |
//-----------------------|------------------------------|-------------------|----------------------------|----------------------------------------|-----------|------|---------------------------------------|-------------|----------------|
{PROPID_E_NAME           ,NULL                          ,VT_LPWSTR          ,ADSTYPE_INVALID             ,MQADpRetrieveEnterpriseName             ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            },
{PROPID_E_NAMESTYLE      ,MQ_E_NAMESTYLE_ATTRIBUTE      ,VT_UI1             ,MQ_E_NAMESTYLE_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultENameStyle  ,NULL         ,NULL            },
{PROPID_E_CSP_NAME       ,MQ_E_CSP_NAME_ATTRIBUTE       ,VT_LPWSTR          ,MQ_E_CSP_NAME_ADSTYPE       ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultECspName    ,NULL         ,NULL            },
{PROPID_E_S_INTERVAL1    ,MQ_E_INTERVAL1                ,VT_UI2             ,MQ_E_INTERVAL1_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultEInterval1  ,NULL         ,NULL            },
{PROPID_E_S_INTERVAL2    ,MQ_E_INTERVAL2                ,VT_UI2             ,MQ_E_INTERVAL2_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultEInterval2  ,NULL         ,NULL            },
{PROPID_E_ID             ,MQ_E_ID_ATTRIBUTE             ,VT_CLSID           ,MQ_E_ID_ADSTYPE             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            },
{PROPID_E_LONG_LIVE      ,MQ_E_LONG_LIVE_ATTRIBUTE      ,VT_UI4             ,MQ_E_LONG_LIVE_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultELongLive   ,NULL         ,NULL            },
{PROPID_E_VERSION        ,MQ_E_VERSION_ATTRIBUTE        ,VT_UI2             ,MQ_E_VERSION_ADSTYPE        ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultEVersion    ,NULL         ,NULL            },
{PROPID_E_NT4ID          ,MQ_E_NT4ID_ATTRIBUTE          ,VT_CLSID           ,MQ_E_NT4ID_ADSTYPE          ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            },
{PROPID_E_SECURITY       ,MQ_E_SECURITY_ATTRIBUTE       ,VT_BLOB            ,MQ_E_SECURITY_ADSTYPE       ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            }
};


const defaultVARIANT varDefaultLGatesDN = { VT_LPWSTR|VT_VECTOR, 0,0,0, 0, 0};
const defaultVARIANT varDefaultLGates = { VT_CLSID|VT_VECTOR, 0,0,0, 0, 0};
const defaultVARIANT varDefaultLDescription = { VT_LPWSTR, 0,0,0, (LONG_PTR)TEXT(""), 0};

translateProp   SiteLinkTranslateInfo[cSiteLinkTranslateInfoSize] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                  | Set routine           | Creare routine          |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|--------------------------------|-----------------------|-------------------------|
{PROPID_L_NEIGHBOR1      ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,MQADpRetrieveLinkNeighbor1              ,FALSE      ,FALSE ,NULL                            ,MQADpSetLinkNeighbor1  ,MQADpCreateLinkNeighbor1},
{PROPID_L_NEIGHBOR2      ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,MQADpRetrieveLinkNeighbor2              ,FALSE      ,FALSE ,NULL                            ,MQADpSetLinkNeighbor2  ,MQADpCreateLinkNeighbor2},
{PROPID_L_COST           ,NULL                          ,VT_UI4             ,ADSTYPE_INVALID            ,MQADpRetrieveLinkCost                   ,FALSE      ,FALSE ,NULL                            ,MQADpSetLinkCost       ,MQADpCreateLinkCost     },
{PROPID_L_ID             ,MQ_L_ID_ATTRIBUTE             ,VT_CLSID           ,MQ_L_ID_ADSTYPE            ,NULL                                    ,FALSE      ,FALSE ,NULL                            ,NULL                   ,NULL                     },
{PROPID_L_GATES_DN       ,MQ_L_SITEGATES_ATTRIBUTE      ,VT_LPWSTR|VT_VECTOR,MQ_L_SITEGATES_ADSTYPE     ,NULL                                    ,TRUE       ,FALSE ,(MQPROPVARIANT*)&varDefaultLGatesDN,NULL                ,NULL                     },
{PROPID_L_NEIGHBOR1_DN   ,MQ_L_NEIGHBOR1_ATTRIBUTE      ,VT_LPWSTR          ,MQ_L_NEIGHBOR1_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,NULL                            ,NULL                   ,NULL                     },
{PROPID_L_NEIGHBOR2_DN   ,MQ_L_NEIGHBOR2_ATTRIBUTE      ,VT_LPWSTR          ,MQ_L_NEIGHBOR2_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,NULL                            ,NULL                   ,NULL                     },
{PROPID_L_DESCRIPTION    ,MQ_L_DESCRIPTION_ATTRIBUTE    ,VT_LPWSTR          ,MQ_L_DESCRIPTION_ADSTYPE   ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultLDescription,NULL            ,NULL                     },
{PROPID_L_FULL_PATH      ,MQ_L_FULL_PATH_ATTRIBUTE      ,VT_LPWSTR          ,MQ_L_FULL_PATH_ADSTYPE     ,NULL                                    ,FALSE      ,TRUE  ,NULL                            ,NULL                   ,NULL                     },            
{PROPID_L_ACTUAL_COST    ,MQ_L_COST_ATTRIBUTE           ,VT_UI4             ,MQ_L_COST_ADSTYPE          ,NULL                                    ,FALSE      ,FALSE ,NULL                            ,NULL                   ,NULL                     },
{PROPID_L_GATES          ,NULL                          ,VT_CLSID|VT_VECTOR ,ADSTYPE_INVALID            ,MQADpRetrieveLinkGates                  ,TRUE       ,FALSE ,(MQPROPVARIANT*)&varDefaultLGates,NULL                  ,NULL                     }
};


const defaultVARIANT varDefaultUserSignCert = { VT_BLOB, 0,0,0, 0, 0};
const defaultVARIANT varDefaultUserDigest = { VT_VECTOR | VT_CLSID, 0,0,0,0,0};

translateProp   UserTranslateInfo[ cUserTranslateInfoSize] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                          | Set routine | Create routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|----------------------------------------|-------------|----------------|
{PROPID_U_SID            ,MQ_U_SID_ATTRIBUTE            ,VT_BLOB            ,MQ_U_SID_ADSTYPE           ,NULL                                    ,FALSE      ,TRUE  ,NULL                                    ,NULL         ,NULL            },
{PROPID_U_SIGN_CERT      ,MQ_U_SIGN_CERT_ATTRIBUTE      ,VT_BLOB            ,MQ_U_SIGN_CERT_ADSTYPE     ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserSignCert ,NULL         ,NULL            },
{PROPID_U_DIGEST         ,MQ_U_DIGEST_ATTRIBUTE         ,VT_CLSID|VT_VECTOR ,MQ_U_DIGEST_ADSTYPE        ,NULL                                    ,TRUE       ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserDigest   ,NULL         ,NULL            },
{PROPID_U_ID             ,MQ_U_ID_ATTRIBUTE             ,VT_CLSID           ,MQ_U_ID_ADSTYPE            ,NULL                                    ,FALSE      ,TRUE  ,NULL                                    ,NULL         ,NULL            }
};

translateProp   MQUserTranslateInfo[cMQUserTranslateInfoSize] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                          | Set routine | Create routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|----------------------------------------|-------------|----------------|
{PROPID_MQU_SID          ,MQ_MQU_SID_ATTRIBUTE          ,VT_BLOB            ,MQ_MQU_SID_ADSTYPE         ,NULL                                     ,FALSE     ,TRUE  ,NULL                                    ,NULL         ,NULL            },
{PROPID_MQU_SIGN_CERT    ,MQ_MQU_SIGN_CERT_ATTRIBUTE    ,VT_BLOB            ,MQ_MQU_SIGN_CERT_ADSTYPE   ,NULL                                     ,FALSE     ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserSignCert ,NULL         ,NULL            },
{PROPID_MQU_DIGEST       ,MQ_MQU_DIGEST_ATTRIBUTE       ,VT_CLSID|VT_VECTOR ,MQ_MQU_DIGEST_ADSTYPE      ,NULL                                     ,TRUE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserDigest   ,NULL         ,NULL            },
{PROPID_MQU_ID           ,MQ_MQU_ID_ATTRIBUTE           ,VT_CLSID           ,MQ_MQU_ID_ADSTYPE          ,NULL                                     ,FALSE     ,TRUE  ,NULL                                    ,NULL         ,NULL            },
{PROPID_MQU_SECURITY     ,MQ_MQU_SECURITY_ATTRIBUTE     ,VT_BLOB            ,MQ_MQU_SECURITY_ADSTYPE    ,NULL                                     ,FALSE     ,TRUE  ,NULL                                    ,NULL         ,NULL            }
};

const defaultVARIANT varDefaultSForeign = { VT_UI1, 0,0,0, 0, 0};
const defaultVARIANT varDefaultSInterval1 = { VT_UI2, 0,0,0, DEFAULT_S_INTERVAL1, 0};
const defaultVARIANT varDefaultSInterval2 = { VT_UI2, 0,0,0, DEFAULT_S_INTERVAL2, 0};


translateProp   SiteTranslateInfo[cSiteTranslateInfoSize] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                     | Set routine | Create routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|-----------------------------------|-------------|----------------|
{PROPID_S_PATHNAME       ,MQ_S_NAME_ATTRIBUTE           ,VT_LPWSTR          ,MQ_S_NAME_ADSTYPE          ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            },
{PROPID_S_SITEID         ,MQ_S_ID_ATTRIBUTE             ,VT_CLSID           ,MQ_S_ID_ADSTYPE            ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            },
{PROPID_S_INTERVAL1      ,MQ_S_INTERVAL1                ,VT_UI2             ,MQ_S_INTERVAL1_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultSInterval1,NULL       ,NULL            },
{PROPID_S_INTERVAL2      ,MQ_S_INTERVAL2                ,VT_UI2             ,MQ_S_INTERVAL2_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultSInterval2,NULL       ,NULL            },
{PROPID_S_SECURITY       ,MQ_S_SECURITY_ATRRIBUTE       ,VT_BLOB            ,MQ_S_SECURITY_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            },
{PROPID_S_FULL_NAME      ,MQ_S_FULL_NAME_ATTRIBUTE      ,VT_LPWSTR          ,MQ_S_FULL_NAME_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            },
{PROPID_S_NT4_STUB       ,MQ_S_NT4_STUB_ATTRIBUTE       ,VT_UI2             ,MQ_S_NT4_STUB_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            },
{PROPID_S_FOREIGN        ,MQ_S_FOREIGN_ATTRIBUTE        ,VT_UI1             ,MQ_S_FOREIGN_ADSTYPE       ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultSForeign,NULL         ,NULL            },                                         
{PROPID_S_DONOTHING      ,NULL                          ,VT_UI1             ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            },
{PROPID_S_SECURITY_INFORMATION  ,NULL                   ,VT_UI1             ,ADSTYPE_INVALID            ,MQADpRetrieveNothing                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            }
};


translateProp   ServerTranslateInfo[cServerTranslateInfoSize] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| default value | Set routine | Create routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|---------------|-------------|----------------|
{PROPID_SRV_NAME         ,MQ_SRV_NAME_ATTRIBUTE         ,VT_LPWSTR          ,MQ_SRV_NAME_ADSTYPE        ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            },
{PROPID_SRV_ID           ,MQ_SRV_ID_ATTRIBUTE           ,VT_CLSID           ,MQ_SRV_ID_ADSTYPE          ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            },                              
{PROPID_SRV_FULL_PATH    ,MQ_SRV_FULL_PATH_ATTRIBUTE    ,VT_LPWSTR          ,MQ_SRV_FULL_PATH_ADSTYPE   ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            }                              
};

translateProp   SettingTranslateInfo[cSettingTranslateInfoSize] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| default value | Set routine | Create routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|---------------|-------------|----------------|
{PROPID_SET_NAME         ,MQ_SET_NAME_ATTRIBUTE         ,VT_LPWSTR          ,MQ_SET_NAME_ADSTYPE        ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            },
{PROPID_SET_OLDSERVICE    ,MQ_SET_SERVICE_ATTRIBUTE      ,VT_UI4             ,MQ_SET_SERVICE_ADSTYPE     ,NULL                                   ,FALSE      ,NULL           ,NULL         ,NULL            },
{PROPID_SET_SERVICE_ROUTING   ,MQ_SET_SERVICE_ROUTING_ATTRIBUTE   ,VT_UI1 ,MQ_SET_SERVICE_ROUTING_ADSTYPE     ,NULL                              ,FALSE      ,NULL           ,NULL         ,NULL            },
{PROPID_SET_SERVICE_DSSERVER  ,MQ_SET_SERVICE_DSSERVER_ATTRIBUTE  ,VT_UI1 ,MQ_SET_SERVICE_DSSERVER_ADSTYPE    ,NULL                              ,FALSE      ,NULL           ,NULL         ,NULL            },
{PROPID_SET_SERVICE_DEPCLIENTS,MQ_SET_SERVICE_DEPCLIENTS_ATTRIBUTE,VT_UI1 ,MQ_SET_SERVICE_DEPCLIENTS_ADSTYPE  ,NULL                              ,FALSE      ,NULL           ,NULL         ,NULL            },
{PROPID_SET_QM_ID        ,MQ_SET_QM_ID_ATTRIBUTE        ,VT_CLSID           ,MQ_SET_QM_ID_ADSTYPE       ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            },
{PROPID_SET_APPLICATION  ,MQ_SET_APPLICATION_ATTRIBUTE  ,VT_LPWSTR          ,MQ_SET_QM_ID_ADSTYPE       ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            },
{PROPID_SET_FULL_PATH    ,MQ_SET_FULL_PATH_ATTRIBUTE    ,VT_LPWSTR          ,MQ_SET_FULL_PATH_ADSTYPE   ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            },          
{PROPID_SET_NT4          ,MQ_SET_NT4_ATTRIBUTE          ,VT_UI4             ,MQ_SET_NT4_ADSTYPE         ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            },
{PROPID_SET_MASTERID     ,MQ_SET_MASTERID_ATTRIBUTE     ,VT_CLSID           ,MQ_SET_MASTERID_ADSTYPE    ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            },
{PROPID_SET_SITENAME     ,MQ_SET_SITENAME_ATTRIBUTE     ,VT_LPWSTR          ,MQ_SET_SITENAME_ADSTYPE    ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            }
};

const defaultVARIANT varDefaultComVersion = { VT_LPWSTR, 0,0,0, (LONG_PTR)TEXT(""), 0};

translateProp ComputerTranslateInfo[cComputerTranslateInfoSize] = {
// PROPID                   | attribute-name                   | vartype           | adstype                       | Translation routine                    | multivalue| InGC | default value                          | Set routine | Create routine |
//--------------------------|----------------------------------|-------------------|-------------------------------|----------------------------------------|-----------|------|----------------------------------------|-------------|----------------|
{PROPID_COM_FULL_PATH       ,MQ_COM_FULL_PATH_ATTRIBUTE        ,VT_LPWSTR          ,MQ_COM_FULL_PATH_ADSTYPE       ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            },
{PROPID_COM_SAM_ACCOUNT     ,MQ_COM_SAM_ACCOUNT_ATTRIBUTE      ,VT_LPWSTR          ,MQ_COM_SAM_ACCOUNT_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            },
{PROPID_COM_CONTAINER       ,NULL                              ,VT_LPWSTR          ,ADSTYPE_INVALID                ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            },
{PROPID_COM_ACCOUNT_CONTROL ,MQ_COM_ACCOUNT_CONTROL_ATTRIBUTE  ,VT_UI4             ,MQ_COM_ACCOUNT_CONTROL_ADSTYPE ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            },
{PROPID_COM_DNS_HOSTNAME    ,MQ_COM_DNS_HOSTNAME_ATTRIBUTE     ,VT_LPWSTR          ,MQ_COM_DNS_HOSTNAME_ADSTYPE    ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            },
{PROPID_COM_SID             ,MQ_COM_SID_ATTRIBUTE              ,VT_BLOB            ,MQ_COM_SID_ADSTYPE             ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            },
{PROPID_COM_SIGN_CERT       ,MQ_COM_SIGN_CERT_ATTRIBUTE        ,VT_BLOB            ,MQ_COM_SIGN_CERT_ADSTYPE       ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserSignCert ,NULL         ,NULL            },
{PROPID_COM_DIGEST          ,MQ_COM_DIGEST_ATTRIBUTE           ,VT_CLSID|VT_VECTOR ,MQ_COM_DIGEST_ADSTYPE          ,NULL                                    ,TRUE       ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserDigest   ,NULL         ,NULL            },
{PROPID_COM_ID              ,MQ_COM_ID_ATTRIBUTE               ,VT_CLSID           ,MQ_COM_ID_ADSTYPE              ,NULL                                    ,FALSE      ,TRUE  ,NULL                                    ,NULL         ,NULL            },
{PROPID_COM_VERSION         ,MQ_COM_VERSION_ATTRIBUTE          ,VT_LPWSTR          ,MQ_COM_VERSION_ADSTYPE         ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultComVersion   ,NULL         ,NULL            }
};

//-----------------------------------------------------
// Helper macro to get the number of elements in a static array
//
//-----------------------------------------------------
#define ARRAY_SIZE(array)   (sizeof(array)/sizeof(array[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\tranrout.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tranrout.h

Abstract:

    Translation routines for properties not in NT5 DS

Author:

    ronit hartmann ( ronith)

--*/
#ifndef __tranrout_h__
#define __tranrout_h__
#include "traninfo.h"


HRESULT WINAPI MQADpRetrieveEnterpriseName(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant);



HRESULT WINAPI MQADpRetrieveSiteInterval1(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADpRetrieveSiteInterval2(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant);



HRESULT WINAPI MQADpRetrieveQueueQMid(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant);


HRESULT WINAPI MQADpRetrieveQueueName(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 LPCWSTR             pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADpRetrieveQueueDNSName(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADpRetrieveQueueADSPath(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADpRetrieveNothing(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADpRetrieveLinkNeighbor1(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADpRetrieveLinkNeighbor2(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADpRetrieveLinkGates(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADpSetLinkNeighbor1(
                 IN IADs *             pAdsObj,
                 IN LPCWSTR            pwcsDomainController,
                 IN bool			   fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADpCreateLinkNeighbor1(
                 IN const PROPVARIANT *pPropVar,
                 IN  LPCWSTR           pwcsDomainController,
                 IN  bool			   fServerName,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADpSetLinkNeighbor2(
                 IN IADs *             pAdsObj,
                 IN LPCWSTR            pwcsDomainController,
                 IN bool			   fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADpCreateLinkNeighbor2(
                 IN const PROPVARIANT *pPropVar,
                 IN  LPCWSTR           pwcsDomainController,
                 IN  bool			   fServerName,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADpRetrieveLinkCost(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADpSetLinkCost(
                 IN IADs *             pAdsObj,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADpCreateLinkCost(
                 IN const PROPVARIANT *pPropVar,
                 IN  LPCWSTR           pwcsDomainController,
                 IN  bool			   fServerName,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\tranrout.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tranrout.cpp

Abstract:


    Translation routines for properties not in NT5 DS


Author:

    ronit hartmann ( ronith)

--*/

#include "ds_stdh.h"
#include "mqads.h"
#include "mqadglbo.h"
#include <winsock.h>
#include "mqadp.h"
#include "mqattrib.h"
#include "xlatqm.h"
#include "_propvar.h"

#include "tranrout.tmh"

static WCHAR *s_FN=L"mqad/tranrout";

/*====================================================

MQADpRetrieveEnterpriseName

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpRetrieveEnterpriseName(
                 IN  CObjXlateInfo * /*pcObjXlateInfo*/,
                 IN  LPCWSTR         /*pwcsDomainController*/,
                 IN bool			 /*fServerName*/,
                 OUT PROPVARIANT *   ppropvariant
				 )
{
    DWORD len = wcslen( g_pwcsDsRoot);
    ppropvariant->pwszVal = new WCHAR[ len+ 1];
    wcscpy( ppropvariant->pwszVal, g_pwcsDsRoot);
    ppropvariant->vt = VT_LPWSTR;
    return(MQ_OK);
}



/*====================================================

MQADpRetrieveNothing

Arguments:

Return Value:

=====================================================*/

HRESULT WINAPI MQADpRetrieveNothing(
                 IN  CObjXlateInfo * /*pcObjXlateInfo*/,
                 IN  LPCWSTR         /*pwcsDomainController*/,
                 IN bool			 /*fServerName*/,
                 OUT PROPVARIANT *   ppropvariant)
{
    ppropvariant->vt = VT_EMPTY ;
    return MQ_OK ;
}

/*====================================================

MQADpRetrieveQueueQMid

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpRetrieveQueueQMid(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
				 IN  bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant
				 )
{
    const WCHAR * pchar = pcObjXlateInfo->ObjectDN();
    //
    //  Skip the queue name
    //
    while ( *pchar != L',')
    {
        pchar++;
    }
    pchar++;

    PROPID prop = PROPID_QM_MACHINE_ID;
    //
    //  To be on the safe side we'd better leave the vt as is, cause it can also be VT_CLSID
    //  if prop requestor allocated the guid (common practice).
    //  The propvariant in this translation routine is the prop requestor propvariant.
    //

    //
    //  Is the computer in the local domain?
    //
    const WCHAR * pwcsQueueName = pcObjXlateInfo->ObjectDN();
    WCHAR * pszDomainName = wcsstr(pwcsQueueName, x_DcPrefix);
    ASSERT(pszDomainName) ;
    HRESULT hr;

    CMqConfigurationObject object(NULL, NULL, pwcsDomainController, fServerName);
    object.SetObjectDN( pchar);

	AP<WCHAR> pwcsLocalDsRootToFree;
	LPWSTR pwcsLocalDsRoot = NULL;
	hr = g_AD.GetLocalDsRoot(
				pwcsDomainController, 
				fServerName,
				&pwcsLocalDsRoot,
				pwcsLocalDsRootToFree
				);

	if(FAILED(hr))
	{
		TrERROR(mqad, "Failed to get Local Ds Root, hr = 0x%x", hr);
	}

    if (SUCCEEDED(hr) && (!wcscmp( pszDomainName, pwcsLocalDsRoot))) 
    {
        //
        //   try local DC
        //

        hr =g_AD.GetObjectProperties(
                adpDomainController,
                &object,
                1,
                &prop,
                ppropvariant);         // output variant array

    }
    else
    {
        hr =g_AD.GetObjectProperties(
            adpGlobalCatalog,	
            &object,
            1,
            &prop,
            ppropvariant);         // output variant array
    }
    return LogHR(hr, s_FN, 30);
}

/*====================================================

MQADpRetrieveQueueName

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpRetrieveQueueName(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 LPCWSTR             pwcsDomainController,
                 IN bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant
				 )
{
      const WCHAR * pchar = pcObjXlateInfo->ObjectDN();
      //
      //    Parse the distinguished name of a queue and
      //    build pathname
      //

      //
      //    Find queue name
      //
      const WCHAR * pwcsStartQueue = pchar + x_CnPrefixLen;
      const WCHAR * pwcsEndQueue =  pwcsStartQueue;
      while ( *pwcsEndQueue != ',')
      {
            pwcsEndQueue++;
      }
      //
      //    Find machine name
      //
      const WCHAR * pwcsStartMachine = pwcsEndQueue + 2*(1 + x_CnPrefixLen)
                        + x_MsmqComputerConfigurationLen;    // skip msmq-configuration
      const WCHAR * pwcsEndMachine = pwcsStartMachine;
      while ( *pwcsEndMachine != ',')
      {
            pwcsEndMachine++;
      }
      //
      //    Is the queue name splitted between two attributes?
      //
      AP<WCHAR> pwcsNameExt;
      DWORD dwNameExtLen = 0;
      if (( pwcsEndQueue - pwcsStartQueue) == x_PrefixQueueNameLength +1)
      {
          //
          //    read the queue name ext attribute
          //
          PROPVARIANT varNameExt;
          varNameExt.vt = VT_NULL;
          HRESULT hr = pcObjXlateInfo->GetDsProp(
							MQ_Q_NAME_EXT,
							pwcsDomainController,
							fServerName,
							ADSTYPE_CASE_EXACT_STRING,
							VT_LPWSTR,
							FALSE,
							&varNameExt
							);
          if ( hr ==  E_ADS_PROPERTY_NOT_FOUND)
          {
              varNameExt.pwszVal = NULL;
              hr = MQ_OK;
          }

          if (FAILED(hr))
          {
              return LogHR(hr, s_FN, 40);
          }
          pwcsNameExt = varNameExt.pwszVal;
          if (  pwcsNameExt != NULL)
          {
              dwNameExtLen = wcslen( pwcsNameExt);
              //
              //    ignore the guid that we added to the first part of the
              //    the queue name
              //
              pwcsEndQueue -= x_SplitQNameIdLength;
          }
      }

      ppropvariant->pwszVal = new WCHAR[2 + (pwcsEndMachine - pwcsStartMachine)
                                          + (pwcsEndQueue - pwcsStartQueue) + dwNameExtLen];
      //
      //    build queue pathname ( m1\q1)
      //
      WCHAR * ptmp =  ppropvariant->pwszVal;
      memcpy( ptmp, pwcsStartMachine, sizeof(WCHAR)*(pwcsEndMachine - pwcsStartMachine));
      ptmp += (pwcsEndMachine - pwcsStartMachine );
      *ptmp = PN_DELIMITER_C;
      ptmp++;

      //
      //    skip escape chars
      //
      while (pwcsStartQueue < pwcsEndQueue) 
      {
          if (*pwcsStartQueue != L'\\')
          {
            *ptmp = *pwcsStartQueue;
            ptmp++;
          }
          pwcsStartQueue++;

      }

      if ( dwNameExtLen > 0)
      {
        memcpy( ptmp, pwcsNameExt, sizeof(WCHAR)*dwNameExtLen);
      }
      ptmp += dwNameExtLen;
      *ptmp = '\0';
      CharLower( ppropvariant->pwszVal);

      ppropvariant->vt = VT_LPWSTR;
      return(MQ_OK);
}

/*====================================================

MQADpRetrieveQueueDNSName

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpRetrieveQueueDNSName(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
                 IN bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant
				 )
{
      const WCHAR * pchar = pcObjXlateInfo->ObjectDN();
      //
      //    Parse the distinguished name of a queue and
      //    get the queue name from it, for the DNS name of
      //    the computer, retrieve dNSHostName
      //

      //
      //    Find queue name
      //
      const WCHAR * pwcsStartQueue = pchar + x_CnPrefixLen;
      const WCHAR * pwcsEndQueue =  pwcsStartQueue;
      while ( *pwcsEndQueue != ',')
      {
            pwcsEndQueue++;
      }
      const WCHAR * pwcsComputerName = pwcsEndQueue + 2 + x_CnPrefixLen
                        + x_MsmqComputerConfigurationLen;    // skip msmq-configuration
      //
      //    Is the queue name splitted between two attributes?
      //
      AP<WCHAR> pwcsNameExt;
      DWORD dwNameExtLen = 0;
      if (( pwcsEndQueue - pwcsStartQueue) == x_PrefixQueueNameLength +1)
      {
          //
          //    read the queue name ext attribute
          //
          PROPVARIANT varNameExt;
          varNameExt.vt = VT_NULL;
          HRESULT hr = pcObjXlateInfo->GetDsProp(
							MQ_Q_NAME_EXT,
							pwcsDomainController,
							fServerName,
							ADSTYPE_CASE_EXACT_STRING,
							VT_LPWSTR,
							FALSE,
							&varNameExt
							);
          if ( hr ==  E_ADS_PROPERTY_NOT_FOUND)
          {
              varNameExt.pwszVal = NULL;
              hr = MQ_OK;
          }

          if (FAILED(hr))
          {
              return LogHR(hr, s_FN, 50);
          }
          pwcsNameExt = varNameExt.pwszVal;
          if (  pwcsNameExt != NULL)
          {
              dwNameExtLen = wcslen( pwcsNameExt);
              //
              //    ignore the guid that we added to the first part of the
              //    the queue name
              //
              pwcsEndQueue -= x_SplitQNameIdLength;
          }
      }
      //
      //    Read the computer DNS name
      //
      AP<WCHAR> pwcsDnsName;

      HRESULT hr =  MQADpGetComputerDns(
							pwcsComputerName,
							pwcsDomainController,
							fServerName,
							&pwcsDnsName
							);

     if ( hr == HRESULT_FROM_WIN32(E_ADS_PROPERTY_NOT_FOUND))
      {
          //
          //    The dNSHostName attribute doesn't have value
          //
          ppropvariant->vt = VT_EMPTY;
          return MQ_OK;
      }
      if (FAILED(hr))
      {
          return LogHR(hr, s_FN, 60);
      }
      DWORD lenComputer = wcslen(pwcsDnsName);

      ppropvariant->pwszVal = new WCHAR[2 + lenComputer
                                          + (pwcsEndQueue - pwcsStartQueue) + dwNameExtLen];
      //
      //    build queue pathname ( m1\q1)
      //
      WCHAR * ptmp =  ppropvariant->pwszVal;
      wcscpy( ptmp, pwcsDnsName);
      ptmp += lenComputer;
      *ptmp = PN_DELIMITER_C;
      ptmp++;
      memcpy( ptmp, pwcsStartQueue, sizeof(WCHAR)*(pwcsEndQueue - pwcsStartQueue));
      ptmp += (pwcsEndQueue - pwcsStartQueue );
      if ( dwNameExtLen > 0)
      {
        memcpy( ptmp, pwcsNameExt, sizeof(WCHAR)*dwNameExtLen);
      }
      ptmp += dwNameExtLen;
      *ptmp = '\0';
      CharLower( ppropvariant->pwszVal);

      ppropvariant->vt = VT_LPWSTR;
      return(MQ_OK);
}

/*====================================================

MQADpRetrieveQueueADSPath

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpRetrieveQueueADSPath(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         /*pwcsDomainController*/,
                 IN bool			 /*fServerName*/,
                 OUT PROPVARIANT *   ppropvariant
				 )
{
      const WCHAR * pchar = pcObjXlateInfo->ObjectDN();

      //
      // Add LDAP:// prefix
      //
      DWORD len = x_LdapProviderLen + wcslen(pchar) + 1;

      ppropvariant->pwszVal = new WCHAR[len];

        DWORD dw = swprintf(
             ppropvariant->pwszVal,
             L"%s%s",
             x_LdapProvider,
             pchar
            );
        DBG_USED(dw);
		ASSERT( dw < len);

        ppropvariant->vt = VT_LPWSTR;
        return MQ_OK;
}




/*====================================================

RetrieveSiteLink

Arguments:

Return Value:

=====================================================*/
static
HRESULT 
RetrieveSiteLink(
           IN  CObjXlateInfo *  pcObjXlateInfo,
           IN  LPCWSTR          pwcsDomainController,
           IN bool			    fServerName,
           IN  LPCWSTR          pwcsAttributeName,
           OUT MQPROPVARIANT *  ppropvariant
           )
{
    HRESULT hr;

    MQPROPVARIANT varSiteDn;
    varSiteDn.vt = VT_NULL;
    //
    //  Retrieve the DN of the site-link
    //
    hr = pcObjXlateInfo->GetDsProp(
				pwcsAttributeName,
				pwcsDomainController,
				fServerName,
				ADSTYPE_DN_STRING,
				VT_LPWSTR,
				FALSE,
				&varSiteDn
				);
    if (FAILED(hr))
    {
        //
        //  Site-link is a mandatory property, therefore if not found it is
        //  a problem
        //
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("RetrieveSiteLink:GetDsProp(%ls)=%lx"), pwcsAttributeName, hr));
        return LogHR(hr, s_FN, 70);
    }
    AP<WCHAR> pClean = varSiteDn.pwszVal;

    //
    //  Translate the DN of the site link into unique id
    //
    PROPID prop = PROPID_S_SITEID;
    CSiteObject object(NULL, NULL, pwcsDomainController, fServerName);
    object.SetObjectDN( varSiteDn.pwszVal);

    
    hr = g_AD.GetObjectProperties(
                adpDomainController,
                &object,
                1,
                &prop,
                ppropvariant
                );
    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) || 
         hr == HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX))
    {
        //
        //  To enable admin to identify a state where one
        //  of the link's sites was deleted.
        //
        ppropvariant->vt = VT_EMPTY;
        ppropvariant->pwszVal = NULL;
        hr = MQ_OK;   // go on to next result
    }
    return LogHR(hr, s_FN, 80);
}

/*====================================================

MQADpRetrieveLinkNeighbor1

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpRetrieveLinkNeighbor1(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
                 IN bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant
				 )
{
    HRESULT hr2 = RetrieveSiteLink(
						pcObjXlateInfo,
						pwcsDomainController,
						fServerName,
						MQ_L_NEIGHBOR1_ATTRIBUTE,
						ppropvariant
						);
    return LogHR(hr2, s_FN, 90);
}

/*====================================================

MQADpRetrieveLinkNeighbor2

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpRetrieveLinkNeighbor2(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
                 IN bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant)
{
    HRESULT hr2 = RetrieveSiteLink(
						pcObjXlateInfo,
						pwcsDomainController,
						fServerName,
						MQ_L_NEIGHBOR2_ATTRIBUTE,
						ppropvariant
						);
    return LogHR(hr2, s_FN, 100);
}

/*====================================================

MQADpRetrieveLinkGates

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpRetrieveLinkGates(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
                 IN bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant
				 )
{
    HRESULT hr;

    CMQVariant varLinkGatesDN;
    //
    //  Retrieve the link gates DNs
    //
    hr = pcObjXlateInfo->GetDsProp(
				MQ_L_SITEGATES_ATTRIBUTE,
				pwcsDomainController,
				fServerName,
				MQ_L_SITEGATES_ADSTYPE,
				VT_LPWSTR|VT_VECTOR,
				TRUE,
				varLinkGatesDN.CastToStruct()
				);

    if ( hr ==  E_ADS_PROPERTY_NOT_FOUND)
    {
      ppropvariant->cauuid.pElems = NULL;
      ppropvariant->cauuid.cElems = 0;
      ppropvariant->vt = VT_CLSID|VT_VECTOR;
      return MQ_OK;
    }

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 180);
    }

    //
    //  Translate the gates DNs to gates-ids
    //
    hr =  MQADpTranslateGateDn2Id(
                pwcsDomainController,
				fServerName,
                varLinkGatesDN.CastToStruct(),
                &ppropvariant->cauuid.pElems,
                &ppropvariant->cauuid.cElems
                );
    if (SUCCEEDED(hr))
    {
        ppropvariant->vt = VT_CLSID|VT_VECTOR;
    }
    return LogHR(hr, s_FN, 190);
}


/*====================================================

MQADpSetLinkNeighbor

Arguments:

Return Value:

=====================================================*/
static 
HRESULT 
MQADpSetLinkNeighbor(
	IN const PROPVARIANT *pPropVar,
	IN  LPCWSTR           pwcsDomainController,
	IN bool				  fServerName,
	OUT PROPVARIANT      *pNewPropVar
	)
{
    PROPID prop = PROPID_S_FULL_NAME;
    pNewPropVar->vt = VT_NULL;
    CSiteObject object(NULL, pPropVar->puuid, pwcsDomainController, fServerName);

    HRESULT hr2 =g_AD.GetObjectProperties(
                    adpDomainController,	
                    &object,
                    1,
                    &prop,
                    pNewPropVar);
    return LogHR(hr2, s_FN, 110);
}
/*====================================================

MQADpCreateLinkNeighbor1

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpCreateLinkNeighbor1(
                 IN const PROPVARIANT *pPropVar,
                 IN  LPCWSTR           pwcsDomainController,
                 IN  bool			   fServerName,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    *pdwNewPropID = PROPID_L_NEIGHBOR1_DN;
    HRESULT hr2 = MQADpSetLinkNeighbor(
                    pPropVar,
                    pwcsDomainController,
                    fServerName,
                    pNewPropVar
					);
    return LogHR(hr2, s_FN, 120);
}

/*====================================================

MQADpSetLinkNeighbor1

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpSetLinkNeighbor1(
                 IN IADs *             pAdsObj,
                 IN LPCWSTR            pwcsDomainController,
                 IN bool			   fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    UNREFERENCED_PARAMETER( pAdsObj);
    HRESULT hr2 = MQADpCreateLinkNeighbor1(
                    pPropVar,
                    pwcsDomainController,
					fServerName,
					pdwNewPropID,
                    pNewPropVar
					);
    return LogHR(hr2, s_FN, 130);
}
/*====================================================

MQADpCreateLinkNeighbor2

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpCreateLinkNeighbor2(
                 IN const PROPVARIANT *pPropVar,
                 IN  LPCWSTR           pwcsDomainController,
                 IN bool			   fServerName,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    *pdwNewPropID = PROPID_L_NEIGHBOR2_DN;
    HRESULT hr2 = MQADpSetLinkNeighbor(
                    pPropVar,
                    pwcsDomainController,
					fServerName,
                    pNewPropVar
					);
    return LogHR(hr2, s_FN, 140);
}

/*====================================================

MQADpSetLinkNeighbor2

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpSetLinkNeighbor2(
                 IN IADs *             pAdsObj,
                 IN  LPCWSTR           pwcsDomainController,
                 IN bool			   fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    UNREFERENCED_PARAMETER( pAdsObj);
    HRESULT hr2 = MQADpCreateLinkNeighbor2(
                    pPropVar,
                    pwcsDomainController,
					fServerName,
					pdwNewPropID,
                    pNewPropVar
					);
    return LogHR(hr2, s_FN, 150);
}

static
BOOL 
IsNeighborForeign(
           IN  CObjXlateInfo *  pcObjXlateInfo,
           IN  LPCWSTR          pwcsDomainController,
           IN  bool			    fServerName,
           IN  LPCWSTR          pwcsAttributeName
           )
{
    //
    //  Check if a site-link neighbor is a foreign site
    //  BUGBUG : future improvment- to cache foreign site info.
    //
    //  Start with getting the neighbor's site-id
    //  
    PROPVARIANT varNeighbor;
    GUID    guidNeighbor;
    varNeighbor.vt = VT_CLSID;
    varNeighbor.puuid = &guidNeighbor;
    HRESULT hr;
    hr = RetrieveSiteLink(
                pcObjXlateInfo,
                pwcsDomainController,
				fServerName,
                pwcsAttributeName,
                &varNeighbor
                );

    if (FAILED(hr))
    {
        //
        //  Assume it is not a foreign site
        //
        return FALSE;
    }
    //
    //  Is it a foreign site?
    //
    PROPID prop = PROPID_S_FOREIGN;
    PROPVARIANT var;
    var.vt = VT_NULL;
    CSiteObject object( NULL, &guidNeighbor, pwcsDomainController, fServerName);
    hr =g_AD.GetObjectProperties(
                adpDomainController,
                &object,
                1,
                &prop,
                &var
                );
    if (FAILED(hr))
    {
        //
        //  assume it is no a foreign site
        //
        return FALSE;
    }
    return (var.bVal > 0);
}


/*====================================================

MQADpRetrieveLinkCost

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpRetrieveLinkCost(
                 IN  CObjXlateInfo * pcObjXlateInfo,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT *   ppropvariant
				 )
{
    //
    //  Is it a link to a foreign site, if yes increment the cost
    //  otherwise return the cost as is.
    //

    //
    //  First read the cost
    //
    HRESULT hr;
    hr = pcObjXlateInfo->GetDsProp(
				MQ_L_COST_ATTRIBUTE,
				pwcsDomainController,
				fServerName,
				MQ_L_COST_ADSTYPE,
				VT_UI4,
				FALSE,
				ppropvariant
				);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }

    if (IsNeighborForeign(
			pcObjXlateInfo,
			pwcsDomainController,
			fServerName,
			MQ_L_NEIGHBOR1_ATTRIBUTE
			))
    {
        //
        //  For a link to foreign site, increment the cost to prevent
        //  routing through it
        //
        ppropvariant->ulVal += MQ_MAX_LINK_COST;
        return MQ_OK;
    }
    if (IsNeighborForeign(
			pcObjXlateInfo,
			pwcsDomainController,
			fServerName,
			MQ_L_NEIGHBOR2_ATTRIBUTE
			))
    {
        //
        //  For a link to foreign site, increment the cost to prevent
        //  routing through it
        //
        ppropvariant->ulVal += MQ_MAX_LINK_COST;
        return MQ_OK;
    }
    return MQ_OK;
}
/*====================================================

MQADpCreateLinkCost

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpCreateLinkCost(
                 IN const PROPVARIANT *pPropVar,
                 IN  LPCWSTR           /* pwcsDomainController*/,
                 IN  bool			   /* fServerName */,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    //
    //  Just set the PROPID_L_ACTUAL_COST
    //  This support is required for MSMQ 1.0 explorer
    //
    *pdwNewPropID = PROPID_L_ACTUAL_COST;
    *pNewPropVar = *pPropVar;
    return MQ_OK;
}

/*====================================================

MQADpSetLinkCost

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpSetLinkCost(
                 IN IADs *             pAdsObj,
                 IN LPCWSTR            pwcsDomainController,
                 IN bool			   fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    //
    //  Just set the PROPID_L_ACTUAL_COST
    //  This support is required for MSMQ 1.0 explorer
    //
    UNREFERENCED_PARAMETER( pAdsObj);
	HRESULT hr2 = MQADpCreateLinkCost(
						pPropVar,
						pwcsDomainController,
						fServerName,
						pdwNewPropID,
						pNewPropVar
						);
    return LogHR(hr2, s_FN, 170);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\sttngobj.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    confobj.cpp

Abstract:

    Implementation of CSettingObject class.

Author:

    ronith

--*/
#include "ds_stdh.h"
#include "baseobj.h"
#include "mqattrib.h"
#include "mqadglbo.h"

#include "sttngobj.tmh"

static WCHAR *s_FN=L"mqad/sttngobj";

DWORD CSettingObject::m_dwCategoryLength = 0;
AP<WCHAR> CSettingObject::m_pwcsCategory = NULL;


CSettingObject::CSettingObject( 
                    LPCWSTR         pwcsPathName,
                    const GUID *    pguidObject,
                    LPCWSTR         pwcsDomainController,
					bool		    fServerName
                    ) : CBasicObjectType( 
								pwcsPathName, 
								pguidObject,
								pwcsDomainController,
								fServerName
								)
/*++
    Abstract:
	constructor of setting object

    Parameters:
    LPCWSTR       pwcsPathName - the object MSMQ name
    const GUID *  pguidObject  - the object unique id
    LPCWSTR       pwcsDomainController - the DC name against
	                             which all AD access should be performed
    bool		   fServerName - flag that indicate if the pwcsDomainController
							     string is a server name

    Returns:
	none

--*/
{
}

CSettingObject::~CSettingObject()
/*++
    Abstract:
	destructor of site object

    Parameters:
	none

    Returns:
	none
--*/
{
	//
	// nothing to do ( everything is released with automatic pointers
	//
}

HRESULT CSettingObject::ComposeObjectDN()
/*++
    Abstract:
	Composed distinguished name of the settings object

    Parameters:
	none

    Returns:
	none
--*/
{
    ASSERT(0);
    LogIllegalPoint(s_FN, 81);
    return MQ_ERROR_DS_ERROR;
}

HRESULT CSettingObject::ComposeFatherDN()
/*++
    Abstract:
	Composed distinguished name of the parent of settings object

    Parameters:
	none

    Returns:
	none
--*/
{
    ASSERT(0);
    LogIllegalPoint(s_FN, 82);
    return MQ_ERROR_DS_ERROR;
}

LPCWSTR CSettingObject::GetRelativeDN()
/*++
    Abstract:
	return the RDN of the settings object

    Parameters:
	none

    Returns:
	LPCWSTR settings RDN
--*/
{
    return x_MsmqSettingName;
}

DS_CONTEXT CSettingObject::GetADContext() const
/*++
    Abstract:
	Returns the AD context where setting object should be looked for

    Parameters:
	none

    Returns:
	DS_CONTEXT
--*/
{
    return e_SitesContainer;
}

bool CSettingObject::ToAccessDC() const
/*++
    Abstract:
	returns whether to look for the object in DC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	true (i.e. to look for the object in any DC)
--*/
{
    //
    //  configuration container is on every DC
    //
    return true;
}

bool CSettingObject::ToAccessGC() const
/*++
    Abstract:
	returns whether to look for the object in GC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	false 
--*/
{
    return false;
}

void CSettingObject::ObjectWasFoundOnDC()
/*++
    Abstract:
	The object was found on DC, this is not relevant for setting object 
    (i.e. it is always looked for in DC only)


    Parameters:
	none

    Returns:
	none
--*/
{
}


LPCWSTR CSettingObject::GetObjectCategory() 
/*++
    Abstract:
	prepares and retruns the object category string

    Parameters:
	none

    Returns:
	LPCWSTR object category string
--*/
{
    if (CSettingObject::m_pwcsCategory == NULL)
    {
        DWORD len = wcslen(g_pwcsSchemaContainer) + wcslen(x_SettingsCategoryName) + 2;

        AP<WCHAR> pwcsCategory = new WCHAR[len];
        DWORD dw = swprintf(
             pwcsCategory,
             L"%s,%s",
             x_SettingsCategoryName,
             g_pwcsSchemaContainer
            );
        DBG_USED(dw);
		ASSERT( dw < len);

        if (NULL == InterlockedCompareExchangePointer(
                              &CSettingObject::m_pwcsCategory.ref_unsafe(), 
                              pwcsCategory.get(),
                              NULL
                              ))
        {
            pwcsCategory.detach();
            CSettingObject::m_dwCategoryLength = len;
        }
    }
    return CSettingObject::m_pwcsCategory;
}

DWORD   CSettingObject::GetObjectCategoryLength()
/*++
    Abstract:
	prepares and retruns the length object category string

    Parameters:
	none

    Returns:
	DWORD object category string length
--*/
{
	//
	//	call GetObjectCategory in order to initailaze category string
	//	and length
	//
	GetObjectCategory();

    return CSettingObject::m_dwCategoryLength;
}

AD_OBJECT CSettingObject::GetObjectType() const
/*++
    Abstract:
	returns the object type

    Parameters:
	none

    Returns:
	AD_OBJECT
--*/
{
    return eSETTING;
}
LPCWSTR CSettingObject::GetClass() const
/*++
    Abstract:
	returns a string represinting the object class in AD

    Parameters:
	none

    Returns:
	LPCWSTR object class string
--*/
{
    return MSMQ_SETTING_CLASS_NAME;
}

DWORD CSettingObject::GetMsmq1ObjType() const
/*++
    Abstract:
	returns the object type in MSMQ 1.0 terms

    Parameters:
	none

    Returns:
	DWORD 
--*/
{
    ASSERT(0);
    return 0;
}

HRESULT CSettingObject::SetObjectSecurity(
            IN  SECURITY_INFORMATION        /*RequestedInformation*/,
            IN  const PROPID                /*prop*/,
            IN  const PROPVARIANT *         /*pVar*/,
            IN OUT MQDS_OBJ_INFO_REQUEST *  /*pObjInfoRequest*/, 
            IN OUT MQDS_OBJ_INFO_REQUEST *  /*pParentInfoRequest*/
            )
/*++

Routine Description:
    The routine sets object security in AD 

Arguments:
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - infomation about the object
    MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - information about the object's parent

Return Value
	HRESULT

--*/
{
    //
    //  This operation is not supported
    //
    return MQ_ERROR_FUNCTION_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\updtallw.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
    updtallw.cpp

Abstract:
    Verify if update operation is allowed on the requested object

Author:

    Ronith

--*/
#include "ds_stdh.h"

#include "updtallw.h"
#include <_mqini.h>
#include "dsutils.h"
#include "mqad.h"
#include <_registr.h>
#include "mqlog.h"
#include "mqadglbo.h"

#include "updtallw.tmh"

static WCHAR *s_FN=L"mqad/updtallw";


const PROPID x_rgNT4SitesPropIDs[] = {PROPID_SET_MASTERID,
                                      PROPID_SET_FULL_PATH,
                                      PROPID_SET_QM_ID};
enum
{
    e_NT4SitesProp_MASTERID,
    e_NT4SitesProp_FULL_PATH,
    e_NT4SitesProp_QM_ID,
};
const MQCOLUMNSET x_columnsetNT4Sites = {ARRAY_SIZE(x_rgNT4SitesPropIDs), const_cast<PROPID *>(x_rgNT4SitesPropIDs)};



CVerifyObjectUpdate::CVerifyObjectUpdate(void):
            m_fInited(false),
			m_dwLastRefreshNT4Sites(0),
			m_dwRefreshNT4SitesInterval(MSMQ_DEFAULT_NT4SITES_ADSSEARCH_INTERVAL * 1000),
			m_fMixedMode(false)
 
{
}


CVerifyObjectUpdate::~CVerifyObjectUpdate(void)
{
}


HRESULT CVerifyObjectUpdate::Initialize()
{

    if (m_fInited)
    {
        return MQ_OK;
    }

    //
    //  Read RefreshNT4SitesInterval key.
    //  This key is optional and may not be in registry. We dont accept 0 (zero).
    //
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    DWORD dwRefreshNT4SitesInterval;
    long rc = GetFalconKeyValue( MSMQ_NT4SITES_ADSSEARCH_INTERVAL_REGNAME, &dwType, &dwRefreshNT4SitesInterval, &dwSize);
    if ((rc == ERROR_SUCCESS) && (dwRefreshNT4SitesInterval > 0))
    {
        m_dwRefreshNT4SitesInterval = dwRefreshNT4SitesInterval * 1000;
    }

    //
    //  Build NT4Sites map, and associated data
    //
    HRESULT hr = RefreshNT4Sites();
	if(FAILED(hr))
	{
		return hr;
	}

    {
        //
        // Protect access to map pointer
        //
        CS cs(m_csNT4Sites);
	    ASSERT(m_pmapNT4Sites != NULL);
	    if(m_pmapNT4Sites->GetCount() > 0) 
	    {
		    //
		    // There are NT4 Sites
		    //
		    m_fMixedMode = true;
	    }

        m_fInited = true;
    }
    return MQ_OK;
}

bool CVerifyObjectUpdate::IsObjectTypeAlwaysAllowed(
            AD_OBJECT       eObject
            )
{
    //
    //  Only for queues and machines we need to chaeck who owns them.
    //  For other object types are owned by PEC, and in mixed mode the PEC
    //  is already migrated to NT5 \Whistler
    //
    switch( eObject)
    {
        case eQUEUE:
        case eMACHINE:
            return false;
        default:
            return true;
    }
}


bool CVerifyObjectUpdate::IsUpdateAllowed(
            AD_OBJECT          eObject,
            CBasicObjectType * pObject
            )
{
    //
    // sanity check
    //
    if (!m_fInited)
    {
        DBGMSG((DBGMOD_DS, DBGLVL_WARNING, TEXT("CVerifyObjectUpdate::IsUpdateAllowed CVerifyObjectUpdate is not initialized")));
        return false;
    }

    //
    // if we're not in mixed mode, return
    //
    if (!m_fMixedMode)
    {
        return true;
    }
    //
    // Is the object type is such that there is no need to continue checking
    //
    if (IsObjectTypeAlwaysAllowed(eObject))
    {
        return true;
    }

    bool fIsOwnedByNT4Site;

    HRESULT hr;

    switch (eObject)
    {
    case eQUEUE:
        hr = CheckQueueIsOwnedByNT4Site(pObject,
                                        &fIsOwnedByNT4Site
                                        );
        if (FAILED(hr))
        {
            LogHR(hr, s_FN, 345);
            return false;
        } 
        break;

    case eMACHINE:
        hr = CheckMachineIsOwnedByNT4Site(pObject,
                                          &fIsOwnedByNT4Site
                                          );
        if (FAILED(hr))
        {
            LogHR(hr, s_FN, 350);
            return false;
        }
        break;

    default:
        ASSERT(0);
        LogHR(MQ_ERROR_DS_ERROR, s_FN, 360);
        return true;
        break;
    }

    return !fIsOwnedByNT4Site;
}

bool CVerifyObjectUpdate::IsCreateAllowed(
            AD_OBJECT          eObject,
            CBasicObjectType * pObject
            )
{
    //
    // sanity check
    //
    if (!m_fInited)
    {
        DBGMSG((DBGMOD_DS, DBGLVL_WARNING, TEXT("CVerifyObjectUpdate::IsCreateAllowed CVerifyObjectUpdate is not initialized")));
        return false;
    }

    //
    // if we're not in mixed mode, return
    //
    if (!m_fMixedMode)
    {
        return true;
    }
    //
    // Is the object type is such that there is no need to continue checking
    //
    if (eObject != eQUEUE)
    {
        return true;
    }

	//
	// Need to check that the machine is not own by NT4 site in order to allow
	// create queue
	//
	HRESULT hr = pObject->ComposeFatherDN();
	if(FAILED(hr))
	{
		return false;
	}

	P<CMqConfigurationObject> pMachineObject = new CMqConfigurationObject(
														NULL, 
														NULL, 
														pObject->GetDomainController(),
														pObject->IsServerName()
														);

	pMachineObject->SetObjectDN(pObject->GetObjectParentDN());

    bool fIsOwnedByNT4Site;

    hr = CheckMachineIsOwnedByNT4Site(
				pMachineObject,
				&fIsOwnedByNT4Site
				);
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 340);
        return false;
    } 

    return !fIsOwnedByNT4Site;
}





HRESULT CVerifyObjectUpdate::RefreshNT4Sites()
/*++

Routine Description:
    Refreshes the NT4 PSC maps from the DS, incase a predefined time has passed since the last refresh.
    It does that by building new maps, and replacing the old ones.

Arguments:

Return Value:
    none
--*/
{
	//
	// Should be in mixed mode or first time
	//
    ASSERT((m_fMixedMode == true) || (m_dwLastRefreshNT4Sites == 0));

    //
    // ignore refresh if last refresh was done and recently
    // Capture last refresh time for concurency.
    //
    DWORD dwTickCount = GetTickCount();
    DWORD dwLastRefreshNT4Sites =  m_dwLastRefreshNT4Sites;

    if ((dwLastRefreshNT4Sites != 0) &&
        (dwTickCount >= dwLastRefreshNT4Sites) &&
        (dwTickCount - dwLastRefreshNT4Sites < m_dwRefreshNT4SitesInterval))
    {
        return MQ_OK;
    }

    //
    // create a new map for NT4 PSCs
    //

    HRESULT hr;
    P<NT4Sites_CMAP> pmapNT4SitesNew;
    hr = CreateNT4SitesMap( &pmapNT4SitesNew);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CVerifyObjectUpdate::RefreshNT4Sites:CreateNT4SitesMap()=%lx"), hr));
        return LogHR(hr, s_FN, 540);
    }

    {
        //
        // enter critical section
        //
        CS cs(m_csNT4Sites);
        //
        // delete old NT4Sites map if any, and set new NT4Sites map
        //
	    SafeAssign(m_pmapNT4Sites, pmapNT4SitesNew);

        //
        // mark last refresh time
        //
        m_dwLastRefreshNT4Sites = GetTickCount();  
    }
	return MQ_OK;

}

HRESULT CVerifyObjectUpdate::CreateNT4SitesMap(
                                 OUT NT4Sites_CMAP ** ppmapNT4Sites
                                 )
/*++

Routine Description:
    Creates new maps for NT4 site PSC's

Arguments:
    ppmapNT4Sites   - returned new NT4Sites map

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // find all msmq servers that have an NT4 flags > 0 AND services == PSC
    //
    //
    // NT4 flags > 0 (equal to NT4 flags >= 1 for easier LDAP query)
    //
    //
    // start search
    //

    CAutoMQADQueryHandle hLookup;

    // This search request will be recognized and specially simulated by DS
    hr = MQADQueryNT4MQISServers(
                    NULL,   // BUGBUG- pwcsDomainController 
					false,	// fServerName
                    SERVICE_PSC,
                    1,
                    const_cast<MQCOLUMNSET*>(&x_columnsetNT4Sites),
                    &hLookup);

    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CreateNT4SitesMap:DSCoreLookupBegin()=%lx"), hr));
        return LogHR(hr, s_FN, 510);
    }
	ASSERT( hLookup != NULL );
    //
    // create maps for NT4 PSC data
    //
    P<NT4Sites_CMAP> pmapNT4Sites = new NT4Sites_CMAP;

    //
    // allocate propvars array for NT4 PSC
    //
    CAutoCleanPropvarArray cCleanProps;
    PROPVARIANT * rgPropVars = cCleanProps.allocClean(ARRAY_SIZE(x_rgNT4SitesPropIDs));

    //
    // loop on the NT4 PSC's
    //
    BOOL fContinue = TRUE;
    while (fContinue)
    {
        //
        // get next server
        //
        DWORD cProps = ARRAY_SIZE(x_rgNT4SitesPropIDs);

        hr = MQADQueryResults(hLookup, &cProps, rgPropVars);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CreateNT4SitesMap:DSCoreLookupNext()=%lx"), hr));
            return LogHR(hr, s_FN, 520);
        }

        //
        // remember to clean the propvars in the array for the next loop
        // (only propvars, not the array itself, this is why we call attachStatic)
        //
        CAutoCleanPropvarArray cCleanPropsLoop;
        cCleanPropsLoop.attachStatic(cProps, rgPropVars);

        //
        // check if finished
        //
        if (cProps < ARRAY_SIZE(x_rgNT4SitesPropIDs))
        {
            //
            // finished, exit loop
            //
            fContinue = FALSE;
        }
        else
        {
            ASSERT(rgPropVars[e_NT4SitesProp_MASTERID].vt == VT_CLSID);
            GUID guidSiteId = *(rgPropVars[e_NT4SitesProp_MASTERID].puuid);

            //
            // add entry to the NT4Sites map
            //
            pmapNT4Sites->SetAt(guidSiteId, 1);
        }
    }

    //
    // return results
    //
    *ppmapNT4Sites = pmapNT4Sites.detach();
    return MQ_OK;
}



bool CVerifyObjectUpdate::CheckSiteIsNT4Site(
                            const GUID * pguidSite
                            )
/*++

Routine Description:
    Checks if a site is an NT4 site

Arguments:
    pguidIdentifier - guid of site
    pfIsNT4Site     - returned indication if the site is NT4

Return Value:
    HRESULT

--*/
{
    return( LookupNT4Sites(pguidSite));
}


bool CVerifyObjectUpdate::LookupNT4Sites(const GUID * pguidSite)
/*++

Routine Description:
    Given a site guid, retrieves an NT4Sites entry if found.
    the returned entry pointer must not be freed, it points to a CMAP-owned entry.

Arguments:
    pguid     - site id
    ppNT4Site - returned pointer to NT4Sites entry

Return Value:
    TRUE  - site guid was found in the NT4 Site PSC's map, ppNT4Site is set to point to the entry
    FALSE - site guid was not found in the NT4 Site PSC's map

--*/
{
    //
    // refresh if its time to do so
    //
    HRESULT hr = RefreshNT4Sites();
	if(FAILED(hr))
	{
		return false;
	}

    //
    // Protect access to map pointer and return the lookup value
    //
    CS cs(m_csNT4Sites);

    DWORD dwNotApplicable;
    BOOL f =   m_pmapNT4Sites->Lookup(*pguidSite, dwNotApplicable);
    bool result = f ? true: false;
    return result;
       
}


HRESULT CVerifyObjectUpdate::CheckMachineIsOwnedByNT4Site(
                          CBasicObjectType *    pObject,
                          OUT bool * pfIsOwnedByNT4Site
                          )
/*++

Routine Description:
    Checks if a machine is owned by an NT4 site, and if so, returns the site guid,
    and fills the qm info request

Arguments:
    pwcsPathName       - object's pathname
    pguidIdentifier    - object's guid
    pfIsOwnedByNT4Site - returned indication whether it is owned by NT4 site
    pguidOwnerNT4Site  - returned guid of owner NT4 site
    pvarObjSecurity    - returned security descriptor of object
    pQmInfoRequest     - requested qm props - filled only if it is owned by NT4 site

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // get PROPID_QM_MASTERID
    //
    PROPID aProp[] = {PROPID_QM_MASTERID};
    CAutoCleanPropvarArray cCleanProps;
    PROPVARIANT * pProps = cCleanProps.allocClean(ARRAY_SIZE(aProp));
    hr = pObject->GetObjectProperties(
                        ARRAY_SIZE(aProp),
                        aProp,
                        pProps);

    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        //
        // if the property not found, it is not owned by an NT4 site
        //
        *pfIsOwnedByNT4Site = false;
        return MQ_OK;
    }
    else if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 410);
    }

    //
    // check if the owner site is NT4
    //
    ASSERT(pProps[0].vt == VT_CLSID);
    ASSERT(pProps[0].puuid != NULL);
    *pfIsOwnedByNT4Site = CheckSiteIsNT4Site(pProps[0].puuid);

    return MQ_OK;
}


HRESULT CVerifyObjectUpdate::CheckQueueIsOwnedByNT4Site( 
                                  CBasicObjectType * pObject,
                                  OUT bool * pfIsOwnedByNT4Site
                                  )
/*++

Routine Description:
    Checks if a queue is owned by an NT4 site, and if so, returns the site guid,
    and fills the info requests.

    There are two ways:
    1. Find PROPID_Q_QMID and check whether the machine is owned by NT4 site.
    2. Find PROPID_Q_MASTERID (if exists), and if exists check if the site is an NT4.

    It looks like most of the queue calls to NT5 DS (in mixed mode) will not be
    for NT4 owned queues, so there is an advantage to getting a negative answer first,
    so we take the second approach, it is faster for negative answer, but slower on
    positive answer (e.g. extra DS call to fill the qm info)

Arguments:
    pwcsPathName       - object's pathname
    pguidIdentifier    - object's guid
    pfIsOwnedByNT4Site - returned indication whether it is owned by NT4 site
    pguidOwnerNT4Site  - returned guid of owner NT4 site
    pvarObjSecurity    - returned security descriptor of object

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // get PROPID_Q_MASTERID, if not found then it is not owned by NT4
    //
    PROPID aProp[] = {PROPID_Q_MASTERID};
    CAutoCleanPropvarArray cCleanProps;
    PROPVARIANT * pProps = cCleanProps.allocClean(ARRAY_SIZE(aProp));

    hr = pObject->GetObjectProperties(
                        ARRAY_SIZE(aProp),
                        aProp,
                        pProps);

    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        //
        // if the property not found, it is not owned by an NT4 site
        //
        *pfIsOwnedByNT4Site = false;
        return MQ_OK;
    }
    else if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 440);
    }

    //
    // check whether the owner site is NT4
    //
    ASSERT(pProps[0].vt == VT_CLSID);
    ASSERT(pProps[0].puuid != NULL);
    *pfIsOwnedByNT4Site = CheckSiteIsNT4Site(pProps[0].puuid);

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\srvrobj.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    srvrobj.cpp

Abstract:

    Implementation of CServerObject class.

Author:

    ronith

--*/
#include "ds_stdh.h"
#include "baseobj.h"
#include "mqattrib.h"
#include "mqadglbo.h"

#include "srvrobj.tmh"

static WCHAR *s_FN=L"mqad/srvrobj";

DWORD CServerObject::m_dwCategoryLength = 0;
AP<WCHAR> CServerObject::m_pwcsCategory = NULL;


CServerObject::CServerObject( 
                    LPCWSTR         pwcsPathName,
                    const GUID *    pguidObject,
                    LPCWSTR         pwcsDomainController,
					bool		    fServerName
                    ) : CBasicObjectType( 
								pwcsPathName, 
								pguidObject,
								pwcsDomainController,
								fServerName
								)
/*++
    Abstract:
	constructor of server object

    Parameters:
    LPCWSTR       pwcsPathName - the object MSMQ name
    const GUID *  pguidObject  - the object unique id
    LPCWSTR       pwcsDomainController - the DC name against
	                             which all AD access should be performed
    bool		   fServerName - flag that indicate if the pwcsDomainController
							     string is a server name

    Returns:
	none

--*/
{
}

CServerObject::~CServerObject()
/*++
    Abstract:
	destructor of site object

    Parameters:
	none

    Returns:
	none
--*/
{
	//
	// nothing to do ( everything is released with automatic pointers
	//
}

HRESULT CServerObject::ComposeObjectDN()
/*++
    Abstract:
	Composed distinguished name of the server object

    Parameters:
	none

    Returns:
	none
--*/
{
    ASSERT(0);
    LogIllegalPoint(s_FN, 82);
    return MQ_ERROR_DS_ERROR;
}

HRESULT CServerObject::ComposeFatherDN()
/*++
    Abstract:
	Composed distinguished name of the parent of server object

    Parameters:
	none

    Returns:
	none
--*/
{
    ASSERT(0);
    LogIllegalPoint(s_FN, 81);
    return MQ_ERROR_DS_ERROR;
}

LPCWSTR CServerObject::GetRelativeDN()
/*++
    Abstract:
	return the RDN of the server object

    Parameters:
	none

    Returns:
	LPCWSTR server RDN
--*/
{
    return m_pwcsPathName;
}


DS_CONTEXT CServerObject::GetADContext() const
/*++
    Abstract:
	Returns the AD context where server object should be looked for

    Parameters:
	none

    Returns:
	DS_CONTEXT
--*/
{
    return e_SitesContainer;
}

bool CServerObject::ToAccessDC() const
/*++
    Abstract:
	returns whether to look for the object in DC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	true (i.e. to look for the object in any DC)
--*/
{
    //
    //  configuration container is on every DC
    //
    return true;
}

bool CServerObject::ToAccessGC() const
/*++
    Abstract:
	returns whether to look for the object in GC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	false 
--*/
{
    return false;
}

void CServerObject::ObjectWasFoundOnDC()
/*++
    Abstract:
	The object was found on DC, this is not relevant for server object


    Parameters:
	none

    Returns:
	none
--*/
{
}


LPCWSTR CServerObject::GetObjectCategory() 
/*++
    Abstract:
	prepares and retruns the object category string

    Parameters:
	none

    Returns:
	LPCWSTR object category string
--*/
{
    if (CServerObject::m_pwcsCategory == NULL)
    {
        DWORD len = wcslen(g_pwcsSchemaContainer) + wcslen(x_ServerCategoryName) + 2;

        AP<WCHAR> pwcsCategory = new WCHAR[len];
        DWORD dw = swprintf(
             pwcsCategory,
             L"%s,%s",
             x_ServerCategoryName,
             g_pwcsSchemaContainer
            );
        DBG_USED(dw);
		ASSERT( dw < len);

        if (NULL == InterlockedCompareExchangePointer(
                              &CServerObject::m_pwcsCategory.ref_unsafe(), 
                              pwcsCategory.get(),
                              NULL
                              ))
        {
            pwcsCategory.detach();
            CServerObject::m_dwCategoryLength = len;
        }
    }
    return CServerObject::m_pwcsCategory;
}

DWORD   CServerObject::GetObjectCategoryLength()
/*++
    Abstract:
	prepares and retruns the length object category string

    Parameters:
	none

    Returns:
	DWORD object category string length
--*/
{
	//
	//	call GetObjectCategory in order to initailaze category string
	//	and length
	//
	GetObjectCategory();

    return CServerObject::m_dwCategoryLength;
}

AD_OBJECT CServerObject::GetObjectType() const
/*++
    Abstract:
	returns the object type

    Parameters:
	none

    Returns:
	AD_OBJECT
--*/
{
    return eSERVER;
}

LPCWSTR CServerObject::GetClass() const
/*++
    Abstract:
	returns a string represinting the object class in AD

    Parameters:
	none

    Returns:
	LPCWSTR object class string
--*/
{
    return MSMQ_SERVER_CLASS_NAME;
}

DWORD CServerObject::GetMsmq1ObjType() const
/*++
    Abstract:
	returns the object type in MSMQ 1.0 terms

    Parameters:
	none

    Returns:
	DWORD 
--*/
{
    ASSERT(0);
    return 0;
}

HRESULT CServerObject::SetObjectSecurity(
            IN  SECURITY_INFORMATION        /*RequestedInformation*/,
            IN  const PROPID                /*prop*/,
            IN  const PROPVARIANT *         /*pVar*/,
            IN OUT MQDS_OBJ_INFO_REQUEST *  /*pObjInfoRequest*/, 
            IN OUT MQDS_OBJ_INFO_REQUEST *  /*pParentInfoRequest*/
            )
/*++

Routine Description:
    The routine sets object security in AD 

Arguments:
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - infomation about the object
    MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - information about the object's parent

Return Value
	HRESULT

--*/
{
    //
    //  This operation is not supported
    //
    return MQ_ERROR_FUNCTION_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\traninfo.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
	traninfo.h

Abstract:

Author:
    ronith


--*/


#ifndef __TRANINFO_H__
#define __TRANINFO_H__

#include "ds_stdh.h"
#include "activeds.h"
#include "oledb.h"
#include "oledberr.h"
#include "mqads.h"
#include "adsiutil.h"

class CObjXlateInfo
{
public:
    CObjXlateInfo(LPCWSTR               pwszObjectDN,
                  const GUID*           pguidObjectGuid
                  );
    virtual ~CObjXlateInfo();    // allow destructing derived classes
    LPCWSTR ObjectDN();
    GUID*  ObjectGuid();
    void InitGetDsProps(IN IDirectorySearch * pSearchObj,
                        IN ADS_SEARCH_HANDLE hSearch);
    void InitGetDsProps(IN IADs * pIADs);
    HRESULT GetDsProp(IN LPCWSTR pwszPropName,
                      IN LPCWSTR pwszDomainCOntroller,
	 	              IN bool	 fServerName,
                      IN ADSTYPE adstype,
                      IN VARTYPE vartype,
                      IN BOOL fMultiValued,
                      OUT PROPVARIANT * ppropvarResult);

private:
    AP<WCHAR> m_pwszObjectDN  ;      // object's DN
    P<GUID>   m_pguidObjectGuid;     // object's GUID
    R<IADs>             m_pIADs;      // IADs interface to DS props
    R<IDirectorySearch> m_pSearchObj; // IDirectorySearch interface to DS props
    ADS_SEARCH_HANDLE   m_hSearch;    // needed for IDirectorySearch interface to DS props

};

inline LPCWSTR CObjXlateInfo::ObjectDN()    {return m_pwszObjectDN;}
inline GUID*  CObjXlateInfo::ObjectGuid()  {return m_pguidObjectGuid;}



//-----------------------------------------
// Routine to retrieve a property value ( for properties that are not kept in DS)
//-----------------------------------------
typedef HRESULT (WINAPI*  RetrieveValue_HANDLER)(
                 IN  CObjXlateInfo *        pcObjXlateInfo,
                 IN  LPCWSTR                pwcsDomainController,
	             IN  bool					fServerName,
                 OUT PROPVARIANT *          ppropvariant
                );

// Routine to set a property value ( for properties that are not kept in DS)
//-----------------------------------------
typedef HRESULT (WINAPI*  SetValue_HANDLER)(
                 IN  IADs *            pAdsObj,
                 IN  LPCWSTR           pwcsDomainController,
	             IN  bool			   fServerName,
                 IN  const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

//-----------------------------------------
// Routine to set a property value during create of an object
// ( for properties that are not kept in DS)
//-----------------------------------------
typedef HRESULT (WINAPI*  CreateValue_HANDLER)(
                 IN const PROPVARIANT *pPropVar,
                 IN LPCWSTR            pwcsDomainController,
	             IN  bool			   fServerName,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);


//---------------------------------------
//  TranslateInfo
//
//  A structure describing property in MQ and NT5
//---------------------------------------
struct translateProp
{
    PROPID                  propid;
    LPCWSTR                 wcsPropid;
    VARTYPE                 vtMQ;         // the vartype of this property in MQ
    ADSTYPE                 vtDS;         // the vartype of this property in NT5 DS
    RetrieveValue_HANDLER   RetrievePropertyHandle;
    BOOL                    fMultiValue;  // whether the attribute is multi value or not
    BOOL                    fPublishInGC; // whether the attribute is published in GC or not
    const MQPROPVARIANT *   pvarDefaultValue;   // attribute's default value, incase it is not in DS
    SetValue_HANDLER        SetPropertyHandle;
	CreateValue_HANDLER	    CreatePropertyHandle;
};


const DWORD cQueueTranslateInfoSize = 28;
extern translateProp   QueueTranslateInfo[cQueueTranslateInfoSize];

const DWORD cMachineTranslateInfoSize = 34;
extern translateProp   MachineTranslateInfo[cMachineTranslateInfoSize];

const DWORD cEnterpriseTranslateInfoSize = 10;
extern translateProp   EnterpriseTranslateInfo[cEnterpriseTranslateInfoSize];

const DWORD cSiteLinkTranslateInfoSize = 11;
extern translateProp   SiteLinkTranslateInfo[cSiteLinkTranslateInfoSize];

const DWORD cUserTranslateInfoSize = 4;
extern translateProp   UserTranslateInfo[cUserTranslateInfoSize];

const DWORD cMQUserTranslateInfoSize = 6;
extern translateProp   MQUserTranslateInfo[cMQUserTranslateInfoSize];

const DWORD cSiteTranslateInfoSize = 10;
extern translateProp   SiteTranslateInfo[cSiteTranslateInfoSize];

const DWORD cServerTranslateInfoSize = 3;
extern translateProp   ServerTranslateInfo[cServerTranslateInfoSize];

const DWORD cSettingTranslateInfoSize = 11;
extern translateProp   SettingTranslateInfo[cSettingTranslateInfoSize];

const DWORD cComputerTranslateInfoSize = 10;
extern translateProp ComputerTranslateInfo[cComputerTranslateInfoSize];




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\updtallw.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
    updtallw.h

Abstract:
    class to encapsulate the code for verifying the
    object owner in mixed mode DS

Author:
    ronith

--*/

#ifndef _UPDTALLW_H_
#define _UPDTALLW_H_

#include <mqaddef.h>
#include "baseobj.h"




//
// map of NT4 Site entries by site id
//
typedef CMap<GUID, const GUID&, DWORD, DWORD> NT4Sites_CMAP;




class CVerifyObjectUpdate
{
public:
    CVerifyObjectUpdate(void);

    ~CVerifyObjectUpdate(void);

    HRESULT Initialize();


    bool IsUpdateAllowed(
            AD_OBJECT         eObject,
            CBasicObjectType* pObject
            );

    bool IsCreateAllowed(
        AD_OBJECT         eObject,
        CBasicObjectType* pObject
        );


private:
    bool IsObjectTypeAlwaysAllowed(
            AD_OBJECT       eObject
            );

    HRESULT RefreshNT4Sites();

    HRESULT CreateNT4SitesMap(
             NT4Sites_CMAP ** ppmapNT4Sites
             );

    bool CheckSiteIsNT4Site(
            const GUID * pguidSite
            );

    bool LookupNT4Sites(
        const GUID * pguidSite
        );

    HRESULT CheckQueueIsOwnedByNT4Site( 
                      CBasicObjectType * pObject,
                      OUT bool * pfIsOwnedByNT4Site
                      );

    HRESULT CheckMachineIsOwnedByNT4Site(
                     CBasicObjectType * pObject,
                     OUT bool * pfIsOwnedByNT4Site
                     );




private:
    bool m_fInited;
    bool m_fMixedMode;
    CCriticalSection m_csNT4Sites;
    P<NT4Sites_CMAP> m_pmapNT4Sites;
    DWORD  m_dwLastRefreshNT4Sites;
    DWORD  m_dwRefreshNT4SitesInterval;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\usercert.h ===
/*++
  
Copyright (c) 1995  Microsoft Corporation

Module Name:
    usercert.h

Abstract:
    Classes to manipulate use certificate blob


Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __USERCERT_H__
#define __USERCERT_H__
//-----------------------------------------
// User object : certificate attribute structure
//
// In MSMQ each user has a certificate per machine,
// In NT5 there is one user object per user.
// Therefore msmq-certificate property in NT5 will contain
// multiple values
//-----------------------------------------


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CUserCert {
public:
    inline CUserCert( const GUID&    guidDigest,
                      const GUID&    guidId,
                      const DWORD    dwCertLength,
                      const BYTE *   pCert);
    inline CUserCert();
    inline CUserCert( const CUserCert& other);
    static ULONG CalcSize(
            IN DWORD dwCertLen);

    inline HRESULT CopyIntoBlob( OUT MQPROPVARIANT * pvar) const;

    inline BOOL DoesDigestMatch(
                IN  const GUID *       pguidDigest) const;

    inline DWORD GetSize() const;

    inline BYTE * MarshaleIntoBuffer(
                    IN BYTE * pbBuffer);

private:

    GUID           m_guidDigest;
    GUID           m_guidId;
    DWORD          m_dwCertLength;
    BYTE           m_Cert[0];       // variable length
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

inline CUserCert::CUserCert(
                      const GUID&    guidDigest,
                      const GUID&    guidId,
                      const DWORD    dwCertLength,
                      const BYTE *   pCert)
{
	//
	// ISSUE-2000/12/18-ilanh Compiler bug
	//
    memcpy((UNALIGNED GUID*)&m_guidDigest, &guidDigest, sizeof(GUID));
    memcpy((UNALIGNED GUID*)&m_guidId, &guidId, sizeof(GUID));
    memcpy((UNALIGNED DWORD*)&m_dwCertLength, &dwCertLength, sizeof(DWORD));
    memcpy( m_Cert, pCert, dwCertLength);
}


inline CUserCert::CUserCert(
                  const CUserCert& other)
{
	//
	// ISSUE-2000/12/18-ilanh Compiler bug
	//
    memcpy((UNALIGNED GUID*)&m_guidDigest, &other.m_guidDigest, sizeof(GUID));
    memcpy((UNALIGNED GUID*)&m_guidId, &other.m_guidId, sizeof(GUID));
    memcpy((UNALIGNED DWORD*)&m_dwCertLength, &other.m_dwCertLength, sizeof(DWORD));
    memcpy( m_Cert, &other.m_Cert, m_dwCertLength);
}

inline CUserCert::CUserCert()
{
}

inline HRESULT CUserCert::CopyIntoBlob( OUT MQPROPVARIANT * pvar) const
{
    if ( pvar->vt != VT_NULL)
    {
		ASSERT(0);
		return MQ_ERROR_DS_ERROR;
    }
    if ( m_dwCertLength == 0)
    {
		ASSERT(0);
		return MQ_ERROR_DS_ERROR;
    }
    //
    //  allocate memory
    //
    pvar->blob.pBlobData = new BYTE[ m_dwCertLength];
    memcpy( pvar->blob.pBlobData, &m_Cert,  m_dwCertLength);
    pvar->blob.cbSize =  m_dwCertLength;
    pvar->vt = VT_BLOB;
    return( MQ_OK);
}

inline BOOL CUserCert::DoesDigestMatch(
                 IN  const GUID *  pguidDigest) const
{
	//
	// ISSUE-2000/12/18-ilanh Compiler bug
	//
    return(memcmp((UNALIGNED GUID*)&m_guidDigest, pguidDigest, sizeof(GUID)) == 0);
}

inline DWORD CUserCert::GetSize() const
{
    return( sizeof( CUserCert) +  m_dwCertLength);
}

inline ULONG CUserCert::CalcSize(
                   IN DWORD dwCertLen)
{
    return( sizeof(CUserCert) + dwCertLen);
}

inline BYTE * CUserCert::MarshaleIntoBuffer(
                         IN BYTE * pbBuffer)
{
    BYTE * pNextToFill = pbBuffer;
    memcpy( pNextToFill, &m_guidDigest, sizeof(GUID));
    pNextToFill += sizeof(GUID);
    memcpy( pNextToFill, &m_guidId, sizeof(GUID));
    pNextToFill += sizeof(GUID);
    memcpy( pNextToFill, &m_dwCertLength, sizeof(DWORD));
    pNextToFill += sizeof(DWORD);
    memcpy( pNextToFill, &m_Cert, m_dwCertLength);
    pNextToFill += m_dwCertLength;
    return( pNextToFill);

}


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


struct CUserCertBlob {
public:
    inline CUserCertBlob(
                    IN const CUserCert *     pUserCert);
    inline CUserCertBlob();
    static ULONG CalcSize( void);

    inline HRESULT GetUserCert( IN  const GUID *       pguidDigest,
                         OUT const CUserCert ** ppUserCert) const;

    inline DWORD GetNumberOfCerts();

    inline HRESULT GetCertificate(
                          IN  const DWORD     dwCertificateNumber,
                          OUT MQPROPVARIANT * pvar
                          );

    inline void MarshaleIntoBuffer(
                  IN BYTE * pbBuffer);
    inline void IncrementNumCertificates();

    inline HRESULT RemoveCertificateFromBuffer(
                            IN  const GUID *     pguidDigest,
                            IN  DWORD            dwTotalSize,
                            OUT DWORD *          pdwCertSize);

private:

    DWORD           m_dwNumCert;
    CUserCert       m_userCert;
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

inline CUserCertBlob::CUserCertBlob(
              IN const CUserCert *     pUserCert):
              m_userCert(*pUserCert)
{
    m_dwNumCert = 1;
}

inline CUserCertBlob::CUserCertBlob()
{
}

inline HRESULT CUserCertBlob::GetUserCert(
                         IN  const GUID *       pguidDigest,
                         OUT const CUserCert ** ppUserCert) const
{
    *ppUserCert = NULL;
    if ( m_dwNumCert == 0)
    {
		return MQ_ERROR_DS_ERROR;
    }
    const CUserCert * pUserCert = &m_userCert;
    for (DWORD i = 0; i < m_dwNumCert; i++)
    {
        if (pUserCert->DoesDigestMatch( pguidDigest))
        {
            *ppUserCert = pUserCert;
            return( MQ_OK);
        }
        //
        //  Move to next certificate
        //
        BYTE *pBuf = (BYTE*) pUserCert ;
        pBuf += pUserCert->GetSize();
        pUserCert = (const CUserCert*) pBuf ;
    }
    //
    //  No match digest in the user cert blob
    //
    return MQ_ERROR_DS_ERROR;

}
inline DWORD CUserCertBlob::GetNumberOfCerts()
{
    return( m_dwNumCert);
}

inline HRESULT CUserCertBlob::GetCertificate(
                          IN  const DWORD     dwCertificateNumber,
                          OUT MQPROPVARIANT * pvar
                          )
{
    HRESULT hr;

    if ( dwCertificateNumber > m_dwNumCert)
    {
		return MQ_ERROR_DS_ERROR;
    }
    const CUserCert * pUserCert = &m_userCert;
    //
    //  Move to certificate number dwCertificateNumber
    //
    for (DWORD i = 0; i < dwCertificateNumber; i++)
    {
        //
        //  Move to next certificate
        //
        pUserCert = (const CUserCert * )((const unsigned char *)pUserCert + pUserCert->GetSize());
    }
    pvar->vt = VT_NULL;
    hr = pUserCert->CopyIntoBlob(
                            pvar
                            );
    return(hr);
}

inline ULONG CUserCertBlob::CalcSize( void)
{
    //
    //  Just the size of CUserCertBlob without
    //  the size of m_userCert
    //
    return( sizeof(CUserCertBlob) - CUserCert::CalcSize(0));
}

inline void CUserCertBlob::MarshaleIntoBuffer(
                  IN BYTE * pbBuffer)
{
    ASSERT( m_dwNumCert == 1);
    memcpy( pbBuffer, &m_dwNumCert, sizeof(DWORD));
    m_userCert.MarshaleIntoBuffer( pbBuffer + sizeof(DWORD));

}
inline void CUserCertBlob::IncrementNumCertificates()
{
    m_dwNumCert++;
}

inline HRESULT CUserCertBlob::RemoveCertificateFromBuffer(
                            IN  const GUID *     pguidDigest,
                            IN  DWORD            dwTotalSize,
                            OUT DWORD *          pdwCertSize)
{
    const CUserCert * pUserCert = &m_userCert;
    //
    //  Find the certificate to be removed according to its digest
    //
    BOOL fFoundCertificate = FALSE;
    for ( DWORD i = 0; i < m_dwNumCert; i++)
    {
        if ( pUserCert->DoesDigestMatch( pguidDigest))
        {
            fFoundCertificate = TRUE;
            break;
        }
        //
        //  Move to next certificate
        //
        pUserCert = (const CUserCert * )((const unsigned char *)pUserCert + pUserCert->GetSize());
    }
    if ( !fFoundCertificate)
    {
        return MQDS_OBJECT_NOT_FOUND;
    }
    //
    //  copy buffer ( i.e. copy the remaining certificates over the removed one)
    //
    DWORD dwCertSize =  pUserCert->GetSize();
    DWORD_PTR dwSizeToCopy =  dwTotalSize -
                         (((const unsigned char *)pUserCert) - ((const unsigned char *)&m_userCert))
                         - dwCertSize - sizeof(m_dwNumCert);
    if ( dwSizeToCopy)
    {
        memcpy( (unsigned char *)pUserCert,
                (unsigned char *)pUserCert + dwCertSize,
                dwSizeToCopy);
    }
    *pdwCertSize = dwCertSize;
    m_dwNumCert--;
    return(MQ_OK);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\utils.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
	dsutils.h

Abstract:
	General declarations and utilities for MqAds project

Author:
    AlexDad

--*/


#ifndef __UTILS_H__
#define __UTILS_H__
#include "iads.h"

//-----------------------------
//  Misc routines
//-----------------------------
// Translation from MqPropValue to wide string
extern HRESULT MqPropVal2String(
      IN  MQPROPVARIANT *pPropVar,
      IN  ADSTYPE        adsType,
      OUT LPWSTR *       ppwszVal); 
// Translation from MQPropValue to ADSI Variant
extern HRESULT MqVal2AdsiVal(
      IN  ADSTYPE        adsType,
      OUT DWORD         *pdwNumValues,
      OUT PADSVALUE     *ppADsValue, 
      IN  const MQPROPVARIANT *pPropVar,
      IN  PVOID          pvMainAlloc);
// Translation from MQPropValue to OLE Variant
extern HRESULT MqVal2Variant(
      OUT VARIANT *pvProp, 
      IN  const MQPROPVARIANT *pPropVar,
      ADSTYPE adsType);

// Translation from OLE variant to MQPropValue
extern HRESULT Variant2MqVal(
      OUT  MQPROPVARIANT *   pMqVar,
      IN   VARIANT *         pOleVar,
      IN   const ADSTYPE     adstype,
      IN   const VARTYPE     vartype
      );

// Translation from ADSI Value to MQPropValue
extern HRESULT AdsiVal2MqVal(
      OUT MQPROPVARIANT *pPropVar,
      IN  VARTYPE       vtTarget, 
      IN  ADSTYPE       AdsType,
      IN  DWORD         dwNumValues,
      IN  PADSVALUE     pADsValue
      );

extern void StringToSearchFilter(
      IN  LPCWSTR        pwcs,
      OUT LPWSTR *       ppwszVal
      );

extern bool IsLocalUser(void);





extern void LogTraceQuery(LPWSTR wszStr, LPWSTR wszFileName, USHORT usPoint);

extern void LogTraceQuery2(LPWSTR wszStr1, LPWSTR wszStr2, LPWSTR wszFileName, USHORT usPoint);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\xlatqm.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    xlatqm.cpp

Abstract:

    Definition of routines to translate QM info from NT5 Active DS
    to what MSMQ 1.0 (NT4) QM's expect

Author:

    Raanan Harari (raananh)

--*/

#ifndef __XLATQM_H__
#define __XLATQM_H__

#include "traninfo.h"

HRESULT WINAPI GetMsmqQmXlateInfo(
                 IN  LPCWSTR                pwcsObjectDN,
                 IN  const GUID*            pguidObjectGuid,
                 OUT CObjXlateInfo**        ppcObjXlateInfo);


HRESULT WINAPI MQADpRetrieveMachineName(
                 IN  CObjXlateInfo * pTrans,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADpRetrieveMachineDNSName(
                 IN  CObjXlateInfo * pTrans,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT * ppropvariant);


HRESULT WINAPI MQADpRetrieveQMService(
                 IN  CObjXlateInfo * pTrans,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADpRetrieveMachineSite(
                 IN  CObjXlateInfo * pTrans,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADpSetMachineServiceDs(
                 IN IADs *             pAdsObj,
                 IN LPCWSTR            pwcsDomainController,
                 IN  bool			   fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADpSetMachineServiceRout(
                 IN IADs *             pAdsObj,
                 IN LPCWSTR            pwcsDomainController,
                 IN  bool			   fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADpRetrieveMachineOutFrs(
                 IN  CObjXlateInfo * pTrans,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADpRetrieveMachineInFrs(
                 IN  CObjXlateInfo * pTrans,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT * ppropvariant);



HRESULT WINAPI MQADpSetMachineOutFrss(
                 IN IADs *             pAdsObj,
                 IN LPCWSTR            pwcsDomainController,
                 IN  bool			   fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADpCreateMachineOutFrss(
                 IN const PROPVARIANT *pPropVar,
                 IN LPCWSTR            pwcsDomainController,
                 IN  bool			   fServerName,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADpSetMachineInFrss(
                 IN IADs *             pAdsObj,
                 IN LPCWSTR            pwcsDomainController,
                 IN  bool			   fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADpCreateMachineInFrss(
                 IN const PROPVARIANT *pPropVar,
                 IN LPCWSTR            pwcsDomainController,
                 IN  bool			   fServerName,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);


HRESULT MQADpGetComputerDns(
                IN  LPCWSTR     pwcsComputerName,
                IN  LPCWSTR     pwcsDomainController,
	            IN  bool		fServerName,
                OUT WCHAR **    ppwcsDnsName
                );

HRESULT WINAPI MQADpSetMachineService(
                 IN IADs *             pAdsObj,
                 IN LPCWSTR            pwcsDomainController,
                 IN  bool			   fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADpRetrieveMachineEncryptPk(
                 IN  CObjXlateInfo * pTrans,
                 IN  LPCWSTR         pwcsDomainController,
                 IN  bool			 fServerName,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADpSetMachineEncryptPk(
                 IN IADs *             pAdsObj,
                 IN LPCWSTR            pwcsDomainController,
                 IN  bool			   fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADpCreateMachineEncryptPk(
                 IN const PROPVARIANT *pPropVar,
                 IN LPCWSTR            pwcsDomainController,
                 IN  bool			   fServerName,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);


#endif //__XLATQM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\userobj.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    queueobj.cpp

Abstract:

    Implementation of CUserObject class.

Author:

    ronith

--*/
#include "ds_stdh.h"
#include "baseobj.h"
#include "mqattrib.h"
#include "mqadglbo.h"
#include "usercert.h"
#include "mqadp.h"
#include "dsutils.h"
#include "mqsec.h"

#include "userobj.tmh"

static WCHAR *s_FN=L"mqad/userobj";

DWORD CUserObject::m_dwCategoryLength = 0;
AP<WCHAR> CUserObject::m_pwcsCategory = NULL;


CUserObject::CUserObject( 
                    LPCWSTR         pwcsPathName,
                    const GUID *    pguidObject,
                    LPCWSTR         pwcsDomainController,
					bool		    fServerName
                    ) : CBasicObjectType( 
								pwcsPathName, 
								pguidObject,
								pwcsDomainController,
								fServerName
								)
/*++
    Abstract:
	constructor of user object

    Parameters:
    LPCWSTR       pwcsPathName - the object MSMQ name
    const GUID *  pguidObject  - the object unique id
    LPCWSTR       pwcsDomainController - the DC name against
	                             which all AD access should be performed
    bool		   fServerName - flag that indicate if the pwcsDomainController
							     string is a server name

    Returns:
    none

--*/
{
    //
    //  don't assume that the object can be found on DC
    //
    m_fFoundInDC = false;
    //
    //  Keep an indication that never tried to look for
    //  the object in AD ( and therefore don't really know if it can be found
    //  in DC or not)
    //
    m_fTriedToFindObject = false;
}

CUserObject::~CUserObject()
/*++
    Abstract:
	destructor of site object

    Parameters:
	none

    Returns:
	none
--*/
{
	//
	// nothing to do ( everything is released with automatic pointers
	//
}

HRESULT CUserObject::ComposeObjectDN()
/*++
    Abstract:
	Composed distinguished name of the user object

    Parameters:
	none

    Returns:
	none
--*/
{
	//
	//	User object is not accessed according to its DN
	//
    ASSERT(0);
    LogIllegalPoint(s_FN, 81);
    return MQ_ERROR_DS_ERROR;
}

HRESULT CUserObject::ComposeFatherDN()
/*++
    Abstract:
	Composed distinguished name of the parent of user object

    Parameters:
	none

    Returns:
	none
--*/
{
	//
	//	MSMQ doesn't create user objects, therefore there is no
	//  need to compose father DN
	//
    ASSERT(0);
    LogIllegalPoint(s_FN, 82);
    return MQ_ERROR_DS_ERROR;
}

LPCWSTR CUserObject::GetRelativeDN()
/*++
    Abstract:
	return the RDN of the user object

    Parameters:
	none

    Returns:
	LPCWSTR user RDN
--*/
{
    //
    //  we never actually create a new user object
    //
    ASSERT(0);
    LogIllegalPoint(s_FN, 83);
    return NULL;
}


DS_CONTEXT CUserObject::GetADContext() const
/*++
    Abstract:
	Returns the AD context where user object should be looked for

    Parameters:
	none

    Returns:
	DS_CONTEXT
--*/
{
    return e_RootDSE;
}

bool CUserObject::ToAccessDC() const
/*++
    Abstract:
	returns whether to look for the object in DC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	true or false
--*/
{
    if (!m_fTriedToFindObject)
    {
        return true;
    }
    return m_fFoundInDC;
}

bool CUserObject::ToAccessGC() const
/*++
    Abstract:
	returns whether to look for the object in GC ( based on
	previous AD access regarding this object)

    Parameters:
	none

    Returns:
	true or false 
--*/
{
    if(!m_fTriedToFindObject)
    {
        return true;
    }
    return !m_fFoundInDC;
}

void CUserObject::ObjectWasFoundOnDC()
/*++
    Abstract:
	The object was found on DC, set indication not to
    look for it on GC


    Parameters:
	none

    Returns:
	none
--*/
{
    m_fTriedToFindObject = true;
    m_fFoundInDC = true;
}


LPCWSTR CUserObject::GetObjectCategory() 
/*++
    Abstract:
	prepares and retruns the object category string

    Parameters:
	none

    Returns:
	LPCWSTR object category string
--*/
{
    if (CUserObject::m_pwcsCategory == NULL)
    {
        DWORD len = wcslen(g_pwcsSchemaContainer) + wcslen(x_UserCategoryName) + 2;

        AP<WCHAR> pwcsCategory = new WCHAR[len];
        DWORD dw = swprintf(
             pwcsCategory,
             L"%s,%s",
             x_UserCategoryName,
             g_pwcsSchemaContainer
            );
        DBG_USED(dw);
		ASSERT( dw < len);

        if (NULL == InterlockedCompareExchangePointer(
                              &CUserObject::m_pwcsCategory.ref_unsafe(), 
                              pwcsCategory.get(),
                              NULL
                              ))
        {
            pwcsCategory.detach();
            CUserObject::m_dwCategoryLength = len;
        }
    }
    return CUserObject::m_pwcsCategory;
}

DWORD   CUserObject::GetObjectCategoryLength()
/*++
    Abstract:
	prepares and retruns the length object category string

    Parameters:
	none

    Returns:
	DWORD object category string length
--*/
{
	//
	//	call GetObjectCategory in order to initailaze category string
	//	and length
	//
	GetObjectCategory();

    return CUserObject::m_dwCategoryLength;
}

AD_OBJECT CUserObject::GetObjectType() const
/*++
    Abstract:
	returns the object type

    Parameters:
	none

    Returns:
	AD_OBJECT
--*/
{
    return eUSER;
}

LPCWSTR CUserObject::GetClass() const
/*++
    Abstract:
	returns a string represinting the object class in AD

    Parameters:
	none

    Returns:
	LPCWSTR object class string
--*/
{
    return MSMQ_USER_CLASS_NAME;
}

DWORD CUserObject::GetMsmq1ObjType() const
/*++
    Abstract:
	returns the object type in MSMQ 1.0 terms

    Parameters:
	none

    Returns:
	DWORD 
--*/
{
    return MQDS_USER;
}

HRESULT CUserObject::DeleteObject(
            MQDS_OBJ_INFO_REQUEST * /* pObjInfoRequest*/,
            MQDS_OBJ_INFO_REQUEST * /* pParentInfoRequest*/
        )
/*++
    Abstract:
	This routine deletes a user object ( or more precisely removes
	a certificates from a user object).

    NOTE m_guidObject is actually the Digest of the specific
	certificate.
    The routine first tries to find the digest in USER object, and
    if not found it tries in MIGRATED-USER

    Parameters:
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - infomation about the object
    MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - information about the object's parent

    Returns:
	HRESULT
--*/
{
    const GUID * pDigest = &m_guidObject;
    //
    // First try to delete from a User object.
    //
    PROPID UserProp[3] = { PROPID_U_ID,
                           PROPID_U_DIGEST,
                           PROPID_U_SIGN_CERT};

    HRESULT hr = _DeleteUserObject( eUSER,
                                    pDigest,
                                    UserProp,
                                    MQ_U_DIGEST_ATTRIBUTE);

    if (hr == MQDS_OBJECT_NOT_FOUND)
    {
        //
        // User objectnot found. Try computer object.
        //
        PROPID ComUserProp[3] = { PROPID_COM_ID,
                                  PROPID_COM_DIGEST,
                                  PROPID_COM_SIGN_CERT };
        //
        // try to find this object in the msmqUsers container
        //
        hr = _DeleteUserObject( eCOMPUTER,
                                pDigest,
                                ComUserProp,
                                MQ_COM_DIGEST_ATTRIBUTE ) ;
    }

    if (hr == MQDS_OBJECT_NOT_FOUND)
    {
        //
        // Computer objectnot found. Try msmqUser object.
        //
        PROPID MQUserProp[3] = { PROPID_MQU_ID,
                                 PROPID_MQU_DIGEST,
                                 PROPID_MQU_SIGN_CERT };
        //
        // try to find this object in the msmqUsers container
        //
        hr = _DeleteUserObject( eMQUSER,
                                pDigest,
                                MQUserProp,
                                MQ_MQU_DIGEST_ATTRIBUTE ) ;
    }

    return LogHR(hr, s_FN, 220);
}


HRESULT CUserObject::_DeleteUserObject(
                        IN  AD_OBJECT           eObject,
                        IN const GUID *         pDigest,
                        IN  PROPID *			propIDs,
                        IN  LPCWSTR             pwcsDigest )
/*++

Routine Description:
    The routine deletes user object according to its digest

Arguments:
    AD_OBJECT      eObject - object type ( user, mq-user,..)
    const GUID *   pDigest - the digest of the user certificatet to be deleted
    PROPID  *      propIDs - properties to be retrieved for the delete operation
    LPCWSTR        pwcsDigest - the digest attribute string

Return Value:
    The status of the ds operation.

--*/
{
    HRESULT hr;
    //
    //  This routine deletes a user certificate according to its
    //  digest.
    //  A user object may contain multiple digests and certificates
    //

    //
    //  Find the user object
    //
    DWORD cp = 3;
    MQPROPVARIANT propvar[3];
    propvar[0].vt = VT_NULL;    
    propvar[1].vt = VT_NULL;
    propvar[2].vt = VT_NULL;

    hr =  FindUserAccordingToDigest(
                    FALSE,  // fOnlyInDC
                    eObject,
                    pDigest,
                    pwcsDigest,
                    cp,
                    propIDs,
                    propvar
                    );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 190);
    }

    ASSERT( propvar[0].vt == VT_CLSID);
    P<GUID> pguidUserId = propvar[0].puuid;

    ASSERT( propvar[1].vt == (VT_CLSID | VT_VECTOR));
    AP<GUID> pDigestArray = propvar[1].cauuid.pElems;

    ASSERT( propvar[2].vt == VT_BLOB);
    P<BYTE> pbyteCertificate = propvar[2].blob.pBlobData;

    if ( propvar[1].cauuid.cElems == 1)
    {
        //
        //  Last digest and certificate
        //
        propvar[1].cauuid.cElems = 0;
        propvar[2].blob.cbSize = 0;
    }
    else
    {
        BOOL fFoundDigest = FALSE;
        //
        //  remove the requested digest for the digest-vector
        //
        for ( DWORD i = 0 ; i < propvar[1].cauuid.cElems; i++)
        {
            if ( propvar[1].cauuid.pElems[i] == *pDigest)
            {
                fFoundDigest = TRUE;
                //
                //  found the entry to remove
                //
                for ( DWORD j = i + 1; j < propvar[1].cauuid.cElems; j++)
                {
                    propvar[1].cauuid.pElems[ j - 1] = propvar[1].cauuid.pElems[j];
                }
                break;
            }
        }
        propvar[1].cauuid.cElems--;
        ASSERT( fFoundDigest);
        //
        //  Remove the certificate
        //
        CUserCertBlob * pUserCertBlob =
            reinterpret_cast<CUserCertBlob *>( propvar[2].blob.pBlobData);

        DWORD dwSizeToRemoveFromBlob;
        hr = pUserCertBlob->RemoveCertificateFromBuffer(
                            pDigest,
                            propvar[2].blob.cbSize,
                            &dwSizeToRemoveFromBlob);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 200);
        }
        propvar[2].blob.cbSize -=  dwSizeToRemoveFromBlob;

    }

    //
    //  Update user properties with new values
    //
    m_guidObject =  *pguidUserId;
    hr =  g_AD.SetObjectProperties(
                adpDomainController,
                this,
                2,
                &propIDs[1],
                &propvar[1],
                NULL,   //pObjInfoRequest
                NULL    // pParentInfoRequest
				);

   return LogHR(hr, s_FN, 210);
}

HRESULT CUserObject::FindUserAccordingToDigest(
                IN  BOOL            fOnlyInDC,
                IN  AD_OBJECT       eObject,
                IN  const GUID *    pguidDigest,
                IN  LPCWSTR         pwcsDigest,
                IN  DWORD           dwNumProps,
                IN  const PROPID *  propToRetrieve,
                IN OUT PROPVARIANT* varResults
                )
/*++

Routine Description:
    The routine finds a user object according to digest, and retrieves
    the requested properties

Arguments:
    BOOL            fOnlyInDC - where to locate the user object
    AD_OBJECT       eObject - object type ( user, mq-user,..)
    const GUID *    pDigest - the digest of the user certificatet to be deleted
    LPCWSTR         pwcsDigest - the digest attribute string
    DWORD           dwNumProps - number of properties to retrieve
    const PROPID *  propToRetrieve - properties to retrieve
    PROPVARIANT* varResults - value of retrieved properties


Return Value:
    The status of the ds operation.

--*/
{
    //
    //  Find the user object according to its digest
    //
    HRESULT hr;

    DWORD dwNumResults = dwNumProps ;
    BOOL fUserFound = FALSE ;
    MQCOLUMNSET  Columns = {dwNumProps,
                             const_cast<PROPID*> (propToRetrieve) } ;

    hr = LocateUser( 
				m_pwcsDomainController,
				m_fServerName,
				fOnlyInDC,
				FALSE,     // fOnlyInGC
				eObject,
				pwcsDigest,
				NULL,      // pBlobSid 
				pguidDigest,
				&Columns,
				varResults,
				&dwNumResults,
				&fUserFound 
				);


    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 90);
    }
    else if (!fUserFound)
    {
        //
        //  failed to find user object
        //
        return LogHR(MQDS_OBJECT_NOT_FOUND, s_FN, 100);
    }

    ASSERT(dwNumResults ==  dwNumProps);
    return(MQ_OK);
}


HRESULT CUserObject::GetObjectProperties(
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT  PROPVARIANT         apVar[]
                )
/*++

Routine Description:
    The routine retrieve user object.
    It first tries to find the digest in USER object, and
    if not found it tries in MIGRATED-USER

Arguments:
	const DWORD     cp		- number of properties to retrieve
	const PROPID    aProp	- properties to retrieve
	PROPVARIANT     apVar   - values of retrieved properties

Return Value:
    The status of the ds operation.

--*/
{
	//
	//	first try user object
	//
    HRESULT hr = _GetUserProperties(
                        eUSER,
                        MQ_U_DIGEST_ATTRIBUTE,
                        cp,
                        aProp,
                        apVar
                        );

    if ( hr == MQDS_OBJECT_NOT_FOUND )
    {
        //
        // try to find it in a computer object.
        //
        // Change propid from _U_ property to _COM_
        // ( hack : object class is resolved according to the first propid)
        //
        AP<PROPID> tmpProp = new PROPID[ cp ];
        switch(aProp[0])
        {
            case PROPID_U_ID:
                tmpProp[0] = PROPID_COM_ID;
                break;
            case PROPID_U_DIGEST:
                tmpProp[0] = PROPID_COM_DIGEST;
                break;
            case PROPID_U_SIGN_CERT:
                tmpProp[0] = PROPID_COM_SIGN_CERT;
                break;
            case PROPID_U_SID:
                tmpProp[0] = PROPID_COM_SID;
                break;
            default:
                ASSERT(0);
                break;
        }

        for (DWORD i=1; i<cp; i++)
        {
            tmpProp[i] = aProp[i];
        }

        hr = _GetUserProperties(
                    eCOMPUTER,
                    MQ_COM_DIGEST_ATTRIBUTE,
                    cp,
                    tmpProp,
                    apVar
                    );
    }

    if ( hr == MQDS_OBJECT_NOT_FOUND )
    {
        //
        // try to find it in the msmqUsers container
        //
        // Change propid from _U_ property to _MQU_
        // ( hack : object class is resolved according to the first propid)
        //
        AP<PROPID> tmpProp = new PROPID[ cp ];
        switch(aProp[0])
        {
            case PROPID_U_ID:
                tmpProp[0] = PROPID_MQU_ID;
                break;
            case PROPID_U_DIGEST:
                tmpProp[0] = PROPID_MQU_DIGEST;
                break;
            case PROPID_U_SIGN_CERT:
                tmpProp[0] = PROPID_MQU_SIGN_CERT;
                break;
            case PROPID_U_SID:
                tmpProp[0] = PROPID_MQU_SID;
                break;
            default:
                ASSERT(0);
                break;
        }

        for (DWORD i=1; i<cp; i++)
        {
            tmpProp[i] = aProp[i];
        }

        hr = _GetUserProperties(
                    eMQUSER,
                    MQ_MQU_DIGEST_ATTRIBUTE,
                    cp,
                    tmpProp,
                    apVar
                    );
    }

    return LogHR(hr, s_FN, 260);
}

HRESULT CUserObject::_GetUserProperties(
               IN  AD_OBJECT     eObject,
               IN  LPCWSTR       pwcsDigest,
               IN  DWORD         cp,
               IN  const PROPID  aProp[],
               OUT PROPVARIANT  apVar[]
               )
/*++

Routine Description:
	A helper routine for retrieving user properties. It locates
	the object according to digest in the specified type of object.

Arguments:
	AD_OBJECT       eObject - object type
	LPCWSTR         pwcsDigest - digest attribute string
	const DWORD     cp		- number of properties to retrieve
	const PROPID    aProp	- properties to retrieve
	PROPVARIANT     apVar   - values of retrieved properties

Return Value:
	HRESULT
--*/
{
    HRESULT hr;
    //
    //  Find the user object according to the digest
    //

    CAutoCleanPropvarArray propArray;
    MQPROPVARIANT * ppropvar = new MQPROPVARIANT[ cp];
    propArray.attachClean( cp, ppropvar);

    hr = FindUserAccordingToDigest(
                    FALSE,			// fOnlyInDC
                    eObject,
                    &m_guidObject,  //pguidDigest
                    pwcsDigest,
                    cp,
                    aProp,
                    ppropvar
                    );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 230);
    }
    //
    //  Is one of the properties is PROPID_U_SIGN_CERT ?
    //
    DWORD i;
    BOOL  fGetCert = FALSE;
    for ( i =0; i < cp; i++)
    {
        if ( aProp[i] == PROPID_U_SIGN_CERT   ||
             aProp[i] == PROPID_COM_SIGN_CERT ||
             aProp[i] == PROPID_MQU_SIGN_CERT)
        {
            fGetCert = TRUE;
            break;
        }
    }
    //
    //  Parse the user certificates array, and return only the certificate
    //  associate with the requested digest
    //
    if( fGetCert)
    {
        ASSERT( i < cp);
        CUserCertBlob * pUserCertBlob =
            reinterpret_cast<CUserCertBlob *>( ppropvar[i].blob.pBlobData);

        const CUserCert * pUserCert = NULL;
        hr = pUserCertBlob->GetUserCert( &m_guidObject,  //pguidDigest
                                         &pUserCert );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 240);
        }
        hr = pUserCert->CopyIntoBlob(&apVar[i]);
        {
            if ( FAILED(hr))
            {
                return LogHR(hr, s_FN, 250);
            }
        }
    }

    //
    //  Copy the rest of proerties
    //
    for ( DWORD j = 0; j < cp; j++)
    {
        //
        //  don't copy the user cert property
        //
        if ( j != i)
        {
            apVar[j] = ppropvar[j];
            ppropvar[j].vt = VT_NULL;    // not to free allocated buffers
        }
    }


   return(MQ_OK);


}


HRESULT CUserObject::CreateInAD(
            IN DWORD                  cp,        
            IN const PROPID          *aProp, 
            IN const MQPROPVARIANT   *apVar, 
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest, 
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
                 )
/*++
    Abstract:
	The routine creates user object in AD with the specified attributes
	values

    Parameters:
    DWORD         cp - number of properties        
    const PROPID  *aProp - the propperties
    const MQPROPVARIANT *apVar - properties value
    PSECURITY_DESCRIPTOR    pSecurityDescriptor - SD of the object
    OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - properties to 
							retrieve while creating the object 
    OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - properties 
						to retrieve about the object's parent
    Returns:
	HRESULT
--*/
{
    DBG_USED(pObjInfoRequest);
    DBG_USED(pParentInfoRequest);
    ASSERT(pObjInfoRequest == NULL);    // no need to send notification
    ASSERT(pParentInfoRequest == NULL);
    //
    // First try "standard" user objects.
    //
    HRESULT hr = _CreateUserObject(
                         cp,
                         aProp,
                         apVar
                         );
    if (hr !=  MQDS_OBJECT_NOT_FOUND)
    {
        return LogHR(hr, s_FN, 310);
    }

    for (DWORD i = 0 ; i < cp ; i++ )
    {
        if (aProp[i] == PROPID_COM_SID)
        {
            //
            // Computer object for registering a certificate from service
            // must be found in the Active Directory. If not found, it's
            // a weird error. quit !
            //
            return LogHR(hr, s_FN, 320);
        }
    }

    //
    // try to find the user object in the msmqUsers container
    //
    // create new PROPID array with PROPID_MQU_* property
    // instead of PROPID_U_*
    //
    DWORD dwSIDPropNum = cp;
    DWORD dwCertPropNum = cp;
    DWORD dwDigestPropNum = cp;
    DWORD dwIdPropNum = cp;
    AP<PROPID> tmpProp = new PROPID[ cp ];
    for ( i=0; i<cp; i++)
    {
        switch ( aProp[i])
        {
            case PROPID_U_SID:
                dwSIDPropNum = i;
                tmpProp[i] = PROPID_MQU_SID;
                break;
            case PROPID_U_SIGN_CERT:
                dwCertPropNum = i;
                tmpProp[i] = PROPID_MQU_SIGN_CERT;
                break;
            case PROPID_U_MASTERID:
                tmpProp[i] = PROPID_MQU_MASTERID;
                break;
            case PROPID_U_SEQNUM:
                tmpProp[i] = PROPID_MQU_SEQNUM;
                break;
            case PROPID_U_DIGEST:
                dwDigestPropNum = i;
                tmpProp[i] = PROPID_MQU_DIGEST;
                break;
            case PROPID_U_ID:
                dwIdPropNum = i;
                tmpProp[i] = PROPID_MQU_ID;
                break;
            default:
                ASSERT(0);
                break;
        }
    }

    if ( (dwSIDPropNum == cp) || (dwDigestPropNum == cp) ||
         (dwIdPropNum == cp) ||  (dwCertPropNum == cp))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CUserObject::CreateObject : Wrong input properties")));
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 330);
    }
    hr = _CreateUserObject(
                     cp,
                     tmpProp,
                     apVar
                     );
    if ( hr !=  MQDS_OBJECT_NOT_FOUND)
    {
        return LogHR(hr, s_FN, 340);
    }
    //
    //  No User or MQUser object were found ( for this SID).
    //  We assume it is a NT4 user and we'll create MQUser for
    //  it (in which we'll store the certificates).
    //  Creating the msmqMigratedUser is  done in the context
    //  of the user.
    //  That's not similar to regular Windows 2000 users, that are not the
    //  owner of their user object and have no permissions on that object.
    //
	//	If the MQUser OU is there, then we will not try to create it (
	//	the user will not have sufficient rights to do it)
	//
    CMqUserObject objectMqUser( m_pwcsPathName, NULL, m_pwcsDomainController, m_fServerName);
    hr = objectMqUser.CreateInAD(
                     cp,
                     tmpProp,
                     apVar,
                     NULL,
                     NULL
                     );
    return LogHR(hr, s_FN, 350);
}

HRESULT  CUserObject::_CreateUserObject(
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ]
                 )
/*++

Routine Description:
	Helper routine for creating user object. It tries to locate
	user or mq-user or computer object with the caller SID.

Arguments:
    DWORD         cp - number of properties        
    const PROPID  *aProp - the propperties
    const MQPROPVARIANT *apVar - properties value

Return Value:
	HRESULT
--*/
{
    ASSERT( m_pwcsPathName == NULL);
    //
    //  search the user according to its SID
    //
    DWORD dwNeedToFind = 3;
    BLOB blobUserSid;
    BLOB blobSignCert = {0, 0};
    GUID * pguidDigest = NULL;
    GUID * pguidId = NULL;  // if the caller doesn't supply it, use the digest as
                            // the id

    PROPID propSID = (PROPID)-1;
    AD_OBJECT eObject = eUSER;
    LPCWSTR pwcsSid = NULL;
    for ( DWORD i = 0 ; i < cp; i++)
    {

        if (aProp[i] == PROPID_U_SID)
        {
            blobUserSid= apVar[i].blob;
            propSID = aProp[i];
            pwcsSid = MQ_U_SID_ATTRIBUTE;
            eObject = eUSER;
            --dwNeedToFind;
        }
        if (aProp[i] == PROPID_COM_SID)
        {
            blobUserSid= apVar[i].blob;
            propSID = aProp[i];
            pwcsSid = MQ_COM_SID_ATTRIBUTE;
            eObject = eCOMPUTER;
            --dwNeedToFind;
        }
        if (aProp[i] == PROPID_MQU_SID)
        {
            blobUserSid= apVar[i].blob;
            propSID = aProp[i];
            pwcsSid = MQ_MQU_SID_ATTRIBUTE;
            eObject = eMQUSER;
            --dwNeedToFind;
        }

        if ( (aProp[i] == PROPID_U_SIGN_CERT)   ||
             (aProp[i] == PROPID_COM_SIGN_CERT) ||
             (aProp[i] == PROPID_MQU_SIGN_CERT) )
        {
            blobSignCert = apVar[i].blob;
            --dwNeedToFind;
        }
        if ( (aProp[i] == PROPID_U_DIGEST)   ||
             (aProp[i] == PROPID_COM_DIGEST) ||
             (aProp[i] == PROPID_MQU_DIGEST) )
        {
            pguidDigest = apVar[i].puuid;
            --dwNeedToFind;
        }
        if ( (aProp[i] == PROPID_U_ID)   ||
             (aProp[i] == PROPID_COM_ID) ||
             (aProp[i] == PROPID_MQU_ID) )
        {
            pguidId = apVar[i].puuid;
        }
    }

    PROPID propDigest = PROPID_U_DIGEST;
    if (propSID == PROPID_COM_SID)
    {
        propDigest = PROPID_COM_DIGEST;
    }
    else if (propSID == PROPID_MQU_SID)
    {
        propDigest = PROPID_MQU_DIGEST;
    }

    if ( dwNeedToFind != 0)
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("_CreateUserObject : Wrong input properties")));
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 270);
    }
    if ( pguidId == NULL)
    {
        //
        //  Use the digest as the id ( for replication to NT4 only)
        //
        pguidId = pguidDigest;
    }
    //
    //  Find the user object according to its SID
    //
    HRESULT hr;
    const DWORD cNumProperties = 3;
    PROPID prop[cNumProperties] = { propDigest,
                                    PROPID_U_SIGN_CERT,
                                    PROPID_U_ID};
    MQPROPVARIANT var[ cNumProperties];
    var[0].vt = VT_NULL;
    var[1].vt = VT_NULL;
    var[2].vt = VT_NULL;
    ASSERT( cNumProperties == 3);

    hr =  FindUserAccordingToSid(
                 FALSE,  // fOnlyInDC
                 FALSE,  // fOnlyInGC
                 eObject,
                &blobUserSid,
                pwcsSid,
                cNumProperties,
                prop,
                var
                );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 280);
    }
    AP<GUID> pCleanDigest =  var[0].cauuid.pElems;
    AP<BYTE> pCleanCert = var[1].blob.pBlobData;
    P<GUID> pCleanId =  var[2].puuid;

    //
    // Check if it's a new user certificate or one that is already registered.
    // Control panel code first try to register old certificate (to verify
    // that user indeed has write permission in the active directory to do
    // that) and only then create a new certificate and register it. So
    // this case (trying to register an existing certificate) is legitimate
    // and mqrt.dll + control panel handle it correctly.
    //
    DWORD dwSize = var[0].cauuid.cElems;
    for ( DWORD j = 0; j < dwSize; j++)
    {
        if ( pCleanDigest[j] == *pguidDigest)
        {
            return LogHR(MQDS_CREATE_ERROR, s_FN, 290); // for compatability : RT translates to MQ_ERROR_INTERNAL_USER_CERT_EXIST
        }
    }

    //
    //  Now add the digest and certificate to the array of values
    //
    //
    //  First digest array
    //
    AP<GUID> pGuids = new GUID[ dwSize  + 1];
    if ( dwSize)
    {
        memcpy( pGuids, pCleanDigest, dwSize * sizeof(GUID));  // old array content
    }
    memcpy( &pGuids[ dwSize], pguidDigest, sizeof(GUID));    // new addition
    var[0].cauuid.cElems += 1;
    var[0].cauuid.pElems = pGuids;
    //
    //  Second user certificate
    //
    ASSERT( prop[1] == PROPID_U_SIGN_CERT);

    dwSize = var[1].blob.cbSize;
    ULONG ulUserCertBufferSize = CUserCert::CalcSize( blobSignCert.cbSize);
    AP<unsigned char> pBuffUserCert = new unsigned char[ ulUserCertBufferSize];

#ifdef _DEBUG
#undef new
#endif
    CUserCert * pUserCert = new(pBuffUserCert) CUserCert(
                                   *pguidDigest,
                                   *pguidId,
                                   blobSignCert.cbSize,
                                   blobSignCert.pBlobData);
    AP<BYTE> pbTmp;
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    if ( dwSize)
    {
        pbTmp = new BYTE[ dwSize + ulUserCertBufferSize];
        //
        //  there are already certificates for this user
        //
        CUserCertBlob * pUserCertBlob =
            reinterpret_cast<CUserCertBlob *>( var[1].blob.pBlobData);

        pUserCertBlob->IncrementNumCertificates();
        memcpy( pbTmp, var[1].blob.pBlobData, dwSize);
        pUserCert->MarshaleIntoBuffer( &pbTmp[ dwSize]);
        var[1].blob.cbSize = dwSize + ulUserCertBufferSize;

    }
    else
    {
        pbTmp = new BYTE[ CUserCertBlob::CalcSize() + ulUserCertBufferSize ];
#ifdef _DEBUG
#undef new
#endif
        CUserCertBlob * pUserCertBlob = new(pbTmp) CUserCertBlob(
                                    pUserCert);
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

        pUserCertBlob->MarshaleIntoBuffer( pbTmp);
        var[1].blob.cbSize = CUserCertBlob::CalcSize() + ulUserCertBufferSize;

    }

    var[1].blob.pBlobData = pbTmp;

    //
    //  Update the user object with the new values
    //
    CUserObject objectUser(NULL, var[2].puuid, m_pwcsDomainController, m_fServerName); 
    hr = g_AD.SetObjectProperties(
                adpDomainController,
                &objectUser,
                2,
                prop,
                var,
                NULL,   // pObjInfoRequest
                NULL    // pParentInfoRequest
                );

    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("_CreateUserObject : failed to update user props %lx"),hr));
    }
    return LogHR(hr, s_FN, 300);
}


HRESULT CUserObject::FindUserAccordingToSid(
                IN  BOOL            fOnlyInDC,
                IN  BOOL            fOnlyInGC,
                IN  AD_OBJECT       eObject,
                IN  BLOB *          pblobUserSid,
                IN  LPCWSTR         pwcsSID,
                IN  DWORD           dwNumProps,
                IN  const PROPID *  propToRetrieve,
                IN OUT PROPVARIANT* varResults
                )
/*++

Routine Description:
    The routine finds a user or MQUser object according to SID, and retrieves
    the requested properties

Arguments:
	BOOL            fOnlyInDC - to look for the object only in DC
	BOOL            fOnlyInGC - to look for the object only in GC
	AD_OBJECT       eObject - object type
	BLOB *          pblobUserSid - the user SID
	LPCWSTR         pwcsSID - the sid attribute string
	DWORD           dwNumProps - number of properties
	const PROPID *  propToRetrieve - properties 
	PROPVARIANT*    varResults - properties values


Return Value:
    The status of the ds operation.

--*/
{
    //
    // Only one of these two flags can be true.
    //
    ASSERT(!(fOnlyInDC && fOnlyInGC)) ;

    //
    //  Find the user object according to its SID
    //
    HRESULT hr;

    DWORD dwNumResults = dwNumProps ;
    BOOL fUserFound = FALSE ;
    MQCOLUMNSET  Columns = { dwNumProps,
                             const_cast<PROPID*> (propToRetrieve) } ;
    hr = LocateUser( 
			m_pwcsDomainController,
			m_fServerName,
			fOnlyInDC,
			fOnlyInGC,
			eObject,
			pwcsSID,
			pblobUserSid,
			NULL,  // pguidDigest 
			&Columns,
			varResults,
			&dwNumResults,
			&fUserFound 
			);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 70);
    }
    else if (!fUserFound)
    {
        //
        //  failed to find user object
        //
        return LogHR(MQDS_OBJECT_NOT_FOUND, s_FN, 80);
    }

    ASSERT(dwNumResults ==  dwNumProps);
    return(MQ_OK);
}


HRESULT CUserObject::VerifyAndAddProps(
            IN  const DWORD            cp,        
            IN  const PROPID *         aProp, 
            IN  const MQPROPVARIANT *  apVar, 
            IN  PSECURITY_DESCRIPTOR   /* pSecurityDescriptor*/,
            OUT DWORD*                 pcpNew,
            OUT PROPID**               ppPropNew,
            OUT MQPROPVARIANT**        ppVarNew
            )
/*++
    Abstract:
	verifies site properties and adds user SID

    Parameters:
    const DWORD            cp - number of props        
    const PROPID *         aProp - props ids
    const MQPROPVARIANT *  apVar - properties value
    PSECURITY_DESCRIPTOR   pSecurityDescriptor - SD for the object
    DWORD*                 pcpNew - new number of props
    PROPID**               ppPropNew - new prop ids
    OMQPROPVARIANT**       ppVarNew - new properties values

    Returns:
	HRESULT
--*/
{
    //
    // Security property should never be supplied as a property
    //
    PROPID pSecId = GetObjectSecurityPropid();
	bool fMachine = false;

    for ( DWORD i = 0; i < cp ; i++ )
    {
        if (pSecId == aProp[i])
        {
            ASSERT(0) ;
            return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 40);
        }

        if (aProp[i] == PROPID_COM_SIGN_CERT)
        {
            fMachine = true;
        }

    }
    //
    //  add SID attribute 
    //

    AP<PROPVARIANT> pAllPropvariants;
    AP<PROPID> pAllPropids;
    ASSERT( cp > 0);
    DWORD cpNew = cp + 1;
    //
    //  Just copy the caller supplied properties as is
    //
    if ( cp > 0)
    {
        pAllPropvariants = new PROPVARIANT[cpNew];
        pAllPropids = new PROPID[cpNew];
        memcpy (pAllPropvariants, apVar, sizeof(PROPVARIANT) * cp);
        memcpy (pAllPropids, aProp, sizeof(PROPID) * cp);
    }


    //
    //  add caller SID
    //
    HRESULT hr;
	PROPID prop;

    if (fMachine)
    {
		prop = PROPID_COM_SID;
        m_pUserSid = reinterpret_cast<BYTE *>(MQSec_GetLocalMachineSid(TRUE, NULL));
        if(m_pUserSid.get() == NULL)
        {
		    return LogHR(MQ_ERROR_ILLEGAL_USER, s_FN, 50);
        }

		ASSERT(IsValidSid(m_pUserSid.get()));
    }
	else
	{
		prop =	 PROPID_U_SID;
		hr = MQSec_GetThreadUserSid(FALSE, (PSID*) &m_pUserSid, NULL);
		if (hr == HRESULT_FROM_WIN32(ERROR_NO_TOKEN))
		{
			//
			//  Try the process, if the thread doesn't have a token
			//
			hr = MQSec_GetProcessUserSid((PSID*) &m_pUserSid, NULL);
		}
		if (FAILED(hr))
		{
			LogHR(hr, s_FN, 60);
			return MQ_ERROR_ILLEGAL_USER;
		}
		ASSERT(IsValidSid(m_pUserSid.get()));

		BOOL fAnonymus = MQSec_IsAnonymusSid( m_pUserSid.get());
		if (fAnonymus)
		{
			return LogHR(MQ_ERROR_ILLEGAL_USER, s_FN, 75);
		} 
	}

    pAllPropvariants[cp].vt = VT_BLOB;
    pAllPropvariants[cp].blob.cbSize = GetLengthSid(m_pUserSid.get());
    pAllPropvariants[cp].blob.pBlobData = (unsigned char *)m_pUserSid.get();
    pAllPropids[cp] = prop;

    *pcpNew = cpNew;
    *ppPropNew = pAllPropids.detach();
    *ppVarNew = pAllPropvariants.detach();
    return MQ_OK;

}

HRESULT CUserObject::GetObjectSecurity(
            IN  SECURITY_INFORMATION    /* RequestedInformation*/,
            IN  const PROPID            /* prop*/,
            IN OUT  PROPVARIANT *       /* pVar*/
            )
/*++

Routine Description:
    The routine retrieve user object security.

Arguments:
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	PROPVARIANT             pVar - property values

Return Value:
    The status of the ds operation.

--*/
{
    ASSERT(0);
    return LogHR(MQ_ERROR_PROPERTY_NOTALLOWED, s_FN, 450);
}

HRESULT CUserObject::SetObjectSecurity(
            IN  SECURITY_INFORMATION        /*RequestedInformation*/,
            IN  const PROPID                /*prop*/,
            IN  const PROPVARIANT *         /*pVar*/,
            IN OUT MQDS_OBJ_INFO_REQUEST *  /*pObjInfoRequest*/, 
            IN OUT MQDS_OBJ_INFO_REQUEST *  /*pParentInfoRequest*/
            )
/*++

Routine Description:
    The routine sets object security in AD 

Arguments:
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest - infomation about the object
    MQDS_OBJ_INFO_REQUEST * pParentInfoRequest - information about the object's parent

Return Value
	HRESULT

--*/
{
    //
    //  This operation is not supported
    //
    return MQ_ERROR_FUNCTION_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\xlatqm.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    xlatqm.cpp

Abstract:

    Implementation of routines to translate QM info from NT5 Active DS
    to what MSMQ 1.0 (NT4) QM's expect

Author:

    Raanan Harari (raananh)

--*/

#include "ds_stdh.h"
#include "mqads.h"
#include "mqattrib.h"
#include "xlatqm.h"
#include "mqadglbo.h"
#include "dsutils.h"
#include "_propvar.h"
#include "utils.h"
#include "adtempl.h"
#include "mqdsname.h"
#include "uniansi.h"
#include <mqsec.h>

#include "xlatqm.tmh"

static WCHAR *s_FN=L"mqdscore/xlatqm";

HRESULT WideToAnsiStr(LPCWSTR pwszUnicode, LPSTR * ppszAnsi);


//----------------------------------------------------------------------
//
// Static routines
//
//----------------------------------------------------------------------

STATIC HRESULT GetMachineNameFromQMObject(LPCWSTR pwszDN, LPWSTR * ppwszMachineName)
/*++

Routine Description:
    gets the machine name from the object's DN

Arguments:
    pwszDN              - Object's DN
    ppwszMachineName    - returned name for the object

Return Value:
    HRESULT

--*/
{
    //
    // copy to tmp buf so we can munge it
    //
    AP<WCHAR> pwszTmpBuf = new WCHAR[1+wcslen(pwszDN)];
    wcscpy(pwszTmpBuf, pwszDN);

    //
    // skip "CN=msmq,CN="
    // BUGBUG: need to write a parser for DN's
    //
    LPWSTR pwszTmp = wcschr(pwszTmpBuf, L',');
    if (pwszTmp)
        pwszTmp = wcschr(pwszTmp, L'=');
    if (pwszTmp)
        pwszTmp++;

    //
    // sanity check
    //
    if (pwszTmp == NULL)
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetMachineNameFromQMObject:Bad DN for QM object (%ls)"), pwszDN));
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 10);
    }

    LPWSTR pwszNameStart = pwszTmp;

    //
    // remove the ',' at the end of the name
    //
    pwszTmp = wcschr(pwszNameStart, L',');
    if (pwszTmp)
        *pwszTmp = L'\0';

    //
    // save name
    //
    AP<WCHAR> pwszMachineName = new WCHAR[1+wcslen(pwszNameStart)];
    wcscpy(pwszMachineName, pwszNameStart);

    //
    // return values
    //
    *ppwszMachineName = pwszMachineName.detach();
    return S_OK;
}

/*++

Routine Description:
    gets the computer DNS name

Arguments:
    pwcsComputerName    - the computer name
    ppwcsDnsName        - returned DNS name of the computer

Return Value:
    HRESULT

--*/
HRESULT MQADpGetComputerDns(
                IN  LPCWSTR     pwcsComputerName,
                IN  LPCWSTR     pwcsDomainController,
	            IN  bool		fServerName,
                OUT WCHAR **    ppwcsDnsName
                )
{
    *ppwcsDnsName = NULL;
    PROPID prop = PROPID_COM_DNS_HOSTNAME;
    PROPVARIANT varDnsName;
    varDnsName.vt = VT_NULL;
    //
    //  Is the computer in the local domain?
    //
    WCHAR * pszDomainName = wcsstr(pwcsComputerName, x_DcPrefix);
    ASSERT(pszDomainName) ;
    HRESULT hr;
    CComputerObject objectComputer(NULL, NULL, pwcsDomainController, fServerName);
    objectComputer.SetObjectDN(pwcsComputerName);

	AP<WCHAR> pwcsLocalDsRootToFree;
	LPWSTR pwcsLocalDsRoot = NULL;
	hr = g_AD.GetLocalDsRoot(
				pwcsDomainController, 
				fServerName,
				&pwcsLocalDsRoot,
				pwcsLocalDsRootToFree
				);

	if(FAILED(hr))
	{
		TrERROR(mqad, "Failed to get Local Ds Root, hr = 0x%x", hr);
	}

    if (SUCCEEDED(hr) && (!wcscmp( pszDomainName, pwcsLocalDsRoot))) 
    {
        //
        //   try local DC
        //
        hr = g_AD.GetObjectProperties(
            adpDomainController,
 	        &objectComputer,  
            1,
            &prop,
            &varDnsName);
    }
    else
    {

        hr =  g_AD.GetObjectProperties(
                    adpGlobalCatalog,
 	                &objectComputer,  
                    1,
                    &prop,
                    &varDnsName);
    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }

    //
    // return value
    //
    *ppwcsDnsName = varDnsName.pwszVal;
    return MQ_OK;
}


//----------------------------------------------------------------------
//
// CMsmqQmXlateInfo class
//
//----------------------------------------------------------------------


struct XLATQM_ADDR_SITE
//
// Describes an address in a site
//
{
    GUID        guidSite;
    USHORT      AddressLength;
    USHORT      usAddressType;
    sockaddr    Address;
};

class CQmXlateInfo : public CObjXlateInfo
//
// translate object for the QM DS object. It contains common info needed for
// for translation of several properties in the QM object
//
{
public:
    CQmXlateInfo(
        LPCWSTR             pwszObjectDN,
        const GUID*         pguidObjectGuid
        );
    ~CQmXlateInfo();


    HRESULT RetrieveFrss(
           IN  LPCWSTR          pwcsAttributeName,
           IN  LPCWSTR          pwcsDomainController,
           IN  bool				fServerName,
           OUT MQPROPVARIANT *  ppropvariant
           );


private:

    HRESULT RetrieveFrssFromDs(
           IN  LPCWSTR          pwcsAttributeName,
           IN  LPCWSTR          pwcsDomainController,
           IN  bool				fServerName,
           OUT MQPROPVARIANT *  pvar
           );



};




CQmXlateInfo::CQmXlateInfo(LPCWSTR          pwszObjectDN,
                                   const GUID*      pguidObjectGuid
                                   )
/*++

Routine Description:
    Class consructor. constructs base object, and initilaizes class

Arguments:
    pwszObjectDN    - DN of object in DS
    pguidObjectGuid - GUID of object in DS

Return Value:
    None

--*/
 : CObjXlateInfo(pwszObjectDN, pguidObjectGuid)
{
}


CQmXlateInfo::~CQmXlateInfo()
/*++

Routine Description:
    Class destructor

Arguments:
    None

Return Value:
    None

--*/
{
    //
    // members are auto delete classes
    //
}






static 
HRESULT 
FillQmidsFromQmDNs(
		IN const PROPVARIANT * pvarQmDNs,
		IN LPCWSTR             pwcsDomainController,
        IN bool				   fServerName,
		OUT PROPVARIANT * pvarQmids
		)
/*++

Routine Description:
    Given a propvar of QM DN's, fills a propvar of QM id's
    returns an error if none of the QM DN's could be converted to guids

Arguments:
    pvarQmDNs       - QM distinguished names propvar
    pvarQmids       - returned QM ids propvar

Return Value:
    None

--*/
{

    //
    // sanity check
    //
    if (pvarQmDNs->vt != (VT_LPWSTR|VT_VECTOR))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1716);
    }

    //
    // return an empty guid list if there is an empty DN list
    //
    if (pvarQmDNs->calpwstr.cElems == 0)
    {
        pvarQmids->vt = VT_CLSID|VT_VECTOR;
        pvarQmids->cauuid.cElems = 0;
        pvarQmids->cauuid.pElems = NULL;
        return MQ_OK;
    }

    //
    // DN list is not empty
    // allocate guids in an auto free propvar
    //
    CMQVariant varTmp;
    PROPVARIANT * pvarTmp = varTmp.CastToStruct();
    pvarTmp->cauuid.pElems = new GUID [pvarQmDNs->calpwstr.cElems];
    pvarTmp->cauuid.cElems = pvarQmDNs->calpwstr.cElems;
    pvarTmp->vt = VT_CLSID|VT_VECTOR;

    //
    //  Translate each of the QM DN into unique id
    //
    ASSERT(pvarQmDNs->calpwstr.pElems != NULL);
    PROPID prop = PROPID_QM_MACHINE_ID;
    PROPVARIANT varQMid;
    DWORD dwNextToFile = 0;
    for ( DWORD i = 0; i < pvarQmDNs->calpwstr.cElems; i++)
    {
        varQMid.vt = VT_CLSID; // so returned guid will not be allocated
        varQMid.puuid = &pvarTmp->cauuid.pElems[dwNextToFile];

        
        WCHAR * pszDomainName = wcsstr(pvarQmDNs->calpwstr.pElems[i], x_DcPrefix);
        ASSERT(pszDomainName) ;
        HRESULT hr;
        CMqConfigurationObject objectQM(NULL, NULL, pwcsDomainController, fServerName);
        objectQM.SetObjectDN( pvarQmDNs->calpwstr.pElems[i]); 
        //
        //  try local DC if FRS belongs to the same domain
        //
		AP<WCHAR> pwcsLocalDsRootToFree;
		LPWSTR pwcsLocalDsRoot = NULL;
		hr = g_AD.GetLocalDsRoot(
					pwcsDomainController, 
					fServerName,
					&pwcsLocalDsRoot,
					pwcsLocalDsRootToFree
					);

		if(FAILED(hr))
		{
			TrERROR(mqad, "Failed to get Local Ds Root, hr = 0x%x", hr);
		}

		if (SUCCEEDED(hr) && (!wcscmp( pszDomainName, pwcsLocalDsRoot))) 
        {
            hr = g_AD.GetObjectProperties(
                                adpDomainController,
                                &objectQM,
                                1,
                                &prop,
                                &varQMid
                                );
        }
        else
        {
            hr = g_AD.GetObjectProperties(
                                adpGlobalCatalog,
                                &objectQM,
                                1,
                                &prop,
                                &varQMid
                                );
        }
        if (SUCCEEDED(hr))
        {
            dwNextToFile++;
        }
    }

    if (dwNextToFile == 0)
    {
        //
        //  no FRS in the list is a valid one ( they were
        //  uninstalled probably)
        //
        pvarQmids->vt = VT_CLSID|VT_VECTOR;
        pvarQmids->cauuid.cElems = 0;
        pvarQmids->cauuid.pElems = NULL;
        return MQ_OK;
    }

    //
    // return results
    //
    pvarTmp->cauuid.cElems = dwNextToFile;
    *pvarQmids = *pvarTmp;   // set returned propvar
    pvarTmp->vt = VT_EMPTY;  // detach varTmp
    return MQ_OK;
}


HRESULT CQmXlateInfo::RetrieveFrss(
           IN  LPCWSTR          pwcsAttributeName,
           IN  LPCWSTR          pwcsDomainController,
	       IN bool				fServerName,
           OUT MQPROPVARIANT *  ppropvariant
           )
/*++

Routine Description:
    Retrieves IN or OUT FRS property from the DS.
    In the DS we keep the distingushed name of the FRSs. DS client excpects
    to retrieve the unique-id of the FRSs. Therefore for each FRS ( according
    to its DN) we retrieve its unique-id.


Arguments:
    pwcsAttributeName   : attribute name string ( IN or OUT FRSs)
    ppropvariant        : propvariant in which the retrieved values are returned.

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    ASSERT((ppropvariant->vt == VT_NULL) || (ppropvariant->vt == VT_EMPTY));
    //
    //  Retrieve the DN of the FRSs
    //  into an auto free propvar
    //
    CMQVariant varFrsDn;
    hr = RetrieveFrssFromDs(
                    pwcsAttributeName,
                    pwcsDomainController,
					fServerName,
                    varFrsDn.CastToStruct()
					);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::RetrieveFrss:pQMTrans->RetrieveOutFrss()=%lx "),hr));
        return LogHR(hr, s_FN, 1656);
    }

    HRESULT hr2 = FillQmidsFromQmDNs(varFrsDn.CastToStruct(), pwcsDomainController, fServerName, ppropvariant);
    return LogHR(hr2, s_FN, 1657);
}


HRESULT CQmXlateInfo::RetrieveFrssFromDs(
           IN  LPCWSTR          pwcsAttributeName,
           IN  LPCWSTR          pwcsDomainController,
	       IN bool				fServerName,
           OUT MQPROPVARIANT *  pvar
           )
/*++

Routine Description:
    Retrieves the computer's frss.

Arguments:
    pwcsAttributeName   : attribute name string ( IN or OUT FRSs)
    ppropvariant        : propvariant in which the retrieved values are returned.

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // get the FRSs stored in the DS for the computer
    //
    hr = GetDsProp(
			pwcsAttributeName,
			pwcsDomainController,
			fServerName,
			ADSTYPE_DN_STRING,
			VT_VECTOR|VT_LPWSTR,
			TRUE,		 //fMultiValued
			pvar
			);
    if (FAILED(hr) && (hr != E_ADS_PROPERTY_NOT_FOUND))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::RetrieveFrssFromDs:GetDsProp(%ls)=%lx"), MQ_QM_OUTFRS_ATTRIBUTE, hr));
        return LogHR(hr, s_FN, 1661);
    }

    //
    // if property is not there, we return 0 frss
    //
    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        pvar->vt = VT_LPWSTR|VT_VECTOR;
        pvar->calpwstr.cElems = 0;
        pvar->calpwstr.pElems = NULL;
        return MQ_OK;
    }

    return( MQ_OK);

}

//----------------------------------------------------------------------
//
// Routine to get a default translation object for MSMQ DS objects
//
//----------------------------------------------------------------------
HRESULT WINAPI GetQmXlateInfo(
                 IN  LPCWSTR                pwcsObjectDN,
                 IN  const GUID*            pguidObjectGuid,
                 OUT CObjXlateInfo**        ppcObjXlateInfo)
/*++
    Abstract:
        Routine to get a translate object that will be passed to
        translation routines to all properties of the QM

    Parameters:
        pwcsObjectDN        - DN of the translated object
        pguidObjectGuid     - GUID of the translated object
        ppcObjXlateInfo -     Where the translate object is put

    Returns:
      HRESULT
--*/
{
    *ppcObjXlateInfo = new CQmXlateInfo(pwcsObjectDN, pguidObjectGuid);
    return MQ_OK;
}


/*====================================================

MQADpRetrieveMachineName

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpRetrieveMachineName(
                 IN  CObjXlateInfo * pTrans,
                 IN  LPCWSTR         /* pwcsDomainController */,
		         IN  bool			 /* fServerName */,
                 OUT PROPVARIANT * ppropvariant)
{
    //
    // get the machine name
    //
    AP<WCHAR> pwszMachineName;
    HRESULT hr = GetMachineNameFromQMObject(pTrans->ObjectDN(), &pwszMachineName);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("MQADpRetrieveMachineName:GetMachineNameFromQMObject()=%lx"), hr));
        return LogHR(hr, s_FN, 1667);
    }

    CharLower(pwszMachineName);

    //
    // set the returned prop variant
    //
    ppropvariant->pwszVal = pwszMachineName.detach();
    ppropvariant->vt = VT_LPWSTR;
    return(MQ_OK);
}

/*====================================================

MQADpRetrieveMachineDNSName

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpRetrieveMachineDNSName(
                 IN  CObjXlateInfo * pTrans,
                 IN  LPCWSTR         pwcsDomainController,
		         IN bool			 fServerName,
                 OUT PROPVARIANT * ppropvariant)
{
    //
    // read dNSHostName of the computer object
    //
    WCHAR * pwcsComputerName = wcschr(pTrans->ObjectDN(), L',') + 1;
    WCHAR * pwcsDnsName; 
    HRESULT hr = MQADpGetComputerDns(
                pwcsComputerName,
                pwcsDomainController,
			    fServerName,
                &pwcsDnsName
                );
    if ( hr == HRESULT_FROM_WIN32(E_ADS_PROPERTY_NOT_FOUND))
    {
        //
        //    The dNSHostName attribute doesn't have value
        //
        ppropvariant->vt = VT_EMPTY;
        return MQ_OK;
    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1718);
    }

    CharLower(pwcsDnsName);

    //
    // set the returned prop variant
    //
    ppropvariant->pwszVal = pwcsDnsName;
    ppropvariant->vt = VT_LPWSTR;
    return(MQ_OK);
}


/*====================================================

MQADpRetrieveMachineOutFrs

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpRetrieveMachineOutFrs(
                 IN  CObjXlateInfo * pTrans,
                 IN  LPCWSTR         pwcsDomainController,
		         IN bool			 fServerName,
                 OUT PROPVARIANT * ppropvariant
				 )
{
    HRESULT hr;

    //
    // get derived translation context
    //
    CQmXlateInfo * pQMTrans = (CQmXlateInfo *) pTrans;

    hr = pQMTrans->RetrieveFrss( 
						MQ_QM_OUTFRS_ATTRIBUTE,
						pwcsDomainController,
						fServerName,
						ppropvariant
						);

    return LogHR(hr, s_FN, 1721);

}

/*====================================================

MQADpRetrieveMachineInFrs

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpRetrieveMachineInFrs(
                 IN  CObjXlateInfo * pTrans,
                 IN  LPCWSTR         pwcsDomainController,
		         IN bool			 fServerName,
                 OUT PROPVARIANT * ppropvariant
				 )
{
    HRESULT hr;

    //
    // get derived translation context
    //
    CQmXlateInfo * pQMTrans = (CQmXlateInfo *) pTrans;

    hr = pQMTrans->RetrieveFrss( 
						MQ_QM_INFRS_ATTRIBUTE,
						pwcsDomainController,
						fServerName,
						ppropvariant
						);
    return LogHR(hr, s_FN, 1722);
}

/*====================================================

MQADpRetrieveQMService

Arguments:

Return Value:
                  [adsrv]
=====================================================*/
HRESULT WINAPI MQADpRetrieveQMService(
                 IN  CObjXlateInfo * pTrans,
                 IN  LPCWSTR         pwcsDomainController,
		         IN bool			 fServerName,
                 OUT PROPVARIANT * ppropvariant
				 )
{
    HRESULT hr;

    //
    // get derived translation context
    //
    CQmXlateInfo * pQMTrans = (CQmXlateInfo *) pTrans;

    //
    // get the QM service type bits
    //
    MQPROPVARIANT varRoutingServer, varDsServer;  //, varDepClServer;
    varRoutingServer.vt = VT_UI1;
    varDsServer.vt      = VT_UI1;

    hr = pQMTrans->GetDsProp(
						MQ_QM_SERVICE_ROUTING_ATTRIBUTE,
						pwcsDomainController,
						fServerName,
						MQ_QM_SERVICE_ROUTING_ADSTYPE,
						VT_UI1,
						FALSE,
						&varRoutingServer
						);
    if (FAILED(hr))
    {
        if (hr == E_ADS_PROPERTY_NOT_FOUND)
        {
            //
            //  This can happen if some of the computers were installed
            //  with Beta2 DS servers
            //
            //  In this case, we return the old-service as is.
            //
            hr = pQMTrans->GetDsProp(
								MQ_QM_SERVICE_ATTRIBUTE,
								pwcsDomainController,
								fServerName,
								MQ_QM_SERVICE_ADSTYPE,
								VT_UI4,
								FALSE,
								ppropvariant
								);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 1723);
            }
            else
            {
                ppropvariant->vt = VT_UI4;
                return(MQ_OK);
            }

        }


        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("MQADpRetrieveQMService:GetDsProp(MQ_QM_SERVICE_ROUTING_ATTRIBUTE)=%lx"), hr));
        return LogHR(hr, s_FN, 1668);
    }

    hr = pQMTrans->GetDsProp(
						MQ_QM_SERVICE_DSSERVER_ATTRIBUTE,
						pwcsDomainController,
						fServerName,
						MQ_QM_SERVICE_DSSERVER_ADSTYPE,
						VT_UI1,
						FALSE,
						&varDsServer
						);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("MQADpRetrieveQMService:GetDsProp(MQ_QM_SERVICE_DSSERVER_ATTRIBUTE)=%lx"), hr));
        return LogHR(hr, s_FN, 1669);
    }


    //
    // set the returned prop variant
    //
    ppropvariant->vt    = VT_UI4;
    ppropvariant->ulVal = (varDsServer.bVal ? SERVICE_PSC : (varRoutingServer.bVal ? SERVICE_SRV : SERVICE_NONE));
    return(MQ_OK);
}

/*====================================================

MQADpRetrieveMachineSite

Arguments:

Return Value:
=====================================================*/
HRESULT WINAPI MQADpRetrieveMachineSite(
                 IN  CObjXlateInfo * pTrans,
                 IN  LPCWSTR         pwcsDomainController,
		         IN bool			 fServerName,
                 OUT PROPVARIANT * ppropvariant
				 )
{
    //
    //  This routine supports retreival of PROPID_QM_SITE_ID.
    //
    //  Though this property is obsolete, since it is exposed in MSMQ API,
    //  we continue to support it
    //

    //
    //  Get the list of site-ids, and return the first one
    //
    CMQVariant varSites;
    HRESULT hr; 

    //
    // get derived translation context
    //
    CQmXlateInfo * pQMTrans = (CQmXlateInfo *) pTrans;

    hr = pQMTrans->GetDsProp(
						MQ_QM_SITES_ATTRIBUTE,
						pwcsDomainController,
						fServerName,
						MQ_QM_SITES_ADSTYPE,
						VT_CLSID|VT_VECTOR,
						TRUE,
						varSites.CastToStruct()
						);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1725);
    }
    ASSERT( (varSites.GetCACLSID())->cElems > 0);

    if (ppropvariant->vt == VT_NULL)
    {
        ppropvariant->puuid = new GUID;
        ppropvariant->vt = VT_CLSID;
    }
    *ppropvariant->puuid = *(varSites.GetCACLSID())->pElems;
    return MQ_OK;

}


static 
HRESULT  
SetMachineFrss(
     IN const PROPID       propidFRS,
     IN LPCWSTR            pwcsDomainController,
	 IN bool			   fServerName,
     IN const PROPVARIANT *pPropVar,
     OUT PROPID           *pdwNewPropID,
     OUT PROPVARIANT      *pNewPropVar
	 )
/*++

Routine Description:
    Translate PROPID_QM_??FRS to PROPID_QM_??FRS_DN, for set or create
    operation

Arguments:
    propidFRS   - the proerty that we translate to
    pPropVar    - the user supplied property value
    pdwNewPropID - the property that we translate to
    pNewPropVar  - the translated property value

Return Value:
    HRESULT

--*/
{
    //
    //  When the user tries to set PROPID_QM_OUTFRS or
    //  PROPID_QM_INFRS, we need to translate the frss'
    //  unqiue-id to their DN.
    //
    ASSERT(pPropVar->vt == (VT_CLSID|VT_VECTOR));
    *pdwNewPropID = propidFRS;

    if ( pPropVar->cauuid.cElems == 0)
    {
        //
        //  No FRSs
        //
        pNewPropVar->calpwstr.cElems = 0;
        pNewPropVar->calpwstr.pElems = NULL;
        pNewPropVar->vt = VT_LPWSTR|VT_VECTOR;
       return(S_OK);
    }
    HRESULT hr;
    //
    //  Translate unique id to DN
    //
    pNewPropVar->calpwstr.cElems = pPropVar->cauuid.cElems;
    pNewPropVar->calpwstr.pElems = new LPWSTR[ pPropVar->cauuid.cElems];
    memset(  pNewPropVar->calpwstr.pElems, 0, pPropVar->cauuid.cElems * sizeof(LPWSTR));
    pNewPropVar->vt = VT_LPWSTR|VT_VECTOR;

    PROPID prop = PROPID_QM_FULL_PATH;
    PROPVARIANT var;

    for (DWORD i = 0; i < pPropVar->cauuid.cElems; i++)
    {
        var.vt = VT_NULL;

        CMqConfigurationObject object(NULL, &pPropVar->cauuid.pElems[i], pwcsDomainController, fServerName);
        hr = g_AD.GetObjectProperties(
                    adpGlobalCatalog,	
                    &object,
                    1,
                    &prop,
                    &var);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 1733);
        }
        pNewPropVar->calpwstr.pElems[i] = var.pwszVal;
    }
    return(S_OK);
}


/*====================================================

MQADpCreateMachineOutFrss

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpCreateMachineOutFrss(
                 IN const PROPVARIANT *pPropVar,
                 IN LPCWSTR            pwcsDomainController,
		         IN bool			   fServerName,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar
				 )
{
        HRESULT hr2 = SetMachineFrss(
                         PROPID_QM_OUTFRS_DN,
                         pwcsDomainController,
						 fServerName,
                         pPropVar,
                         pdwNewPropID,
                         pNewPropVar
						 );
        return LogHR(hr2, s_FN, 1734);
}
/*====================================================

MQADpSetMachineOutFrss

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpSetMachineOutFrss(
                 IN IADs *             pAdsObj,
                 IN LPCWSTR            pwcsDomainController,
		         IN bool			   fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar
				 )
{
        UNREFERENCED_PARAMETER( pAdsObj);
        HRESULT hr2 = SetMachineFrss(
                         PROPID_QM_OUTFRS_DN,
                         pwcsDomainController,
						 fServerName,
                         pPropVar,
                         pdwNewPropID,
                         pNewPropVar
						 );
        return LogHR(hr2, s_FN, 1746);
}


/*====================================================

MQADpCreateMachineInFrss

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpCreateMachineInFrss(
                 IN const PROPVARIANT *pPropVar,
                 IN LPCWSTR            pwcsDomainController,
		         IN bool			   fServerName,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
        HRESULT hr2 = SetMachineFrss(
                         PROPID_QM_INFRS_DN,
                         pwcsDomainController,
						 fServerName,
                         pPropVar,
                         pdwNewPropID,
                         pNewPropVar
						 );
        return LogHR(hr2, s_FN, 1747);
}

/*====================================================

MQADpSetMachineInFrss

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpSetMachineInFrss(
                 IN IADs *             pAdsObj,
                 IN LPCWSTR            pwcsDomainController,
		         IN bool			   fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar
				 )
{
        UNREFERENCED_PARAMETER( pAdsObj);
        HRESULT hr2 = SetMachineFrss(
                         PROPID_QM_INFRS_DN,
                         pwcsDomainController,
						 fServerName,
                         pPropVar,
                         pdwNewPropID,
                         pNewPropVar
						 );
        return LogHR(hr2, s_FN, 1748);
}



/*====================================================

MQADpSetMachineServiceInt

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpSetMachineServiceTypeInt(
                 IN  PROPID            propFlag,
                 IN  LPCWSTR           pwcsDomainController,
		         IN bool			   fServerName,
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    //
    //  If service < SERVICE_SRV then nothing to do.
    //
    *pdwNewPropID = 0;
    UNREFERENCED_PARAMETER( pNewPropVar);
    
    //
    //  Set this value in msmqSetting
    //
    //
    //  First get the QM-id from msmqConfiguration
    //
    BS bsProp(MQ_QM_ID_ATTRIBUTE);
    CAutoVariant varResult;
    HRESULT  hr = pAdsObj->Get(bsProp, &varResult);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_TRACE, TEXT("MQADpSetMachineService:pIADs->Get()=%lx"), hr));
        return LogHR(hr, s_FN, 1751);
    }

    //
    // translate to propvariant
    //
    CMQVariant propvarResult;
    hr = Variant2MqVal(propvarResult.CastToStruct(), &varResult, MQ_QM_ID_ADSTYPE, VT_CLSID);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("MQADpSetMachineService:Variant2MqVal()=%lx"), hr));
        return LogHR(hr, s_FN, 1671);
    }

    //
    //  Locate all msmq-settings of the QM and change the service level
    //

    //
    //  Find the distinguished name of the msmq-setting
    //
    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;
    propRestriction.prop = PROPID_SET_QM_ID;
    propRestriction.prval.vt = VT_CLSID;
    propRestriction.prval.puuid = propvarResult.GetCLSID();

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;

    PROPID prop = PROPID_SET_FULL_PATH;

    // BUGBUG - to prepare restriction
    AP<WCHAR> pwcsSearchFilter;

    CAdQueryHandle hQuery;
    R<CSettingObject> pObject = new CSettingObject(NULL, NULL, pwcsDomainController, fServerName);

    hr = g_AD.LocateBegin(
            searchSubTree,	
            adpDomainController,	
            e_SitesContainer,    //  Context 
            pObject.get(),
            NULL,				 // pguidSearchBase 
            pwcsSearchFilter,   
            NULL,				 // pDsSortKey 
            1,
            &prop,
            hQuery.GetPtr()
			);

    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADpSetMachineService : Locate begin failed %lx"),hr));
        return LogHR(hr, s_FN, 1754);
    }
    //
    //  Read the results
    //
    DWORD cp = 1;
    MQPROPVARIANT var;

    var.vt = VT_NULL;

    HRESULT hr1 = MQ_OK;
    while (SUCCEEDED(hr = g_AD.LocateNext(
                hQuery.GetHandle(),
                &cp,
                &var
                )))
    {
        if ( cp == 0)
        {
            //
            //  Not found -> nothing to change.
            //
            break;
        }
        AP<WCHAR> pClean = var.pwszVal;
        //
        //  change the msmq-setting object
        //
        CSettingObject object(NULL, NULL, pwcsDomainController, fServerName);
		object.SetObjectDN(var.pwszVal);

        hr = g_AD.SetObjectProperties (
                        adpDomainController,
                        &object,
                        1,
                        &propFlag,              
                        pPropVar,
                        NULL,	// pObjInfoRequest
                        NULL    // pParentInfoRequest
                        );

        if (FAILED(hr))
        {
            hr1 = hr;
        }

    }
    if (FAILED(hr1))
    {
        return LogHR(hr1, s_FN, 1756);
    }

    return LogHR(hr, s_FN, 1757);
}

/*====================================================

MQADpSetMachineServiceDs

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpSetMachineServiceDs(
                 IN IADs *             pAdsObj,
                 IN LPCWSTR            pwcsDomainController,
		         IN bool			   fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    HRESULT hr = MQADpSetMachineServiceTypeInt(
					 PROPID_SET_SERVICE_DSSERVER,
                     pwcsDomainController,
					 fServerName,
					 pAdsObj,
					 pPropVar,
					 pdwNewPropID,
					 pNewPropVar
					 );
    if (FAILED(hr))
    {
    	return LogHR(hr, s_FN, 1758);
    }
	
    //
    // we have to reset PROPID_SET_NT4 flag. 
    // In general this flag was reset by migration tool for PEC/PSC.
    // The problem is BSC. After BSC upgrade we have to change
    // PROPID_SET_NT4 flag to 0 and if this BSC is not DC we have to 
    // reset PROPID_SET_SERVICE_DSSERVER flag too. 
    // So, when QM runs first time after upgrade, it completes upgrade
    // process and tries to set PROPID_SET_SERVICE_DSSERVER. 
    // Together with this flag we can change PROPID_SET_NT4 too.
    //

    //
    // BUGBUG: we need to perform set only for former BSC.
    // Here we do it everytime for every server. 
    //
    PROPVARIANT propVarSet;
    propVarSet.vt = VT_UI1;
    propVarSet.bVal = 0;

    hr = MQADpSetMachineServiceTypeInt(
				     PROPID_SET_NT4,
                     pwcsDomainController,
					 fServerName,
				     pAdsObj,
				     &propVarSet,
				     pdwNewPropID,
				     pNewPropVar
					 );

    return LogHR(hr, s_FN, 1759);
}


/*====================================================

MQADpSetMachineServiceRout

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpSetMachineServiceRout(
                 IN IADs *             pAdsObj,
                 IN LPCWSTR            pwcsDomainController,
		         IN bool			   fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    HRESULT hr2 = MQADpSetMachineServiceTypeInt(
						 PROPID_SET_SERVICE_ROUTING,
						 pwcsDomainController,
						 fServerName,
						 pAdsObj,
						 pPropVar,
						 pdwNewPropID,
						 pNewPropVar
						 );
    return LogHR(hr2, s_FN, 1761);
}

/*====================================================

MQADpSetMachineService

Arguments:

Return Value:

=====================================================*/

// [adsrv] BUGBUG:  TBD: If there will be any setting of PROPID_QM_OLDSERVICE, we'll have to rewrite it...

HRESULT WINAPI MQADpSetMachineService(
                 IN IADs *             pAdsObj,
                 IN LPCWSTR            pwcsDomainController,
		         IN bool			   fServerName,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    //
    //  If service < SERVICE_SRV then nothing to do.
    //
    *pdwNewPropID = 0;
    UNREFERENCED_PARAMETER( pNewPropVar);

    if ( pPropVar->ulVal < SERVICE_SRV)
    {
        return S_OK;
    }
    //
    //  Set this value in msmqSetting
    //
    //
    //  First get the QM-id from msmqConfiguration
    //
    BS bsProp(MQ_QM_ID_ATTRIBUTE);
    CAutoVariant varResult;
    HRESULT  hr = pAdsObj->Get(bsProp, &varResult);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_TRACE, TEXT("MQADpSetMachineService:pIADs->Get()=%lx"), hr));
        return LogHR(hr, s_FN, 1762);
    }

    //
    // translate to propvariant
    //
    CMQVariant propvarResult;
    hr = Variant2MqVal(propvarResult.CastToStruct(), &varResult, MQ_QM_ID_ADSTYPE, VT_CLSID);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("MQADpSetMachineService:Variant2MqVal()=%lx"), hr));
        return LogHR(hr, s_FN, 1673);
    }

    //
    //  Locate all msmq-settings of the QM and change the service level
    //

    //
    //  Find the distinguished name of the msmq-setting
    //
    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;
    propRestriction.prop = PROPID_SET_QM_ID;
    propRestriction.prval.vt = VT_CLSID;
    propRestriction.prval.puuid = propvarResult.GetCLSID();

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;

    PROPID prop = PROPID_SET_FULL_PATH;

    CAdQueryHandle hQuery;
    R<CSettingObject> pObject = new CSettingObject(NULL, NULL, pwcsDomainController, fServerName);
    AP<WCHAR> pwcsSearchFilter; //BUGBUG to do!!

    hr = g_AD.LocateBegin(
            searchSubTree,
            adpDomainController,	
            e_SitesContainer,
            pObject.get(),
            NULL,       // pguidSearchBase 
            pwcsSearchFilter,
            NULL,
            1,
            &prop,
            hQuery.GetPtr());


    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADpSetMachineService : Locate begin failed %lx"),hr));
        return LogHR(hr, s_FN, 1764);
    }
    //
    //  Read the results
    //
    DWORD cp = 1;
    MQPROPVARIANT var;

    var.vt = VT_NULL;

    while (SUCCEEDED(hr = g_AD.LocateNext(
                hQuery.GetHandle(),
                &cp,
                &var
                )))
    {
        if ( cp == 0)
        {
            //
            //  Not found -> nothing to change.
            //
            break;
        }
        AP<WCHAR> pClean = var.pwszVal;
        //
        //  change the msmq-setting object
        //

        // [adsrv] TBD: here we will have to translate PROPID_QM_OLDSERVICE into set of 3 bits
        PROPID aFlagPropIds[] = {PROPID_SET_SERVICE_DSSERVER,
                                 PROPID_SET_SERVICE_ROUTING,
                                 PROPID_SET_SERVICE_DEPCLIENTS,
								 PROPID_SET_OLDSERVICE};

        MQPROPVARIANT varfFlags[4];
        for (DWORD j=0; j<3; j++)
        {
            varfFlags[j].vt   = VT_UI1;
            varfFlags[j].bVal = FALSE;
        }
        varfFlags[3].vt   = VT_UI4;
        varfFlags[3].ulVal = pPropVar->ulVal;


        switch(pPropVar->ulVal)
        {
        case SERVICE_SRV:
            varfFlags[1].bVal = TRUE;   // router
            varfFlags[2].bVal = TRUE;   // dep.clients server
            break;

        case SERVICE_BSC:
        case SERVICE_PSC:
        case SERVICE_PEC:
            varfFlags[0].bVal = TRUE;   // DS server
            varfFlags[1].bVal = TRUE;   // router
            varfFlags[2].bVal = TRUE;   // dep.clients server
            break;

        case SERVICE_RCS:
            return S_OK;                // nothing to set - we ignored downgrading
            break;

        default:
            ASSERT(0);
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1766);
        }
        CSettingObject object(NULL, NULL, pwcsDomainController, fServerName);
		object.SetObjectDN( var.pwszVal);

        hr = g_AD.SetObjectProperties (
                        adpDomainController,
                        &object,
                        4,
                        aFlagPropIds,
                        varfFlags,
                        NULL,	// pObjInfoRequest
                        NULL    // pParentInfoRequest
                        );

    }
    return LogHR(hr, s_FN, 1767);
}



/*====================================================

MQADpQM1SetMachineSite

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpQM1SetMachineSite(
                 IN ULONG             /*cProps */,
                 IN const PROPID      * /*rgPropIDs*/,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar)
{
    const PROPVARIANT *pPropVar = &rgPropVars[idxProp];

    if ((pPropVar->vt != (VT_CLSID|VT_VECTOR)) ||
        (pPropVar->cauuid.cElems == 0) ||
        (pPropVar->cauuid.pElems == NULL))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1768);
    }

    //
    // return the first site-id from the list
    //
    pNewPropVar->puuid = new CLSID;
    pNewPropVar->vt = VT_CLSID;
    *pNewPropVar->puuid = pPropVar->cauuid.pElems[0];
    return MQ_OK;
}




HRESULT WINAPI MQADpRetrieveMachineEncryptPk(
                 IN  CObjXlateInfo * pTrans,
                 IN  LPCWSTR         pwcsDomainController,
		         IN bool			 fServerName,
                 OUT PROPVARIANT * ppropvariant
				 )
{
    //
    //  This routine supports retreival of PROPID_QM_ENCRYPT_PK.
    //
    //  Read PROPID_QM_ENCTYPT_PKS from DS, unpack and return only
    //  the base encryption key.
    //

    CMQVariant varPks;
    HRESULT hr; 

    //
    // get derived translation context
    //
    CQmXlateInfo * pQMTrans = (CQmXlateInfo *) pTrans;

    hr = pQMTrans->GetDsProp(
						MQ_QM_ENCRYPT_PK_ATTRIBUTE,
						pwcsDomainController,
						fServerName,
						MQ_QM_ENCRYPT_PK_ADSTYPE,
						VT_BLOB,
						FALSE,   // not multi value
						varPks.CastToStruct()
						);
   if (hr == E_ADS_PROPERTY_NOT_FOUND)
   {
       ppropvariant->vt = VT_BLOB;
       ppropvariant->blob.cbSize = 0;
       ppropvariant->blob.pBlobData = NULL;
       return MQ_OK;
   }
   if (FAILED(hr))
   {
       return LogHR(hr, s_FN, 1665);
   }

   //
   // unpack and return only the base key
   //
   MQDSPUBLICKEYS * pPublicKeys =
               reinterpret_cast<MQDSPUBLICKEYS *>(varPks.CastToStruct()->blob.pBlobData);
   BYTE   *pKey = NULL ;
   ULONG   ulKeyLen = 0 ;
   hr =  MQSec_UnpackPublicKey( pPublicKeys,
                                x_MQ_Encryption_Provider_40,
                                x_MQ_Encryption_Provider_Type_40,
                                &pKey,
                                &ulKeyLen
                                );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 260);
    }

    ppropvariant->vt = VT_BLOB;
    ppropvariant->blob.cbSize = ulKeyLen;
    ppropvariant->blob.pBlobData = new BYTE[ulKeyLen];
    memcpy(ppropvariant->blob.pBlobData, pKey, ulKeyLen);

    return MQ_OK;

}

/*====================================================

MQADpCreateMachineEncryptPk

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpCreateMachineEncryptPk(
                 IN const PROPVARIANT *pPropVar,
                 IN LPCWSTR            /* pwcsDomainController */,
		         IN bool			   /* fServerName */,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    // 
    // Just set PROPID_QM_ENCRYPT_PKS 
    //
     *pdwNewPropID = PROPID_QM_ENCRYPT_PKS;
     pNewPropVar->vt = VT_BLOB;
     pNewPropVar->blob.cbSize = pPropVar->blob.cbSize;
     pNewPropVar->blob.pBlobData = new BYTE[ pPropVar->blob.cbSize];
     memcpy( pNewPropVar->blob.pBlobData,
             pPropVar->blob.pBlobData,
             pPropVar->blob.cbSize
             );
     return MQ_OK;
}

/*====================================================

MQADpSetMachineEncryptPk

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADpSetMachineEncryptPk(
                 IN IADs *             /* pAdsObj */,
                 IN LPCWSTR            /* pwcsDomainController */,
		         IN bool			   /* fServerName */,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    // 
    // Just set PROPID_QM_ENCRYPT_PKS 
    //
     *pdwNewPropID = PROPID_QM_ENCRYPT_PKS;
     pNewPropVar->vt = VT_BLOB;
     pNewPropVar->blob.cbSize = pPropVar->blob.cbSize;
     pNewPropVar->blob.pBlobData = new BYTE[ pPropVar->blob.cbSize];
     memcpy( pNewPropVar->blob.pBlobData,
             pPropVar->blob.pBlobData,
             pPropVar->blob.cbSize
             );
     return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\ds_stdh.h ===
#include "..\h\ds_stdh.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\utils.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dsutils.cpp

Abstract:

    Implementation of utilities used in MQADS dll.

Author:

    Alexander Dadiomov (AlexDad)

--*/
#include "ds_stdh.h"
#include "utils.h"
#include "adtempl.h"
#include "dsutils.h"
#include "mqsec.h"

#include "utils.tmh"

static WCHAR *s_FN=L"mqad/utils";

const WCHAR x_True[] = L"TRUE";
const DWORD x_TrueLength = (sizeof( x_True) /sizeof(WCHAR)) -1;
const WCHAR x_False[] = L"FALSE";
const DWORD x_FalseLength = (sizeof( x_False) /sizeof(WCHAR)) -1;
const DWORD x_NumberLength = 256;
const WCHAR x_Null[] = L"\\00";
const DWORD x_NullLength = (sizeof( x_Null)/sizeof(WCHAR)) -1;
#define CHECK_ALLOCATION(p, point)              \
    if (p == NULL)                              \
    {                                           \
        ASSERT(0);                              \
        LogIllegalPoint(s_FN, point);           \
        return MQ_ERROR_INSUFFICIENT_RESOURCES; \
    }



BOOL WINAPI DllMain(HMODULE /*hMod*/, DWORD Reason, LPVOID /*pReserved*/)
{
    switch (Reason)
    {
        case DLL_PROCESS_ATTACH:
            WPP_INIT_TRACING(L"Microsoft\\MSMQ");
            break;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            WPP_CLEANUP();
            break;

        case DLL_THREAD_DETACH:
            break;
    }

    return TRUE;
}


//-------------------------------------------
// TimeFromSystemTime:
//
//  This routine convertes SYSTEMTIME structure into time_t
//-------------------------------------------
STATIC inline time_t TimeFromSystemTime(const SYSTEMTIME * pstTime)
{
	tm tmTime;
        //
        // year in struct tm starts from 1900
        //
	tmTime.tm_year  = pstTime->wYear - 1900;
        //
        // month in struct tm is zero based 0-11 (in SYSTEMTIME it is 1-12)
        //
	tmTime.tm_mon   = pstTime->wMonth - 1;
	tmTime.tm_mday  = pstTime->wDay;
	tmTime.tm_hour  = pstTime->wHour; 
	tmTime.tm_min   = pstTime->wMinute;
	tmTime.tm_sec   = pstTime->wSecond; 
        //
        // time is in UTC, no need to adjust daylight savings time
        //
	tmTime.tm_isdst = 0;
        return mktime(&tmTime);
}

//-------------------------------------------
// TimeFromOleDate:
//
//  This routine convertes DATE into time_t
//-------------------------------------------
STATIC BOOL TimeFromOleDate(DATE dtSrc, time_t *ptime)
{
	SYSTEMTIME stTime;
	if (!VariantTimeToSystemTime(dtSrc, &stTime))
	{
		return LogBOOL(FALSE, s_FN, 200);
	}
        *ptime = TimeFromSystemTime(&stTime);
	return TRUE;
}



STATIC void StringVarToSearchFilter(
      IN  MQPROPVARIANT *pPropVar,
      OUT LPWSTR *       ppwszVal
)
/*++

Routine Description:
    Translate a string variant restirction to a LDAP search filter
    according to RFC 2254

Arguments:
    pPropVar    : varaint containing the string
    ppwszVal    : output, the search filter

Return Value:
    none

--*/
{
    return StringToSearchFilter(
                pPropVar->pwszVal,
                ppwszVal);
}

void StringToSearchFilter(
      IN  LPCWSTR        pwcs,
      OUT LPWSTR *       ppwszVal
)
/*++

Routine Description:
    Translate a string variant restirction to a LDAP search filter
    according to RFC 2254

Arguments:
    pPropVar    : varaint containing the string
    ppwszVal    : output, the search filter

Return Value:
    none

--*/
{
    //
    //  NUL string should be replace with \00
    //
    if ( wcslen( pwcs) == 0)
    {
      *ppwszVal = new WCHAR[ x_NullLength + 1];
      wcscpy(*ppwszVal, x_Null);
      return;
    }
    DWORD len = wcslen( pwcs);
    *ppwszVal = new WCHAR[ 3 * len + 1];
    WCHAR * pNextChar = *ppwszVal;
    //
    //  Chars *,(,),\ should be escaped in a special way
    //
    for ( DWORD i = 0; i < len; i++)
    {
        switch( pwcs[i])
        {
        case L'*':
            *pNextChar++ = L'\\';
            *pNextChar++ = L'2';
            *pNextChar++ = L'a';
            break;
        case L'(':
            *pNextChar++ = L'\\';
            *pNextChar++ = L'2';
            *pNextChar++ = L'8';
            break;
        case L')':
            *pNextChar++ = L'\\';
            *pNextChar++ = L'2';
            *pNextChar++ = L'9';
            break;
        case '\\':
            *pNextChar++ = L'\\';
            *pNextChar++ = L'5';
            *pNextChar++ = L'c';
            break;
        default:
            *pNextChar++ = pwcs[i];
            break;
        }
    }

    *pNextChar = L'\0';
    return;
}

//------------------------------------------------------------
//    MqVal2String()
//    Translates MQPropVal into string
//------------------------------------------------------------
HRESULT MqPropVal2String(
      IN  MQPROPVARIANT *pPropVar,
      IN  ADSTYPE        adsType,
      OUT LPWSTR *       ppwszVal)
{
    HRESULT hr;

    switch (pPropVar->vt)
    {
      case(VT_UI1):
          {
              if ( adsType == ADSTYPE_BOOLEAN)
              {
                  if ( pPropVar->bVal)
                  {
                      *ppwszVal = new WCHAR[ x_TrueLength + 1];
                      wcscpy(*ppwszVal,x_True);
                  }
                  else
                  {
                      *ppwszVal = new WCHAR[ x_FalseLength + 1];
                      wcscpy(*ppwszVal,x_False);
                  }
              }
              else
              {
                  *ppwszVal = new WCHAR[ x_NumberLength + 1];
                wsprintf(*ppwszVal, L"%d", pPropVar->bVal);
              }
          }
          break;

      case(VT_I2):
          *ppwszVal = new WCHAR[ x_NumberLength + 1];
          wsprintf(*ppwszVal, L"%d", pPropVar->iVal);
          break;

      case(VT_UI2):
          *ppwszVal = new WCHAR[ x_NumberLength + 1];
          wsprintf(*ppwszVal, L"%d", pPropVar->uiVal);
          break;

      case(VT_BOOL):
          *ppwszVal = new WCHAR[ x_NumberLength + 1];
          wsprintf(*ppwszVal, L"%d", pPropVar->boolVal);
          break;

      case(VT_I4):
		  if ( adsType == ADSTYPE_INTEGER)
		  {
			  *ppwszVal = new WCHAR[ x_NumberLength + 1];
			  wsprintf(*ppwszVal, L"%d", pPropVar->lVal);
		  }
		  else if ( adsType == ADSTYPE_UTC_TIME)
		  {
			  struct tm  * ptmTime;
			  time_t tTime = pPropVar->lVal; //BUGBUG bug year 2038
			  ptmTime = gmtime( &tTime);
			  if ( ptmTime == NULL)
			  {
                  return LogHR(MQ_ERROR_DS_ERROR, s_FN, 920);
			  }
			  *ppwszVal = new WCHAR[ 20];
			  //
			  // the format should be
			  //  990513102200Z i.e 13.5.99 10:22:00
			  //
			  wsprintf(
					*ppwszVal,
					L"%02d%02d%02d%02d%02d%02dZ",
					(ptmTime->tm_year + 1900) % 100,   //year in struct tm starts from 1900
					ptmTime->tm_mon + 1,			   //month in struct tm starts from 0
					ptmTime->tm_mday,
					ptmTime->tm_hour ,			       //hour in struct tm starts from 0
					ptmTime->tm_min ,			       //minute in struct tm starts from 0
					ptmTime->tm_sec                    //second in struct tm starts from 0
					);
		  }
		  else
		  {
			  ASSERT(0);
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 930);
		  }
          break;

      case(VT_UI4):
          *ppwszVal = new WCHAR[ x_NumberLength + 1];
          wsprintf(*ppwszVal, L"%d", pPropVar->ulVal);
          break;

      case(VT_HRESULT):
          *ppwszVal = new WCHAR[ x_NumberLength + 1];
          wsprintf(*ppwszVal, L"%d", pPropVar->scode);
          break;

      case(VT_CLSID):
          {
              ADsFree  pwcsGuid;
              hr = ADsEncodeBinaryData(
                    (unsigned char *)pPropVar->puuid,
                    sizeof(GUID),
                    &pwcsGuid
                    );
              if (FAILED(hr))
              {
                  return LogHR(hr, s_FN, 940);
              }
              *ppwszVal = new WCHAR[ wcslen( pwcsGuid) + 1];
              wcscpy( *ppwszVal, pwcsGuid);
          }
          break;

      case(VT_BLOB):
          {

              ADsFree  pwcsBlob;
              hr = ADsEncodeBinaryData(
                    pPropVar->blob.pBlobData,
                    pPropVar->blob.cbSize,
                    &pwcsBlob
                    );
              if (FAILED(hr))
              {
                  return LogHR(hr, s_FN, 950);
              }
              *ppwszVal = new WCHAR[ wcslen( pwcsBlob) + 1];
              wcscpy( *ppwszVal, pwcsBlob);
          }

          break;

      case(VT_LPWSTR):
          StringVarToSearchFilter(
                    pPropVar,
                    ppwszVal
                    );
          break;

      case(VT_EMPTY):

		  //
		  // NULL string should be replace with \00
		  // This will be used for PROPID_Q_MULTICAST_ADDRESS
		  // that in case of VT_EMPTY you will get NULL string
		  //
		  *ppwszVal = new WCHAR[x_NullLength + 1];
		  wcscpy(*ppwszVal, x_Null);
          break;

      default:
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 960);
    }

    return MQ_OK;
}
//------------------------------------------------------------
// SetWStringIntoAdsiValue: puts wide string into ADSValue according to ADSType
//------------------------------------------------------------
STATIC HRESULT SetWStringIntoAdsiValue(
   ADSTYPE adsType,
   PADSVALUE pADsValue,
   LPWSTR wsz,
   PVOID pvMainAlloc)
{
    ULONG  ul;
    LPWSTR pwszTmp;

    if (adsType == ADSTYPE_DN_STRING ||
        adsType == ADSTYPE_CASE_EXACT_STRING ||
        adsType == ADSTYPE_CASE_IGNORE_STRING ||
        adsType == ADSTYPE_PRINTABLE_STRING ||
        adsType == ADSTYPE_NUMERIC_STRING)
    {
        ul      = (wcslen(wsz) + 1) * sizeof(WCHAR);
        pwszTmp = (LPWSTR)PvAllocMore(ul, pvMainAlloc);
        CHECK_ALLOCATION(pwszTmp, 10);
        CopyMemory(pwszTmp,  wsz,  ul);
    }
    else
    {
          pADsValue->dwType = ADSTYPE_INVALID;
          return LogHR(MQ_ERROR_DS_ERROR, s_FN, 210);
    }

    switch (adsType)
    {
      case  ADSTYPE_DN_STRING :
          pADsValue->DNString = pwszTmp;
          break;
      case ADSTYPE_CASE_EXACT_STRING:
          pADsValue->CaseExactString = pwszTmp;
          break;
      case ADSTYPE_CASE_IGNORE_STRING:
          pADsValue->CaseIgnoreString = pwszTmp;
          break;
      case ADSTYPE_PRINTABLE_STRING:
          pADsValue->PrintableString = pwszTmp;
          break;
      case ADSTYPE_NUMERIC_STRING:
          pADsValue->NumericString = pwszTmp;
          break;
      default:
          ASSERT(0);
          pADsValue->dwType = ADSTYPE_INVALID;
          return LogHR(MQ_ERROR_DS_ERROR, s_FN, 220);
    }

    pADsValue->dwType = adsType;
    return MQ_OK;
}

//------------------------------------------------------------
// SetStringIntoAdsiValue: puts string into ADSValue according to ADSType
//------------------------------------------------------------
STATIC HRESULT SetStringIntoAdsiValue(
    ADSTYPE adsType,
    PADSVALUE pADsValue,
    LPSTR sz,
    PVOID pvMainAlloc)
{
    ULONG  ul;
    LPWSTR pwszTmp;

    if (adsType == ADSTYPE_DN_STRING ||
        adsType == ADSTYPE_CASE_EXACT_STRING ||
        adsType == ADSTYPE_CASE_IGNORE_STRING ||
        adsType == ADSTYPE_PRINTABLE_STRING ||
        adsType == ADSTYPE_NUMERIC_STRING)
    {
        ul = (strlen(sz) + 1) * sizeof(WCHAR);
        pwszTmp = (LPWSTR)PvAllocMore(ul, pvMainAlloc);
        CHECK_ALLOCATION(pwszTmp, 20);
        mbstowcs(pwszTmp, sz, ul/sizeof(WCHAR) );
    }
    else
    {
          pADsValue->dwType = ADSTYPE_INVALID;
          return LogHR(MQ_ERROR_DS_ERROR, s_FN, 230);
    }

    switch (adsType)
    {
      case  ADSTYPE_DN_STRING :
          pADsValue->DNString = pwszTmp;
          break;
      case ADSTYPE_CASE_EXACT_STRING:
          pADsValue->CaseExactString = pwszTmp;
          break;
      case ADSTYPE_CASE_IGNORE_STRING:
          pADsValue->CaseIgnoreString = pwszTmp;
          break;
      case ADSTYPE_PRINTABLE_STRING:
          pADsValue->PrintableString = pwszTmp;
          break;
      case ADSTYPE_NUMERIC_STRING:
          pADsValue->NumericString = pwszTmp;
          break;
      default:
          ASSERT(0);
          pADsValue->dwType = ADSTYPE_INVALID;
          return LogHR(MQ_ERROR_DS_ERROR, s_FN, 240);
    }

    pADsValue->dwType = adsType;
    return MQ_OK;
}



//------------------------------------------------------------
//    MqVal2AdsiVal()
//    Translates MQPropVal into ADSI value
//------------------------------------------------------------
HRESULT MqVal2AdsiVal(
      IN  ADSTYPE        adsType,
      OUT DWORD         *pdwNumValues,
      OUT PADSVALUE     *ppADsValue,
      IN  const MQPROPVARIANT *pPropVar,
      IN  PVOID          pvMainAlloc)
{
    HRESULT hr;
    ULONG   i;
    PADSVALUE pADsValue = NULL;

    // Allocate ADS value  for a single case
    if (!(pPropVar->vt & VT_VECTOR))
    {
          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE), pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 80);
          pADsValue->dwType = adsType;
          *pdwNumValues     = 1;
          *ppADsValue       = pADsValue;
    }

    switch (pPropVar->vt)
    {
      case(VT_UI1):
          if (adsType != ADSTYPE_INTEGER &&
              adsType != ADSTYPE_BOOLEAN )
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 660);
          }
          pADsValue->Integer = pPropVar->bVal;
          break;

      case(VT_I2):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 670);
          }
          pADsValue->Integer = pPropVar->iVal;
          break;

      case(VT_UI2):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 680);
          }
          pADsValue->Integer = pPropVar->uiVal;
          break;

      case(VT_BOOL):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 700);
          }
          pADsValue->Boolean = (pPropVar->boolVal ? TRUE : FALSE);
          //BUGBUG: is it the same representation?
          break;

      case(VT_I4):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 710);
          }
          // BUGBUG Signed long may loose sign while copied to DWORD
          pADsValue->Integer = pPropVar->lVal; // may loose sign here!
          break;

      case(VT_UI4):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 720);
          }
          pADsValue->Integer = pPropVar->ulVal;
          break;

      case(VT_HRESULT):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 730);
          }
          pADsValue->Integer = pPropVar->scode;
          break;

      case(VT_DATE):
          if (adsType != ADSTYPE_UTC_TIME)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 740);
          }
          if (!VariantTimeToSystemTime(pPropVar->date, &pADsValue->UTCTime))
          {
               ASSERT(0);
               pADsValue->dwType = ADSTYPE_INVALID;
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 750);
          }
          break;

      case(VT_CLSID):
          if (adsType != ADSTYPE_OCTET_STRING)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 760);
          }
          pADsValue->OctetString.dwLength = sizeof(GUID);
          pADsValue->OctetString.lpValue  = (LPBYTE)PvAllocMore(sizeof(GUID), pvMainAlloc);
          CHECK_ALLOCATION(pADsValue->OctetString.lpValue, 90);
          CopyMemory(pADsValue->OctetString.lpValue,  pPropVar->puuid,  sizeof(CLSID));
          break;

      case(VT_BLOB):
          if (adsType == ADSTYPE_NT_SECURITY_DESCRIPTOR)
          {
              pADsValue->SecurityDescriptor.dwLength = pPropVar->blob.cbSize;
              pADsValue->SecurityDescriptor.lpValue  = (LPBYTE)PvAllocMore(pPropVar->blob.cbSize, pvMainAlloc);
              CHECK_ALLOCATION(pADsValue->SecurityDescriptor.lpValue, 100);
              CopyMemory(pADsValue->SecurityDescriptor.lpValue,  pPropVar->blob.pBlobData,  pPropVar->blob.cbSize);
          }
          else if (adsType == ADSTYPE_OCTET_STRING)
          {
              pADsValue->OctetString.dwLength = pPropVar->blob.cbSize;
              pADsValue->OctetString.lpValue  = (LPBYTE)PvAllocMore(pPropVar->blob.cbSize, pvMainAlloc);
              CHECK_ALLOCATION(pADsValue->OctetString.lpValue, 110);
              CopyMemory(pADsValue->OctetString.lpValue,  pPropVar->blob.pBlobData,  pPropVar->blob.cbSize);
          }
          else
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 770);
          }
          break;

      case(VT_BSTR):
          hr = SetWStringIntoAdsiValue(adsType, pADsValue, pPropVar->bstrVal, pvMainAlloc);
          if (FAILED(hr))
          {
              ASSERT(0);
              return LogHR(hr, s_FN, 780);
          }
          break;

      case(VT_LPSTR):
          hr = SetStringIntoAdsiValue(adsType, pADsValue, pPropVar->pszVal, pvMainAlloc);
          if (FAILED(hr))
          {
              ASSERT(0);
              return LogHR(hr, s_FN, 790);
          }
          break;

      case(VT_LPWSTR):
          hr = SetWStringIntoAdsiValue(adsType, pADsValue, pPropVar->pwszVal, pvMainAlloc);
          if (FAILED(hr))
          {
              ASSERT(0);
              return LogHR(hr, s_FN, 800);
          }
          break;

      case(VT_VECTOR | VT_UI1):
          switch(adsType)
          {
                  case ADSTYPE_OCTET_STRING:
                      pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE), pvMainAlloc);
                      CHECK_ALLOCATION(pADsValue, 120);
                      pADsValue->dwType = adsType;

                      pADsValue->OctetString.dwLength = pPropVar->caub.cElems;
                      pADsValue->OctetString.lpValue  = (LPBYTE)PvAllocMore(pPropVar->caub.cElems, pvMainAlloc);
                      CHECK_ALLOCATION(pADsValue->OctetString.lpValue, 130);
                      CopyMemory(pADsValue->OctetString.lpValue,  pPropVar->caub.pElems,  pPropVar->caub.cElems);

                      *ppADsValue   = pADsValue;
                      *pdwNumValues = 1;
                      break;

                  case ADSTYPE_INTEGER:
                      pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->caub.cElems, pvMainAlloc);
                      CHECK_ALLOCATION(pADsValue, 140);

                      for (i=0; i<pPropVar->caub.cElems; i++)
                      {
                          pADsValue[i].Integer = pPropVar->caub.pElems[i];
                          pADsValue[i].dwType = adsType;
                      }

                      *ppADsValue   = pADsValue;
                      *pdwNumValues = pPropVar->caub.cElems;
                      break;

                  default:
                      ASSERT(0);
                      return LogHR(MQ_ERROR_DS_ERROR, s_FN, 810);
          }

          break;

      case(VT_VECTOR | VT_I2):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 820);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->cai.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 150)
          pADsValue->dwType = adsType;

          for (i=0; i<pPropVar->cai.cElems; i++)
          {
              pADsValue[i].Integer = pPropVar->cai.pElems[i];
              pADsValue[i].dwType = adsType;
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->cai.cElems;
          break;

      case(VT_VECTOR | VT_UI2):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 830);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->caui.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 160)

          for (i=0; i<pPropVar->caui.cElems; i++)
          {
              pADsValue[i].Integer = pPropVar->caui.pElems[i];
              pADsValue[i].dwType = adsType;
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->caui.cElems;
          break;

      case(VT_VECTOR | VT_I4):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 840);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->cal.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 170);

          for (i=0; i<pPropVar->cal.cElems; i++)
          {
              // BUGBUG:  may loose sign
              pADsValue[i].Integer = pPropVar->cal.pElems[i];
              pADsValue[i].dwType = adsType;
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->cal.cElems;
          break;

      case(VT_VECTOR | VT_UI4):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 850);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->caul.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 180);

          for (i=0; i<pPropVar->caul.cElems; i++)
          {
              pADsValue[i].Integer = pPropVar->caul.pElems[i];
              pADsValue[i].dwType = adsType;
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->caul.cElems;
          break;

      case(VT_VECTOR | VT_CLSID):
          if (adsType != ADSTYPE_OCTET_STRING)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 860);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->cauuid.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 190);
          pADsValue->dwType = adsType;

          for (i=0; i<pPropVar->cauuid.cElems; i++)
          {
              pADsValue[i].OctetString.dwLength = sizeof(GUID);
              pADsValue[i].dwType = adsType;
              pADsValue[i].OctetString.lpValue  = (LPBYTE)PvAllocMore(sizeof(GUID), pvMainAlloc);
              CHECK_ALLOCATION(pADsValue[i].OctetString.lpValue, 200);
              CopyMemory(pADsValue[i].OctetString.lpValue,  &pPropVar->cauuid.pElems[i],  sizeof(GUID));
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->cauuid.cElems;
          break;

      case(VT_VECTOR | VT_BSTR):
          if (adsType != ADSTYPE_OCTET_STRING)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 870);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->cabstr.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 210);


          for (i=0; i<pPropVar->cabstr.cElems; i++)
          {
              hr = SetWStringIntoAdsiValue(adsType, pADsValue+i, pPropVar->cabstr.pElems[i], pvMainAlloc);
              if (FAILED(hr))
              {
                  ASSERT(0);
                  return LogHR(MQ_ERROR_DS_ERROR, s_FN, 880);
              }
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->cabstr.cElems;
          break;

      case(VT_VECTOR | VT_LPWSTR):
          if (adsType != ADSTYPE_DN_STRING)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 890);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->calpwstr.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 220);

          for (i=0; i<pPropVar->calpwstr.cElems; i++)
          {
              hr = SetWStringIntoAdsiValue(adsType, pADsValue+i, pPropVar->calpwstr.pElems[i], pvMainAlloc);
              if (FAILED(hr))
              {
                  ASSERT(0);
                  return LogHR(hr, s_FN, 900);
              }
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->calpwstr.cElems;
          break;

    case(VT_VARIANT):
    case(VT_EMPTY):
    case VT_NULL:
    default:
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 910);
    }

    return MQ_OK;
}
STATIC LPWSTR GetWStringFromAdsiValue(
      IN  ADSTYPE       AdsType,
      IN  PADSVALUE     pADsValue)
{
    switch(AdsType)
    {
    case ADSTYPE_DN_STRING:
        return pADsValue->DNString;

    case ADSTYPE_CASE_EXACT_STRING:
        return pADsValue->CaseExactString;

    case ADSTYPE_CASE_IGNORE_STRING:
        return pADsValue->CaseIgnoreString;

    case ADSTYPE_PRINTABLE_STRING:
        return pADsValue->PrintableString;

    case ADSTYPE_NUMERIC_STRING:
        return pADsValue->NumericString;

    case ADSTYPE_OBJECT_CLASS:
        return pADsValue->ClassName;

    default:
        ASSERT(0);
        return NULL;
    }
}

STATIC HRESULT AdsiStringVal2MqVal(
      OUT MQPROPVARIANT *pPropVar,
      IN  VARTYPE       vtTarget,
      IN  ADSTYPE       AdsType,
      IN  DWORD         dwNumValues,
      IN  PADSVALUE     pADsValue)
{
    LPWSTR pwsz;

    if (vtTarget == VT_LPWSTR)
    {
        if (dwNumValues == 1)
        {
            pwsz = GetWStringFromAdsiValue(AdsType, pADsValue);
            if (pwsz == NULL)
            {
                ASSERT(0);
                return LogHR(MQ_ERROR_DS_ERROR, s_FN, 970);
            }

            pPropVar->vt      = VT_LPWSTR;
            pPropVar->pwszVal = new WCHAR[wcslen(pwsz) + 1];
            wcscpy(pPropVar->pwszVal, pwsz);
			return(MQ_OK);
        }
		else
		{
			ASSERT(0);
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 980);
		}
	}
    else if (vtTarget == (VT_LPWSTR | VT_VECTOR))
    {
        pPropVar->vt    = VT_LPWSTR | VT_VECTOR;
        AP<LPWSTR> pElems = new LPWSTR[dwNumValues];
        CWcsArray pClean( dwNumValues,  pElems);
        for(DWORD i = 0; i < dwNumValues; i++)
        {
            pwsz = GetWStringFromAdsiValue(AdsType, &pADsValue[i]);
            if (pwsz == NULL)
            {
                ASSERT(0);
                return LogHR(MQ_ERROR_DS_ERROR, s_FN, 990);
            }

            pElems[i] = new WCHAR[wcslen(pwsz) + 1];
            wcscpy(pElems[i], pwsz);
        }

        (pPropVar->calpwstr).cElems = dwNumValues;
        pClean.detach();
        (pPropVar->calpwstr).pElems = pElems.detach();
        return MQ_OK;
    }
    else
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1000);
    }
}
STATIC HRESULT SetIntegerIntoMqPropVar(
    IN  VARTYPE       vtTarget,
    OUT MQPROPVARIANT *pPropVar,
    IN  ULONG         *pIntegers,
    IN  ULONG          cIntegers)
{
    DBG_USED(cIntegers);
	pPropVar->vt = vtTarget;

    switch(vtTarget)
    {
    case(VT_UI1):
        ASSERT(cIntegers == 1);
        pPropVar->bVal = *(unsigned char *)pIntegers;   // UCHAR
        break;

    case(VT_I2):
        ASSERT(cIntegers == 1);
        pPropVar->iVal = *(short *)pIntegers;   // short
        break;

    case(VT_UI2):
        ASSERT(cIntegers == 1);
        pPropVar->uiVal = *(unsigned short *)pIntegers;   // USHORT
        break;

    case(VT_I4):
        ASSERT(cIntegers == 1);
        pPropVar->lVal = *pIntegers;   // long
        break;

    case(VT_UI4):
        ASSERT(cIntegers == 1);
        pPropVar->ulVal = *pIntegers;   // ULONG
        break;

    case(VT_HRESULT):
        ASSERT(cIntegers == 1);
        pPropVar->scode = *pIntegers;   // SCODE
        break;



    default:
        ASSERT(0);
        pPropVar->vt = VT_EMPTY;
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1010);
    }

    return MQ_OK;
}



STATIC HRESULT AdsiIntegerVal2MqVal(
      OUT MQPROPVARIANT *pPropVar,
      IN  VARTYPE       vtTarget,
      IN  DWORD         dwNumValues,
      IN  PADSVALUE     pADsValue)
{
    if (dwNumValues == 1)
    {
        ULONG intval = pADsValue->Integer;
        if (FAILED(SetIntegerIntoMqPropVar(
                      vtTarget,
                      pPropVar,
                      &intval,
                      1)))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1020);
        }
    }
    else
    {
        AP<ULONG> pArr = new ULONG[dwNumValues];
        for (DWORD i=0; i<dwNumValues; i++)
        {
            pArr[i] = pADsValue[i].Integer;
        }

        if (FAILED(SetIntegerIntoMqPropVar(
                      vtTarget,
                      pPropVar,
                      pArr,
                      dwNumValues)))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1030);
        }

    }
    return MQ_OK;
}

//------------------------------------------------------------
//    AdsiVal2MqVal()
//    Translates ADSI value into MQ PropVal
//------------------------------------------------------------
HRESULT AdsiVal2MqVal(
      OUT MQPROPVARIANT *pPropVar,
      IN  VARTYPE       vtTarget,
      IN  ADSTYPE       AdsType,
      IN  DWORD         dwNumValues,
      IN  ADSVALUE *    pADsValue)
{
    HRESULT hr2;

    switch (AdsType)
    {
    case ADSTYPE_DN_STRING:
    case ADSTYPE_CASE_EXACT_STRING:
    case ADSTYPE_CASE_IGNORE_STRING:
    case ADSTYPE_PRINTABLE_STRING:
    case ADSTYPE_NUMERIC_STRING:
    case ADSTYPE_OBJECT_CLASS:

        hr2 = AdsiStringVal2MqVal(
                  pPropVar,
                  vtTarget,
                  AdsType,
                  dwNumValues,
                  pADsValue);
        return LogHR(hr2, s_FN, 1040);

    case ADSTYPE_INTEGER:

        hr2 = AdsiIntegerVal2MqVal(
                    pPropVar,
                    vtTarget,
                    dwNumValues,
                    pADsValue);
        return LogHR(hr2, s_FN, 1050);

    case ADSTYPE_BOOLEAN:
        if (dwNumValues == 1)
        {
            if (vtTarget == VT_BOOL)
            {
                pPropVar->vt      = VT_BOOL;
#pragma warning(disable: 4310)
                pPropVar->boolVal = (pADsValue->Boolean ? VARIANT_TRUE : VARIANT_FALSE);  //BUGBUG: are values the same?
#pragma warning(default: 4310)
            }
            else if (vtTarget == VT_UI1)
            {
                pPropVar->vt      = VT_UI1;
                pPropVar->bVal = (pADsValue->Boolean ? (unsigned char)1 : (unsigned char)0);  //BUGBUG: are values the same?
            }
            else
            {
                ASSERT(0);
                return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1060);
            }
        }
        else
        {
            ASSERT(0);  // There is no VT_BOOL | VT_VECTOR case on MQPROPVARIANT
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1070);
        }
        break;

    case ADSTYPE_OCTET_STRING:

        if (vtTarget == VT_BLOB)
        {
            if (dwNumValues != 1)
            {
                ASSERT(0);  // NIY
                return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1080);
            }
            pPropVar->vt             = VT_BLOB;
            pPropVar->blob.cbSize    = pADsValue->OctetString.dwLength;
            pPropVar->blob.pBlobData = new BYTE[pADsValue->OctetString.dwLength];

            CopyMemory(pPropVar->blob.pBlobData,
                       pADsValue->OctetString.lpValue,
                       pADsValue->OctetString.dwLength);
        }
        else if (vtTarget == VT_CLSID)
        {
            if (dwNumValues != 1)
            {
                ASSERT(0);  // NIY
                return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1090);
            }
            ASSERT(pADsValue->OctetString.dwLength == 16);

            //
            //  This is a special case where we do not necessarily allocate the memory for the guid
            //  in puuid. The caller may already have puuid set to a guid, and this is indicated by the
            //  vt member on the given propvar. It could be VT_CLSID if guid already allocated, otherwise
            //  we allocate it (and vt should be VT_NULL (or VT_EMPTY))
            //
            if (pPropVar->vt != VT_CLSID)
            {
                ASSERT(((pPropVar->vt == VT_NULL) || (pPropVar->vt == VT_EMPTY)));
                pPropVar->vt    = VT_CLSID;
                pPropVar->puuid = new GUID;
            }   
            else if ( pPropVar->puuid == NULL)
            {
                return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 1100);
            }

            CopyMemory(pPropVar->puuid,
                       pADsValue->OctetString.lpValue,
                       pADsValue->OctetString.dwLength);
        }
        else if (vtTarget == (VT_CLSID|VT_VECTOR))
        {
            ASSERT( pADsValue->OctetString.dwLength == sizeof(GUID));
            DWORD num = dwNumValues;
            pPropVar->cauuid.pElems = new GUID[ num];
            pPropVar->cauuid.cElems = num;
            pPropVar->vt = VT_CLSID|VT_VECTOR;


            for (DWORD i = 0 ; i < num; i++, pADsValue++)
            {
                CopyMemory(&pPropVar->cauuid.pElems[i],
                           pADsValue->OctetString.lpValue,
                           sizeof(GUID));
            }

        }
        else
        {
            ASSERT(0);
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1110);
        }
        break;

    case ADSTYPE_UTC_TIME:
        if (dwNumValues != 1)
        {
            ASSERT(0);    // NIY
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1120);
        }

        if (vtTarget == VT_DATE)
        {
            pPropVar->vt      = VT_DATE;
            if (!SystemTimeToVariantTime(&pADsValue->UTCTime, &pPropVar->date))
            {
                ASSERT(0);
                return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1130);
            }
        }
        else if (vtTarget == VT_I4)
        {
            //
            //   convert SYSTEMTIME->time_t
            //
            pPropVar->vt = VT_I4;
            pPropVar->lVal = INT_PTR_TO_INT(TimeFromSystemTime(&pADsValue->UTCTime)); //BUGBUG bug year 2038

        }
        else
        {
            ASSERT(0);
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1140);
        }
        break;

    case ADSTYPE_LARGE_INTEGER:
        // No such thing in MQ!
        ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1150);

	case ADSTYPE_NT_SECURITY_DESCRIPTOR:
        if (dwNumValues != 1)
        {
            ASSERT(0);    // NIY
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1160);
        }

        if (vtTarget == VT_BLOB)
        {
#ifdef _DEBUG
            SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR*)
                                    pADsValue->SecurityDescriptor.lpValue ;
            DWORD dwSDLen = GetSecurityDescriptorLength(pSD) ;

            ASSERT(IsValidSecurityDescriptor(pSD)) ;
            ASSERT(dwSDLen == pADsValue->SecurityDescriptor.dwLength) ;
#endif

            pPropVar->vt             = VT_BLOB;
            pPropVar->blob.cbSize    = pADsValue->SecurityDescriptor.dwLength;
            pPropVar->blob.pBlobData = new BYTE[pADsValue->SecurityDescriptor.dwLength];

            CopyMemory(pPropVar->blob.pBlobData,
                       pADsValue->SecurityDescriptor.lpValue,
                       pADsValue->SecurityDescriptor.dwLength);
        }
        break;

    default:
		ASSERT(0);
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1180);

    }
    return MQ_OK;
}

HRESULT ArrayOfLpwstr2MqVal(
      IN  VARIANT  *        pOleVar,
      IN  const ADSTYPE     adstype,
      IN  const VARTYPE     /* vartype*/,
      IN  const VARTYPE     vartypeElement,
      OUT MQPROPVARIANT *   pMqVar
      )
{
       //
       // get number of elements
       //
       LONG lLbound, lUbound;
       if (FAILED(SafeArrayGetLBound(pOleVar->parray, 1, &lLbound)) ||
           FAILED(SafeArrayGetUBound(pOleVar->parray, 1, &lUbound)))
       {
           ASSERT(0);
           return LogHR(MQ_ERROR_DS_ERROR, s_FN, 420);
       }
       ULONG cElems;
       cElems = lUbound - lLbound + 1;

       //
       // Allocate array of results
       //
       AP<LPWSTR> pElems = new LPWSTR[cElems];

       //
       // Translate each element
       //
       LONG lIdx;
       ULONG ulTmp;
       for (ulTmp = 0, lIdx = lLbound; ulTmp < cElems; ulTmp++, lIdx++)
       {
           //
           // get variant to translate
           //
           CAutoVariant varTmp;
           HRESULT hr = SafeArrayGetElement(pOleVar->parray, &lIdx, &varTmp);
           if (FAILED(hr))
           {
               ASSERT(0);
               return LogHR(hr, s_FN, 430);
           }

           //
           // translate the variant (RECURSION)
           //
           PROPVARIANT var;
           hr = Variant2MqVal(&var, &varTmp, adstype, vartypeElement);
           if (FAILED(hr))
           {
               ASSERT(0);
               return LogHR(hr, s_FN, 440);
           }
			
		   ASSERT(var.pwszVal != NULL);
           //
           // Fill element in array of results
           //
           pElems[ulTmp] = var.pwszVal;
       }

       //
       // set return variant
       //
       pMqVar->vt = VT_VECTOR|VT_LPWSTR;
       pMqVar->calpwstr.cElems = cElems;
       pMqVar->calpwstr.pElems = pElems.detach();
       return(MQ_OK);
}



HRESULT ArrayOfClsid2MqVal(
      IN  VARIANT  *        pOleVar,
      IN  const ADSTYPE     adstype,
      IN  const VARTYPE     /* vartype*/,
      IN  const VARTYPE     vartypeElement,
      OUT MQPROPVARIANT *   pMqVar
      )
{
       //
       // get number of elements
       //
       LONG lLbound, lUbound;
       if (FAILED(SafeArrayGetLBound(pOleVar->parray, 1, &lLbound)) ||
           FAILED(SafeArrayGetUBound(pOleVar->parray, 1, &lUbound)))
       {
           ASSERT(0);
           return LogHR(MQ_ERROR_DS_ERROR, s_FN, 450);
       }
       ULONG cElems;
       cElems = lUbound - lLbound + 1;

       //
       // Allocate array of results
       //
       AP<GUID> pElems = new GUID[cElems];

       //
       // Translate each element
       //
       LONG lIdx;
       ULONG ulTmp;
       for (ulTmp = 0, lIdx = lLbound; ulTmp < cElems; ulTmp++, lIdx++)
       {
           //
           // get variant to translate
           //
           CAutoVariant varTmp;
           HRESULT hr = SafeArrayGetElement(pOleVar->parray, &lIdx, &varTmp);
           if (FAILED(hr))
           {
               ASSERT(0);
               LogHR(hr, s_FN, 460);
               return MQ_ERROR_DS_ERROR;
           }

           //
           // translate the variant (RECURSION)
           //
           CMQVariant MQVarTmp;
           hr = Variant2MqVal(MQVarTmp.CastToStruct(), &varTmp, adstype, vartypeElement);
           if (FAILED(hr))
           {
               ASSERT(0);
               LogHR(hr, s_FN, 470);
               return MQ_ERROR_DS_ERROR;
           }

           //
           // Fill element in array of results
           //
           pElems[ulTmp] = *(MQVarTmp.GetCLSID());
       }

       //
       // set return variant
       //
       pMqVar->vt = VT_VECTOR|VT_CLSID;
       pMqVar->cauuid.cElems = cElems;
       pMqVar->cauuid.pElems = pElems.detach();
       return(MQ_OK);
}



//------------------------------------------------------------
//    Variant2MqVal()
//    Translates OLE Variant into MQPropVal value
//------------------------------------------------------------
HRESULT Variant2MqVal(
      OUT  MQPROPVARIANT * pMqVar,
      IN   VARIANT  *      pOleVar,
      IN const ADSTYPE     adstype,
      IN const VARTYPE     vartype)
{

    switch (pOleVar->vt)
    {
       case(VT_UI1):
           if (adstype == ADSTYPE_BOOLEAN)
           {
                pMqVar->vt = VT_UI1;
                pMqVar->bVal = (pOleVar->boolVal ? (unsigned char)1 : (unsigned char)0);
           }
           else if (adstype ==  ADSTYPE_INTEGER)
           {
                pMqVar->vt = VT_I4;
                pMqVar->lVal = pOleVar->bVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 480);
           }
           break;

       case(VT_I2):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pMqVar->vt = VT_I4;
               pMqVar->lVal = pOleVar->iVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 490);
           }
           break;

       case(VT_I4):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               if ( vartype == VT_I2)
               {
                   pMqVar->vt = VT_I2;
                   pMqVar->iVal = pOleVar->iVal;
               }
               else if ( vartype == VT_UI2)
               {
                   pMqVar->vt = VT_UI2;
                   pMqVar->iVal = pOleVar->uiVal;
               }
               else
               {
                   ASSERT(( vartype == VT_I4) || (vartype == VT_UI4));
                   pMqVar->vt = vartype;
                   pMqVar->lVal = pOleVar->lVal;
               }
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 500);
           }
           break;

       case(VT_UI2):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pMqVar->vt = VT_I4;
               pMqVar->lVal = pOleVar->uiVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 510);
           }
           break;

       case(VT_BOOL):
           if (adstype == ADSTYPE_BOOLEAN)
           {
                pMqVar->vt = VT_UI1;
                pMqVar->bVal = (pOleVar->boolVal ? (unsigned char)1 : (unsigned char)0);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 520);
           }
           break;

       case(VT_UI4):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pMqVar->vt = VT_I4;
               CopyMemory(&pMqVar->lVal, &pOleVar->ulVal, sizeof(ULONG));
           }
           else if (adstype ==  ADSTYPE_UTC_TIME)
           {
               //pMqVar->vt = VT_DATE;
               //CopyMemory(&pMqVar->date, &pOleVar->ulVal, sizeof(ULONG));
               //
               // BUGBUG - The code above is wrong, We can't assign ULONG into OLE Date.
               // Currently we never get to here because all of our time props ar read-only,
               // but this needs to be changed when we add a writable time property
               // to the the DS. (RaananH)
               // 
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 530);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 540);
           }
           break;

       case(VT_DATE):
           if (adstype ==  ADSTYPE_UTC_TIME)
           {
               //
               //   convert date->time_t
               //
               time_t tTime;
               if (!TimeFromOleDate(pOleVar->date, &tTime))
               {
                   return LogHR(MQ_ERROR_DS_ERROR, s_FN, 550);
               }
               pMqVar->lVal = INT_PTR_TO_INT(tTime); //BUGBUG bug year 2038
               pMqVar->vt = VT_I4;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 560);
           }
           break;

       case(VT_BSTR):
           if (adstype ==  ADSTYPE_DN_STRING          ||
               adstype == ADSTYPE_CASE_EXACT_STRING   ||
               adstype ==  ADSTYPE_CASE_IGNORE_STRING ||
               adstype == ADSTYPE_PRINTABLE_STRING    ||
               adstype ==  ADSTYPE_NUMERIC_STRING     ||
               adstype == ADSTYPE_CASE_EXACT_STRING)
           {
               pMqVar->vt = VT_LPWSTR;
               pMqVar->pwszVal = new WCHAR[ 1 + wcslen(pOleVar->bstrVal)];
               wcscpy( pMqVar->pwszVal, pOleVar->bstrVal);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 570);
           }
           break;

       case(VT_ARRAY):
           if (adstype ==  ADSTYPE_OCTET_STRING)
           {
               ASSERT(0);
               //pMqVar->vt = VT_BSTR;
               //pMqVar->bstrVal = SysAllocStringByteLen(NULL, pOleVar->parray->...);
               //CopyMemory(pMqVar->bstrVal, pOleVar->parray...ptr.., pOleVar->parray...size);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 580);
           }
           break;

       case(VT_ARRAY|VT_UI1):
           if (adstype == ADSTYPE_OCTET_STRING)
           {
                ASSERT(SafeArrayGetDim( pOleVar->parray) == 1);
                LONG    lUbound;
                LONG    lLbound;

                SafeArrayGetUBound(pOleVar->parray, 1, &lUbound);
                SafeArrayGetLBound(pOleVar->parray, 1, &lLbound);

                LONG len = lUbound - lLbound + 1;
                unsigned char * puc = NULL;
                if ( vartype == VT_CLSID)
                {
                    ASSERT( len == sizeof(GUID));
                    //
                    //  This is a special case where we do not necessarily allocate the memory for the guid
                    //  in puuid. The caller may already have puuid set to a guid, and this is indicated by the
                    //  vt member on the given propvar. It could be VT_CLSID if guid already allocated, otherwise
                    //  we allocate it (and vt should be VT_NULL (or VT_EMPTY))
                    //
                    if (pMqVar->vt != VT_CLSID)
                    {
                        ASSERT(((pMqVar->vt == VT_NULL) || (pMqVar->vt == VT_EMPTY)));
                        pMqVar->puuid = new GUID;
                        pMqVar->vt = VT_CLSID;
                    }
                    else if ( pMqVar->puuid == NULL)
                    {
                        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 590);
                    }
                    puc = ( unsigned char *)pMqVar->puuid;
                }
                else if (vartype == VT_BLOB)
                {
                    pMqVar->caub.cElems = len;
                    pMqVar->caub.pElems = new unsigned char[ len];
                    puc = pMqVar->caub.pElems;
                    pMqVar->vt = VT_BLOB;
                }
                ASSERT( puc != NULL);
                for ( long i = 0; i < len; i++)
                {
                    SafeArrayGetElement(pOleVar->parray, &i, puc + i);

                }

           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 600);
           }
           break;
       case(VT_ARRAY|VT_VARIANT):
           {
               //
               // this is a multi-valued property, each variant is one of the values.
               // target must be a vector.
               //
               if (!(vartype & VT_VECTOR))
               {
                   ASSERT(0);
                   return LogHR(MQ_ERROR_DS_ERROR, s_FN, 610);
               }

               //
               // get target type of each element
               //
               VARTYPE vartypeElement;
               vartypeElement = vartype;
               vartypeElement &= (~VT_VECTOR);

               if (( vartypeElement == VT_CLSID) &&
                   (adstype == ADSTYPE_OCTET_STRING))
               {
                    HRESULT hr2 = ArrayOfClsid2MqVal(
                                            pOleVar,
                                            adstype,
                                            vartype,
                                            vartypeElement,
                                            pMqVar);
                   return LogHR(hr2, s_FN, 620);
              }

              if (( vartypeElement == VT_LPWSTR) &&
                   (adstype == ADSTYPE_DN_STRING))
              {
                    HRESULT hr2 = ArrayOfLpwstr2MqVal(
                                            pOleVar,
                                            adstype,
                                            vartype,
                                            vartypeElement,
                                            pMqVar);
                   return LogHR(hr2, s_FN, 630);
              }

              //
              // currently we support only VT_CLSID  and VT_LPWSTR
              // here we may need to check for other types when we support them
              //
              ASSERT(0);
              return LogHR(MQ_ERROR_DS_ERROR, s_FN, 640);
              break;
           }

       default:
           // NIY
           ASSERT(0);
           return LogHR(MQ_ERROR_DS_ERROR, s_FN, 650);
    }
    return MQ_OK;
}


//------------------------------------------------------------
//    MqVal2Variant()
//    Translates MQPropVal into OLE Variant value
//------------------------------------------------------------
HRESULT MqVal2Variant(
      OUT VARIANT       *pOleVar,
      IN  const MQPROPVARIANT *pMqVar,
      ADSTYPE           adstype)
{
    LPWSTR wsz;
    ULONG  ul;
    HRESULT hr;

    switch (pMqVar->vt)
    {
       case(VT_UI1):
           if (adstype == ADSTYPE_BOOLEAN)
           {
                pOleVar->vt = VT_BOOL;
#pragma warning(disable: 4310)
                pOleVar->boolVal = (pMqVar->bVal ? VARIANT_TRUE : VARIANT_FALSE);
#pragma warning(default: 4310)
           }
           else if (adstype ==  ADSTYPE_INTEGER)
           {
                pOleVar->vt = VT_I4;
                pOleVar->lVal = pMqVar->bVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 250);
           }
           break;

       case(VT_I2):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pOleVar->vt = VT_I4;
               pOleVar->lVal = pMqVar->iVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 260);
           }
           break;

       case(VT_UI2):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pOleVar->vt = VT_I4;
               pOleVar->lVal = pMqVar->uiVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 270);
           }
           break;

       case(VT_BOOL):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pOleVar->vt = VT_BOOL;
               pOleVar->boolVal = pMqVar->boolVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 280);
           }
           break;

       case(VT_I4):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pOleVar->vt = VT_I4;
               pOleVar->lVal = pMqVar->lVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 290);
           }
           break;

       case(VT_UI4):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pOleVar->vt = VT_I4;
               CopyMemory(&pOleVar->lVal, &pMqVar->ulVal, sizeof(ULONG));
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 310);
           }
           break;

       case(VT_DATE):
           if (adstype ==  ADSTYPE_UTC_TIME)
           {
               pOleVar->vt = VT_DATE;
               pOleVar->date = pMqVar->date;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 320);
           }
           break;

       case(VT_BSTR):
           if (adstype ==  ADSTYPE_DN_STRING          ||
               adstype == ADSTYPE_CASE_EXACT_STRING   ||
               adstype ==  ADSTYPE_CASE_IGNORE_STRING ||
               adstype == ADSTYPE_PRINTABLE_STRING    ||
               adstype ==  ADSTYPE_NUMERIC_STRING     ||
               adstype == ADSTYPE_CASE_EXACT_STRING)
           {
               pOleVar->vt = VT_BSTR;
               pOleVar->bstrVal = SysAllocString(pMqVar->bstrVal);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 330);
           }
           break;

       case(VT_LPSTR):
           if (adstype ==  ADSTYPE_DN_STRING          ||
               adstype == ADSTYPE_CASE_EXACT_STRING   ||
               adstype ==  ADSTYPE_CASE_IGNORE_STRING ||
               adstype == ADSTYPE_PRINTABLE_STRING    ||
               adstype ==  ADSTYPE_NUMERIC_STRING     ||
               adstype == ADSTYPE_CASE_EXACT_STRING)
           {
               pOleVar->vt = VT_BSTR;
               ul = strlen(pMqVar->pszVal) + 1;
               wsz = new WCHAR[ul * sizeof(WCHAR)];
               mbstowcs( wsz, pMqVar->pszVal, ul );
               pOleVar->bstrVal = SysAllocString(wsz);
               delete [] wsz;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 340);
           }
           break;

       case(VT_LPWSTR):
           if (adstype ==  ADSTYPE_DN_STRING          ||
               adstype == ADSTYPE_CASE_EXACT_STRING   ||
               adstype ==  ADSTYPE_CASE_IGNORE_STRING ||
               adstype == ADSTYPE_PRINTABLE_STRING    ||
               adstype ==  ADSTYPE_NUMERIC_STRING     ||
               adstype == ADSTYPE_CASE_EXACT_STRING)
           {
               pOleVar->vt = VT_BSTR;
               pOleVar->bstrVal = SysAllocString(pMqVar->pwszVal);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 350);
           }
           break;

       case(VT_LPWSTR|VT_VECTOR):
           if (adstype ==  ADSTYPE_DN_STRING)
           {

                //
                // Create safe array
                //
                SAFEARRAYBOUND  saBounds;

                saBounds.lLbound   = 0;
                saBounds.cElements = pMqVar->calpwstr.cElems;
                pOleVar->parray = SafeArrayCreate(VT_VARIANT, 1, &saBounds);
			    CHECK_ALLOCATION(pOleVar->parray, 30);
                pOleVar->vt = VT_VARIANT | VT_ARRAY;

                //
                // Fill safe array with strings
                //
                LONG            lTmp, lNum;
                lNum = pMqVar->calpwstr.cElems;
                for (lTmp = 0; lTmp < lNum; lTmp++)
                {
                   CAutoVariant   varClean;
                   VARIANT * pvarTmp = &varClean;
                   pvarTmp->bstrVal = BS_SysAllocString(pMqVar->calpwstr.pElems[lTmp]);
                   pvarTmp->vt = VT_BSTR;

                   //
                   // Add to safe array
                   //
                   hr = SafeArrayPutElement(pOleVar->parray, &lTmp, pvarTmp);
                   if (FAILED(hr))
                   {
                        return LogHR(hr, s_FN, 2000);
                   }

                }
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 360);
           }
           break;

       case(VT_CLSID):
           if (adstype ==  ADSTYPE_OCTET_STRING)
           {
			   pOleVar->vt = VT_ARRAY | VT_UI1;
			   pOleVar->parray = SafeArrayCreateVector(VT_UI1, 0, 16);
			   CHECK_ALLOCATION(pOleVar->parray, 40);
				
			   for (long i=0; i<16; i++)
			   {
				   hr = SafeArrayPutElement(
					        pOleVar->parray,
						    &i,
						    ((unsigned char *)pMqVar->puuid)+i);
                   if (FAILED(hr))
                   {
                       return LogHR(hr, s_FN, 2010);
                   }
			   }

           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 370);
           }
           break;

       case(VT_BLOB):
           if (adstype ==  ADSTYPE_OCTET_STRING)
           {
               ASSERT( pMqVar->blob.cbSize > 0);
			   pOleVar->vt = VT_ARRAY | VT_UI1;
               DWORD len = pMqVar->blob.cbSize;

			   pOleVar->parray = SafeArrayCreateVector(VT_UI1, 0, len);
			   CHECK_ALLOCATION(pOleVar->parray, 50);
               ASSERT( ((long)len) > 0);
				
			   for (long i=0; i<(long)len; i++)
			   {
				   hr = SafeArrayPutElement(
					        pOleVar->parray,
						    &i,
						    pMqVar->blob.pBlobData+i);
                   if (FAILED(hr))
                   {
                        return LogHR(hr, s_FN, 2020);
                   }
               }

           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 380);
           }
           break;

       case(VT_VECTOR|VT_CLSID):
           if (adstype ==  ADSTYPE_OCTET_STRING)
           {
                //
                //  Can't set array size to be zero ( ADSI limitation)
                //
                if ( pMqVar->cauuid.cElems == 0)
                {
                    return LogHR(MQ_ERROR_DS_ERROR, s_FN, 390);
                }

                //
                // Create safe array
                //
                SAFEARRAYBOUND  saBounds;

                saBounds.lLbound   = 0;
                saBounds.cElements = pMqVar->cauuid.cElems;
                pOleVar->parray = SafeArrayCreate(VT_VARIANT, 1, &saBounds);
			    CHECK_ALLOCATION(pOleVar->parray, 60);
                pOleVar->vt = VT_VARIANT | VT_ARRAY;

                //
                // Fill safe array with GUIDs ( each GUID is a safe array)
                //
                LONG            lTmp, lNum;
                lNum = pMqVar->cauuid.cElems;
                for (lTmp = 0; lTmp < lNum; lTmp++)
                {
                   CAutoVariant   varClean;
                   VARIANT * pvarTmp = &varClean;

			       pvarTmp->parray = SafeArrayCreateVector(VT_UI1, 0, 16);
			       CHECK_ALLOCATION(pvarTmp->parray, 70);
			       pvarTmp->vt = VT_ARRAY | VT_UI1;

			       for (long i=0; i<16; i++)
			       {
				       hr = SafeArrayPutElement(
					            pvarTmp->parray,
						        &i,
						        ((unsigned char *)(pMqVar->cauuid.pElems + lTmp))+i);
                       if (FAILED(hr))
                       {
                            return LogHR(hr, s_FN, 2030);
                       }
			       }
                   //
                   // Add safearray variant to safe array
                   //
                   hr = SafeArrayPutElement(pOleVar->parray, &lTmp, pvarTmp);
                   if (FAILED(hr))
                   {
                        return LogHR(hr, s_FN, 2040);
                   }

                }
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR_DS_ERROR, s_FN, 400);
           }
           break;

       default:
           // NIY
           ASSERT(0);
           return LogHR(MQ_ERROR_DS_ERROR, s_FN, 410);
    }
    return MQ_OK;
}


bool IsLocalUser(void)
/*++
Routine Description:
	Check if the user is local user.
	This function is called in order to return better error code for local user in cases of failure

Arguments:
	None.

Returned Value:
	true if the user is local user, false otherwise. 

--*/
{
	BOOL fLocalUser = FALSE;
	HRESULT hr = MQSec_GetUserType( 
						NULL,
						&fLocalUser,
						NULL 
						);

	if (SUCCEEDED(hr) && fLocalUser)
	{
	    TrERROR(mqad, "the user is local user");
	    return true;
	}
	return false;
}


void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogDS,
                     LOG_DS_ERRORS,
                     L"MQADS Error: %s/%d. HR: %x", 
                     wszFileName,
                     usPoint,
                     hr)) ;
}

void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogDS,
                     LOG_DS_ERRORS,
                     L"MQADS Error: %s/%d. NTStatus: %x", 
                     wszFileName,
                     usPoint,
                     status)) ;
}

void LogMsgRPCStatus(RPC_STATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogDS,
                     LOG_DS_ERRORS,
                     L"MQADS Error: %s/%d. RPCStatus: %x", 
                     wszFileName,
                     usPoint,
                     status)) ;
}

void LogMsgBOOL(BOOL b, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogDS,
                     LOG_DS_ERRORS,
                     L"MQADS Error: %s/%d. BOOL: %x", 
                     wszFileName,
                     usPoint,
                     b)) ;
}

void LogIllegalPoint(LPWSTR wszFileName, USHORT usPoint)
{
        WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                         e_LogDS,
                         LOG_DS_ERRORS,
                         L"MQADS Error: %s/%d. Point", 
                         wszFileName,
                         usPoint)) ;
}

#ifdef _WIN64
	void LogIllegalPointValue(DWORD64 dw64, LPCWSTR wszFileName, USHORT usPoint)
	{
		WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
						 e_LogDS,
						 LOG_DS_ERRORS,
						 L"MQADS Error: %s/%d, Value: 0x%I64x",
						 wszFileName,
						 usPoint,
						 dw64)) ;
	}
#else
	void LogIllegalPointValue(DWORD dw, LPCWSTR wszFileName, USHORT usPoint)
	{
		WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
						 e_LogDS,
						 LOG_DS_ERRORS,
						 L"MQADS Error: %s/%d, Value: 0x%x",
						 wszFileName,
						 usPoint,
						 dw)) ;
	}
#endif //_WIN64

void LogTraceQuery(LPWSTR wszStr, LPWSTR wszFileName, USHORT usPoint)
{
        WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                         e_LogDS,
                         LOG_DS_QUERY,
                         L"MQADS Trace: %s/%d. %s", 
                         wszFileName,
                         usPoint,
                         wszStr)) ;
}

void LogTraceQuery2(LPWSTR wszStr1, LPWSTR wszStr2, LPWSTR wszFileName, USHORT usPoint)
{
        WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                         e_LogDS,
                         LOG_DS_QUERY,
                         L"MQADS Trace: %s/%d. %s  %s", 
                         wszFileName,
                         usPoint,
                         wszStr1,
                         wszStr2)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\xlatobj.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    xlatobj.cpp

Abstract:

    Implementation of routines that deal with translation of generic MSMQ objects:
    CObjXlateInfo

Author:

    Raanan Harari (raananh)

--*/

#include "ds_stdh.h"
#include <activeds.h>
#include "mqad.h"
#include "_propvar.h"
#include "dsutils.h"
#include "utils.h"
#include "xlatqm.h"

#include "xlatobj.tmh"

static WCHAR *s_FN=L"mqad/xlatobj";

//--------------------------------------------------------------------
// static functions fwd declaration
//--------------------------------------------------------------------

static 
HRESULT 
GetPropvarByIADs(
		IN IADs * pIADs,
		IN LPCWSTR pwszPropName,
		IN ADSTYPE adstype,
		IN VARTYPE vartype,
		IN BOOL fMultiValued,
		OUT PROPVARIANT * ppropvarResult
		);


static
HRESULT 
GetPropvarByDN(
		IN LPCWSTR pwszObjectDN,
		IN LPCWSTR pwcsDomainController,
        IN bool	   fServerName,
		IN LPCWSTR pwszPropName,
		IN ADSTYPE adstype,
		IN VARTYPE vartype,
		IN BOOL fMultiValued,
		OUT PROPVARIANT * ppropvarResult,
		OUT IADs ** ppIADs
		);


static 
HRESULT 
GetPropvarBySearchObj(
		IN IDirectorySearch *pSearchObj,
		IN ADS_SEARCH_HANDLE hSearch,
		IN LPCWSTR pwszPropName,
		IN ADSTYPE adstype,
		IN VARTYPE vartype,
		OUT PROPVARIANT * ppropvarResult
		);

//--------------------------------------------------------------------
// CObjXlateInfo implementation
//--------------------------------------------------------------------

CObjXlateInfo::CObjXlateInfo(
                    LPCWSTR             pwszObjectDN,
                    const GUID*         pguidObjectGuid)
/*++
    Constructor for the generic xlate info for an MSMQ objects
--*/
{
    //
    // record the DN of the object if any
    //
    if (pwszObjectDN)
    {
        m_pwszObjectDN = new WCHAR[wcslen(pwszObjectDN) + 1];
        wcscpy(m_pwszObjectDN, pwszObjectDN);
    }

    //
    // record the guid of the object if any
    //
    if (pguidObjectGuid)
    {
        m_pguidObjectGuid = new GUID;
        *m_pguidObjectGuid = *pguidObjectGuid;
    }
//
//    no need for following initialization since these are auto-release and inited
//    to NULL already
//
//    m_pIADs = NULL;
//    m_pSearchObj = NULL;
//
}


CObjXlateInfo::~CObjXlateInfo()
/*++
    Destructor for the generic xlate info for an MSMQ objects.
--*/
{
    //
    // members are auto release
    //
}


void CObjXlateInfo::InitGetDsProps(IN IADs * pIADs)
/*++
    Abstract:
        Initialization for GetDsProp call.
        GetDsProp will use the given IADs object when trying to
        get props for the object.

    Parameters:
        pIADs           - IADs interface for the object

    Returns:
      None
--*/
{
    pIADs->AddRef();  // keep it alive
    m_pIADs = pIADs;  // will auto release on destruction
}


void CObjXlateInfo::InitGetDsProps(IN IDirectorySearch * pSearchObj,
                                       IN ADS_SEARCH_HANDLE hSearch)
/*++
    Abstract:
        Initialization for GetDsProp call.
        GetDsProp will use the given search object first when trying to
        get props for the object, before binding to it using IADs.

    Parameters:
        pSearchObj      - search object
        hSearch         - search handle

    Returns:
      None
--*/
{
    pSearchObj->AddRef();      // keep it alive
    m_pSearchObj = pSearchObj; // will auto release on destruction
    m_hSearch = hSearch;
}


HRESULT 
CObjXlateInfo::GetDsProp(
	IN LPCWSTR pwszPropName,
	LPCWSTR    pwcsDomainController,
	IN bool	   fServerName,
	IN ADSTYPE adstype,
	IN VARTYPE vartype,
	IN BOOL fMultiValued,
	OUT PROPVARIANT * ppropvarResult
	)
/*++
    Abstract:
        Get a DS property value of the object as a propvariant, w/o going
        to translation routine or default value

    Parameters:
        pwszPropName    - property name
        adstype         - requested ADSTYPE
        vartype         - requested VARTYPE in result propvariant
        fMultiValued    - whether the property is multi-valued in the DS
        ppropvarResult  - propvariant to fill, should be empty already

    Returns:
      MQ_OK - success, ppropvarResult is filled
      E_ADS_PROPERTY_NOT_FOUND - property was not found
      other HRESULT errors
--*/
{
    HRESULT hr;
    CMQVariant propvarResult;
    BOOL fGotPropFromSearchObj = FALSE;

    //
    // start with getting the property from search object
    //
    if (m_pSearchObj.get() != NULL)
    {
        hr = GetPropvarBySearchObj(m_pSearchObj.get(),
                                   m_hSearch,
                                   pwszPropName,
                                   adstype,
                                   vartype,
                                   propvarResult.CastToStruct());
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetDsProp:GetPropvarBySearchObj()=%lx"), hr));
            return LogHR(hr, s_FN, 10);
        }

        //
        // hr could be S_OK (if property found) or S_FALSE (if property was not requested in search)
        //
        if (hr == S_OK) //e.g. (hr != S_FALSE)
        {
            //
            // we don't need to check further
            //
            fGotPropFromSearchObj = TRUE;
        }
    }

    //
    // if search object was not helpfull, use IADs
    //
    if (!fGotPropFromSearchObj)
    {
        //
        // property was not found, use IADs
        //
        if (m_pIADs.get() != NULL)
        {
            //
            // there is already an open IADs for the object, use it
            //
            hr = GetPropvarByIADs(m_pIADs.get(),
                                  pwszPropName,
                                  adstype,
                                  vartype,
                                  fMultiValued,
                                  propvarResult.CastToStruct());
            if (FAILED(hr))
            {
                DBGMSG((DBGMOD_ADS, DBGLVL_TRACE, TEXT("GetDsProp:GetPropvarByIADs()=%lx"), hr));
                return LogHR(hr, s_FN, 20);
            }
        }
        else
        {
            //
            // IADs is not set, bind to the object, and save the IADs
            //
            R<IADs> pIADs;
            hr = GetPropvarByDN(
						ObjectDN(),
						pwcsDomainController,
						fServerName,
						pwszPropName,
						adstype,
						vartype,
						fMultiValued,
						propvarResult.CastToStruct(),
						&pIADs.ref()
						);
            if (FAILED(hr))
            {
                DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetDsProp:GetPropvarByDN()=%lx"), hr));
                return LogHR(hr, s_FN, 30);
            }

            //
            // save the IADs
            // we must not AddRef it since we created it and we need to totally release
            // it on destruction, it is not a passed parameter we need to keep alive
            //
            m_pIADs = pIADs;
        }
    }

    //
    // return values
    //
    *ppropvarResult = *(propvarResult.CastToStruct());
    (propvarResult.CastToStruct())->vt = VT_EMPTY;
    return MQ_OK;
}



//--------------------------------------------------------------------
// external functions
//--------------------------------------------------------------------


//--------------------------------------------------------------------
// static functions
//--------------------------------------------------------------------

static 
HRESULT 
GetPropvarByIADs(
		IN IADs * pIADs,
		IN LPCWSTR pwszPropName,
		IN ADSTYPE adstype,
		IN VARTYPE vartype,
		IN BOOL fMultiValued,
		OUT PROPVARIANT * ppropvarResult
		)
/*++
    Abstract:
        Get a DS property as a propvariant, w/o going to translation routine,
        using IADs

    Parameters:
        pIADs           - IADs interface for the object
        pwszPropName    - property name
        adstype         - requested ADSTYPE
        vartype         - requested VARTYPE in result propvariant
        fMultiValued    - whether the property is multi-valued in the DS
        ppropvarResult  - propvariant to fill, should be empty already

    Returns:
      S_OK - success, ppropvarResult is filled
      other HRESULT errors
--*/
{
    HRESULT hr;
    //
    // get prop
    //
    CAutoVariant varResult;
    BS bsProp = pwszPropName;
    if (fMultiValued)
    {
        hr = pIADs->GetEx(bsProp, &varResult);
    }
    else
    {
        hr = pIADs->Get(bsProp, &varResult);
    }    
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_TRACE, TEXT("GetPropvarByIADs:pIADs->Get()/GetEx()=%lx"), hr));
        return LogHR(hr, s_FN, 40);
    }

    //
    // translate to propvariant
    //
    CMQVariant propvarResult;
    hr = Variant2MqVal(propvarResult.CastToStruct(), &varResult, adstype, vartype);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetPropvarByIADs:Variant2MqVal()=%lx"), hr));
        return LogHR(hr, s_FN, 50);
    }

    //
    // return values
    //
    *ppropvarResult = *(propvarResult.CastToStruct());
    (propvarResult.CastToStruct())->vt = VT_EMPTY;
    return S_OK;
}


static 
HRESULT 
GetPropvarByDN(
	IN LPCWSTR pwszObjectDN,
	IN LPCWSTR pwcsDomainController,
    IN bool	   fServerName,
	IN LPCWSTR pwszPropName,
	IN ADSTYPE adstype,
	IN VARTYPE vartype,
	IN BOOL fMultiValued,
	OUT PROPVARIANT * ppropvarResult,
	OUT IADs ** ppIADs
	)
/*++
    Abstract:
        Get a DS property as a propvariant, w/o going to translation routine,
        using its DN. It also returns the IADs for the object.

    Parameters:
        pwszObjectDN    - distinguished name of the object
        pwszPropName    - property name
        adstype         - requested ADSTYPE
        vartype         - requested VARTYPE in result propvariant
        fMultiValued    - whether the property is multi-valued in the DS
        ppropvarResult  - propvariant to fill, should be empty already
        ppIADs          - returned IADs interface for the object

    Returns:
      S_OK - success, ppropvarResult is filled
      other HRESULT errors
--*/
{
    HRESULT hr;

    //
    // Create ADSI path
    //
    DWORD lenDC = (pwcsDomainController != NULL) ? wcslen(pwcsDomainController) : 0;
    AP<WCHAR> pwszPath = new WCHAR[1 + x_LdapProviderLen + lenDC + 1 + wcslen(pwszObjectDN)];

    if (pwcsDomainController == NULL)
    {
        swprintf( pwszPath,
                  L"%s%s",
                  x_LdapProvider,
                  pwszObjectDN);
    }
    else
    {
        swprintf( pwszPath,
                  L"%s%s/%s",
                  x_LdapProvider,
                  pwcsDomainController,
                  pwszObjectDN);
    }
    //
    // bind to the obj
    //
    R<IADs> pIADs;

	DWORD Flags = ADS_SECURE_AUTHENTICATION;
	if(fServerName && (pwcsDomainController != NULL))
	{
		Flags |= ADS_SERVER_BIND;
	}

	hr = ADsOpenObject(
			pwszPath,
			NULL,
			NULL,
			Flags, 
			IID_IADs,
			(void**)&pIADs
			);

    LogTraceQuery(pwszPath, s_FN, 59);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetPropvarByDN:ADsOpenObject()=%lx"), hr));
        return LogHR(hr, s_FN, 60);
    }

    //
    // get the prop
    //
    CMQVariant propvarResult;
    hr = GetPropvarByIADs(pIADs.get(), pwszPropName, adstype, vartype, fMultiValued, propvarResult.CastToStruct());
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetPropvarByDN:GetPropvarByIADs()=%lx"), hr));
        return LogHR(hr, s_FN, 70);
    }

    //
    // return values
    //
    *ppropvarResult = *(propvarResult.CastToStruct());
    (propvarResult.CastToStruct())->vt = VT_EMPTY;
    *ppIADs = pIADs.detach();
    return S_OK;
}


static 
HRESULT 
GetPropvarBySearchObj(
	IN IDirectorySearch *pSearchObj,
	IN ADS_SEARCH_HANDLE hSearch,
	IN LPCWSTR pwszPropName,
	IN ADSTYPE adstype,
	IN VARTYPE vartype,
	OUT PROPVARIANT * ppropvarResult
	)
/*++
    Abstract:
        Get a DS property as a propvariant, w/o going to translation routine,
        using a search object.
        Note it might not find the property if it was not requested by the
        search originator.

    Parameters:
        pSearchObj      - search object
        hSearch         - search handle
        pwszPropName    - property name
        adstype         - requested ADSTYPE
        vartype         - requested VARTYPE in result propvariant
        ppropvarResult  - propvariant to fill, should be empty already

    Returns:
      S_OK - success, ppropvarResult is filled
      S_FALSE - property not requested by search originator, ppropvarResult is not filled
      other HRESULT errors
--*/
{
    //
    // check if prop is requested
    //
    ADS_SEARCH_COLUMN columnProp;
    HRESULT hr = pSearchObj->GetColumn(hSearch, const_cast<LPWSTR>(pwszPropName), &columnProp);
    if (FAILED(hr) && (hr != E_ADS_COLUMN_NOT_SET))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetPropvarBySearchObj:pSearchObj->GetColumn()=%lx"), hr));
        return LogHR(hr, s_FN, 80);
    }
    
    if (hr == E_ADS_COLUMN_NOT_SET)
    {
        //
        // property was not requested
        //
        return S_FALSE;
    }

    //
    // property was found, make sure the column is freed eventually
    //
    CAutoReleaseColumn cAutoReleaseColumnProp(pSearchObj, &columnProp);

    //
    // convert it to propvariant
    //
    CMQVariant propvarResult;
    hr = AdsiVal2MqVal(propvarResult.CastToStruct(),
                       vartype,
                       adstype,
                       columnProp.dwNumValues,
                       columnProp.pADsValues);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetPropvarBySearchObj:AdsiVal2MqVal()=%lx"), hr));
        return LogHR(hr, s_FN, 90);
    }

    //
    // return values
    //
    *ppropvarResult = *(propvarResult.CastToStruct());
    (propvarResult.CastToStruct())->vt = VT_EMPTY;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\dsglbobj.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    DSGlbObj.h

Abstract:

    Definition of Global Instances of the MQADS server.
    They are put in one place to ensure the order their constructors take place.

Author:

    ronit hartmann (ronith)

--*/
#ifndef __DSGLBOBJ_H__
#define __DSGLBOBJ_H__

#include "ds_stdh.h"
#include "wrtreq.h"

//
//  For sending write requests
//
extern CGenerateWriteRequests g_GenWriteRequests;

//
// For tracking DSCore init status
//
extern BOOL g_fInitedDSCore;

extern BOOL g_fMQADSSetupMode;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\dsglbobj.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    DSGlbObj.cpp

Abstract:

    Declaration of Global Instances of the MQADS server.
    They are put in one place to ensure the order their constructors take place.

Author:

    ronit hartmann (ronith)

--*/
#include "ds_stdh.h"
#include "mqperf.h"
#include "wrtreq.h"

#include "dsglbobj.tmh"

static WCHAR *s_FN=L"mqads/dsglobj";


//
// Defenition for ds performance counters , if the counters are not initialized then
// a dummy array of counters will be used.
// Counters are initialized by the QM when the DS server is loaded by calling
// the DSSetPerfCounters in the ds server
//

DSCounters g_DummyCounters;
__declspec(dllexport) DSCounters *g_pdsCounters = &g_DummyCounters;

//
//  For sending write requests
//
CGenerateWriteRequests g_GenWriteRequests;

//
// For tracking DSCore init status
//
BOOL g_fInitedDSCore = FALSE;


BOOL g_fMQADSSetupMode = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\midluser.cpp ===
#include "ds_stdh.h"

#include "..\\..\\common\\midluser.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\mqadssec.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mqadssec.h

Abstract:

	mqadssec function prototype

Author:

    Ilan Herbst    (IlanH)   19-Feb-2001 

--*/

#ifndef _MQADSSEC_MQADS_H_
#define _MQADSSEC_MQADS_H_

HRESULT CheckTrustForDelegation();

HRESULT 
CanUserCreateConfigObject(
	IN   LPCWSTR  pwcsPathName,
	OUT  bool    *pfComputerExist 
	);


#endif 	// _MQADSSEC_MQADS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqad\test\test.cpp ===
#include "..\..\h\ds_stdh.h"
#include "mqad.h"
#include "mqprops.h"
#include <dsgetdc.h>
#include "mqsec.h"



extern "C" 
int 
__cdecl 
_tmain(
    int /* argc */,
    LPCTSTR* /* argv */
    )
{
    printf("    Please remeber to delete manually the following objects from AD: \n");
    printf("            for-site1, \n");
    printf("            for-site2 \n");
    printf("            forcom1 \n");
    printf("            forcom1 server object \n");
    printf("\n\n");

    MQADInit(  NULL, false, NULL);


    //
    //  Retrieve local computer name
    //
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    AP<WCHAR> pwcsComputerName = new WCHAR[dwSize];

    if (GetComputerName(pwcsComputerName, &dwSize))
    {
        CharLower(pwcsComputerName);
    }
    else
    {
        printf("failed to retreive local computer name \n");
    }
    //
    //  Get the name of a local domain controller
    //
    ULONG ulFlags =  DS_FORCE_REDISCOVERY           |
                 DS_DIRECTORY_SERVICE_PREFERRED; 

    DOMAIN_CONTROLLER_INFO * pDomainControllerInfo;

    DWORD dwDC = DsGetDcName(  NULL,    //LPCTSTR ComputerName,
                               NULL,    // szDoaminName, 
                               NULL,    //GUID *DomainGuid,
                               NULL,    //LPCTSTR SiteName,
                               ulFlags,
                               &pDomainControllerInfo);

    if (dwDC != NO_ERROR)
    {
        printf("failed to retreive domain controller name \n");
    }

    WCHAR * pwcsDC = pDomainControllerInfo->DomainControllerName + 2;


    PROPID prop[40];
    PROPVARIANT var[40];
    HRESULT hr;

    //
    //  create q1
    //
    prop[0] = PROPID_Q_TRANSACTION;
    var[0].vt = VT_UI1;
    var[0].bVal = 0;  

    GUID guidQueue1;
    AP<WCHAR> pwcsQ1Name = new WCHAR[dwSize + 10];
    swprintf( pwcsQ1Name, L"%s\\q1", pwcsComputerName);

    hr = MQADCreateObject(
                eQUEUE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
                pwcsQ1Name,
                NULL,
                1,
                prop,
                var,
                &guidQueue1
                );
    if (FAILED(hr) && hr != MQ_ERROR_QUEUE_EXISTS)
    {
        printf("FAILURE : creating queue %S, hr = %lx\n", pwcsQ1Name, hr);
    }
    if ( hr == MQ_ERROR_QUEUE_EXISTS)
    {
        //
        //  delete the queue
        //
        hr = MQADDeleteObject(
                eQUEUE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
                pwcsQ1Name
                );
        if (FAILED(hr))
        {
            printf("FAILURE : deleting queue %S, hr = %lx\n", pwcsQ1Name, hr);
        }
        hr = MQADCreateObject(
                    eQUEUE,
					NULL,       // pwcsDomainController
					false,	    // fServerName
                    pwcsQ1Name,
                    NULL,
                    1,
                    prop,
                    var,
                    &guidQueue1
                    );
        if (FAILED(hr))
        {
            printf("FAILURE : creating queue %S, hr = %lx\n", pwcsQ1Name, hr);
        }
    }

    prop[0] = PROPID_Q_QMID;
    prop[1] = PROPID_Q_INSTANCE;
    GUID guidComputer;

    var[0].vt = VT_CLSID;
    var[0].puuid = &guidComputer;
    var[1].vt = VT_NULL;
    hr  = MQADGetObjectProperties(
                eQUEUE,
                NULL,
				false,	// fServerName
                pwcsQ1Name,
                2,
                prop,
                var
                );
    if (FAILED(hr))
    {
        printf("FAILURE : Get queue props %S, hr = %lx\n", pwcsQ1Name, hr);
    }
    if (guidQueue1 != *var[1].puuid)
    {
        printf("FAILURE : Wrong guid was returned\n");
    }
    delete var[1].puuid;

    var[1].vt = VT_NULL;
    hr  = MQADGetObjectProperties(
            eQUEUE,
            pwcsDC,
			true,	// fServerName
            pwcsQ1Name,
            2,
            prop,
            var
            );

    if (FAILED(hr))
    {
        printf("FAILURE : Get queue props %S, hr = %lx\n", pwcsQ1Name, hr);
    }
    if (guidQueue1 != *var[1].puuid)
    {
        printf("FAILURE : Wrong guid was returned\n");
    }
    delete var[1].puuid;


    prop[0] = PROPID_Q_PATHNAME;

    var[0].vt = VT_NULL;
    hr  = MQADGetObjectPropertiesGuid(
                eQUEUE,
                NULL,
				false,	// fServerName
                &guidQueue1,
                1,
                prop,
                var
                );
    if (FAILED(hr))
    {
        printf("FAILURE : Get queue props according to guid, hr = %lx\n", hr);
    }
    if (0 != wcscmp(pwcsQ1Name, var[0].pwszVal))
    {
        printf("FAILURE : Wrong pathname was returned\n");
    }

    //
    //  create q2
    //
    prop[0] = PROPID_Q_TRANSACTION;
    var[0].vt = VT_UI1;
    var[0].bVal = 0;  

    GUID guidQueue2;
    AP<WCHAR> pwcsQ2Name = new WCHAR[dwSize + 10];
    swprintf( pwcsQ2Name, L"%s\\q2", pwcsComputerName);

    hr = MQADCreateObject(
                eQUEUE,
                pwcsDC,
				true,	    // fServerName
                pwcsQ2Name,
                NULL,
                1,
                prop,
                var,
                &guidQueue2
                );
    if (FAILED(hr))
    {
        printf("FAILURE : creating queue %S, hr = %lx\n", pwcsQ2Name, hr);
    }
    //
    //  get all props of q2
    //
    prop[0] = PROPID_Q_INSTANCE;
    var[0].vt = VT_NULL;

    prop[1] = PROPID_Q_TYPE;
    var[1].vt = VT_NULL;

    prop[2] = PROPID_Q_PATHNAME;
    var[2].vt = VT_NULL;

    prop[3] = PROPID_Q_JOURNAL;
    var[3].vt = VT_NULL;

    prop[4] = PROPID_Q_QUOTA;
    var[4].vt = VT_NULL;

    prop[5] = PROPID_Q_BASEPRIORITY;
    var[5].vt = VT_NULL;

    prop[6] = PROPID_Q_JOURNAL_QUOTA;
    var[6].vt = VT_NULL;

    prop[7] = PROPID_Q_LABEL;
    var[7].vt = VT_NULL;

    prop[8] = PROPID_Q_CREATE_TIME;
    var[8].vt = VT_NULL;

    prop[9] = PROPID_Q_MODIFY_TIME;
    var[9].vt = VT_NULL;

    prop[10] = PROPID_Q_AUTHENTICATE;
    var[10].vt = VT_NULL;

    prop[11] = PROPID_Q_PRIV_LEVEL;
    var[11].vt = VT_NULL;

    prop[12] = PROPID_Q_TRANSACTION;
    var[12].vt = VT_NULL;

    prop[13] = PROPID_Q_QMID;
    var[13].vt = VT_NULL;

    prop[14] = PROPID_Q_FULL_PATH;
    var[14].vt = VT_NULL;

    prop[15] = PROPID_Q_PATHNAME_DNS;
    var[15].vt = VT_NULL;

    hr  = MQADGetObjectProperties(
                eQUEUE,
                NULL,
				false,	// fServerName
                pwcsQ2Name,
                16,
                prop,
                var
                );
    if (FAILED(hr))
    {
        printf("FAILURE : Get queue props %S, hr = %lx\n", pwcsQ2Name, hr);
    }
    // check retrieved values
    //
    //      PROPID_Q_INSTANCE
    //
    if (guidQueue2 != *var[0].puuid)
    {
        printf("FAILURE : wrong Q_INSTANCE for queue %S\n", pwcsQ2Name);
    }
    delete var[0].puuid;
    //
    //      PROPID_Q_TYPE;
    if(*var[1].puuid != GUID_NULL)
    {
        printf("FAILURE : wrong Q_TYPE for queue %S\n", pwcsQ2Name);
    }
    delete var[1].puuid;
    //
    //      PROPID_Q_PATHNAME;
    if (0 != wcscmp(var[2].pwszVal, pwcsQ2Name))
    {
        printf("FAILURE : wrong Q_PATHNAME for queue %S\n", pwcsQ2Name);
    }
    delete []var[2].pwszVal;
    //
    //      PROPID_Q_JOURNAL;
    if (DEFAULT_Q_JOURNAL != var[3].bVal)
    {
        printf("FAILURE : wrong Q_JOURNAL for queue %S\n", pwcsQ2Name);
    }
    //
    //      PROPID_Q_QUOTA;
    if (DEFAULT_Q_QUOTA != var[4].ulVal)
    {
        printf("FAILURE : wrong Q_QUOTA for queue %S\n", pwcsQ2Name);
    }
    //
    //      PROPID_Q_BASEPRIORITY;
    if (DEFAULT_Q_BASEPRIORITY !=  var[5].bVal)
    {
        printf("FAILURE : wrong Q_BASEPRIORITY for queue %S\n", pwcsQ2Name);
    }
    //
    //      PROPID_Q_JOURNAL_QUOTA;
    if (DEFAULT_Q_JOURNAL_QUOTA != var[6].ulVal)
    {
        printf("FAILURE : wrong Q_JOURNAL_QUOTA for queue %S\n", pwcsQ2Name);
    }
    //
    //      PROPID_Q_LABEL;
    if (0 != wcscmp(TEXT(""), var[7].pwszVal))
    {
        printf("FAILURE : wrong Q_LABEL for queue %S\n", pwcsQ2Name);
    }
    delete [] var[7].pwszVal;
    //
    //      PROPID_Q_AUTHENTICATE;
    if (DEFAULT_Q_AUTHENTICATE != var[10].bVal)
    {
        printf("FAILURE : wrong Q_AUTHENTICATE for queue %S\n", pwcsQ2Name);
    }
    //
    //      PROPID_Q_PRIV_LEVEL;
    if (DEFAULT_Q_PRIV_LEVEL != var[11].ulVal)
    {
        printf("FAILURE : wrong Q_PRIV_LEVEL for queue %S\n", pwcsQ2Name);
    }
    //
    //      PROPID_Q_TRANSACTION;
    if (MQ_TRANSACTIONAL_NONE != var[12].bVal)
    {
        printf("FAILURE : wrong Q_TRANSACTION for queue %S\n", pwcsQ2Name);
    }
    //
    //  PROPID_Q_QMID;
    if (guidComputer != *var[13].puuid)
    {
        printf("FAILURE : wrong Q_QMID for queue %S\n", pwcsQ2Name);
    }
    delete var[13].puuid;

    //PROPID_Q_FULL_PATH;
    delete [] var[14].pwszVal;

    //PROPID_Q_PATHNAME_DNS;
    delete var[15].pwszVal;

    //
    //  set queue multicast address
    //
    prop[0] = PROPID_Q_MULTICAST_ADDRESS;
    var[0].vt = VT_LPWSTR;
    var[0].pwszVal = TEXT("12345678910");

    hr  = MQADSetObjectProperties(
                eQUEUE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
                pwcsQ2Name,
                1,
                prop,
                var
                );
    if (FAILED(hr))
    {
        printf("FAILURE : set queue multicast address %S, hr = %lx\n", pwcsQ2Name, hr);
    }

    var[0].vt = VT_NULL;
    hr  = MQADGetObjectProperties(
                eQUEUE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
                pwcsQ2Name,
                1,
                prop,
                var
                );
    if (FAILED(hr))
    {
        printf("FAILURE : get queue multicast address %S, hr = %lx\n", pwcsQ2Name, hr);
    }
    if (0 != wcscmp(TEXT("12345678910"), var[0].pwszVal))
    {
        printf("FAILURE : wrong multicast address %S\n", pwcsQ2Name);
    }

    var[0].vt = VT_EMPTY;
    hr  = MQADSetObjectProperties(
                eQUEUE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
                pwcsQ2Name,
                1,
                prop,
                var
                );
    if (FAILED(hr))
    {
        printf("FAILURE : set queue empty multicast address %S, hr = %lx\n", pwcsQ2Name, hr);
    }

    var[0].vt = VT_NULL;
    hr  = MQADGetObjectProperties(
                eQUEUE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
                pwcsQ2Name,
                1,
                prop,
                var
                );
    if (FAILED(hr))
    {
        printf("FAILURE : get queue empty multicast address %S, hr = %lx\n", pwcsQ2Name, hr);
    }
    if (var[0].vt != VT_EMPTY)
    {
        printf("FAILURE : wrong empty multicast address %S\n", pwcsQ2Name);
    }
    //
    //  locate local computer's queueus
    //

    PROPID colInstance = PROPID_Q_INSTANCE;
    MQCOLUMNSET columns;
    columns.cCol = 1;
    columns.aCol = &colInstance;

    HANDLE h;

    hr = MQADQueryMachineQueues(
                pwcsDC,
				true,		// fServerName
                &guidComputer,
                &columns,
                &h
                );
    if (FAILED(hr))
    {
        printf("FAILURE : MQADQueryMachineQueues hr = %lx \n",hr);
    }

    PROPVARIANT result;
    DWORD num = 1;

    result.vt = VT_NULL;
    DWORD needToFind = 2;

    while (SUCCEEDED( hr =  MQADQueryResults(h, &num, &result)))
    {
        if (num == 0)
        {
            break;
        }
        if (*result.puuid == guidQueue1)
        {
            needToFind--;
        }
        if (*result.puuid == guidQueue2)
        {
            needToFind--;
        }
        delete result.puuid;
        result.vt = VT_NULL;
    }

    if (FAILED(hr))
    {
        printf("FAILURE : QueryMachineQueues: query results hr = %lx \n",hr);

    }
    if (needToFind != 0)
    {
        printf("FAILURE : QueryMachineQueues: not enough results\n");
    }

    hr = MQADEndQuery(h);
    if (FAILED(hr))
    {
        printf("FAILURE : QueryMachineQueues: end query hr = %lx \n",hr);

    }
    //
    //  change q2 label to q1
    //
    prop[0] = PROPID_Q_LABEL;
    var[0].vt = VT_LPWSTR;
    var[0].pwszVal = L"q1";
    hr = MQADSetObjectProperties(
				eQUEUE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				pwcsQ2Name,
				1,
				prop,
				var
				);
    if (FAILED(hr))
    {
        printf("FAILURE : updating q = %S, hr = %lx \n",pwcsQ2Name, hr);
    }
    //
    //  Change q1 label to q1
    //
    hr = MQADSetObjectPropertiesGuid(
				eQUEUE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				&guidQueue1,
				1,
				prop,
				var
				);
    if (FAILED(hr))
    {
        printf("FAILURE : updating q = %S according to guid, hr = %lx \n",pwcsQ1Name, hr);
    }

    //
    // Locate all queues where label == q1
    //

    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;
    propRestriction.prval.vt = VT_LPWSTR;
    propRestriction.prval.pwszVal = L"q1";
    propRestriction.prop = PROPID_Q_LABEL;

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;
    hr = MQADQueryQueues(
                NULL,       //pwcsDomainController
				false,		// fServerName
                &restriction,
                &columns,
                NULL,       //pSort,
                &h
                );
    if (FAILED(hr))
    {
        printf("FAILURE : MQADQueryQueues hr = %lx \n",hr);
    }

    num = 1;

    result.vt = VT_NULL;
    needToFind = 2;

    while (SUCCEEDED( hr =  MQADQueryResults(h, &num, &result)))
    {
        if (num == 0)
        {
            break;
        }
        if (*result.puuid == guidQueue1)
        {
            needToFind--;
        }
        if (*result.puuid == guidQueue2)
        {
            needToFind--;
        }
        delete result.puuid;
        result.vt = VT_NULL;
    }

    if (FAILED(hr))
    {
        printf("FAILURE : MQADQueryQueues: query results hr = %lx \n",hr);

    }
    if (needToFind != 0)
    {
        printf("FAILURE : MQADQueryQueues: not enough results\n");
    }

    hr = MQADEndQuery(h);
    if (FAILED(hr))
    {
        printf("FAILURE : QueryMachineQueues: end query hr = %lx \n",hr);

    }

    //
    //  delete q2 according to its guid
    //
    hr = MQADDeleteObjectGuid(
				eQUEUE,
				pwcsDC,
				true,	    // fServerName
				&guidQueue2
				);
    if (FAILED(hr))
    {
        printf("FAILURE : to delete q2 according to guid, hr = %lx\n", hr);
    }

    //
    //  Create foreign site-1
    //
    prop[0] = PROPID_S_FOREIGN;
    var[0].vt = VT_UI1;
    var[0].bVal = 1;

    hr = MQADCreateObject(
				eSITE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				L"for-site1",
				NULL, //pSecurityDescriptor
				1,
				prop,
				var,
				NULL
				);
    if (FAILED(hr))
    {
        printf("FAILURE : to create foreign site 1, hr =%lx\n", hr);
    }

    //
    //  Create foreign site-2
    //
    prop[0] = PROPID_S_FOREIGN;
    var[0].vt = VT_UI1;
    var[0].bVal = 1;

    hr = MQADCreateObject(
				eSITE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				L"for-site2",
				NULL, //pSecurityDescriptor
				1,
				prop,
				var,
				NULL
				);
    if (FAILED(hr))
    {
        printf("FAILURE : to create foreign site 2, hr =%lx\n", hr);
    }

    GUID guidForSite1;

    prop[0] = PROPID_S_SITEID;
    var[0].vt = VT_CLSID;
    var[0].puuid = &guidForSite1;

    hr = MQADGetObjectProperties(
				eSITE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				L"for-site1",
				1,
				prop,
				var
				);
    if (FAILED(hr))
    {
        printf("FAILURE : to retrieve foreign site 1 properties, hr =%lx\n", hr);
    }

    GUID guidForSite2;

    prop[0] = PROPID_S_SITEID;
    var[0].vt = VT_CLSID;
    var[0].puuid = &guidForSite2;

    hr = MQADGetObjectProperties(
				eSITE,
				pwcsDC,
				true,	// fServerName
				L"for-site2",
				1,
				prop,
				var
				);
    if (FAILED(hr))
    {
        printf("FAILURE : to retrieve foreign site 2 properties, hr =%lx\n", hr);
    }


    //
    //  create routing link between foreign sites 1 and 2
    //

    prop[0] = PROPID_L_NEIGHBOR1;
    var[0].vt = VT_CLSID;
    var[0].puuid = &guidForSite2;
    prop[1] = PROPID_L_NEIGHBOR2;
    var[1].vt = VT_CLSID;
    var[1].puuid = &guidForSite1;
    prop[2] = PROPID_L_COST;
    var[2].vt = VT_UI4;
    var[2].ulVal = 5;
    GUID guidRoutingLink;

    hr = MQADCreateObject(
				eROUTINGLINK,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				NULL, // pwcsPathName
				NULL, //pSecurityDescriptor
				3,
				prop,
				var,
				&guidRoutingLink
				);
    if (FAILED(hr))
    {
        printf("FAILURE : to create routing-link, hr =%lx\n", hr);
    }

    //
    //  Set routing-link properties
    //
    prop[0] = PROPID_L_COST;
    var[0].vt = VT_UI4;
    var[0].ulVal = 33;
    hr = MQADSetObjectPropertiesGuid(
				eROUTINGLINK,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				&guidRoutingLink,
				1,
				prop,
				var
				);
    if (FAILED(hr))
    {
        printf("FAILURE : to set routing-link properties, hr =%lx\n", hr);
    }
    //
    //  Get routing link properties
    //
    prop[0] = PROPID_L_ACTUAL_COST;
    var[0].vt = VT_NULL;

    hr = MQADGetObjectPropertiesGuid(
				eROUTINGLINK,
				NULL,  //pwcsDomainController
				false,	// fServerName
				&guidRoutingLink,
				1,
				prop,
				var
				);
    if (FAILED(hr))
    {
        printf("FAILURE : to get routing-link properties, hr =%lx\n", hr);
    }
    if ( var[0].ulVal != 33)
    {
        printf("FAILURE : wrong value for routing-link cost\n");
    }
    //
    //  Get local computer sites
    //
    GUID* pguidSites;
    DWORD numSites;

    hr = MQADGetComputerSites(
                        pwcsComputerName,
                        &numSites,
                        &pguidSites
                        );
    if (FAILED(hr))
    {
        printf("FAILURE: to getComputerSites, computer = %S, hr =%lx\n", pwcsComputerName, hr);
    }
    if (numSites != 1)
    {
        printf("FAILURE: wrong number of sites \n");
    }

    //
    //  creating foreign computer
    //
    //  This is trick : it is created as a routing server in two sites
    //  (and creation of msmsq-settings in the foreign site will fail!!!)
    //
    prop[0] = PROPID_QM_FOREIGN;
    var[0].vt = VT_UI1;
    var[0].bVal = 1;
    GUID g[2];
    g[0] = *pguidSites;
    g[1] =guidForSite1 ;
    
    prop[1] =  PROPID_QM_SITE_IDS;
    var[1].vt = VT_CLSID|VT_VECTOR;
    var[1].cauuid.cElems = 2;
    var[1].cauuid.pElems = g;

    prop[2] =  PROPID_QM_OS;
    var[2].vt = VT_UI4;
    var[2].ulVal = MSMQ_OS_FOREIGN;

    prop[3] =  PROPID_QM_SERVICE_ROUTING;
    var[3].vt = VT_UI1;
    var[3].bVal = 1;

    hr = MQADCreateObject(
                eMACHINE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
                L"forcom1",
                NULL,
                4,
                prop,
                var,
                NULL
                );
    if (FAILED(hr) && hr != 0xc00e000d)
    {
        printf("FAILURE : to create foreign computer forcom1, hr = %lx \n", hr);
    }

    //
    //  Locate routing servers
    //
    
    PROPID colRouter = PROPID_QM_PATHNAME;
    MQCOLUMNSET columnsRouter;
    columnsRouter.cCol = 1;
    columnsRouter.aCol = &colRouter;
    HANDLE h1;

    hr = MQADQuerySiteServers(
                    NULL,   //pwcsDomainController
					false,	// fServerName
                    pguidSites,
                    eRouter,
                    &columnsRouter,
                    &h1
                    );

    if (FAILED(hr))
    {
        printf("FAILURE : to query site servers, hr = %lx\n",hr);
    }

    PROPVARIANT resultRouters;
    DWORD numRouters = 1;

    resultRouters.vt = VT_NULL;
    needToFind = 1;

    while (SUCCEEDED( hr =  MQADQueryResults(h1, &numRouters, &resultRouters)))
    {
        if (numRouters == 0)
        {
            break;
        }
        if ( 0 == wcscmp(resultRouters.pwszVal, L"forcom1"))
        {
            needToFind--;
        }
        delete []resultRouters.pwszVal ;
        resultRouters.vt = VT_NULL;
    }

    if (FAILED(hr))
    {
        printf("FAILURE : QuerySiteServers: query results hr = %lx \n",hr);

    }
    if (needToFind != 0)
    {
        printf("FAILURE : QuerySiteServers: not enough results\n");
    }

    hr = MQADEndQuery(h1);
    if (FAILED(hr))
    {
        printf("FAILURE : QuerySiteServers: end query hr = %lx \n",hr);

    }
    

    //
    //  Locate foreign sites
    //
    PROPID colSite = PROPID_S_PATHNAME;
    MQCOLUMNSET columnsSite;
    columnsSite.cCol = 1;
    columnsSite.aCol = &colSite;

    HANDLE h2;
    hr = MQADQueryForeignSites(
				NULL,       // pwcsDomainController
				false,	    // fServerName
                &columnsSite,
                &h2
                );

    if (FAILED(hr))
    {
        printf("FAILURE : MQADQueryForeignSites hr = %lx \n",hr);
    }

    PROPVARIANT resultSites;
    DWORD numForSites = 1;

    resultSites.vt = VT_NULL;
    needToFind = 2;

    while (SUCCEEDED( hr =  MQADQueryResults(h2, &numForSites, &resultSites)))
    {
        if (numForSites == 0)
        {
            break;
        }
        if (wcscmp(resultSites.pwszVal, L"for-site1") == 0)
        {
            needToFind--;
        }
        if (wcscmp(resultSites.pwszVal, L"for-site2") == 0)
        {
            needToFind--;
        }
        delete []resultSites.pwszVal;
        resultSites.vt = VT_NULL;
    }

    if (FAILED(hr))
    {
        printf("FAILURE : MQADQueryForeignSites: query results hr = %lx \n",hr);

    }
    if (needToFind != 0)
    {
        printf("FAILURE : MQADQueryForeignSites: not enough results\n");
    }

    hr = MQADEndQuery(h2);
    if (FAILED(hr))
    {
        printf("FAILURE : MQADQueryForeignSites: end query hr = %lx \n",hr);

    }

    //
    // create user
    //
    prop[0] = PROPID_U_ID;
    GUID guidCert;
    var[0].vt = VT_CLSID;
    var[0].puuid = &guidCert;
    UuidCreate(&guidCert);

    byte c[200] ={'a'};
    prop[1] = PROPID_U_SIGN_CERT;
    var[1].vt = VT_BLOB;
    var[1].blob.cbSize =  200 ;
    var[1].blob.pBlobData  = c ;

    prop[2] = PROPID_U_DIGEST;
    var[2].vt = VT_CLSID;
    var[2].puuid = &guidCert;

    hr = MQADCreateObject(   
				eUSER,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				NULL,
				NULL,
				3,
				prop,
				var,
				NULL 
				);
    if (FAILED(hr))
    {
        printf("FAILURE - to create user hr = %lx\n",hr);
    }
    //
    //  locate users accoring to sid
    //
    BYTE * pUserSid = NULL;
    hr = MQSec_GetProcessUserSid((PSID*) &pUserSid, NULL);
    if (FAILED(hr))
    {
        printf("FAILURE to get prosses sid, hr = %lx\n",hr);
    }
    BLOB blobUserSid;
    blobUserSid.cbSize = GetLengthSid(pUserSid);
    blobUserSid.pBlobData = (unsigned char *)pUserSid;

    PROPID colUserCert = PROPID_U_SIGN_CERT;
    MQCOLUMNSET columnsUsers;
    columnsUsers.cCol = 1;
    columnsUsers.aCol = &colUserCert;

    HANDLE h4;
    hr = MQADQueryUserCert(
                NULL,   //pwcsDomainController,
				false,	// fServerName
                &blobUserSid,
                &columnsUsers,
                &h4
                );
    if (FAILED(hr))
    {
        printf("FAILURE: to query user cert, hr = %lx\n", hr);
    }
    PROPVARIANT resultUsers;
    DWORD numUsers = 1;

    resultUsers.vt = VT_NULL;
    needToFind = 1;

    while (SUCCEEDED( hr =  MQADQueryResults(h4, &numUsers, &resultUsers)))
    {
        if (numUsers == 0)
        {
            break;
        }
        if ((resultUsers.blob.cbSize == 200) &&
            (resultUsers.blob.pBlobData[0] == 'a'))
        {
            needToFind--;
        }
        delete []resultUsers.blob.pBlobData;
        resultUsers.vt = VT_NULL;
    }

    if (FAILED(hr))
    {
        printf("FAILURE : MQADQueryUserCert: query results hr = %lx \n",hr);

    }
    if (needToFind != 0)
    {
        printf("FAILURE : MQADQueryUserCert: not enough results\n");
    }

    hr = MQADEndQuery(h4);
    if (FAILED(hr))
    {
        printf("FAILURE : MQADQueryUserCert: end query hr = %lx \n",hr);

    }

    //
    //  delete the user object
    //
    hr = MQADDeleteObjectGuid(
            eUSER,
			NULL,       // pwcsDomainController
			false,	    // fServerName
            &guidCert
			);
    if (FAILED(hr))
    {
        printf(" FAILURE - to delete user, hr = %lx\n", hr);
    }


    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\mqadsmain.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    mqadsmain.cpp

Abstract:
    Dllmain for mqads.dll

Author:
    Ilan Herbst (ilanh) 6-Jul-2000

Environment:
    Platform-independent,

--*/

#include "ds_stdh.h"
#include "Ex.h"
#include "Cm.h"
#include "Tr.h"

#include "mqadsmain.tmh"

//-------------------------------------
//
//  DllMain
//
//-------------------------------------

BOOL WINAPI DllMain (HMODULE /* hMod */, DWORD fdwReason, LPVOID /* lpvReserved */)
{
    BOOL result = TRUE;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
			//
			// Initialize static library
			//
			CmInitialize(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MSMQ");
			TrInitialize();
			ExInitialize(1);

            WPP_INIT_TRACING(L"Microsoft\\MSMQ");
            break;
        }

        case DLL_THREAD_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            WPP_CLEANUP();
            break;

        case DLL_THREAD_DETACH:
            break;

    }
    return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\mqdsapi.cpp ===
/*++

Copyright (c) 1995-99  Microsoft Corporation

Module Name:

    mqdsapi.cpp

Abstract:

    Implementation of  MQDS API, ( of MQNT5 provider).

Author:

    ronit hartmann (ronith)
    Ilan Herbst    (ilanh)   9-July-2000

--*/

#include "ds_stdh.h"
#include "mqds.h"
#include "mqads.h"
#include "dsutils.h"
#include "notify.h"
#include "dsproto.h"
#include "dsglbobj.h"
#include "_secutil.h"
#include "dscore.h"
#include "mqsec.h"
#include "wrtreq.h"
#include "_rstrct.h"
#include "bupdate.h"
#include "_mqini.h"
#include <autoreln.h>
#include <_registr.h>
#include "servlist.h"
#include "mqadssec.h"

#include "mqdsapi.tmh"

static WCHAR *s_FN=L"mqads/mqdsapi";

//
// Binary enums, instead of BOOLs, to make code more readable.
//
enum enumNotify
{
    e_DoNotNotify = 0,
    e_DoNotify = 1
} ;

enum enumTryWriteReq
{
    e_DoNotTryWriteReq = 0,
    e_DoTryWriteReq = 1
} ;

//
// The following include is needed for the code that grant the "AddGuid"
// permission. See MQDSCreateObject().
//
#include <aclapi.h>


/*====================================================

RoutineName: CreateObjectInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
_CreateObjectInternal(
                 IN DWORD            dwObjectType,
                 IN LPCWSTR          pwcsPathName,
                 IN DWORD            cp,
                 IN PROPID           aProp[  ],
                 IN PROPVARIANT      apVar[  ],
                 IN DWORD            cpExIn,
                 IN PROPID           aPropExIn[ ],
                 IN PROPVARIANT      apVarEx[  ],
                 IN CDSRequestContext *         pRequestContext,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,    // optional request for object info
                 IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest) // optional request for parent info
{
    HRESULT hr;

    //
    // if we're creating a queue, and we're not prohibited from issuing a write request (like
    // when doing it on behalf of replication from NT4), check issuing a write request
    //
    if (dwObjectType == MQDS_QUEUE)
    {
        //
        // attempt to generate a write request if needed
        //
        BOOL fGeneratedWriteRequest;
        hr = g_GenWriteRequests.AttemptCreateQueue
                        (pwcsPathName,
                         cp,
                         aProp,
                         apVar,
                         pRequestContext,
                         &fGeneratedWriteRequest,
                         pObjInfoRequest,
                         pParentInfoRequest);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 10);
        }

        //
        // if generated write request, we're done
        //
        if (fGeneratedWriteRequest)
        {
            return MQ_OK;
        }
    }

    //
    // we didn't generate a write request.
    // Either we're not in mixed mode,  or the object is native,  not
    // "mastered" by an NT4 site.
    // We create the object on this server.
    // Let handle "default" security, if present. "Default" security is the
    // security descriptor of the object, as created by msmq, when it's not
    // specified by application. In that case, don't provide owner. Owner
    // will be added by the active directory code.
    //
    DWORD cpEx = cpExIn ;
    PROPID *aPropEx = aPropExIn ;

    if ((cpEx == 1) && (aPropEx[0] == PROPID_Q_DEFAULT_SECURITY))
    {
        for ( long j = (long) (cp - 1) ; j >= 0 ; j-- )
        {
            if ((aProp[j] == PROPID_Q_SECURITY) ||
                (aProp[j] == PROPID_S_SECURITY))
            {
                SECURITY_DESCRIPTOR_RELATIVE *pSD =
                   (SECURITY_DESCRIPTOR_RELATIVE *) apVar[j].blob.pBlobData ;
                //
                // Let's hack a little, to save time and effort.
                // Just reset the Owner offset.
                //
                ASSERT((pSD->Owner > 0) &&
                       (pSD->Owner < apVar[j].blob.cbSize)) ;

                pSD->Owner = 0 ;
                break ;
            }
        }
        ASSERT(j == (long) (cp-1)) ; // Q_SECURITY should be at index cp-1

        cpEx = 0 ;
        aPropEx = NULL ;
    }

    HRESULT hr2 = DSCoreCreateObject( dwObjectType,
                                      pwcsPathName,
                                      cp,
                                      aProp,
                                      apVar,
                                      cpEx,
                                      aPropEx,
                                      apVarEx,
                                      pRequestContext,
                                      pObjInfoRequest,
                                      pParentInfoRequest ) ;
    return LogHR(hr2, s_FN, 20);
}

/*====================================================

RoutineName: CreateObjectAndNotify
Creates an object, creates a notification when creating a queue.

Arguments:

Return Value:

=====================================================*/

HRESULT
_CreateObjectAndNotify(
                 IN  DWORD            dwObjectType,
                 IN  LPCWSTR          pwcsPathName,
                 IN  DWORD            cp,
                 IN  PROPID           aProp[  ],
                 IN  PROPVARIANT      apVar[  ],
                 IN  DWORD            cpEx,
                 IN  PROPID           aPropEx[  ],
                 IN  PROPVARIANT      apVarEx[  ],
                 IN  CDSRequestContext * pRequestContext,
                 OUT GUID*            pObjGuid)
{
    MQDS_OBJ_INFO_REQUEST sQueueInfoRequest, sQmInfoRequest ;
    CAutoCleanPropvarArray cCleanQueuePropvars, cCleanQmPropvars ;

    MQDS_OBJ_INFO_REQUEST sObjectInfoRequest;
    CAutoCleanPropvarArray cCleanObjectPropvars;

    MQDS_OBJ_INFO_REQUEST *pObjInfoRequest = NULL ;
    MQDS_OBJ_INFO_REQUEST *pParentInfoRequest = NULL ;
    HRESULT hr;

    ULONG idxQueueGuid = 0; //index of queue guid property in requested queue object info

    PROPID sLinkGuidProps[] = {PROPID_L_ID};
    PROPID sMachineGuidProps[] = {PROPID_QM_MACHINE_ID};
    ULONG  idxObjGuid = 0; //index of guid property in requested info.

    //
    // if object is a queue, we request notification properties back so we can
    // create a notification. The reason is that not all of its properties are
    // supplied as input to this function as they have default values in NT5 DS,
    // some are computed as well, so we specifically ask for needed properties
    // back.
    //
    // we also request properties from the parent (QM), specifically its guid
    // and if it is a foreign machine.
    //
    //
    // BUGBUG: we may do better, and ask only for queue properties that were not
    // supplied already to this function
    //
    if (dwObjectType == MQDS_QUEUE)
    {
        //
        // fill request info for object
        // make sure propvars are inited now, and destroyed at the end
        //
        sQueueInfoRequest.cProps = g_cNotifyCreateQueueProps;
        sQueueInfoRequest.pPropIDs = g_rgNotifyCreateQueueProps;
        sQueueInfoRequest.pPropVars = cCleanQueuePropvars.allocClean(g_cNotifyCreateQueueProps);
        idxQueueGuid = g_idxNotifyCreateQueueInstance;
        //
        // fill request info for parent
        // make sure propvars are inited now, and destroyed at the end
        //
        sQmInfoRequest.cProps = g_cNotifyQmProps;
        sQmInfoRequest.pPropIDs = g_rgNotifyQmProps;
        sQmInfoRequest.pPropVars = cCleanQmPropvars.allocClean(g_cNotifyQmProps);
        //
        // ask for queue info & QM info back
        //
        pObjInfoRequest = &sQueueInfoRequest;
        pParentInfoRequest = &sQmInfoRequest;
    }
    else if (pObjGuid != NULL)
    {
        if (dwObjectType == MQDS_SITELINK)
        {
            //
            // no notification needed, but still need to fill request info
            // for object (guid only)
            // make sure propvars are inited now, and destroyed at the end
            //
            sObjectInfoRequest.cProps = ARRAY_SIZE(sLinkGuidProps);
            sObjectInfoRequest.pPropIDs = sLinkGuidProps;
            sObjectInfoRequest.pPropVars =
               cCleanObjectPropvars.allocClean(ARRAY_SIZE(sLinkGuidProps));
            idxObjGuid = 0;
            //
            // ask for link info only back
            //
            pObjInfoRequest = &sObjectInfoRequest;
            pParentInfoRequest = NULL;
        }
        else if ((dwObjectType == MQDS_MACHINE) ||
                 (dwObjectType == MQDS_MSMQ10_MACHINE))
        {
            //
            // no notification needed, but still need to fill request info
            // for object (guid only)
            // make sure propvars are inited now, and destroyed at the end
            //
            sObjectInfoRequest.cProps = ARRAY_SIZE(sMachineGuidProps);
            sObjectInfoRequest.pPropIDs = sMachineGuidProps;
            sObjectInfoRequest.pPropVars =
              cCleanObjectPropvars.allocClean(ARRAY_SIZE(sMachineGuidProps));
            idxObjGuid = 0;
            //
            // ask for machine info only back
            //
            pObjInfoRequest = &sObjectInfoRequest;
            pParentInfoRequest = NULL;
        }
    }

    //
    // create the object
    //
    hr = _CreateObjectInternal( dwObjectType,
                                pwcsPathName,
                                cp,
                                aProp,
                                apVar,
                                cpEx,
                                aPropEx,
                                apVarEx,
                                pRequestContext,
                                pObjInfoRequest,
                                pParentInfoRequest ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }

    //
    // send notification if creating queue, ignore errors
    //
    if (dwObjectType == MQDS_QUEUE)
    {
        if (pObjGuid != NULL)
        {
            //
            //  The user requested for the queue's instance
            //  ( generated by the DS)
            //

            //
            //  If failed to retrieve the queue's instance,
            //  an error must be returned to the caller.
            //  The reason is that MQCreateQueue() checks only
            //  for error before preparing the queue-format
            //
            hr = RetreiveQueueInstanceFromNotificationInfo(
                           &sQueueInfoRequest,
                           idxQueueGuid,
                           pObjGuid);
        }

        ASSERT(pwcsPathName);
        HRESULT hrTmp;
        hrTmp = NotifyCreateQueue(&sQueueInfoRequest,
                                  &sQmInfoRequest,
                                  pwcsPathName);
        if (FAILED(hrTmp))
        {
            //
            // put debug info and ignore
            //
            DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
              "CreateObjectAndNotify:NotifyCreateQueue()= %lx, can't notify queue %ls creation, ignoring..."),
                                               hrTmp, pwcsPathName));
            LogHR(hrTmp, s_FN, 1900);
        }
    }
    else if (pObjGuid != NULL)
    {
        if ((dwObjectType == MQDS_SITELINK) ||
            (dwObjectType == MQDS_MACHINE)  ||
            (dwObjectType == MQDS_MSMQ10_MACHINE))
        {
            //
            //  The user requested for the link's instance
            //  ( generated by the DS)
            //

            hr = RetreiveObjectIdFromNotificationInfo(
                           &sObjectInfoRequest,
                           idxObjGuid,
                           pObjGuid);
            LogHR(hr, s_FN, 1910);
        }
    }

    return LogHR(hr, s_FN, 40);
}

/*====================================================

RoutineName: MQDSCreateObject

Arguments:

Return Value:

=====================================================*/

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSCreateObject( 
	IN  DWORD             dwObjectType,
	IN  LPCWSTR           pwcsPathName,
	IN  DWORD             cpIn,
	IN  PROPID            aPropIn[  ],
	IN  PROPVARIANT       apVarIn[  ],
	IN  DWORD             cpEx,
	IN  PROPID            aPropEx[  ],
	IN  PROPVARIANT       apVarEx[  ],
	IN  CDSRequestContext *  pRequestContext,
	OUT GUID*             pObjGuid 
	)
{
    if (dwObjectType == MQDS_USER)
    {
        //
        // Only client code call this routine, so make sure it impersonates.
        //
        ASSERT(pRequestContext->NeedToImpersonate());
    }

    DWORD  dwObjectTypeForCreate = dwObjectType;
    CAutoLocalFreePtr pAutoRelSD = NULL;
    bool           fNeedAddGuid = false;
    HRESULT        hr;

    CDSRequestContext RequestContext = *pRequestContext;

    DWORD cpCore = cpIn;
    PROPID*	pPropCore = aPropIn;
    PROPVARIANT* apVarCore = apVarIn;

    AP<PROPID> aPropIdCleanup  = NULL;
    AP<PROPVARIANT> aPropVarCleanup = NULL;
    AP<BYTE> pOwnerSid = NULL;

    if (dwObjectType == MQDS_MACHINE)
    {
        //
        // We're creating a machine object.
        // RTM: Check if we have to grant the "AddGuid" Permission to caller.
        // Code changed, and instead of granting "AddGuid" to user,
        // the msmq service will perform the access check and then call
        // active directory without impersonation. This will always succeed
        // on local domain. In all cases, we have
        // problems cross domains, as local system service on domain
        // controller is just another authenticated user on other domains.
        // bug 6294.
        //
        // This scenario happen when setting up a MSMQ1.0 machine.
        // MSMQ1.0 setup code generate the guid for the machine
        // object and it also keep this guid in local registry on
        // that machine. So we must create the mSMQConfiguration
        // object with this guid.
        //
        // This scenario require that caller supply PROPID_QM_MACHINE_ID (the
        // object guid).
        //

        bool fFromWorkgroup = false;

        for (DWORD j = 0; j < cpIn; j++)
        {
            if (aPropIn[j] == PROPID_QM_MACHINE_ID)
            {
                dwObjectTypeForCreate = MQDS_MSMQ10_MACHINE;
                fNeedAddGuid = true;
                break ;
            }
            else if (aPropIn[j] == PROPID_QM_WORKGROUP_ID)
            {
                //
                // that's a Windows 2000 workgroup machine that join domain.
                // Create the object with a predefined GUID (as we do for
                // NT4/Win9x setup), but keep default security of Win2000
                // machine (i.e, everyone can not create queues).
                //
                fNeedAddGuid = true;
                fFromWorkgroup = true;
                break;
            }
        }

        if (fNeedAddGuid)
        {
            //
            // Read the security descriptor of the computer object and see
            // if caller has permission to create the msmqConfiguration
            // object. if he doesn't, fail right now.
            //
            // Assert that we need to impersonate...
            //
            ASSERT(pRequestContext->NeedToImpersonate());

            bool fComputerExist = true;
            hr = CanUserCreateConfigObject( 
						pwcsPathName,
						&fComputerExist 
						);

            if (FAILED(hr))
            {
                DBGMSG((DBGMOD_DS, DBGLVL_WARNING, TEXT("DSCreateObject(), cannot create msmqConfiguration, hr- %lxh"), hr));

                return LogHR(hr, s_FN, 69);
            }

            //
            // User has the permission to create the msmqConfiguration
            // object. So create it under context of LocalSystem msmq service
            // and do not impersonate client.
            // Add the PROPID_QM_OWNER_SID property, so user get full control
            // permission on the msmqConfiguration object.
            // Don't add this one when msmq2 join domain. not necessary.
            //
            bool fPropFound = false;

            if (fFromWorkgroup)
            {
                fPropFound = true; // dummy, for next "if"
            }
            else
            {
                for (DWORD k = 0; k < cpIn; k++)
                {
                    if (aPropIn[k] == PROPID_QM_OWNER_SID)
                    {
                        fPropFound = true;
                        break;
                    }
                }
            }

            if (!fPropFound)
            {
                DWORD dwSidLen = 0;
                hr =  MQSec_GetThreadUserSid(
							true,
							reinterpret_cast<PSID*>(&pOwnerSid),
							&dwSidLen 
							);

                if (FAILED(hr))
                {
                    ASSERT(SUCCEEDED(hr));
                    LogHR(hr, s_FN, 71);
                }
                else
                {
                    ASSERT(dwSidLen > 0);
                    //
                    // Allocate new array of props and propvariants.
                    //
                    cpCore = cpIn + 1;

                    pPropCore = new PROPID[cpCore];
                    aPropIdCleanup = pPropCore;

                    apVarCore = new PROPVARIANT[cpCore];
                    aPropVarCleanup = apVarCore;

                    memcpy(apVarCore, apVarIn, (sizeof(PROPVARIANT) * cpIn));
                    memcpy(pPropCore, aPropIn, (sizeof(PROPID) * cpIn));

                    pPropCore[cpIn] = PROPID_QM_OWNER_SID;
                    apVarCore[cpIn].vt = VT_BLOB;
                    apVarCore[cpIn].blob.pBlobData = (PBYTE) pOwnerSid;
                    apVarCore[cpIn].blob.cbSize = dwSidLen;
                }
            }

            if (fComputerExist)
            {
                //
                // If computer object exist, then do not impersonate
                // the creation of msmqConfiguration.
                // Otherwise, impersonate and create the comptuer
                // object. If computer is created ok, then dscore
                // code will not impersonate the creation of
                // msmqConfiguration.
                //
                RequestContext.SetDoNotImpersonate();
            }
        }
    }

    hr = _CreateObjectAndNotify( 
				dwObjectTypeForCreate,
				pwcsPathName,
				cpCore,
				pPropCore,
				apVarCore,
				cpEx,
				aPropEx,
				apVarEx,
				&RequestContext,
				pObjGuid 
				);

    if (fNeedAddGuid)
    {
		if(hr == HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM))
		{
			//
			// Add Guid permission can be granted only on GC.
			// if this DC is not a GC you will get this error.
			//
			static bool fReportEvent = true;
			if(fReportEvent)
			{
				//
				// Report this event once only, in order not to fill the event log in case
				// of setup or join domain retries by down level client
				//
	            REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_MQDS, EVENT_MQDS_GC_NEEDED, 1, pwcsPathName));
				fReportEvent = false;
			}
			hr = MQ_ERROR_GC_NEEDED;
		}

    }

    return LogHR(hr, s_FN, 70);
}

/*====================================================

RoutineName: DeleteObjectInternal

Arguments:

Return Value:

=====================================================*/
STATIC
HRESULT
DeleteObjectInternal(
                     IN     DWORD                   dwObjectType,
                     IN     LPCWSTR                 pwcsPathName,
                     IN     const GUID *            pguidIdentifier,
                     IN     CDSRequestContext *     pRequestContext,
                     IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest)
{
    HRESULT hr;

    //
    // if we're deleteing a queue/machine, and we're not prohibited from issuing a write request (like
    // when doing it on behalf of replication from NT4), check issuing a write request
    //
    if ((dwObjectType == MQDS_QUEUE) || (dwObjectType == MQDS_MACHINE))
    {
        //
        // attempt to generate a write request if needed
        //
        BOOL fGeneratedWriteRequest;
        hr = g_GenWriteRequests.AttemptDeleteObject
                        (dwObjectType,
                         pwcsPathName,
                         pguidIdentifier,
                         pRequestContext,
                         &fGeneratedWriteRequest,
                         pParentInfoRequest);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 80);
        }

        //
        // if generated write request, we're done
        //
        if (fGeneratedWriteRequest)
        {
            return MQ_OK;
        }
    }

    //
    // we didn't generate a write request
    // either we're not in mixed mode, or not allowed to (in replication),
    // or the object is just not mastered by an NT4 site
    //
    // we delete the object on this server
    //
    //
    // delete the object
    //
    HRESULT hr2 = DSCoreDeleteObject(dwObjectType,
                              pwcsPathName,
                              pguidIdentifier,
                              pRequestContext,
                              pParentInfoRequest);
    return LogHR(hr2, s_FN, 90);
}

/*====================================================

RoutineName: DeleteObjectAndNotify
Deletes object, creates a notification when deleting a queue.

Arguments:

Return Value:

=====================================================*/

STATIC HRESULT
DeleteObjectAndNotify(
                      IN DWORD              dwObjectType,
                      IN LPCWSTR            pwcsPathName,
                      IN const GUID *       pguidIdentifier,
                      IN CDSRequestContext *   pRequestContext
                      )
{
    MQDS_OBJ_INFO_REQUEST sQmInfoRequest;
    CAutoCleanPropvarArray cCleanQmPropvars;
    MQDS_OBJ_INFO_REQUEST *pParentInfoRequest;
    HRESULT hr;
    //
    // if object is a queue, we request from the parent (QM), specifically its guid
    // and if it is a foreign machine.
    //
    if (dwObjectType == MQDS_QUEUE)
    {
        //
        // fill request info for parent
        // make sure propvars are inited now, and destroyed at the end
        //
        sQmInfoRequest.cProps = g_cNotifyQmProps;
        sQmInfoRequest.pPropIDs = g_rgNotifyQmProps;
        sQmInfoRequest.pPropVars = cCleanQmPropvars.allocClean(g_cNotifyQmProps);
        //
        // ask for QM info back
        //
        pParentInfoRequest = &sQmInfoRequest;
    }
    else
    {
        //
        // object is not a queue, no need for parent info back
        //
        pParentInfoRequest = NULL;
    }

    //
    // delete the object
    //
    hr = DeleteObjectInternal(dwObjectType,
                              pwcsPathName,
                              pguidIdentifier,
                              pRequestContext,
                              pParentInfoRequest);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100);
    }

    //
    // send notification if deleting queue, ignore errors
    //
    if (dwObjectType == MQDS_QUEUE)
    {
        HRESULT hrTmp;
        hrTmp = NotifyDeleteQueue(&sQmInfoRequest,
                                  pwcsPathName,
                                  pguidIdentifier);
        if (FAILED(hrTmp))
        {
            //
            // put debug info and ignore
            //
            DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
             "DeleteObjectAndNotify:NotifyDeleteQueue()=%lx, can't notify. queue %ls deletion, ignoring..."),
             hrTmp, (pwcsPathName ? pwcsPathName : L"<guid>")));
            LogHR(hrTmp, s_FN, 1995);
        }
    }

    return MQ_OK;
}

/*====================================================

RoutineName: MQDSDeleteObject

Arguments:

Return Value:

=====================================================*/

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSDeleteObject( DWORD             dwObjectType,
                  LPCWSTR           pwcsPathName,
                  CONST GUID *      pguidIdentifier,
                  CDSRequestContext *  pRequestContext
                  )
{

    HRESULT hr = DeleteObjectAndNotify( dwObjectType,
                                        pwcsPathName,
                                        pguidIdentifier,
                                        pRequestContext);
    return LogHR(hr, s_FN, 110);
}

/*====================================================

RoutineName: MQDSGetProps

Arguments:

Return Value:

=====================================================*/
HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSGetProps(
             IN  DWORD dwObjectType,
             IN  LPCWSTR pwcsPathName,
             IN  CONST GUID *  pguidIdentifier,
             IN  DWORD cp,
             IN  PROPID  aProp[  ],
             OUT PROPVARIANT  apVar[  ],
             IN  CDSRequestContext *  pRequestContext
             )
{
    HRESULT hr;

    hr = DSCoreGetProps(
                        dwObjectType,
                        pwcsPathName,
                        pguidIdentifier,
                        cp,
                        aProp,
                        pRequestContext,
                        apVar);
    return LogHR(hr, s_FN, 120);

}


/*====================================================

RoutineName: CheckSetProps
Checks if setting invalid objects or props

Arguments:

Return Value:

=====================================================*/
STATIC
HRESULT
CheckSetProps(          DWORD dwObjectType,
                        DWORD cp,
                        PROPID  aProp[  ])
{
    switch ( dwObjectType)
    {

        case MQDS_USER:
            //
            // It is not possible to change the user settings.
            //
            ASSERT(0);
            return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 130);
            break;

        case MQDS_CN:
            //
            //  Not supposed to be called, except from MSMQ 1.0 explorer
            //  which allows to rename a CN or to change properties. This
            //  functionality is not supported!!!
            //  One feature is supported- changing the security descriptor
            //  of foreign sites.
            //
            if ((cp != 1) || (aProp[0] != PROPID_CN_SECURITY))
            {
                return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 140);
            }
            break;

        case MQDS_MACHINE:
            {
                //
                //  We allow to change PROPID_S_SERVICE
                //  from SERVICE_SRV to SERVICE_PEC and vice versa
                //  ( in order to support dcpromom/dcunpromo)
                //

                for ( DWORD i = 0; i < cp; i++)
                {
                    if ( aProp[i] == PROPID_QM_SERVICE)   // [adsrv] TBD: can this be called from old machines?
                    {
                        if ( aProp[i] < SERVICE_SRV)  //[adsrv] keeping, although it seems to be wrong: TBD
                        {
                            return LogHR(MQ_ERROR, s_FN, 150);
                        }
                    }
                    else if (aProp[i] == PROPID_QM_SERVICE_ROUTING)
                    {
                        return LogHR(MQ_ERROR, s_FN, 160);
                    }
                    // TBD [adsrv] Do we want to permit change of DepClients ?
                }
            }
            break;

        default:
            break;
    }

    return MQ_OK;
}

/*======================================================================

RoutineName: SetPropsInternal

Description: Set the object properties, either in NT5 DS or by sending
             write request to an NT4 master.

Input Parameters:
    enum  eTryWriteRequest - Usually it's TRUE, and we first check if write
            request to NT4 MSMQ1.0 master is needed. If write request is not
            needed then we write directly to NT5 DS. One exception is when
            a NT4 PSC try to renew its crypto key. The NT4 PSC first write
            its new key to the site object, by calling the PEC. In NT5, site
            objects do not have this attribure. So the PEC (which is NT5)
            write the key directly into the PSC machine object. Normally,
            such a write would trigger a write request (the NT4 PSC site is
            the owner of the PSC machine). But in that case,
            eTryWriteRequest is FALSE and we update the NT5 DS.

Return Value:

=======================================================================*/

STATIC
HRESULT
SetPropsInternal(
                 IN  DWORD                   dwObjectType,
                 IN  LPCWSTR                 pwcsPathName,
                 IN  CONST GUID *            pguidIdentifier,
                 IN  DWORD                   cp,
                 IN  PROPID                  aProp[  ],
                 IN  PROPVARIANT             apVar[  ],
                 IN  enumTryWriteReq         eTryWriteRequest,
                 IN  SECURITY_INFORMATION    SecurityInformation,
                 IN  CDSRequestContext *     pRequestContext,
                 OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest
                 )
{
    HRESULT hr;

    //
    // if we're setting a queue/machine, and we're not prohibited from issuing a write request (like
    // when doing it on behalf of replication from NT4), check issuing a write request
    //
    if ((eTryWriteRequest == e_DoTryWriteReq) &&
         ((dwObjectType == MQDS_QUEUE) || (dwObjectType == MQDS_MACHINE)) )
    {
        //
        // attempt to generate a write request if needed
        //
        BOOL fGeneratedWriteRequest;
        hr = g_GenWriteRequests.AttemptSetObjectProps(
                         dwObjectType,
                         pwcsPathName,
                         pguidIdentifier,
                         cp,
                         aProp,
                         apVar,
                         pRequestContext,
                         &fGeneratedWriteRequest,
                         pObjInfoRequest,
                         SecurityInformation);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 170);
        }

        //
        // if generated write request, we're done
        //
        if (fGeneratedWriteRequest)
        {
            return MQ_OK;
        }
    }

    PROPID       *pPropId = aProp ;
    PROPVARIANT  *pPropVar = apVar ;

    PROPID       aPropSecId[2] ;
    PROPVARIANT  aPropSecVar[2] ;

    if (SecurityInformation != 0)
    {
        //
        // we're setting security. pass the SecurityInformation as
        // a property.
        //
        ASSERT(cp == 1) ;

        aPropSecId[0] = aProp[0] ;
        aPropSecVar[0] = apVar[0] ;

        if (aPropSecId[0] == PROPID_Q_SECURITY)
        {
            aPropSecId[1] = PROPID_Q_SECURITY_INFORMATION ;
        }
        else
        {
            ASSERT((aPropSecId[0] == PROPID_QM_SECURITY) ||
                   (aPropSecId[0] == PROPID_CN_SECURITY)) ;
            aPropSecId[1] = PROPID_QM_SECURITY_INFORMATION ;
        }

        aPropSecVar[1].vt = VT_UI4 ;
        aPropSecVar[1].ulVal = SecurityInformation ;

        cp = 2 ;
        pPropId = aPropSecId ;
        pPropVar = aPropSecVar ;
    }
    else
    {
#ifdef _DEBUG
        //
        // When setting security descriptor, we get only one property- the
        // descriptor. Present code does not set security when setting
        // other properties.
        //
        for ( DWORD j = 0 ; j < cp ; j++ )
        {
            ASSERT(pPropId[j] != PROPID_Q_SECURITY) ;
            ASSERT(pPropId[j] != PROPID_QM_SECURITY) ;
        }
#endif
    }

    //
    // we didn't generate a write request
    // either we're not in mixed mode, or not allowed to (in replication),
    // or the object is just not mastered by an NT4 site
    //
    // we set the object props on this server
    //
    HRESULT hr2 = DSCoreSetObjectProperties(
                        dwObjectType,
                        pwcsPathName,
                        pguidIdentifier,
                        cp,
                        pPropId,
                        pPropVar,
                        pRequestContext,
                        pObjInfoRequest
                        );
    return LogHR(hr2, s_FN, 180);
}

/*====================================================

RoutineName: SetSpecialMachineProperties
Sets PROPID_QM_QUOTA instead of the PROPID_QM_ADDRESS and/or PROPID_QM_CNS,
creates a notification when setting QM.

PROPID_QM_ADDRESS and PROPID_QM_CNS are not saved in DS, in order to replicate address
changes we have to change something for machine in DS.

Arguments:

Return Value:

=====================================================*/
#define DUMMY_QM_DESCRIPTION  L"MSMQ"

STATIC HRESULT
SetSpecialMachineProperties(
                              IN  DWORD                 dwObjectType,
                              IN  LPCWSTR               pwcsPathName,
                              IN  const GUID *          pguidIdentifier,
                              IN  enumTryWriteReq       eTryWriteRequest,// = e_DoTryWriteReq,
                              IN  CDSRequestContext *   pRequestContext,
                              IN  SECURITY_INFORMATION  SecurityInformation,
                              OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest
                              )
{
    //
    // get current value of Description from DS
    //
    PROPID DescProp = PROPID_QM_DESCRIPTION;
    PROPVARIANT DescVar;
    DescVar.vt = VT_NULL ;
    DescVar.pwszVal = NULL ;

    HRESULT hr = MQDSGetProps(
                    dwObjectType,
                    pwcsPathName,
                    pguidIdentifier,
                    1,
                    &DescProp,
                    &DescVar,
                    pRequestContext
                    ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 190);
    }

    ASSERT (DescVar.vt == VT_LPWSTR);

    PROPVARIANT tmpVar;
    tmpVar.vt = VT_LPWSTR;
    tmpVar.pwszVal = DUMMY_QM_DESCRIPTION;

    hr = SetPropsInternal( dwObjectType,
                           pwcsPathName,
                           pguidIdentifier,
                           1,
                           &DescProp,
                           &tmpVar,
                           eTryWriteRequest,
                           SecurityInformation,
                           pRequestContext,
                           pObjInfoRequest
                           );

    hr = SetPropsInternal( dwObjectType,
                           pwcsPathName,
                           pguidIdentifier,
                           1,
                           &DescProp,
                           &DescVar,
                           eTryWriteRequest,
                           SecurityInformation,
                           pRequestContext,
                           pObjInfoRequest
                           );

    if (DescVar.pwszVal != NULL)
    {
        delete DescVar.pwszVal;
    }

    return LogHR(hr, s_FN, 200);
}

/*====================================================

RoutineName: SetPropsAndNotify
Sets props, creates a notification when setting QM or queue props.

Arguments:

Return Value:

=====================================================*/

STATIC HRESULT
SetPropsAndNotify(
                  IN  DWORD                 dwObjectType,
                  IN  LPCWSTR               pwcsPathName,
                  IN  const GUID *          pguidIdentifier,
                  IN  DWORD                 cp,
                  IN  PROPID                aProp[  ],
                  IN  PROPVARIANT           apVar[  ],
                  IN  enumNotify            eNotify,
                  IN  enumTryWriteReq       eTryWriteRequest,// = e_DoTryWriteReq,
                  IN  CDSRequestContext *   pRequestContext,
                  IN  SECURITY_INFORMATION  SecurityInformation )
{
    HRESULT hr;

    //
    // check if setting invalid objects or prop ids
    //
    hr = CheckSetProps(dwObjectType, cp, aProp);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 210);
    }

    //
    // prepare for notification on set props
    //
    ULONG cObjRequestProps;
    AP<PROPID> rgObjRequestPropIDs;
    ULONG cNotifyProps = 0;
    AP<PROPID> rgNotifyPropIDs;
    AP<MQDS_NotifyTable> rgNotifyPropTbl;
    MQDS_OBJ_INFO_REQUEST *pObjInfoRequest = NULL; //default - dont ask for obj info back
    BOOL fDoNotification = FALSE ;                 //default - don't notify.
    MQDS_OBJ_INFO_REQUEST sObjInfoRequest;
    CAutoCleanPropvarArray cCleanObjPropvars;

    //
    // if we need to do notification handling
    //
    if ((eNotify == e_DoNotify) &&
        ((dwObjectType == MQDS_QUEUE) || (dwObjectType == MQDS_MACHINE)))
    {
        //
        // get obj props to request from the DS upon setting, and information
        // on the notification props
        //
        HRESULT hrTmp;
        hrTmp = GetNotifyUpdateObjProps(dwObjectType,
                                        cp,
                                        aProp,
                                        &cObjRequestProps,
                                        &rgObjRequestPropIDs,
                                        &cNotifyProps,
                                        &rgNotifyPropIDs,
                                        &rgNotifyPropTbl);
        if (FAILED(hrTmp))
        {
            //
            // dont return an error on notification handling failure
            // just put debug info and mark that notification failed
            //
            DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
                "SetPropsAndNotify:GetNotifyUpdateObjProps()=%lx"), hrTmp)) ;
            LogHR(hrTmp, s_FN, 1990);
        }
        else
        {
            //
            // we got the notification props and the request props
            // fill request info for object
            // make sure propvars are inited now, and destroyed at the end
            //
            sObjInfoRequest.cProps = cObjRequestProps;
            sObjInfoRequest.pPropIDs = rgObjRequestPropIDs;
            sObjInfoRequest.pPropVars = cCleanObjPropvars.allocClean(cObjRequestProps);
            //
            // ask for obj info back
            //
            pObjInfoRequest = &sObjInfoRequest;
            //
            // mark to continue with notification
            //
            fDoNotification = TRUE;
        }
    }

    BOOL fSpecialCase = FALSE;
    if (dwObjectType == MQDS_MACHINE && cp <=2)
    {
        fSpecialCase =
            ((cp == 2) && ( aProp[0] == PROPID_QM_ADDRESS) && ( aProp[1] == PROPID_QM_CNS)) ||
            ((cp == 1) && ( aProp[0] == PROPID_QM_ADDRESS)) ;

    }

    if (fSpecialCase && g_GenWriteRequests.IsInMixedMode())
    {
        //
        // we are here if we are in mixed mode AND CNs and/ or addresses
        // were changes. In that case we need to change something,
        // i.e. Quota, for replication purposes.
        //
        hr = SetSpecialMachineProperties(  dwObjectType,
                                           pwcsPathName,
                                           pguidIdentifier,
                                           eTryWriteRequest,
                                           pRequestContext,
                                           SecurityInformation,
                                           pObjInfoRequest
                                           );

        //
        // we'll return OK anyway, so this address change will not be replicated
        // but everything will continue as usual
        //
		if ( FAILED(hr))
		{
			return MQ_OK;
		}

    }
    else
    {
        hr = SetPropsInternal( dwObjectType,
                               pwcsPathName,
                               pguidIdentifier,
                               cp,
                               aProp,
                               apVar,
                               eTryWriteRequest,
                               SecurityInformation,
                               pRequestContext,
                               pObjInfoRequest
                               );
    }

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 220);
    }

    //
    // if we need to do notification handling
    //
    if (fDoNotification)
    {
        HRESULT hrTmp;
        //
        // send notification, ignore errors
        //
        hrTmp = NotifyUpdateObj(dwObjectType,
                                &sObjInfoRequest,
                                pwcsPathName,
                                pguidIdentifier,
                                cp,
                                aProp,
                                apVar,
                                cNotifyProps,
                                rgNotifyPropIDs,
                                rgNotifyPropTbl);
        if (FAILED(hrTmp))
        {
            //
            // put debug info and ignore
            //
            DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
             "SetPropsAndNotify:NotifyUpdateObj()=%lx, can't notify- objtype %ld name %ls update, ignoring..."),
             hrTmp, dwObjectType, (pwcsPathName ? pwcsPathName : L"<guid>")));
            LogHR(hrTmp, s_FN, 1980);
        }
    }

    return MQ_OK;
}


/*====================================================

RoutineName: MQDSSetProps

Arguments:

Return Value:

=====================================================*/

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSSetProps( DWORD             dwObjectType,
              LPCWSTR           pwcsPathName,
              CONST GUID *      pguidIdentifier,
              DWORD             cp,
              PROPID            aProp[  ],
              PROPVARIANT       apVar[  ],
              CDSRequestContext * pRequestContext
              )
{
    if (!pRequestContext->NeedToImpersonate())
    {
        //
        // Only client code call this routine, so make sure it impersonate.
        // BUGBUG- users object are not impersonating at present.
        //
        if (!g_fMQADSSetupMode)
        {
            ASSERT(dwObjectType == MQDS_USER || dwObjectType == MQDS_MACHINE) ;
        }
    }

    HRESULT hr;

    hr = SetPropsAndNotify(
                    dwObjectType,
                    pwcsPathName,
                    pguidIdentifier,
                    cp,
                    aProp,
                    apVar,
                    e_DoNotify,
                    e_DoTryWriteReq,
                    pRequestContext,
                    0);  //SecurityInformation
    return LogHR(hr, s_FN, 230);
}

/*====================================================

RoutineName: MQDSGetObjectSecurity

Arguments:

Return Value:

=====================================================*/

HRESULT
MQDS_EXPORT
APIENTRY
MQDSGetObjectSecurity(
    DWORD                   dwObjectType,
    LPCWSTR                 pwcsPathName,
    CONST GUID *            pguidIdentifier,
    SECURITY_INFORMATION    RequestedInformation,
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    DWORD                   nLength,
    LPDWORD                 lpnLengthNeeded,
    CDSRequestContext *     pRequestContext
    )
{
    HRESULT hr ;

    if (RequestedInformation & (MQDS_KEYX_PUBLIC_KEY | MQDS_SIGN_PUBLIC_KEY))
    {
        if (((dwObjectType != MQDS_MACHINE) && (dwObjectType != MQDS_SITE)) ||
            ((dwObjectType == MQDS_SITE) && (RequestedInformation & MQDS_KEYX_PUBLIC_KEY)))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 240);
        }


        PROPID PropId;

        if (RequestedInformation & MQDS_KEYX_PUBLIC_KEY)
        {
            PropId = PROPID_QM_ENCRYPT_PK;
        }
        else if (dwObjectType == MQDS_MACHINE)
        {
            PropId = PROPID_QM_SIGN_PK ;
        }
        else
        {
            PropId = PROPID_S_PSC_SIGNPK ;
        }

        PROPVARIANT PropVar;

        PropVar.vt = VT_NULL;

        hr = DSCoreGetProps( dwObjectType,
                             pwcsPathName,
                             pguidIdentifier,
                             1,
                             &PropId,
                             pRequestContext,
                             &PropVar ) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 250);
        }
        if (PropVar.blob.pBlobData == NULL)
        {
            *lpnLengthNeeded = 0 ;
            return MQ_OK ;
        }

        //
        // unpack the key. We're called from MSMQ1.0 machine so retrieve
        // the base provider key.
        //
        P<MQDSPUBLICKEYS> pPublicKeys =
                              (MQDSPUBLICKEYS *) PropVar.blob.pBlobData ;
        BYTE   *pKey = NULL ;
        ULONG   ulKeyLen = 0 ;

        ASSERT(pPublicKeys->ulLen == PropVar.blob.cbSize);

        hr =  MQSec_UnpackPublicKey( pPublicKeys,
                                     x_MQ_Encryption_Provider_40,
                                     x_MQ_Encryption_Provider_Type_40,
                                    &pKey,
                                    &ulKeyLen ) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 260);
        }

        *lpnLengthNeeded = ulKeyLen ;

        if (*lpnLengthNeeded <= nLength)
        {
            memcpy(pSecurityDescriptor, pKey, *lpnLengthNeeded);
        }
        else
        {
            return LogHR(MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL, s_FN, 270);
        }
    }
    else
    {
        DWORD       dwSecIndex = 0 ;
        DWORD       cProps = 1 ;
        PROPID      aPropId[2] ;
        PROPVARIANT aPropVar[2] ;

        aPropVar[0].vt = VT_NULL;
        DWORD dwInternalObjectType = dwObjectType;

        if (dwObjectType == MQDS_QUEUE)
        {
            aPropId[ dwSecIndex ] = PROPID_Q_SECURITY;

            aPropId[1] = PROPID_Q_SECURITY_INFORMATION ;
            aPropVar[1].vt = VT_UI4 ;
            aPropVar[1].ulVal = RequestedInformation ;

            cProps = 2 ;
        }
        else if (dwObjectType == MQDS_MACHINE)
        {
            aPropId[ dwSecIndex ] = PROPID_QM_SECURITY;

            aPropId[1] = PROPID_QM_SECURITY_INFORMATION ;
            aPropVar[1].vt = VT_UI4 ;
            aPropVar[1].ulVal = RequestedInformation ;

            cProps = 2 ;
        }
        else
        {
            switch( dwObjectType)
            {
            case MQDS_SITE:
                aPropId[ dwSecIndex ] = PROPID_S_SECURITY;
                dwInternalObjectType = MQDS_SITE;
                break;

            case MQDS_CN:
                //
                // CN are "represented" by sites, so read the site security.
                // Request the FOREIGN property too, to know how
                // to convert the security descriptor.
                // Make the "foreign" property first, so it's fetch before
                // the security property. When converting security
                // descriptor, we should already know if it's a foreign
                // site.
                //
                aPropId[0] = PROPID_S_FOREIGN ;
                aPropVar[0].vt = VT_NULL ;
                dwSecIndex = 1 ;
                aPropId[ dwSecIndex ] = PROPID_S_SECURITY ;
                aPropVar[ dwSecIndex ].vt = VT_NULL ;
                cProps = 2 ;
                dwInternalObjectType = MQDS_SITE;
                break;

            case MQDS_ENTERPRISE:
                aPropId[ dwSecIndex ] = PROPID_E_SECURITY;
                break;

            default:
                 ASSERT(0);
                 break;
            }
        }

        hr = DSCoreGetProps( dwInternalObjectType,
                             pwcsPathName,
                             pguidIdentifier,
                             cProps,
                             aPropId,
                             pRequestContext,
                             aPropVar ) ;
        if ( FAILED(hr))
        {
            return LogHR(hr, s_FN, 280);
        }

        //
        // Just to make sure this is released.
        //
        P<BYTE> pBlob = aPropVar[ dwSecIndex ].blob.pBlobData;
        *lpnLengthNeeded = aPropVar[ dwSecIndex ].blob.cbSize;

        if ( *lpnLengthNeeded <= nLength )
        {
            //
            //  Copy the buffer
            //
            memcpy( pSecurityDescriptor,
                    aPropVar[ dwSecIndex ].blob.pBlobData,
                   *lpnLengthNeeded ) ;
            return LogHR(hr, s_FN, 290);
        }
        else
        {
            return LogHR(MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL, s_FN, 300);
        }
    }
    return(MQ_OK);
}

/*====================================================

RoutineName: MQDSSetObjectSecurity

Arguments:

Return Value:

=====================================================*/

HRESULT
MQDS_EXPORT
APIENTRY
MQDSSetObjectSecurity(
    DWORD                   dwObjectType,
    LPCWSTR                 pwcsPathName,
    CONST GUID *            pguidIdentifier,
    SECURITY_INFORMATION    SecurityInformation,
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    CDSRequestContext *     pRequestContext
    )
{


    if (SecurityInformation & (MQDS_KEYX_PUBLIC_KEY | MQDS_SIGN_PUBLIC_KEY))
    {
        ASSERT((SecurityInformation & (OWNER_SECURITY_INFORMATION |
                                       GROUP_SECURITY_INFORMATION |
                                       DACL_SECURITY_INFORMATION  |
                                       SACL_SECURITY_INFORMATION)) == 0) ;
        HRESULT hr ;

        if (((dwObjectType != MQDS_MACHINE) && (dwObjectType != MQDS_SITE)) ||
            ((dwObjectType == MQDS_SITE) && (SecurityInformation & MQDS_KEYX_PUBLIC_KEY)))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 310);
        }


        PROPID PropId;
        PROPVARIANT PropVar;
        PropVar.vt = VT_BLOB;
        PMQDS_PublicKey pPbKey = (PMQDS_PublicKey)pSecurityDescriptor;
        P<MQDSPUBLICKEYS> pPublicKeys = NULL ;

        if (SecurityInformation & MQDS_KEYX_PUBLIC_KEY)
        {
            PropId = PROPID_QM_ENCRYPT_PK;

        }
        else if (dwObjectType == MQDS_MACHINE)
        {
            PropId = PROPID_QM_SIGN_PK ;
        }
        else
        {
            PropId = PROPID_S_PSC_SIGNPK ;
        }

        //
        // Called by MSMQ1.0 machine.
        // Pack single key, 40 bits provider.
        //
        hr = MQSec_PackPublicKey( (BYTE*)pPbKey->abPublicKeyBlob,
                                  pPbKey->dwPublikKeyBlobSize,
                                  x_MQ_Encryption_Provider_40,
                                  x_MQ_Encryption_Provider_Type_40,
                                 &pPublicKeys ) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 320);
        }

        MQDSPUBLICKEYS *pTmp = pPublicKeys ;
        PropVar.blob.pBlobData = (BYTE*) pTmp ;
        PropVar.blob.cbSize = 0 ;
        if (pPublicKeys)
        {
            PropVar.blob.cbSize = pPublicKeys->ulLen ;
        }

        P<WCHAR> pwszServerName = NULL ;
        const WCHAR     *pwszSiteName = NULL ;
        BOOL             fTouchSite = FALSE ;
        enumNotify       eNotify = e_DoNotify ;
        enumTryWriteReq  eTryWriteRequest = e_DoTryWriteReq ;

        if (PropId == PROPID_S_PSC_SIGNPK)
        {
            ASSERT(pwcsPathName) ;
            ASSERT(!pguidIdentifier) ;

            //
            // CoInit() should be before any R<xxx> or P<xxx> so that its
            // destructor (CoUninitialize)
            //
            CCoInit cCoInit;
            hr = cCoInit.CoInitialize();
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 330);
            }

            //
            // NT4 PSC try to renew its crypto key.
            // On MSMQ1.0, that means writing the signing public key in the
            // site object too.
            // With MSMQ2.0, we'll write directly in the machine object.
            // Then we'll touch the site object to force replication of site
            // object to all NT4 sites. (replication of site objects read
            // the key from the relevant PSC machine object).
            //
            hr = DSCoreGetNT4PscName( pguidIdentifier,
                                      pwcsPathName,
                                     &pwszServerName ) ;
            if (FAILED(hr))
            {
                //
                // We will never reach here for an NT5 server. So if we can't
                // find NT4 PSC name, fail the setting operation.
                //
                return LogHR(hr, s_FN, 340);
            }

            dwObjectType = MQDS_MACHINE ;
            PropId = PROPID_QM_SIGN_PK ;
            pwszSiteName = pwcsPathName ; // save site name.
            pwcsPathName = pwszServerName ;

            fTouchSite = TRUE ;
            eNotify = e_DoNotNotify ;
            eTryWriteRequest = e_DoNotTryWriteReq ;
            //
            // We want to change property of a NT4 object which is owned
            // by NT4 site. By default, this will create a write request
            // to the NT4 master. however, in this case we want to make the
            // change locally, on the local NT5 DS, so we have the new crypto
            // key ready when replication from that NT4 PSC start to arrive.
            //
        }

        hr = SetPropsAndNotify( dwObjectType,
                                pwcsPathName,
                                pguidIdentifier,
                                1,
                                &PropId,
                                &PropVar,
                                eNotify,
                                eTryWriteRequest,
                                pRequestContext,
                                0 ) ;

        LogHR(hr, s_FN, 1811);
        if (fTouchSite && SUCCEEDED(hr))
        {
            //
            // OK, now touch the site object.
            // Get and set NT4STUB for the site in order to increase SN
            // and force replication.
            //
            PROPID      aSiteProp = PROPID_S_NT4_STUB;
            PROPVARIANT aSiteVar;
            aSiteVar.vt = VT_UI2;
            CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

            HRESULT hr1 = DSCoreGetProps ( MQDS_SITE,
                                           pwszSiteName,
                                           NULL,
                                           1,
                                           &aSiteProp,
                                           &requestDsServerInternal,
                                           &aSiteVar );

            if (FAILED(hr1))
            {
                ASSERT(0) ;
                aSiteVar.uiVal  = 1 ;
                LogHR(hr1, s_FN, 1950);
            }

            PROPVARIANT tmpVar;
            tmpVar.vt = VT_UI2;
            tmpVar.uiVal = aSiteVar.uiVal ;
            tmpVar.uiVal++ ;

            CDSRequestContext requestDsServerInternal1( e_DoImpersonate, e_IP_PROTOCOL);
            hr1 = DSCoreSetObjectProperties ( MQDS_SITE,
                                              pwszSiteName,
                                              NULL,
                                              1,
                                              &aSiteProp,
                                              &tmpVar,
                                              &requestDsServerInternal1,
                                              NULL );
            ASSERT(SUCCEEDED(hr1)) ;
            LogHR(hr1, s_FN, 1960);

            CDSRequestContext requestDsServerInternal2( e_DoImpersonate, e_IP_PROTOCOL);
            hr1 = DSCoreSetObjectProperties ( MQDS_SITE,
                                              pwszSiteName,
                                              NULL,
                                              1,
                                              &aSiteProp,
                                              &aSiteVar,
                                              &requestDsServerInternal2,
                                              NULL );
            ASSERT(SUCCEEDED(hr1)) ;
            LogHR(hr1, s_FN, 1970);
        }

        return LogHR(hr, s_FN, 350);
    }
    else
    {
        //
        // Set security descriptor of object.
        //
        if (pSecurityDescriptor &&
            !IsValidSecurityDescriptor(pSecurityDescriptor))
        {
            return LogHR(MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR, s_FN, 360);
        }

        //
        // First retreive the present security descriptor of the object
        // from DS. Use Q_OBJ_SECURITY and QM_OBJ_SECURITY prop ids in
        // order to get back the win2k format. Win2k format preserve the
        // "protected" bit, if set. Querying the win2k format is also more
        // efficient and reduce number of conversions of security descriptor
        // format from nt4 to win2k and vice versa.
        //

        DWORD dwSecIndex = 0 ;
        PROPVARIANT aPropVarOld[2] ;
        PROPID aPropId[2] ;
        aPropVarOld[0].vt = VT_NULL ;
        DWORD cProps = 1 ;
        DWORD dwObjectTypeInternal = dwObjectType ;

        switch ( dwObjectType)
        {
            case MQDS_QUEUE:
                aPropId[ dwSecIndex ] = PROPID_Q_OBJ_SECURITY;
                break;

            case MQDS_MACHINE:
                aPropId[ dwSecIndex ] = PROPID_QM_OBJ_SECURITY;
                break;

            case MQDS_CN:
                //
                // It's OK to set security of foreign sites, not of
                // standard win2k sites. So check if site is foreign.
                //
                aPropId[0] = PROPID_S_FOREIGN ;
                dwSecIndex = 1 ;
                aPropId[ dwSecIndex ] = PROPID_S_SECURITY;
                aPropVarOld[ dwSecIndex ].vt = VT_NULL ;
                cProps = 2 ;
                dwObjectTypeInternal = MQDS_SITE ;
                break ;

            default:
                //
                // All objects other than queues and msmqConfiguration are
                // handled by the DS MMC directly, without intervention
                // of MSMQ code. We should not reach here at all, from win2k
                // clients. We will reach here from nt4 clients, trying
                // to set security of sites, for exaple.
                //
                return LogHR(MQ_ERROR_UNSUPPORTED_OPERATION, s_FN, 370);
                break;
        }

        HRESULT  hr = DSCoreGetProps( dwObjectTypeInternal,
                                      pwcsPathName,
                                      pguidIdentifier,
                                      cProps,
                                      aPropId,
                                      pRequestContext,
                                      aPropVarOld ) ;
        if ( FAILED(hr))
        {
            return LogHR(hr, s_FN, 380);
        }

        //
        // Just to make sure this buffer is released.
        //
        P<BYTE> pObjSD = (BYTE*)  aPropVarOld[ dwSecIndex ].blob.pBlobData ;

        if (aPropId[0] == PROPID_S_FOREIGN)
        {
            if (aPropVarOld[0].bVal == 0)
            {
                //
                // not foreign site. quit !
                //
                return LogHR(MQ_ERROR_UNSUPPORTED_OPERATION, s_FN, 390);
            }
            else
            {
                aPropId[ dwSecIndex ] = PROPID_CN_SECURITY;
            }
        }

        ASSERT(pObjSD && IsValidSecurityDescriptor(pObjSD)) ;
        P<BYTE> pOutSec = NULL ;

        //
        // Merge the input descriptor with object descriptor.
        // Replace the old components in obj descriptor  with new ones from
        // input descriptor.
        //
        hr = MQSec_MergeSecurityDescriptors( dwObjectType,
                                       SecurityInformation,
                                       pSecurityDescriptor,
                                       (PSECURITY_DESCRIPTOR) pObjSD,
                                       (PSECURITY_DESCRIPTOR*) &pOutSec ) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 400);
        }
        ASSERT(pOutSec && IsValidSecurityDescriptor(pOutSec)) ;

        PROPVARIANT PropVar;

        PropVar.vt = VT_BLOB;
        PropVar.blob.pBlobData = pOutSec ;
        PropVar.blob.cbSize = GetSecurityDescriptorLength(pOutSec) ;

        //
        // The inner code for "set" assume Q_SECURITY (or QM_SECURITY),
        // not the win2k native OBJ_SECURITY.
        //
        if (aPropId[ dwSecIndex ] == PROPID_Q_OBJ_SECURITY)
        {
            aPropId[ dwSecIndex ] = PROPID_Q_SECURITY ;
        }
        else if (aPropId[ dwSecIndex ] == PROPID_QM_OBJ_SECURITY)
        {
            aPropId[ dwSecIndex ] = PROPID_QM_SECURITY ;
        }

        hr = SetPropsAndNotify( dwObjectType,
                                pwcsPathName,
                                pguidIdentifier,
                                1,
                                &aPropId[ dwSecIndex ],
                                &PropVar,
                                e_DoNotify,
                                e_DoTryWriteReq,
                                pRequestContext,
                                SecurityInformation ) ;

        return LogHR(hr, s_FN, 410);
    }
}

static
HRESULT
CheckSortParameter(
    IN const MQSORTSET* pSort
	)
/*++

Routine Description:
    This routine verifies that the sort parameter doesn't
    contain the same property with conflicting sort-order.
    In MSMQ 1.0  ODBC\SQL returned an error in such case.
    NT5 ignores it.
    This check is added on the server side, in order to
    support old clients.

Arguments:

Return Value:
    MQ_OK - if sort parameter doesn't contain conflicting sort-order of the
    same property MQ_ERROR_ILLEGAL_SORT - otherwise

-----------------------------------------------------------------------*/

{
    if ( pSort == NULL)
    {
        return(MQ_OK);
    }


    const MQSORTKEY * pSortKey = pSort->aCol;
    for ( DWORD i = 0; i < pSort->cCol; i++, pSortKey++)
    {
        const MQSORTKEY * pPreviousSortKey = pSort->aCol;
        for ( DWORD j = 0; j< i; j++, pPreviousSortKey++)
        {
            if ( pPreviousSortKey->propColumn == pSortKey->propColumn)
            {
                //
                //  is it the same sorting order?
                //
                if (pPreviousSortKey->dwOrder !=  pSortKey->dwOrder)
                {
                    return LogHR(MQ_ERROR_ILLEGAL_SORT, s_FN, 420);
                }
            }
        }
    }
    return(MQ_OK);
}



/*====================================================

RoutineName: MQDSLookupBegin

Arguments:

Return Value:


=====================================================*/

BOOL FindQueryIndex( IN  MQRESTRICTION  *pRestriction,
                     OUT DWORD          *pdwIndex,
                     OUT DS_CONTEXT     *pdsContext ) ;

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSLookupBegin( IN  LPWSTR           pwcsContext,
                 IN  MQRESTRICTION   *pRestriction,
                 IN  MQCOLUMNSET     *pColumns,
                 IN  MQSORTSET       *pSort,
                 IN  HANDLE          *pHandle,
                 IN  CDSRequestContext * pRequestContext
                 )
{
    //
    //  Check sort parameter
    //
    HRESULT hr = CheckSortParameter( pSort);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 430);
    }
    //
    // To support ntlm clients, we may need to disable impersonation.
    //
    if (pRequestContext->NeedToImpersonate())
    {
        DWORD       dwIndex ;
        DS_CONTEXT  dsContext ;

        BOOL f = FindQueryIndex( pRestriction,
	    					     &dwIndex,
                                 &dsContext ) ;
        if (f && ((dsContext == e_SitesContainer) ||
                  (dsContext == e_ConfigurationContainer)))
        {
            //
            // See mqdssrv\dsifsrv.cpp, S_DSGetProps() for explanation why
            // we're not impersonating when querying for sites info.
            //
            pRequestContext->SetDoNotImpersonate();
        }
    }

    //
    // Now try to see if it's a relevant null-restriction query.
    //
    if (pRequestContext->NeedToImpersonate())
    {
        if (!pRestriction)
        {
            switch (pColumns->aCol[0])
            {
                case PROPID_L_NEIGHBOR1:
                case PROPID_S_SITEID:
                case PROPID_CN_PROTOCOLID:
                case PROPID_E_NAME:
                case PROPID_E_ID:
		        case PROPID_E_VERSION:
                    pRequestContext->SetDoNotImpersonate();
                    break ;

                default:
                    break ;
            }
        }
    }

    //
    //  Special handling of specific queries
    //

    HRESULT hr2 = DSCoreLookupBegin(
                pwcsContext,
                pRestriction,
                pColumns,
                pSort,
                pRequestContext,
                pHandle);

    return LogHR(hr2, s_FN, 440);
}

/*====================================================

RoutineName: MQDSLookupNext

Arguments:

Return Value:


=====================================================*/
HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSLookupNext(
                     HANDLE             handle,
                     DWORD  *           pdwSize,
                     PROPVARIANT  *     pbBuffer)
{
    //
    //  vartype of all PROPVARIANT should be VT_NULL.
    //  ( user cannot specify buffers for results).
    //
    PROPVARIANT * pvar = pbBuffer;
    for ( DWORD i = 0; i < *pdwSize; i++, pvar++)
    {
        pvar->vt = VT_NULL;
    }

    HRESULT hr2 = DSCoreLookupNext(
                     handle,
                     pdwSize,
                     pbBuffer);
    return LogHR(hr2, s_FN, 450);
}

/*====================================================

RoutineName: MQDSLookupEnd

Arguments:

Return Value:

=====================================================*/
HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSLookupEnd(
    IN HANDLE handle)
{

    return LogHR(DSCoreLookupEnd(handle), s_FN, 460);
}

/*====================================================

RoutineName: MQDSInit

Arguments:

Return Value:

=====================================================*/

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSInit()
{
    HRESULT hr;
    ASSERT(!g_fMQADSSetupMode);

    //
    //  Initialize DSCore if not initilized already
    //
    if (!g_fInitedDSCore)
    {
        hr = DSCoreInit(
				FALSE /* fSetupMode */
				);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 500);
        }
        g_fInitedDSCore = TRUE;
    }

	//
	// BUGBUG - Initialize the g_GenWriteRequests to do nothing
	//
//    g_GenWriteRequests.InitializeDummy();

    //
    //  Initialize generation of write requests to NT4 PSC's
    //
    hr = g_GenWriteRequests.Initialize();
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("MQDSInit : g_GenWriteRequests.Initialize()=%lx"),hr));
        return LogHR(hr, s_FN, 510);
    }

    //
    // See if "trust-for-delegation" is turned on. If not, raise an error
    // event. MSMQ server on domain controller can't process queries if
    // the server is not trusted for Kerberos delegation.
    //
    hr = CheckTrustForDelegation() ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 520);
    }

    return MQ_OK;
}


/*====================================================

RoutineName: MQDSTerminate

Arguments:

Return Value:

=====================================================*/
void
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSTerminate()
{
    DSCoreTerminate();
}

//+--------------------------------------------
//
//  HRESULT _StartQmResponseVerification()
//
//+--------------------------------------------

STATIC HRESULT _StartQmResponseVerification( IN  LPCWSTR    pwcsPathName,
                                             IN const GUID  *pMachineGuid,
                                             IN  BYTE       pbChallenge[],
                                             IN  DWORD      dwChallengeSize,
                                             OUT HCRYPTKEY  *phKey,
                                             OUT HCRYPTHASH *phHash )
{
    ASSERT(!pwcsPathName || !pMachineGuid) ;

    PROPID PropId = PROPID_QM_SIGN_PKS ;
    PROPVARIANT PropVar;

    PropVar.vt = VT_NULL;

    //
    // Get the QM's public signing key.
    //
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    HRESULT hr = DSCoreGetProps( MQDS_MACHINE,
                                 pwcsPathName,
                                 pMachineGuid,
                                 1,
                                 &PropId,
                                 &requestDsServerInternal,
                                 &PropVar ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 540);
    }
    ASSERT(PropVar.vt == VT_BLOB) ;

    if (PropVar.blob.pBlobData == NULL)
    {
        //
        // ops, what a surprise. Machine doesn't have public key.
        //
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 550);
    }

    //
    // unpack the base provider key.
    //
    P<MQDSPUBLICKEYS> pPublicKeys =
                          (MQDSPUBLICKEYS *) PropVar.blob.pBlobData ;
    BYTE   *pKey = NULL ;
    ULONG   ulKeyLen = 0 ;

    ASSERT(pPublicKeys->ulLen == PropVar.blob.cbSize);
    if ((long) (pPublicKeys->ulLen) > (long) (PropVar.blob.cbSize))
    {
        //
        // DS probably still have old data (msmq1.0 format).
        //
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 560);
    }

    hr =  MQSec_UnpackPublicKey( pPublicKeys,
                                 x_MQ_Encryption_Provider_40,
                                 x_MQ_Encryption_Provider_Type_40,
                                &pKey,
                                &ulKeyLen ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 570);
    }

    DWORD dwErr = 0 ;
    ASSERT(g_hProvVer) ;

    if (!CryptImportKey(g_hProvVer, pKey, ulKeyLen, NULL, 0, phKey))
    {
        dwErr = GetLastError() ;
        DBGMSG((DBGMOD_DS | DBGMOD_SECURITY, DBGLVL_ERROR, TEXT(
        "MQADS: _ResponseVerification(), CryptImportKey() fail, err- %lxh"),
         dwErr)) ;

        LogNTStatus(dwErr, s_FN, 581);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 580);
    }

    if (!CryptCreateHash(g_hProvVer, CALG_MD5, NULL, 0, phHash))
    {
        dwErr = GetLastError() ;
        DBGMSG((DBGMOD_DS | DBGMOD_SECURITY, DBGLVL_ERROR, TEXT(
        "MQADS: _ResponseVerification(), CryptCreateHash() fail, err- %lxh"),
         dwErr)) ;

        LogNTStatus(dwErr, s_FN, 582);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 590);
    }

    if (!CryptHashData(*phHash, pbChallenge, dwChallengeSize, 0))
    {
        dwErr = GetLastError() ;
        DBGMSG((DBGMOD_DS | DBGMOD_SECURITY, DBGLVL_ERROR, TEXT(
        "MQADS: _ResponseVerification(), CryptHashData() fail, err- %lxh"),
         dwErr)) ;

        LogNTStatus(dwErr, s_FN, 583);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 600);
    }

    return MQ_OK ;
}

/*====================================================

RoutineName: MQDSQMSetMachineProperties

Arguments:

Return Value:

=====================================================*/
HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSQMSetMachineProperties(
            IN  LPCWSTR     pwcsPathName,
            IN  DWORD       cp,
            IN  PROPID      aProp[],
            IN  PROPVARIANT apVar[],
            IN  BYTE        pbChallenge[],
            IN  DWORD       dwChallengeSize,
            IN  BYTE        pbSignature[],
            IN  DWORD       dwSignatureSize)
{
    CHCryptKey hKey;
    CHCryptHash hHash;

    HRESULT hr = _StartQmResponseVerification( pwcsPathName,
                                               NULL,
                                               pbChallenge,
                                               dwChallengeSize,
                                              &hKey,
                                              &hHash ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 610);
    }

    //
    // Hash the properties.
    //
    hr = HashProperties(hHash, cp, aProp, apVar);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 620);
    }

    //
    // Verify the the signature is OK.
    //
    if (!CryptVerifySignature(
            hHash,
            pbSignature,
            dwSignatureSize,
            hKey,
            NULL,
            0))
    {
        DWORD dwErr = GetLastError() ;
        DBGMSG((DBGMOD_DS | DBGMOD_SECURITY, DBGLVL_ERROR, TEXT(
        "MQADS: MQDSQMSetMachineProperties(), signature verification failed, err- %lxh"),
                                                 dwErr)) ;
        //
        // Bad signature.
        //
        if (dwErr == NTE_BAD_SIGNATURE)
        {
            return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 630);
        }
        else
        {
            LogNTStatus(dwErr, s_FN, 631);
            return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 640);
        }
    }

    if ((cp == 1) && (aProp[0] == PROPID_QM_UPGRADE_DACL))
    {
        hr = MQDSUpdateMachineDacl() ;
        return hr ;
    }

    //
    // Set the properties.
    //
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate,
                                               e_IP_PROTOCOL);
    requestDsServerInternal.AccessVerified(TRUE) ;

    hr = SetPropsAndNotify( MQDS_MACHINE,
                            pwcsPathName,
                            NULL,
                            cp,
                            aProp,
                            apVar,
                            e_DoNotify,
                            e_DoTryWriteReq,
                            &requestDsServerInternal,
                            0);  // SecurityInformation

    return LogHR(hr, s_FN, 650);
}

/*====================================================

RoutineName: MQDSQMGetObjectSecurity

Arguments:

Return Value:

=====================================================*/
HRESULT
MQDS_EXPORT
APIENTRY
MQDSQMGetObjectSecurity(
            IN  DWORD                   dwObjectType,
            IN  CONST GUID *            pObjectGuid,
            IN  SECURITY_INFORMATION    RequestedInformation,
            IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
            IN  DWORD                   nLength,
            IN  LPDWORD                 lpnLengthNeeded,
            IN  BYTE                    pbChallenge[],
            IN  DWORD                   dwChallengeSize,
            IN  BYTE                    pbChallengeResponce[],
            IN  DWORD                   dwChallengeResponceSize)
{
    PROPID PropId;
    PROPVARIANT PropVar;
    P<GUID> pMachineGuid_1;
    const GUID *pMachineGuid;

    ASSERT((dwObjectType == MQDS_QUEUE) || (dwObjectType == MQDS_MACHINE));

    HRESULT hr;
    if (dwObjectType == MQDS_QUEUE)
    {
        //
        // retrieve machine guid from queue.
        //
        PropId = PROPID_Q_QMID;
        PropVar.vt = VT_NULL;

        //
        // Get the queue path name.
        //
        CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr = DSCoreGetProps(
                MQDS_QUEUE,
                NULL,
                pObjectGuid,
                1,
                &PropId,
                &requestDsServerInternal,
                &PropVar);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 660);
        }

        pMachineGuid = pMachineGuid_1 = PropVar.puuid;
    }
    else
    {
        pMachineGuid = pObjectGuid;
    }

    //
    // Verify the the challenge responce is OK.
    //

    CHCryptKey hKey;
    CHCryptHash hHash;

    hr = _StartQmResponseVerification( NULL,
                                       pMachineGuid,
                                       pbChallenge,
                                       dwChallengeSize,
                                      &hKey,
                                      &hHash ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 670);
    }

    if (!CryptVerifySignature(
            hHash,
            pbChallengeResponce,
            dwChallengeResponceSize,
            hKey,
            NULL,
            0))
    {
        DWORD dwErr = GetLastError() ;
        DBGMSG((DBGMOD_DS | DBGMOD_SECURITY, DBGLVL_ERROR, TEXT(
        "MQADS: MQDSQMGetObjectSecurity(), signature verification failed, err- %lxh"),
                                                 dwErr)) ;
        //
        // Bad challenge responce.
        //
        if (dwErr == NTE_BAD_SIGNATURE)
        {
            return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 680);
        }
        else
        {
            LogNTStatus(dwErr, s_FN, 681);
            return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 690);
        }
    }

    if (RequestedInformation | SACL_SECURITY_INFORMATION)
    {
        //
        // We verified we're called from a remote MSMQ service.
        // We don't impersonate the call. So if remote msmq ask for SACL,
        // grant ourselves the SE_SECURITY privilege.
        //
        HRESULT hr1 = MQSec_SetPrivilegeInThread(SE_SECURITY_NAME, TRUE);
        ASSERT(SUCCEEDED(hr1)) ;
        LogHR(hr1, s_FN, 1601);
    }

    //
    // Get the object's security descriptor.
    //
    PropId = (dwObjectType == MQDS_QUEUE) ?
                PROPID_Q_SECURITY :
                PROPID_QM_SECURITY;

    PropVar.vt = VT_NULL;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = DSCoreGetProps(
            dwObjectType,
            NULL,
            pObjectGuid,
            1,
            &PropId,
            &requestDsServerInternal,
            &PropVar);

    if (RequestedInformation | SACL_SECURITY_INFORMATION)
    {
        //
        // Remove the SECURITY privilege.
        //
        HRESULT hr1 = MQSec_SetPrivilegeInThread(SE_SECURITY_NAME, FALSE);
        ASSERT(SUCCEEDED(hr1)) ;
        LogHR(hr1, s_FN, 1602);
    }

    if (FAILED(hr))
    {
        if (RequestedInformation | SACL_SECURITY_INFORMATION)
        {
            if (hr == MQ_ERROR_ACCESS_DENIED)
            {
                //
                // change the error code, for compatibility with MSMQ1.0
                //
                hr = MQ_ERROR_PRIVILEGE_NOT_HELD ;
            }
        }
        return LogHR(hr, s_FN, 700);
    }

    AP<BYTE> pSD = PropVar.blob.pBlobData;
    ASSERT(IsValidSecurityDescriptor(pSD));
    SECURITY_DESCRIPTOR SD;
    BOOL bRet;

    //
    // Copy the security descriptor.
    //
    bRet = InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION);
    ASSERT(bRet);

    //
    // use e_DoNotCopyControlBits at present, to be compatible with
    // previous code.
    //
    MQSec_CopySecurityDescriptor( &SD,
                                   pSD,
                                   RequestedInformation,
                                   e_DoNotCopyControlBits ) ;

    *lpnLengthNeeded = nLength;

    if (!MakeSelfRelativeSD(&SD, pSecurityDescriptor, lpnLengthNeeded))
    {
        ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);

        return LogHR(MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL, s_FN, 710);
    }

    ASSERT(IsValidSecurityDescriptor(pSecurityDescriptor));

    return (MQ_OK);
}

/*====================================================

RoutineName: MQDSCreateServersCache

Arguments:

Return Value:

=====================================================*/

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSCreateServersCache()
{
    //
    // First, Delete the existing list.
    //
    LONG    rc;
    DWORD   dwDisposition;
    HKEY    hKeyCache;

    WCHAR  tServersKeyName[ 256 ] = {0};
    wcscpy(tServersKeyName, GetFalconSectionName());
    rc = RegOpenKeyEx( 
				FALCON_REG_POS,
				tServersKeyName,
				0L,
				KEY_ALL_ACCESS,
				&hKeyCache 
				);

    if (rc == ERROR_SUCCESS)
    {
       rc = RegDeleteKey(hKeyCache, L"ServersCache");
       RegCloseKey(hKeyCache);
       LogNTStatus(rc, s_FN, 1623);
       if ((rc != ERROR_SUCCESS) && (rc != ERROR_FILE_NOT_FOUND))
       {
          //
          // ERROR_FILE_NOT_FOUND is legitimate (entry was deleted).
          // Any other error is a real error. However, continue and
          // try to create the servers list.
          //
          ASSERT(0);
          DBGMSG((DBGMOD_DSAPI, DBGLVL_ERROR, _TEXT("MQDSCreateServersCache: Fail to delete old 'ServersCache' Key. Error %d"), rc));
       }
    }
    else
    {
       //
       // The msmq\parameters must exist!
       //
       ASSERT(0);
       LogNTStatus(rc, s_FN, 720);
       return MQ_ERROR;
    }

    //
    // Next, create a new the registry key.
    //
    wcscat(tServersKeyName, TEXT("\\ServersCache"));

    rc = RegCreateKeyEx( 
			FALCON_REG_POS,
			tServersKeyName,
			0L,
			L"REG_SZ",
			REG_OPTION_NON_VOLATILE,
			KEY_WRITE | KEY_READ,
			NULL,
			&hKeyCache,
			&dwDisposition 
			);

    if (rc != ERROR_SUCCESS)
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _TEXT("Fail to Open 'ServersCache' Key. Error %d"), rc));
        REPORT_WITH_STRINGS_AND_CATEGORY((
			CATEGORY_MQDS,
			MSMQ_INTERNAL_ERROR,
			1,
			L"MQDSCreateServersCache()"
			));

        LogNTStatus(rc, s_FN, 730);
        return MQ_ERROR;
    }

    HANDLE      hSiteQuery;
    DWORD       dwSiteProps = 2;
    PROPVARIANT resultSite[2];
    HRESULT hr = MQ_ERROR;
    //
    //  Look for all sites
    //

    //
    // Retrieve  site id.
    //
    CColumns   ColsetSite;

    ColsetSite.Add(PROPID_S_SITEID);
    ColsetSite.Add(PROPID_S_PATHNAME);

    CDSRequestContext requestDsServerInternal(e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = DSCoreLookupBegin( 
				0,
				NULL,
				ColsetSite.CastToStruct(),
				NULL,
				&requestDsServerInternal,
				&hSiteQuery
				);


    if (SUCCEEDED( hr))
    {
       WCHAR wszServers[ WSZSERVERS_LEN ] = {L'\0'};
       LONG cwServers = 0 ;

       while (SUCCEEDED(hr = DSCoreLookupNext(hSiteQuery, &dwSiteProps, resultSite)))
       {
           P<GUID>   pSiteId  = NULL;
           AP<WCHAR> lpwsSiteName = NULL;

           if (dwSiteProps == 0)
           {
              //
              //  No more results to retrieve
              //
              break;
           }

           pSiteId  = resultSite->puuid;
           lpwsSiteName = resultSite[1].pwszVal;

           wszServers[0] = L'\0';
           cwServers = 0;


          //
          //   Query all the site DS servers
          //
          CRestriction Restriction;
          //
          //  Look for all servers (frs not included)
          //
          Restriction.AddRestriction( 
							SERVICE_SRV,
							PROPID_QM_SERVICE,
							PRGT,
							0
							);

          Restriction.AddRestriction( 
							pSiteId,
							PROPID_QM_SITE_ID,
							PREQ,
							1
							);

          //
          // Retrieve machine name
          //
          CColumns   Colset;
          Colset.Add(PROPID_QM_PATHNAME_DNS);
          Colset.Add(PROPID_QM_PATHNAME);

          DWORD       dwProps = 2;
          PROPVARIANT result[2];
          HANDLE      hQuery;

          // This search request will be recognized and specially simulated by DS
          CDSRequestContext requestDsServerInternal(e_DoNotImpersonate, e_IP_PROTOCOL);
          hr = DSCoreLookupBegin( 
					0,
					Restriction.CastToStruct(),
					Colset.CastToStruct(),
					NULL,
					&requestDsServerInternal,
					&hQuery
					);

          if (FAILED(hr))
          {
              continue;
          }

          while (SUCCEEDED(hr = DSCoreLookupNext(hQuery, &dwProps, result)))
          {
               AP<WCHAR> pwszName = NULL;
               AP<WCHAR> pClean;

               if (dwProps == 0)
               {
                 DSCoreLookupEnd( hQuery);
                 //
                 // Write previous site to registry.
                 //
                 cwServers = wcslen(wszServers);
                 if ( cwServers > 0)
                 {
                     wszServers[ cwServers-1 ] = L'\0'; // remove last comma
                     rc =  RegSetValueEx( 
								hKeyCache,
								lpwsSiteName,
								0L,
								REG_SZ,
								(const BYTE*) wszServers,
								(cwServers * sizeof(WCHAR)) 
								);

                     ASSERT(rc == ERROR_SUCCESS);
                 }
                 break;
               }

               if (result->vt == VT_EMPTY)
               {
                   //
                   // empty property was returned. The DNS name of the server
                   // is unknown. Write its netbios name
                   //
                   pwszName = (result + 1)->pwszVal;

               }
               else
               {
                   //
                   //   Write the DNS name of the server.
                   //
                   pwszName = result->pwszVal;
                   pClean = (result + 1)->pwszVal;
               }

               //
               //      For each PSC get its information
               //
               if (wcslen(pwszName) + cwServers + 4 < numeric_cast<size_t>(WSZSERVERS_LEN))
               {
                  cwServers += wcslen(pwszName) + 3;
                  wcscat(wszServers, L"11");
                  wcscat(wszServers, pwszName);
                  wcscat(wszServers, L",");
               }
           }
       }
       //
       // close the query handle
       //
       DSCoreLookupEnd( hSiteQuery);
    }

    DBGMSG((DBGMOD_DS, DBGLVL_TRACE, TEXT("MQDSCreateServersCache terminated (%lxh)"), hr));

    RegCloseKey(hKeyCache);
    return LogHR(hr, s_FN, 740);
}

/*====================================================

RoutineName: MQADSGetComputerSites

Arguments:

Return Value:

=====================================================*/
HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSGetComputerSites(
            IN  LPCWSTR     pwcsComputerName,
            OUT DWORD  *    pdwNumSites,
            OUT GUID **     ppguidSites
            )
{

    *pdwNumSites = 0;
    *ppguidSites = NULL;

    HRESULT hr2 = DSCoreGetComputerSites(
            pwcsComputerName,
            pdwNumSites,
            ppguidSites
            );
    return LogHR(hr2 , s_FN, 760);
}

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSGetPropsEx(
             IN  DWORD dwObjectType,
             IN  LPCWSTR pwcsPathName,
             IN  CONST GUID *  pguidIdentifier,
             IN  DWORD cp,
             IN  PROPID  aProp[  ],
             OUT PROPVARIANT  apVar[  ],
             IN  CDSRequestContext *  pRequestContext
             )
/*++

Routine Description:
    This routine is for retrieving attributes that are defined in
    MSMQ 2.0 and above.

Arguments:

Return Value:
--*/
{
    //
    // At present this api has special use and the following checks are
    // just sanity ones, to keep track of who/why are calling this function.
    // When new calls are needed, just changes the checks.
    //
    if (cp != 1)
    {
        return LogHR(MQ_ERROR_PROPERTY , s_FN, 770);
    }

    if (! ((aProp[0] == PROPID_Q_OBJ_SECURITY)  ||
           (aProp[0] == PROPID_QM_OBJ_SECURITY) ||
           (aProp[0] == PROPID_QM_ENCRYPT_PKS)  ||
           (aProp[0] == PROPID_QM_SIGN_PKS)) )
    {
        return LogHR(MQ_ERROR_PROPERTY , s_FN, 780);
    }

    HRESULT hr;

    hr = DSCoreGetProps(
                        dwObjectType,
                        pwcsPathName,
                        pguidIdentifier,
                        cp,
                        aProp,
                        pRequestContext,
                        apVar);
    return LogHR(hr, s_FN, 790);

}
HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSPreDeleteQueueGatherInfo(
        IN LPCWSTR      pwcsQueueName,
        OUT GUID *      pguidQmId,
        OUT BOOL *      pfForeignQm,
        OUT BOOL *      pfOwnedByNT4Site,
        OUT GUID *      pguidOwnerNT4Site
        )
/*++

Routine Description:
    This routine gather queue information that is required for
    post queue deletion operation.
    The collected data will enable to perform notification and to
    send WriteRequest ( if needed)

Arguments:

Return Value:
--*/
{
    HRESULT hr;
    //
    //  First let's read the QM props
    //
    // start with getting PROPID_Q_QMID.
    //
    PROPID aPropQmId[] = {PROPID_Q_QMID};
    CAutoCleanPropvarArray cCleanVarQmId;
    PROPVARIANT * pVarQmId = cCleanVarQmId.allocClean(ARRAY_SIZE(aPropQmId));
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = DSCoreGetProps(MQDS_QUEUE,
                        pwcsQueueName,
                        NULL,
                        ARRAY_SIZE(aPropQmId),
                        aPropQmId,
                        &requestDsServerInternal,
                        pVarQmId);
    if ( FAILED(hr))
    {
        //
        //  Failed to gather information... no use to continue
        //
        return LogHR(hr, s_FN, 800);
    }
    const DWORD cNum = 2;
    PROPID propQm[cNum] = { PROPID_QM_MACHINE_ID, PROPID_QM_FOREIGN};
    PROPVARIANT varQM[cNum];

    varQM[0].vt = VT_CLSID;
    varQM[0].puuid = pguidQmId;
    varQM[1].vt = VT_NULL;

    CDSRequestContext requestDsServerInternal1( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = DSCoreGetProps(MQDS_MACHINE,
                        NULL /*pwcsPathName*/,
                        pVarQmId[0].puuid,
                        cNum,
                        propQm,
                        &requestDsServerInternal1,
                        varQM);
    if (FAILED(hr))
    {
        //
        //  Failed to gather information... no use to continue
        //
        return LogHR(hr, s_FN, 810);
    }
    *pfForeignQm =  varQM[1].bVal;

    //
    //  verify the owner
    //
    *pfOwnedByNT4Site = FALSE;

    hr = g_GenWriteRequests.CheckQueueIsOwnedByNT4Site(
               pwcsQueueName,
               NULL,
               pfOwnedByNT4Site,
               pguidOwnerNT4Site,
               NULL);
    //
    //  ignore the error
    //
    if (SUCCEEDED(hr))
    {
        if (*pfOwnedByNT4Site)
        {
            //
            //  Let us warn the user that he is about to delete
            //  a queue that is owned by NT4 PSC
            //
            return LogHR(MQ_INFORMATION_QUEUE_OWNED_BY_NT4_PSC, s_FN, 825);
        }
    }


    return LogHR(hr, s_FN, 830);
}

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSPostDeleteQueueActions(
        IN LPCWSTR      pwcsQueueName,
        IN const GUID *       pguidQmId,
        IN BOOL *       pfForeignQm,
        IN BOOL *       pfOwnedByNT4Site,
        IN GUID *       pguidOwnerNT4Site
                           )
/*++

Routine Description:
    The queue was deleted by MMC.
    The cleanups that we need to do are:
    1. if the queue is owned by NT4 site :
            generate a write request ( we do it once and ignore the error
    2. Generate a notification

Arguments:

Return Value:
--*/
{
    HRESULT hr;
    if (*pfOwnedByNT4Site)
    {
        //
        //  Send a write request to the owner psc.
        //  This is done only once and the return code is ignored.
        //
        static const PROPID x_rgDelPropIDs[] = {PROPID_D_SCOPE, PROPID_D_OBJTYPE};
        PROPVARIANT rgDelPropVars[ARRAY_SIZE(x_rgDelPropIDs)];
        rgDelPropVars[0].vt = VT_UI1;
        rgDelPropVars[0].bVal = ENTERPRISE_SCOPE;
        rgDelPropVars[1].vt = VT_UI1;
        rgDelPropVars[1].bVal = (unsigned char)MQDS_QUEUE;

        //
        // send the write request
        //
        hr = g_GenWriteRequests.BuildSendWriteRequest(
                                   pguidOwnerNT4Site,
                                   DS_UPDATE_DELETE,
                                   MQDS_QUEUE,
                                   pwcsQueueName,
                                   NULL,
                                   ARRAY_SIZE(x_rgDelPropIDs),
                                   x_rgDelPropIDs,
                                   rgDelPropVars);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS, DBGLVL_ERROR, 
				TEXT("MQDSPostDeleteQueueActions:send write request()=%lx. queue %ls deletion, ignoring..."),
				hr, (pwcsQueueName ? pwcsQueueName : L"<guid>")));

            REPORT_WITH_STRINGS_AND_CATEGORY((
					CATEGORY_MQDS,
					POST_DEL_WRITE_REQUEST,
					1,
					pwcsQueueName
					));

            //
            //  no use to send notification, the queue still exist in NT4
            //
            LogHR(hr, s_FN, 840);
            return MQ_ERROR_WRITE_REQUEST_FAILED;
        }
    }
    //
    //  send notification about the queue deletion
    //
    extern const ULONG g_cNotifyQmProps;
    MQDS_OBJ_INFO_REQUEST sQmInfoRequest;

    PROPVARIANT var[2];
    sQmInfoRequest.cProps = g_cNotifyQmProps;
    sQmInfoRequest.pPropIDs = g_rgNotifyQmProps;
    sQmInfoRequest.pPropVars = var;
    sQmInfoRequest.hrStatus = MQ_OK;

    ASSERT(g_cNotifyQmProps == 2);
    ASSERT(g_rgNotifyQmProps[0] ==  PROPID_QM_MACHINE_ID);
    ASSERT(g_rgNotifyQmProps[1] ==  PROPID_QM_FOREIGN);
    var[0].vt = VT_CLSID;
    var[0].puuid = const_cast<GUID *>(pguidQmId);
    var[1].vt = VT_UI1;
    var[1].bVal = ( *pfForeignQm)? (unsigned char)1 : (unsigned char)0;

    hr = NotifyDeleteQueue(
				&sQmInfoRequest,
				pwcsQueueName,
				NULL
				);

    if (FAILED(hr))
    {
        //
        // put debug info and ignore
        //
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, 
			TEXT("MQDSPostDeleteQueueActions:NotifyDeleteQueue()=%lx, can't notify. queue %ls deletion, ignoring..."), 
			hr, pwcsQueueName ));
        LogHR(hr, s_FN, 1624);
    }

    return MQ_OK;
}



HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSPreDeleteMachineGatherInfo(
        IN LPCWSTR      pwcsMachineName,
        OUT BOOL *      pfOwnedByNT4Site,
        OUT GUID *      pguidOwnerNT4Site
        )
/*++

Routine Description:
    This routine gather machine information that is required for
    post machine deletion operation.
    The collected data will enable to to
    send WriteRequest ( if needed)

Arguments:

Return Value:
--*/
{
    HRESULT hr;

    //
    //  verify the owner
    //
    *pfOwnedByNT4Site = FALSE;

    hr = g_GenWriteRequests.CheckMachineIsOwnedByNT4Site(
               pwcsMachineName,
               NULL,
               pfOwnedByNT4Site,
               pguidOwnerNT4Site,
               NULL,
               NULL);
    //
    //  ignore the error
    //
    if (SUCCEEDED(hr))
    {
        if (*pfOwnedByNT4Site)
        {
            //
            //  Let us warn the user that he is about to delete
            //  a machine that is owned by NT4 PSC
            //
            return LogHR(MQ_INFORMATION_MACHINE_OWNED_BY_NT4_PSC, s_FN, 820);
        }
    }


    return LogHR(hr, s_FN, 831);
}

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSPostDeleteMachineActions(
        IN LPCWSTR      pwcsMachineName,
        IN BOOL *       pfOwnedByNT4Site,
        IN GUID *       pguidOwnerNT4Site
        )
/*++

Routine Description:
    The machine was deleted by MMC.
    The cleanups that we need to do are:
    1. if the machine is owned by NT4 site :
            generate a write request ( we do it once and ignore the error
    ( no need to send notification)

Arguments:

Return Value:
--*/
{
    HRESULT hr;
    if (*pfOwnedByNT4Site)
    {
        //
        //  Send a write request to the owner psc.
        //  This is done only once and the return code is ignored.
        //
        static const PROPID x_rgDelPropIDs[] = {PROPID_D_SCOPE, PROPID_D_OBJTYPE};
        PROPVARIANT rgDelPropVars[ARRAY_SIZE(x_rgDelPropIDs)];
        rgDelPropVars[0].vt = VT_UI1;
        rgDelPropVars[0].bVal = ENTERPRISE_SCOPE;
        rgDelPropVars[1].vt = VT_UI1;
        rgDelPropVars[1].bVal = (unsigned char)MQDS_MACHINE;

        //
        // send the write request
        //
        hr = g_GenWriteRequests.BuildSendWriteRequest(
                                   pguidOwnerNT4Site,
                                   DS_UPDATE_DELETE,
                                   MQDS_MACHINE,
                                   pwcsMachineName,
                                   NULL,
                                   ARRAY_SIZE(x_rgDelPropIDs),
                                   x_rgDelPropIDs,
                                   rgDelPropVars
								   );
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
             "MQDSPostDeleteMachineActions:send write request()=%lx. machine %ls deletion, ignoring..."),
             hr, (pwcsMachineName ? pwcsMachineName : L"<guid>")));

            REPORT_WITH_STRINGS_AND_CATEGORY((
					CATEGORY_MQDS,
					POST_DEL_WRITE_REQUEST,
					1,
					pwcsMachineName
					));

            //
            //  no use to send notification, the machine still exist in NT4
            //
            LogHR(hr, s_FN, 841);
            return MQ_ERROR_WRITE_REQUEST_FAILED;
        }
    }
    return MQ_OK;
}

//+----------------------------------------
//
//  HRESULT MQDSGetGCListInDomain()
//
//+----------------------------------------

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSGetGCListInDomain(
   IN  LPCWSTR              pwszComputerName,
   IN  LPCWSTR              pwszDomainName,
   OUT LPWSTR              *lplpwszGCList 
   )
{
    HRESULT hr = DSCoreGetGCListInDomain(
                      pwszComputerName,
                      pwszDomainName,
                      lplpwszGCList 
					  );
    return  LogHR(hr, s_FN, 860);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\mqadssec.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:  saddguid.cpp

Abstract:

1.  Code to grant current user (impersonated user) the permission to
    "addGuid", i.e., create object with owner supplied guid.
    Note that such an object can be created only on a GC machine.
    Most of the code is copied from the migration tool.

2.  Code to grant everyone the list_content right on computer objects.
    That's necessary for support of ntlm users and local users.

Author:

    Doron Juster (DoronJ)  06-Oct-1998

--*/

#include "ds_stdh.h"
#include "mqds.h"
#include "mqads.h"
#include "dscore.h"
#include <mqreport.h>
#include <mqsec.h>
#include <autoreln.h>
#include <aclapi.h>
#include <lmaccess.h>
#include "mqadssec.h"
#include "..\..\mqsec\inc\permit.h"

#include "mqadssec.tmh"

static CCriticalSection s_AddGuidCS ;
const WCHAR * GetMsmqServiceContainer() ; // from mqdscore.lib
const WCHAR * GetLocalServerName()      ; // from mqdscore.lib

static WCHAR *s_FN=L"mqads/mqadssec";


//+----------------------------------------------------
//
//  HRESULT   MQDSRelaxSecurity()
//
//+----------------------------------------------------

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSRelaxSecurity(DWORD dwRelaxFlag)
{
    CDSRequestContext RequestContext ( e_DoNotImpersonate,
                                       e_ALL_PROTOCOLS ) ;
    PROPID PropId = PROPID_E_NAMESTYLE ;
    PROPVARIANT var ;
    var.vt = VT_UI1 ;
    var.bVal = (unsigned char) dwRelaxFlag ;

    LPCWSTR pwszMsmqService = GetMsmqServiceContainer() ;

    HRESULT hr = DSCoreSetObjectProperties( MQDS_ENTERPRISE,
                                            pwszMsmqService,
                                            NULL,
                                            1,
                                           &PropId,
                                           &var,
                                           &RequestContext,
                                            NULL ) ; // objInfoRequest
    return LogHR(hr, s_FN, 50);
}

//+-----------------------------------------------------------------------
//
//  HRESULT  CheckTrustForDelegation()
//
//  Check if the "trust-for-delegation" bit is turned on. Return error (and
//  stop running) only if we know for sure that trust is not enable. Any
//  other error (like not being able to query the bit) will result in a
//  warning event but msmq service will continue to run.
//
//+------------------------------------------------------------------------

HRESULT  CheckTrustForDelegation()
{
    PROPID propID = PROPID_COM_ACCOUNT_CONTROL;
    PROPVARIANT varAccount;
    varAccount.vt = VT_UI4;

    const WCHAR  *pServerName =  GetLocalServerName();
    CDSRequestContext RequestContext(e_DoNotImpersonate, e_ALL_PROTOCOLS);

    HRESULT hr = DSCoreGetProps( 
					MQDS_COMPUTER,
					pServerName,
					NULL,
					1,
					&propID,
					&RequestContext,
					&varAccount 
					);

    LogHR(hr, s_FN, 1802);
    if (FAILED(hr))
    {
        ASSERT(0) ;
        REPORT_CATEGORY(CANNOT_DETERMINE_TRUSTED_FOR_DELEGATION, CATEGORY_MQDS);
        return MQ_OK;
    }

    if (varAccount.ulVal & UF_TRUSTED_FOR_DELEGATION)
    {
        //
        // This flag is defined in lmaccess.h, under nt\public\sdk\inc
        //
        return MQ_OK;
    }

    REPORT_CATEGORY(NOT_TRUSTED_FOR_DELEGATION, CATEGORY_MQDS);
    return LogHR(MQ_ERROR_NOT_TRUSTED_DELEGATION, s_FN, 1801);
}

//+-------------------------------
//
//  BOOL MQDSIsServerGC()
//
//+-------------------------------

BOOL
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSIsServerGC()
{
    BOOL fIsGC = DSCoreIsServerGC() ;
    return fIsGC ;
}

//+------------------------------------------------------------------------
//
//  HRESULT  MQDSUpdateMachineDacl()
//
// We update the dacl of the machine object so any service running on the
// machine can update msmq parameters. We don't get any name from client.
// Rather, we impersonate the call and retrieve the computer name from the
// sid.
// We need this functionality to support upgraded computers and computers
// that move between domains. (note- at present, July-1999, move between
// domains will not call this function). After move/upgrade, the computer
// may have a new sid and therefore it can't update its own msmqConfiguration
// object that remained in the old domain. So ask the msmq server on that
// old domain to update the security descriptor.
// This code updates the active directory in the context of the local
// msmq serivce, after it verified that it indeed impersonate a computer
// account.
//
//+-------------------------------------------------------------------------

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSUpdateMachineDacl()
{
    BOOL fGet ;
    HRESULT hr = MQ_OK ;
    P<SID> pCallerSid = NULL ;

    {
        //
        // begin/end block for impersonation.
        //

        P<CImpersonate> pImpersonate = NULL ;

        hr = MQSec_GetImpersonationObject( TRUE,
                                           TRUE,
                                          &pImpersonate ) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 2100);
        }

        fGet = pImpersonate->GetThreadSid( (BYTE**) &pCallerSid ) ;
        if (!fGet)
        {
            return MQ_ERROR_CANNOT_IMPERSONATE_CLIENT ;
        }
    }

    //
    // Get computer name from impersonated sid.
    //
    SID_NAME_USE eUse;
    #define ACCOUNT_BUF_SIZE  1024
    WCHAR wszAccountName[ ACCOUNT_BUF_SIZE ] ;
    DWORD dwAccountNameLen = ACCOUNT_BUF_SIZE ;
    #define DOMAIN_BUF_SIZE  1024
    WCHAR wszDomainName[ DOMAIN_BUF_SIZE ] ;
    DWORD  dwDomainNameLen= DOMAIN_BUF_SIZE ;

    fGet = LookupAccountSid( NULL,
                             pCallerSid,
                             wszAccountName,
                            &dwAccountNameLen,
                             wszDomainName,
                            &dwDomainNameLen,
                            &eUse) ;
    if (!fGet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError()) ;
        return LogHR(hr, s_FN, 2030);
    }

    DWORD dwLen = wcslen(wszAccountName) ;
    if (wszAccountName[ dwLen - 1 ] != L'$')
    {
///////////////  (eUse != SidTypeComputer)) bug in win2k security ???
        //
        // not a computer account. Ignore.
        //
        return LogHR(MQ_ERROR_ILLEGAL_USER, s_FN, 2040);
    }

    //
    // Now use our own query code to fetch the security descriptor of
    // the msmqConfiguration object, after we have the computer name.
    // We need only the DACL, to add new sid to it.
    //
    wszAccountName[ dwLen - 1 ] = 0 ;

    CDSRequestContext RequestContext( e_DoNotImpersonate,
                                      e_ALL_PROTOCOLS ) ;
    //
    // The setting operation is done in the context of the msmq service,
    // without impersonation. How do we know this is safe ?
    // three means are used:
    // 1. this function is called from DSQMSetMachineProperties(), after
    //    running challenge/response algorithm with the source machine.
    // 2. for this operation, we request Kerberos authentication (so we
    //    know this is a win2k machine, or at least a client running Kerberos
    //    and familiar to the active directory). see mqdssrv\dsifsrv.cpp,
    //    S_DSQMSetMachineProperties().
    // 3. We verified above that account name terminate with a $. That's not
    //    really "tight" security, but just one more sanity check.
    //

    PROPID      aPropId[2] = { PROPID_QM_SECURITY,
                               PROPID_QM_SECURITY_INFORMATION } ;
    PROPVARIANT aPropVar[2] ;
    aPropVar[0].vt = VT_NULL ;
    aPropVar[1].vt = VT_UI4 ;
    aPropVar[1].ulVal = DACL_SECURITY_INFORMATION ;

    hr = DSCoreGetProps( MQDS_MACHINE,
                         wszAccountName,
                         NULL,
                         2,
                         aPropId,
                        &RequestContext,
                         aPropVar ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 2080);
    }

    P<BYTE> pBuf = aPropVar[0].blob.pBlobData ;
    BYTE *pTmpBuf = pBuf ;
    SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR *) pTmpBuf ;

    PACL  pDacl = NULL ;
    BOOL  fPresent = FALSE ;
    BOOL  fDefaulted = FALSE ;

    fGet = GetSecurityDescriptorDacl( pSD,
                                     &fPresent,
                                     &pDacl,
                                     &fDefaulted ) ;
    if (!fGet || !pDacl)
    {
        return LogHR(MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR, s_FN, 2050);
    }

    //
    // We have old dacl. Add new sid. The code below is quite "industry
    // standard" in other functions of mqads and mqdscore.
    //
    EXPLICIT_ACCESS expAcss ;
    memset(&expAcss, 0, sizeof(expAcss)) ;

    expAcss.grfAccessPermissions =  MQSEC_MACHINE_SELF_RIGHTS ;
    expAcss.grfAccessMode = GRANT_ACCESS ;

    expAcss.Trustee.pMultipleTrustee = NULL ;
    expAcss.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE ;
    expAcss.Trustee.TrusteeForm = TRUSTEE_IS_SID ;
    expAcss.Trustee.TrusteeType = TRUSTEE_IS_USER ;

    PSID pTmpSid = pCallerSid ;
    expAcss.Trustee.ptstrName = (WCHAR*) pTmpSid ;

    //
    // Obtain new DACL, that merge old one with new ace.
    //
    PACL  pNewDacl = NULL ;
    DWORD dwErr = SetEntriesInAcl( 1,
                                  &expAcss,
                                   pDacl,
                                  &pNewDacl ) ;
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr) ;
        return LogHR(hr, s_FN, 2060);
    }

    CAutoLocalFreePtr pFreeDacl = (BYTE*) pNewDacl ;

    //
    // Create a new security descriptor that contain the new dacl. We
    // need it in order to make it self-relative before writting it back
    // in the active directory.
    //
    SECURITY_DESCRIPTOR sd ;
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION) ;
    SetSecurityDescriptorDacl(&sd, TRUE, pNewDacl, FALSE) ;

    PSECURITY_DESCRIPTOR  pSDOut = NULL ;
    DWORD  dwSDSize = 0 ;

    hr = MQSec_MakeSelfRelative( &sd, &pSDOut, &dwSDSize ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 2070);
    }

    P<BYTE> pBuf1 = (BYTE*) pSDOut ;

    aPropVar[0].blob.pBlobData = pBuf1 ;
    aPropVar[0].blob.cbSize = dwSDSize ;

    hr = DSCoreSetObjectProperties( MQDS_MACHINE,
                                    wszAccountName,
                                    NULL,
                                    2,
                                    aPropId,
                                    aPropVar,
                                   &RequestContext,
                                    NULL ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 2090);
    }

    //
    // See if this computer is also an ex-MQIS server. If yes, add
    // the computer account to the msmqSetting too, so it (the upgraded
    // MQIS server) can update its setting object too.
    //
    // First, retrieve machine guid (guid of msmq Object).
    //
    GUID guidMachine ;
    aPropId[0] = PROPID_QM_MACHINE_ID ;
    aPropVar[0].vt = VT_CLSID ;
    aPropVar[0].puuid = &guidMachine ;

    hr = DSCoreGetProps( MQDS_MACHINE,
                         wszAccountName,
                         NULL,
                         1,
                         aPropId,
                        &RequestContext,
                         aPropVar ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 2110);
    }

    //
    //  From now on don't return errors.
    //  The machine can be an independent client...
    //
    hr = DSCoreUpdateSettingDacl( &guidMachine,
                                   pCallerSid ) ;
    LogHR(hr, s_FN, 2120);

    return MQ_OK ;
}


//+----------------------------------------------------------------------
//
//  HRESULT CanUserCreateConfigObject(IN LPCWSTR pwcsPathName)
//
//  Impersonate the caller and check if he has permission to create the
//  msmqConfiguration object under the given computer object.
//
//+----------------------------------------------------------------------

HRESULT 
CanUserCreateConfigObject(
	IN  LPCWSTR  pwcsComputerName,
	OUT bool    *pfComputerExist 
	)
{
    HRESULT hr = MQ_OK;
    AP<WCHAR> pwcsFullPathName;

    hr = DSCoreGetFullComputerPathName( 
				pwcsComputerName,
				e_RealComputerObject,
				&pwcsFullPathName 
				);
    if (FAILED(hr))
    {
        //
        // assume computer does not exist. This is ok for setup of win9x
        // computer. return ok and go on.
        //
        *pfComputerExist = false;
        return MQ_OK;
    }

    PSECURITY_DESCRIPTOR pSD = NULL;
    SECURITY_INFORMATION  SeInfo = OWNER_SECURITY_INFORMATION |
                                   GROUP_SECURITY_INFORMATION |
                                   DACL_SECURITY_INFORMATION;
    PACL pDacl = NULL;
    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;

    //
    // Obtain owner and present DACL.
    //
    DWORD dwErr = GetNamedSecurityInfo( 
						pwcsFullPathName,
						SE_DS_OBJECT_ALL,
						SeInfo,
						&pOwnerSid,
						&pGroupSid,
						&pDacl,
						NULL,
						&pSD 
						);
    CAutoLocalFreePtr pFreeSD = (BYTE*) pSD;
    if (dwErr != ERROR_SUCCESS)
    {
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT("MQADS, CanUserCreateConfigObject(): fail to GetNamed(%ls), %lut"), pwcsFullPathName, dwErr));

        return LogHR(HRESULT_FROM_WIN32(dwErr), s_FN, 220);
    }

    ASSERT(pSD && IsValidSecurityDescriptor(pSD));
    ASSERT(pOwnerSid && IsValidSid(pOwnerSid));
    ASSERT(pGroupSid && IsValidSid(pGroupSid));
    ASSERT(pDacl && IsValidAcl(pDacl));

    //
    // retrieve sid of computer object to be able to check for the
    // SELF ace.
    //
    PROPID propidSid = PROPID_COM_SID;
    MQPROPVARIANT   PropVarSid;
    PropVarSid.vt = VT_NULL;
    PropVarSid.blob.pBlobData = NULL;

    CDSRequestContext RequestContext (e_DoNotImpersonate, e_ALL_PROTOCOLS);
    hr = DSCoreGetProps( 
			MQDS_COMPUTER,
			pwcsComputerName,
			NULL,
			1,
			&propidSid,
			&RequestContext,
			&PropVarSid 
			);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 230);
    }
    AP<BYTE> pSid = PropVarSid.blob.pBlobData;

    hr = MQSec_AccessCheckForSelf( 
				(SECURITY_DESCRIPTOR*) pSD,
				MQDS_COMPUTER,
				(PSID) pSid,
				RIGHT_DS_CREATE_CHILD,
				TRUE 
				);

    return LogHR(hr, s_FN, 240);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\mqiswreq.h ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    mqiswreq.h

Abstract:

    MQIS message header definition needed for write requests to MSMQ 1.0
    Extracted from mqispkt.h & mqis.h of MSMQ 1.0 sources
    Also contains extracted code of MSMQ 1.0 sources (to be replaced with a common lib with
    the replication service)

Author:


--*/

#ifndef __MQISWREQ_H
#define __MQISWREQ_H

//
// The following is extracted from mqispkt.h of MSMQ 1.0 sources
//
size_t  UnalignedWcslen (const wchar_t UNALIGNED * wcs);

//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
//
//  struct CBasicMQISHeader
//
//*******************************************************************************
//*******************************************************************************
//*******************************************************************************

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CBasicMQISHeader {
public:
    inline CBasicMQISHeader( const unsigned char ucVersion,
                             const GUID *        pguidSiteId,
                             const unsigned char ucOperation);
    inline CBasicMQISHeader();
    static ULONG CalcSize( void);

    inline const unsigned char GetVersion(void) const;
    inline void GetSiteId(GUID * pguidId) const;
    inline const unsigned char GetOperation( void) const;

private:
//
// BEGIN Network Monitor tag
//

    unsigned char   m_ucVersion;
    GUID            m_guidSiteId;
    unsigned char   m_ucOperation;
//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)
/*======================================================================

 Function:     CBasicMQISHeader::CBasicMQISHeader

 Description:  constructor for transmitted message

 =======================================================================*/

inline CBasicMQISHeader::CBasicMQISHeader( const unsigned char ucVersion,
                                           const GUID *        pguidSiteId,
                                           const unsigned char ucOperation) :
                               m_ucVersion( ucVersion),
                               m_ucOperation( ucOperation)
{
	//
	// ISSUE-2000/12/18-ilanh Compiler bug
	//
    memcpy((UNALIGNED GUID*)&m_guidSiteId, pguidSiteId, sizeof(GUID));

}
/*======================================================================

 Function:     CBasicMQISHeader::CBasicMQISHeader

 Description:  constructor for received messages

 =======================================================================*/

inline CBasicMQISHeader::CBasicMQISHeader( )
{

}
/*======================================================================

 Function:     CBasicMQISHeader::CalcSize

 Description:  calculates message size

 =======================================================================*/
inline ULONG CBasicMQISHeader::CalcSize(  void)
{
    return( sizeof(CBasicMQISHeader));
}
/*======================================================================

 Function:     CBasicMQISHeader::GetVersion

 Description:  returns the version number

 =======================================================================*/
inline const unsigned char CBasicMQISHeader::GetVersion(void) const
{
    return m_ucVersion;
}

/*======================================================================

 Function:     CBasicMQISHeader::GetSiteId

 Description:  returns the version number

 =======================================================================*/
inline void CBasicMQISHeader::GetSiteId(GUID * pguidId) const
{
	//
	// ISSUE-2000/12/18-ilanh Compiler bug
	//
    memcpy((UNALIGNED GUID*)pguidId, &m_guidSiteId, sizeof(GUID));
}

/*======================================================================

 Function:     CBasicMQISHeader::GetOperation

 Description:  returns the version number

 =======================================================================*/
inline const unsigned char CBasicMQISHeader::GetOperation(void) const
{
    return m_ucOperation;
}

//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
//
// struct CWriteRequestHeader
//
//*******************************************************************************
//*******************************************************************************
//*******************************************************************************

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CWriteRequestHeader {
public:

    inline CWriteRequestHeader( const unsigned char ucVersion,
                                const GUID *        pguidSiteId,
                                const unsigned char ucOperation,
                                const GUID *        pguidMasterId,
                                const DWORD         dwHandle,
                                const DWORD         dwRequesterNamesize,
                                const WCHAR *       pwcsRequesterName,
                                const DWORD         dwPSCNameSize,
                                const WCHAR *       pwcsPSCName);
    inline  CWriteRequestHeader();

    static ULONG CalcSize(  DWORD             dwRequesterNameLength,
                            DWORD             dwIntermidiatePSCNameLength);

    inline const DWORD GetRequesterNameSize() const;
    inline const DWORD GetIntermidiatePSCNameSize() const;
    inline const GUID * GetOwnerId() const;
    inline void GetHandle( DWORD * pdwHandle) const;
    inline void GetRequesterName(  WCHAR * pBuf, DWORD size) const;
    inline void GetPSCName(  WCHAR * pBuf, DWORD size) const;
private:

//
// BEGIN Network Monitor tag
//
    CBasicMQISHeader  m_BasicHeader;
    GUID              m_guidOwnerId;
    DWORD             m_hInternal;
    DWORD             m_OffsetPSCName;  // if zero, than PSC name not included
    WCHAR             m_wcsNames[0];    //must be last
                                        //includes requester name, and PSC name if required
//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)


/*======================================================================

 Function:     CWriteRequestHeader::CWriteRequestHeader

 Description:  constructor for transmitted messages

 =======================================================================*/
inline CWriteRequestHeader::CWriteRequestHeader(
                                const unsigned char ucVersion,
                                const GUID *        pguidSiteId,
                                const unsigned char ucOperation,
                                const GUID *        pguidMasterId,
                                const DWORD         dwHandle,
                                const DWORD         dwRequesterNamesize,
                                const WCHAR *       pwcsRequesterName,
                                const DWORD         dwPSCNameSize,
                                const WCHAR *       pwcsPSCName) :
                                m_BasicHeader( ucVersion,  pguidSiteId, ucOperation)
{
	//
	// ISSUE-2000/12/18-ilanh Compiler bug
	//
    memcpy((UNALIGNED GUID*)&m_guidOwnerId, pguidMasterId, sizeof(GUID));
    memcpy((UNALIGNED DWORD*)&m_hInternal, &dwHandle, sizeof(DWORD));
    memcpy((UNALIGNED WCHAR*)m_wcsNames, pwcsRequesterName, dwRequesterNamesize);
    if ( dwPSCNameSize)
    {
        m_OffsetPSCName = dwRequesterNamesize / sizeof(WCHAR);

		//
		// ISSUE-2000/12/18-ilanh Compiler bug
		//
        memcpy((UNALIGNED WCHAR*)&m_wcsNames[ m_OffsetPSCName], pwcsPSCName, dwPSCNameSize);
    }
    else
    {
        //
        //  No intermidiate PSC name
        //
        m_OffsetPSCName = 0;
    }

}
/*======================================================================

 Function:     CWriteRequestHeader::CWriteRequestHeader

 Description:  constructor for received messages

 =======================================================================*/
inline CWriteRequestHeader::CWriteRequestHeader()
{
}
/*======================================================================

 Function:     CWriteRequestHeader::CalcSize

 Description:  calculates message size

 =======================================================================*/

inline  ULONG CWriteRequestHeader::CalcSize(  DWORD             dwRequesterNameLength,
                            DWORD             dwIntermidiatePSCNameLength)
{
    return( dwRequesterNameLength +
        dwIntermidiatePSCNameLength +
        sizeof(CWriteRequestHeader) );
}

/*======================================================================

 Function:     CWriteRequestHeader::GetRequesterNameSize

 Description:  return requester name size

 =======================================================================*/
inline const DWORD CWriteRequestHeader::GetRequesterNameSize() const
{
    return( numeric_cast<DWORD>(( 1 + UnalignedWcslen( m_wcsNames)) * sizeof(WCHAR)));
}
/*======================================================================

 Function:     CWriteRequestHeader::GetIntermidiatePSCNameSize

 Description:  return intermidiate psc name size

 =======================================================================*/
inline const DWORD CWriteRequestHeader::GetIntermidiatePSCNameSize() const
{
    if ( m_OffsetPSCName)
    {
        return( numeric_cast<DWORD>(( 1 + UnalignedWcslen( &m_wcsNames[m_OffsetPSCName])) * sizeof(WCHAR)));
    }
    else
    {
        return(0);
    }
}
/*======================================================================

 Function:     CWriteRequestHeader::GetOwnerId

 Description:  return owner id

 =======================================================================*/
inline const GUID * CWriteRequestHeader::GetOwnerId( ) const
{
    return(&m_guidOwnerId);
}
/*======================================================================

 Function:     CWriteRequestHeader::GetHandle

 Description:  return handle

 =======================================================================*/
inline void CWriteRequestHeader::GetHandle( DWORD * pdwHandle) const
{
	//
	// ISSUE-2000/12/18-ilanh Compiler bug
	//
    memcpy((UNALIGNED DWORD*)pdwHandle, &m_hInternal, sizeof(DWORD));
}
/*======================================================================

 Function:     CWriteRequestHeader::GetRequesterName

 Description:  return requester name

 =======================================================================*/
inline void CWriteRequestHeader::GetRequesterName(  WCHAR * pBuf, DWORD size) const
{
	//
	// ISSUE-2000/12/18-ilanh Compiler bug
	//
    memcpy((UNALIGNED WCHAR*)pBuf, m_wcsNames, size);
}
/*======================================================================

 Function:     CWriteRequestHeader::GetPSCName

 Description:  return intermidiate psc name

 =======================================================================*/
inline void CWriteRequestHeader::GetPSCName(  WCHAR * pBuf, DWORD size) const
{
    ASSERT(m_OffsetPSCName != 0);

	//
	// ISSUE-2000/12/18-ilanh Compiler bug
	//
    memcpy((UNALIGNED WCHAR*)pBuf, &m_wcsNames[ m_OffsetPSCName], size);
}

//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
//
// struct CWriteReplyHeader
//
//*******************************************************************************
//*******************************************************************************
//*******************************************************************************

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CWriteReplyHeader {
public:

    inline CWriteReplyHeader( const unsigned char ucVersion,
                                const GUID *        pguidSiteId,
                                const unsigned char ucOperation,
                                const DWORD         hInternal,
                                const HRESULT       hr,
                                const DWORD         dwRequesterNameSize,
                                LPCWSTR             pwcsRequesterName);
    inline  CWriteReplyHeader();

    static ULONG CalcSize(  DWORD             dwRequesterNameLength);

    inline const DWORD GetRequesterNameSize() const;
    inline void GetRequesterName(  WCHAR * pBuf, DWORD size) const;
    inline void GetHandle( DWORD * pdwHandle) const;
    inline void GetResult( HRESULT * pResult) const;

private:

//
// BEGIN Network Monitor tag
//
    CBasicMQISHeader  m_BasicHeader;
    DWORD             m_hInternal;
    HRESULT           m_result;
    WCHAR             m_wcsRequesterName[0]; //must be last

//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

/*======================================================================

 Function:     CWriteReplyHeader::CWriteReplyHeader

 Description:  constructor for transmitted message

 =======================================================================*/
inline CWriteReplyHeader::CWriteReplyHeader(
                                const unsigned char ucVersion,
                                const GUID *        pguidSiteId,
                                const unsigned char ucOperation,
                                const DWORD         hInternal,
                                const HRESULT       hr,
                                const DWORD         dwRequesterNameSize,
                                LPCWSTR             pwcsRequesterName) :
                                m_BasicHeader( ucVersion,  pguidSiteId, ucOperation)
{
	//
	// ISSUE-2000/12/18-ilanh Compiler bug
	//
    memcpy((UNALIGNED DWORD*)&m_hInternal, &hInternal, sizeof(DWORD));
    memcpy((UNALIGNED DWORD*)&m_result, &hr, sizeof(DWORD));
    memcpy((UNALIGNED WCHAR*)m_wcsRequesterName, pwcsRequesterName, dwRequesterNameSize);

}

/*======================================================================

 Function:     CWriteReplyHeader::CWriteReplyHeader

 Description:  constructor for received message

 =======================================================================*/
inline CWriteReplyHeader::CWriteReplyHeader()
{
}

/*======================================================================

 Function:     CWriteReplyHeader::CalcSize

 Description:  calculates message size

 =======================================================================*/
inline  ULONG CWriteReplyHeader::CalcSize(  DWORD             dwRequesterNameLength)
{
    return( dwRequesterNameLength +
        sizeof(CWriteReplyHeader) );
}
/*======================================================================

 Function:     CWriteReplyHeader::GetRequesterName

 Description:  returns requester name

 =======================================================================*/
inline void CWriteReplyHeader::GetRequesterName(  WCHAR * pBuf, DWORD size) const
{
	//
	// ISSUE-2000/12/18-ilanh Compiler bug
	//
    memcpy((UNALIGNED WCHAR*)pBuf, m_wcsRequesterName, size);
}
/*======================================================================

 Function:     CWriteReplyHeader::GetRequesterNameSize

 Description:  returns requester name  size

 =======================================================================*/
inline const DWORD CWriteReplyHeader::GetRequesterNameSize() const
{
    return( numeric_cast<DWORD>(( 1 + UnalignedWcslen( m_wcsRequesterName)) * sizeof(WCHAR)));
}
/*======================================================================

 Function:     CWriteReplyHeader::GetHandle

 Description:  returns handle

 =======================================================================*/
inline void CWriteReplyHeader::GetHandle( DWORD * pdwHandle) const
{
	//
	// ISSUE-2000/12/18-ilanh Compiler bug
	//
    memcpy((UNALIGNED DWORD*)pdwHandle, &m_hInternal, sizeof(DWORD));
}
/*======================================================================

 Function:     CWriteReplyHeader::GetResult

 Description:  returns result parameter

 =======================================================================*/
inline void CWriteReplyHeader::GetResult( HRESULT * pResult) const
{
	//
	// ISSUE-2000/12/18-ilanh Compiler bug
	//
    memcpy((UNALIGNED DWORD*)pResult, &m_result, sizeof(DWORD));
}

//
// The following is extracted from mqis.h of MSMQ 1.0 sources
//
#define DS_PACKET_VERSION   0
#define DS_WRITE_REQUEST        ((unsigned char ) 0x01)
#define DS_WRITE_REPLY          ((unsigned char ) 0x04)
#define DS_WRITE_MSG_TIMEOUT            10 /* 10 sec */
#define DS_WRITE_REQ_PRIORITY   ( MQ_MAX_PRIORITY + 1)
#define MQIS_QUEUE_NAME  L"private$\\"L_REPLICATION_QUEUE_NAME

//
//  Structure for WRITE request/reply
//
typedef struct
{
    DWORD   dwValidationSeq[4];
    HANDLE  hEvent;
    HRESULT hr;
} WRITE_SYNC_INFO;

//
// The following is extracted from ds\mqis\dsglbobj.cpp of MSMQ 1.0 sources
//
CCriticalSection    g_csWriteRequests;

//
// The following is extracted from ds\mqis\writereq.cpp of MSMQ 1.0 sources
//
//-------------------------------------------------------------------
//
//  Helper Class - CWriteSyncInfo
//
//-------------------------------------------------------------------
DWORD ValidationSeq[4] = {4325,4321,5678,8765};

#define WRITE_REQUEST_ADDITIONAL_WAIT 5 /* 5 sec */

class CWriteSyncInfo
{
public:
    CWriteSyncInfo( HANDLE hEvent);
    ~CWriteSyncInfo();
    HRESULT GetHr();
    WRITE_SYNC_INFO * GetWriteSyncInfoPtr();

private:
    WRITE_SYNC_INFO m_WriteSyncInfo;


};
inline CWriteSyncInfo::CWriteSyncInfo(HANDLE hEvent)
{
    memcpy( m_WriteSyncInfo.dwValidationSeq, ValidationSeq, sizeof( ValidationSeq));
    m_WriteSyncInfo.hEvent = hEvent;
}

inline  CWriteSyncInfo::~CWriteSyncInfo()
{
    CS lock( g_csWriteRequests);
    //
    //  mark this class as un-valid
    //
    memset( m_WriteSyncInfo.dwValidationSeq, 0, sizeof( ValidationSeq));
    //
    //  Cleaning
    //
    CloseHandle(m_WriteSyncInfo.hEvent);


}

inline HRESULT CWriteSyncInfo::GetHr()
{
    return( m_WriteSyncInfo.hr);
}

inline WRITE_SYNC_INFO * CWriteSyncInfo::GetWriteSyncInfoPtr()
{
    return( &m_WriteSyncInfo);
}

//
// Start - Needed for NoServerAuth
//
#include "_mqini.h"
#include "_registr.h"
//
// End - Needed for NoServerAuth
//
#if 0 //disabled security
//
// The following is extracted from ds\mqis\recvrepl.cpp of MSMQ 1.0 sources
//
STATIC
BOOL
NoServerAuth( void )
{
    DWORD dwType;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwUseServerAuthWithParent = DEFAULT_SRVAUTH_WITH_PARENT;

    //
    // See if the user wanted to risk getting the public key from a malicious
    // server. On the other hand this way it is more convenient to distribute
    // the new public key. You only need to open the security for a short
    // period of time.
    //
    GetFalconKeyValue(SRVAUTH_WITH_PARENT_REG_NAME,
                      &dwType,
                      &dwUseServerAuthWithParent,
                      &dwSize);

    return dwUseServerAuthWithParent == 0;
}
#endif //0 //disabled security

/*====================================================

RoutineName
    IsValidSyncInfo()

Arguments:

Return Value:

Threads:Receive

=====================================================*/
STATIC BOOL IsValidSyncInfo(WRITE_SYNC_INFO * pWriteSyncInfo)
{
    __try
    {
        //
        //  BUGBUG: this is a potential bug, you can't assume that the memory is invalid
        //      is could have been reallocated. erezh
        //

        if (memcmp(pWriteSyncInfo->dwValidationSeq, ValidationSeq, sizeof(ValidationSeq)))
        {
            return(FALSE);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return( FALSE);
    }
    return(TRUE);
}

#endif //__MQISWREQ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\msgprop.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    msgprop.h

Abstract:

	Message property class.

Author:

    Ilan Herbst    (IlanH)   6-Aug-2000 

--*/

#include "ds_stdh.h"
#include "msgprop.h"
#include <mqprops.h>
#include <tr.h>

#include "msgprop.tmh"

const TraceIdEntry MsgProp = L"Message Properties";

CMsgProperties::CMsgProperties()
{
	m_MsgProps.cProp = xMSG_PROPERTIES_TOTAL_COUNT; 
	m_MsgProps.aPropID = m_paPropId;               
	m_MsgProps.aPropVar = m_paVariant;             
	m_MsgProps.aStatus = NULL;                     

	m_pMsgBodyBuffer = new BYTE[xMSG_BODY_DEFAULT_SIZE];
	m_MsgBodyBufferSize = xMSG_BODY_DEFAULT_SIZE;
		
	InitMsgProp();
}
	
void CMsgProperties::InitMsgProp()
/*++

Routine Description:
	Initialize the Message properties.
	This should be called before every receive of new message.

Arguments:
	None

Returned Value:
	None

--*/
{
	DWORD MsgPropCnt = 0;

	//
	// BODY_SIZE
	//
	m_paPropId[xMSG_PROP_IDX_MSGBODY_LEN] = PROPID_M_BODY_SIZE;       
	m_paVariant[xMSG_PROP_IDX_MSGBODY_LEN].vt = VT_UI4;                  
	m_paVariant[xMSG_PROP_IDX_MSGBODY_LEN].ulVal = m_MsgBodyBufferSize; 
	MsgPropCnt++;

	//
	// BODY_TYPE
	//
	m_paPropId[xMSG_PROP_IDX_MSGBODY_TYPE] = PROPID_M_BODY_TYPE;       
	m_paVariant[xMSG_PROP_IDX_MSGBODY_TYPE].vt = VT_UI4;                  
	m_paVariant[xMSG_PROP_IDX_MSGBODY_TYPE].ulVal = 0; 
	MsgPropCnt++;
	 
	//
	// BODY
	//
	m_paPropId[xMSG_PROP_IDX_MSGBODY] = PROPID_M_BODY;               
	m_paVariant[xMSG_PROP_IDX_MSGBODY].vt = VT_VECTOR|VT_UI1; 
	m_paVariant[xMSG_PROP_IDX_MSGBODY].caub.cElems = m_MsgBodyBufferSize;  
	m_paVariant[xMSG_PROP_IDX_MSGBODY].caub.pElems = m_pMsgBodyBuffer;
	MsgPropCnt++;

	//
	// AUTHENTICATED
	//
	m_paPropId[xMSG_PROP_IDX_AUTHENTICATED] = PROPID_M_AUTHENTICATED;               
	m_paVariant[xMSG_PROP_IDX_AUTHENTICATED].vt = VT_UI1; 
	MsgPropCnt++;

	//
	// CLASS
	//
	m_paPropId[xMSG_PROP_IDX_CLASS] = PROPID_M_CLASS; 
	m_paVariant[xMSG_PROP_IDX_CLASS].vt = VT_UI2;        
	MsgPropCnt++;

	//
	// RESP_QUEUE_LEN
	//
	m_paPropId[xMSG_PROP_IDX_RESPQNAME_LEN] = PROPID_M_RESP_QUEUE_LEN;  
	m_paVariant[xMSG_PROP_IDX_RESPQNAME_LEN].vt = VT_UI4;               
	m_paVariant[xMSG_PROP_IDX_RESPQNAME_LEN].ulVal = xMSG_RESP_QUEUE_BUFFER_SIZE_IN_WCHARS;    
	MsgPropCnt++;

	//
	// RESP_QUEUE
	//
	m_paPropId[xMSG_PROP_IDX_RESPQNAME] = PROPID_M_RESP_QUEUE;         
	m_paVariant[xMSG_PROP_IDX_RESPQNAME].vt = VT_LPWSTR;               
	m_paVariant[xMSG_PROP_IDX_RESPQNAME].pwszVal = m_pResponseQueueBuffer; 
	MsgPropCnt++;

	ASSERT(("mismatch in the number of messageg properties", MsgPropCnt == xMSG_PROPERTIES_TOTAL_COUNT));
}


BYTE* CMsgProperties::MsgBody()
{
	return m_paVariant[xMSG_PROP_IDX_MSGBODY].caub.pElems;
}


void CMsgProperties::ReAllocMsgBody()
/*++

Routine Description:
	Reallocates the buffer used to hold the message body
	The current msg body length is used to determine the 
    size of the new buffer.

Arguments:
	None

Returned Value:
	None

--*/
{
	DWORD dwBufferSize = m_paVariant[xMSG_PROP_IDX_MSGBODY_LEN].ulVal;

	TrTRACE(MsgProp, "ReAllocMsgBody Prev = %d, Requested = %d", m_MsgBodyBufferSize, dwBufferSize);

	AP<BYTE> Temp = new BYTE[dwBufferSize];

	m_pMsgBodyBuffer.free();
	m_pMsgBodyBuffer = Temp.detach();
	m_MsgBodyBufferSize = dwBufferSize;

	//
	// Update the MSG_PROPS of MsgBodySize, MsgBody 
	//
	m_paVariant[xMSG_PROP_IDX_MSGBODY_LEN].ulVal = m_MsgBodyBufferSize; 
	m_paVariant[xMSG_PROP_IDX_MSGBODY].caub.cElems = m_MsgBodyBufferSize;  
	m_paVariant[xMSG_PROP_IDX_MSGBODY].caub.pElems = m_pMsgBodyBuffer;

}


ULONG CMsgProperties::MsgBodyLen()
{
	return(m_paVariant[xMSG_PROP_IDX_MSGBODY_LEN].ulVal);
}


bool CMsgProperties::IsAuthenticated()
{
	return(!!m_paVariant[xMSG_PROP_IDX_AUTHENTICATED].bVal);
}


USHORT CMsgProperties::MsgClass()
{
	return(m_paVariant[xMSG_PROP_IDX_CLASS].uiVal);
}


long CMsgProperties::ResponseQueueNameLen()
{
	return(m_paVariant[xMSG_PROP_IDX_RESPQNAME_LEN].ulVal);
}


LPCWSTR CMsgProperties::ResponseQueueName()
{
	return(m_paVariant[xMSG_PROP_IDX_RESPQNAME].pwszVal);
}


void CMsgProperties::MessageSummary()
/*++

Routine Description:
	Print Summary of the message.

Arguments:
	None

Returned Value:
	None

--*/
{
	static LONG l_MsgIndex = 0;
	InterlockedIncrement(&l_MsgIndex);

	TrTRACE(MsgProp, "Message Index = %d", l_MsgIndex);
	TrTRACE(MsgProp, "Body Length = %d", m_paVariant[xMSG_PROP_IDX_MSGBODY_LEN].ulVal);
	TrTRACE(MsgProp, "Authenticated = %d", m_paVariant[xMSG_PROP_IDX_AUTHENTICATED].bVal);
	TrTRACE(MsgProp, "Class = %d", m_paVariant[xMSG_PROP_IDX_CLASS].uiVal);
	if (m_paVariant[xMSG_PROP_IDX_RESPQNAME].pwszVal != NULL) 
	{
		TrTRACE(MsgProp, "Response Q Name = %ls", m_paVariant[xMSG_PROP_IDX_RESPQNAME].pwszVal);
	}
	else
	{
		TrTRACE(MsgProp, "Response Q Name is <NULL>");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\msgprop.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    msgprop.h

Abstract:

	Message property class.

Author:

    Ilan Herbst    (IlanH)   6-Aug-2000 

--*/

#ifndef _CMSGPROP_MQADS_H_
#define _CMSGPROP_MQADS_H_

#include <mqtypes.h>
#include <_mqdef.h>
#include <qformat.h>

//-------------------------------------------------------------------
//
// class CMsgProperties
//
//-------------------------------------------------------------------
class CMsgProperties  
{

private:

	//
	// Indexs for each message property into the array of message properties.
	//
	enum {
		xMSG_PROP_IDX_MSGBODY_LEN = 0,
		xMSG_PROP_IDX_MSGBODY_TYPE,
		xMSG_PROP_IDX_MSGBODY, 
		xMSG_PROP_IDX_AUTHENTICATED,
		xMSG_PROP_IDX_CLASS, 
		xMSG_PROP_IDX_RESPQNAME_LEN, 
		xMSG_PROP_IDX_RESPQNAME,

		xMSG_PROPERTIES_TOTAL_COUNT
	};

	enum	{xMSG_RESP_QUEUE_BUFFER_SIZE_IN_WCHARS = MQ_MAX_Q_NAME_LEN + 1};

	enum	{xMSG_BODY_DEFAULT_SIZE = 1024*10};

public:		

	CMsgProperties();

	void InitMsgProp();

	ULONG MsgBodyLen();
	BYTE* MsgBody();
	void ReAllocMsgBody();

	long ResponseQueueNameLen();
	LPCWSTR ResponseQueueName();

	bool IsAuthenticated();
	USHORT MsgClass();

	void MessageSummary();

public:		

	MQMSGPROPS m_MsgProps;
	MQPROPVARIANT m_paVariant[xMSG_PROPERTIES_TOTAL_COUNT];
	MSGPROPID m_paPropId[xMSG_PROPERTIES_TOTAL_COUNT];
	DWORD m_MsgBodyBufferSize;
	WCHAR m_pResponseQueueBuffer[xMSG_RESP_QUEUE_BUFFER_SIZE_IN_WCHARS];
	AP<BYTE> m_pMsgBodyBuffer;

};

#endif 	// _CMSGPROP_MQADS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\qmrepl_c_.c ===
#pragma warning(push, 3)
#include <qmrepl_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqads.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\rpccli.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rpccli.cpp

Abstract:

    Implementation of rpc client to the QM
	this interface is used for sending packets.
	This code was taken from replserv\mq1repl\replrpc.cpp

Author:

    Ilan Herbst    (IlanH)   9-July-2000 

--*/

#include "ds_stdh.h"
#include "rpccli.h"
#include "qmrepl.h"

#include "rpccli.tmh"

static WCHAR *s_FN=L"mqads/rpccli";

HRESULT 
GetRpcClientHandle(
	handle_t *phBind
	)
/*++

Routine Description:
	Get RPC binding handle for the client.

Arguments:
	phBind - out RPC binding handle.

Returned Value:
	MQ_OK if success, else error code. 

--*/
{
    static handle_t s_hBind = NULL;
    if (s_hBind)
    {
        *phBind = s_hBind;
        return MQ_OK;
    }

    WCHAR *wszStringBinding = NULL;

    RPC_STATUS status = RpcStringBindingCompose( 
							NULL,
							QMREPL_PROTOCOL,
							NULL,
							QMREPL_ENDPOINT,
							QMREPL_OPTIONS,
							&wszStringBinding
							);

    if (status != RPC_S_OK)
    {
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 30);	// MQ_E_RPC_BIND_COMPOSE
    }

    status = RpcBindingFromStringBinding(
				wszStringBinding,
				&s_hBind
				);

    if (status != RPC_S_OK)
    {
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 35);	// MQ_E_RPC_BIND_BINDING
    }

	//
	// LogHR(MQ_I_RPC_BINDING, s_FN, 36);
	//

    status = RpcStringFree(&wszStringBinding);

    *phBind = s_hBind;
    return MQ_OK;
}


HRESULT 
QMRpcSendMsg(
    IN handle_t hBind,
    IN LPWSTR lpwszDestination,
    IN DWORD dwSize,
    IN const unsigned char *pBuffer,
    IN DWORD dwTimeout,
    IN unsigned char bAckMode,
    IN unsigned char bPriority,
    IN LPWSTR lpwszAdminResp
	)
/*++

Routine Description:
    Sends message for destination QM using QMSendReplMsg (RPC)

Arguments:
    hBind - RPC handle
    lpwszDestination - destination queue
    dwSize - pBuffer size
    pBuffer - message body property
    dwTimeout - timeout property
    bAckMode - acknowledge mode
    bPriority - message priority
    lpwszAdminResp - admin queue

Return Value:
    MQ_OK if success, else error code

--*/
{
	__try
    {
		return QMSendReplMsg( 
					hBind,
					lpwszDestination,
					dwSize,
					pBuffer,
					dwTimeout,
					bAckMode,
					bPriority,
					lpwszAdminResp
					);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
		//
		// ISSUE-2000/07/25-ilanh  is this the correct error - check with ronith
		//
        return MQ_ERROR_NO_RESPONSE_FROM_OBJECT_SERVER; // MQ_E_RPC_QM_NOT_RESPOND
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\usercert.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    usercert.h

Abstract:
    Classes to manipulate use certificate blob


Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __USERCERT_H__
#define __USERCERT_H__
//-----------------------------------------
// User object : certificate attribute structure
//
// In MSMQ each user has a certificate per machine,
// In NT5 there is one user object per user.
// Therefore msmq-certificate property in NT5 will contain
// multiple values 
//-----------------------------------------


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CUserCert {
public:
    inline CUserCert( const GUID&    guidDigest,
                      const DWORD    dwCertLength,
                      const BYTE *   pCert);
    inline CUserCert();
    inline CUserCert( const CUserCert& other);
    static ULONG CalcSize(
            IN DWORD dwCertLen);

    inline HRESULT CopyIntoBlob( OUT MQPROPVARIANT * pvar) const;

    inline BOOL DoesDigestMatch(
                IN  const GUID *       pguidDigest) const;

    inline DWORD GetSize() const;

    inline BYTE * MarshaleIntoBuffer(
                    IN BYTE * pbBuffer);

private:

    GUID           m_guidDigest;
    DWORD          m_dwCertLength;
    BYTE           m_Cert[0];       // variable length
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

inline CUserCert::CUserCert( 
                      const GUID&    guidDigest,
                      const DWORD    dwCertLength,
                      const BYTE *   pCert)
{
    memcpy(&m_guidDigest, &guidDigest, sizeof(GUID));
    memcpy(&m_dwCertLength, &dwCertLength, sizeof(DWORD));
    memcpy( m_Cert, pCert, dwCertLength);
}
inline CUserCert::CUserCert( 
                  const CUserCert& other)
{
    memcpy(&m_guidDigest, &other.m_guidDigest, sizeof(GUID));
    memcpy(&m_dwCertLength, &other.m_dwCertLength, sizeof(DWORD));
    memcpy( m_Cert, &other.m_Cert, m_dwCertLength);
}

inline CUserCert::CUserCert()
{
}

inline HRESULT CUserCert::CopyIntoBlob( OUT MQPROPVARIANT * pvar) const
{
    if ( pvar->vt != VT_NULL)
    {
        return LogHR(MQ_ERROR, s_FN, 1901);
    }
    if ( m_dwCertLength == 0)
    {
        return LogHR(MQ_ERROR, s_FN, 1902);
    }
    //
    //  allocate memory
    //
    pvar->blob.pBlobData = new BYTE[ m_dwCertLength];
    memcpy( pvar->blob.pBlobData, &m_Cert,  m_dwCertLength);
    pvar->blob.cbSize =  m_dwCertLength;
    pvar->vt = VT_BLOB;
    return( MQ_OK);
}

inline BOOL CUserCert::DoesDigestMatch(
                 IN  const GUID *  pguidDigest) const
{
    return( m_guidDigest == *pguidDigest);
}

inline DWORD CUserCert::GetSize() const
{
    return( sizeof( CUserCert) +  m_dwCertLength);
}

inline ULONG CUserCert::CalcSize( 
                   IN DWORD dwCertLen)
{
    return( sizeof(CUserCert) + dwCertLen);
}

inline BYTE * CUserCert::MarshaleIntoBuffer(
                         IN BYTE * pbBuffer)
{
    BYTE * pNextToFill = pbBuffer;
    memcpy( pNextToFill, &m_guidDigest, sizeof(GUID));
    pNextToFill += sizeof(GUID);
    memcpy( pNextToFill, &m_dwCertLength, sizeof(DWORD));
    pNextToFill += sizeof(DWORD);
    memcpy( pNextToFill, &m_Cert, m_dwCertLength);
    pNextToFill += m_dwCertLength;
    return( pNextToFill);

}


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


struct CUserCertBlob {
public:
    inline CUserCertBlob( 
                    IN const CUserCert *     pUserCert); 
    inline CUserCertBlob();
    static ULONG CalcSize( void);

    inline HRESULT GetUserCert( IN  const GUID *       pguidDigest,
                         OUT const CUserCert ** ppUserCert) const;

    inline DWORD GetNumberOfCerts();

    inline HRESULT GetCertificate(
                          IN  const DWORD     dwCertificateNumber,
                          OUT MQPROPVARIANT * pvar
                          );

    inline void MarshaleIntoBuffer(
                  IN BYTE * pbBuffer);
    inline void IncrementNumCertificates();

    inline HRESULT RemoveCertificateFromBuffer(
                            IN  const GUID *     pguidDigest,
                            IN  DWORD            dwTotalSize,
                            OUT DWORD *          pdwCertSize);

private:

    DWORD           m_dwNumCert;
    CUserCert       m_userCert;
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

inline CUserCertBlob::CUserCertBlob( 
              IN const CUserCert *     pUserCert):
              m_userCert(*pUserCert)
{
    m_dwNumCert = 1;
}

inline CUserCertBlob::CUserCertBlob()
{
}

inline HRESULT CUserCertBlob::GetUserCert(
                         IN  const GUID *       pguidDigest,
                         OUT const CUserCert ** ppUserCert) const
{
    if ( m_dwNumCert == 0)
    {
        return LogHR(MQ_ERROR, s_FN, 1903);
    }
    const CUserCert * pUserCert = &m_userCert;
    for (DWORD i = 0; i < m_dwNumCert; i++)
    {
        if (pUserCert->DoesDigestMatch( pguidDigest))
        {
            *ppUserCert = pUserCert;
            return( MQ_OK);
        }
        //
        //  Move to next certificate
        //
        pUserCert += pUserCert->GetSize();
    }
    //
    //  No match digest in the user cert blob
    //
    return LogHR(MQ_ERROR, s_FN, 1904);

}
inline DWORD CUserCertBlob::GetNumberOfCerts()
{
    return( m_dwNumCert);
}

inline HRESULT CUserCertBlob::GetCertificate(
                          IN  const DWORD     dwCertificateNumber,
                          OUT MQPROPVARIANT * pvar
                          )
{
    HRESULT hr;

    if ( dwCertificateNumber > m_dwNumCert)
    {
        return LogHR(MQ_ERROR, s_FN, 1905));
    }
    const CUserCert * pUserCert = &m_userCert;
    //
    //  Move to certificate number dwCertificateNumber
    //
    for (DWORD i = 0; i < dwCertificateNumber; i++)
    {
        //
        //  Move to next certificate
        //
        pUserCert = (const CUserCert * )((const unsigned char *)pUserCert + pUserCert->GetSize());
    }
    pvar->vt = VT_NULL;
    hr = pUserCert->CopyIntoBlob(
                            pvar
                            );
    return LogHR(hr, s_FN, 1906);
}

inline ULONG CUserCertBlob::CalcSize( void)
{
    //
    //  Just the size of CUserCertBlob without 
    //  the size of m_userCert
    //
    return( sizeof(CUserCertBlob) - CUserCert::CalcSize(0));
}

inline void CUserCertBlob::MarshaleIntoBuffer(
                  IN BYTE * pbBuffer)
{
    ASSERT( m_dwNumCert == 1);
    memcpy( pbBuffer, &m_dwNumCert, sizeof(DWORD));
    m_userCert.MarshaleIntoBuffer( pbBuffer + sizeof(DWORD));

}
inline void CUserCertBlob::IncrementNumCertificates()
{
    m_dwNumCert++;
}

inline HRESULT CUserCertBlob::RemoveCertificateFromBuffer(
                            IN  const GUID *     pguidDigest,
                            IN  DWORD            dwTotalSize,
                            OUT DWORD *          pdwCertSize)
{
    const CUserCert * pUserCert = &m_userCert;
    //
    //  Find the certificate to be removed according to its digest
    //
    BOOL fFoundCertificate = FALSE;
    for ( DWORD i = 0; i < m_dwNumCert; i++)
    {
        if ( pUserCert->DoesDigestMatch( pguidDigest)) 
        {
            fFoundCertificate = TRUE;
            break;
        }
        //
        //  Move to next certificate
        //
        pUserCert = (const CUserCert * )((const unsigned char *)pUserCert + pUserCert->GetSize());
    }
    if ( !fFoundCertificate)
    {
        return LogHR(MQ_ERROR, s_FN, 1907);
    }
    //
    //  copy buffer ( i.e. copy the remaining certificates over the removed one)
    //
    DWORD dwCertSize =  pUserCert->GetSize();
    DWORD dwSizeToCopy =  dwTotalSize - 
                         (((const unsigned char *)pUserCert) - ((const unsigned char *)&m_userCert))
                         - dwCertSize - sizeof(m_dwNumCert);
    if ( dwSizeToCopy)
    {
        memcpy( (unsigned char *)pUserCert,
                (unsigned char *)pUserCert + dwCertSize,
                dwSizeToCopy);
    }
    *pdwCertSize = dwCertSize;
    m_dwNumCert--;
    return(MQ_OK);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\wrtreq.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
    wrtreq.cpp

Abstract:
    write requests to NT4 owner sites

Author:

    Raanan Harari (raananh)
    Ilan Herbst    (ilanh)   9-July-2000 

--*/
#include "ds_stdh.h"
#include "bupdate.h"
#include "dsutils.h"
#include "mqiswreq.h"
#include "dsglbobj.h"
#include "privque.h"
#include "uniansi.h"
#include "wrtreq.h"
#include "_secutil.h"
#include "notify.h"
#include "qmperf.h" //BUGBUG: UPDATE_COUNTER might need static link to QM dll
#include "dscore.h"
#include "adserr.h"
#include <mqsec.h>
#include "rpccli.h"
#include <mqutil.h>
#include <mqexception.h>
#include <mqformat.h>

#include "wrtreq.tmh"

//
// mqwin64.cpp may be included only once in a module
//
#include <mqwin64.cpp>

static WCHAR *s_FN=L"mqads/wrtreq";

#define NT5PEC_MQIS_QUEUE_NAME  L"private$\\"L_NT5PEC_REPLICATION_QUEUE_NAME

HRESULT MQADSpSplitAndFilterQueueName(
                IN  LPCWSTR             pwcsPathName,
                OUT LPWSTR *            ppwcsMachineName,
                OUT LPWSTR *            ppwcsQueueName );

//
// The following is slightly modified from ds\mqis\recvrepl.cpp of MSMQ 1.0 sources
//

//
// public class functions
//

CGenerateWriteRequests::CGenerateWriteRequests()
{
    m_dwWriteMsgTimeout = DS_WRITE_MSG_TIMEOUT;
    m_dwWaitTime = (DS_WRITE_MSG_TIMEOUT + WRITE_REQUEST_ADDITIONAL_WAIT) * 1000 * 2;
    m_dwRefreshNT4SitesInterval = MSMQ_DEFAULT_NT4SITES_ADSSEARCH_INTERVAL * 1000;
    m_dwLastRefreshNT4Sites = 0;
    m_guidMyQMId = GUID_NULL;
    m_guidMySiteId = GUID_NULL;
    m_fIsPEC = FALSE;
    m_fInited = FALSE;
    m_fExistNT4PSC = TRUE; //until proven otherwise...
    m_fExistNT4BSC = TRUE; //until proven otherwise...
    m_fDummyInitialization = FALSE;
    m_pwszIntermediatePSC = NULL;
    m_cbIntermediatePSC = 0;
}


CGenerateWriteRequests::~CGenerateWriteRequests()
{
    //
    // members are auto release
    //
}


STATIC HRESULT CheckIfWeArePEC(BOOL * pfIsPEC)
/*++

Routine Description:
    Checks if we are a PEC (in mixed mode)
    We do this by looking at the registry to find if we were the NT4 old PEC

Arguments:
    pfIsPEC - returned whether we are PEC or not

Return Value:
    HRESULT

--*/
{
    //
    // get the service type
    //
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    DWORD dwServiceType;
    long rc = GetFalconKeyValue(MSMQ_MQS_REGNAME, &dwType, &dwServiceType, &dwSize);
    // [adsrv] We must keep MSMQ_MQS_REGNAME in registry for all machines (even pure NT5)
    if (rc != ERROR_SUCCESS)
    {
        //
        // value doesn't exist
        //
        ASSERT(0);
        return LogHR(HRESULT_FROM_WIN32(rc), s_FN, 10);
    }

    //
    // return results
    //
    if (dwServiceType == SERVICE_PEC)
    {
        *pfIsPEC = TRUE;
    }
    else
    {
        *pfIsPEC = FALSE;
    }
    return MQ_OK;
}


STATIC BOOLEAN GetServerNameFromSettingsDN(IN LPCWSTR pwszSettingsDN,
                                           OUT LPWSTR * ppwszServerName)
/*++

Routine Description:
    Gets server name from the MSMQ Settings DN in configuration site servers

Arguments:
    pwszSettingsDN   - MSMQ Settings DN
    ppwszServerName  - Server name returned

Return Value:
    BOOLEAN

--*/
{
    //
    // skip CN=MSMQ Settings,CN=
    //
    LPWSTR pwszTmp = wcschr(pwszSettingsDN, L',');
    if (pwszTmp)
    {
        pwszTmp = wcschr(pwszTmp, L'=');
        if (pwszTmp)
        {
            pwszTmp++;
        }
    }
    if (!pwszTmp)
    {
        LogBOOL(FALSE, s_FN, 1908);
        return FALSE;
    }

    //
    // find end of server name
    //
    LPWSTR pwszTmpEnd = wcschr(pwszTmp, L',');
    if (!pwszTmpEnd)
    {
        LogBOOL(FALSE, s_FN, 1909);
        return FALSE;
    }

    //
    // copy server name
    //
    ULONG_PTR cch = pwszTmpEnd - pwszTmp;
    AP<WCHAR> pwszServerName = new WCHAR [cch + 1];
    memcpy(pwszServerName, pwszTmp, cch*sizeof(WCHAR));
    pwszServerName[cch] = L'\0';

    //
    // return results
    //
    *ppwszServerName = pwszServerName.detach();
    return TRUE;
}


const PROPID x_rgNT5PecPropIDs[] = {PROPID_SET_FULL_PATH,
                                    PROPID_SET_OLDSERVICE,
                                    PROPID_SET_NT4};
enum
{
    e_NT5Pec_FULL_PATH,
    e_NT5Pec_SERVICE,
    e_NT5Pec_NT4
};
const MQCOLUMNSET x_columnsetNT5Pec = {ARRAY_SIZE(x_rgNT5PecPropIDs), const_cast<PROPID *>(x_rgNT5PecPropIDs)};

STATIC HRESULT GetMixedModePECInfo(LPWSTR *ppwszPecName)
/*++

Routine Description:
    Queries the Active DS for the mixed mode PEC.
    The mixed mode PEC is the only MSMQ DS server with ServiceType == SERVICE_PEC

Arguments:
    ppwszPecName - returned PEC name

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // I can use the same query for NT4 PSC's to query for the NT5 PEC in mixed mode, even
    // though it also queries for NT4 flag. Since in mixed mode the PEC was always migrated
    // from NT4, it has the NT4 flag, this time with the value of 0.
    //
    // find all msmq servers that have an NT4 flags >= 0 AND services == PEC
    //
    MQRESTRICTION restrictionNT5Pec;
    MQPROPERTYRESTRICTION propertyRestriction[2];
    restrictionNT5Pec.cRes = ARRAY_SIZE(propertyRestriction);
    restrictionNT5Pec.paPropRes = propertyRestriction;
    //
    // services == PEC.
    //
    propertyRestriction[0].rel = PREQ;
    propertyRestriction[0].prop = PROPID_SET_SERVICE;
    propertyRestriction[0].prval.vt = VT_UI4;
    propertyRestriction[0].prval.ulVal = SERVICE_PEC;
    //
    // NT4 flags >= 0. We need == 0, but we don't have that in the query, and it doesn't worth
    // to add a new query just for that since currently for NT5 there are no servers with
    // services >= PEC and NT4 flags > 0.
    //
    propertyRestriction[1].rel = PRGE;
    propertyRestriction[1].prop = PROPID_SET_NT4;
    propertyRestriction[1].prval.vt = VT_UI4;
    propertyRestriction[1].prval.ulVal = 0;

    //
    // start search
    //
    CAutoDSCoreLookupHandle hLookup;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = DSCoreLookupBegin(NULL,
                           &restrictionNT5Pec,
                           const_cast<MQCOLUMNSET*>(&x_columnsetNT5Pec),
                           NULL,
                           &requestDsServerInternal,
                           &hLookup);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("GetMixedModePECInfo:DSCoreLookupBegin()=%lx"), hr));
        return LogHR(hr, s_FN, 20);
    }

    //
    // allocate propvars array for NT5 PEC
    //
    CAutoCleanPropvarArray cCleanProps;
    PROPVARIANT * rgPropVars = cCleanProps.allocClean(ARRAY_SIZE(x_rgNT5PecPropIDs));

    //
    // Should be exactly one result, the NT5 mixed mode PEC.
    //
    DWORD cProps = ARRAY_SIZE(x_rgNT5PecPropIDs);

    hr = DSCoreLookupNext(hLookup, &cProps, rgPropVars);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("GetMixedModePECInfo:DSCoreLookupNext()=%lx"), hr));
        return LogHR(hr, s_FN, 30);
    }

    //
    // check if there is a server
    //
    if (cProps < ARRAY_SIZE(x_rgNT5PecPropIDs))
    {
        //
        // this is an error, should be an NT5 PEC in the DS.
        //
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("GetMixedModePECInfo:No servers found")));
        ASSERT(0);
        //
        // BUGBUG, should raise an event
        //
        return LogHR(MQ_ERROR, s_FN, 40);
    }
    //
    // sanity check - the service == PEC (and not greater), NT4 flag == 0 (and not greater)
    //
    if ((rgPropVars[e_NT5Pec_SERVICE].ulVal != SERVICE_PEC) ||
        (rgPropVars[e_NT5Pec_NT4].ulVal != 0))
    {
        //
        // this is an error, this should be the NT5 PEC
        //
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("GetMixedModePECInfo:Found server is not NT5 PEC")));
        ASSERT(0);
        //
        // BUGBUG, should raise an event
        //
        return LogHR(MQ_ERROR, s_FN, 50);
    }

    //
    // Get PEC name
    //
    ASSERT(rgPropVars[e_NT5Pec_FULL_PATH].vt == VT_LPWSTR);
    AP<WCHAR> pwszPecName;
    if (!GetServerNameFromSettingsDN(rgPropVars[e_NT5Pec_FULL_PATH].pwszVal,
                                     &pwszPecName))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("GetMixedModePECInfo::GetServerNameFromSettingsDN(%ls) failed"), rgPropVars[e_NT5Pec_FULL_PATH].pwszVal));
        return LogHR(MQ_ERROR, s_FN, 60);
    }

    //
    // return results
    //
    *ppwszPecName = pwszPecName.detach();
    return MQ_OK;
}


STATIC QUEUE_FORMAT * CreateQueueFormat(LPCWSTR pwszMachineName, LPCWSTR pwszQueueName)
/*++

Routine Description:
    creates and returns a queue format based on OS:machine\queue
    Caller is responsible to call DisposeString on the queue format

Arguments:
    pwszMachineName - machine name
    pwszQueueName   - queue name

Return Value:
    QUEUE_FORMAT pointer

--*/
{
    DWORD dwLength =
            FN_DIRECT_OS_TOKEN_LEN +            // "OS:"
            wcslen(pwszMachineName) +     // "machineName"
            wcslen(pwszQueueName) + 2;    // "\\queuename\0"
    //
    // alloc and fill string
    //
    AP<WCHAR> pwszFormatName = new WCHAR[dwLength];
    swprintf(
            pwszFormatName,
            FN_DIRECT_OS_TOKEN  // "OS:"
            L"%s\\%s",          // "machineName\queuename"
            pwszMachineName,
            pwszQueueName);
    //
    // create queue format
    //
    QUEUE_FORMAT *pqf = new QUEUE_FORMAT((LPWSTR)pwszFormatName);
    pwszFormatName.detach(); //responsibility passed to QUEUE_FORMAT
    return pqf;
}


HRESULT  
CGenerateWriteRequests::GetMQISAdminQueueName(
    WCHAR **ppwQueueFormatName,
    BOOL    fIsPec 
    )
/*++

Routine Description:
	Get MQIS Admin queue FormatName for write requests response queue.

	OS:machine_name\private$\mqis_queue$ or nt5pec_mqis_queue$

	the function allocate the QueueFormatName string, which need to be free by the caller.

Arguments:
	ppwQueueFormatName - pointer to QueueFormatName string. (need to be free by the caller)
	fIsPec - flag to indicate if we are mixed mode pec.

Returned Value:
	MQ_OK if success, else error code. 

--*/
{
    WCHAR *pQueueName = MQIS_QUEUE_NAME;  // private$\mqis_queue$
    if (fIsPec)
    {
        pQueueName = NT5PEC_MQIS_QUEUE_NAME;  // private$\nt5pec_mqis_queue$
    }

    DWORD Length = 1 ; //  '\'

    //
    // Get machine name
    //
	DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
	WCHAR MyMachineName[MAX_COMPUTERNAME_LENGTH + 1];

    HRESULT hr = GetComputerNameInternal(MyMachineName, &dwSize);
    if(FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::GetComputerNameInternal()=%lx"), hr));
        return LogHR(hr, s_FN, 187);
    }

    Length += FN_DIRECT_OS_TOKEN_LEN;
    Length += wcslen(MyMachineName);
    Length += lstrlen(pQueueName) + 1;

    AP<WCHAR> lpwFormatName = new WCHAR[Length + 4];
    WCHAR pNum[2] = {PN_DELIMITER_C,0};

    wcscpy(lpwFormatName, FN_DIRECT_OS_TOKEN);
    wcscat(lpwFormatName, MyMachineName);
    wcscat(lpwFormatName, pNum);
    wcscat(lpwFormatName, pQueueName);

    *ppwQueueFormatName = lpwFormatName.detach();

    return MQ_OK ;
}


HRESULT CGenerateWriteRequests::Initialize()
/*++

Routine Description:
    Initializes the generation of write requests to NT4 PSC's in mixed mode

Arguments:

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // sanity check
    //
    if (m_fInited)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 90);
    }

    //
    // we need to check if we are in mixed mode. If we're not in mixed mode, and we are
    // a pure NT5 enterprise, we don't have to do write requests, and we abort the init.
    //
    // with the lack of a better indication, we read the NT4 PSC's table from ADS (something
    // we need anyway). If there are no NT4 PSC's, then we are in PURE NT5 enterprise, otherwise
    // we're in mixed mode.
    //
    //  Read RefreshNT4SitesInterval key.
    //  This key is optional and may not be in registry. We dont accept 0 (zero).
    //
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    DWORD dwRefreshNT4SitesInterval;
    long rc = GetFalconKeyValue( MSMQ_NT4SITES_ADSSEARCH_INTERVAL_REGNAME, &dwType, &dwRefreshNT4SitesInterval, &dwSize);
    if ((rc == ERROR_SUCCESS) && (dwRefreshNT4SitesInterval > 0))
    {
        m_dwRefreshNT4SitesInterval = dwRefreshNT4SitesInterval * 1000;
    }
    //
    //  Build NT4Sites and NT4PscQMs maps, and associated data
    //
    hr = RefreshNT4Sites();
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::Initialize:RefreshNT4Sites()=%lx"), hr));
        return LogHR(hr, s_FN, 100);
    }

    //
    // return immediately if wer'e not in mixed mode
    //
    if (!IsInMixedModeWithNT4PSC())
    {
        m_fInited = TRUE;
        return MQ_OK;
    }


    //
    // get this MSMQ DS info
    //
    GetThisMqDsInfo(&m_guidMySiteId, &m_pwszServerName);

    //
    //  Read WriteMsgTimeout key
    //  This key is optional and may not be in registry. We dont accept 0 (zero).
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    DWORD   dwWriteMsgTimeout;
    rc = GetFalconKeyValue( MSMQ_MQIS_WRITETIMEOUT_REGNAME, &dwType, &dwWriteMsgTimeout, &dwSize);
    if ((rc == ERROR_SUCCESS) && (dwWriteMsgTimeout > 0))
    {
        m_dwWriteMsgTimeout = dwWriteMsgTimeout;
    }

    //
    // Read QMId from registry
    //
    dwSize = sizeof(GUID);
    dwType = REG_BINARY;
    rc = GetFalconKeyValue(MSMQ_QMID_REGNAME, &dwType, &m_guidMyQMId, &dwSize);
    if (rc != ERROR_SUCCESS)
    {
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT("Can't get QM ID from registery. Error %lx"), rc));
        LogNTStatus(rc, s_FN, 120);
        return MQ_ERROR;
    }

    //
    // check if we are a mixed mode PEC
    //
    hr = CheckIfWeArePEC(&m_fIsPEC);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::Initialize:CheckIfWeArePEC()=%lx"), hr));
        return LogHR(hr, s_FN, 130);
    }

    //
    //  If we are not the mixed mode PEC, we need to send write requests only to that PEC
    //  otherwise the write request will be rejected by the NT4 PSC's (they don't recognize
    //  NT5 servers as PSC's).
    //
    if (!m_fIsPEC)
    {
        //
        // get the name of the mixed mode PEC
        //
        hr = GetMixedModePECInfo(&m_pwszRemotePECName);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::Initialize:GetMixedModePECInfo()=%lx"), hr));
            return LogHR(hr, s_FN, 140);
        }

        //
        // get the queue format of the mixed mode PEC
        //
        m_pqfRemotePEC = CreateQueueFormat(m_pwszRemotePECName, MQIS_QUEUE_NAME);
    }

    //
    //  Get a queue for write request responses, and number of request hops
    //
    DWORD dwNumberOfRequestHops;
    if (m_fIsPEC)
    {
        //
        // this is a mixed mode PEC. There is a replication service running that is using the
        // mqis_queue$ for inbound, so we use a different queue. the replication service
        // will forward the write request responses to this different queue
        //

        //
        //  Wait time : three hops, one hop to the other PSC, two hops back (replication service is in the middle)
        //
        dwNumberOfRequestHops = 3;
        //
        //  We dont need an intermediate PSC, so we set it to NULL
        //
        m_pwszIntermediatePSC = NULL;
        m_cbIntermediatePSC = 0;
    }
    else
    {
        //
        // this is not a mixed mode PEC. we use the regular mqis_queue$ for inbound. Notice
        // we should not get anything other than write request responses on it, because we have
        // no NT4 BSC's (migration rules), and we are not recognized by other NT4 PSC's as masters.
        //

        //
        //  Wait time : four hops, one hop to the NT5 PEC, one hop to the NT4 PSC, one back
        //              from the NT4 PSC to the NT5 PEC, and then to us
        //
        dwNumberOfRequestHops = 4;
        //
        //  point to the PEC as an intermediate PSC
        //
        m_pwszIntermediatePSC = m_pwszRemotePECName;
        m_cbIntermediatePSC = (wcslen(m_pwszRemotePECName) + 1) * sizeof(WCHAR);
    }

    //
    //  A limited wait for response
    //
    m_dwWaitTime = (m_dwWriteMsgTimeout + WRITE_REQUEST_ADDITIONAL_WAIT) * 1000 * dwNumberOfRequestHops;

	hr = GetMQISAdminQueueName(&m_WriteReqRespFormatName, m_fIsPEC);

	if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::GetMQISAdminQueueName()=%lx"), hr));
        return LogHR(hr, s_FN, 165);
    }

	//
    //  Start write request response processing
    //
	try
	{
	    m_pWrrMsg = new CWriteRequestsReceiveMsg(m_fIsPEC, m_guidMyQMId);
	}
	catch(const bad_hresult& exp)
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::CWriteRequestsReceiveMsg constructor throw bad_hresult hr = 0x%x"), exp.error()));
        return LogHR(exp.error(), s_FN, 170);
    }
	catch(const bad_alloc&)
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::CWriteRequestsReceiveMsg constructor throw bad_alloc")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 172);
    }
    catch (const exception& exp)
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::CWriteRequestsReceiveMsg constructor throw exception, what = %s"), exp.what()));
        ASSERT(("Need to know the real reason for failure here!", 0));
		DBG_USED(exp);
        return LogHR(MQ_ERROR, s_FN, 174);
    }

    //
    // initialization succeeded
    //
    m_fInited = TRUE;
    return MQ_OK;
}


void CGenerateWriteRequests::InitializeDummy()
/*++

Routine Description:
    Initializes the class to do nothing. We do this for setup, we don't want
    to write a code in DS API that acts differently when loaded by setup, so we
    allow this class to be inited in such a way that it will basically do nothing.

Arguments:

Return Value:
    HRESULT

--*/
{
    //
    // sanity check
    //
    if (m_fInited)
    {
        ASSERT(0);
        return;
    }

    //
    // we make a dummy initialization. All public methods will return immediately
    //
    m_fDummyInitialization = TRUE;
    m_fInited = TRUE;
}


void CGenerateWriteRequests::ReceiveNack(CWriteRequestsReceiveMsg* pWrrMsg)
/*++

Routine Description:
    Propcess a reply for the write request. This is ported from QM1.0 with minor changes.
    It checks the message authentication, and signals the write-request event with the returned
    result of the write request

Arguments:
    pWrrMsg - pointer to CWriteRequestsReceiveMsg class (this class contain the message properties)

Return Value:
    None

--*/
{
    //
    // sanity check
    //
    if (!m_fInited)
    {
        ASSERT(0);
        return;
    }

    //
    // this callback should not be called in dummy initialization
    //
    if (m_fDummyInitialization)
    {
        ASSERT(0);
        return;
    }

    //
    // get body
    //
    const unsigned char *pBuf = pWrrMsg->MsgBody();

    //
    // Get basic header
    // BUGBUG why not check CalcSize before
    //
#ifdef _DEBUG
#undef new
#endif
    CBasicMQISHeader * pMessage = new((unsigned char *)pBuf) CBasicMQISHeader();
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    //
    //  Verify correct version
    //
    if (pMessage->GetVersion() != DS_PACKET_VERSION)
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::ReceiveNack: Wrong version number %lx, expected %lx"), (DWORD)pMessage->GetVersion(), (DWORD)DS_PACKET_VERSION));
        ASSERT(0);
        LogIllegalPoint(s_FN, 1628);
        return;
    }

    //
    // Verify the original msg was indeed a write request
    //
    if (pMessage->GetOperation() != DS_WRITE_REQUEST)
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::ReceiveNack: original msg was not a write request but %lx"), (DWORD)pMessage->GetOperation()));
        ASSERT(0);
        LogIllegalPoint(s_FN, 1629);
        return;
    }

//    //
//    //  Verify that the original write request was indeed sent by us
//    //
//    GUID guidSiteId;
//    pMessage->GetSiteId(&guidSiteId);
//    if (memcmp(&m_guidMySiteId, &guidSiteId, sizeof(GUID)) != 0)
//    {
//        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::ReceiveNack: site-id of sender for original write request is not our site")));
//        ASSERT(0);
//        return;
//    }

    //
    // Get write request header
    // BUGBUG why not check CalcSize before
    //
#ifdef _DEBUG
#undef new
#endif
    CWriteRequestHeader * pRequest = new((unsigned char *)pBuf) CWriteRequestHeader();
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    //
    // get requestor name
    //
    DWORD dwRequesterNameSize = pRequest->GetRequesterNameSize();
    AP<WCHAR> pwcsRequesterName = new WCHAR[dwRequesterNameSize/sizeof(WCHAR)];
    pRequest->GetRequesterName(pwcsRequesterName, dwRequesterNameSize);

    //
    // validate we are the requestor (we can't be intermediate because
    // as an NT5 PSC (other than the PEC) we don't have BSC's, and as the PEC
    // the replication service takes care to filter out the intermediates
    //
    if (CompareStringsNoCaseUnicode(pwcsRequesterName, m_pwszServerName) != 0)
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::ReceiveNack: requestor of original write request is not us but %ls"), (LPCWSTR)pwcsRequesterName));
        ASSERT(0);
        LogIllegalPoint(s_FN, 1631);
        return;
    }

    //
    // get pointer to write request info
    //
    WRITE_SYNC_INFO * pWriteSyncInfo;
    DWORD dwSyncInfoPtr;
    pRequest->GetHandle(&dwSyncInfoPtr);
    try
    {
        pWriteSyncInfo = (WRITE_SYNC_INFO *) 
            GET_FROM_CONTEXT_MAP(m_map_MQADS_SyncInfoPtr, dwSyncInfoPtr, s_FN, 1930); //this may throw
    }
    catch(...)
    {
        LogIllegalPoint(s_FN, 1931);
        //
        // it may have been deleted from map due to time-out
        //
        return;        
    }

    //
    // enter critical section
    //
    CS lock(g_csWriteRequests);

    //
    //  Check Validty of Write Sync Info (it may have been deleted
    //  because time-out had expired)
    //
    if (!IsValidSyncInfo(pWriteSyncInfo))
    {
        return;
    }

    //
    // mark that the write request failed
    //
    pWriteSyncInfo->hr = MQDS_OWNER_NOT_REACHED;

    //
    //  Signal the event to notify there is a result for the write request
    //
    SetEvent(pWriteSyncInfo->hEvent);
}

void CGenerateWriteRequests::ReceiveReply(CWriteRequestsReceiveMsg* pWrrMsg)
/*++

Routine Description:
    Process a reply for the write request. This is ported from QM1.0 with minor changes.
    It checks the message authentication, and signals the write-request event with the returned
    result of the write request

Arguments:
    pWrrMsg - pointer to CWriteRequestsReceiveMsg class (this class contain the message properties)

Return Value:
    None

--*/
{
    //
    // sanity check
    //
    if (!m_fInited)
    {
        ASSERT(0);
        return;
    }

    //
    // this callback should not be called in dummy initialization
    //
    if (m_fDummyInitialization)
    {
        ASSERT(0);
        return;
    }

    //
    // get body
    //
    const unsigned char *pBuf = pWrrMsg->MsgBody();

    //
    // Get basic header
    // BUGBUG why not check CalcSize before
    //
#ifdef _DEBUG
#undef new
#endif
    CBasicMQISHeader * pMessage = new((unsigned char *)pBuf) CBasicMQISHeader();
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    //
    //  Verify correct version
    //
    if (pMessage->GetVersion() != DS_PACKET_VERSION)
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::ReceiveReply: Wrong version number %lx, expected %lx"), (DWORD)pMessage->GetVersion(), (DWORD)DS_PACKET_VERSION));
        ASSERT(0);
        LogIllegalPoint(s_FN, 1632);
        return;
    }

    //
    //  Validate packet is authenticated.
    //  If we're on PEC, then the replication service already validated
    //  this.
    //
    if (!m_fIsPEC && !pWrrMsg->IsAuthenticated())
    {
        DBGMSG(( (DBGMOD_REPLSERV | DBGMOD_SECURITY), DBGLVL_ERROR,
             TEXT("ERROR- ReceiveWriteReply: packet not authenticated") )) ;
        LogIllegalPoint(s_FN, 1633);
        return ;
    }

    //
    // make sure it is only a write reply message (we should not get any other types)
    //
    if (pMessage->GetOperation() != DS_WRITE_REPLY)
    {
        DBGMSG((DBGMOD_DS, DBGLVL_WARNING, TEXT(
        "CGenerateWriteRequests::ReceiveReply: invalid operation type %lx"),
                                        (DWORD)pMessage->GetOperation()));
        return;
    }

    //
    // do specific write reply
    //
    // Was this machine the originator of the write request
    //
#ifdef _DEBUG
#undef new
#endif
    CWriteReplyHeader * pReply = new((unsigned char *)pBuf) CWriteReplyHeader();
#ifdef _DEBUG
#define new DEBUG_NEW
#endif
    //
    // get requestor name
    //
    DWORD dwRequesterNameSize = pReply->GetRequesterNameSize();
    AP<WCHAR> pwcsRequesterName = new WCHAR[dwRequesterNameSize/sizeof(WCHAR)];
    pReply->GetRequesterName(pwcsRequesterName, dwRequesterNameSize);

    //
    // validate we are the requestor (we can't be intermediate because
    // as an NT5 PSC (other than the PEC) we don't have BSC's, and as the PEC
    // the replication service takes care to filter out the intermediates
    //
    if (CompareStringsNoCaseUnicode(pwcsRequesterName, m_pwszServerName) != 0)
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::ReceiveReply: requestor of original write request is not us but %ls"), (LPCWSTR)pwcsRequesterName));
        ASSERT(0);
        LogIllegalPoint(s_FN, 1634);
        return;
    }

    //
    // get pointer to write request info
    //
    WRITE_SYNC_INFO * pWriteSyncInfo;
    DWORD dwSyncInfoPtr;
    pReply->GetHandle(&dwSyncInfoPtr);
    try
    {
        pWriteSyncInfo = (WRITE_SYNC_INFO *) 
            GET_FROM_CONTEXT_MAP(m_map_MQADS_SyncInfoPtr, dwSyncInfoPtr, s_FN, 1940); //this may throw on win64
    }
    catch(...)
    {
        LogIllegalPoint(s_FN, 1941);
        //
        // it may have been deleted from map due to time-out
        //
        return;        
    }

    //
    // get result
    //
    HRESULT rc;
    pReply->GetResult(&rc);

    //
    // enter critical section
    //
    CS lock(g_csWriteRequests);

    //
    //  Check Validty of Write Sync Info (it may have been deleted
    //  because time-out had expired)
    //
    if (!IsValidSyncInfo(pWriteSyncInfo))
    {
        return;
    }

    //
    // mark the status of the write request
    //
    pWriteSyncInfo->hr = rc;

    //
    //  Signal the event to notify there is a result for the write request
    //
    SetEvent(pWriteSyncInfo->hEvent);
}


BOOL CGenerateWriteRequests::IsQmIdNT4Psc(const GUID * pguid)
/*++

Routine Description:
    Given a QM guid, checks if it is an NT4 PSC (e.g. in our NT4PscQMs map)

Arguments:
    pguid - QM id

Return Value:
    TRUE if the QM is an NT4 Site PSC, FALSE otherwise

--*/
{
    //
    // sanity check
    //
    if (!m_fInited)
    {
        ASSERT(0);
        return LogBOOL(FALSE, s_FN, 1911);
    }

    //
    // this callback should not be called in dummy initialization
    //
    if (m_fDummyInitialization)
    {
        ASSERT(0);
        return LogBOOL(FALSE, s_FN,1912);
    }

    //
    // enter critical section
    //
    CS cs(m_csNT4Sites);
    //
    // refresh if its time to do so
    //
    RefreshNT4Sites();
    //
    // return the lookup
    //
    DWORD dwDummy;
    return m_pmapNT4PscQMs->Lookup(*pguid, dwDummy);
}


HRESULT CGenerateWriteRequests::AttemptCreateQueue(
                         IN LPCWSTR          pwcsPathName,
                         IN DWORD            cp,
                         IN PROPID           aProp[  ],
                         IN PROPVARIANT      apVar[  ],
                         IN CDSRequestContext * pRequestContext,
                         OUT BOOL *          pfGeneratedWriteRequest,
                         IN OUT MQDS_OBJ_INFO_REQUEST * pQueueInfoRequest,
                         IN OUT MQDS_OBJ_INFO_REQUEST * pQmInfoRequest)
/*++

Routine Description:
    If we're in mixed mode and the new queue is on a machine that is mastered
    by an NT4 site, we generate a write request, and fill the info requests
    Otherwise we just return

Arguments:
    pwcsPathName            - pathname of object
    cp                      - properties of object (count)
    aProp                   - properties of object (propids)
    apVar                   - properties of object (propvars)
    pfGeneratedWriteRequest - returned whether we generated a write request
    pQueueInfoRequest       - requested queue props - filled only if we generated a write request
    pQmInfoRequest          - requested qm props - filled only if we generated a write request

Return Value:
    HRESULT

--*/
{
    //
    // sanity check
    //
    if (!m_fInited)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 190);
    }

    //
    // if we were dummy initialized, return
    //
    if (m_fDummyInitialization)
    {
        *pfGeneratedWriteRequest = FALSE;
        return MQ_OK;
    }

    //
    // if we're not in mixed mode, return
    //
    if (!IsInMixedModeWithNT4PSC())
    {
        *pfGeneratedWriteRequest = FALSE;
        return MQ_OK;
    }

    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>
    //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 200);
    }

    //
    // we pass the info request to another routine here. If it is filled, but then
    // later there is an error, we like to clear the propvars before we return.
    // we attachStaticClean to it because we don't want to free the array, just clean
    // the filled propvars.
    // we detach it when we return these propvars at the end.
    //
    CAutoCleanPropvarArray cCleanQmPropvars;
    if (pQmInfoRequest)
    {
        cCleanQmPropvars.attachStaticClean(pQmInfoRequest->cProps, pQmInfoRequest->pPropVars);
    }

    //
    // check if the owner qm is mastered by an NT4 site
    // use this opportunity to get the QM props that were requested by
    // the caller (pQmInfoRequest)
    //
    BOOL fIsOwnedByNT4Site;
    GUID guidOwnerNT4Site;
    CMQVariant varQmSecurity;
    hr = CheckNewQueueIsOwnedByNT4Site(pwcsPathName,
                                       &fIsOwnedByNT4Site,
                                       &guidOwnerNT4Site,
                                       varQmSecurity.CastToStruct(),
                                       pQmInfoRequest);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 210);
    }

    //
    // if object is not mastered by an NT4 site, return
    //
    if (!fIsOwnedByNT4Site)
    {
        *pfGeneratedWriteRequest = FALSE;
        return MQ_OK;
    }

    //
    // we need to generate a write request
    // check that we are allowed to create the queue.
    //
    ASSERT(varQmSecurity.CastToStruct()->vt == VT_BLOB);
    SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR*)
                          (varQmSecurity.CastToStruct()->blob.pBlobData) ;
    ASSERT(IsValidSecurityDescriptor(pSD)) ;

    DWORD_PTR dwId = (DWORD_PTR) &pSD ; // dummy unique id.

    AP<unsigned short> pwcsMachineName;
    AP<unsigned short> pwcsQueueName;

    hr = MQADSpSplitAndFilterQueueName(
                      pwcsPathName,
                      &pwcsMachineName,
                      &pwcsQueueName
                      );

    BOOL fImpersonate = pRequestContext->NeedToImpersonate();
    hr = MQSec_AccessCheck( pSD,
                            MQDS_MACHINE,
                            pwcsMachineName,
                            MQSEC_CREATE_QUEUE,
                            &dwId,
                            fImpersonate,
                            fImpersonate ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 220);
    }

    //
    // get the NT4 props needed for create queue using the supplied props
    //
    ULONG cNT4Props;
    AP<PROPID> rgNT4PropIDs;
    PROPVARIANT * rgNT4PropVars;
    hr = GetNT4CreateQueueProps(cp, aProp, apVar, &cNT4Props, &rgNT4PropIDs, &rgNT4PropVars);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 230);
    }

    //
    // remember to free the NT4 props
    //
    CAutoCleanPropvarArray cCleanNT4Props;
    cCleanNT4Props.attach(cNT4Props, rgNT4PropVars);

    //
    // check that there are props to send
    //
    if (cNT4Props == 0)
    {
        //
        // this will never happen in create
        //
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 240);
    }

    //
    // send the write request
    //
    hr = BuildSendWriteRequest(&guidOwnerNT4Site,
                               DS_UPDATE_CREATE,
                               MQDS_QUEUE,
                               pwcsPathName,
                               NULL /*pguidIdentifier*/,
                               cNT4Props,
                               rgNT4PropIDs,
                               rgNT4PropVars);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 250);
    }

    //
    // We Can't fail the routine after here. The write request succeeded.
    //

    //
    // fill the obj info request
    //
    if (pQueueInfoRequest)
    {
        FillObjInfoRequest(MQDS_QUEUE,
                           pwcsPathName,
                           NULL /*pguidIdentifier*/,
                           cNT4Props,
                           rgNT4PropIDs,
                           rgNT4PropVars,
                           cp,
                           aProp,
                           apVar,
                           pQueueInfoRequest);
    }

    //
    // we return the propvars that were filled earlier
    //
    cCleanQmPropvars.detach();

    //
    // return results
    //
    *pfGeneratedWriteRequest = TRUE;
    return MQ_OK;
}


HRESULT CGenerateWriteRequests::AttemptDeleteObject(
                         IN DWORD               dwObjectType,
                         IN LPCWSTR             pwcsPathName,
                         IN const GUID *        pguidIdentifier,
                         IN CDSRequestContext * pRequestContext,
                         OUT BOOL *             pfGeneratedWriteRequest,
                         IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest)
/*++

Routine Description:
    If we're in mixed mode and the object is mastered
    by an NT4 site, we generate a write request, and fill the info requests
    Otherwise we just return

Arguments:
    dwObjectType            - type of object (queue, machine)
    pwcsPathName            - pathname of object
    pguidIdentifier         - object's guid
    pfGeneratedWriteRequest - returned whether we generated a write request
    pParentInfoRequest      - requested parent props - filled only if we generated a write request

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // sanity check
    //
    if (!m_fInited)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 260);
    }

    //
    // if we were dummy initialized, return
    //
    if (m_fDummyInitialization)
    {
        *pfGeneratedWriteRequest = FALSE;
        return MQ_OK;
    }

    //
    // if we're not in mixed mode, return
    //
    if (!IsInMixedModeWithNT4PSC())
    {
        *pfGeneratedWriteRequest = FALSE;
        return MQ_OK;
    }

    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>
    //
    // Initialize OLE with auto uninitialize
    //
    hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 270);
    }

    //
    // check if the object is mastered by an NT4 site
    // use this opportunity to get the parent props that were requested by
    // the caller (pParentInfoRequest)
    //
    BOOL fIsOwnedByNT4Site;
    GUID guidOwnerNT4Site;
    CMQVariant varObjSecurity;
    DWORD  dwDesiredAccess = 0 ;
    PROPID PropIdName = 0 ;

    switch (dwObjectType)
    {
    case MQDS_QUEUE:
        dwDesiredAccess = MQSEC_DELETE_QUEUE ;
        PropIdName = PROPID_Q_PATHNAME ;
        hr = CheckQueueIsOwnedByNT4Site(pwcsPathName,
                                        pguidIdentifier,
                                        &fIsOwnedByNT4Site,
                                        &guidOwnerNT4Site,
                                        varObjSecurity.CastToStruct());
        break;

    case MQDS_MACHINE:
        dwDesiredAccess = MQSEC_DELETE_MACHINE ;
        hr = CheckMachineIsOwnedByNT4Site(pwcsPathName,
                                          pguidIdentifier,
                                          &fIsOwnedByNT4Site,
                                          &guidOwnerNT4Site,
                                          varObjSecurity.CastToStruct(),
                                          NULL /*pQmInfoRequest*/);
        break;

    default:
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 280);
        break;
    }

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 290);
    }

    //
    // if object is not mastered by an NT4 site, return
    //
    if (!fIsOwnedByNT4Site)
    {
        *pfGeneratedWriteRequest = FALSE;
        return MQ_OK;
    }

    //
    // we need to generate a write request
    // check that we are allowed to delete the object.
    //
    ASSERT(dwDesiredAccess != 0) ;
    ASSERT(varObjSecurity.CastToStruct()->vt == VT_BLOB);
    SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR*)
                          (varObjSecurity.CastToStruct()->blob.pBlobData);
    ASSERT(IsValidSecurityDescriptor(pSD)) ;

    DWORD_PTR dwId = (DWORD_PTR) &pSD ; // dummy unique id.
    LPWSTR  pObjName = const_cast<LPWSTR> (pwcsPathName) ;
    P<WCHAR> pOjbNameFromDS = NULL ;
    if (!pObjName && MQSec_CanGenerateAudit() && PropIdName)
    {
        //
        // Get object name, to enable auditing.
        //
        PROPVARIANT vPropName;
        vPropName.vt = VT_NULL;
        CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr = DSCoreGetProps( dwObjectType,
                             NULL,
                             pguidIdentifier,
                             1,
                             &PropIdName,
                             &requestDsServerInternal,
                             &vPropName );
        if (SUCCEEDED(hr))
        {
            pOjbNameFromDS = vPropName.pwszVal ; //auto release
            pObjName = pOjbNameFromDS ;
        }
    }
    BOOL fImpersonate = pRequestContext->NeedToImpersonate();
    hr = MQSec_AccessCheck( pSD,
                            dwObjectType,
                            pObjName,
                            dwDesiredAccess,
                            &dwId,
                            fImpersonate,
                            fImpersonate);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 300);
    }

    //
    // create delete props
    //
    static const PROPID x_rgDelPropIDs[] = {PROPID_D_SCOPE, PROPID_D_OBJTYPE};
    PROPVARIANT rgDelPropVars[ARRAY_SIZE(x_rgDelPropIDs)];
    rgDelPropVars[0].vt = VT_UI1;
    rgDelPropVars[0].bVal = ENTERPRISE_SCOPE;
    rgDelPropVars[1].vt = VT_UI1;
    rgDelPropVars[1].bVal = (unsigned char)dwObjectType;

    //
    // send the write request
    //
    hr = BuildSendWriteRequest(&guidOwnerNT4Site,
                               DS_UPDATE_DELETE,
                               dwObjectType,
                               pwcsPathName,
                               pguidIdentifier,
                               ARRAY_SIZE(x_rgDelPropIDs),
                               x_rgDelPropIDs,
                               rgDelPropVars);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 310);
    }

    //
    // We Can't fail the routine after here. The write request succeeded.
    //

    //
    // fill parent info request
    //
    if (pParentInfoRequest)
    {
        //
        // we should get parent info request only for queues
        //
        ASSERT(dwObjectType == MQDS_QUEUE);
        //
        // get PROPID_Q_QMID.
        //
        PROPID aPropQmId[] = {PROPID_Q_QMID};
        CAutoCleanPropvarArray cCleanPropsQmId;
        PROPVARIANT * pPropsQmId = cCleanPropsQmId.allocClean(ARRAY_SIZE(aPropQmId));
        CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr = DSCoreGetProps(MQDS_QUEUE,
                            pwcsPathName,
                            pguidIdentifier,
                            ARRAY_SIZE(aPropQmId),
                            aPropQmId,
                            &requestDsServerInternal,
                            pPropsQmId);
        if (SUCCEEDED(hr))
        {
            ASSERT(pPropsQmId[0].vt == VT_CLSID);
            ASSERT(pPropsQmId[0].puuid != NULL);
            CDSRequestContext requestDsServerInternal1( e_DoNotImpersonate, e_IP_PROTOCOL);
            hr = DSCoreGetProps(MQDS_MACHINE,
                                NULL /*pwcsPathName*/,
                                pPropsQmId[0].puuid,
                                pParentInfoRequest->cProps,
                                const_cast<PROPID *>(pParentInfoRequest->pPropIDs),
                                &requestDsServerInternal1,
                                pParentInfoRequest->pPropVars);
        }
        //
        // set request status
        //
        pParentInfoRequest->hrStatus = hr;
    }

    //
    // return results
    //
    *pfGeneratedWriteRequest = TRUE;
    return MQ_OK;
}


HRESULT CGenerateWriteRequests::AttemptSetObjectProps(
                         DWORD        dwObjectType,
                         LPCWSTR      pwcsPathName,
                         const GUID * pguidIdentifier,
                         DWORD        cp,
                         PROPID       aProp[  ],
                         PROPVARIANT  apVar[  ],
                         IN CDSRequestContext *   pRequestContext,
                         OUT BOOL *   pfGeneratedWriteRequest,
                         IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
                         IN SECURITY_INFORMATION     SecurityInformation )
/*++

Routine Description:
    If we're in mixed mode and the object is mastered
    by an NT4 site, we generate a write request, and fill the info requests
    Otherwise we just return

Arguments:
    dwObjectType            - type of object (queue, machine)
    pwcsPathName            - pathname of object
    pguidIdentifier         - object's guid
    cp                      - properties of object (count)
    aProp                   - properties of object (propids)
    apVar                   - properties of object (propvars)
    pfGeneratedWriteRequest - returned whether we generated a write request
    pObjInfoRequest         - requested object props - filled only if we generated a write request

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // sanity check
    //
    if (!m_fInited)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 320);
    }

    //
    // if we were dummy initialized, return
    //
    if (m_fDummyInitialization)
    {
        *pfGeneratedWriteRequest = FALSE;
        return MQ_OK;
    }

    //
    // if we're not in mixed mode, return
    //
    if (!IsInMixedModeWithNT4PSC())
    {
        *pfGeneratedWriteRequest = FALSE;
        return MQ_OK;
    }

    //
    // Check the special case that BSC upgraded to win2k, booted as
    // ds-less FRS and then dcpromo. Now it (the msmq service on the BSC)
    // try to write in the active directory that it is win2k and ds server.
    // This write must be done locally, as it is relevant only in the
    // win2k active directory. Anyway, a PSC won't understand this new
    // property (QM_SERVICE_DSSERVER) and won't know what to do with it.
    // Note that this case happen both after dcpromo and dcunpromo of BSC.
    // If BSC is after dcpromo, then this code run on the BSC itself.
    // If it's after dcunpromo, then this run on the ex-PEc that is called
    // by the BSC.
    //

    if ((cp == 1)                       &&
        (dwObjectType == MQDS_MACHINE)  &&
        (aProp[0] == PROPID_QM_SERVICE_DSSERVER))
    {
        //
        // That's the migrated/upgraded BSC case. Don't write request the
        // PSC. Make it locally.
        //
        *pfGeneratedWriteRequest = FALSE;
        return MQ_OK ;
    }

    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>
    //
    // Initialize OLE with auto uninitialize
    //
    hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 330);
    }

    //
    // check if the object is mastered by an NT4 site
    // use this opportunity to get the parent props that were requested by
    // the caller (pParentInfoRequest)
    //
    BOOL fIsOwnedByNT4Site;
    GUID guidOwnerNT4Site;
    CMQVariant varObjSecurity;
    DWORD dwDesiredAccess = 0  ;

    switch (dwObjectType)
    {
    case MQDS_QUEUE:
        dwDesiredAccess = MQSEC_SET_QUEUE_PROPERTIES ;
        hr = CheckQueueIsOwnedByNT4Site(pwcsPathName,
                                        pguidIdentifier,
                                        &fIsOwnedByNT4Site,
                                        &guidOwnerNT4Site,
                                        varObjSecurity.CastToStruct());
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 340);
        }
        break;

    case MQDS_MACHINE:
        dwDesiredAccess = MQSEC_SET_MACHINE_PROPERTIES ;
        hr = CheckMachineIsOwnedByNT4Site(pwcsPathName,
                                          pguidIdentifier,
                                          &fIsOwnedByNT4Site,
                                          &guidOwnerNT4Site,
                                          varObjSecurity.CastToStruct(),
                                          NULL /*pQmInfoRequest*/);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 350);
        }
        break;

    default:
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 360);
        break;
    }

    //
    // if object is not mastered by an NT4 site, return
    //
    if (!fIsOwnedByNT4Site)
    {
        *pfGeneratedWriteRequest = FALSE;
        return MQ_OK;
    }

    if ((aProp[0] == PROPID_Q_SECURITY) || (aProp[0] == PROPID_QM_SECURITY))
    {
        //
        // changing security descriptor need special permissions.
        //
        ASSERT(cp == 1) ;
        dwDesiredAccess = 0 ;

        if (SecurityInformation & OWNER_SECURITY_INFORMATION)
        {
            dwDesiredAccess |= WRITE_OWNER;
        }

        if (SecurityInformation & DACL_SECURITY_INFORMATION)
        {
            dwDesiredAccess |= WRITE_DAC;
        }

        if (SecurityInformation & SACL_SECURITY_INFORMATION)
        {
            dwDesiredAccess |= ACCESS_SYSTEM_SECURITY;
        }
    }

    //
    // we need to generate a write request
    // check that we are allowed to update the object.
    //
    ASSERT(dwDesiredAccess != 0) ;
    ASSERT(varObjSecurity.CastToStruct()->vt == VT_BLOB);
    SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR*)
                          (varObjSecurity.CastToStruct()->blob.pBlobData);
    ASSERT(IsValidSecurityDescriptor(pSD)) ;

    DWORD_PTR dwId = (DWORD_PTR) &pSD ; // dummy unique id.
    BOOL fImpersonate = pRequestContext->NeedToImpersonate();

    if (!fImpersonate && (pRequestContext->IsAccessVerified()))
    {
        //
        // This call was verified by crypto signature, by challenge/response
        // protocol between this server and client machine.
        // This will happen on upgraded BSC that belong to PSC sites.
        // Do not make any access check, because the thread probably do
        // not have an access token.
        //
    }
    else
    {
        hr = MQSec_AccessCheck( pSD,
                                dwObjectType,
                                NULL,
                                dwDesiredAccess,
                                &dwId,
                                fImpersonate,
                                fImpersonate) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 370);
        }
    }

    //
    // Convert given props to NT4 props
    //
    ULONG cNT4Props;
    AP<PROPID> rgNT4PropIDs;
    PROPVARIANT * rgNT4PropVars;
    hr = ConvertToNT4Props(cp, aProp, apVar, &cNT4Props, &rgNT4PropIDs, &rgNT4PropVars);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 380);
    }
    //
    // remember to free converted NT4 props
    //
    CAutoCleanPropvarArray cCleanNT4Props;
    cCleanNT4Props.attach(cNT4Props, rgNT4PropVars);

    //
    // check that there are props to send
    // BUGBUG: need better error code
    //
    if (cNT4Props == 0)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 390);
    }

    //
    // send the write request
    //
    hr = BuildSendWriteRequest(&guidOwnerNT4Site,
                               DS_UPDATE_SET,
                               dwObjectType,
                               pwcsPathName,
                               pguidIdentifier,
                               cNT4Props,
                               rgNT4PropIDs,
                               rgNT4PropVars);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 400);
    }

    //
    // We Can't fail the routine after here. The write request succeeded.
    //

    //
    // fill the obj info request
    //
    if (pObjInfoRequest)
    {
        FillObjInfoRequest(dwObjectType,
                           pwcsPathName,
                           pguidIdentifier,
                           cNT4Props,
                           rgNT4PropIDs,
                           rgNT4PropVars,
                           cp,
                           aProp,
                           apVar,
                           pObjInfoRequest);
    }

    //
    // return results
    //
    *pfGeneratedWriteRequest = TRUE;
    return MQ_OK;
}

//
// private class functions
//

HRESULT CGenerateWriteRequests::CheckSiteIsNT4Site(IN const GUID * pguidIdentifier,
                                                   OUT BOOL * pfIsNT4Site)
/*++

Routine Description:
    Checks if a site is an NT4 site

Arguments:
    pguidIdentifier - guid of site
    pfIsNT4Site     - returned indication if the site is NT4

Return Value:
    HRESULT

--*/
{
    NT4SitesEntry * pNT4Site;
    *pfIsNT4Site = LookupNT4Sites(pguidIdentifier, &pNT4Site);
    return MQ_OK;
}


HRESULT CGenerateWriteRequests::CheckMachineIsOwnedByNT4Site(IN LPCWSTR pwcsPathName,
                                                             IN const GUID * pguidIdentifier,
                                                             OUT BOOL * pfIsOwnedByNT4Site,
                                                             OUT GUID * pguidOwnerNT4Site,
                                                             OUT PROPVARIANT * pvarObjSecurity,
                                                             IN OUT MQDS_OBJ_INFO_REQUEST * pQmInfoRequest)
/*++

Routine Description:
    Checks if a machine is owned by an NT4 site, and if so, returns the site guid,
    and fills the qm info request

Arguments:
    pwcsPathName       - object's pathname
    pguidIdentifier    - object's guid
    pfIsOwnedByNT4Site - returned indication whether it is owned by NT4 site
    pguidOwnerNT4Site  - returned guid of owner NT4 site
    pvarObjSecurity    - returned security descriptor of object
    pQmInfoRequest     - requested qm props - filled only if it is owned by NT4 site

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // get PROPID_QM_MASTERID
    //
    PROPID aProp[] = {PROPID_QM_MASTERID};
    CAutoCleanPropvarArray cCleanProps;
    PROPVARIANT * pProps = cCleanProps.allocClean(ARRAY_SIZE(aProp));
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = DSCoreGetProps(MQDS_MACHINE,
                        pwcsPathName,
                        pguidIdentifier,
                        ARRAY_SIZE(aProp),
                        aProp,
                        &requestDsServerInternal,
                        pProps);
    if ((hr == MQ_ERROR_MACHINE_NOT_FOUND) ||
        (hr == MQDS_OBJECT_NOT_FOUND) ||
        (hr == E_ADS_PROPERTY_NOT_FOUND))
    {
        //
        // if the object not found or the property not found, it is not owned by an NT4 site
        //
        // BUGBUG: currently if the property is not found, I get PROPID_QM_SITE_ID
        // and not E_ADS_PROPERTY_NOT_FOUND because a retrieval routine exists.
        // I'm not interested in it, plus it might do dikstra to find the best site.
        // I'm just interested in the property as it is in the DS.
        // I can go straight to ADSI, but better pass a flag to skip retrieval
        // routine if not found in the DS. This is because of encapsulated logic
        // in MQADSpGetComputerProperties, and the guid bind of CADSI, which I need.
        //
        *pfIsOwnedByNT4Site = FALSE;
        return MQ_OK;
    }
    else if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 410);
    }

    //
    // check if the owner site is NT4
    //
    ASSERT(pProps[0].vt == VT_CLSID);
    ASSERT(pProps[0].puuid != NULL);
    BOOL fIsNT4Site;
    hr = CheckSiteIsNT4Site(pProps[0].puuid, &fIsNT4Site);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CheckMachineIsOwnedByNT4Site:CheckSiteIsNT4Site()=%lx"), hr));
        return LogHR(hr, s_FN, 420);
    }

    //
    // return if the owner site is not NT4
    //
    if (!fIsNT4Site)
    {
        *pfIsOwnedByNT4Site = FALSE;
        return MQ_OK;
    }

    //
    // machine is owned by NT4 site
    //
    // get the security descriptor of the QM into the supplied propvar. We attach-Static
    // to it so we will clean it up if we don't return normally. We detach before returning.
    //
    CAutoCleanPropvarArray cCleanObjSecurity;
    if (pvarObjSecurity != NULL)
    {
        cCleanObjSecurity.attachStaticClean(1, pvarObjSecurity);
        PROPID propidObjSecurity = PROPID_QM_SECURITY;
        CDSRequestContext requestDsServerInternal1( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr = DSCoreGetProps(MQDS_MACHINE,
                            pwcsPathName,
                            pguidIdentifier,
                            1,
                            &propidObjSecurity,
                            &requestDsServerInternal1,
                            pvarObjSecurity);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 430);
        }
    }

    //
    // fill qm info request
    //
    if (pQmInfoRequest)
    {
        CDSRequestContext requestDsServerInternal2( e_DoNotImpersonate, e_IP_PROTOCOL);
        pQmInfoRequest->hrStatus = DSCoreGetProps(MQDS_MACHINE,
                                                  pwcsPathName,
                                                  pguidIdentifier,
                                                  pQmInfoRequest->cProps,
                                                  const_cast<PROPID *>(pQmInfoRequest->pPropIDs),
                                                  &requestDsServerInternal2,
                                                  pQmInfoRequest->pPropVars);
    }

    //
    // return results
    //
    *pfIsOwnedByNT4Site = TRUE;
    *pguidOwnerNT4Site = *(pProps[0].puuid);
    cCleanObjSecurity.detach();
    return MQ_OK;
}


HRESULT CGenerateWriteRequests::CheckQueueIsOwnedByNT4Site(IN LPCWSTR pwcsPathName,
                                                           IN const GUID * pguidIdentifier,
                                                           OUT BOOL * pfIsOwnedByNT4Site,
                                                           OUT GUID * pguidOwnerNT4Site,
                                                           OUT PROPVARIANT * pvarObjSecurity)
/*++

Routine Description:
    Checks if a queue is owned by an NT4 site, and if so, returns the site guid,
    and fills the info requests.

    There are two ways:
    1. Find PROPID_Q_QMID and check whether the machine is owned by NT4 site.
    2. Find PROPID_Q_MASTERID (if exists), and if exists check if the site is an NT4.

    It looks like most of the queue calls to NT5 DS (in mixed mode) will not be
    for NT4 owned queues, so there is an advantage to getting a negative answer first,
    so we take the second approach, it is faster for negative answer, but slower on
    positive answer (e.g. extra DS call to fill the qm info)

Arguments:
    pwcsPathName       - object's pathname
    pguidIdentifier    - object's guid
    pfIsOwnedByNT4Site - returned indication whether it is owned by NT4 site
    pguidOwnerNT4Site  - returned guid of owner NT4 site
    pvarObjSecurity    - returned security descriptor of object

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // get PROPID_Q_MASTERID, if not found then it is not owned by NT4
    //
    PROPID aProp[] = {PROPID_Q_MASTERID};
    CAutoCleanPropvarArray cCleanProps;
    PROPVARIANT * pProps = cCleanProps.allocClean(ARRAY_SIZE(aProp));
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = DSCoreGetProps(MQDS_QUEUE,
                        pwcsPathName,
                        pguidIdentifier,
                        ARRAY_SIZE(aProp),
                        aProp,
                        &requestDsServerInternal,
                        pProps);
    if ((hr == MQ_ERROR_QUEUE_NOT_FOUND) ||
        (hr == MQDS_OBJECT_NOT_FOUND) ||
        (hr == E_ADS_PROPERTY_NOT_FOUND))
    {
        //
        // if the object not found or the property not found, it is not owned by an NT4 site
        //
        *pfIsOwnedByNT4Site = FALSE;
        return MQ_OK;
    }
    else if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 440);
    }

    //
    // check whether the owner site is NT4
    //
    ASSERT(pProps[0].vt == VT_CLSID);
    ASSERT(pProps[0].puuid != NULL);
    BOOL fIsNT4Site;
    hr = CheckSiteIsNT4Site(pProps[0].puuid, &fIsNT4Site);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CheckQueueIsOwnedByNT4Site:CheckSiteIsNT4Site()=%lx"), hr));
        return LogHR(hr, s_FN, 450);
    }

    //
    // return if the owner site is not NT4
    //
    if (!fIsNT4Site)
    {
        *pfIsOwnedByNT4Site = FALSE;
        return MQ_OK;
    }

    //
    // queue is owned by NT4 site
    //
    // get the security descriptor of the queue into the supplied propvar. We attach-Static
    // to it so we will clean it up if we don't return normally. We detach before returning.
    //
    CAutoCleanPropvarArray cCleanObjSecurity;
    if (pvarObjSecurity != NULL)
    {
        cCleanObjSecurity.attachStaticClean(1, pvarObjSecurity);
        PROPID propidObjSecurity = PROPID_Q_SECURITY;
        CDSRequestContext requestDsServerInternal1( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr = DSCoreGetProps(MQDS_QUEUE,
                            pwcsPathName,
                            pguidIdentifier,
                            1,
                            &propidObjSecurity,
                            &requestDsServerInternal1,
                            pvarObjSecurity);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 460);
        }
    }

    //
    // return results
    //
    *pfIsOwnedByNT4Site = TRUE;
    *pguidOwnerNT4Site = *(pProps[0].puuid);
    cCleanObjSecurity.detach();
    return MQ_OK;
}


HRESULT CGenerateWriteRequests::CheckNewQueueIsOwnedByNT4Site(IN LPCWSTR pwcsPathName,
                                                              OUT BOOL * pfIsOwnedByNT4Site,
                                                              OUT GUID * pguidOwnerNT4Site,
                                                              OUT PROPVARIANT * pvarQmSecurity,
                                                              IN OUT MQDS_OBJ_INFO_REQUEST * pQmInfoRequest)
/*++

Routine Description:
    Checks if a new queue should be owned by an NT4 site. We check the machine
    on which the queue is created

Arguments:
    pwcsPathName       - pathname of new object
    pfIsOwnedByNT4Site - returned indication whether it should be owned by NT4 site
    pguidOwnerNT4Site  - returned guid of owner NT4 site
    pvarQmSecurity     - returned security descriptor of owner qm
    pQmInfoRequest     - requested qm props - filled only if it is owned by NT4 site

Return Value:
    HRESULT

--*/
{
    //
    // get the owner machine of the new queue path name is machine\queue
    //
    ASSERT(pwcsPathName);
    LPCWSTR pwszTmp = wcschr(pwcsPathName, PN_DELIMITER_C);
    if (!pwszTmp)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_ILLEGAL_QUEUE_PATHNAME, s_FN, 470);
    }
    DWORD_PTR dwLen = pwszTmp - pwcsPathName;
    AP<WCHAR> pwszMachineName = new WCHAR[dwLen+1];
    memcpy(pwszMachineName, pwcsPathName, sizeof(WCHAR)*dwLen);
    pwszMachineName[dwLen] = L'\0';

    //
    // return whether the owner machine is owned by NT4 site
    //
    HRESULT hr2 = CheckMachineIsOwnedByNT4Site(pwszMachineName,
                                        NULL,
                                        pfIsOwnedByNT4Site,
                                        pguidOwnerNT4Site,
                                        pvarQmSecurity,
                                        pQmInfoRequest);
    return LogHR(hr2, s_FN, 480);
}


const PROPID x_rgNT4SitesPropIDs[] = {PROPID_SET_MASTERID,
                                      PROPID_SET_FULL_PATH,
                                      PROPID_SET_QM_ID};
enum
{
    e_NT4SitesProp_MASTERID,
    e_NT4SitesProp_FULL_PATH,
    e_NT4SitesProp_QM_ID,
};
const MQCOLUMNSET x_columnsetNT4Sites = {ARRAY_SIZE(x_rgNT4SitesPropIDs), const_cast<PROPID *>(x_rgNT4SitesPropIDs)};

STATIC HRESULT CheckIfExistNT4BSC(BOOL *pfIfExistNT4BSC)
/*++

Routine Description:
    Check if there is at least one NT4 BSC in Enterprise

Arguments:
    *pfIfExistNT4BSC is FALSE if there is no NT4 BSCs, otherwise it is TRUE

Return Value:
	HRESULT

--*/
{
    HRESULT hr;
    *pfIfExistNT4BSC = TRUE;    //in any case init this flag to TRUE

    //
    // find all msmq servers that have an NT4 flags > 0 AND services == BSC
    //
    MQRESTRICTION restrictionNT4Bsc;
    MQPROPERTYRESTRICTION propertyRestriction[2];
    restrictionNT4Bsc.cRes = ARRAY_SIZE(propertyRestriction);
    restrictionNT4Bsc.paPropRes = propertyRestriction;	

    //
    // services == BSC
    //
    propertyRestriction[0].rel = PREQ;
    propertyRestriction[0].prop = PROPID_SET_SERVICE;
    propertyRestriction[0].prval.vt = VT_UI4;         // [adsrv] Old service field will be kept for NT4 machines
    propertyRestriction[0].prval.ulVal = SERVICE_BSC;
    //
    // NT4 flags > 0 (equal to NT4 flags >= 1 for easier LDAP query)
    //
    propertyRestriction[1].rel = PRGE;
    propertyRestriction[1].prop = PROPID_SET_NT4;
    propertyRestriction[1].prval.vt = VT_UI4;
    propertyRestriction[1].prval.ulVal = 1;
    //
    // start search
    //

    CAutoDSCoreLookupHandle hLookup;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    PROPID columnsetPropertyID  = PROPID_SET_QM_ID;	

    MQCOLUMNSET columnsetNT4BSC;
    columnsetNT4BSC.cCol = 1;
    columnsetNT4BSC.aCol = &columnsetPropertyID;

    // This search request will be recognized and specially simulated by DS
    hr = DSCoreLookupBegin(NULL,
                           &restrictionNT4Bsc,
                           &columnsetNT4BSC,
                           NULL,
                           &requestDsServerInternal,
                           &hLookup);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CheckIfExistNT4BSC:DSCoreLookupBegin()=%lx"), hr));		
        return LogHR(hr, s_FN, 490);
    }
		
    DWORD cProps = 1;

    PROPVARIANT aVar;
    aVar.puuid = NULL;

    hr = DSCoreLookupNext(hLookup, &cProps, &aVar);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CheckIfExistNT4BSC:DSCoreLookupNext()=%lx"), hr));
        return LogHR(hr, s_FN, 500);
    }

    if (cProps == 0)
    {
        //
        // it means that NT4 BSCs were not found
        //
        *pfIfExistNT4BSC = FALSE;
        return MQ_OK;
    }

    if (aVar.puuid)
    {
        delete aVar.puuid;
    }

    return MQ_OK;
}

STATIC HRESULT CreateNT4SitesMap(IN const NT4Sites_CMAP * pmapNT4SitesOld,
                                 OUT NT4Sites_CMAP ** ppmapNT4Sites,
                                 OUT NT4PscQMs_CMAP ** ppmapNT4PscQMs)
/*++

Routine Description:
    Creates new maps for NT4 site PSC's

Arguments:
    pmapNT4SitesOld - old NT4Sites map. for retrieving cached data from the old map
    ppmapNT4Sites   - returned new NT4Sites map
    ppmapNT4PscQMs   - returned new NT4PscQMs map

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // find all msmq servers that have an NT4 flags > 0 AND services == PSC
    //
    MQRESTRICTION restrictionNT4Psc;
    MQPROPERTYRESTRICTION propertyRestriction[2];
    restrictionNT4Psc.cRes = ARRAY_SIZE(propertyRestriction);
    restrictionNT4Psc.paPropRes = propertyRestriction;
    //
    // services == PSC
    //
    propertyRestriction[0].rel = PREQ;
    propertyRestriction[0].prop = PROPID_SET_SERVICE;
    propertyRestriction[0].prval.vt = VT_UI4;         // [adsrv] Old service field will be kept for NT4 machines
    propertyRestriction[0].prval.ulVal = SERVICE_PSC;
    //
    // NT4 flags > 0 (equal to NT4 flags >= 1 for easier LDAP query)
    //
    propertyRestriction[1].rel = PRGE;
    propertyRestriction[1].prop = PROPID_SET_NT4;
    propertyRestriction[1].prval.vt = VT_UI4;
    propertyRestriction[1].prval.ulVal = 1;

    //
    // start search
    //

    CAutoDSCoreLookupHandle hLookup;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    // This search request will be recognized and specially simulated by DS
    hr = DSCoreLookupBegin(NULL,
                           &restrictionNT4Psc,
                           const_cast<MQCOLUMNSET*>(&x_columnsetNT4Sites),
                           NULL,
                           &requestDsServerInternal,
                           &hLookup);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CreateNT4SitesMap:DSCoreLookupBegin()=%lx"), hr));
        return LogHR(hr, s_FN, 510);
    }

    //
    // create maps for NT4 PSC data
    //
    P<NT4Sites_CMAP> pmapNT4Sites = new NT4Sites_CMAP;
    P<NT4PscQMs_CMAP> pmapNT4PscQMs = new NT4PscQMs_CMAP;

    //
    // allocate propvars array for NT4 PSC
    //
    CAutoCleanPropvarArray cCleanProps;
    PROPVARIANT * rgPropVars = cCleanProps.allocClean(ARRAY_SIZE(x_rgNT4SitesPropIDs));

    //
    // loop on the NT4 PSC's
    //
    BOOL fContinue = TRUE;
    while (fContinue)
    {
        //
        // get next server
        //
        DWORD cProps = ARRAY_SIZE(x_rgNT4SitesPropIDs);

        hr = DSCoreLookupNext(hLookup, &cProps, rgPropVars);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CreateNT4SitesMap:DSCoreLookupNext()=%lx"), hr));
            return LogHR(hr, s_FN, 520);
        }

        //
        // remember to clean the propvars in the array for the next loop
        // (only propvars, not the array itself, this is why we call attachStatic)
        //
        CAutoCleanPropvarArray cCleanPropsLoop;
        cCleanPropsLoop.attachStatic(cProps, rgPropVars);

        //
        // check if finished
        //
        if (cProps < ARRAY_SIZE(x_rgNT4SitesPropIDs))
        {
            //
            // finished, exit loop
            //
            fContinue = FALSE;
        }
        else
        {
            //
            // we got PSC props, create a SitePSC entry and add it to the map
            //
            P<NT4SitesEntry> pNT4Site = new NT4SitesEntry;
            //
            // set master guid
            //
            ASSERT(rgPropVars[e_NT4SitesProp_MASTERID].vt == VT_CLSID);
            pNT4Site->guidSiteId = *(rgPropVars[e_NT4SitesProp_MASTERID].puuid);
            //
            // set PSC name
            //
            ASSERT(rgPropVars[e_NT4SitesProp_FULL_PATH].vt == VT_LPWSTR);
            if (!GetServerNameFromSettingsDN(rgPropVars[e_NT4SitesProp_FULL_PATH].pwszVal,
                                             &pNT4Site->pwszPscName))
            {
                DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CreateNT4SitesMap:GetServerNameFromSettingsDN(%ls) failed"), rgPropVars[e_NT4SitesProp_FULL_PATH].pwszVal));
                return LogHR(MQ_ERROR, s_FN, 530);
            }
            //
            // get queue format from old map if an entry exists with the same (guid,name)
            // and has a queue format ready
            //
            if (pmapNT4SitesOld)
            {
                NT4SitesEntry * pNT4SiteOld;
                if (pmapNT4SitesOld->Lookup(pNT4Site->guidSiteId , pNT4SiteOld))
                {
                    if (CompareStringsNoCaseUnicode(pNT4Site->pwszPscName, pNT4SiteOld->pwszPscName) == 0)
                    {
                        if ((QUEUE_FORMAT *)pNT4SiteOld->pqfPsc != NULL)
                        {
                            //
                            // we have a queue format from the previous table.
                            // copy the queue format
                            //
                            LPCWSTR pwszDirectID = pNT4SiteOld->pqfPsc->DirectID();
                            ASSERT(pwszDirectID != NULL);
                            if (pwszDirectID != NULL)
                            {
                                AP<WCHAR> pwszTmp = new WCHAR[1+wcslen(pwszDirectID)];
                                wcscpy(pwszTmp, pwszDirectID);
                                pNT4Site->pqfPsc = new QUEUE_FORMAT(pwszTmp.detach());
                            }
                        }
                    }
                    else
                    {
                        // Sanity check.
                        // There is a diffrent NT4 PSC for the same site. It cannot be.
                        // In mixed mode you cannot install new NT4 PSC's, so once a site is mastered
                        // by an NT4 PSC, it must be the same NT4 PSC until that PSC is upgraded to NT5
                        //
                        ASSERT(0);
                    }
                }
            }

            //
            // add entry to the NT4Sites map
            //
            pmapNT4Sites->SetAt(pNT4Site->guidSiteId, pNT4Site);
            pNT4Site.detach();

            //
            // qm-id of PSC
            //
            ASSERT(rgPropVars[e_NT4SitesProp_QM_ID].vt == VT_CLSID);
            //
            // add entry to the QmId map (value is dummy)
            //
            DWORD dwDummy = 0;
            pmapNT4PscQMs->SetAt(*rgPropVars[e_NT4SitesProp_QM_ID].puuid, dwDummy);
        }
    }

    //
    // return results
    //
    *ppmapNT4Sites = pmapNT4Sites.detach();
    *ppmapNT4PscQMs = pmapNT4PscQMs.detach();
    return MQ_OK;
}


HRESULT CGenerateWriteRequests::RefreshNT4Sites()
/*++

Routine Description:
    Refreshes the NT4 PSC maps from the DS, incase a predefined time has passed since the last refresh.
    It does that by building new maps, and replacing the old ones.

Arguments:

Return Value:
    S_OK      - maps were refreshed (or created if it is the first time)
    S_FALSE   - maps were not refreshed because the last refresh was done recently
    Otherwise - errors in creating the new maps. The old maps (if existed) are still intact.

--*/
{
    //
    // enter critical section
    //
    CS cs(m_csNT4Sites);

    //
    // ignore refresh if we're not in mixed mode
    // there is no way back from NT5 pure mode to mixed mode (with NT4), so
    // once we detect we're not in mixed mode anymore, we cease to update the
    // NT4 Sites table therefore continue to be in NT5 pure mode.
    //
    // we init m_fExistNT4PSC to TRUE so we won't stick to NT5 pure mode on startup...
    //
    // To disable this sticky mode behavior, just remove the if statement below
    //
    if (!m_fExistNT4PSC  &&   // there is no NT4 PSCs
        !m_fExistNT4BSC )	  // there is no NT4 BSCs
    {
        return S_FALSE;
    }

    //
    // ignore refresh if last refresh was done and recently
    //
    DWORD dwTickCount = GetTickCount();
    if ((m_dwLastRefreshNT4Sites != 0) &&
        (dwTickCount >= m_dwLastRefreshNT4Sites) &&
        (dwTickCount - m_dwLastRefreshNT4Sites < m_dwRefreshNT4SitesInterval))
    {
        return S_FALSE;
    }

    HRESULT hr;
    //
    // we need to refresh NT4 PSC maps only when there were PSC's before.
    //
    if (m_fExistNT4PSC)
    {
        //
        // create a new map for NT4 PSCs
        //
        P<NT4Sites_CMAP> pmapNT4SitesNew;
        P<NT4PscQMs_CMAP> pmapNT4PscQMsNew;
        hr = CreateNT4SitesMap(m_pmapNT4Sites, &pmapNT4SitesNew, &pmapNT4PscQMsNew);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::RefreshNT4Sites:CreateNT4SitesMap()=%lx"), hr));
            return LogHR(hr, s_FN, 540);
        }
        //
        // delete old NT4Sites map if any, and set new NT4Sites map
        //
        if ((NT4Sites_CMAP *)m_pmapNT4Sites)
        {
            delete m_pmapNT4Sites.detach();
        }
        m_pmapNT4Sites = pmapNT4SitesNew.detach();

        //
        // delete old NT4PscQMs map if any, and set new NT4PscQMs map
        //
        if ((NT4PscQMs_CMAP *)m_pmapNT4PscQMs)
        {
            delete m_pmapNT4PscQMs.detach();
        }
        m_pmapNT4PscQMs = pmapNT4PscQMsNew.detach();

        //
        // refresh flag if we're in mixed mode
        //
        if (m_pmapNT4Sites->GetCount() > 0)
        {
            //
            // there are some NT4 PSC's, wer'e in mixed mode
            //
            m_fExistNT4PSC = TRUE;
        }
        else
        {
            //
            // no NT4 PSC's
            //
            m_fExistNT4PSC = FALSE;
        }
    }

    //
    // if there are PSC's, the info on BSC's is not relevant since we are already
    // in mixed mode. if there are no PSC's we continue to check if there are BSC's
    // (again only if there were BSC's before)
    //
    if (!m_fExistNT4PSC &&  // there is no NT4 PSC
         m_fExistNT4BSC)    // but there were NT4 BSCs
    {
        hr = CheckIfExistNT4BSC(&m_fExistNT4BSC);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::RefreshNT4Sites:CheckIfExistNT4BSC()=%lx"), hr));
            return LogHR(hr, s_FN, 550);
        }
    }

    //
    // mark last refresh time
    //
    m_dwLastRefreshNT4Sites = GetTickCount();    		

    //
    // the map was refreshed
    //
    return (S_OK);
}


BOOL CGenerateWriteRequests::IsInMixedModeWithNT4PSC()
/*++

Routine Description:
    Checks if we are in a mixed mode. This is here because some of the checks whether to
    issue a write request are expensive, and when not in mixed mode it is a waste of time

Arguments:

Return Value:
    TRUE if we're in mixed mode, FALSE otherwise

--*/
{
    //
    // enter critical section
    //
    CS cs(m_csNT4Sites);
    //
    // refresh if its time to do so
    //
    RefreshNT4Sites();
    //
    // return result
    //
    return m_fExistNT4PSC;
}


BOOL CGenerateWriteRequests::LookupNT4Sites(const GUID * pguid, NT4SitesEntry** ppNT4Site)
/*++

Routine Description:
    Given a site guid, retrieves an NT4Sites entry if found.
    the returned entry pointer must not be freed, it points to a CMAP-owned entry.

Arguments:
    pguid     - site id
    ppNT4Site - returned pointer to NT4Sites entry

Return Value:
    TRUE  - site guid was found in the NT4 Site PSC's map, ppNT4Site is set to point to the entry
    FALSE - site guid was not found in the NT4 Site PSC's map

--*/
{
    //
    // enter critical section
    //
    CS cs(m_csNT4Sites);
    //
    // refresh if its time to do so
    //
    RefreshNT4Sites();
    //
    // return the lookup
    //
    return m_pmapNT4Sites->Lookup(*pguid, *ppNT4Site);
}


HRESULT CGenerateWriteRequests::BuildSendWriteRequest(
                         IN  const GUID *    pguidMasterId,
                         IN  unsigned char   ucOperation,
                         IN  DWORD           dwObjectType,
                         IN  LPCWSTR         pwcsPathName,
                         IN  const GUID *    pguidIdentifier,
                         IN  DWORD               cp,
                         IN  const PROPID *      aProp,
                         IN  const PROPVARIANT * apVar)
/*++

Routine Description:
    Sends a write request for an NT4 site

Arguments:
    pguidMasterId       - destination NT4 site id
    ucOperation         - type of opreation - Create, Delete, etc...
    dwObjectType        - type of object - Queue, Machine, erc...
    pwcsPathName        - pathname of object
    pguidIdentifier     - guid of object
    cp                  - properties of object (count)
    aProp               - properties of object (propids)
    apVar               - properties of object (propvars)

Return Value:
    MQDS_OK_REMOTE         - succeeded
    MQDS_NO_RSP_FROM_OWNER - no response for the write request
    MQDS_OWNER_NOT_REACHED - write request message did not reach destination site
    otherwise              - other failures (whether local or in the remote write request)

--*/
{

    //
    // Sending an write request on anoter PSC or PEC
    // is a blocking operation, until:
    //  1) A reply is received from the master to
    //     whom the request was sent. The reponse class
    //     may be ACK or NACK.
    //  2) WRITE_REQUEST_WAIT_LIMIT expire ( i.e. without
    //     receiving respone)
    //

    //
    //  In order to block this routine we create an event
    //  and pass its handle in the write-request and
    //  write-reply messages.
    //  When an write-reply is received the handle
    //  is used to signal the event.
    //  Since this routine limits the time it waits for
    //  the event to be signaled, the write messages
    //  instead of holding the handle will hold a
    //  pointer to a structure that consists of:
    //  1) validation sequence. Will be used by the
    //     the write-receive to varify validty of event's handle
    //  2) event handle
    //  3) status - the hresult included in the write-receive
    //     message.

    HRESULT hr;

    ASSERT(m_fInited);

    //
    // return immediately if wer'e not in mixed mode
    //
    if (!IsInMixedModeWithNT4PSC())
    {
        return MQ_OK;
    }

    //
    // create event for write request response
    //
    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!hEvent)
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 560);
    }

    //
    // create header for write request, destructor will free the event handle
    //
    P<CWriteSyncInfo> pSyncInfo = new CWriteSyncInfo( hEvent);

    //
    //  Prepare Write request message
    //
    CDSBaseUpdate cUpdate;
    CSeqNum snSmallestValue;    // Init to smallest value
    if (pwcsPathName)
    {
        hr = cUpdate.Init(
                        pguidMasterId,
                        snSmallestValue,       // not applicable
                        snSmallestValue,       // not applicable
                        snSmallestValue,       // not applicable
                        FALSE,      // this master is not the owner
                        ucOperation,
                        UPDATE_NO_COPY_NO_DELETE,
                        const_cast<LPWSTR>(pwcsPathName),
                        cp,
                        const_cast<PROPID *>(aProp),
                        const_cast<PROPVARIANT *>(apVar));
    }
    else
    {
        hr = cUpdate.Init(
                        pguidMasterId,
                        snSmallestValue,       // not applicable
                        snSmallestValue,       // not applicable
                        snSmallestValue,       // not applicable
                        FALSE,      // this master is not the owner
                        ucOperation,
                        UPDATE_NO_COPY_NO_DELETE,
                        pguidIdentifier,
                        cp,
                        const_cast<PROPID *>(aProp),
                        const_cast<PROPVARIANT *>(apVar));
    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 570);
    }

    //
    // Calculate the buffer size
    //
    DWORD dwBuffSize;
    hr = cUpdate.GetSerializeSize(&dwBuffSize);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 580);
    }
    //
    //  Add the size of the write request header
    //  The size of write request header depends on the length of requester name
    //
    DWORD RequesterNamesize = sizeof(WCHAR) * (wcslen(m_pwszServerName) + 1);
    DWORD dwSizeWriteRequestHeader = CWriteRequestHeader::CalcSize( RequesterNamesize, m_cbIntermediatePSC);
    dwBuffSize += dwSizeWriteRequestHeader;

    //
    // allocate
    //
    AP< unsigned char> pBuff = new unsigned char[dwBuffSize];

    //
    // prepare DWORD context for the write request
    //
    DWORD dwSyncInfoPtr =
        (DWORD) ADD_TO_CONTEXT_MAP(m_map_MQADS_SyncInfoPtr, pSyncInfo->GetWriteSyncInfoPtr(), s_FN, 1920); //this may throw bad_alloc on win64

    //
    // remember to remove it from mapping when going out of scope
    //
    CAutoDeleteDwordContext cCleanSyncInfoPtr(m_map_MQADS_SyncInfoPtr, dwSyncInfoPtr);
                                                     
#ifdef _DEBUG
#undef new
#endif

    CWriteRequestHeader * pMessage = new(pBuff) CWriteRequestHeader(
                                            DS_PACKET_VERSION,
                                            &m_guidMySiteId,
                                            DS_WRITE_REQUEST,
                                            pguidMasterId,
                                            dwSyncInfoPtr,
                                            RequesterNamesize,
                                            m_pwszServerName,
                                            m_cbIntermediatePSC,
                                            m_pwszIntermediatePSC);
	UNREFERENCED_PARAMETER(pMessage);

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
    unsigned char * ptr = pBuff + dwSizeWriteRequestHeader;

    //
    // write the request parmeters
    //
    DWORD dwTmpSize;
    cUpdate.Serialize( ptr, &dwTmpSize, FALSE /*fInterSite*/);

    //
    // send the request to the destination NT4 site
    //
    hr = SendWriteRequest(pguidMasterId, dwBuffSize, pBuff);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 590);
    }

    //
    // wait for response or timeout
    //
    DWORD dwStatus = WaitForSingleObject( hEvent, m_dwWaitTime );
    if (dwStatus == WAIT_TIMEOUT)
    {
        //
        // no positive or negative response was received
        //
        return LogHR(MQDS_NO_RSP_FROM_OWNER, s_FN, 600);
    }
    if ( dwStatus == WAIT_ABANDONED)
    {
        return LogHR(MQ_ERROR, s_FN, 610);
    }

    //
    //  return the request status received in the write response
    //
    hr = pSyncInfo->GetHr();
    if (hr == MQ_OK)
    {
        hr = MQDS_OK_REMOTE;
    }
    return LogHR(hr, s_FN, 620);
}


HRESULT CGenerateWriteRequests::SendWriteRequest(
                         IN  const GUID *    pguidMasterId,
                         IN  DWORD           dwBuffSize,
                         IN  const BYTE *    pBuff)
/*++

Routine Description:
    Sends a write request to an NT4 site PSC.
    Then waits for a reply to this message, and returns the status of the request

Arguments:
    pguidMasterId - destination NT4 site id
    dwBuffSize    - size of write request data buffer
    pBuff         - write request data buffer

Return Value:
    HRESULT

--*/
{
    //
    // enter critical section, we use data from NT4Sites
    //
    CS cs(m_csNT4Sites);

    //
    // get queue handle for destination
    // if we are PEC we can send directly to the NT4 PSC.
    // if not, the NT4 PSC's will reject the write request since they don't recognize
    // NT5 servers other than the PEC, so we send to the PEC that will forward the request
    // to NT4 PSC
    //
    QUEUE_FORMAT * pqfNT4Site;
    if (m_fIsPEC)
    {
        //
        // we can send directly to the NT4 PSC.
        //
        HRESULT hr = GetQueueFormatForNT4Site(pguidMasterId, &pqfNT4Site);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 630);
        }
    }
    else
    {
        //
        // we are not the PEC. We need to send the request to the PEC that will forward it
        // to the PSC.
        //
        pqfNT4Site = m_pqfRemotePEC;
    }

    //
    // Update performance counters
    //
    // BUGBUG: this might be better after we know we succeeded to send
    //
    UPDATE_COUNTER(&g_pdsCounters->nWriteReqSent,g_pdsCounters->nWriteReqSent++)

    //
    // We send the AdminQ == ResponceQ because the receive (in recvrepl.cpp)
    // function receives only the responce queue. But we actually need the
    // admin and don't mind about the responce queue. So we pass the admin
    // queue as a responce queue and so we get the admin queue in the receive
    // function. The responce queue is important in the ReceiveAck function
    // (also in recvrepl.cpp). There it is important because the responce queue
    // is the destination queue for re-transmitting the message as a responce
    // for the NACK.
    //
    handle_t hBind = NULL;
    HRESULT hr = GetRpcClientHandle(&hBind);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 635);   // MQ_E_GET_RPC_HANDLE
    }
    ASSERT(hBind);

	//
	// ISSUE-2000/07/25-ilanh  - temporarily converting QUEUE_FORMAT to format name 
	// is FormatName is what we need or PathName ??
	//
	WCHAR lpwszDestination[128];
	ULONG ulDestinationNameLen = sizeof(lpwszDestination)/sizeof(WCHAR);

	hr = MQpQueueFormatToFormatName(
			 pqfNT4Site,
			 lpwszDestination,
 			 ulDestinationNameLen,
			 &ulDestinationNameLen,
             false
			 );

	if (FAILED(hr))
	{
        return LogHR(hr, s_FN, 637);
	}

/*
	WCHAR lpwszAdminResp[128];
	ULONG ulAdminRespNameLen = sizeof(lpwszAdminResp)/sizeof(WCHAR);

	hr = MQpQueueFormatToFormatName(
			 &m_WriteReqRespQueueFormat,
			 lpwszAdminResp,
 			 ulAdminRespNameLen,
			 &ulAdminRespNameLen,
             false
			 );

	if (FAILED(hr))
	{
        return LogHR(hr, s_FN, 638);
	}
*/    


	hr = QMRpcSendMsg( 
			hBind,
			lpwszDestination, /** pqfNT4Site **/
			dwBuffSize,
			pBuff,
			m_dwWriteMsgTimeout,
			MQMSG_ACKNOWLEDGMENT_NACK_REACH_QUEUE,
			DS_WRITE_REQ_PRIORITY,
			m_WriteReqRespFormatName  // lpwszAdminResp
			);

    if (FAILED(hr))
    {
        DBGMSG((
			DBGMOD_REPLSERV, 
			DBGLVL_ERROR, 
			TEXT("ERROR(::SendWriteRequest), SendWriteRequestMsg(%ls) failed, hr- %lxh"),
            lpwszDestination,
			hr
			)) ;

        return LogHR(hr, s_FN, 640);
    }

    //
    // return results
    //
    return MQ_OK;
}


HRESULT CGenerateWriteRequests::GetQueueFormatForNT4Site(
                                   const GUID * pguidMasterId,
                                   QUEUE_FORMAT ** ppqfNT4Site)
/*++

Routine Description:
    Returns a queue format for the private input queue of the destination site PSC
    Looks in the NT4Sites entry for a cached value, if not found, creates it, and
    returns a pointer to it
    Must not free the QUEUE_FORMAT pointed data since it is a pointer to a CMAP-owned object

Arguments:
    pguidMasterId       - destination NT4 site id
    ppqfNT4Site         - returned pointer to queue format

Return Value:
    HRESULT

--*/
{
    NT4SitesEntry * pNT4Site;

    //
    // enter critical section
    //
    CS cs(m_csNT4Sites);

    //
    // lookup the NT4 site
    //
    if (!LookupNT4Sites(pguidMasterId, &pNT4Site))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CGenerateWriteRequests::GetQueueFormatForNT4Site: Master site is not NT4")));
        ASSERT(0);
        return LogHR(MQDS_UNKNOWN_SOURCE, s_FN, 650);
    }

    //
    // check the queue format
    //
    if ((QUEUE_FORMAT *)pNT4Site->pqfPsc == NULL)
    {
        //
        // queue format not created yet, create the queue format
        //
        pNT4Site->pqfPsc = CreateQueueFormat(pNT4Site->pwszPscName, MQIS_QUEUE_NAME);
    }

    //
    // return results
    //
    *ppqfNT4Site = (QUEUE_FORMAT *)pNT4Site->pqfPsc;
    return MQ_OK;
}


void CGenerateWriteRequests::FillObjInfoRequest(
                         IN DWORD        dwObjectType,
                         IN LPCWSTR      pwcsPathName,
                         IN const GUID * pguidIdentifier,
                         DWORD           cpNT4,
                         PROPID          aPropNT4[  ],
                         PROPVARIANT     apVarNT4[  ],
                         DWORD           cp,
                         PROPID          aProp[  ],
                         PROPVARIANT     apVar[  ],
                         IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest)
/*++

Routine Description:
    Fills obj info request. It tries to find the requested props in the converted
    to NT4 props, and if not found, then in the original props, and if not found
    there, then look at the DS for it.

Arguments:
    dwObjectType            - type of object (queue, machine)
    pwcsPathName            - pathname of object
    pguidIdentifier         - object's guid
    cpNT4                   - NT4 properties of object (count)
    aPropNT4                - NT4 properties of object (propids)
    apVarNT4                - NT4 properties of object (propvars)
    cp                      - properties of object (count)
    aProp                   - properties of object (propids)
    apVar                   - properties of object (propvars)
    pObjInfoRequest         - requested object props

Return Value:
    HRESULT

--*/
{
    ASSERT(pObjInfoRequest);
    ASSERT(pObjInfoRequest->cProps > 0);

    //
    // we fill the propvars in obj info, but if the DS call later for the unknown props fails
    // we like to clear the propvars in obj info before we return them.
    // we attachStaticClean to it because we don't want to free the array, just clean
    // the filled propvars.
    // we detach it when we return these propvars at the end.
    //
    CAutoCleanPropvarArray cCleanObjPropvars;
    cCleanObjPropvars.attachStaticClean(pObjInfoRequest->cProps, pObjInfoRequest->pPropVars);

    //
    // we might need to go to the DS for some props we didn't find in the given
    // props, so we allocate a place for them here
    //
    AP<PROPID> rgUnknownPropIDs = new PROPID [pObjInfoRequest->cProps];
    AP<ULONG> rgIndexesOfUnknownProps = new ULONG [pObjInfoRequest->cProps];
    ULONG cUnknownProps = 0;

    //
    // loop over the properties in the info request
    //
    for (ULONG ulProp = 0; ulProp < pObjInfoRequest->cProps; ulProp++)
    {
        //
        // look for the propid in the NT4 props
        //
        ASSERT(pObjInfoRequest->pPropIDs);
        PROPID propid = pObjInfoRequest->pPropIDs[ulProp];
        PROPVARIANT * pPropVar = FindPropInArray(propid, cpNT4, aPropNT4, apVarNT4);

        //
        // if not found, look for the propid in the original props
        //
        if (!pPropVar)
        {
            pPropVar = FindPropInArray(propid, cp, aProp, apVar);
        }

        //
        // if we still not found, remember to ask it from the DS
        //
        if (!pPropVar)
        {
            rgUnknownPropIDs[cUnknownProps] = propid;
            rgIndexesOfUnknownProps[cUnknownProps] = ulProp;
            cUnknownProps++;
        }
        else
        {
            //
            // duplicate the found property
            //
            CMQVariant varTmp(*pPropVar);
            ASSERT(pObjInfoRequest->pPropVars);
            ASSERT((pObjInfoRequest->pPropVars[ulProp].vt == VT_EMPTY) ||
                   (pObjInfoRequest->pPropVars[ulProp].vt == VT_NULL));
            pObjInfoRequest->pPropVars[ulProp] = *(varTmp.CastToStruct());
            varTmp.CastToStruct()->vt = VT_EMPTY;
        }
    }

    //
    // if we have unknown properties, query them from the DS
    //
    if (cUnknownProps > 0)
    {
        //
        // alloc place for results
        //
        CAutoCleanPropvarArray cCleanUnknownProps;
        PROPVARIANT * rgUnknownPropVars = cCleanUnknownProps.allocClean(cUnknownProps);

        //
        // qeury ds
        //
        CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
        HRESULT hr = DSCoreGetProps(
                            dwObjectType,
                            pwcsPathName,
                            pguidIdentifier,
                            cUnknownProps,
                            rgUnknownPropIDs,
                            &requestDsServerInternal,
                            rgUnknownPropVars);
        if (FAILED(hr))
        {
            pObjInfoRequest->hrStatus = hr;
            LogHR(hr, s_FN, 1900);
            return;
        }

        //
        // go over the retrieved props, and fill the unknown props
        //
        for (ULONG ulUnknownProp = 0; ulUnknownProp < cUnknownProps; ulUnknownProp++)
        {
            //
            // use the retrieved property w/o duplicate, and set the retrived
            // to VT_EMPTY so it won't be freed
            //
            ULONG ulPropToSet = rgIndexesOfUnknownProps[ulUnknownProp];
            pObjInfoRequest->pPropVars[ulPropToSet] = rgUnknownPropVars[ulUnknownProp];
            rgUnknownPropVars[ulUnknownProp].vt = VT_EMPTY;
        }
    }

    //
    // don't free the filled props, we return them
    //
    cCleanObjPropvars.detach();

    //
    // return results
    //
    pObjInfoRequest->hrStatus = MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\wrrmsg.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name: 

	wrrmsg.h

Abstract: 

    header for write requests response class.

Author:

    Ilan Herbst    (ilanh)   6-Aug-2000 

--*/

#ifndef _WRRMSG_H_
#define _WRRMSG_H_

#include "msgprop.h"

#include <ex.h>
#include <rt.h>

//---------------------------------------------------------
//
//  class CQueueHandle
//
//---------------------------------------------------------
class CQueueHandle {
public:
    CQueueHandle(HANDLE h = 0) : m_h(h) {}
   ~CQueueHandle()               { if (m_h != 0) MQCloseQueue(m_h); }

    HANDLE* operator &()         { return &m_h; }
    operator HANDLE() const      { return m_h; }
    HANDLE detach()              { HANDLE h = m_h; m_h = 0; return h; }

private:
    CQueueHandle(const CQueueHandle&);
    CQueueHandle& operator=(const CQueueHandle&);

private:
    HANDLE m_h;
};


//---------------------------------------------------------
//
//  class CWriteRequestsReceiveMsg
//
//---------------------------------------------------------
class CWriteRequestsReceiveMsg : public CMsgProperties
{
public:

    CWriteRequestsReceiveMsg(
		BOOL fIsPec,
		GUID QmGuid
        );

public:

	void HandleReceiveMsg();

    static void WINAPI ReceiveMsgSucceeded(EXOVERLAPPED* pov);
    static void WINAPI ReceiveMsgFailed(EXOVERLAPPED* pov);

private:

	void OpenQueue(BOOL fIsPec, GUID QmGuid);

	LPWSTR 
	MQISQueueFormatName( 
		GUID	QmGuid,
		BOOL    fIsPec = FALSE 
		);

	void RequestNextMessage();
	void SafeRequestNextMessage();

private:
    EXOVERLAPPED    m_WrrOv;
	CQueueHandle    m_hQueue;             
};

#endif //_WRRMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\wrrmsg.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    wrrmsg.cpp

Abstract:

    Implementation write requests response class.

Author:

    Ilan Herbst    (IlanH)   6-Aug-2000 

--*/

#include "ds_stdh.h"
#include "wrrmsg.h"
#include "wrtreq.h"
#include <rt.h>
#include <tr.h>
#include <mqexception.h>
#include <privque.h>
#include <fntoken.h>
#include <mqformat.h>

#include "wrrmsg.tmh"

const TraceIdEntry WrrMsg = L"WriteRequestsReceiveMsg";

extern CGenerateWriteRequests g_GenWriteRequests;

CWriteRequestsReceiveMsg::CWriteRequestsReceiveMsg(
	BOOL fIsPec,
	GUID QmGuid
	) :
    m_WrrOv(ReceiveMsgSucceeded, ReceiveMsgFailed)
{
	OpenQueue(fIsPec, QmGuid);

	//
	// Attach the Queue Handle to the completion port and start getting messages
	//
	ExAttachHandle(m_hQueue);
	RequestNextMessage();
}


void CWriteRequestsReceiveMsg::RequestNextMessage()
/*++

Routine Description:
	Request next message.
	The function 

Arguments:
	None

Returned Value:
	MQ_OK if success, else error code. 

--*/
{
	InitMsgProp();

	//
	// Request the next message
	//
	HRESULT hr = MQReceiveMessage(
					m_hQueue,
					INFINITE,
					MQ_ACTION_RECEIVE,          
					&m_MsgProps,
					&m_WrrOv,
					NULL,
					NULL,
					NULL 
					);                   
	
	if (hr == MQ_ERROR_BUFFER_OVERFLOW)
	{
		//
		// The failure is because the Allocated Message Buffer is to small
		// Reallocate the buffer and retry.
		// 
		ReAllocMsgBody();

		hr = MQReceiveMessage(
				m_hQueue,
				INFINITE,
				MQ_ACTION_RECEIVE,          
				&m_MsgProps,
				&m_WrrOv,
				NULL,
				NULL,
				NULL 
				);                   
	}

	if(SUCCEEDED(hr))
		return;
	
	TrERROR(WrrMsg, "Failed to received write request response or ack, hr = 0x%x", hr);
	throw bad_hresult(hr);
}


LPWSTR  
CWriteRequestsReceiveMsg::MQISQueueFormatName( 
	GUID	QmGuid,
    BOOL    fIsPec 
	)
/*++

Routine Description:
	Get local MQIS queue FormatName.
	this must be in the format with the Qm Guid. 
	PRIVATE=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\00000001	 or \00000005

	the function allocate the returned QueueFormatName string, which need to be free by the caller.

Arguments:
	QmGuid - QM GUID.
	fIsPec - flag to indicate if we are mixed mode pec.

Returned Value:
	QueueFormatName string.

--*/
{
	QUEUE_FORMAT qf(QmGuid, (fIsPec ? NT5PEC_REPLICATION_QUEUE_ID : REPLICATION_QUEUE_ID));

    DWORD Length = FN_PRIVATE_TOKEN_LEN + 1 + GUID_STR_LENGTH + 1 + 8 + 1;

    AP<WCHAR> lpwFormatName = new WCHAR[Length];

	HRESULT hr = MQpQueueFormatToFormatName(
					 &qf,
					 lpwFormatName,
 					 Length,
					 &Length,
					 false
					 );

	ASSERT(hr == MQ_OK);
	DBG_USED(hr);
    
	return(lpwFormatName.detach());
}


void CWriteRequestsReceiveMsg::OpenQueue(BOOL fIsPec, GUID QmGuid)
/*++

Routine Description:
	Open the write requests response queue.
	The Queue is opened with MQ_RECEIVE_ACCESS, MQ_DENY_RECEIVE_SHARE.

	the function throw bad_hresult() if failed.

Arguments:
	fIsPec - flag to indicate if we are mixed mode pec
	QmGuid - QM GUID.

Returned Value:
	None.

--*/
{
	//
	// Get QueueFormatName
	//
	AP<WCHAR> pQueueFormatName = MQISQueueFormatName(QmGuid, fIsPec);

	//
	// Open the Queue for Receive, No share
	//
	HRESULT hr = MQOpenQueue( 
					pQueueFormatName,
					MQ_RECEIVE_ACCESS,
					MQ_DENY_RECEIVE_SHARE,
					&m_hQueue 
					);

	if(FAILED(hr))
	{
		TrERROR(WrrMsg, "Fail to open Queue for WriteRequestResponse QueueFormatName = %ls, hr = 0x%x", pQueueFormatName, hr);
		throw bad_hresult(hr);
	}

	TrTRACE(WrrMsg, "Open write request response queue, QueueFormatName = %ls", pQueueFormatName);
}


void CWriteRequestsReceiveMsg::SafeRequestNextMessage()
/*++

Routine Description:
	Treat exceptions from RequestNextMessage.
	By sleeping 1 Sec and retrying.

Arguments:
	None

Returned Value:
	None 

--*/
{
	for(;;)
	{
		try
		{
			RequestNextMessage();
			return;
		}
		catch(const bad_hresult& exp)
		{
			TrERROR(WrrMsg, "SafeRequestNextMessage(): RequestNextMessage throw bad_hresult exception, hr = 0x%x", exp.error());
		}
		catch (const exception& exp)
		{
			TrERROR(WrrMsg, "SafeRequestNextMessage(): RequestNextMessage throw exception, what = %s", exp.what());
		}

		TrWARNING(WrrMsg, "SafeRequestNextMessage(): Sleeping for 1 second");
		Sleep(1000);
	}
}


void CWriteRequestsReceiveMsg::HandleReceiveMsg()
/*++

Routine Description:
    Handle write request response messages.

Arguments:
	None.

Return Value:
    None.

--*/
{
    ASSERT(MsgBody() != NULL);
    ASSERT(MsgBodyLen() <= m_MsgBodyBufferSize);

	//
	// Don't handle empty messages
	//
	if(MsgBodyLen() == 0)
	{
		TrERROR(WrrMsg, "HandleReceiveMsg(): WriteRequest Received empty message");
		return;
	}

    //
    //  Handle messages according to their class
    //
    if (MsgClass() == MQMSG_CLASS_NORMAL)
    {
        g_GenWriteRequests.ReceiveReply(this);
    }
    else if(MQCLASS_NACK(MsgClass()))
    {
        g_GenWriteRequests.ReceiveNack(this);
    }
    else
    {
		TrERROR(WrrMsg, "HandleReceiveMsg() unexpected message class 0x%x", MsgClass());
		throw bad_hresult(MQ_ERROR);
    }
}


VOID WINAPI CWriteRequestsReceiveMsg::ReceiveMsgSucceeded(EXOVERLAPPED* pov)
/*++

Routine Description:
    Receive Message Success routine.

Arguments:
	pov - pointer to EXOVERLAPPED 

Return Value:
    None.

--*/
{
    CWriteRequestsReceiveMsg* pWrrMsg = CONTAINING_RECORD(pov, CWriteRequestsReceiveMsg, m_WrrOv);

	try
	{
	    pWrrMsg->HandleReceiveMsg(); 
	}
    catch (const exception&)
    {
		TrERROR(WrrMsg, "HandleReceiveMsg() throw exception");
	    Sleep(1000);
    }

	pWrrMsg->SafeRequestNextMessage();
}


VOID WINAPI CWriteRequestsReceiveMsg::ReceiveMsgFailed(EXOVERLAPPED* pov)
/*++

Routine Description:
    Receive Message Failure routine.

Arguments:
	pov - pointer to EXOVERLAPPED 

Return Value:
    None.

--*/
{
    CWriteRequestsReceiveMsg* pWrrMsg = CONTAINING_RECORD(pov, CWriteRequestsReceiveMsg, m_WrrOv);

	if(pov->GetStatus() == MQ_ERROR_BUFFER_OVERFLOW)
	{
		//
		// The failure is because the Allocated Message Buffer is to small
		// Reallocate the buffer and RequestNextMessage.
		// 
		pWrrMsg->ReAllocMsgBody();
		pWrrMsg->SafeRequestNextMessage();
		return;
	}

	TrERROR(WrrMsg, "ReceiveMsgFailed Status = 0x%x", pov->GetStatus());

    //
    // Let's sleep a little (one second).
    // Otherwise, in low resources condition, we may enter an
    // endless loop of failures.
    //
    Sleep(1000);

	pWrrMsg->SafeRequestNextMessage();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqads\wrtreq.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
    wrtreq.h

Abstract:
    class to encapsulate the code for generating write requests to NT4 PSC's in mixed mode

Author:
    Raanan Harari (raananh)

--*/

#ifndef _WRTREQ_H_
#define _WRTREQ_H_

#include "_guid.h" // for CMAP based on guids
#include "qformat.h" // for QUEUE_FORMAT
#include "mqads.h" // for MQDS_OBJ_INFO_REQUEST
#include "dsreqinf.h"
#include "msgprop.h"
#include "wrrmsg.h"
//
// auto release pointer for QUEUE_FORMAT
// valid only for direct format !!!
//
class CPtrQueueFormat
{
public:
    CPtrQueueFormat()
    {
        m_pqf = NULL;
    }

    ~CPtrQueueFormat()
    {
        if (m_pqf)
        {
            m_pqf->DisposeString();
            delete m_pqf;
        }
    }

    operator QUEUE_FORMAT*() const
    {
        return m_pqf;
    }

    QUEUE_FORMAT** operator&()
    {
        return &m_pqf;
    }

    QUEUE_FORMAT* operator->() const
    {
        return m_pqf;
    }

    CPtrQueueFormat& operator=(QUEUE_FORMAT* pqf)
    {
        ASSERT(m_pqf == NULL);
        m_pqf = pqf;
        return *this;
    }

    QUEUE_FORMAT * detach()
    {
        QUEUE_FORMAT * pqf = m_pqf;
        m_pqf = NULL;
        return pqf;
    }

private:
    QUEUE_FORMAT * m_pqf;
};

//
// NT4 Site entry
//
struct NT4SitesEntry
{
    GUID guidSiteId;
    AP<WCHAR> pwszPscName;
    CPtrQueueFormat pqfPsc;
};

//
// map of NT4 Site entries by site id
//
typedef CMap<GUID, const GUID&, NT4SitesEntry*, NT4SitesEntry*> NT4Sites_CMAP;

//
// Destruction of NT4 Site entries
//
inline void AFXAPI DestructElements(NT4SitesEntry ** ppEntry, int n)
{
    for (int i=0;i<n;i++)
    {
        //
        // members are auto release
        //
        delete *ppEntry;
        ppEntry++;
    }
}

//
// map of NT4 PSC QM's
//
typedef CMap<GUID, const GUID&, DWORD, DWORD> NT4PscQMs_CMAP;


//
// CGenerateWriteRequests class
//
class CGenerateWriteRequests
{
public:
    CGenerateWriteRequests();

    ~CGenerateWriteRequests();

    HRESULT Initialize();

    void InitializeDummy();

    void ReceiveNack(CWriteRequestsReceiveMsg* pWrrMsg);

    void ReceiveReply(CWriteRequestsReceiveMsg* pWrrMsg);

    BOOL IsQmIdNT4Psc(const GUID * pguid);

    HRESULT AttemptCreateQueue(
                         IN LPCWSTR          pwcsPathName,
                         IN DWORD            cp,
                         IN PROPID           aProp[  ],
                         IN PROPVARIANT      apVar[  ],
                         IN CDSRequestContext * pRequestContext,
                         OUT BOOL *          pfGeneratedWriteRequest,
                         IN OUT MQDS_OBJ_INFO_REQUEST * pQueueInfoRequest,
                         IN OUT MQDS_OBJ_INFO_REQUEST * pQmInfoRequest);

    HRESULT AttemptDeleteObject(
                         IN DWORD               dwObjectType,
                         IN LPCWSTR             pwcsPathName,
                         IN const GUID *        pguidIdentifier,
                         IN CDSRequestContext * pRequestContext,
                         OUT BOOL *             pfGeneratedWriteRequest,
                         IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest);

    HRESULT AttemptSetObjectProps(
                         DWORD                  dwObjectType,
                         LPCWSTR                pwcsPathName,
                         const GUID *           pguidIdentifier,
                         DWORD                  cp,
                         PROPID                 aProp[  ],
                         PROPVARIANT            apVar[  ],
                 IN      CDSRequestContext *    pRequestContext,
                 OUT     BOOL *                 pfGeneratedWriteRequest,
                 IN OUT  MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
                 IN      SECURITY_INFORMATION     SecurityInformation ) ;

    HRESULT CheckQueueIsOwnedByNT4Site(IN LPCWSTR pwcsPathName,
                                       IN const GUID * pguidIdentifier,
                                       OUT BOOL * pfIsOwnedByNT4Site,
                                       OUT GUID * pguidOwnerNT4Site,
                                       OUT PROPVARIANT * pvarObjSecurity);

    HRESULT BuildSendWriteRequest(
                         IN  const GUID *    pguidMasterId,
                         IN  unsigned char   ucOperation,
                         IN  DWORD           dwObjectType,
                         IN  LPCWSTR         pwcsPathName,
                         IN  const GUID *    pguidIdentifier,
                         IN  DWORD               cp,
                         IN  const PROPID *      aProp,
                         IN  const PROPVARIANT * apVar);
	
    BOOL IsInMixedMode();

    HRESULT CheckMachineIsOwnedByNT4Site(IN LPCWSTR pwcsPathName,
                                         IN const GUID * pguidIdentifier,
                                         OUT BOOL * pfIsOwnedByNT4Site,
                                         OUT GUID * pguidOwnerNT4Site,
                                         OUT PROPVARIANT * pvarObjSecurity,
                                         IN OUT MQDS_OBJ_INFO_REQUEST * pQmInfoRequest);


	HRESULT  
	GetMQISAdminQueueName(
		WCHAR **ppwQueueFormatName,
		BOOL    fIsPec = FALSE
		);


private:
    DWORD  m_dwWriteMsgTimeout;
    DWORD  m_dwWaitTime;
    DWORD  m_dwRefreshNT4SitesInterval;

    //
    // the below critical section serializes access to:
    // m_pmapNT4Sites, m_pmapNT4PscQMs, m_dwLastRefreshNT4Sites, m_fExistNT4PSC, m_fExistNT4BSC
    //
    CCriticalSection m_csNT4Sites;
    P<NT4Sites_CMAP> m_pmapNT4Sites;
    P<NT4PscQMs_CMAP> m_pmapNT4PscQMs;
    DWORD  m_dwLastRefreshNT4Sites;
    BOOL m_fExistNT4PSC;
    //
    // value of m_fExistNT4BSC is valid (e.g. computed) only if m_fExistNT4PSC is false.
    // otherwise it is not relevant since we already know we're in mixed mode.
    //
    BOOL m_fExistNT4BSC;

    GUID m_guidMyQMId;
    GUID m_guidMySiteId;
    BOOL m_fIsPEC;
    BOOL m_fInited;
    AP<WCHAR> m_WriteReqRespFormatName;
	P<CWriteRequestsReceiveMsg> m_pWrrMsg;

    BOOL m_fDummyInitialization;
    AP<WCHAR> m_pwszServerName;
    //
    // If we're not the PEC we need to send write requests to the PEC that will forward to
    // the NT4 PSC. for this we keep the queue format for the PEC, and its name.
    //
    CPtrQueueFormat m_pqfRemotePEC;
    AP<WCHAR> m_pwszRemotePECName;
    //
    // IF we're the PEC, we set the below to NULL and 0. otherwise we use
    // the PEC as our intermediate PSC to NT4 servers, so we point them to the PEC
    // No need for auto release for the string, it just points to m_pwszRemotePECName
    // if we're not the PEC.
    //
    LPWSTR m_pwszIntermediatePSC;
    DWORD m_cbIntermediatePSC;

    //
    // map between a PTR (WRITE_SYNC_INFO *) and a DWORD to be sent on the write
    // request as a context to the write-reply processing
    //
    CContextMap m_map_MQADS_SyncInfoPtr;

    HRESULT CheckSiteIsNT4Site(IN const GUID * pguidIdentifier,
                               OUT BOOL * pfIsNT4Site);


    HRESULT CheckNewQueueIsOwnedByNT4Site(IN LPCWSTR pwcsPathName,
                                          OUT BOOL * pfIsOwnedByNT4Site,
                                          OUT GUID * pguidOwnerNT4Site,
                                          OUT PROPVARIANT * pvarQmSecurity,
                                          IN OUT MQDS_OBJ_INFO_REQUEST * pQmInfoRequest);

    HRESULT RefreshNT4Sites();

    BOOL IsInMixedModeWithNT4PSC();

    BOOL LookupNT4Sites(const GUID * pguid, NT4SitesEntry** ppNT4Site);	

    HRESULT SendWriteRequest(
                         IN  const GUID *    pguidMasterId,
                         IN  DWORD           dwBuffSize,
                         IN  const BYTE *    pBuff);

    HRESULT GetQueueFormatForNT4Site(const GUID * pguidMasterId,
                                     QUEUE_FORMAT ** ppqfNT4Site);

    void FillObjInfoRequest(
                         IN DWORD        dwObjectType,
                         IN LPCWSTR      pwcsPathName,
                         IN const GUID * pguidIdentifier,
                         DWORD           cpNT4,
                         PROPID          aPropNT4[  ],
                         PROPVARIANT     apVarNT4[  ],
                         DWORD           cp,
                         PROPID          aProp[  ],
                         PROPVARIANT     apVar[  ],
                         IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest);
};

//
// get current state of configuration
//
inline BOOL CGenerateWriteRequests::IsInMixedMode()
{
    //
    // enter critical section
    //
    CS cs(m_csNT4Sites);
    return (m_fExistNT4PSC || m_fExistNT4BSC);
}



#endif //_WRTREQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscli\chndssrv.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    chndssrv.cpp

Abstract:
    Change DS server class
     when exception happen

Author:
    Doron Juster  (DoronJ)

--*/

#include "stdh.h"
#include "ds.h"
#include "chndssrv.h"
#include "dsproto.h"
#include "_secutil.h"
#include "mqcacert.h"
#include "mqkeyhlp.h"
#include "rpcdscli.h"
#include "freebind.h"
#include "uniansi.h"
#include "winsock.h"
#include "mqcert.h"
#include "dsreg.h"
#include "dsutils.h"
#include <mqsec.h>
#include "dsclisec.h"

#include "chndssrv.tmh"

extern CFreeRPCHandles           g_CFreeRPCHandles ;
extern QMLookForOnlineDS_ROUTINE g_pfnLookDS ;
extern MQGetMQISServer_ROUTINE   g_pfnGetServers ;
extern NoServerAuth_ROUTINE      g_pfnNoServerAuth ;
extern WCHAR                     g_szMachineName[];

extern BOOL g_fWorkGroup;

extern HRESULT RpcInit( LPWSTR  pServer,
                        MQRPC_AUTHENTICATION_LEVEL* peAuthnLevel,
                        ULONG ulAuthnSvc,
                        BOOL    *pProtocolNotSupported,
                        BOOL    *pLocalRpc );

#define  SET_RPCBINDING_PTR(pBinding)                       \
    LPADSCLI_DSSERVERS  pBinding ;                          \
    if (m_fPerThread  &&  (tls_bind_data))                  \
    {                                                       \
        pBinding = &((tls_bind_data)->sDSServers) ;         \
    }                                                       \
    else                                                    \
    {                                                       \
        pBinding = &mg_sDSServers ;                         \
    }

//+----------------------------------------
//
//   CChangeDSServer::SetAuthnLevel()
//
//+----------------------------------------

inline void
CChangeDSServer::SetAuthnLevel()
{
    SET_RPCBINDING_PTR(pBinding) ;

    pBinding->eAuthnLevel = MQRPC_SEC_LEVEL_MAX;
    pBinding->ulAuthnSvc = RPC_C_AUTHN_GSS_KERBEROS;
}

//+-------------------------------------------------------------------
//
//  CChangeDSServer::Init()
//
//+-------------------------------------------------------------------

void
CChangeDSServer::Init( IN BOOL fSetupMode,
                       IN BOOL fQMDll,
                       IN LPCWSTR szServerName /* =NULL */ )
{
    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,  L"CChangeDSServer::Init"));
    
    CS  Lock(m_cs);

    SET_RPCBINDING_PTR(pBinding) ;
	if (!pBinding->fServerFound)
	{
		pBinding->wzDsIP[0] = TEXT('\0') ;
	}

    TCHAR wzDs[ MAX_REG_DSSERVER_LEN ];
    if (szServerName == NULL)
    {
        m_fUseSpecificServer = FALSE;
        if (!m_fFirstTimeInit)
        {
           if (fQMDll)
           {
              //
              // Write blank server name in registry.
              //
              WCHAR wszBlank[1] = {0} ;
              DWORD dwSize = sizeof(WCHAR) ;
              DWORD dwType = REG_SZ;
              LONG rc = SetFalconKeyValue(
                            MSMQ_DS_CURRENT_SERVER_REGNAME,
                            &dwType,
                            wszBlank,
                            &dwSize );
              if (rc != ERROR_SUCCESS)
              {
                  DBGMSG((DBGMOD_DSAPI, DBGLVL_ERROR, _T("Failed to write to registry, status 0x%x"), rc));
                  ASSERT(rc == ERROR_SUCCESS) ;
              }
              
			  DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE, L"Wrote blank CurrentMQISServer to registry"));
			  
           }
           m_fFirstTimeInit = TRUE ;
        }

        //
        // If we're loaded by RT and run on a remoteQM configuration then
        // get the MQIS servers list from the remote QM.
        //
        if (g_pfnGetServers)
        {
			HRESULT hr1 = (*g_pfnGetServers)(&m_fClient);
			UNREFERENCED_PARAMETER(hr1);
			ASSERT(m_fClient);
        }

        SetAuthnLevel() ;
        m_fSetupMode = fSetupMode ;
        m_fQMDll     = fQMDll ;

        //
        //  Is it a static DS servers configuration ?
        //
        if ( !fSetupMode)
        {
            //
            //  Read the list of static servers ( the same
            //  format as MQIS server list)
            //
            READ_REG_DS_SERVER_STRING( wzDs,
                                       MAX_REG_DSSERVER_LEN,
                                       MSMQ_STATIC_DS_SERVER_REGNAME,
                                       MSMQ_DEFAULT_DS_SERVER);
                                       
  		    DBGMSG((DBGMOD_DSAPI, DBGLVL_TRACE, L"read StaticMQISServer from registry: %ls", wzDs));
			                   
            if ( CompareStringsNoCaseUnicode( wzDs, MSMQ_DEFAULT_DS_SERVER ))
            {
                //
                //  Static configuration : Init() is not
                //  called again to refresh the servers list
                //
                m_fUseSpecificServer = TRUE;
                
	  		    DBGMSG((DBGMOD_DSAPI,DBGLVL_WARNING,  L"Will use statically configured MQIS server! "));
            }
        }

        if ( !m_fUseSpecificServer)
        {
            //
            //  Read the list of servers from registry
            //
            READ_REG_DS_SERVER_STRING( wzDs,
                                       MAX_REG_DSSERVER_LEN,
                                       MSMQ_DS_SERVER_REGNAME,
                                       MSMQ_DEFAULT_DS_SERVER ) ;

  		    DBGMSG((DBGMOD_DSAPI, DBGLVL_TRACE, L"read MQISServer from registry: %ls", wzDs));
        }
    }
    else
    {
        pBinding->fServerFound = FALSE;
        m_fUseSpecificServer = TRUE;
        wcscpy( wzDs, szServerName ) ;
    }

    //
    // parse the server's list
    //
    // since Init() can be called several times in this class, we need to
    // delete the old servers array before we set it again.
    // delete can accept NULL, but this is more explicit
    //
    if ((MqRegDsServer *)m_rgServers)
    {
        delete[] m_rgServers.detach();
    }
    ParseRegDsServers(wzDs, &m_cServers, &m_rgServers);
    if (m_cServers == 0)
    {
       if (!fSetupMode)
       {
          //
          // Bug 5413
          //
          ASSERT(0) ;
       }

       if (!m_fEmptyEventIssued)
       {
          //
          // Issue the event only once.
          //
          m_fEmptyEventIssued = TRUE ;
          REPORT_CATEGORY(EVENT_ERROR_DS_SERVER_LIST_EMPTY, CATEGORY_KERNEL);
       }
       return ;
    }

    //
    // Read minimum interval between successive ADS searches (seconds)
    //
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    DWORD dwDefault = MSMQ_DEFAULT_DSCLI_ADSSEARCH_INTERVAL ;
    LONG rc = GetFalconKeyValue( MSMQ_DSCLI_ADSSEARCH_INTERVAL_REGNAME,
                                 &dwType,
                                 &m_dwMinTimeToAllowNextAdsSearch,
                                 &dwSize,
                                 (LPCTSTR) &dwDefault );
    if (rc != ERROR_SUCCESS)
    {
        ASSERT(0);
        m_dwMinTimeToAllowNextAdsSearch = dwDefault;
    }

    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,  L"read DSCli interval for next server searches in ADS: %d seconds", m_dwMinTimeToAllowNextAdsSearch));
                   
    m_fInitialized = TRUE ;
    //
    //  Read enterprise Id ( if not in setup mode), and PerThread flag.
    //
    if ( !fSetupMode )
    {
        DWORD dwSize = sizeof(GUID);
        DWORD dwType = REG_BINARY;
        LONG rc = GetFalconKeyValue(MSMQ_ENTERPRISEID_REGNAME,
                                    &dwType,
                                    &m_guidEnterpriseId,
                                    &dwSize );
        ASSERT(rc == ERROR_SUCCESS) ;
		DBG_USED(rc);

        m_fPerThread =  MSMQ_DEFAULT_THREAD_DS_SERVER ;
        if (!fQMDll)
        {
            //
            // only applications need the option of using different DS
            // server in each thread. The QM does not need this.
            //
            DWORD dwSize = sizeof(DWORD);
            DWORD dwType = REG_DWORD;
            LONG rc = GetFalconKeyValue( MSMQ_THREAD_DS_SERVER_REGNAME,
                                        &dwType,
                                        &m_fPerThread,
                                        &dwSize );
            if (rc != ERROR_SUCCESS)
            {
                m_fPerThread =  MSMQ_DEFAULT_THREAD_DS_SERVER ;
            }

		    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE, L"read from registry PerThreadDSServer flag: %d", m_fPerThread));
                   
            if (m_fPerThread)
            {
                DBGMSG((DBGMOD_DSAPI, DBGLVL_TRACE, TEXT("chndssrv: using per-thread server"))) ;

			    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE, L"App will use per-thread DS server"));
            }
        }
    }

    //
    // Use first server (in registry format, so we compose one)
    //
    ULONG ulTmp;
    BOOL fOK = ComposeRegDsServersBuf(1,
                                 &m_rgServers[0],
                                  pBinding->wszDSServerName,
                                  ARRAY_SIZE(pBinding->wszDSServerName) - 1,
                                 &ulTmp);
    ASSERT(fOK);
	DBG_USED(fOK);

    //
    // Read from registry the MQIS server which was already found by
    // the QM. Only if mqdscli is loaded by mqrt.
    //
    if (!m_fQMDll && !m_fUseSpecificServer)
    {
       TCHAR  wszDSServerName[ DS_SERVER_NAME_MAX_SIZE ] = {0} ;
       DWORD  dwSize = sizeof(WCHAR) * DS_SERVER_NAME_MAX_SIZE ;
       DWORD  dwType = REG_SZ;
       LONG rc = GetFalconKeyValue( MSMQ_DS_CURRENT_SERVER_REGNAME,
                                    &dwType,
                                    wszDSServerName,
                                    &dwSize );
       if ((rc == ERROR_SUCCESS) && (wszDSServerName[0] != L'\0'))
       {
          wcscpy(pBinding->wszDSServerName, wszDSServerName) ;
          m_fUseRegServer = TRUE ;

    	  DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE, L"CChangeDSServer will use %ls (from registry) for RPC binding ", wszDSServerName));
       }
    }
}

void
CChangeDSServer::ReInit( void )
{
    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,  L"CChangeDSServer::ReInit"));
    
    SET_RPCBINDING_PTR(pBinding) ;
    pBinding->fServerFound = FALSE;
    Init(m_fSetupMode, m_fQMDll);
}

HRESULT
CChangeDSServer::GetIPAddress()
{
    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,  L"CChangeDSServer::GetIPAddress"));
    
    //
    // Get IP address of this server and keep it for next time.
    // this save the name resolution overhead when recreatin the
    // roc binding handle.
    //
    SET_RPCBINDING_PTR(pBinding) ;
    pBinding->wzDsIP[0] = TEXT('\0') ;

    if (pBinding->dwProtocol == IP_ADDRESS_TYPE)
    {
        char  szDSServerName[ DS_SERVER_NAME_MAX_SIZE ];
        ConvertToMultiByteString(&pBinding->wszDSServerName[2],
                                 szDSServerName,
                                 sizeof(szDSServerName)) ;

        WSADATA WSAData ;
        int rc = WSAStartup(MAKEWORD(1,1), &WSAData);
        ASSERT(rc == 0) ;
		DBG_USED(rc);

        PHOSTENT phe = gethostbyname(szDSServerName);
		if(phe == NULL)
		{
			//
			// This failure cause because we are not connected to the network
			//
			rc = WSAGetLastError();
            DBGMSG((DBGMOD_DSAPI, DBGLVL_ERROR, TEXT("CChangeDSServer::GetIPAddress failed in gethostbyname(), err = %d"), rc));
			return HRESULT_FROM_WIN32(rc);
		}

        in_addr inaddr ;
        memcpy(&inaddr, phe->h_addr_list[0], IP_ADDRESS_LEN);
        char * pName = inet_ntoa(inaddr) ;
        if (pName)
        {
            ConvertToWideCharString(pName, pBinding->wzDsIP,
                (sizeof(pBinding->wzDsIP) / sizeof(pBinding->wzDsIP[0]))) ;
            
            DBGMSG((DBGMOD_DSAPI, DBGLVL_TRACE, L"Found for DS server %hs address %hs", szDSServerName, pName));
            
        }

        WSACleanup() ;
    }

    return MQ_OK ;
}

//+-------------------------------------
//
//  CChangeDSServer::FindServer()
//
//+-------------------------------------

HRESULT
CChangeDSServer::FindServer( IN BOOL fWithoutSSL)
{
    ASSERT(g_fWorkGroup == FALSE);

    if (!m_fInitialized || m_fSetupMode)
    {
       //
       // This may happen with applications loading MQRT.
       // In setup, re-read each time the servers list, as it is changed
       // by user.
       //
       Init( m_fSetupMode, m_fQMDll ) ;
    }

    //
    // Initialize the per-thread structure. This method is the entry point
    // for each thread when it search for a DS server, so it's a good
    // place to initialize the tls data.
    //
    LPADSCLI_RPCBINDING pCliBind = NULL ;
    if (TLS_IS_EMPTY)
    {
        pCliBind = (LPADSCLI_RPCBINDING) new ADSCLI_RPCBINDING ;
        memset(pCliBind, 0, sizeof(ADSCLI_RPCBINDING)) ;
        BOOL fSet = TlsSetValue( g_hBindIndex, pCliBind ) ;
        ASSERT(fSet) ;
		DBG_USED(fSet);

        if (m_fPerThread)
        {
            CS  Lock(m_cs);

            memcpy( &(pCliBind->sDSServers),
                    &mg_sDSServers,
                    sizeof(mg_sDSServers) ) ;
        }
    }
    SET_RPCBINDING_PTR(pBinding) ;

    BOOL fServerFound = pBinding->fServerFound ;

    CS  Lock(m_cs);

    if (m_cServers == 0)
    {
        //
        // An event was issued indicating that there is no server list in registry
        //
	    DBGMSG((DBGMOD_DSAPI,DBGLVL_WARNING, L"FindServer: failed  because the server list is empty"));
        return MQ_ERROR_NO_DS;
    }

    if (pBinding->fServerFound)
    {
       //
       // A server was already found. Just bind a RPC handle.
       //
       ASSERT(pBinding->dwProtocol != 0) ;
       HRESULT hr = BindRpc();
       if (SUCCEEDED(hr))
       {
          if (SERVER_NOT_VALIDATED)
          {
             hr = ValidateThisServer( fWithoutSSL) ;
          }
          if (SUCCEEDED(hr))
          {
             return hr ;
          }
       }
       //
       // If server not available, or
       // If we didn't succeed to validate the server then try another one.
       //
    }
    else if (fServerFound)
    {
       //
       // While we (our thread) waited on the critical section, another
       // thread tried and failed to find a MQIS server. So we won't
       // waste our time and return immediately.
       //
	   DBGMSG((DBGMOD_DSAPI,DBGLVL_WARNING, L"FindServer: failed because other thread tried/failed concurrently"));
       return MQ_ERROR_NO_DS ;
    }

    DWORD dwCount = 0 ;
    return FindAnotherServer(&dwCount, fWithoutSSL) ;
}

//
// Function -
//      ValidateServer
//
// Parameters -
//      szServerName - The name of the server to be validated.
//
// Description -
//      The function verifies that the common name of the server and it's
//      certificate issuer are what we expect it to be.
//

HRESULT
CChangeDSServer::ValidateServer( IN LPCWSTR wszServerName )
{
    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,  L"CChangeDSServer::ValidateServer %ls", wszServerName));
    
    HRESULT hr;

    //
    // Get the name of the server and the name of it's CA.
    //
    CHAR szShortSubjectName[128];
    AP<CHAR> pszLongSubjectName;
    LPSTR szSubjectName = szShortSubjectName;
    DWORD dwSubjectName = sizeof(szShortSubjectName);

    CHAR szShortIssuerName[128];
    AP<CHAR> pszLongIssuerName;
    LPSTR szIssuerName = szShortIssuerName;
    DWORD dwIssuerName = sizeof(szShortIssuerName);

    hr = MQsspi_GetNames( tls_hSvrAuthClientCtx.pvhContext,
                          szSubjectName,
                          &dwSubjectName,
                          szIssuerName,
                          &dwIssuerName );
    if (FAILED(hr))
    {
        if (hr != MQ_ERROR_USER_BUFFER_TOO_SMALL)
        {
            return(hr);
        }

        //
        // One or both of the boffer are too small. Allocate large enough
        // buffers and try once again.
        //

        if (dwSubjectName > sizeof(szShortSubjectName))
        {
            pszLongSubjectName = new CHAR[dwSubjectName];
            szSubjectName = pszLongSubjectName;
        }

        if (dwIssuerName > sizeof(szShortIssuerName))
        {
            pszLongIssuerName = new CHAR[dwIssuerName];
            szIssuerName = pszLongIssuerName;
        }

        hr = MQsspi_GetNames( tls_hSvrAuthClientCtx.pvhContext,
                              szSubjectName,
                              &dwSubjectName,
                              szIssuerName,
                              &dwIssuerName );
        if (FAILED(hr))
        {
	 	    DBGMSG((DBGMOD_DSAPI,DBGLVL_WARNING,  L"Server %ls failed validation: 0x%x", wszServerName, hr));
            return(hr);
        }
    }

    //
    // BUGBUG - For now the common name of the server must be the name of
    //          the server it self. In the future, I'll have to maintain
    //          a list of all the servers and thier X500 names.
    //
    DWORD dwServerNameLen = wcslen(wszServerName);
    LPCSTR szCN = strstr(szSubjectName, "CN=");

    if (!szCN)
    {
        //
        // There is no common name for the server, can't use it.
        //
        return(MQDS_E_CANT_INIT_SERVER_AUTH);
    }

    szCN += 3;

    //
    // Verify the the server name has the same length in the certificate.
    //
    LPCSTR szComma = strchr(szCN, ',');

    if (!szComma)
    {
        if (strlen(szCN) != dwServerNameLen)
        {
            return(MQDS_E_CANT_INIT_SERVER_AUTH);
        }
    }
    else
    {
        if ((DWORD_PTR)(szComma - szCN) != dwServerNameLen)
        {
            return(MQDS_E_CANT_INIT_SERVER_AUTH);
        }
    }

    //
    // BUGBUG - Should we convert the ANSI string to a UNICODE string,
    //          or vis versa?
    //
    AP<CHAR> szServerName = new CHAR[dwServerNameLen + 1];
    wcstombs(szServerName, wszServerName, dwServerNameLen + 1);

    if (_strnicmp(szCN, szServerName, dwServerNameLen) != 0)
    {
        //
        // The server name in the certificate is not as excpected. We are currently
        // expecting to see the server name in the common came (CN) in the subject
        // field.
        //
        return(MQDS_E_CANT_INIT_SERVER_AUTH);
    }

    //
    // Get the configuration of the CAs. We get an array of structures, each structure
    // hold a flag that says whether or not the CA is enabled.
    //
    static DWORD nCerts;
    static AP<MQ_CA_CONFIG> pCaConfig;

    if (!pCaConfig)
    {
        hr = MQGetCaConfig(&nCerts, &pCaConfig);
        if (FAILED(hr))
        {
            return(hr);
        }
    }

    //
    // See whether the CA of the server is a familiar Ca and whether it is configured
    // as enabled.
    //
    DWORD dwIssuerNameLen = strlen(szIssuerName);
    AP<WCHAR> wszIssuerName = new WCHAR[dwIssuerNameLen + 1];
    mbstowcs(wszIssuerName, szIssuerName, dwIssuerNameLen + 1);

    //
    // the following variables are used for building the server certificate.
    //
    AP<BYTE> pLongCert;
    BYTE abShortCert[512];
    PBYTE pServerCertificateBlob = abShortCert;
    DWORD cbServerCertificate = sizeof(abShortCert);
    R<CMQSigCertificate> pServerCert = NULL ;
    BOOL fCreateServerCert = TRUE ;

    for (DWORD i = 0; i < nCerts; i++)
    {
        if (wcscmp(wszIssuerName, pCaConfig[i].szCaSubjectName) == 0)
        {
            //
            // The CA  is familiar to us, see whether it is enabled.
            //
            if (!pCaConfig[i].fEnabled)
            {
                continue;
            }

            //
            // Get the server's certificate.
            //
            if (fCreateServerCert)
            {
                fCreateServerCert = FALSE ;

                hr = CheckContextCredStatus(
                                        tls_hSvrAuthClientCtx.pvhContext,
                                        pServerCertificateBlob,
                                        &cbServerCertificate);
                if (FAILED(hr))
                {
                    if (hr != MQ_ERROR_USER_BUFFER_TOO_SMALL)
                    {
                        return MQDS_E_CANT_INIT_SERVER_AUTH;
                    }

                    pLongCert = new BYTE[ cbServerCertificate ];
                    pServerCertificateBlob = pLongCert;

                    hr = CheckContextCredStatus(
                                       tls_hSvrAuthClientCtx.pvhContext,
                                       pServerCertificateBlob,
                                       &cbServerCertificate );
                    if (FAILED(hr))
                    {
                        return MQDS_E_CANT_INIT_SERVER_AUTH;
                    }
                }

                hr = MQSigCreateCertificate( &pServerCert.ref(),
                                             NULL,
                                             pServerCertificateBlob,
                                             cbServerCertificate ) ;
                if (FAILED(hr))
                {
                    return hr ;
                }

                MQUInitGlobalScurityVars();
            }

            //
            // get the CA'a certificate from SCHANNEL registry.
            //
            DWORD dwCaCertSize;
            AP<BYTE> pbCaCert;

            hr = MQsspi_GetCaCert( pCaConfig[i].szCaRegName,
                                   pCaConfig[i].pbSha1Hash,
                                   pCaConfig[i].dwSha1HashSize,
                                   &dwCaCertSize,
                                   &pbCaCert );
            if (FAILED(hr))
            {
                ASSERT(0);
                continue;
            }

            //
            // See if indeed the CA has signed the server certificate.
            //
            R<CMQSigCertificate> pCaCert ;

            hr = MQSigCreateCertificate( &pCaCert.ref(),
                                         NULL,
                                         pbCaCert,
                                         dwCaCertSize ) ;
            if (FAILED(hr))
            {
                ASSERT(0);
                continue;
            }

            hr = pServerCert->IsCertificateValid( pCaCert.get() ) ;
            if (FAILED(hr))
            {
                continue ;
            }


            DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE,
                        TEXT("SEC: Server %ls validated OK, by %ls"),
                        wszServerName, wszIssuerName));

            return MQ_OK;
        }
    }

    //
    // The CA is not familiar, do not use the server.
    //
    DBGMSG((DBGMOD_SECURITY, DBGLVL_WARNING,
            TEXT("SEC: Failed to validate Server %ls"), wszServerName)) ;

    return(MQDS_E_CANT_INIT_SERVER_AUTH);
}

HRESULT
CChangeDSServer::TryThisServer( IN BOOL fWithoutSSL)
{
   DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,  L"CChangeDSServer::TryThisServer"));
   
   HRESULT hr = BindRpc();
   if ( FAILED(hr))
   {
       return(hr);
   }

   return ValidateThisServer( fWithoutSSL) ;
}


HRESULT
CChangeDSServer::ValidateThisServer( IN BOOL fWithoutSSL)
{
   SET_RPCBINDING_PTR(pBinding) ;

   if (pBinding->ulAuthnSvc == RPC_C_AUTHN_GSS_KERBEROS)
   {
        //
        // Kerberos has built-in mutual authentication. No need to do
        // sspi/schannel certificate based server authentication.
        //
        // However !!!
        // Becasue MSMQ1.0 implement server authentication as context handle
        // in RPC calls, we must build the context. So at present (Sep-98)
        // go on with msmq1.0 code. Later, if time permit, we'll replace
        // all interfaces with new ones that do not use context.
        //
       if (fWithoutSSL)
       {
           //
           //   NT5 to NT5 interface, using kerberos
           //
           return MQ_OK;
       }
   }

   HRESULT hr ;

   while (TRUE)
   {
       //
       // first two characters in server name string are the protocol flags.
       //
       WCHAR *pwszServerName = pBinding->wszDSServerName + 2 ;
       BOOL fTryServerAuth = IsSspiServerAuthNeeded( pBinding,
                                                     m_fSetupMode ) ;

       hr = ValidateSecureServer( pwszServerName,
                                 &m_guidEnterpriseId,
                                  m_fSetupMode,
                                  fTryServerAuth );
       if (SUCCEEDED(hr) && fTryServerAuth)
       {
           //
           // So the server seem to exist and suppoort our security
           // requirements. See if the server is familiar to us. That is,
           // whether the server's common name and certificate issuer is
           // what we expect it to be.
           //
           hr = ValidateServer(pBinding->wszDSServerName + 2);
           if (FAILED(hr))
           {
               hr = MQDS_E_CANT_INIT_SERVER_AUTH;
           }
       }

       if ((hr != MQDS_E_CANT_INIT_SERVER_AUTH) ||
           !fTryServerAuth                      ||
           (g_pfnNoServerAuth == NULL))
       {
            break;
       }

       ASSERT(m_fSetupMode) ;

       if (!g_pfnNoServerAuth())
       {
           break;
       }
   }

   if (FAILED(hr))
   {
       g_CFreeRPCHandles.FreeCurrentThreadBinding();
   }

   return hr ;
}


HRESULT
CChangeDSServer::FindAnotherServerFromRegistry(
                       IN OUT   DWORD * pdwCount,
                       IN       BOOL    fWithoutSSL)
{
    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,  L"CChangeDSServer::FindAnotherServerFromRegistry"));
    
    SET_RPCBINDING_PTR(pBinding) ;

    if (*pdwCount >= m_cServers)
    {
       return MQ_ERROR ;
    }

    BOOL fServerFound = pBinding->fServerFound ;

    CS  Lock(m_cs);

    if (fServerFound && !pBinding->fServerFound)
    {
       //
       // While we (our thread) waited on the critical section, another
       // thread tried and failed to find a MQIS server. So we won't
       // waste our time and return immediately.
       //
       return MQ_ERROR_NO_DS ;
    }

    pBinding->fServerFound = FALSE ;
    BOOL  fTryAllProtocols = FALSE ;
    BOOL  fInLoop = TRUE ;
    HRESULT hr = MQ_OK ;

    do
    {
       SetAuthnLevel() ;

       if (*pdwCount >= m_cServers)
       {
          //
          // We tried all servers.
          //
          if (!fTryAllProtocols)
          {
             //
             // Now try again all servers, but used protocols which are
             // not "recomended" by the flags in registry.
             //
             DBGMSG((DBGMOD_DSAPI, DBGLVL_WARNING,
                 TEXT("MQDSCLI, FindAnotherServerFromRegistry(): Try all protocols"))) ;
             fTryAllProtocols = TRUE ;
             *pdwCount = 0 ;
          }
          else
          {
             //
             // we already tried all servers in the list. (with all protocols).
             // (the '>=' operation takes into account the case where
             // servers list was changed by another thread).
             //
             hr = RpcClose();
             ASSERT(hr == MQ_OK) ;

             pBinding->fServerFound = FALSE ;
			 DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,  L"we already tried all servers, failing"));
			 
             hr = MQ_ERROR_NO_DS ;
             break ;
          }
       }

       if (m_fUseRegServer)
       {
          ASSERT(!m_fQMDll) ;
          m_fUseRegServer = FALSE ;
       }
       else
       {
          //
          // Use requested server (in registry format, so we compose one)
          //
          ULONG ulTmp;
          BOOL fOK = ComposeRegDsServersBuf(1,
                                &m_rgServers[*pdwCount],
                                 pBinding->wszDSServerName,
                                 ARRAY_SIZE(pBinding->wszDSServerName) - 1,
                                &ulTmp);
          ASSERT(fOK);
		  DBG_USED(fOK);

          (*pdwCount)++ ;
       }
       ASSERT(pBinding->wszDSServerName[0] != L'\0') ;

       //
       // Check what protocol are used by the server.
       //
       TCHAR *pServer = pBinding->wszDSServerName;
       BOOL  fServerUseIP = (BOOL) (*pServer - TEXT('0')) ;
       pServer++ ;
       pServer++;

       if (fTryAllProtocols)
       {
          fServerUseIP  = !fServerUseIP ;
       }

       BOOL fTryThisServer = FALSE;

       if (fServerUseIP)
       {
           pBinding->dwProtocol = IP_ADDRESS_TYPE ;
           fTryThisServer = TRUE;
       }

       pBinding->wzDsIP[0] = TEXT('\0') ;
       if (_wcsicmp(pServer, g_szMachineName))
       {
			//
			//   Incase of non-local DS server, use the IP address of the server
			//   instead of name
			//
			hr = GetIPAddress();
			if(FAILED(hr))
			{
				//
				// GetIPAddress failure indicate we are not connected to the network.
				//
				DBGMSG((DBGMOD_DSAPI, DBGLVL_WARNING, TEXT("MQDSCLI, GetIPAddress() failed")));
				return hr;
			}

       }

       while (fTryThisServer)
       {
           hr = TryThisServer(fWithoutSSL) ;
           if (hr != MQ_ERROR_NO_DS)
           {
               //
               // Any error other than "MQ_ERROR_NO_DS" is a 'real' error and
               // we quit. MQ_ERROR_NO_DS tells us to try another server or
               // try present one with other parameters. In case we got
               // MQDS_E_WRONG_ENTERPRISE or MQDS_E_CANT_INIT_SERVER_AUTH,
               // we continue to try the other servers and modify the error
               // code to MQ_ERROR_NO_DS
               //
               fInLoop = (hr == MQDS_E_WRONG_ENTERPRISE) ||
                         (hr == MQDS_E_CANT_INIT_SERVER_AUTH);
               if (SUCCEEDED(hr))
               {
                   pBinding->fServerFound = TRUE ;
                   if (m_fQMDll)
                   {
                      //
                      // Write new server name in registry.
                      //
                      DWORD dwSize = sizeof(WCHAR) *
                                   (1 + wcslen(pBinding->wszDSServerName)) ;
                      DWORD dwType = REG_SZ;
                      LONG rc = SetFalconKeyValue(
                                    MSMQ_DS_CURRENT_SERVER_REGNAME,
                                    &dwType,
                                    pBinding->wszDSServerName,
                                    &dwSize );
			 		  DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,  
			 		                L"keeping %ls in registry for CurrentMQISServer - after we tried it sucessfully",
			 		                pBinding->wszDSServerName));
			 		  
                      ASSERT(rc == ERROR_SUCCESS);
					  DBG_USED(rc);
                   }
               }
               else
               {
		 		  DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,  
		 		                L"failed in trying server, hr=0x%x", hr));
                   if (fInLoop)
                   {
                       hr = MQ_ERROR_NO_DS;
                   }
               }
               break ;
           }

           //
           // Now try this server with other parameters.
           //
           if(pBinding->eAuthnLevel == MQRPC_SEC_LEVEL_NONE)
           {
               //
               // Entering here, means (posible scenarios)
               //   A) Binding failed, no server available on the other side,
               //   B) Binding failed, this The server does not support this protocol
               //   C) Last call used no security, and now server went down.
               //

               SetAuthnLevel() ;

               fTryThisServer = FALSE ;
               
               //
               // Restore first protocol to be tried for this server.
               //
               pBinding->dwProtocol = IP_ADDRESS_TYPE;
           }
           else if(pBinding->eAuthnLevel == MQRPC_SEC_LEVEL_MIN)
           {
               //
               // Last, try no security.
               //
               pBinding->eAuthnLevel =  MQRPC_SEC_LEVEL_NONE;
           }
           else if(pBinding->ulAuthnSvc == RPC_C_AUTHN_WINNT)
           {
               //
               // Try reduced security.
               //
               pBinding->eAuthnLevel =  MQRPC_SEC_LEVEL_MIN;
           }
           else
           {
               //
               // Try antoher authentication srvice
               //
               ASSERT(pBinding->ulAuthnSvc == RPC_C_AUTHN_GSS_KERBEROS);
               pBinding->ulAuthnSvc = RPC_C_AUTHN_WINNT;
           }
       }
    }
    while (fInLoop) ;

    if ((hr == MQ_ERROR_NO_DS) && !m_fUseSpecificServer)
    {
       //
       // Refresh the MQIS servers list.
       //
       Init( m_fSetupMode, m_fQMDll );

       if (g_pfnLookDS)
       {
          //
          // Tell the QM to start again looking for an online DS server.
          //
          (*g_pfnLookDS)(0, 1) ;
       }
    }

    return hr ;
}


HRESULT
CChangeDSServer::FindAnotherServer(
                IN OUT  DWORD *pdwCount,
                IN      BOOL fWithoutSSL)
{
    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,  L"CChangeDSServer::FindAnotherServer"));
    
    //
    // try to find another server from current registry
    //
    HRESULT hr = FindAnotherServerFromRegistry(pdwCount, fWithoutSSL);
    return hr;
}


HRESULT
CChangeDSServer::BindRpc()
{
    SET_RPCBINDING_PTR(pBinding) ;

    //
    //  Bind new server. First call RpcClose() without checking ite return
    //  code because this function may be called multiple times from
    //  MQQM initialization.
    //
    TCHAR  *pServer = pBinding->wszDSServerName;
    pServer += 2 ; // skip the ip/ipx flags.

    if ((pBinding->dwProtocol == IP_ADDRESS_TYPE) &&
        (pBinding->wzDsIP[0] != TEXT('\0')))
    {
       pServer = pBinding->wzDsIP ;
    }
    else
    {
        ASSERT(("Must be IP only environment. shaik", 0));
    }

    BOOL fProtocolNotSupported ;

    HRESULT hr = RpcClose();
    ASSERT(hr == MQ_OK) ;

    hr = RpcInit( pServer,
                  &(pBinding->eAuthnLevel),
                  pBinding->ulAuthnSvc,
                  &fProtocolNotSupported,
                  &pBinding->fLocalRpc) ;

    return (hr) ;
}


//+-------------------------------------------------------
//
//  HRESULT CChangeDSServer::CopyServersList()
//
//+-------------------------------------------------------

HRESULT CChangeDSServer::CopyServersList( WCHAR *wszFrom, WCHAR *wszTo )
{
    //
    // Read present list.
    //
    TCHAR wzDsTmp[ MAX_REG_DSSERVER_LEN ];
    READ_REG_DS_SERVER_STRING( wzDsTmp,
                               MAX_REG_DSSERVER_LEN,
                               wszFrom,
                               MSMQ_DEFAULT_DS_SERVER ) ;
    DWORD dwSize = _tcslen(wzDsTmp) ;
    if (dwSize <= 2)
    {
        //
        // "From" list is empty. Ignore.
        //
        return MQ_OK ;
    }

    //
    // Save it back in registry.
    //
    dwSize = (dwSize + 1) * sizeof(TCHAR) ;
    DWORD dwType = REG_SZ;
    LONG rc = SetFalconKeyValue( wszTo,
                                &dwType,
                                 wzDsTmp,
                                &dwSize ) ;
    if (rc != ERROR_SUCCESS)
    {
        //
        // we were not able to update the registry, put a debug error
        //
        DBGMSG((DBGMOD_DSAPI, DBGLVL_ERROR, TEXT(
          "chndssrv::SaveLastKnownGood: SetFalconKeyValue(%ls,%ls)=%lx"),
                                           wszTo, wzDsTmp, rc)) ;

        return HRESULT_FROM_WIN32(rc) ;
    }
    
    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,  
          L"CopyServersList: Saved %ls in registry: %ls", wszTo, wzDsTmp));

    return MQ_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscli\chndssrv.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    chndssrv.h

Abstract:
    Change DS server class
    when exception happen

Author:
    Ronit Hartmann (ronith)

--*/

#ifndef __CHNDSSRV_H
#define __CHNDSSRV_H

#include "cs.h"
#include "_registr.h"
#include "_mqrpc.h"
#include "dsreg.h"
#include "rpcdscli.h"

#define DS_SERVER_NAME_MAX_SIZE 256

#define READ_REG_DS_SERVER_STRING(string, len, ValueName, default)            \
   {																\
		DWORD  dwSize = len * sizeof(TCHAR);						\
		DWORD  dwType = REG_SZ;										\
																	\
		ASSERT(wcslen(default) < MAX_REG_DEFAULT_LEN);				\
																	\
		LONG res = GetFalconKeyValue( ValueName,					\
								   &dwType,							\
								   string,							\
								   &dwSize,							\
								   default );						\
		ASSERT(res == ERROR_SUCCESS);								\
		DBG_USED(res);												\
		ASSERT(dwType == REG_SZ);									\
   }

//-----------------------------
//
//  Change DS server
//
//-----------------------------

class CChangeDSServer
{
public:
    CChangeDSServer();
    ~CChangeDSServer();

    void    Init( IN BOOL fSetupMode,
                  IN BOOL fQMDll,
                  IN LPCWSTR szServerName =NULL ) ;

    void    ReInit( void );

    HRESULT FindServer(
                IN      BOOL fWithoutSSL);
    HRESULT FindAnotherServer(
                IN OUT  DWORD *pdwCount,
                IN      BOOL fWithoutSSL);

private:
    void    SetAuthnLevel() ;
    HRESULT TryThisServer(
                IN      BOOL fWithoutSSL);
    HRESULT ValidateThisServer(  IN BOOL fWithoutSSL) ;
    HRESULT FindAnotherServerFromRegistry(
            IN OUT  DWORD   *pdwCount,
            IN      BOOL    fWithoutSSL);
    HRESULT ValidateServer( IN LPCWSTR wszServerName ) ;
    HRESULT BindRpc();
    HRESULT GetIPAddress() ;
    BOOL AdsSearchChangeRegistryServers();

    HRESULT CopyServersList( WCHAR *wszFrom, WCHAR *wszTo ) ;

    CCriticalSection    m_cs;

    //
    // These are the parameters for present rpc binding.
    // We use this structure even if same DS server is used for all threads
    // to make code simpler.
    //
    ADSCLI_DSSERVERS    mg_sDSServers ;

    //
    // number of servers in list (read from registry, value- MQISServer).
    //
    DWORD            m_cServers ;

    //
    // list of servers read from registry (MQISServer).
    //
    AP<MqRegDsServer> m_rgServers;

    BOOL             m_fSetupMode ;
    GUID             m_guidEnterpriseId; // for server validation

    BOOL             m_fInitialized ;
    BOOL             m_fEmptyEventIssued ;

    //
    // TRUE if MSMQ client machine (machine without QM).
    //
    BOOL    m_fClient ;

    //
    // TRUE if this dll is loaded by mqqm.dll when it run as workstation.
    //
    BOOL    m_fQMDll ;

    //
    // TRUE after this object is initialized for the first time.
    //
    BOOL    m_fFirstTimeInit ;

    //
    // When TRUE, use the server name read from "CurrentMQISServer" registry
    // and don't search a server from the "MQISServer" list. This always
    // happen on a Falcon apps (one linked with mqrt.dll) when it connects
    // to a MQIS server for the first time.
    //
    BOOL    m_fUseRegServer ;

    //
    // This flag is set to true when we want to use some specific server
    // without attempting to switch between servers. This flag is set when
    // we access a parent DS server from some child DS server via RPC
    // (BSC->PSC, PSC->PEC).
    //
    BOOL    m_fUseSpecificServer;

    //
    // Time (seconds) that has to pass since the last ADS search
    // in order to attempt a subsequesnt ADS search. It is here becasue
    // ADS search is not a trivial action, and ADS is not supposed to
    // be updated often anyway. It is initialized using a registry key.
    //
    DWORD m_dwMinTimeToAllowNextAdsSearch;

    //
    // TRUE if servers list is per thread. this is necessary for nt4 clients
    // to correctly run in a nt5 servers environment. Each thread may need
    // to query a different nt5 ds server.
    //
    BOOL    m_fPerThread ;
};

inline   CChangeDSServer::CChangeDSServer()
{
    mg_sDSServers.dwProtocol   = 0 ;
    mg_sDSServers.eAuthnLevel  = MQRPC_SEC_LEVEL_MAX ;
    mg_sDSServers.ulAuthnSvc   = RPC_C_AUTHN_GSS_KERBEROS;
    mg_sDSServers.fServerFound = FALSE ;
    mg_sDSServers.fLocalRpc = FALSE;
    mg_sDSServers.wszDSServerName[0] = L'\0' ;

    m_fSetupMode   = FALSE ;
    m_fInitialized = FALSE ;
    m_fClient = FALSE ;
    m_fEmptyEventIssued = FALSE ;

    m_fQMDll = FALSE ;
    m_fFirstTimeInit = FALSE ;
    m_fUseRegServer = FALSE ;
    m_fUseSpecificServer = FALSE;
    m_fPerThread = FALSE ;

    //
    // wait at least this time before searching ADS again
    //
    m_dwMinTimeToAllowNextAdsSearch = MSMQ_DEFAULT_DSCLI_ADSSEARCH_INTERVAL;
}

inline  CChangeDSServer::~CChangeDSServer()
{
}

extern CChangeDSServer   g_ChangeDsServer;

#endif  //  __CHNDSSRV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscli\dsapi.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dsapi.cpp

Abstract:

   Client side of DS APIs calls the DS server over RPC

Author:

    Ronit Hartmann (ronith)

--*/

#include "stdh.h"
#include "dsproto.h"
#include "ds.h"
#include "chndssrv.h"
#include <malloc.h>
#include "rpcdscli.h"
#include "freebind.h"
#include "rpcancel.h"
#include "dsclisec.h"
#include <_secutil.h>

#include "dsapi.tmh"

QMLookForOnlineDS_ROUTINE g_pfnLookDS = NULL ;
MQGetMQISServer_ROUTINE   g_pfnGetServers = NULL ;
NoServerAuth_ROUTINE      g_pfnNoServerAuth = NULL ;

//
// This flag indicates if the machine work as "WorkGroup" or not.
// If the machine is "WorkGroup" machine don't try to access the DS.
//
extern BOOL g_fWorkGroup;

//
// PTR/DWORD map of the dwContext of DSQMSetMachineProperties (for the callback sign proc)
//
CContextMap g_map_DSCLI_DSQMSetMachineProperties;
//
// PTR/DWORD map of the dwContext of DSQMGetObjectSecurity (the actual callback routine)
// BUGBUG - we could do without mapping here , since the callback that is used is always
// QMSignGetSecurityChallenge, but that would require the QM to supply it in
// DSInit (or otherwise keep it in a global var), and it is out of the scope here.
// We will do it in the next checkin.
//
CContextMap g_map_DSCLI_DSQMGetObjectSecurity;
//
// we don't have an infrastructure yet to log DS client errors
//
#ifdef _WIN64
	void LogIllegalPointValue(DWORD64 dw64, LPCWSTR wszFileName, USHORT usPoint)
	{
	}
#else
	void LogIllegalPointValue(DWORD dw, LPCWSTR wszFileName, USHORT usPoint) 
	{
	}
#endif //_WIN64

/*====================================================

DSInit

Arguments:

 BOOL fQMDll - TRUE if this dll is loaded by MQQM.DLL, while running as
               workstation QM. FALSE otherwise.
Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSInit( QMLookForOnlineDS_ROUTINE pfnLookDS /* =NULL */,
        MQGetMQISServer_ROUTINE   pfnGetServers /* =NULL */,
        BOOL  fReserved /* =FALSE */,
        BOOL  fSetupMode /* =FALSE */,
        BOOL  fQMDll /* =FALSE */,
        NoServerAuth_ROUTINE pfnNoServerAuth /* =NULL */,
        LPCWSTR szServerName /* =NULL */)
{
    HRESULT hr = MQ_OK;

    if (g_fWorkGroup)
        return MQ_OK;

    g_pfnNoServerAuth = pfnNoServerAuth;
    if (g_pfnNoServerAuth != NULL)
    {
        //
        // Do not remove this setting!!!
        // This is where it all starts. Setup calls DSInit with a callback
        // function to get notifications about failure in setting secured
        // server communications.
        // On MSMQ1.0, we turned on secured server communications here.
        // if the server does not support secured communications, the server
        // validation routine turned off secured communications, if the
        // callback function return TRUE.
        // On MSMQ2.0, that use Kerberos by default, only setup code
        // write the "SecuredComm" bit in Registry.
        //
        g_CFreeRPCHandles.FreeCurrentThreadBinding();
    }

    if (!g_pfnGetServers && pfnGetServers)
    {
       ASSERT(!pfnLookDS) ;
       g_pfnGetServers =  pfnGetServers ;
       return hr ;
    }

    if (!g_pfnLookDS)
    {
       g_pfnLookDS = pfnLookDS ;
    }

    //
    // Initialize the Change-DS-server object.
    //
    g_ChangeDsServer.Init( fSetupMode, fQMDll, szServerName );


    return(hr);
}


/*====================================================

DSCreateObjectInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSCreateObjectInternal( IN  DWORD                   dwObjectType,
                        IN  LPCWSTR                 pwcsPathName,
                        IN  DWORD                   dwSecurityLength,
                        IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                        IN  DWORD                   cp,
                        IN  PROPID                  aProp[],
                        IN  PROPVARIANT             apVar[],
                        OUT GUID*                   pObjGuid)
{
    RPC_STATUS rpc_stat;
    HRESULT hr;
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    ASSERT(g_fWorkGroup == FALSE);

    RpcTryExcept
    {
        RegisterCallForCancel( &hThread);
        ASSERT(tls_hBindRpc) ;
        hr = S_DSCreateObject( tls_hBindRpc,
                               dwObjectType,
                               pwcsPathName,
                               dwSecurityLength,
                               (unsigned char *)pSecurityDescriptor,
                               cp,
                               aProp,
                               apVar,
                               pObjGuid);
    }
    RpcExcept(1)
    {
        HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
    }
    RpcEndExcept

    UnregisterCallForCancel( hThread);
    return hr ;
}


/*====================================================

DSCreateObject

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSCreateObject( IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[],
                OUT GUID*                   pObjGuid)
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    HRESULT hr = MQ_OK;
    HRESULT hr1 = MQ_OK;
    DWORD   dwCount = 0 ;
    DWORD dwSecurityLength = (pSecurityDescriptor) ? GetSecurityDescriptorLength(pSecurityDescriptor) : 0;

    DBGMSG((DBGMOD_DSAPI, DBGLVL_TRACE,
        TEXT(" Calling S_DSCreateObject : object type %d"), dwObjectType)) ;


    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr =  DSCreateObjectInternal(dwObjectType,
                                     pwcsPathName,
                                     dwSecurityLength,
                                     (unsigned char *)pSecurityDescriptor,
                                     cp,
                                     aProp,
                                     apVar,
                                     pObjGuid);

        if ( hr == MQ_ERROR_NO_DS)
        {
           hr1 =  g_ChangeDsServer.FindAnotherServer(
                                    &dwCount,
                                    FALSE   // fWithoutSSL
                                    );
        }
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}



/*====================================================

DSDeleteObjectInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSDeleteObjectInternal( IN  DWORD                   dwObjectType,
                        IN  LPCWSTR                 pwcsPathName)
{
    HRESULT hr;
    RPC_STATUS rpc_stat;
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    ASSERT(g_fWorkGroup == FALSE);

    RpcTryExcept
    {
        RegisterCallForCancel( &hThread);
        ASSERT(tls_hBindRpc) ;
        hr = S_DSDeleteObject( tls_hBindRpc,
                               dwObjectType,
                               pwcsPathName);
    }
    RpcExcept(1)
    {
        HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
    }
    RpcEndExcept

    UnregisterCallForCancel( hThread);
    return hr ;
}

/*====================================================

DSDeleteObject

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSDeleteObject( IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName)
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    HRESULT hr = MQ_OK;
    HRESULT hr1 = MQ_OK;
    DWORD   dwCount = 0 ;

    DBGMSG((DBGMOD_DSAPI, DBGLVL_TRACE,
      TEXT(" Calling S_DSDeleteObject : object type %d"), dwObjectType) ) ;

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSDeleteObjectInternal( dwObjectType,
                                        pwcsPathName);
        if ( hr == MQ_ERROR_NO_DS)
        {
            hr1 =  g_ChangeDsServer.FindAnotherServer(
                                    &dwCount,
                                    FALSE       //fWithoutSSL
                                    );
        }
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}

/*====================================================

DSGetObjectPropertiesInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSGetObjectPropertiesInternal( IN  DWORD                    dwObjectType,
                               IN  LPCWSTR                  pwcsPathName,
                               IN  DWORD                    cp,
                               IN  PROPID                   aProp[],
                               IN  PROPVARIANT              apVar[])
{
    HRESULT hr = MQ_OK;
    RPC_STATUS rpc_stat;
    DWORD dwServerSignatureSize;
    LPBYTE pbServerSignature = AllocateSignatureBuffer(&dwServerSignatureSize);
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    ASSERT(g_fWorkGroup == FALSE);

    __try
    {
        RpcTryExcept
        {
           RegisterCallForCancel( &hThread);
           ASSERT(tls_hBindRpc) ;
            hr = S_DSGetProps( tls_hBindRpc,
                               dwObjectType,
                               pwcsPathName,
                               cp,
                               aProp,
                               apVar,
                               tls_hSrvrAuthnContext,
                               pbServerSignature,
                               &dwServerSignatureSize);
        }
        RpcExcept(1)
        {
            HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
        }
        RpcEndExcept

        UnregisterCallForCancel( hThread);
        if (SUCCEEDED(hr) && tls_hSvrAuthClientCtx.pvhContext)
        {
            hr = ValidateProperties(cp,
                                    aProp,
                                    apVar,
                                    pbServerSignature,
                                    dwServerSignatureSize);
        }
    }
    __finally
    {
        delete[] pbServerSignature;
    }
    return hr ;
}

/*====================================================

DSGetObjectProperties

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectProperties( IN  DWORD                    dwObjectType,
                       IN  LPCWSTR                  pwcsPathName,
                       IN  DWORD                    cp,
                       IN  PROPID                   aProp[],
                       IN  PROPVARIANT              apVar[])
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    DSCLI_API_PROLOG ;

    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,
          TEXT (" DSGetObjectProperties: object type %d"), dwObjectType) );

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    //
    //  Clear all the pointers of VT_NULL variants
    //
    for ( DWORD i = 0 ; i < cp ; i++ )
    {
        if (apVar[i].vt == VT_NULL)
        {
            memset( &apVar[i].caub, 0, sizeof(CAUB));
        }
    }

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSGetObjectPropertiesInternal(
                           dwObjectType,
                           pwcsPathName,
                           cp,
                           aProp,
                           apVar);

        DSCLI_HANDLE_DS_ERROR(hr, hr1, dwCount, fReBind ) ;
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}

/*====================================================

DSSetObjectPropertiesInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSSetObjectPropertiesInternal( IN  DWORD            dwObjectType,
                               IN  LPCWSTR          pwcsPathName,
                               IN  DWORD            cp,
                               IN  PROPID           aProp[],
                               IN  PROPVARIANT      apVar[])
{
    ASSERT(g_fWorkGroup == FALSE);

    HRESULT hr = MQ_OK;
    RPC_STATUS rpc_stat;
    HANDLE  hThread = INVALID_HANDLE_VALUE;


    RpcTryExcept
    {
        RegisterCallForCancel( &hThread);
        ASSERT(tls_hBindRpc) ;
        hr = S_DSSetProps( tls_hBindRpc,
                           dwObjectType,
                           pwcsPathName,
                           cp,
                           aProp,
                           apVar);
    }
    RpcExcept(1)
    {
        HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
    }
    RpcEndExcept
    UnregisterCallForCancel( hThread);

    return hr ;
}

/*====================================================

DSSetObjectProperties

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectProperties( IN  DWORD                dwObjectType,
                       IN  LPCWSTR              pwcsPathName,
                       IN  DWORD                cp,
                       IN  PROPID               aProp[],
                       IN  PROPVARIANT          apVar[])
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    HRESULT hr = MQ_OK;
    HRESULT hr1 = MQ_OK;
    DWORD   dwCount = 0 ;

    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,
      TEXT(" Calling S_DSSetObjectProperties for object type %d"), dwObjectType) );

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSSetObjectPropertiesInternal(
                           dwObjectType,
                           pwcsPathName,
                           cp,
                           aProp,
                           apVar);

        if ( hr == MQ_ERROR_NO_DS)
        {
            hr1 =  g_ChangeDsServer.FindAnotherServer( &dwCount,
                                                       FALSE);  //fWithoutSSL
        }
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}

/*====================================================

DSLookupBeginInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSLookupBeginInternal(
                IN  LPTSTR                  pwcsContext,
                IN  MQRESTRICTION*          pRestriction,
                IN  MQCOLUMNSET*            pColumns,
                IN  MQSORTSET*              pSort,
                OUT PHANDLE                 phEnume)
{
    HRESULT hr;
    RPC_STATUS rpc_stat;
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    ASSERT(g_fWorkGroup == FALSE);

    RpcTryExcept
    {
        RegisterCallForCancel( &hThread);
        ASSERT(tls_hBindRpc) ;
        hr = S_DSLookupBegin( tls_hBindRpc,
                              phEnume,
                              pwcsContext,
                              pRestriction,
                              pColumns,
                              pSort,
                              tls_hSrvrAuthnContext ) ;
    }
    RpcExcept(1)
    {
        HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
    }
    RpcEndExcept
    UnregisterCallForCancel( hThread);
    return hr ;
}

/*====================================================

DSLookupBegin

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSLookupBegin(
                IN  LPWSTR                  pwcsContext,
                IN  MQRESTRICTION*          pRestriction,
                IN  MQCOLUMNSET*            pColumns,
                IN  MQSORTSET*              pSort,
                OUT PHANDLE                 phEnume)
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    DSCLI_API_PROLOG ;

    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,TEXT (" Calling S_DSLookupBegin ")) );

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSLookupBeginInternal( pwcsContext,
                                    pRestriction,
                                    pColumns,
                                    pSort,
                                    phEnume);

        DSCLI_HANDLE_DS_ERROR(hr, hr1, dwCount, fReBind) ;
    }

    return hr ;
}

/*====================================================

DSLookupNaxt

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSLookupNext(
                IN      HANDLE          hEnum,
                IN OUT  DWORD*          pcProps,
                OUT     PROPVARIANT     aPropVar[])
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    HRESULT hr = MQ_OK;
    RPC_STATUS rpc_stat;
    DWORD dwOutSize = 0;

    //
    //  No use to try to connect another server in case of connectivity
    //  failure ( should contine with the one that handled LookupBein and LookupEnd/
    //

    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,TEXT (" Calling S_MQDSLookupNext : handle %p"), hEnum) );

    // clearing the buffer memory
    memset(aPropVar, 0, (*pcProps) * sizeof(PROPVARIANT));

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    DWORD dwServerSignatureSize;
    LPBYTE pbServerSignature = AllocateSignatureBuffer(&dwServerSignatureSize);
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    __try
    {
        RpcTryExcept
        {
            RegisterCallForCancel( &hThread);
            ASSERT(tls_hBindRpc) ;
            hr = S_DSLookupNext( tls_hBindRpc,
                                 hEnum,
                                 pcProps,
                                 &dwOutSize,
                                 aPropVar,
                                 tls_hSrvrAuthnContext,
                                 pbServerSignature,
                                 &dwServerSignatureSize);
        }
        RpcExcept(1)
        {
            HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
        }
        RpcEndExcept
        UnregisterCallForCancel( hThread);

        if (SUCCEEDED(hr) && tls_hSvrAuthClientCtx.pvhContext)
        {
            hr = ValidateProperties(dwOutSize,
                                    NULL,
                                    aPropVar,
                                    pbServerSignature,
                                    dwServerSignatureSize);
        }
    }
    __finally
    {
        delete[] pbServerSignature;
    }

    *pcProps = dwOutSize ;
    return hr ;
}


/*====================================================

DSLookupEnd

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSLookupEnd( IN  HANDLE      hEnum)
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    HRESULT hr;
    RPC_STATUS rpc_stat;

    //
    //  No use to try to connect another server in case of connectivity
    //  failure ( should contine with the one that handled LookupBein and LookupEnd/
    //
    DBGMSG((DBGMOD_DSAPI, DBGLVL_TRACE,
                  TEXT (" Calling S_DSLookupEnd : handle %p"), hEnum) ) ;

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    RpcTryExcept
    {
        RegisterCallForCancel( &hThread);
        ASSERT(tls_hBindRpc) ;
        hr = S_DSLookupEnd( tls_hBindRpc,
                            &hEnum );
    }
    RpcExcept(1)
    {
        HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
    }
    RpcEndExcept
    UnregisterCallForCancel( hThread);

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}


/*====================================================

DSDeleteObjectGuidInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
APIENTRY
DSDeleteObjectGuidInternal(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid)
{

    HRESULT hr;
    RPC_STATUS rpc_stat;
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    ASSERT(g_fWorkGroup == FALSE);

    RpcTryExcept
    {
        RegisterCallForCancel( &hThread);
        ASSERT(tls_hBindRpc) ;
        hr = S_DSDeleteObjectGuid( tls_hBindRpc,
                                   dwObjectType,
                                   pObjectGuid);
    }
    RpcExcept(1)
    {
        HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
    }
    RpcEndExcept
    UnregisterCallForCancel( hThread);

    return hr ;

}
/*====================================================

DSDeleteObjectGuid

Arguments:

Return Value:


=====================================================*/
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSDeleteObjectGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid)
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;


    HRESULT hr = MQ_OK;
    HRESULT hr1 = MQ_OK;
    DWORD   dwCount = 0 ;

    DBGMSG((DBGMOD_DSAPI, DBGLVL_TRACE,
     TEXT(" Calling S_DSDeleteObjectGuid : object type %d"), dwObjectType) );

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSDeleteObjectGuidInternal( dwObjectType,
                                         pObjectGuid);

        if (hr == MQ_ERROR_NO_DS)
        {
            hr1 =  g_ChangeDsServer.FindAnotherServer( &dwCount,
                                                       FALSE); //fWithoutSSL
        }
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;

}

/*====================================================

DSGetObjectPropertiesGuidInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSGetObjectPropertiesGuidInternal(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[])
{
    HRESULT hr = MQ_OK;
    RPC_STATUS rpc_stat;
    DWORD dwServerSignatureSize;
    LPBYTE pbServerSignature = AllocateSignatureBuffer(&dwServerSignatureSize);
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    ASSERT(g_fWorkGroup == FALSE);

    __try
    {
        RpcTryExcept
        {
            RegisterCallForCancel( &hThread);
            ASSERT(tls_hBindRpc) ;
            hr = S_DSGetPropsGuid(  tls_hBindRpc,
                                    dwObjectType,
                                    pObjectGuid,
                                    cp,
                                    aProp,
                                    apVar,
                                    tls_hSrvrAuthnContext,
                                    pbServerSignature,
                                    &dwServerSignatureSize);
        }
        RpcExcept(1)
        {
            HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
        }
        RpcEndExcept
        UnregisterCallForCancel( hThread);

        if (SUCCEEDED(hr) && tls_hSvrAuthClientCtx.pvhContext)
        {
            hr = ValidateProperties(cp,
                                    aProp,
                                    apVar,
                                    pbServerSignature,
                                    dwServerSignatureSize);
        }
    }
    __finally
    {
        delete[] pbServerSignature;
    }

    return hr ;
}

/*====================================================

DSGetObjectPropertiesGuid

Arguments:

Return Value:

=====================================================*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectPropertiesGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[])
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    DSCLI_API_PROLOG ;

    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,
       TEXT(" DSGetObjectPropertiesGuid: object type %d"), dwObjectType) ) ;

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    //
    //  Clear all the pointers of VT_NULL variants
    //
    for ( DWORD i = 0; i < cp; i++)
    {
        if (apVar[i].vt == VT_NULL)
        {
            memset( &apVar[i].caub, 0, sizeof(CAUB));
        }
    }

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSGetObjectPropertiesGuidInternal(  dwObjectType,
                                                 pObjectGuid,
                                                 cp,
                                                 aProp,
                                                 apVar);

        DSCLI_HANDLE_DS_ERROR(hr, hr1, dwCount, fReBind) ;
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}

/*====================================================

DSSetObjectPropertiesGuidInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSSetObjectPropertiesGuidInternal(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[])

{
    HRESULT hr;
    RPC_STATUS rpc_stat;
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    ASSERT(g_fWorkGroup == FALSE);

    RpcTryExcept
    {
        RegisterCallForCancel( &hThread);
        ASSERT(tls_hBindRpc) ;
        hr = S_DSSetPropsGuid(  tls_hBindRpc,
                                dwObjectType,
                                pObjectGuid,
                                cp,
                                aProp,
                                apVar);
    }
    RpcExcept(1)
    {
        HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
    }
    RpcEndExcept
    UnregisterCallForCancel( hThread);

    return hr ;
}
/*====================================================

DSSetObjectPropertiesGuid

Arguments:

Return Value:

=====================================================*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectPropertiesGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[])

{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    HRESULT hr = MQ_OK;
    HRESULT hr1 = MQ_OK;
    DWORD   dwCount = 0 ;

    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,TEXT(" Calling S_DSSetObjectPropertiesGuid for object type %d"), dwObjectType) );

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSSetObjectPropertiesGuidInternal(
                           dwObjectType,
                           pObjectGuid,
                           cp,
                           aProp,
                           apVar);

        if ( hr == MQ_ERROR_NO_DS )
        {
            hr1 =  g_ChangeDsServer.FindAnotherServer( &dwCount,
                                                       FALSE);  //fWithoutSSL
        }
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}

/*====================================================

DSGetObjectSecurity

Arguments:

Return Value:

=====================================================*/

HRESULT
DSGetObjectSecurityInternal(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded)
{
    HRESULT hr = MQ_OK;
    RPC_STATUS rpc_stat;
    DWORD dwServerSignatureSize;
    LPBYTE pbServerSignature = AllocateSignatureBuffer(&dwServerSignatureSize);
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    ASSERT(g_fWorkGroup == FALSE);

    __try
    {
        RpcTryExcept
        {
            RegisterCallForCancel( &hThread);
            ASSERT(tls_hBindRpc) ;
            hr = S_DSGetObjectSecurity( tls_hBindRpc,
                                        dwObjectType,
                                        pwcsPathName,
                                        RequestedInformation,
                                        (unsigned char*) pSecurityDescriptor,
                                        nLength,
                                        lpnLengthNeeded,
                                        tls_hSrvrAuthnContext,
                                        pbServerSignature,
                                        &dwServerSignatureSize);
        }
        RpcExcept(1)
        {
            HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
        }
        RpcEndExcept
        UnregisterCallForCancel( hThread);

        if (SUCCEEDED(hr) && tls_hSvrAuthClientCtx.pvhContext)
        {
            hr = ValidateBuffer(*lpnLengthNeeded,
                                (LPBYTE)pSecurityDescriptor,
                                pbServerSignature,
                                dwServerSignatureSize);
        }
    }
    __finally
    {
        delete[] pbServerSignature;
    }

    return hr ;
}

/*====================================================

DSGetObjectSecurity

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectSecurity(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                  pwcsPathName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded)
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    DSCLI_API_PROLOG ;

    DBGMSG((DBGMOD_DSAPI, DBGLVL_TRACE,
      TEXT(" Calling S_DSGetObjectSecurity, object type %dt"), dwObjectType));

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSGetObjectSecurityInternal(
                                    dwObjectType,
                                    pwcsPathName,
                                    RequestedInformation,
                                    (unsigned char*) pSecurityDescriptor,
                                    nLength,
                                    lpnLengthNeeded);

        DSCLI_HANDLE_DS_ERROR(hr, hr1, dwCount, fReBind) ;
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}

/*====================================================

DSSetObjectSecurityInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSSetObjectSecurityInternal(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor)
{
    HRESULT hr;
    RPC_STATUS rpc_stat;
    DWORD nLength = 0;

    ASSERT(g_fWorkGroup == FALSE);
    ASSERT((SecurityInformation &
            (MQDS_KEYX_PUBLIC_KEY | MQDS_SIGN_PUBLIC_KEY)) !=
           (MQDS_KEYX_PUBLIC_KEY | MQDS_SIGN_PUBLIC_KEY));
    ASSERT(!((SecurityInformation & (MQDS_KEYX_PUBLIC_KEY | MQDS_SIGN_PUBLIC_KEY)) &&
             (SecurityInformation & ~(MQDS_KEYX_PUBLIC_KEY | MQDS_SIGN_PUBLIC_KEY))));

    if (pSecurityDescriptor)
    {
        if (SecurityInformation & (MQDS_SIGN_PUBLIC_KEY | MQDS_KEYX_PUBLIC_KEY))
        {
            ASSERT((dwObjectType == MQDS_MACHINE) || (dwObjectType == MQDS_SITE));
            nLength = ((PMQDS_PublicKey)pSecurityDescriptor)->dwPublikKeyBlobSize + sizeof(DWORD);
        }
        else
        {
            nLength = GetSecurityDescriptorLength(pSecurityDescriptor);
        }
    }

    HANDLE  hThread = INVALID_HANDLE_VALUE;

    RpcTryExcept
    {
        RegisterCallForCancel( &hThread);
        ASSERT(tls_hBindRpc) ;
        hr = S_DSSetObjectSecurity( tls_hBindRpc,
                                    dwObjectType,
                                    pwcsPathName,
                                    SecurityInformation,
                                    (unsigned char*) pSecurityDescriptor,
                                    nLength);
    }
    RpcExcept(1)
    {
        HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
    }
    RpcEndExcept
    UnregisterCallForCancel( hThread);

    return hr ;
}

/*====================================================

DSSetObjectSecurity

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectSecurity(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                  pwcsPathName,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor)
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    HRESULT hr = MQ_OK;
    HRESULT hr1 = MQ_OK;
    DWORD   dwCount = 0 ;

    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,TEXT(" Calling S_DSSetObjectSecurity for object type %d"), dwObjectType) );

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSSetObjectSecurityInternal( dwObjectType,
                                          pwcsPathName,
                                          SecurityInformation,
                                          (unsigned char*) pSecurityDescriptor);

        if ( hr == MQ_ERROR_NO_DS)
        {
            hr1 =  g_ChangeDsServer.FindAnotherServer( &dwCount,
                                                       FALSE);  //fWithoutSSL
        }
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}

/*====================================================

DSGetObjectSecurityGuidInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSGetObjectSecurityGuidInternal(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded)
{
    HRESULT hr = MQ_OK;
    RPC_STATUS rpc_stat;
    DWORD dwServerSignatureSize;
    LPBYTE pbServerSignature = AllocateSignatureBuffer(&dwServerSignatureSize);
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    ASSERT(g_fWorkGroup == FALSE);

    __try
    {
        RpcTryExcept
        {
            RegisterCallForCancel( &hThread);
            ASSERT(tls_hBindRpc) ;
            hr = S_DSGetObjectSecurityGuid( tls_hBindRpc,
                                            dwObjectType,
                                            pObjectGuid,
                                            RequestedInformation,
                                            (unsigned char*) pSecurityDescriptor,
                                            nLength,
                                            lpnLengthNeeded,
                                            tls_hSrvrAuthnContext,
                                            pbServerSignature,
                                            &dwServerSignatureSize);
        }
        RpcExcept(1)
        {
            HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
        }
        RpcEndExcept
        UnregisterCallForCancel( hThread);

        if (SUCCEEDED(hr) && tls_hSvrAuthClientCtx.pvhContext)
        {
            hr = ValidateBuffer(*lpnLengthNeeded,
                                (LPBYTE)pSecurityDescriptor,
                                pbServerSignature,
                                dwServerSignatureSize);
        }
    }
    __finally
    {
        delete[] pbServerSignature;
    }

    return hr ;
}

/*====================================================

DSGetObjectSecurityGuid

Arguments:

Return Value:

=====================================================*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectSecurityGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded)
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    DSCLI_API_PROLOG ;

    DBGMSG((DBGMOD_DSAPI, DBGLVL_TRACE,
     TEXT(" Calling S_DSGetObjectSecurityGuid, object type %dt"), dwObjectType) );

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSGetObjectSecurityGuidInternal(
                                        dwObjectType,
                                        pObjectGuid,
                                        RequestedInformation,
                                        (unsigned char*) pSecurityDescriptor,
                                        nLength,
                                        lpnLengthNeeded);

        DSCLI_HANDLE_DS_ERROR(hr, hr1, dwCount, fReBind) ;
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}

/*====================================================

DSSetObjectSecurityGuidInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSSetObjectSecurityGuidInternal(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor)
{
    HRESULT hr;
    RPC_STATUS rpc_stat;
    DWORD nLength = 0;

    ASSERT(g_fWorkGroup == FALSE);
    ASSERT((SecurityInformation &
            (MQDS_KEYX_PUBLIC_KEY | MQDS_SIGN_PUBLIC_KEY)) !=
           (MQDS_KEYX_PUBLIC_KEY | MQDS_SIGN_PUBLIC_KEY));
    ASSERT(!((SecurityInformation & (MQDS_KEYX_PUBLIC_KEY | MQDS_SIGN_PUBLIC_KEY)) &&
             (SecurityInformation & ~(MQDS_KEYX_PUBLIC_KEY | MQDS_SIGN_PUBLIC_KEY))));

    if (pSecurityDescriptor)
    {
        if (SecurityInformation & (MQDS_SIGN_PUBLIC_KEY | MQDS_KEYX_PUBLIC_KEY))
        {
            ASSERT(dwObjectType == MQDS_MACHINE);
            nLength = ((PMQDS_PublicKey)pSecurityDescriptor)->dwPublikKeyBlobSize + sizeof(DWORD);
        }
        else
        {
            nLength = GetSecurityDescriptorLength(pSecurityDescriptor);
        }
    }

    HANDLE  hThread = INVALID_HANDLE_VALUE;

    RpcTryExcept
    {
        RegisterCallForCancel( &hThread);
        ASSERT(tls_hBindRpc) ;
        hr = S_DSSetObjectSecurityGuid( tls_hBindRpc,
                                        dwObjectType,
                                        pObjectGuid,
                                        SecurityInformation,
                                        (unsigned char*) pSecurityDescriptor,
                                        nLength ) ;
    }
    RpcExcept(1)
    {
        HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
    }
    RpcEndExcept
    UnregisterCallForCancel( hThread);

    return hr ;
}

/*====================================================

DSSetObjectSecurityGuid

Arguments:

Return Value:

=====================================================*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectSecurityGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor)
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    HRESULT hr = MQ_OK;
    HRESULT hr1 = MQ_OK;
    DWORD   dwCount = 0 ;

    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,
    TEXT(" Calling S_DSSetObjectSecurityGuid for object type %d"), dwObjectType) );

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSSetObjectSecurityGuidInternal(
                                        dwObjectType,
                                        pObjectGuid,
                                        SecurityInformation,
                                        (unsigned char*) pSecurityDescriptor);

        if ( hr == MQ_ERROR_NO_DS)
        {
            hr1 =  g_ChangeDsServer.FindAnotherServer( &dwCount,
                                                       FALSE);  //fWithoutSSL
        }
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}


/*====================================================

DSGetUserParamsInternal

Arguments:

Return Value:

=====================================================*/

static
HRESULT
DSGetUserParamsInternal(
    IN DWORD dwFlags,
    IN DWORD dwSidLength,
    OUT PSID pUserSid,
    OUT DWORD *pdwSidReqLength,
    OUT LPWSTR szAccountName,
    OUT DWORD *pdwAccountNameLen,
    OUT LPWSTR szDomainName,
    OUT DWORD *pdwDomainNameLen)
{
    HRESULT hr = MQ_OK;
    RPC_STATUS rpc_stat;
    DWORD dwServerSignatureSize;
    LPBYTE pbServerSignature = AllocateSignatureBuffer(&dwServerSignatureSize);
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    ASSERT(g_fWorkGroup == FALSE);

    __try
    {
        RpcTryExcept
        {
            RegisterCallForCancel( &hThread);
            ASSERT(tls_hBindRpc) ;
            hr = S_DSGetUserParams( tls_hBindRpc,
                                    dwFlags,
                                    dwSidLength,
                                    (unsigned char *)pUserSid,
                                    pdwSidReqLength,
                                    szAccountName,
                                    pdwAccountNameLen,
                                    szDomainName,
                                    pdwDomainNameLen,
                                    tls_hSrvrAuthnContext,
                                    pbServerSignature,
                                    &dwServerSignatureSize);

            if (SUCCEEDED(hr) && tls_hSvrAuthClientCtx.pvhContext)
            {
                DWORD cp = 0;
                PROPVARIANT PropVar[3];

                if (dwFlags & GET_USER_PARAM_FLAG_SID)
                {
                    PropVar[cp].vt = VT_VECTOR | VT_UI1;
                    PropVar[cp].caub.pElems = (PBYTE)pUserSid;
                    PropVar[cp].caub.cElems = *pdwSidReqLength;
                    cp++;
                }

                if (dwFlags & GET_USER_PARAM_FLAG_ACCOUNT)
                {
                    PropVar[cp].vt = VT_LPWSTR;
                    PropVar[cp].pwszVal = szAccountName;
                    PropVar[cp+1].vt = VT_LPWSTR;
                    PropVar[cp+1].pwszVal = szDomainName;
                    cp += 2;
                }

                hr = ValidateProperties(cp,
                                        NULL,
                                        PropVar,
                                        pbServerSignature,
                                        dwServerSignatureSize);
            }
        }
        RpcExcept(1)
        {
            HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
        }
        RpcEndExcept
        UnregisterCallForCancel( hThread);
    }
    __finally
    {
        delete[] pbServerSignature;
    }

    return  hr ;
}

/*====================================================

DSGetUserParams

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetUserParams(
    IN DWORD dwFlags,
    IN DWORD dwSidLength,
    OUT PSID pUserSid,
    OUT DWORD *pdwSidReqLength,
    OUT LPWSTR szAccountName,
    OUT DWORD *pdwAccountNameLen,
    OUT LPWSTR szDomainName,
    OUT DWORD *pdwDomainNameLen)
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    DSCLI_API_PROLOG ;

    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,TEXT(" Calling DSGetUserParams")));

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSGetUserParamsInternal(
                 dwFlags,
                 dwSidLength,
                 pUserSid,
                 pdwSidReqLength,
                 szAccountName,
                 pdwAccountNameLen,
                 szDomainName,
                 pdwDomainNameLen);

        DSCLI_HANDLE_DS_ERROR(hr, hr1, dwCount, fReBind) ;
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}

/*====================================================

S_DSQMSetMachinePropertiesSignProc

Arguments:

Return Value:

=====================================================*/

HRESULT
S_DSQMSetMachinePropertiesSignProc(
    BYTE             *abChallenge,
    DWORD            dwCallengeSize,
    DWORD            dwContext,
    BYTE             *abSignature,
    DWORD            *pdwSignatureSize,
    DWORD            dwSignatureMaxSize)
{
    struct DSQMSetMachinePropertiesStruct *ps;
    try
    {   
        ps = (struct DSQMSetMachinePropertiesStruct *)
                 GET_FROM_CONTEXT_MAP(g_map_DSCLI_DSQMSetMachineProperties, dwContext,
                                      NULL, 0); //this may throw an exception on win64
    }
    catch(...)
    {
        return MQ_ERROR_INVALID_PARAMETER;
    }
    //
    // Sign the challenge and the properties that needs to be updated.
    //
    return (*ps->pfSignProc)(
                abChallenge,
                dwCallengeSize,
                (DWORD_PTR)ps,
                abSignature,
                pdwSignatureSize,
                dwSignatureMaxSize);
}


HRESULT
DSQMSetMachinePropertiesInternal(
    IN  LPCWSTR          pwcsPathName,
    IN  DWORD            cp,
    IN  PROPID           *aProp,
    IN  PROPVARIANT      *apVar,
    IN  DWORD            dwContextToUse)
{
    RPC_STATUS rpc_stat;
    HRESULT hr;
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    ASSERT(g_fWorkGroup == FALSE);

    RpcTryExcept
    {
        RegisterCallForCancel( &hThread);
        ASSERT(tls_hBindRpc) ;
        hr = S_DSQMSetMachineProperties(
                tls_hBindRpc,
                pwcsPathName,
                cp,
                aProp,
                apVar,
                dwContextToUse);
    }
    RpcExcept(1)
    {
        HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
    }
    RpcEndExcept
    UnregisterCallForCancel( hThread);

    return hr ;
}


/*====================================================

DSQMSetMachineProperties

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSQMSetMachineProperties(
    IN  LPCWSTR          pwcsPathName,
    IN  DWORD            cp,
    IN  PROPID           *aProp,
    IN  PROPVARIANT      *apVar,
    IN  DSQMChallengeResponce_ROUTINE pfSignProc,
    IN  DWORD_PTR        dwContext)
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    HRESULT hr = MQ_OK;
    HRESULT hr1 = MQ_OK;
    DWORD   dwCount = 0 ;

    DBGMSG((DBGMOD_DSAPI, DBGLVL_TRACE,
                          TEXT(" Calling DSQMSetMachineProperties")));

    //
    // Prepare the context for the RPC call to S_DSQMSetMachineProperties
    // On win32 just use the address of the struct below. On win64 we need to add
    // the address of the struct to a mapping table, and delete the mapping
    // when the struct goes out of scope.
    //
    // Passed context should be zero, we don't use it...
    //
    ASSERT(dwContext == 0);
    struct DSQMSetMachinePropertiesStruct s;
    s.cp = cp;
    s.aProp = aProp;
    s.apVar = apVar;
    s.pfSignProc = pfSignProc;
    DWORD dwContextToUse;
    try
    {
        dwContextToUse = (DWORD) ADD_TO_CONTEXT_MAP(g_map_DSCLI_DSQMSetMachineProperties, &s,
                                                    NULL, 0); //this may throw an exception on win64
    }
    catch(...)
    {
        return MQ_ERROR_INSUFFICIENT_RESOURCES;    
    }

    //
    // cleanup of the context mapping before returning from this function
    //
    CAutoDeleteDwordContext cleanup_dwpContext(g_map_DSCLI_DSQMSetMachineProperties, dwContextToUse);

	DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSQMSetMachinePropertiesInternal(
                pwcsPathName,
                cp,
                aProp,
                apVar,
                dwContextToUse);

        if ( hr == MQ_ERROR_NO_DS )
        {
            hr1 =  g_ChangeDsServer.FindAnotherServer( &dwCount,
                                                       FALSE);  //fWithoutSSL
        }
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}

/*====================================================

S_DSQMGetObjectSecurityChallengeResponceProc

Arguments:

Return Value:

=====================================================*/

HRESULT
S_DSQMGetObjectSecurityChallengeResponceProc(
    BYTE    *abChallenge,
    DWORD   dwCallengeSize,
    DWORD   dwContext,
    BYTE    *pbChallengeResponce,
    DWORD   *pdwChallengeResponceSize,
    DWORD   dwChallengeResponceMaxSize)
{
    DSQMChallengeResponce_ROUTINE pfChallengeResponceProc;
    try
    {
        pfChallengeResponceProc = (DSQMChallengeResponce_ROUTINE)
            GET_FROM_CONTEXT_MAP(g_map_DSCLI_DSQMGetObjectSecurity, dwContext,
                                 NULL, 0); //this may throw on win64
    }
    catch(...)
    {
        return MQ_ERROR_INVALID_PARAMETER;
    }

    //
    // Sign the challenge.
    //
    return (*pfChallengeResponceProc)(
                abChallenge,
                dwCallengeSize,
                (DWORD_PTR)pfChallengeResponceProc, // unused, but that is the context...
                pbChallengeResponce,
                pdwChallengeResponceSize,
                dwChallengeResponceMaxSize);
}

HRESULT
DSQMGetObjectSecurityInternal(
    IN  DWORD                   dwObjectType,
    IN  CONST GUID*             pObjectGuid,
    IN  SECURITY_INFORMATION    RequestedInformation,
    IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    IN  DWORD                   nLength,
    IN  LPDWORD                 lpnLengthNeeded,
    IN  DWORD                   dwContextToUse)
{
    RPC_STATUS rpc_stat;
    HRESULT hr = MQ_OK;
    HANDLE  hThread = INVALID_HANDLE_VALUE;
    DWORD dwServerSignatureSize;
    LPBYTE pbServerSignature = AllocateSignatureBuffer(&dwServerSignatureSize);

    ASSERT(g_fWorkGroup == FALSE);

    __try
    {
        RpcTryExcept
        {
            RegisterCallForCancel( &hThread);
            ASSERT(tls_hBindRpc) ;
            hr = S_DSQMGetObjectSecurity(
                    tls_hBindRpc,
                    dwObjectType,
                    pObjectGuid,
                    RequestedInformation,
                    (BYTE*)pSecurityDescriptor,
                    nLength,
                    lpnLengthNeeded,
                    dwContextToUse,
                    tls_hSrvrAuthnContext,
                    pbServerSignature,
                    &dwServerSignatureSize);
        }
        RpcExcept(1)
        {
            HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
        }
        RpcEndExcept
        UnregisterCallForCancel( hThread);

        if (SUCCEEDED(hr) && tls_hSvrAuthClientCtx.pvhContext)
        {
            hr = ValidateBuffer(*lpnLengthNeeded,
                                (LPBYTE)pSecurityDescriptor,
                                pbServerSignature,
                                dwServerSignatureSize);
        }
    }
    __finally
    {
        delete[] pbServerSignature;
    }

    return hr ;
}

/*====================================================

DSQMGetObjectSecurity

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSQMGetObjectSecurity(
    IN  DWORD                   dwObjectType,
    IN  CONST GUID*             pObjectGuid,
    IN  SECURITY_INFORMATION    RequestedInformation,
    IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    IN  DWORD                   nLength,
    IN  LPDWORD                 lpnLengthNeeded,
    IN  DSQMChallengeResponce_ROUTINE
                                pfChallengeResponceProc,
    IN  DWORD_PTR               dwContext)
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    HRESULT hr = MQ_OK;
    HRESULT hr1 = MQ_OK;
    DWORD   dwCount = 0 ;

    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,TEXT(" Calling DSQMGetObjectSecurity")));

    //
    // Prepare the context for the RPC call to S_DSQMGetObjectSecurity
    // On win32 just use the address of the challenge function. On win64 we need to add
    // the address of the challenge function to a mapping table, and delete the mapping
    // when the we go out of scope.
    //
    // Passed context should be zero, we don't use it...
    //
    ASSERT(dwContext == 0);
    DWORD dwContextToUse;
    try
    {
        dwContextToUse = (DWORD) ADD_TO_CONTEXT_MAP(g_map_DSCLI_DSQMGetObjectSecurity, pfChallengeResponceProc,
                                                    NULL, 0); //this may throw an exception on win64
    }
    catch(...)
    {
        return MQ_ERROR_INSUFFICIENT_RESOURCES;    
    }

    //
    // cleanup of the context mapping before returning from this function
    //
    CAutoDeleteDwordContext cleanup_dwpContext(g_map_DSCLI_DSQMGetObjectSecurity, dwContextToUse);

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSQMGetObjectSecurityInternal(
                dwObjectType,
                pObjectGuid,
                RequestedInformation,
                pSecurityDescriptor,
                nLength,
                lpnLengthNeeded,
                dwContextToUse);

        if ( hr == MQ_ERROR_NO_DS )
        {
            hr1 =  g_ChangeDsServer.FindAnotherServer( &dwCount,
                                                       FALSE ); //fWithoutSSL
        }
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}

/*====================================================

 DSCreateServersCacheInternal

Arguments:      None

Return Value:   None

=====================================================*/

HRESULT  DSCreateServersCacheInternal( DWORD *pdwIndex,
                                       LPWSTR *lplpSiteString)
{
    RPC_STATUS rpc_stat;
    HRESULT hr = MQ_OK;
    DWORD dwServerSignatureSize;
    LPBYTE pbServerSignature = AllocateSignatureBuffer(&dwServerSignatureSize);
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    ASSERT(g_fWorkGroup == FALSE);

    __try
    {
        RpcTryExcept
        {
            RegisterCallForCancel( &hThread);
            ASSERT(tls_hBindRpc) ;

            hr = S_DSCreateServersCache( tls_hBindRpc,
                                         pdwIndex,
                                         lplpSiteString,
                                         tls_hSrvrAuthnContext,
                                         pbServerSignature,
                                         &dwServerSignatureSize) ;
        }
        RpcExcept(1)
        {
            HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
        }
        RpcEndExcept
        UnregisterCallForCancel( hThread);

        if (SUCCEEDED(hr) && tls_hSvrAuthClientCtx.pvhContext)
        {
            PROPVARIANT PropVar[2];

            PropVar[0].vt = VT_UI4;
            PropVar[0].ulVal = *pdwIndex;
            PropVar[1].vt = VT_LPWSTR;
            PropVar[1].pwszVal = *lplpSiteString;


            hr = ValidateProperties(2,
                                    NULL,
                                    PropVar,
                                    pbServerSignature,
                                    dwServerSignatureSize);
        }

    }
    __finally
    {
        delete[] pbServerSignature;
    }

    return hr ;
}

/*====================================================

DSCreateServersCache

Arguments:      None

Return Value:   None

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSCreateServersCache()
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

   return _DSCreateServersCache() ; // in servlist.cpp
}


/*====================================================

DSTerminate

Arguments:      None

Return Value:   None

=====================================================*/

VOID
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSTerminate()
{
}


/*====================================================

DSCloseServerHandle

Arguments:

Return Value:

=====================================================*/

void
DSCloseServerHandle(
              IN PCONTEXT_HANDLE_SERVER_AUTH_TYPE *   pphContext)
{

    HANDLE  hThread = INVALID_HANDLE_VALUE;

    RpcTryExcept
    {
        RegisterCallForCancel( &hThread);
        S_DSCloseServerHandle(pphContext);
    }
    RpcExcept(1)
    {
        //
        //  we don't care if we can not reach the server, but we do
        //  want to destroy the client context in this case.
        //
        RpcSsDestroyClientContext((PVOID *)pphContext);
    }
    RpcEndExcept
    UnregisterCallForCancel( hThread);
}



/*====================================================

DSGetComputerSitesInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSGetComputerSitesInternal(
                        IN  LPCWSTR                 pwcsPathName,
                        OUT DWORD *                 pdwNumberSites,
                        OUT GUID**                  ppguidSites)
{
    RPC_STATUS rpc_stat;
    HRESULT hr = MQ_OK;
    DWORD dwServerSignatureSize;
    LPBYTE pbServerSignature = AllocateSignatureBuffer(&dwServerSignatureSize);
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    ASSERT(g_fWorkGroup == FALSE);

    __try
    {
        RpcTryExcept
        {
            RegisterCallForCancel( &hThread);
            ASSERT(tls_hBindRpc) ;
            hr = S_DSGetComputerSites(
                                   tls_hBindRpc,
                                   pwcsPathName,
                                   pdwNumberSites,
                                   ppguidSites,
                                   tls_hSrvrAuthnContext,
                                   pbServerSignature,
                                   &dwServerSignatureSize
                                   );
        }
        RpcExcept(1)
        {
            HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
        }
        RpcEndExcept
        UnregisterCallForCancel( hThread);
        if (SUCCEEDED(hr) && tls_hSvrAuthClientCtx.pvhContext)
        {

            hr = ValidateBuffer( sizeof(GUID) *(*pdwNumberSites),
                                (LPBYTE)*ppguidSites,
                                pbServerSignature,
                                dwServerSignatureSize);
        }
    }
    __finally
    {
        delete[] pbServerSignature;
    }

    return hr ;
}


/*====================================================

DSGetComputerSites

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetComputerSites(
                        IN  LPCWSTR                 pwcsPathName,
                        OUT DWORD *                 pdwNumberSites,
                        OUT GUID**                  ppguidSites)
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;


    HRESULT hr = MQ_OK;
    HRESULT hr1 = MQ_OK;
    DWORD   dwCount = 0 ;

    DBGMSG((DBGMOD_DSAPI, DBGLVL_TRACE,
        TEXT(" Calling S_DSGetComputerSites "))) ;

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL
    *pdwNumberSites = 0;
    *ppguidSites = NULL;

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr =  DSGetComputerSitesInternal(
                                pwcsPathName,
                                pdwNumberSites,
                                ppguidSites);



        if ( hr == MQ_ERROR_NO_DS)
        {
           hr1 =  g_ChangeDsServer.FindAnotherServer(&dwCount,
                                                     FALSE);    // fWithoutSSL
        }
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}

/*====================================================

DSGetObjectPropertiesExInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSGetObjectPropertiesExInternal(
                               IN  DWORD                    dwObjectType,
                               IN  LPCWSTR                  pwcsPathName,
                               IN  DWORD                    cp,
                               IN  PROPID                   aProp[],
                               IN  PROPVARIANT              apVar[])
{
    HRESULT hr = MQ_OK;
    RPC_STATUS rpc_stat;
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    DWORD dwServerSignatureSize;
    LPBYTE pbServerSignature =
                      AllocateSignatureBuffer( &dwServerSignatureSize ) ;

    ASSERT(g_fWorkGroup == FALSE);

    __try
    {
        RpcTryExcept
        {
           RegisterCallForCancel( &hThread);
           ASSERT(tls_hBindRpc) ;

            hr = S_DSGetPropsEx(
                           tls_hBindRpc,
                           dwObjectType,
                           pwcsPathName,
                           cp,
                           aProp,
                           apVar,
                           tls_hSrvrAuthnContext,
                           pbServerSignature,
                          &dwServerSignatureSize ) ;
        }
        RpcExcept(1)
        {
            HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
        }
        RpcEndExcept
        UnregisterCallForCancel( hThread);

        if (SUCCEEDED(hr) && tls_hSvrAuthClientCtx.pvhContext)
        {
            hr = ValidateProperties(cp,
                                    aProp,
                                    apVar,
                                    pbServerSignature,
                                    dwServerSignatureSize);
        }
    }
    __finally
    {
        delete[] pbServerSignature;
    }

    return hr ;
}

/*====================================================

DSGetObjectPropertiesEx

    For retrieving MSMQ 2.0 properties


Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectPropertiesEx(
                       IN  DWORD                    dwObjectType,
                       IN  LPCWSTR                  pwcsPathName,
                       IN  DWORD                    cp,
                       IN  PROPID                   aProp[],
                       IN  PROPVARIANT              apVar[] )
                       /*IN  BOOL                     fSearchDSServer )*/
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    DSCLI_API_PROLOG ;
	UNREFERENCED_PARAMETER(fReBind);

    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,
          TEXT (" DSGetObjectPropertiesEx: object type %d"), dwObjectType) );

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    //
    //  Clear all the pointers of VT_NULL variants
    //
    for ( DWORD i = 0 ; i < cp ; i++ )
    {
        if (apVar[i].vt == VT_NULL)
        {
            memset( &apVar[i].caub, 0, sizeof(CAUB));
        }
    }

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSGetObjectPropertiesExInternal(
                           dwObjectType,
                           pwcsPathName,
                           cp,
                           aProp,
                           apVar);

        /*if ((hr == MQ_ERROR_NO_DS) && fSearchDSServer)*/
        if (hr == MQ_ERROR_NO_DS)
        {
            hr1 =  g_ChangeDsServer.FindAnotherServer(&dwCount,
                                                       FALSE);  // fWithoutSSL
        }
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}

/*====================================================

DSGetObjectPropertiesGuidExInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSGetObjectPropertiesGuidExInternal(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[])
{
    HRESULT hr = MQ_OK;
    RPC_STATUS rpc_stat;
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    DWORD dwServerSignatureSize;
    LPBYTE pbServerSignature =
                      AllocateSignatureBuffer( &dwServerSignatureSize ) ;

    ASSERT(g_fWorkGroup == FALSE);

    __try
    {
        RpcTryExcept
        {
            RegisterCallForCancel( &hThread);
            ASSERT(tls_hBindRpc) ;
            hr = S_DSGetPropsGuidEx(
                                tls_hBindRpc,
                                dwObjectType,
                                pObjectGuid,
                                cp,
                                aProp,
                                apVar,
                                tls_hSrvrAuthnContext,
                                pbServerSignature,
                               &dwServerSignatureSize ) ;
        }
        RpcExcept(1)
        {
            HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
        }
        RpcEndExcept
        UnregisterCallForCancel( hThread);

        if (SUCCEEDED(hr) && tls_hSvrAuthClientCtx.pvhContext)
        {
            hr = ValidateProperties(cp,
                                    aProp,
                                    apVar,
                                    pbServerSignature,
                                    dwServerSignatureSize);
        }
    }
    __finally
    {
        delete[] pbServerSignature;
    }

    return hr ;
}

/*====================================================

DSGetObjectPropertiesGuidEx

    For retrieving MSMQ 2.0 properties


Arguments:

Return Value:

=====================================================*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectPropertiesGuidEx(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[] )
                /*IN  BOOL                    fSearchDSServer )*/
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    DSCLI_API_PROLOG ;
	UNREFERENCED_PARAMETER(fReBind);

    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,
       TEXT(" DSGetObjectPropertiesGuidEx: object type %d"), dwObjectType) ) ;

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    //
    //  Clear all the pointers of VT_NULL variants
    //
    for ( DWORD i = 0; i < cp; i++)
    {
        if (apVar[i].vt == VT_NULL)
        {
            memset( &apVar[i].caub, 0, sizeof(CAUB));
        }
    }

    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSGetObjectPropertiesGuidExInternal(
                                                 dwObjectType,
                                                 pObjectGuid,
                                                 cp,
                                                 aProp,
                                                 apVar);

        /*if ((hr == MQ_ERROR_NO_DS) && fSearchDSServer)*/
        if (hr == MQ_ERROR_NO_DS)
        {
           hr1 =  g_ChangeDsServer.FindAnotherServer(&dwCount,
                                                     FALSE);    // fWithoutSSL
        }
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}

/*====================================================

DSBeginDeleteNotificationInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSBeginDeleteNotificationInternal(
                      LPCWSTR						pwcsQueueName,
                      HANDLE   *                    phEnum
                      )
{
    HRESULT hr;
    RPC_STATUS rpc_stat;
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    ASSERT(g_fWorkGroup == FALSE);

    RpcTryExcept
    {
        RegisterCallForCancel( &hThread);
        ASSERT(tls_hBindRpc) ;
        hr = S_DSBeginDeleteNotification(
                            tls_hBindRpc,
                            pwcsQueueName,
                            phEnum,
                            tls_hSrvrAuthnContext
                            );
    }
    RpcExcept(1)
    {
        HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
    }
    RpcEndExcept
    UnregisterCallForCancel( hThread);


    return hr ;
}
/*====================================================

RoutineName: DSBeginDeleteNotification

Arguments:

Return Value:

=====================================================*/
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSBeginDeleteNotification(
                      LPCWSTR						pwcsQueueName,
                      HANDLE   *                    phEnum
	                  )
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    DSCLI_API_PROLOG ;
	UNREFERENCED_PARAMETER(fReBind);

    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,
       TEXT(" DSBeginDeleteNotification")) ) ;

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL


    while (!FAILED(hr1))
    {
        hr1 = MQ_ERROR;

        hr = DSBeginDeleteNotificationInternal(
                                    pwcsQueueName,
                                    phEnum);

        if ( hr == MQ_ERROR_NO_DS)
        {
           hr1 =  g_ChangeDsServer.FindAnotherServer(&dwCount,
                                                     FALSE);    // fWithoutSSL
        }
    }

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}

/*====================================================

RoutineName: DSNotifyDelete

Arguments:

Return Value:

=====================================================*/
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSNotifyDelete(
     HANDLE                             hEnum
	)
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    HRESULT hr;
    RPC_STATUS rpc_stat;

    //
    //  No use to try to connect another server in case of connectivity
    //  failure ( should contine with the one that handled LookupBein and LookupEnd/
    //
    DBGMSG((DBGMOD_DSAPI, DBGLVL_TRACE,
                  TEXT (" Calling DSNotifyDelete : handle %p"), hEnum) ) ;

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    RpcTryExcept
    {
        RegisterCallForCancel( &hThread);
        ASSERT(tls_hBindRpc) ;
        hr = S_DSNotifyDelete(
                        tls_hBindRpc,
                        hEnum );
    }
    RpcExcept(1)
    {
        HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
    }
    RpcEndExcept
    UnregisterCallForCancel( hThread);

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr;
}

/*====================================================

RoutineName: DSEndDeleteNotification

Arguments:

Return Value:

=====================================================*/
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSEndDeleteNotification(
    HANDLE                          hEnum
	)
{
    if (g_fWorkGroup)
        return MQ_ERROR_UNSUPPORTED_OPERATION   ;

    HRESULT hr;
    RPC_STATUS rpc_stat;

    //
    //  No use to try to connect another server in case of connectivity
    //  failure ( should contine with the one that handled LookupBein and LookupEnd/
    //
    DBGMSG((DBGMOD_DSAPI, DBGLVL_TRACE,
                  TEXT (" Calling DSEndDeleteNotification : handle %p"), hEnum) ) ;

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    RpcTryExcept
    {
        RegisterCallForCancel( &hThread);
        ASSERT(tls_hBindRpc) ;
        S_DSEndDeleteNotification(
                            tls_hBindRpc,
                            &hEnum );
        hr = MQ_OK;
    }
    RpcExcept(1)
    {
        HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
    }
    RpcEndExcept
    UnregisterCallForCancel( hThread);

    DSCLI_RELEASE_RPC_HANDLE ;
    return hr ;
}


/*====================================================

RoutineName: DSFreeMemory

Arguments:

Return Value:

=====================================================*/
void
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSFreeMemory(
        IN PVOID pMemory
        )
{
	delete pMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscli\dsclisec.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dslcisec.h

Abstract:

   Security related code (mainly client side of server authentication)
   for mqdscli

Author:

    Doron Juster  (DoronJ)

--*/

HRESULT
ValidateProperties(
    DWORD cp,
    PROPID *aProp,
    PROPVARIANT *apVar,
    PBYTE pbServerSignature,
    DWORD dwServerSignatureSize) ;

HRESULT
ValidateBuffer(
    DWORD cbSize,
    PBYTE pbBuffer,
    PBYTE pbServerSignature,
    DWORD dwServerSignatureSize) ;

LPBYTE
AllocateSignatureBuffer( DWORD *pdwSignatureBufferSize ) ;

BOOL IsSspiServerAuthNeeded( IN LPADSCLI_DSSERVERS  pBinding,
                             IN BOOL                fRefresh ) ;

HRESULT
ValidateSecureServer(
    IN      LPCWSTR         szServerName,
    IN      CONST GUID*     pguidEnterpriseId,
    IN      BOOL            fSetupMode,
    IN      BOOL            fTryServerAuth ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscli\dscomm_c_.c ===
#pragma warning(push, 3)
#pragma warning(disable: 4701)
#include <dscomm_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscli\dsreg.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    dsreg.h

Abstract:
    parse & compose DS servers settings in registry (e.g. MQISServer)

Author:
    Raanan Harari (RaananH)

--*/

#ifndef __DSREG_H__
#define __DSREG_H__

//----------------------------------------------------
//  Data on a DS server as appears in the registry
//----------------------------------------------------
struct MqRegDsServer
{
    AP<WCHAR> pwszName;
    BOOL fSupportsIP;
    BOOL fUnused; // was: fSupportsIPX;
};

BOOL ParseRegDsServersBuf(IN LPCWSTR pwszRegDS,
                          IN ULONG cServersBuf,
                          IN MqRegDsServer * rgServersBuf,
                          OUT ULONG *pcServers);

void ParseRegDsServers(IN LPCWSTR pwszRegDS,
                       OUT ULONG * pcServers,
                       OUT MqRegDsServer ** prgServers);

BOOL ComposeRegDsServersBuf(IN ULONG cServers,
                            IN const MqRegDsServer * rgServers,
                            IN LPWSTR pwszRegDSBuf,
                            IN ULONG cchRegDSBuf,
                            OUT ULONG * pcchRegDS);

void ComposeRegDsServers(IN ULONG cServers,
                         IN const MqRegDsServer * rgServers,
                         OUT LPWSTR * ppwszRegDS);

#endif //__DSREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscli\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by res.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscli\dscmain.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    dscmain.cpp


Abstract:
      DllMain - of MQ DS client dll

Author:

    Ronit Hartmann (ronith)
    Doron Juster (DoronJ),  Nov-96,  convert to tcp/ip and ipx instead
              of named pipes. Need for security/impersonation and RAS.
    Shai Kariv  (shaik)  24-Jul-2000    Remove IPX support. 

--*/

#include "stdh.h"
#include "dsproto.h"
#include "dsinc.h"
#include "_registr.h"
#include "chndssrv.h"
#include "_mqrpc.h"
#include "mqutil.h"
#include "rpcdscli.h"
#include "freebind.h"
#include "_mqrpc.h"
//
// mqwin64.cpp may be included only once in a module
//
#include <mqwin64.cpp>

#include "dscmain.tmh"

//
// Global variables
//
// this one is FALSE by default, meaning RPC use dynamic endpoints.
//
BOOL  g_fUsePredefinedEP = RPC_DEFAULT_PREDEFINE_DS_EP ;

//
// This flag indicates if the machine work as "WorkGroup" or not.
// If the machine is "WorkGroup" machine don't try to access the DS.
//
BOOL g_fWorkGroup = FALSE;

#define  MAX_RPC_PORT_LEN  12
static TCHAR   s_wszRpcIpPort[ MAX_RPC_PORT_LEN ] ;

#define  MAX_RPC_LOCAL_EP_LEN  28
static TCHAR   s_wszRpcLocalEp[ MAX_RPC_LOCAL_EP_LEN ] ;

HMODULE g_hMod = NULL;

CChangeDSServer   g_ChangeDsServer;
CFreeRPCHandles   g_CFreeRPCHandles ;

WCHAR             g_szMachineName[ MAX_COMPUTERNAME_LENGTH + 1 ] = {0} ;

//
// Each thread has its own rpc binding handle and server authentication
// context.  This is necessary for at least two reasons:
// 1. Each thread can impersonate a different user.
// 2. Each thread can connect to a different MQIS server.
//
// The handle and context are stored in a TLS slot. We can't use
// declspec(thread) because the dll can be dynamically loaded
// (by LoadLibrary()).
//
// This is the index of the slot.
//
#define UNINIT_TLSINDEX_VALUE   0xffffffff
DWORD  g_hBindIndex = UNINIT_TLSINDEX_VALUE ;
//
//  Critical Section to make RPC thread safe.
//
CCriticalSection CRpcCS ;

extern void DSCloseServerHandle( PCONTEXT_HANDLE_SERVER_AUTH_TYPE * pphContext);


//-------------------------------------
//
//  static void _ThreadDetach()
//
//-------------------------------------

static void _ThreadDetach()
{
    if (g_hBindIndex != UNINIT_TLSINDEX_VALUE)
    {
        if ( (TLS_NOT_EMPTY) && (tls_hThread != NULL))
        {
            CloseHandle( tls_hThread);
            tls_hThread = NULL;
        }
        g_CFreeRPCHandles.Add(tls_bind_data);
        BOOL fFree = TlsSetValue( g_hBindIndex, NULL );
        ASSERT(fFree);
		DBG_USED(fFree);
    }
}

//-------------------------------------
//
//  DllMain
//
//-------------------------------------

BOOL WINAPI DllMain (HMODULE hMod, DWORD fdwReason, LPVOID lpvReserved)
{
    BOOL result = TRUE;
    BOOL fFree ;

    switch (fdwReason)
    {

        case DLL_PROCESS_ATTACH:
        {
            WPP_INIT_TRACING(L"Microsoft\\MSMQ");

            //
            // DLL is attaching to the address space of the current process
            //
            g_hBindIndex = TlsAlloc() ;

            if (g_hBindIndex == UNINIT_TLSINDEX_VALUE)
            {
               return FALSE ;
            }
            g_hMod = hMod;

            //
            // Read local rpc endpoint
            //
            READ_REG_STRING( wzLocalEp,
                             RPC_DS_LOCAL_EP_REGNAME,
                             DEFAULT_RPC_DS_LOCAL_EP ) ;
            ASSERT(wcslen(wzLocalEp) < MAX_RPC_LOCAL_EP_LEN) ;
            wcscpy(s_wszRpcLocalEp, wzLocalEp) ;

            //
            // Read the IP port for RPC.
            // First see if we use dynamic or predefined endpoints.
            //
            DWORD ulDefault =  RPC_DEFAULT_PREDEFINE_DS_EP ;
            READ_REG_DWORD( g_fUsePredefinedEP,
                            RPC_PREDEFINE_DS_EP_REGNAME,
                            &ulDefault );

            if (g_fUsePredefinedEP)
            {
               READ_REG_STRING( wzDsIPEp,
                                FALCON_DS_RPC_IP_PORT_REGNAME,
                                FALCON_DEFAULT_DS_RPC_IP_PORT ) ;
               ASSERT(wcslen(wzDsIPEp) < MAX_RPC_PORT_LEN) ;
               wcscpy(s_wszRpcIpPort, wzDsIPEp) ;
            }

            DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
            HRESULT hr = GetComputerNameInternal( 
                             g_szMachineName,
                             &dwSize
                             );
            ASSERT(SUCCEEDED(hr));
			DBG_USED(hr);

            //
            // Read from registery if the machine is WorkGroup Installed machine
            //
            dwSize = sizeof(DWORD) ;
            DWORD  dwType = REG_DWORD ;

            LONG res = GetFalconKeyValue(
                                MSMQ_WORKGROUP_REGNAME,
                                &dwType,
                                &g_fWorkGroup,
                                &dwSize,
                                FALSE
                                );

			UNREFERENCED_PARAMETER(res);

            //
            // fall thru, put a null in the tls.
            //
        }

        case DLL_THREAD_ATTACH:
            fFree = TlsSetValue( g_hBindIndex, NULL ) ;
            ASSERT(fFree) ;


            break;

        case DLL_PROCESS_DETACH:
            //
            // First free whatever is free in THREAD_DETACH.
            //
            _ThreadDetach() ;

            //
            //  Free the tls index for the rpc binding handle
            //
            ASSERT(g_hBindIndex != UNINIT_TLSINDEX_VALUE) ;
            if (g_hBindIndex != UNINIT_TLSINDEX_VALUE)
            {
               fFree = TlsFree( g_hBindIndex ) ;
               ASSERT(fFree) ;
            }

            WPP_CLEANUP();
            break;

        case DLL_THREAD_DETACH:
            _ThreadDetach() ;
            break;

    }
    return(result);
}


/*====================================================

RpcInit()

Arguments: none

Return Value: HRESULT

This routine create the rpc binding handle and allocate the
MQISCLI_RPCBINDING structure to be kept in tls.

=====================================================*/

HRESULT RpcInit ( LPWSTR  pServer,
                  MQRPC_AUTHENTICATION_LEVEL* peAuthnLevel,
                  ULONG ulAuthnSvc,
                  BOOL    *pProtocolNotSupported,
                  BOOL    *pLocalRpc)
{
    CS Lock(CRpcCS) ;

    *pProtocolNotSupported = FALSE ;

    ASSERT(g_hBindIndex != UNINIT_TLSINDEX_VALUE) ;

    if (g_hBindIndex == UNINIT_TLSINDEX_VALUE)
    {
        //
        // Error. TLS not initialized.
        //
        return MQDS_E_CANT_INIT_RPC ;
    }

    if (TLS_NOT_EMPTY && tls_hBindRpc)
    {
        //
        // RPC already initialized. First call RpcClose() if you want
        // to bind to another server or protocol.
        //
        return MQ_OK ;
    }

    LPADSCLI_RPCBINDING pCliBind = tls_bind_data ;
    ASSERT(pCliBind) ;

    handle_t hBind ;

    *pLocalRpc = FALSE;
    if (!_wcsicmp(pServer, g_szMachineName))
    {
        //
        // Local MQIS. Use local rpc, not tcp/ip or spx
        //
        *pLocalRpc = TRUE;
        RPC_STATUS rc;
        TBYTE* pszStringBinding = NULL ;

        AP<WCHAR> pwzEndpoint = 0;
        ComposeLocalEndPoint(s_wszRpcLocalEp, &pwzEndpoint);

        rc = RpcStringBindingCompose( 0,
                                      RPC_LOCAL_PROTOCOL,
                                      0,
                                      pwzEndpoint,
                                      RPC_LOCAL_OPTION,
                                      &pszStringBinding );
        ASSERT(rc == 0);
        DBGMSG((DBGMOD_RPC, DBGLVL_INFO,
            TEXT("RpcStringBindingCompose for local MQIS: 0x%x, (%ls)"),
                                              rc, pszStringBinding)) ;

        rc = RpcBindingFromStringBinding( pszStringBinding, &hBind );
        mqrpcUnbindQMService( NULL, &pszStringBinding );

        if(rc != RPC_S_OK)
        {
            return MQDS_E_CANT_INIT_RPC;
        }
    }
    else
    {
        HRESULT hr = MQ_OK ;
        TCHAR *pwzRpcPort ;
        pwzRpcPort = s_wszRpcIpPort ;

        GetPort_ROUTINE pfnGetPort = S_DSGetServerPort ;
        if (!g_fUsePredefinedEP)
        {
            pwzRpcPort = NULL ;
        }
        
        hr = mqrpcBindQMService( pServer,
            IP_ADDRESS_TYPE,
            pwzRpcPort,
            peAuthnLevel,
            pProtocolNotSupported,
            &hBind,
            TRUE,
            pfnGetPort,
            NULL /*pfWin95*/,
            ulAuthnSvc) ;
        if (FAILED(hr))
        {
            return MQ_ERROR_NO_DS;
        }       
    }

    ASSERT(hBind) ;
    pCliBind->hRpcBinding = hBind ;
    return MQ_OK ;
}

/*====================================================

RpcClose

Arguments:
 *  IN BOOL fCloseAuthn- if TRUE then release the server authentication
      context. By default (fCloseAuthn == FALSE), we close only the binding
      handle (e.g., when a thread exit). However, if a server crash and then
      reboot, we'll close the binding handle and release server
      authentication. We identify the crash case when rpc call reutrn with
      exception INVALID_HANDLE.

Return Value:

This routine cleans up RPC connection

=====================================================*/

HRESULT RpcClose()
{
    CS Lock(CRpcCS) ;

    g_CFreeRPCHandles.FreeCurrentThreadBinding();

    return MQ_OK ;
}



/*====================================================

FreeBindingAndContext

Arguments:
 *  IN LPADSCLI_RPCBINDING pmqisRpcBinding

Return Value:

This routine frees the binding handle and closes the sever authentication context

=====================================================*/

void FreeBindingAndContext( LPADSCLI_RPCBINDING pmqisRpcBinding)
{
    handle_t  hBind = pmqisRpcBinding->hRpcBinding ;
    if (hBind)
    {
        RPC_STATUS status = RpcBindingFree(&hBind);
        ASSERT(status == RPC_S_OK);
		DBG_USED(status);
        pmqisRpcBinding->hRpcBinding = NULL;
    }
    if (pmqisRpcBinding->hServerAuthContext)
    {
        DSCloseServerHandle(&pmqisRpcBinding->hServerAuthContext);
        pmqisRpcBinding->hServerAuthContext = NULL;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscli\dsclisec.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dslcisec.cpp

Abstract:

   Security related code (mainly client side of server authentication)
   for mqdscli

Author:

    Doron Juster  (DoronJ)

--*/

#include "stdh.h"
#include "dsproto.h"
#include "ds.h"
#include "chndssrv.h"
#include <malloc.h>
#include "rpcdscli.h"
#include "rpcancel.h"
#include "dsclisec.h"
#include <_secutil.h>
#include <mqsec.h>
#include <mqkeyhlp.h>

#include "dsclisec.tmh"

class ClientInitSecCtxContext
{
public:
	ClientInitSecCtxContext() :
		pvhClientCred(NULL),
		pvhClientContext(NULL)
	{
	}

public:
    LPVOID pvhClientCred;
    LPVOID pvhClientContext;
};

typedef ClientInitSecCtxContext *PClientInitSecCtxContext;

CContextMap g_map_DSCLI_DSValidateServer;

//+----------------------------------------------------------------------
//
//  HRESULT  S_InitSecCtx()
//
//  This function is called back from MSMQ DS server when establishing
//  RPC session with server authentication.
//
//+----------------------------------------------------------------------

HRESULT
S_InitSecCtx(
    DWORD dwContext,
    UCHAR *pCerverBuff,
    DWORD dwServerBuffSize,
    DWORD dwMaxClientBuffSize,
    UCHAR *pClientBuff,
    DWORD *pdwClientBuffSize)
{
    PClientInitSecCtxContext pContext;
    try
    {
        pContext = (PClientInitSecCtxContext)
            GET_FROM_CONTEXT_MAP(g_map_DSCLI_DSValidateServer, dwContext,
                                 NULL, 0); //this may throw an exception on win64
    }
    catch(...)
    {
        return MQ_ERROR_INVALID_PARAMETER;
    }

    return ClientInitSecCtx(pContext->pvhClientCred,
                            pContext->pvhClientContext,
                            pCerverBuff,
                            dwServerBuffSize,
                            dwMaxClientBuffSize,
                            pClientBuff,
                            pdwClientBuffSize);
}


/*====================================================

ValidateSecureServer

Arguments:

Return Value:

=====================================================*/

HRESULT
ValidateSecureServer(
    IN      LPCWSTR         szServerName,
    IN      CONST GUID*     pguidEnterpriseId,
    IN      BOOL            fSetupMode,
    IN      BOOL            fTryServerAuth )
{

    RPC_STATUS rpc_stat;
    HRESULT hr = MQ_OK;
    LPBYTE pbTokenBuffer = NULL;
    DWORD  dwTokenBufferSize;
    DWORD dwTokenBufferMaxSize;
    DWORD dwDummy;

    ClientInitSecCtxContext Context;
    DWORD dwContextToUse = 0;
    BOOL fSecuredServer = fTryServerAuth ;

    tls_hSrvrAuthnContext = NULL ;
    tls_hSvrAuthClientCtx.pvhContext = NULL;
    tls_hSvrAuthClientCtx.cbHeader = 0;
    tls_hSvrAuthClientCtx.cbTrailer = 0;
    HANDLE  hThread = INVALID_HANDLE_VALUE;

    __try
    {
        if (fSecuredServer)
        {
            hr = GetSizes(&dwTokenBufferMaxSize);
            if (FAILED(hr))
            {
                return(hr);
            }

            pbTokenBuffer = new BYTE[dwTokenBufferMaxSize];

            hr = GetClientCredHandleAndInitSecCtx(
                    szServerName,
                    &Context.pvhClientCred,
                    &Context.pvhClientContext,
                    pbTokenBuffer,
                    &dwTokenBufferSize);
            if (FAILED(hr))
            {
                return(hr);
            }
        }
        else
        {
            pbTokenBuffer = (LPBYTE)&dwDummy;
            dwTokenBufferSize = 0;
            dwTokenBufferMaxSize = 0;
        }

        dwContextToUse = (DWORD) ADD_TO_CONTEXT_MAP(g_map_DSCLI_DSValidateServer, &Context,
                                                    NULL, 0); //this may throw bad_alloc (like the new above)

        RpcTryExcept
        {
            RegisterCallForCancel( &hThread);
            ASSERT(tls_hBindRpc) ;
            hr = S_DSValidateServer(
                    tls_hBindRpc,
                    pguidEnterpriseId,
                    fSetupMode,
                    dwContextToUse,
                    dwTokenBufferMaxSize,
                    pbTokenBuffer,
                    dwTokenBufferSize,
                    &tls_hSrvrAuthnContext) ;
        }
        RpcExcept(1)
        {
            HANDLE_RPC_EXCEPTION(rpc_stat, hr)  ;
        }
        RpcEndExcept
        UnregisterCallForCancel( hThread);
    }
    __finally
    {
        if (fSecuredServer)
        {
            delete pbTokenBuffer;
        }

        //
        // can't use CAutoDeleteDwordContext because of __try (SEH exceptions)
        //
        if (dwContextToUse)
        {
            DELETE_FROM_CONTEXT_MAP(g_map_DSCLI_DSValidateServer, dwContextToUse,
                                    NULL, 0);
        }
    }

    if (SUCCEEDED(hr) && fSecuredServer)
    {
        tls_hSvrAuthClientCtx.pvhContext = Context.pvhClientContext;
        GetSizes(NULL,
                 tls_hSvrAuthClientCtx.pvhContext,
                 &tls_hSvrAuthClientCtx.cbHeader,
                 &tls_hSvrAuthClientCtx.cbTrailer) ;
    }

    return hr ;
}

/*====================================================

ValidateProperties

Arguments:

Return Value:

=====================================================*/

#define MAX_HASH_SIZE   128 //bytes

HRESULT
ValidateProperties(
    DWORD cp,
    PROPID *aProp,
    PROPVARIANT *apVar,
    PBYTE pbServerSignature,
    DWORD dwServerSignatureSize)
{
    HRESULT hr;
    PBYTE pbServerHash;

    //
    // Unseal the server's signature.
    //
    hr = MQUnsealBuffer(tls_hSvrAuthClientCtx.pvhContext,
                        pbServerSignature,
                        dwServerSignatureSize,
                        &pbServerHash);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Create a hash object.
    //
    CHCryptHash hHash;

    ASSERT(g_hProvVer) ;
    if (!CryptCreateHash(g_hProvVer, CALG_MD5, NULL, 0, &hHash))
    {
        return(MQ_ERROR_INSUFFICIENT_RESOURCES);
    }

    //
    // Hash the properties.
    //
    hr = HashProperties(hHash, cp, aProp, apVar);
    if (FAILED(hr))
    {
        return hr;
    }

    ASSERT(dwServerSignatureSize >
            (tls_hSvrAuthClientCtx.cbHeader +
             tls_hSvrAuthClientCtx.cbTrailer) );

    //
    // Get the hash value.
    //
    DWORD dwHashSize = dwServerSignatureSize -
                       tls_hSvrAuthClientCtx.cbHeader -
                       tls_hSvrAuthClientCtx.cbTrailer ;
    DWORD dwServerHashSize = dwHashSize;
    PBYTE pbHashVal = (PBYTE)_alloca(dwHashSize);

    if (!CryptGetHashParam(hHash, HP_HASHVAL, pbHashVal, &dwHashSize, 0))
    {
        return MQ_ERROR_CORRUPTED_SECURITY_DATA;
    }

    ASSERT(dwHashSize == dwServerHashSize);

        //
    // Compare the two hash values.
    //
    if ((dwServerHashSize != dwHashSize) ||
        (memcmp(pbServerHash, pbHashVal, dwHashSize) != 0))
    {
        REPORT_CATEGORY(SERVER_AUTHENTICATION_FAILURE, CATEGORY_KERNEL);
        return MQ_ERROR_NO_DS;
    }

    return MQ_OK;
}

/*====================================================

ValidateBuffer

Arguments:

Return Value:

=====================================================*/
HRESULT
ValidateBuffer(
    DWORD cbSize,
    PBYTE pbBuffer,
    PBYTE pbServerSignature,
    DWORD dwServerSignatureSize)
{
    //
    // Present the buffer as a VT_BOLB PROPVARIANT and validate is as a single
    // property. This corresponds to the way the server generates the signature
    // for buffers.
    //
    PROPVARIANT PropVar;

    PropVar.vt = VT_BLOB;
    PropVar.blob.cbSize = cbSize;
    PropVar.blob.pBlobData = pbBuffer;

    return ValidateProperties(1,
                              NULL,
                              &PropVar,
                              pbServerSignature,
                              dwServerSignatureSize);
}


#define MAX_HASH_SIZE   128 //bytes

/*====================================================

AllocateSignatureBuffer

Arguments:

Return Value:

=====================================================*/
LPBYTE
AllocateSignatureBuffer(
        DWORD *pdwSignatureBufferSize)
{
    //
    // Allocate a buffer for receiving the server's signature. If no secure
    // connection to the server is required, still we allocate a single byte,
    // this is done for the sake of RPC.
    //
    if (tls_hSvrAuthClientCtx.pvhContext)
    {
        *pdwSignatureBufferSize = MAX_HASH_SIZE +
                                  tls_hSvrAuthClientCtx.cbHeader +
                                  tls_hSvrAuthClientCtx.cbTrailer;
    }
    else
    {
        *pdwSignatureBufferSize = 0;
    }

    return new BYTE[*pdwSignatureBufferSize];
}
//+-------------------------------------------------------------------------
//
//  BOOL IsSspiServerAuthNeeded()
//
//  Return TRUE if SSPI style of server authentication is needed. That's the
//  way used on NT4, with server certificate. On a native Windows 2000
//  environment we use Kerberos mutual authentication, not SSPi.
//
//+-------------------------------------------------------------------------

BOOL IsSspiServerAuthNeeded( LPADSCLI_DSSERVERS  pBinding,
                             BOOL                fSetupMode )
{
    if (pBinding->fLocalRpc)
    {
        return FALSE ;
    }
    else if (pBinding->ulAuthnSvc == RPC_C_AUTHN_GSS_KERBEROS)
    {
        return FALSE ;
    }
    else if ( MQsspi_IsSecuredServerConn( fSetupMode ))
    {
        //
        // user require server authentication and it's not using Kerberos
        // and it's not a local call. So use SSPI.
        //
        return TRUE ;
    }

    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscli\freebind.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    freebind.h

Abstract:
    Free binding handles

Author:
    Doron Juster  (DoronJ)

--*/

#ifndef __FREEBIND_H
#define __FREEBIND_H

#include "cs.h"
#include "rpcdscli.h"


#define  MAX_NUMOF_RPC_HANDLES  1024
extern void FreeBindingAndContext( LPADSCLI_RPCBINDING pmqisRpcBinding);

//---------------------------------------------------------
//
//  class CFreeRPCHandles
//
//---------------------------------------------------------
class CFreeRPCHandles {
public:
    CFreeRPCHandles() ;

    void Add(LPADSCLI_RPCBINDING pCliBind) ;
    void FreeAll() ;
    void FreeCurrentThreadBinding();

private:
    CCriticalSection      m_cs;

    DWORD                 m_dwIndex ;
    LPADSCLI_RPCBINDING   m_apCliBind[ MAX_NUMOF_RPC_HANDLES ] ;
};


inline  CFreeRPCHandles::CFreeRPCHandles()
{
    m_dwIndex = 0 ;
}

inline void CFreeRPCHandles::Add(LPADSCLI_RPCBINDING pCliBind)
{
    CS Lock(m_cs) ;

    ASSERT(m_dwIndex < MAX_NUMOF_RPC_HANDLES);
    if (pCliBind && (m_dwIndex < MAX_NUMOF_RPC_HANDLES))
    {
        m_apCliBind[ m_dwIndex ] = pCliBind ;
        m_dwIndex++ ;
    }
}

inline void CFreeRPCHandles::FreeAll()
{
    CS Lock(m_cs) ;

    for ( DWORD i = 0 ; i < m_dwIndex ; i++ )
    {
        LPADSCLI_RPCBINDING pCliBind = m_apCliBind[ i ] ;

        FreeBindingAndContext( pCliBind);

        delete  pCliBind ;
        m_apCliBind[ i ] = NULL ;
    }
    m_dwIndex = 0 ;
}

#define UNINIT_TLSINDEX_VALUE   0xffffffff

inline void CFreeRPCHandles::FreeCurrentThreadBinding()
{
    ASSERT(g_hBindIndex != UNINIT_TLSINDEX_VALUE);

    if (TLS_IS_EMPTY)
    {
       return;
    }
    ADSCLI_RPCBINDING * pCliBind = tls_bind_data;
    FreeBindingAndContext( pCliBind);

}

#endif  //  __FREEBIND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscli\dsreg.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    dsreg.cpp

Abstract:
    parse & compose DS servers settings in registry (e.g. MQISServer)

Author:
    Raanan Harari (RaananH)

--*/

#include "stdh.h"
#include "_mqini.h"
#include "dsreg.h"

#include "dsreg.tmh"

BOOL ParseRegDsServersBuf(IN LPCWSTR pwszRegDS,
                          IN ULONG cServersBuf,
                          IN MqRegDsServer * rgServersBuf,
                          OUT ULONG *pcServers)
/*++

Routine Description:
    Parses DS servers registry settings in the format FFName,FFNAME,...
    where FF represents IP & IPX connectivity of the server, and Name is
    the server's name.
    This function can be called to fill a given array with the data, or to
    just count the number of servers in the string (e.g. in order to allocate
    a properly sized array, and call again to fill it)

Arguments:
    pwszRegDS    - string in the above format (e.g. 10haifapec,10hafabsc)
    cServersBuf  - number of entries in server array
    rgServersBuf - servers array to fill. can be NULL to only count the servers in the string.
    pcServers    - if above array is NULL:
                      returned number of servers in the string
                   else:
                      returned number of servers filled in the array

Return Value:
    TRUE  - success
    FALSE - partial success. the array is filled, but it is too small, and
            some servers are left out.

--*/
{
    ULONG cServers = 0;
    LPCWSTR pwszStart = pwszRegDS;
    BOOL fBufIsOK = TRUE;
    //
    // loop as long as we didn't reach the end, AND
    //      we didn't fill up the buffer
    //
    while ((*pwszStart) && fBufIsOK)
    {
        //
        // find server's length
        //
        for (LPCWSTR pwszEnd = pwszStart; ((*pwszEnd != L'\0') && (*pwszEnd != DS_SERVER_SEPERATOR_SIGN)); pwszEnd++)
		{
			NULL;
		}
        ULONG_PTR cchLen = pwszEnd - pwszStart;

        //
        // the smallest server' name is at least three characters long
        // (two protocols flags and one character for server name).
        //
        if (cchLen >= 3)
        {
            //
            // if we got a buffer to fill than do it
            //
            if (rgServersBuf)
            {
                if (cServers == cServersBuf)
                {
                    //
                    // buffer is full
                    //
                    fBufIsOK = FALSE;
                }
                else
                {
                    MqRegDsServer * pServer = &rgServersBuf[cServers];
                    //
                    // copy server's flags
                    //
                    pServer->fSupportsIP = (BOOL) (*pwszStart - L'0');
                    //
                    // copy server's name
                    //
                    pServer->pwszName = new WCHAR [cchLen-2+1];
                    memcpy(pServer->pwszName, pwszStart+2, sizeof(WCHAR)*(cchLen-2));
                    pServer->pwszName[cchLen-2] = L'\0';
                    //
                    // increment servers filled
                    //
                    cServers++;
                }
            }
            else
            {
                //
                // no buffer to fill, just count the server
                //
                cServers++;
            }
        }

        //
        // proceed to start of next server if not exiting now
        //
        if (fBufIsOK)
        {
            if (*pwszEnd)
            {
                //
                // it is a comma, skip it
                //
                pwszStart = pwszEnd + 1;
            }
            else
            {
                //
                // it is the end, go to it
                //
                pwszStart = pwszEnd;
            }
        }
    }

    //
    // set the number of servers processed. If we were supplied with a buffer,
    // this is the number of servers filled, otherwise it is the total number of servers
    //
    *pcServers = cServers;
    //
    // return indication whether we parsed all servers (if not supplied
    // with a buffer it is always TRUE)
    //
    return fBufIsOK;
}


void ParseRegDsServers(IN LPCWSTR pwszRegDS,
                       OUT ULONG * pcServers,
                       OUT MqRegDsServer ** prgServers)
/*++

Routine Description:
    Parses DS servers registry settings in the format FFName,FFNAME,...
    where FF represents IP & IPX connectivity of the server, and Name is
    the server's name.
    The routine allocates & returns the server's array

Arguments:
    pwszRegDS    - string in the above format (e.g. 10haifapec,10hafabsc)
    pcServers    - returned number of servers in array
    cServersBuf  - returned array of servers

Return Value:
    None

--*/
{
    //
    // count servers
    //
    ULONG cServers;
    ParseRegDsServersBuf(pwszRegDS, 0, NULL, &cServers);

    AP<MqRegDsServer> rgServers = NULL; //redundant, but for clarity

    //
    // if there are servers, alloc & fill the list
    //
    if (cServers > 0)
    {
        rgServers = new MqRegDsServer [cServers];
        ParseRegDsServersBuf(pwszRegDS, cServers, rgServers, &cServers);
    }

    //
    // return results
    //
    *pcServers = cServers;
    *prgServers = rgServers.detach();
}


BOOL ComposeRegDsServersBuf(IN ULONG cServers,
                            IN const MqRegDsServer * rgServers,
                            IN LPWSTR pwszRegDSBuf,
                            IN ULONG cchRegDSBuf,
                            OUT ULONG * pcchRegDS)
/*++

Routine Description:
    Composes DS servers registry settings in the format FFName,FFNAME,...
    where FF represents IP & IPX connectivity of the server, and Name is
    the server's name.
    This function can be called to fill a given string with the data, or to
    just count the number of characters needed for the string (e.g. in order
    to allocate a properly sized string, and call again to fill it)

Arguments:
    cServers     - number of entries in server array
    rgServers    - servers array
    pwszRegDSBuf - string buffer to fill
    cchRegDSBuf  - number of wide characters to fill in the string buffer, not including
                   the NULL terminator (e.g. the allocated string buffer size should
                   be at least one character bigger).
    pcchRegDS    - if above buffer is NULL:
                      returned number of wide characters needed, not including
                      the NULL terminator (e.g. the allocated string buffer size should
                      be at least one character bigger)
                   else:
                      returned number of wide characters filled in the string buffer, not
                      including the NULL terminator (e.g. NULL is put at the end of the
                      string, but not counted)

Return Value:
    TRUE  - success
    FALSE - partial suucess. the string is filled correctly, but it is too small, and
            some servers are left out.

--*/
{
    BOOL fBufIsOK = TRUE;
    const MqRegDsServer * pServer = rgServers;
    ULONG cchBufLeft = cchRegDSBuf;
    LPWSTR pwszTmp = pwszRegDSBuf;
    ULONG cchRegDS = 0;
    for (ULONG ulServer = 0; (ulServer < cServers) && fBufIsOK; ulServer++, pServer++)
    {
        //
        // calculate size of added server
        //
        ULONG cchName = wcslen(pServer->pwszName);
        ULONG cchToAdd = cchName + 2;
        if (ulServer > 0)
        {
            cchToAdd++; //comma
        }

        //
        // if we need to add, do it
        //
        if (pwszRegDSBuf)
        {
            //
            // make sure there is a place
            //
            if (cchToAdd > cchBufLeft)
            {
                //
                // buf is full
                //
                fBufIsOK = FALSE;
            }
            else
            {
                //
                // put comma
                //
                if (ulServer > 0)
                {
                    *pwszTmp = DS_SERVER_SEPERATOR_SIGN;
                    pwszTmp++;
                }
                //
                // put 2 protocol flags
                //
                *pwszTmp        = (pServer->fSupportsIP  ? L'1' : L'0');

				//
				// put 0 for IPX
				//
                *(pwszTmp + 1)  = L'0';

                pwszTmp += 2;
                //
                // put server's name
                //
                wcscpy(pwszTmp, pServer->pwszName);
                pwszTmp += cchName;

                //
                // update place left in buffer
                //
                cchBufLeft -= cchToAdd;
            }
        }
        else // no need to fill a buffer
        {
            //
            // count needed chars
            //
            cchRegDS += cchToAdd;
        }
    }

    //
    // return results
    //
    if (pwszRegDSBuf)
    {
        *pwszTmp = L'\0';  // incase there were no servers written
        *pcchRegDS = cchRegDSBuf - cchBufLeft;
        return fBufIsOK;
    }
    else
    {
        *pcchRegDS = cchRegDS;
        return TRUE;
    }
}


void ComposeRegDsServers(IN ULONG cServers,
                         IN const MqRegDsServer * rgServers,
                         OUT LPWSTR * ppwszRegDS)
/*++

Routine Description:
    Composes DS servers registry settings in the format FFName,FFNAME,...
    where FF represents IP & IPX connectivity of the server, and Name is
    the server's name.
    The routine allocates & returns the string.

Arguments:
    cServers      - number of entries in server array
    rgServers     - servers array
    ppwszRegDSBuf - returned string

Return Value:
    None

--*/
{
    //
    // get size
    //
    ULONG cchRegDS;
    ComposeRegDsServersBuf(cServers, rgServers, NULL, 0, &cchRegDS);

    //
    // alloc & fill string
    //
    AP<WCHAR> pwszRegDS = new WCHAR [cchRegDS + 1];
    BOOL fOK = ComposeRegDsServersBuf(cServers, rgServers, pwszRegDS, cchRegDS, &cchRegDS);
    ASSERT(fOK);
	DBG_USED(fOK);

    //
    // return results
    //
    *ppwszRegDS = pwszRegDS.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscli\midluser.cpp ===
#include "stdh.h"
#include "..\..\common\midluser.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscli\rpcancel.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    rpcancel.h

Abstract:

   Code to cancel pending calls, if they do not return after some time.

Author:

    Doron Juster  (DoronJ)

--*/

#include <cancel.h>

//
//  Cancel RPC globals
//
extern MQUTIL_EXPORT CCancelRpc g_CancelRpc;
/*====================================================

RegisterCallForCancel

Arguments:

Return Value:

  Register the call for cancel if its duration is too long
=====================================================*/
inline  void RegisterCallForCancel(IN   HANDLE * phThread)
{

    LPADSCLI_RPCBINDING pCliBind = NULL ;
    //
    //  Was the tls structure initiailzed
    //
    if (TLS_IS_EMPTY)
    {
		pCliBind = (LPADSCLI_RPCBINDING) new ADSCLI_RPCBINDING;
		memset(pCliBind, 0, sizeof(ADSCLI_RPCBINDING));
		BOOL fSet = TlsSetValue(g_hBindIndex, pCliBind);
		ASSERT(fSet);
		DBG_USED(fSet);
    }
    else
    {
		pCliBind =  tls_bind_data;
    }
    ASSERT(pCliBind);


    if ( pCliBind->hThread == NULL)
    {
        //
        //  First time
        //
        //  Get the thread handle
        //
        HANDLE hT = GetCurrentThread();
        BOOL fResult = DuplicateHandle(
            GetCurrentProcess(),
            hT,
            GetCurrentProcess(),
            &pCliBind->hThread,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);
        ASSERT(fResult == TRUE);
		DBG_USED(fResult);
        ASSERT(pCliBind->hThread);

        //
        // Set the lower bound on the time to wait before timing
        // out after forwarding a cancel.
        //
        RPC_STATUS status;
        status = RpcMgmtSetCancelTimeout(0);
        ASSERT( status == RPC_S_OK);

    }
    *phThread = pCliBind->hThread;
    //
    //  Register the thread
    //
    g_CancelRpc.Add( pCliBind->hThread, time(NULL));
}


/*====================================================

UnregisterCallForCancel

Arguments:

Return Value:

  Register the call for cancel if its duration is too long
=====================================================*/
inline  void UnregisterCallForCancel(IN HANDLE hThread)
{
    ASSERT( hThread != NULL);

    //
    //  unregister the thread
    //
    g_CancelRpc.Remove( hThread);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscli\servlist.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    servlist.cpp

Abstract:

   Create sites/servers list on Client machine

Author:

    Doron Juster  (DoronJ)

--*/

#include "stdh.h"
#include "ds.h"
#include "chndssrv.h"
#include "servlist.h"
#include "rpcdscli.h"
#include "freebind.h"
#include <_registr.h>

#include "servlist.tmh"

extern CFreeRPCHandles   g_CFreeRPCHandles ;

/*====================================================

 _DSCreateServersCache

Arguments:      None

Return Value:   None

=====================================================*/

HRESULT _DSCreateServersCache()
{
    DBGMSG((DBGMOD_DSAPI,DBGLVL_TRACE,
                                 TEXT(" Calling DSCreateServersCache"))) ;

    //
    // First, open the registry key.
    //
    LONG    rc;
    DWORD   dwDisposition;
    HKEY    hKeyCache ;

    WCHAR  tServersKeyName[ 256 ] = {0} ;
    wcscpy(tServersKeyName, GetFalconSectionName()) ;
    wcscat(tServersKeyName, TEXT("\\ServersCache")) ;

    rc = RegCreateKeyEx( FALCON_REG_POS,
                         tServersKeyName,
                         0L,
                         L"REG_SZ",
                         REG_OPTION_NON_VOLATILE,
                         KEY_WRITE | KEY_READ,
                         NULL,
                         &hKeyCache,
                         &dwDisposition );

    if (rc != ERROR_SUCCESS)
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR,
                _TEXT("Fail to Open 'ServersCache' Key. Error %d"), rc));
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                          MSMQ_INTERNAL_ERROR,
                                          1,
                                          L"DSCreateServersCache()")) ;
        return MQ_ERROR ;
    }

    HRESULT hr = MQ_OK ;
    DWORD dwIndex = 0 ;
    LPWSTR lpSiteString = NULL ;

    DSCLI_ACQUIRE_RPC_HANDLE(FALSE) ;   // fWithoutSSL

    while (SUCCEEDED(hr))
    {
        ASSERT(lpSiteString == NULL) ;
        hr =  DSCreateServersCacheInternal( &dwIndex,
                                            &lpSiteString ) ;

        if (hr == MQ_OK)
        {
           LPWSTR lpValue = lpSiteString ;
           LPWSTR lpData = wcschr(lpSiteString, L';') ;
           *lpData = L'\0' ;
           lpData++ ;

           LONG rc = RegSetValueEx( hKeyCache,
                                    lpValue,
                                    0L,
                                    REG_SZ,
                                    (const BYTE*) lpData,
                              ((wcslen(lpData) + 1) * sizeof(WCHAR)) );
           ASSERT(rc == ERROR_SUCCESS) ;
		   DBG_USED(rc);

           dwIndex++ ;
           delete lpSiteString ;
           lpSiteString = NULL ;
        }
        else if (hr == MQDS_E_NO_MORE_DATA)
        {
           hr = MQ_OK ;
           break ;
        }
    }
    ASSERT(lpSiteString == NULL) ;

    DSCLI_RELEASE_RPC_HANDLE ;

    dwIndex = 0 ;
    WCHAR wszData[ 1024 ] ;
    DWORD dwDataLen = 1024 * sizeof(WCHAR) ;
    WCHAR wszValueName[ 512 ] ;
    DWORD dwValueLen = 512 ;
    DWORD dwType = REG_SZ ;

    if (hr == MQ_OK)
    {
       //
       // Cleanup old entries. Only if we got all entried from MQIS server.
       // New ones always begin with X
       //
       BOOL  fDeleted = FALSE ;

       do
       {
          dwIndex = 0 ;
          fDeleted = FALSE ;
          do
          {
             dwDataLen = 1024 * sizeof(WCHAR) ;
             dwValueLen = 512 ;
             rc = RegEnumValue( hKeyCache,
                                dwIndex,
                                wszValueName,
                                &dwValueLen,
                                NULL,
                                &dwType,
                                (BYTE *)&wszData[0],
                                &dwDataLen ) ;
             if ((rc == ERROR_SUCCESS) &&
                 (wszData[0] != NEW_SITE_IN_REG_FLAG_CHR))
             {
                LONG rc1 = RegDeleteValue(hKeyCache, wszValueName);
                ASSERT(rc1 == ERROR_SUCCESS);
				DBG_USED(rc1);
                fDeleted = TRUE;
             }
             dwIndex++ ;
          }
          while (rc == ERROR_SUCCESS) ;
       }
       while (fDeleted) ;
    }

    //
    // Now remove the '\' from the new entries.
    //
    BOOL  fUpdated = FALSE ;
    do
    {
       dwIndex = 0 ;
       fUpdated = FALSE ;
       do
       {
          dwDataLen = 1024 * sizeof(WCHAR) ;
          dwValueLen = 512 ;
          rc = RegEnumValue( hKeyCache,
                             dwIndex,
                             wszValueName,
                             &dwValueLen,
                             NULL,
                             &dwType,
                             (BYTE *)&wszData[0],
                             &dwDataLen ) ;
          if ((rc == ERROR_SUCCESS) &&
              (wszData[0] == NEW_SITE_IN_REG_FLAG_CHR))
          {
             LONG rc1 = RegSetValueEx( hKeyCache,
                                       wszValueName,
                                       0L,
                                       REG_SZ,
                                    (const BYTE*) &wszData[1],
                         ((wcslen(&wszData[1]) + 1) * sizeof(WCHAR)) );
             ASSERT(rc1 == ERROR_SUCCESS);
			 DBG_USED(rc1);
             fUpdated = TRUE;
          }
          dwIndex++ ;
       }
       while (rc == ERROR_SUCCESS) ;
    }
    while (fUpdated) ;

    RegCloseKey(hKeyCache) ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\adstempl.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    adstempl.h

Abstract:
    Useful templates 

Author:
    ronit hartmann (ronith)

Revision History:
--*/

#ifndef _ADSTEMPL_H
#define _ADSTEMPL_H

#include "dsads.h"
#include "coreglb.h"


//-----------------------------
//
//  Close DS query handle
//
class CDsQueryHandle
{
public:
    CDsQueryHandle( ): m_Handle(0) 
	{}
	~CDsQueryHandle(); 
    HANDLE * GetPtr();
    HANDLE GetHandle();
    void   SetHandle( IN HANDLE handle);
	
private:
    HANDLE  m_Handle;


};

inline CDsQueryHandle::~CDsQueryHandle()
{
    if ( m_Handle)
    {
        g_pDS->LocateEnd( m_Handle);
    }
}

inline void CDsQueryHandle::SetHandle( IN HANDLE handle)
{
    ASSERT( m_Handle == 0);
    m_Handle = handle;
}

inline HANDLE * CDsQueryHandle::GetPtr()
{
    return(&m_Handle);
}
inline HANDLE  CDsQueryHandle::GetHandle()
{
    return(m_Handle);
}


//#pragma warning(disable: 4284)

//-----------------------------
//
//  Auto delete BSTR
//
class PBSTR {
private:
    BSTR * m_p;

public:
    PBSTR() : m_p(0)            {}
    PBSTR(BSTR* p) : m_p(p)     {}
   ~PBSTR()                     {if ( m_p != 0) SysFreeString(*m_p); }

    operator BSTR*() const    { return m_p; }
    //T** operator&()         { return &m_p;}
    //T* operator->() const   { return m_p; }
    //P<T>& operator=(T* p)   { m_p = p; return *this; }
    BSTR* detach()            { BSTR* p = m_p; m_p = 0; return p; }
};


//-----------------------------
//
//  Auto delete of ADs allocated attributes
//
class ADsFreeAttr {
private:
   PADS_ATTR_INFO m_p;

public:
    ADsFreeAttr();
    ADsFreeAttr(PADS_ATTR_INFO p);
   ~ADsFreeAttr();
    // ADsFreeMem is recommended, but only FreeADsMem is defined in adshlp.h

    operator PADS_ATTR_INFO() const   { return m_p; }
    PADS_ATTR_INFO* operator&()       { return &m_p;}
    PADS_ATTR_INFO operator->() const { return m_p; }
};
inline ADsFreeAttr::ADsFreeAttr() : m_p(0)
{}
inline ADsFreeAttr::ADsFreeAttr(PADS_ATTR_INFO p)
             : m_p(p)
{}

inline ADsFreeAttr::~ADsFreeAttr()
{
    if (m_p)
    {
        FreeADsMem(m_p);
    }
}
//-----------------------------
//
//  Auto delete of ADs allocated string
//
class ADsFree {
private:
    WCHAR * m_p;

public:
    ADsFree() : m_p(0)            {}
    ADsFree(WCHAR* p) : m_p(p)    {}
   ~ADsFree()                     {FreeADsStr(m_p);}

    operator WCHAR*() const   { return m_p; }
    WCHAR** operator&()       { return &m_p;}
    WCHAR* operator->() const { return m_p; }
};

//--------------------------------
//
//  Auto delete of ADS_SEARCH_COLUMN array
//
class ADsSearchColumnsFree {
private:
    ADS_SEARCH_COLUMN **m_ppColumns;
    DWORD               m_dwNum;
    IDirectorySearch  * m_pIDirectorySearch;
public:
    ADsSearchColumnsFree( 
            IDirectorySearch * pIDirectorySearch,
            DWORD              dwNum);
    ~ADsSearchColumnsFree();
    ADS_SEARCH_COLUMN * Allocate( DWORD index);
    ADS_SEARCH_COLUMN * Get( DWORD index);
};

inline  ADsSearchColumnsFree::ADsSearchColumnsFree(
            IDirectorySearch * pIDirectorySearch,
            DWORD              dwNum) : 
            m_pIDirectorySearch(pIDirectorySearch)
{
    m_ppColumns = new ADS_SEARCH_COLUMN *[dwNum];
    ADS_SEARCH_COLUMN ** ppColumn = m_ppColumns;
    for (DWORD i = 0 ; i < dwNum; i++, ppColumn++)
    {
        *ppColumn = NULL;    
    }
    m_dwNum = dwNum;
}
inline  ADsSearchColumnsFree::~ADsSearchColumnsFree()
{
    ADS_SEARCH_COLUMN ** ppColumn = m_ppColumns;
    HRESULT hr;
    for (DWORD i = 0; i < m_dwNum; i++, ppColumn++)
    {
        if ( *ppColumn != NULL)
        {
            hr = m_pIDirectorySearch->FreeColumn( *ppColumn);
            ASSERT(SUCCEEDED(hr));       //e.g.wrong column data

            delete *ppColumn;
        }
    }
    delete [] m_ppColumns;
}
inline ADS_SEARCH_COLUMN * ADsSearchColumnsFree::Allocate( DWORD index)
{
    ASSERT( index < m_dwNum);
    ASSERT( m_ppColumns[ index] == NULL);
    ADS_SEARCH_COLUMN * pColumn = new ADS_SEARCH_COLUMN;
    m_ppColumns[ index] = pColumn;
    return pColumn;
}

inline ADS_SEARCH_COLUMN * ADsSearchColumnsFree::Get( DWORD index)
{
    if ( index == x_NoPropertyFirstAppearance)
    {
        return(NULL);
    }
    ASSERT( index < m_dwNum);
    return m_ppColumns[ index];
}



//-----------------------------
//
//  Auto delete of array of strings
//
class CWcsArray {
private:
    DWORD         m_numWcs;
    WCHAR **      m_ppWcs;
    BOOL          m_fNeedRelease;

public:
    CWcsArray(IN DWORD    numWcs,
              IN WCHAR ** ppWcs);

   ~CWcsArray();
   void detach(void)    { m_fNeedRelease = FALSE;}  
};

inline CWcsArray::CWcsArray( IN DWORD    numWcs,
                      IN WCHAR ** ppWcs)
                      : m_numWcs( numWcs),
                        m_ppWcs( ppWcs),
                        m_fNeedRelease( TRUE)
{
    for ( DWORD i = 0 ; i < m_numWcs; i++)
    {
        m_ppWcs[i] = NULL;
    }
}
inline CWcsArray::~CWcsArray()
{
    if (  m_fNeedRelease)
    {
        for (DWORD i = 0; i < m_numWcs; i++)
        {
            delete [] m_ppWcs[i];
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscli\stdh.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    precompiled header file for DS Server

Author:

    RaphiR
    Erez Haba (erezh) 25-Jan-96

--*/

#ifndef __STDH_H
#define __STDH_H

#include <_stdh.h>

#include <dscomm.h>
#include <mqsymbls.h>
#include <_mqdef.h>


HRESULT
_DSCreateServersCache(
    void
    );

HRESULT
DSCreateServersCacheInternal(
    DWORD *pdwIndex,
    LPWSTR *lplpSiteString
    );

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\coreglb.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    DSGlbObj.cpp

Abstract:

    Declaration of Global Instances of the MQADS server.
    They are put in one place to ensure the order their constructors take place.

Author:

    ronit hartmann (ronith)

--*/
#include "ds_stdh.h"
#include "mqads.h"
#include "dsads.h"
#include "siteinfo.h"
#include "siterout.h"
#include "ipsite.h"
#include "fornsite.h"

#include "coreglb.tmh"

static WCHAR *s_FN=L"mqdscore/coreglb";

BOOL g_fSetupMode = FALSE ;

// single global object providing ADSI access
P<CADSI> g_pDS;

// translation information of properties
CMap<PROPID, PROPID, const MQTranslateInfo*, const MQTranslateInfo*&> g_PropDictionary;



P<CSiteInformation>    g_pMySiteInformation;

// sites routing table
P<CSiteRoutingInformation> g_pSiteRoutingTable;

// IPAddress-to-site mapping
P<CIpSite> g_pcIpSite;

//
//  Global DS pathnames
//
AP<WCHAR> g_pwcsServicesContainer;
AP<WCHAR> g_pwcsMsmqServiceContainer;
AP<WCHAR> g_pwcsDsRoot;
AP<WCHAR> g_pwcsSitesContainer;
AP<WCHAR> g_pwcsConfigurationContainer;
AP<WCHAR> g_pwcsLocalDsRoot;

//
//  The local server name
//
AP<WCHAR> g_pwcsServerName = NULL ;
DWORD     g_dwServerNameLength = 0;
GUID      g_guidThisServerQMId = {0};

//
// Local server attributes.
//
//  g_fLocalServerIsGC is TRUE if local domain controller is also a GC
//  (Global Catalog).
//
BOOL      g_fLocalServerIsGC = FALSE ;

// map of foreign sites
CMapForeignSites g_mapForeignSites;


//+-----------------------------
//
//  GetLocalDsRoot()
//
//+-----------------------------

const WCHAR * GetLocalDsRoot()
{
    ASSERT(g_pwcsLocalDsRoot) ;
    return g_pwcsLocalDsRoot;
}

//+-----------------------------
//
//  GetMsmqServiceContainer()
//
//+-----------------------------

const WCHAR * GetMsmqServiceContainer()
{
    ASSERT(g_pwcsMsmqServiceContainer);
    return g_pwcsMsmqServiceContainer;
}

//+-----------------------------
//
//  GetLocalServerName()
//
//+-----------------------------

const WCHAR * GetLocalServerName()
{
    ASSERT(g_pwcsServerName) ;
    return g_pwcsServerName  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscli\rpcdscli.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    rpcdscli.h

Abstract:
    Define data which is needed for being a good and authenticated MQIS
    (rpc) client.

Author:
    Doron Juster  (DoronJ)   21-May-1997   Created

--*/

#ifndef __RPCDSLCI_H
#define __RPCDSLCI_H

/////////////////////////////////////////////
//
//  Structures
//
/////////////////////////////////////////////

#define DS_SERVER_NAME_MAX_SIZE  256
#define DS_IP_BUFFER_SIZE         48

typedef struct _ADSCLI_DSSERVERS
{
   //
   // the following were added to support nt4 clients running in a nt5
   // servers environment. These one need be per-thread, to enable each
   // thread to query a different nt5 ds server.
   // This structure is inisialized in chndssrv.cpp, in ::FindServer().
   //
   TCHAR         wszDSServerName[ DS_SERVER_NAME_MAX_SIZE ] ;
   TCHAR         wzDsIP[ DS_IP_BUFFER_SIZE ] ;
   DWORD         dwProtocol ;

   //
   // TRUE if a DS MSMQ server was found (i.e., actually validated).
   //
   BOOL          fServerFound ;

   //
   // Authentication service to use in rpc calls
   //
   ULONG         ulAuthnSvc ;

   //
   // Indicates whether the communications are done via local RPC.
   // This flag is TRUE when we comunicate from an application to the
   // DS while the application is running on the DS server it self.
   //
   BOOL          fLocalRpc;

   MQRPC_AUTHENTICATION_LEVEL  eAuthnLevel ;
}
ADSCLI_DSSERVERS, *LPADSCLI_DSSERVERS ;

typedef struct _ADSCLI_RPCBINDING
{
   handle_t                          hRpcBinding ;
   PCONTEXT_HANDLE_SERVER_AUTH_TYPE  hServerAuthContext ;
   SERVER_AUTH_STRUCT                ServerAuthClientContext ;
   HANDLE							 hThread;

   ADSCLI_DSSERVERS                  sDSServers ;
}
ADSCLI_RPCBINDING,  *LPADSCLI_RPCBINDING ;

/////////////////////////////////////////////
//
//  Global data
//
/////////////////////////////////////////////

//
// tls index for binding handle and server authentication context.
//
extern DWORD  g_hBindIndex ;

//
// Object which manage release of rpc binding handle and server
// authentication data.
//
class  CFreeRPCHandles ;
extern CFreeRPCHandles   g_CFreeRPCHandles ;

extern BOOL  g_fUseReduceSecurity ;

/////////////////////////////////////////////
//
//  Functions prototypes
//
/////////////////////////////////////////////

extern HRESULT   RpcClose() ;
extern void FreeBindingAndContext( LPADSCLI_RPCBINDING padsRpcBinding);

/////////////////////////////////////////////
//
//  Macros
//
/////////////////////////////////////////////

#define  DSCLI_API_PROLOG        \
    HRESULT hr = MQ_OK;          \
    HRESULT hr1 = MQ_OK;         \
    DWORD   dwCount = 0 ;        \
    BOOL    fReBind = TRUE ;

#define  DSCLI_ACQUIRE_RPC_HANDLE(fWithSSL)                \
   g_CFreeRPCHandles.FreeAll() ;                           \
   if (TLS_IS_EMPTY || (tls_hBindRpc == NULL))             \
{                                                          \
      HRESULT hrRpc = g_ChangeDsServer.FindServer(fWithSSL);  \
      if (hrRpc != MQ_OK)                                  \
      {                                                    \
         return hrRpc ;                                    \
      }                                                    \
}                                                          \

#define  DSCLI_RELEASE_RPC_HANDLE                              \
    ADSCLI_RPCBINDING * padsRpcBinding = tls_bind_data;        \
    ASSERT(padsRpcBinding != NULL);                            \
    ASSERT((padsRpcBinding->hRpcBinding != NULL) ||            \
           (hr == MQ_ERROR_NO_DS)) ;                           \
    FreeBindingAndContext( padsRpcBinding);



#define HANDLE_RPC_EXCEPTION(rpc_stat, hr)            \
        rpc_stat = RpcExceptionCode();                \
        if (FAILED(rpc_stat))                         \
        {                                             \
            hr = (HRESULT) rpc_stat ;                 \
        }                                             \
        else if ( rpc_stat == ERROR_INVALID_HANDLE)   \
        {                                             \
            hr =  STATUS_INVALID_HANDLE ;             \
        }                                             \
        else                                          \
        {                                             \
            hr = MQ_ERROR_NO_DS ;                     \
        }

//
//  This macro specify fWithoutSSL == FALSE!!
//  Therefore do not use in NT5 <--> NT5 interfaces that count
//  on kerberos authentication.
//
#define DSCLI_HANDLE_DS_ERROR(myhr, myhr1, mydwCount, myfReBind)           \
     if (myhr == MQ_ERROR_NO_DS)                                           \
{                                                                          \
        myhr1 =  g_ChangeDsServer.FindAnotherServer( &mydwCount, FALSE ) ; \
}                                                                          \
     else if (myhr == STATUS_INVALID_HANDLE)                               \
{                                                                          \
        if (myfReBind)                                                     \
{                                                                          \
           myhr1 = g_ChangeDsServer.FindServer( FALSE) ;                   \
           myfReBind = FALSE ;                                             \
}                                                                          \
     }



#define tls_bind_data  ((LPADSCLI_RPCBINDING) TlsGetValue(g_hBindIndex))

#define sizeof_tls_bind_data   (sizeof(MQISCLI_RPCBINDING))

#define TLS_IS_EMPTY           (tls_bind_data == NULL)

#define TLS_NOT_EMPTY          (tls_bind_data != NULL)

#define tls_hBindRpc           ((tls_bind_data)->hRpcBinding)

#define tls_hSrvrAuthnContext  ((tls_bind_data)->hServerAuthContext)

#define tls_hSvrAuthClientCtx  ((tls_bind_data)->ServerAuthClientContext)

#define SERVER_NOT_VALIDATED   (tls_hSrvrAuthnContext == NULL)

#define tls_hThread			   ((tls_bind_data)->hThread)

#endif // __RPCDSLCI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\coreglb.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    DSGlbObj.h

Abstract:

    Definition of Global Instances of the MQADS server.
    They are put in one place to ensure the order their constructors take place.

Author:

    ronit hartmann (ronith)

--*/
#ifndef __COREGLB_H__
#define __COREGLB_H__

#include "ds_stdh.h"
#include "mqads.h"
#include "dsads.h"
#include "siteinfo.h"
#include "siterout.h"
#include "ipsite.h"
#include "fornsite.h"

extern BOOL g_fSetupMode ;


// single global object providing ADSI access
extern P<CADSI> g_pDS;

// translation information of properties
extern CMap<PROPID, PROPID, const MQTranslateInfo*, const MQTranslateInfo*&> g_PropDictionary;
			
extern P<CSiteInformation>    g_pMySiteInformation;

// sites routing table
extern P<CSiteRoutingInformation> g_pSiteRoutingTable;

// IPAddress-to-site mapping
extern P<CIpSite> g_pcIpSite;

extern CMapForeignSites g_mapForeignSites;


//
//  Global DS pathnames
//
extern AP<WCHAR> g_pwcsServicesContainer;
extern AP<WCHAR> g_pwcsMsmqServiceContainer;
extern AP<WCHAR> g_pwcsDsRoot;
extern AP<WCHAR> g_pwcsSitesContainer;
extern AP<WCHAR> g_pwcsConfigurationContainer;
extern AP<WCHAR> g_pwcsLocalDsRoot;

//
//  The local server name
//
extern AP<WCHAR> g_pwcsServerName;
extern DWORD     g_dwServerNameLength;
extern GUID      g_guidThisServerQMId;

extern BOOL      g_fLocalServerIsGC ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\dijkstra.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dijkstra.cpp

Abstract:

    
Author:

    Lior Moshaiov (LiorM)

--*/
#include "ds_stdh.h"
#include "dijkstra.h"
#include "routtbl.h"

#include "dijkstra.tmh"

extern CCost    g_InfiniteCost;
static WCHAR *s_FN=L"mqdscore/dijkstra";

/*====================================================

Constructor

Arguments: 

Return Value:

=====================================================*/

void CDijkstraTree::SetRoot(IN const CSiteRoutingNode* pRoot)
{
    P<CNextHop> pNextHop = new CNextHop(pRoot);

    P<CSiteRoutingNode> pDupRoot = pRoot->Duplicate();

    m_list[pDupRoot] = pNextHop;

    //
    // Everything is O.K.
    // We don't want these pointers to be released
    //
    pNextHop.detach();
    pDupRoot.detach();
};

/*====================================================

GetCost

Arguments:

Return Value:

Thread Context: main

=====================================================*/
const CCost&    CDijkstraTree::GetCost(CSiteRoutingNode* pTarget) const
{
    CNextHop    *pNextHop;
    if (m_list.Lookup(pTarget,pNextHop))
    {
        return (pNextHop->GetCost());
    }
    else
    {
        return(g_InfiniteCost);
    }
}

            
/*====================================================

MoveMinimal

Arguments:

Return Value:

Thread Context: main

MoveMinimal moves the node with minimal cost from
*this to OtherTree.

=====================================================*/
void CDijkstraTree::MoveMinimal(IN OUT CDijkstraTree& OtherTree,
                                    OUT CSiteRoutingNode **ppMinNode,
                                    OUT CNextHop **ppMinNextHop,
                                    OUT BOOL *pfFound)
{
    POSITION        pos;
    CSiteRoutingNode    *pNode, *pMinNode;
    CNextHop        *pNextHop, *pMinNextHop;
    CCost           MinCost = g_InfiniteCost;
    
    *pfFound = FALSE;

    //
    // look for minimal node
    //
    pos = m_list.GetStartPosition();
    if (pos == NULL)
    {
        //
        // Tree is Empty
        //
        return;
    }
    
    pMinNode = NULL;
    pMinNextHop = NULL;
    do
    {
        m_list.GetNextAssoc(pos, pNode, pNextHop);
        if (pNextHop->GetCost() < MinCost)
        {
            *pfFound = TRUE;
            pMinNode = pNode;
            pMinNextHop = pNextHop;
            MinCost = pNextHop->GetCost();
        }
    } while(pos != NULL);

    //
    // move the minimal node to OtherTree
    //
    if (*pfFound)
    {
        P<CNextHop> pDupNextHop = pMinNextHop->Duplicate();
        P<CSiteRoutingNode> pDupNode = pMinNode->Duplicate();
        m_list.RemoveKey(pMinNode);

        OtherTree.m_list.SetAt(pDupNode,pDupNextHop);
        *ppMinNextHop = pDupNextHop.detach();
        *ppMinNode = pDupNode.detach();
    }
    
}

/*====================================================

Print

Arguments:

Return Value:

Thread Context: main

=====================================================*/
void    CDijkstraTree::Print(IN const CSiteDB* pRoutingDB) const
{
    POSITION    pos;
    CSiteRoutingNode    *pNode;
    CNextHop    *pNextHop;


    DBGMSG((DBGMOD_ROUTING,DBGLVL_INFO,TEXT("My Node is")));
    (pRoutingDB->GetMyNode())->Print();
    pos = m_list.GetStartPosition();
    if (pos == NULL)
    {
        DBGMSG((DBGMOD_ROUTING,DBGLVL_INFO,TEXT("Empty routing list")));
        return;
    }
    
    do
    {
        DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO,TEXT(" ")));
        m_list.GetNextAssoc(pos, pNode, pNextHop);
        pNode->Print();
        pNextHop->Print();
    } while(pos != NULL);

    return;
}

/*====================================================

UpdateRoutingTable

Arguments:

Return Value:

Thread Context: main

The result of the dijkstra algorythm is written into
the routing tables
=====================================================*/
HRESULT CDijkstraTree::UpdateRoutingTable(IN OUT CRoutingTable *pTbl) const
{
    POSITION    pos;
    CSiteRoutingNode    *pNode;
    CNextHop    *pNextHop;
    HRESULT hr=MQ_OK;



    //
    // Replace routing Table
    //
    pTbl->RemoveAll();

    pos = m_list.GetStartPosition();
    if (pos == NULL)
    {
        DBGMSG((DBGMOD_ALL,DBGLVL_ERROR,TEXT("Error, CT routing tree is empty")));
        return LogHR(MQ_ERROR, s_FN, 10);
    }
        

    P<CNextHop> pSavedNextHop=NULL; 

    //
    // Keep a copy in the routing table
    //
    do
    {
        m_list.GetNextAssoc(pos, pNode, pNextHop);

        pSavedNextHop = new CNextHop(pNextHop->GetNextNode(),pNextHop->GetCost(),pNextHop->GetSiteGate());

        pNode = pNode->Duplicate();

        pTbl->SetAt(pNode,pSavedNextHop);
        pSavedNextHop.detach();

    } while(pos != NULL);

    return LogHR(hr, s_FN, 20);
}

/*====================================================

Dijkstra

Arguments:

Return Value:

Thread Context: main

Dijkstra algorythm

=====================================================*/
HRESULT Dijkstra(IN CSiteDB* pRoutingDB,
                IN OUT CRoutingTable *pTbl)
{
    const CSiteRoutingNode* pMyNode = pRoutingDB->GetMyNode();
    CDijkstraTree   Path;
    CDijkstraTree   Tent;
    CSiteRoutingNode    *pNodeN,*pNodeM;
    const CSiteRoutingNode  *pDirN;
    CNextHop    *pNextHopN;
    CCost   CostM,CostN,CostN2M,AlternateCostM;
    CSiteGate SiteGateM,SiteGateN,SiteGateN2M;
    BOOL    flag;
    HRESULT hr=MQ_OK;
    POSITION    pos;


    Path.SetRoot(pMyNode);

    //
    // Move all my neighbors to Tent
    //
    pos = pRoutingDB->GetStartNeighborPosition(pMyNode);
    P<CNextHop> pNextHopM=NULL;
    while(pos != NULL)
    {
        pRoutingDB->GetNextNeighborAssoc(pos, pNodeM, CostM, SiteGateM);


        pNextHopM = new CNextHop(pNodeM,CostM,SiteGateM);

        Tent.Add(pNodeM,pNextHopM);
        pNextHopM.detach();

    }

    Tent.MoveMinimal(Path,&pNodeN,&pNextHopN,&flag);
    if (! flag)
    {
        DBGMSG((DBGMOD_ROUTING, DBGLVL_TRACE,TEXT("Spanning tree - only one (my) node")));
    }


    
    while (flag)
    {
        CostN = pNextHopN->GetCost();
        pDirN = pNextHopN->GetNextNode();
        SiteGateN = pNextHopN->GetSiteGate();

        //
        // We just added NodeN to Path.
        // Move to path all N neighbors (M) that N gives a better way to reach them
        //

        pos = pRoutingDB->GetStartNeighborPosition(pNodeN);
        while(pos != NULL)
        {
            pRoutingDB->GetNextNeighborAssoc(pos, pNodeM, CostN2M, SiteGateN2M);

            AlternateCostM = CostN + CostN2M;

            if (AlternateCostM < Path.GetCost(pNodeM)
                && AlternateCostM < Tent.GetCost(pNodeM))
            {
                pNextHopM = new CNextHop(pDirN,AlternateCostM,SiteGateN + SiteGateN2M );

                Tent.Add(pNodeM,pNextHopM);
                pNextHopM.detach();
            }
        }
    
        Tent.MoveMinimal(Path,&pNodeN,&pNextHopN,&flag);

    }

    Path.Print(pRoutingDB);
    
    hr = Path.UpdateRoutingTable(pTbl);

    return LogHR(hr, s_FN, 30);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\dsads.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
	dsads.h

Abstract:
	CADSI class - encapsulates work with ADSI

Author:
    AlexDad


--*/


#ifndef __DSADS_H__
#define __DSADS_H__

#include "ds_stdh.h"
#include "activeds.h"
#include "oledb.h"
#include "oledberr.h"
#include "mqads.h"
#include <mqsec.h>
#include "dsutils.h"
#include "dsreqinf.h"
#include <dscore.h>

//-----------------------------
//  Misc types
//-----------------------------

enum DS_PROVIDER {
        //
        //  For set, crate and delete operations of queue,user and machine
        //  objects.
        //  The operation will be performed by the owning DC.
        //
     eDomainController,
        //
        //  For locate operation of queue, user and machine objects.
        //  And when retrieving information of these objects after
        //  failing to find them in the local domain controller.
        //
     eGlobalCatalog,
        //
        //  For all access operation of objects that are in the
        //  configuration container.
        //
        //  And first trial to retrieve information of queue, user and
        //  machine objects.
        //
     eLocalDomainController,
        //
        //  For locate operation under a specific object in global
		//  catalog.
        //
	 eSpecificObjectInGlobalCatalog
};

enum DS_SEARCH_LEVEL {
    eOneLevel,
    eSubTree
};

enum DS_OPERATION {
    eCreate,
    eSet
};

struct _MultiplAppearance
{
public:
    inline _MultiplAppearance();
    DWORD dwIndex;
};

inline _MultiplAppearance::_MultiplAppearance():
           dwIndex(x_NoPropertyFirstAppearance)
{
}

//
// migration code added so many props to the properties arrays, after
// it find a GC for creation of migrated objects.
//
#define MIG_EXTRA_PROPS  3

//----------------------------------------
//  CADSI:: ADSI encapsulation class
//----------------------------------------

class CADSI
{
    friend
    HRESULT  DSCoreCheckIfGoodNtlmServer(
                                 IN DWORD             dwObjectType,
                                 IN LPCWSTR           pwcsPathName,
                                 IN const GUID       *pObjectGuid,
                                 IN DWORD             cProps,
                                 IN const PROPID     *pPropIDs,
                                 IN enum enumNtlmOp   eNtlmOp ) ;
public:
    CADSI();

    ~CADSI();


    // Define ansd start search
    HRESULT LocateBegin(
            IN  DS_SEARCH_LEVEL      SearchLevel,       // one level or subtree
            IN  DS_PROVIDER          Provider,          // local DC or GC
            IN  CDSRequestContext *  pRequestContext,
            IN  const GUID *         pguidUniqueId,     // unique id of object - search base
            IN  const MQRESTRICTION* pMQRestriction,    // search criteria
            IN  const MQSORTSET *    pDsSortkey,        // sort keys array
            IN  const DWORD          cp,                // size of pAttributeNames array
            IN  const PROPID *       pPropIDs,          // attributes to be obtained
            OUT HANDLE *             phResult);         // result handle

    // Search step
    HRESULT LocateNext(
            IN     HANDLE          hResult,         // result handle
            IN     CDSRequestContext *pRequestContext,
            IN OUT DWORD          *pcp,             // IN num of variants; OUT num of results
            OUT    MQPROPVARIANT  *pPropVars);      // MQPROPVARIANT array

    // Finish search
    HRESULT LocateEnd(
            IN HANDLE phResult);                    // result handle

    // Gets DS object properties
    HRESULT GetObjectProperties(
            IN  DS_PROVIDER     Provider,		    // local DC or GC
            IN  CDSRequestContext *pRequestContext,
 	        IN  LPCWSTR         lpwcsPathName,      // object name
            IN  const GUID *    pguidUniqueId,      // unique id of object
            IN  const DWORD     cp,                 // number of attributes to retreive
            IN  const PROPID *  pPropIDs,           // attributes to retreive
            OUT MQPROPVARIANT * pPropVars);         // output variant array

    // Sets DS object properties
    HRESULT SetObjectProperties(
            IN  DS_PROVIDER          provider,
            IN  CDSRequestContext *  pRequestContext,
            IN  LPCWSTR              lpwcsPathName,      // object name
            IN  const GUID *         pguidUniqueId,      // unique id of object
            IN  const DWORD          cp,                 // number of attributes to set
            IN  const PROPID *       pPropIDs,           // attributes to set
            IN  const MQPROPVARIANT *pPropVars,          // attribute values
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest); // optional request for object info

    // Creates new DS object and sets its initial properies
    HRESULT CreateObject(
            IN DS_PROVIDER          Provider,		    // local DC or GC
            IN  CDSRequestContext * pRequestContext,
            IN LPCWSTR              lpwcsObjectClass,   // object class
            IN LPCWSTR              lpwcsChildName,     // object name
            IN LPCWSTR              lpwcsParentPathName,// object parent name
            IN const DWORD          cp,                 // number of attributes
            IN const PROPID *       pPropIDs,          // attributes
            IN const MQPROPVARIANT * pPropVars,        // attribute values
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,     // optional request for object info
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest); // optional request for parent info

    // Deletes DS object
    HRESULT DeleteObject(
            IN DS_PROVIDER      Provider,		    // local DC or GC
            IN DS_CONTEXT       Context,
            IN CDSRequestContext * pRequestContext,
            IN LPCWSTR          lpwcsPathName,      // object name
            IN const GUID *     pguidUniqueId,      // unique id of object
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,     // optional request for object info
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest); // optional request for parent info

    HRESULT DeleteContainerObjects(
            IN DS_PROVIDER      provider,
            IN DS_CONTEXT       Context,
            IN CDSRequestContext * pRequestContext,
            IN LPCWSTR          lpwcsContainerName,
            IN const GUID *     pguidContainerId,
            IN LPCWSTR          pwcsObjectClass);

    HRESULT GetParentName(
            IN  DS_PROVIDER      Provider,		     // local DC or GC
            IN  DS_CONTEXT       Context,
            IN  CDSRequestContext * pRequestContext,
            IN  const GUID *     pguidUniqueId,      // unique id of object
            OUT LPWSTR *        ppwcsParentName
            );

    HRESULT GetParentName(
            IN  DS_PROVIDER     Provider,		    // local DC or GC
            IN  DS_CONTEXT      Context,
            IN  CDSRequestContext *pRequestContext,
            IN  LPCWSTR         pwcsChildName,      //
            OUT LPWSTR *        ppwcsParentName
            );

    HRESULT GetRootDsName(
            OUT LPWSTR *        ppwcsRootName,
            OUT LPWSTR *        ppwcsLocalRootName,
            OUT LPWSTR *        ppwcsSchemaNamingContext
            );

    void Terminate(void);

    HRESULT DoesObjectExists(
        IN  DS_PROVIDER     Provider,
        IN  DS_CONTEXT      Context,
        IN  CDSRequestContext *pRequestContext,
        IN  LPCWSTR         pwcsObjectName
        );
    HRESULT CreateOU(
            IN DS_PROVIDER          Provider,		    // local DC or GC
            IN CDSRequestContext *  pRequestContext,
            IN LPCWSTR              lpwcsChildName,     // object name
            IN LPCWSTR              lpwcsParentPathName,// object parent name
            IN LPCWSTR              lpwcsDescription
            );

    HRESULT InitBindHandles();

    HRESULT FindComputerObjectFullPath(
            IN  DS_PROVIDER             provider,
            IN  enumComputerObjType     eComputerObjType,
			IN  LPCWSTR                 pwcsComputerDnsName,
            IN  const MQRESTRICTION *   pRestriction,
            OUT LPWSTR *                ppwcsFullPathName
            );

protected:
    // Binds to the DS object
    HRESULT BindToObject(
            IN DS_PROVIDER         Provider,		// local DC or GC
            IN DS_CONTEXT          Context,         // DS context
            IN CDSRequestContext * pRequestContext,
            IN LPCWSTR             lpwcsPathName,   // object name
            IN const GUID *        pguidObjectId,
            IN REFIID              riid,            // requested interface
            OUT VOID             *ppIUnk,            // Interface
            OUT CImpersonate **    ppImpersonate);

    HRESULT BindToGUID(
            IN DS_PROVIDER         Provider,		// local DC or GC
            IN DS_CONTEXT          Context,         // DS context
            IN CDSRequestContext * pRequestContext,
            IN const GUID *        pguidObjectId,
            IN REFIID              riid,            // requested interface
            OUT VOID             *ppIUnk,            // Interface
            OUT CImpersonate **    ppImpersonate);

    HRESULT BindToGuidNotInLocalDC(
            IN DS_PROVIDER         Provider,		// local DC or GC
            IN DS_CONTEXT          Context,         // DS context
            IN CDSRequestContext * pRequestContext,
            IN const GUID *        pguidObjectId,
            IN REFIID              riid,            // requested interface
            OUT VOID             *ppIUnk,            // Interface
            OUT CImpersonate **    ppImpersonate);

    HRESULT BindForSearch(
            IN DS_PROVIDER         Provider,		// local DC or GC
            IN DS_CONTEXT          Context,         // DS context
            IN CDSRequestContext * pRequestContext,
            IN const GUID *        pguidObjectId,
            IN BOOL                fSorting,
            OUT VOID *             ppIUnk,            // Interface
            OUT CImpersonate **    ppImpersonate);

    HRESULT FindObjectFullNameFromGuid(
        IN  DS_PROVIDER      Provider,		// local DC or GC
        IN  DS_CONTEXT       Context,       // DS context
        IN  const GUID *     pguidObjectId,
        IN  BOOL             fTryGCToo,
        OUT WCHAR **         pwcsFullName,
        OUT DS_PROVIDER *    pFoundObjectProvider
        );


private:

    // Get object security descriptor from DS
    HRESULT CADSI::GetObjSecurityFromDS(
        IN  IADs                 *pIADs,          // object's IADs pointer
        IN  BSTR                  bs,             // property name
        IN  const PROPID          propid,         // property ID
        IN  SECURITY_INFORMATION  seInfo,         // security information
        OUT MQPROPVARIANT        *pPropVar);      // attribute values

    BOOL    CADSI::NeedToConvertSecurityDesc( PROPID propID ) ;

    // Get object security descriptor.
    HRESULT CADSI::GetObjectSecurity(
        IN  IADs            *pIADs,                  // object's pointer
        IN  DWORD            cPropIDs,               // number of attributes
        IN  const PROPID    *pPropIDs,               // name of attributes
        IN  DWORD            dwProp,                 // index to sec property
        IN  BSTR             bsName,                 // name of property
        IN  DWORD            dwObjectType,           // object type
        OUT MQPROPVARIANT   *pPropVars ) ;           // attribute values

    // Set object properties directly (no cache)
    HRESULT CADSI::SetDirObjectProps(
        IN DS_OPERATION          operation,              // type of DS operation performed
        IN IADs *                pIADs,                  // object's pointer
        IN const DWORD           cPropIDs,               // number of attributes
        IN const PROPID *        pPropIDs,               // name of attributes
        IN const MQPROPVARIANT * pPropVars,              // attribute values
        IN const DWORD           dwObjectType,           // MSMQ1.0 obj type
        IN       BOOL            fUnknownUser = FALSE ) ;

    // Set single object property directly (no cache)
    HRESULT CADSI::SetObjectSecurity(
        IN  IADs                *pIADs,                 // object's IADs pointer
        IN  const BSTR           bs,                    // property name
        IN  const MQPROPVARIANT *pMqVar,                // value in MQ PROPVAL format
        ADSTYPE                  adstype,               // required NTDS type
        IN const DWORD           dwObjectType,          // MSMQ1.0 obj type
        IN  SECURITY_INFORMATION seInfo,                // security information
        IN  PSID                 pComputerSid ) ;       // SID of computer object.

    // Get object properties using cache
    HRESULT GetObjectPropsCached(
        IN  IADs            *pIADs,                  // object's pointer
        IN  DWORD            cp,                     // number of attributes
        IN  const PROPID    *pPropIDs,               // name of attributes
        IN  CDSRequestContext * pRequestContext,
        OUT MQPROPVARIANT   *pPropVars);             // attribute values

    // Set object properties via cache
    HRESULT SetObjectPropsCached(
        IN DS_OPERATION    operation,               // type of DS operation performed
        IN IADs            *pIADs,                  // object's pointer
        IN DWORD            cp,                     // number of attributes
        IN const PROPID    *pPropID,                // name of attributes
        IN const MQPROPVARIANT   *pPropVar);              // attribute values

    // Translate MQ Restriction into ADSI Filter
    HRESULT MQRestriction2AdsiFilter(
        IN  const MQRESTRICTION * pMQRestriction,
        IN  LPCWSTR               pwcsObjectCategory,
        IN  LPCWSTR               pwszObjectClass,
        OUT LPWSTR   *            ppwszSearchFilter
        );


    // Translate MQPropVal into ADSI value
    HRESULT MqPropVal2AdsiVal(OUT ADSTYPE       *pAdsType,
                              OUT DWORD         *pdwNumValues,
                              OUT PADSVALUE     *ppADsValue,
                              IN  PROPID         propID,
                              IN  const MQPROPVARIANT *pPropVar,
                              IN  PVOID          pvMainAlloc);

    // Translate ADSI value into MQ PropVal
    HRESULT AdsiVal2MqPropVal(OUT MQPROPVARIANT *pPropVar,
                              IN  PROPID        propID,
                              IN  ADSTYPE       AdsType,
                              IN  DWORD         dwNumValues,
                              IN  PADSVALUE     pADsValue);

    // Translate array of property names
    HRESULT FillAttrNames(
            OUT LPWSTR    *          ppwszAttributeNames,  // Names array
            OUT DWORD *              pcRequestedFromDS,    // Number of attributes to pass to DS
            IN  DWORD                cPropIDs,             // Number of Attributes to translate
            IN  const PROPID    *    pPropIDs);            // Attributes to translate


    // Set search preferences
    HRESULT FillSearchPrefs(
            OUT ADS_SEARCHPREF_INFO *pPrefs,        // preferences array
            OUT DWORD               *pdw,           // preferences counter
            IN  DS_SEARCH_LEVEL      SearchLevel,	// flat / 1 level / subtree
            IN  const MQSORTSET *    pDsSortkey,    // sort keys array
            OUT      ADS_SORTKEY *  pSortKeys);		// sort keys array in ADSI  format

    HRESULT CopyDefaultValue(
           IN const MQPROPVARIANT *   pvarDefaultValue,
           OUT MQPROPVARIANT *        pvar
           );

    BOOL CompareDefaultValue(
           IN const ULONG           rel,
           IN const MQPROPVARIANT * pvarUser,
           IN const MQPROPVARIANT * pvarDefaultValue
           );

    HRESULT DecideObjectClass(
            IN  const PROPID *  pPropid,
            OUT const MQClassInfo **  ppClassInfo
            );

    HRESULT LocateObjectFullName(
            IN DS_PROVIDER       Provider,		// local DC or GC
            IN DS_CONTEXT        Context,         // DS context
            IN  const GUID *     pguidObjectId,
            OUT WCHAR **         ppwcsFullName
            );

    HRESULT BindRootOfForest(
            OUT void           *ppIUnk);

    HRESULT GetParentInfo(
                       IN LPWSTR                       pwcsFullParentPath,
                       IN CDSRequestContext           *pRequestContext,
                       IN IADsContainer               *pContainer,
                       IN OUT MQDS_OBJ_INFO_REQUEST   *pParentInfoRequest,
                       IN P<CImpersonate>&             pImpersonation
                       );

	HRESULT CreateIDirectoryObject(
            IN LPCWSTR				pwcsObjectClass,	
            IN IDirectoryObject *	pDirObj,
			IN LPCWSTR				pwcsFullChildPath,
            IN const DWORD			cPropIDs,
            IN const PROPID *		pPropIDs,
            IN const MQPROPVARIANT * pPropVar,
			IN const DWORD			dwObjectType,
            OUT IDispatch **		pDisp
			);

    CCoInit             m_cCoInit;
    R<IDirectorySearch> m_pSearchLocalDomainController;
    R<IDirectorySearch> m_pSearchConfigurationContainerLocalDC;
    R<IDirectorySearch> m_pSearchSitesContainerLocalDC;
    R<IDirectorySearch> m_pSearchMsmqServiceContainerLocalDC;
    R<IDirectorySearch> m_pSearchGlobalCatalogRoot;
    R<IDirectorySearch> m_pSearchPathNameLocalDC;
    R<IDirectorySearch> m_pSearchRealPathNameGC;
    R<IDirectorySearch> m_pSearchMsmqPathNameGC;
};


inline void CADSI::Terminate(void)
{
}

//+------------------------------------------------------------------
//
// Error logging....
//
//+------------------------------------------------------------------

#ifdef _DEBUG

#define LOG_ADSI_ERROR(hr)                                  \
{                                                           \
    if (FAILED(hr))                                         \
    {                                                       \
        WCHAR  wszError[ 256 ] ;                            \
        WCHAR  wszProvider[ 256 ] ;                         \
        DWORD  dwErr ;                                      \
                                                            \
        HRESULT hrTmp = ADsGetLastError( &dwErr,            \
                                          wszError,         \
                                          255,              \
                                          wszProvider,      \
                                          255 ) ;           \
        UNREFERENCED_PARAMETER(hrTmp);							        \
    }                                                       \
}

#else

#define LOG_ADSI_ERROR(hr)

#endif

#endif //  __DSADS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\dsadssec.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dsads.cpp

Abstract:

    Implementation of CADSI class, encapsulating work with ADSI.

Author:

    Alexander Dadiomov (AlexDad)

--*/

#include "ds_stdh.h"
#include "adstempl.h"
#include "dsutils.h"
#include "_dsads.h"
#include "dsads.h"
#include "utils.h"
#include "mqads.h"
#include "coreglb.h"
#include "mqadsp.h"
#include "mqattrib.h"
#include "_propvar.h"
#include "mqdsname.h"
#include "dsmixmd.h"
#include <winldap.h>
#include <aclapi.h>
#include <autoreln.h>
#include "..\..\mqsec\inc\permit.h"

#include "dsadssec.tmh"

static WCHAR *s_FN=L"mqdscore/dsadssec";

//+-----------------------------------------------------------------------
//
//    CADSI::GetObjSecurityFromDS()
//
//  Use IDirectoryObject to retrieve security descriptor from ADS.
//  Only this interface return it in the good old SECURITY_DESCRIPTOR
//  format.
//
//+-----------------------------------------------------------------------

HRESULT CADSI::GetObjSecurityFromDS(
        IN  IADs                 *pIADs,        // object's IADs pointer
		IN  BSTR        	      bs,		    // property name
		IN  const PROPID	      propid,	    // property ID
        IN  SECURITY_INFORMATION  seInfo,       // security information
        OUT MQPROPVARIANT        *pPropVar )     // attribute values
{
    ASSERT(seInfo != 0) ;

    HRESULT  hr;
    R<IDirectoryObject> pDirObj = NULL;
    R<IADsObjectOptions> pObjOptions = NULL ;

	// Get IDirectoryObject interface pointer
    hr = pIADs->QueryInterface (IID_IDirectoryObject,(LPVOID *) &pDirObj);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100);
    }

	//
    // Get IADsObjectOptions interface pointer and
    // set ObjectOption, specifying the SECURITY_INFORMATION we want to get.
    //
    hr = pDirObj->QueryInterface (IID_IADsObjectOptions,(LPVOID *) &pObjOptions);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 110);
    }

    VARIANT var ;
    var.vt = VT_I4 ;
    var.ulVal = (ULONG) seInfo ;

    hr = pObjOptions->SetOption( ADS_OPTION_SECURITY_MASK, var ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 120);
    }

    // Get properties
	PADS_ATTR_INFO pAttr;
	DWORD  cp2;

    hr = pDirObj->GetObjectAttributes(
                    &bs,
                    1,
                    &pAttr,
                    &cp2);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 130);
    }
	ADsFreeAttr pClean( pAttr);

    if (1 != cp2)
    {
        return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 10);
    }

    // Translate property values to MQProps
    hr = AdsiVal2MqPropVal(pPropVar,
                           propid,
                           pAttr->dwADsType,
                           pAttr->dwNumValues,
                           pAttr->pADsValues);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 140);
    }

    return MQ_OK;
}

//+-------------------------------------------------
//
//  BOOL  CADSI::NeedToConvertSecurityDesc()
//
//+-------------------------------------------------

BOOL  CADSI::NeedToConvertSecurityDesc( PROPID propID )
{
    if (propID == PROPID_Q_OBJ_SECURITY)
    {
        return FALSE ;
    }
    else if (propID == PROPID_QM_OBJ_SECURITY)
    {
        return FALSE ;
    }

    return TRUE ;
}

//+-------------------------------------------
//
//  HRESULT CADSI::GetObjectSecurity()
//
//+-------------------------------------------

HRESULT CADSI::GetObjectSecurity(
        IN  IADs            *pIADs,           // object's pointer
        IN  DWORD            cPropIDs,        // number of attributes
        IN  const PROPID    *pPropIDs,        // name of attributes
        IN  DWORD            dwProp,          // index to sec property
        IN  BSTR             bsName,          // name of property
        IN  DWORD            dwObjectType,    // object type
        OUT MQPROPVARIANT   *pPropVars )      // attribute values
{
    BOOL fSACLRequested = FALSE ;
    SECURITY_INFORMATION seInfo = MQSEC_SD_ALL_INFO ;

    if ((cPropIDs == 2) && (dwProp == 0))
    {
        if ((pPropIDs[1] == PROPID_Q_SECURITY_INFORMATION) ||
            (pPropIDs[1] == PROPID_QM_SECURITY_INFORMATION))
        {
            //
            // This property is created internally when calling
            // MQSetQeueueSecurity or when calling other functions
            // and explicitely passing the SECURITY_INFORMATION
            // word. So we query whatever the caller asked for, and
            // don't downgrade the query if access is denied.
            //
            seInfo = pPropVars[1].ulVal ;
            fSACLRequested = TRUE ;
        }
    }

    MQPROPVARIANT *pVarSec =  (pPropVars + dwProp) ;
    HRESULT hr = GetObjSecurityFromDS( pIADs,
                                       bsName,
                                       pPropIDs[dwProp],
                                       seInfo,
                                       pVarSec ) ;
    if (hr == MQ_ERROR_ACCESS_DENIED)
    {
        if (!fSACLRequested)
        {
            //
            // Try again, without SACL.
            // SACL was not explicitely requested by caller.
            //
            seInfo = seInfo & (~SACL_SECURITY_INFORMATION) ;
            hr = GetObjSecurityFromDS( pIADs,
                                       bsName,
                                       pPropIDs[dwProp],
                                       seInfo,
                                       pVarSec ) ;
        }
    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 150);
    }

    if (NeedToConvertSecurityDesc(pPropIDs[ dwProp ]))
    {
        DWORD dwConvertType = dwObjectType ;
        //
        // See if it's a foreign site. In that case, change object type
        // to CN.
        //
        if (dwObjectType == MQDS_SITE)
        {
            for ( DWORD j = 0 ; j < cPropIDs ; j++ )
            {
                if ((pPropIDs[j] == PROPID_S_FOREIGN) &&
                    (pPropVars[j].bVal == 1))
                {
                    ASSERT(pPropVars[j].vt == VT_UI1) ;
                    dwConvertType = MQDS_CN ;
                    break ;
                }
            }
        }

        //
        // Translate security descriptor into NT4 format.
        //
        DWORD dwSD4Len = 0 ;
        SECURITY_DESCRIPTOR *pSD4 ;
        hr = MQSec_ConvertSDToNT4Format(
                      dwConvertType,
                     (SECURITY_DESCRIPTOR*) pVarSec->blob.pBlobData,
                      &dwSD4Len,
                      &pSD4,
                      seInfo ) ;
        ASSERT(SUCCEEDED(hr)) ;

        if (SUCCEEDED(hr) && (hr != MQSec_I_SD_CONV_NOT_NEEDED))
        {
            delete [] pVarSec->blob.pBlobData;
            pVarSec->blob.pBlobData = (BYTE*) pSD4 ;
            pVarSec->blob.cbSize = dwSD4Len ;
            pSD4 = NULL ;
        }
        else
        {
            ASSERT(pSD4 == NULL) ;
        }
    }

    return LogHR(hr, s_FN, 20);
}

/*====================================================
    CADSI::SetObjectSecurity()
    Gets single property via IDirectoryObject
=====================================================*/
//
//BUGBUG: Need to add logic of translation routine
//          And fix logic of returning props
//
HRESULT CADSI::SetObjectSecurity(
        IN  IADs                *pIADs,             // object's IADs pointer
		IN  const BSTR			 bs,			 	// property name
        IN  const MQPROPVARIANT *pMqVar,		 	// value in MQ PROPVAL format
        IN  ADSTYPE              adstype,		 	// required NTDS type
        IN  const DWORD          dwObjectType,      // MSMQ1.0 obj type
        IN  SECURITY_INFORMATION seInfo,            // security information
        IN  PSID                 pComputerSid )     // SID of computer object.
{
    HRESULT  hr;
    R<IDirectoryObject> pDirObj = NULL;
    R<IADsObjectOptions> pObjOptions = NULL ;

	ASSERT(wcscmp(bs, L"nTSecurityDescriptor") == 0);
	ASSERT(adstype == ADSTYPE_NT_SECURITY_DESCRIPTOR);
    ASSERT(seInfo != 0) ;

	// Get IDirectoryObject interface pointer
    hr = pIADs->QueryInterface (IID_IDirectoryObject,(LPVOID *) &pDirObj);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }

	//
    // Get IADsObjectOptions interface pointer and
    // set ObjectOption, specifying the SECURITY_INFORMATION we want to set.
    //
    hr = pDirObj->QueryInterface (IID_IADsObjectOptions,(LPVOID *) &pObjOptions);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 170);
    }

    VARIANT var ;
    var.vt = VT_I4 ;
    var.ulVal = (ULONG) seInfo ;

    hr = pObjOptions->SetOption( ADS_OPTION_SECURITY_MASK, var ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 180);
    }

    //
    // Convert security descriptor to NT5 format.
    //
    BYTE   *pBlob = pMqVar->blob.pBlobData;
    DWORD   dwSize = pMqVar->blob.cbSize;

#if 0
    //
    // for future checkin of replication service cross domains.
    //
    PSID  pLocalReplSid = NULL ;
    if ((dwObjectType == MQDS_QUEUE) || (dwObjectType == MQDS_MACHINE))
    {
        hr = GetMyComputerSid( FALSE, //   fQueryADS
                               (BYTE **) &pLocalReplSid ) ;
        //
        // Ignore return value.
        //
        if (FAILED(hr))
        {
            ASSERT(0) ;
            pLocalReplSid = NULL ;
        }
    }
#endif

    P<BYTE>  pSD = NULL ;
    DWORD    dwSDSize = 0 ;
    hr = MQSec_ConvertSDToNT5Format( dwObjectType,
                                     (SECURITY_DESCRIPTOR*) pBlob,
                                     &dwSDSize,
                                     (SECURITY_DESCRIPTOR **) &pSD,
                                     e_DoNotChangeDaclDefault,
                                     pComputerSid /*,
                                     pLocalReplSid*/ ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }
    else if (hr != MQSec_I_SD_CONV_NOT_NEEDED)
    {
        pBlob = pSD ;
        dwSize = dwSDSize ;
    }
    else
    {
        ASSERT(pSD == NULL) ;
    }

    // Set properties
	ADSVALUE adsval;
	adsval.dwType   = ADSTYPE_NT_SECURITY_DESCRIPTOR;
	adsval.SecurityDescriptor.dwLength = dwSize ;
    adsval.SecurityDescriptor.lpValue  = pBlob ;

    ADS_ATTR_INFO AttrInfo;
	DWORD  dwNumAttributesModified = 0;

    AttrInfo.pszAttrName   = bs;
    AttrInfo.dwControlCode = ADS_ATTR_UPDATE;
    AttrInfo.dwADsType     = adstype;
    AttrInfo.pADsValues    = &adsval;
    AttrInfo.dwNumValues   = 1;

    hr = pDirObj->SetObjectAttributes(
                    &AttrInfo,
					1,
					&dwNumAttributesModified);
    LOG_ADSI_ERROR(hr) ;

    if (1 != dwNumAttributesModified)
    {
        hr = MQ_ERROR_ACCESS_DENIED;
    }

    return LogHR(hr, s_FN, 40);
}

//+------------------------------------------------------------------------
//
// DWORD _IsServerIndeedGC()
//
//  double check if we're indeed a GC. Each api return a different answer.
//  So if two answer are not the same, we'll log a warning event.
//  the main check if done by binding to local LDAP server thouth the
//  GC port. If this succeed, then double check using DsGetDcName().
//  Look weird ? it is !!!
//
//+------------------------------------------------------------------------

#include <dsgetdc.h>
#include <lm.h>
#include <lmapibuf.h>
#include <winsock.h>

static DWORD _IsServerIndeedGC()
{
    WSADATA WSAData;
    DWORD rc = WSAStartup(MAKEWORD(1,1), &WSAData);
    if (rc != 0)
    {
       printf("cannot WSAStartUp %lut\n",rc);
       return LogNTStatus(rc, s_FN, 50);
    }

    WCHAR  wszHostName[256];
    char szHostName[256];
    DWORD dwSize = sizeof(szHostName);

    rc = gethostname(szHostName, dwSize);
    WSACleanup();

    if (rc == 0)
    {
        mbstowcs(wszHostName, szHostName, 256);
    }
    else
    {
        LogNTStatus(WSAGetLastError(), s_FN, 60);
        return rc ;
    }

    ULONG ulFlags =  DS_FORCE_REDISCOVERY           |
                     DS_DIRECTORY_SERVICE_REQUIRED  |
                     DS_GC_SERVER_REQUIRED ;

    PDOMAIN_CONTROLLER_INFO DomainControllerInfo;

    rc = DsGetDcName( 
			NULL,
			NULL,    //LPCTSTR DomainName,
			NULL,    //GUID *DomainGuid,
			NULL,    //LPCTSTR SiteName,
			ulFlags,
			&DomainControllerInfo 
			);

    if (rc == NO_ERROR)
    {
        P<WCHAR> pwszComposedName = new WCHAR[wcslen(wszHostName) + 10];
        wcscpy(pwszComposedName, L"\\\\");
        wcscat(pwszComposedName, wszHostName);

        int len = wcslen(pwszComposedName);
        rc = _wcsnicmp( 
				pwszComposedName,
				DomainControllerInfo->DomainControllerName,
				len 
				);

        NetApiBufferFree(DomainControllerInfo);
    }

    return LogNTStatus(rc, s_FN, 70);
}


static bool IsServerGC(LPCWSTR pwszServerName)
/*++

Routine Description:
	Check that the server is GC

Arguments:
	pwszServerName - Server Name

Return Value:
	true if server is GC, false otherwise 
--*/
{
	LDAP* pLdap = ldap_init(
						const_cast<LPWSTR>(pwszServerName), 
						LDAP_GC_PORT
						);

	if(pLdap == NULL)
	{
		return false;
	}

    ULONG LdapError = ldap_set_option( 
							pLdap,
							LDAP_OPT_AREC_EXCLUSIVE,
							LDAP_OPT_ON  
							);

	if (LdapError != LDAP_SUCCESS)
    {
		return false;
    }

	LdapError = ldap_connect(pLdap, 0);
	if (LdapError != LDAP_SUCCESS)
    {
		return false;
    }

    ldap_unbind(pLdap);
	return true;
}

//+-------------------------------
//
//  BOOL DSCoreIsServerGC()
//
//+-------------------------------

const WCHAR * GetLocalServerName();

BOOL  DSCoreIsServerGC()
{
    static BOOL  s_fInitialized = FALSE;
    static BOOL  fIsGC = FALSE;

    if (!s_fInitialized)
    {
        LPCWSTR pwszMyServerName =  GetLocalServerName(); // from mqdscore.lib

        if (!pwszMyServerName)
        {
            ASSERT(pwszMyServerName);
            return FALSE ;
        }

        if (IsServerGC(pwszMyServerName))
        {
            //
            // We opened connection with local GC. So we're a GC :=)
            //
            fIsGC = TRUE ;

            //
            // double check that we're indeed GC. If this fail, then
            // only log an event.
            //
            DWORD dwGC = _IsServerIndeedGC();
            if (dwGC != 0)
            {
                //
                // Are we a GC ??? not sure.
                //
                REPORT_CATEGORY(NOT_SURE_I_AM_A_GC, CATEGORY_MQDS);
            }
        }

        s_fInitialized = TRUE;
    }

    return fIsGC;
}

//+--------------------------------------------------------------
//
//  HRESULT DSCoreSetOwnerPermission()
//
//+--------------------------------------------------------------

HRESULT 
DSCoreSetOwnerPermission( 
		WCHAR *pwszPath,
		DWORD  dwPermissions 
		)
{
    PSECURITY_DESCRIPTOR pSD = NULL;
    SECURITY_INFORMATION  SeInfo = OWNER_SECURITY_INFORMATION |
                                   DACL_SECURITY_INFORMATION;
    PACL pDacl = NULL;
    PSID pOwnerSid = NULL;

    //
    // Obtain owner and present DACL.
    //
    DWORD dwErr = GetNamedSecurityInfo( 
						pwszPath,
						SE_DS_OBJECT_ALL,
						SeInfo,
						&pOwnerSid,
						NULL,
						&pDacl,
						NULL,
						&pSD 
						);
    CAutoLocalFreePtr pFreeSD = (BYTE*) pSD;
    if (dwErr != ERROR_SUCCESS)
    {
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
              "DSCoreSetOwnerPermission(): fail to GetNamed(%ls), %lut"),
                                                     pwszPath, dwErr));

        return LogHR(HRESULT_FROM_WIN32(dwErr), s_FN, 80);
    }

    ASSERT(pSD && IsValidSecurityDescriptor(pSD));
    ASSERT(pOwnerSid && IsValidSid(pOwnerSid));
    ASSERT(pDacl && IsValidAcl(pDacl));

    //
    // Create ace for the owner, granting him the permissions.
    //
    EXPLICIT_ACCESS expAcss;
    memset(&expAcss, 0, sizeof(expAcss));

    expAcss.grfAccessPermissions =  dwPermissions;
    expAcss.grfAccessMode = GRANT_ACCESS;

    expAcss.Trustee.pMultipleTrustee = NULL;
    expAcss.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    expAcss.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    expAcss.Trustee.TrusteeType = TRUSTEE_IS_USER;
    expAcss.Trustee.ptstrName = (WCHAR*) pOwnerSid;

    //
    // Obtai new DACL, that merge present one with new ace.
    //
    PACL  pNewDacl = NULL;
    dwErr = SetEntriesInAcl( 
				1,
				&expAcss,
				pDacl,
				&pNewDacl 
				);

    CAutoLocalFreePtr pFreeDacl = (BYTE*) pNewDacl;
    LogNTStatus(dwErr, s_FN, 1639);

    if (dwErr == ERROR_SUCCESS)
    {
        ASSERT(pNewDacl && IsValidAcl(pNewDacl));
        SeInfo = DACL_SECURITY_INFORMATION ;

        //
        // Change security descriptor of object.
        //
        dwErr = SetNamedSecurityInfo( 
					pwszPath,
					SE_DS_OBJECT_ALL,
					SeInfo,
					NULL,
					NULL,
					pNewDacl,
					NULL 
					);
        LogNTStatus(dwErr, s_FN, 1638);
        if (dwErr != ERROR_SUCCESS)
        {
            DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
              "DSCoreSetOwnerPermission(): fail to SetNamed(%ls), %lut"),
                                                     pwszPath, dwErr));
        }
    }
    else
    {
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
              "DSCoreSetOwnerPermissions(): fail to SetEmtries(), %lut"),
                                                               dwErr));
    }

    return LogHR(HRESULT_FROM_WIN32(dwErr), s_FN, 90);
}

//+-----------------------------------------
//
//  HRESULT _UpgradeSettingSecurity()
//
//+-----------------------------------------

static  
HRESULT 
_UpgradeSettingSecurity( 
	WCHAR *pSettingName,
	PSID   pCallerSid 
	)
{
    PSECURITY_DESCRIPTOR pSD = NULL;
    CAutoLocalFreePtr pAutoRelSD = NULL;
    SECURITY_INFORMATION  SeInfo = DACL_SECURITY_INFORMATION;
    PACL pDacl = NULL;

    DWORD dwErr = GetNamedSecurityInfo( 
						pSettingName,
						SE_DS_OBJECT_ALL,
						SeInfo,
						NULL,
						NULL,
						&pDacl,
						NULL,
						&pSD
						);
    if (dwErr != ERROR_SUCCESS)
    {
        ASSERT(!pSD);
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
             "DSCore: _UpgradeSetting(), fail to GetNamed(%ls), %lut"),
                                                  pSettingName, dwErr));

        return LogHR(HRESULT_FROM_WIN32(dwErr), s_FN, 2200);
    }
    pAutoRelSD = (BYTE*) pSD;

    ASSERT(pSD && IsValidSecurityDescriptor(pSD));
    ASSERT(pDacl && IsValidAcl(pDacl));

    EXPLICIT_ACCESS expAcss;
    memset(&expAcss, 0, sizeof(expAcss));

    expAcss.grfAccessPermissions =  RIGHT_DS_READ_PROPERTY  |
                                    RIGHT_DS_WRITE_PROPERTY;
    expAcss.grfAccessMode = GRANT_ACCESS;

    expAcss.Trustee.pMultipleTrustee = NULL;
    expAcss.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    expAcss.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    expAcss.Trustee.TrusteeType = TRUSTEE_IS_USER;
    expAcss.Trustee.ptstrName = (WCHAR*) pCallerSid;

    CAutoLocalFreePtr pAutoRelDacl = NULL;
    PACL  pNewDacl = NULL;

    dwErr = SetEntriesInAcl( 
				1,
				&expAcss,
				pDacl,
				&pNewDacl 
				);

    LogNTStatus(dwErr, s_FN, 2210);
    if (dwErr == ERROR_SUCCESS)
    {
        pAutoRelDacl = (BYTE*) pNewDacl;
        ASSERT(pNewDacl && IsValidAcl(pNewDacl));

        dwErr = SetNamedSecurityInfo( 
					pSettingName,
					SE_DS_OBJECT_ALL,
					SeInfo,
					NULL,
					NULL,
					pNewDacl,
					NULL 
					);
        if (dwErr != ERROR_SUCCESS)
        {
            DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
              "DScore: _UpgradeSetting(), fail to SetNamed(%ls), %lut"),
                                                   pSettingName, dwErr));
            return LogNTStatus(dwErr, s_FN, 2220);
        }
    }
    else
    {
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
          "DSCore: _UpgtradeSetting(), fail to SetEntries(), %lut"), dwErr));
    }

    return LogHR(HRESULT_FROM_WIN32(dwErr), s_FN, 2230);
}

//+-----------------------------------------
//
//  HRESULT DSCoreUpdateSettingDacl()
//
//+-----------------------------------------

HRESULT 
DSCoreUpdateSettingDacl( 
	GUID  *pQmGuid,
	PSID   pSid 
	)
{
    //
    //  Find the distinguished name of the msmq-setting
    //
    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;
    propRestriction.prop = PROPID_SET_QM_ID;
    propRestriction.prval.vt = VT_CLSID;
    propRestriction.prval.puuid = const_cast<GUID*>(pQmGuid);

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;

    PROPID prop = PROPID_SET_FULL_PATH;

    CDsQueryHandle hQuery;
    CDSRequestContext requestDsServerInternal(e_DoNotImpersonate, e_IP_PROTOCOL);
    HRESULT hr = g_pDS->LocateBegin(
							eSubTree,	
							eLocalDomainController,	
							&requestDsServerInternal,
							NULL,
							&restriction,
							NULL,
							1,
							&prop,
							hQuery.GetPtr()
							);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS, DBGLVL_WARNING, TEXT(
            "DSCoreUpdateSettingDacl(): Locate begin failed %lx"),hr));
        return LogHR(hr, s_FN, 610);
    }

    DWORD cp = 1;
    MQPROPVARIANT var;
	HRESULT hr1 = hr;

    while (SUCCEEDED(hr))
	{
		var.vt = VT_NULL;

		hr  = g_pDS->LocateNext(
						hQuery.GetHandle(),
						&requestDsServerInternal,
						&cp,
						&var 
						);
		if (FAILED(hr))
		{
			DBGMSG((DBGMOD_DS, DBGLVL_WARNING, TEXT(
                "DSCOreUpdateSettingDacl(): Locate next failed %lx"),hr));
            return LogHR(hr, s_FN, 620);
		}
		if ( cp == 0)
		{
			return(MQ_OK);
		}

		AP<WCHAR> pClean = var.pwszVal;

        hr1 = _UpgradeSettingSecurity(
					pClean,
					pSid 
					);
	}

    return LogHR(hr1, s_FN, 630);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\dsads.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dsads.cpp

Abstract:

    Implementation of CADSI class, encapsulating work with ADSI.

Author:

    Alexander Dadiomov (AlexDad)

--*/

#include "ds_stdh.h"
#include "adstempl.h"
#include "dsutils.h"
#include "_dsads.h"
#include "dsads.h"
#include "utils.h"
#include "mqads.h"
#include "coreglb.h"
#include "mqadsp.h"
#include "mqattrib.h"
#include "_propvar.h"
#include "mqdsname.h"
#include "dsmixmd.h"

#include "dsads.tmh"

static WCHAR *s_FN=L"mqdscore/dsads";

#ifdef _DEBUG
extern "C"
{
__declspec(dllimport)
ULONG __cdecl LdapGetLastError( VOID );
}
#endif

//
// this is not checked yet becasue currently we do not link to netapi32.lib
//#include <lmcons.h>     //for lmapibuf.h
//#include <lmapibuf.h>   //for NetApiBufferFree
//#include <dsgetdc.h>    //for DsGetSiteName
//DsGetSiteName_ROUTINE g_pfnDummyDsGetSiteName = DsGetSiteName;
//NetApiBufferFree_ROUTINE g_pfnDummyNetApiBufferFree = NetApiBufferFree;
//
/*====================================================
    CADSI::CADSI()
    Constructor
=====================================================*/
CADSI::CADSI()
    :  m_pSearchMsmqServiceContainerLocalDC(NULL)
{
    HRESULT hr = m_cCoInit.CoInitialize();
    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 1605);
    //BUGBUG - in case of failure

}

/*====================================================
    CADSI::~CADSI()
    Destructor
=====================================================*/
CADSI::~CADSI()
{
}


/*====================================================
    CADSI::LocateBegin()
    Initiates search in the directory
=====================================================*/
HRESULT CADSI::LocateBegin(
            IN  DS_SEARCH_LEVEL       SearchLevel,	    // one level or subtree
            IN  DS_PROVIDER           Provider,		    // local DC or GC
            IN  CDSRequestContext *   pRequestContext,
            IN  const GUID *          pguidUniqueId,    // unique id of object - search base
            IN  const MQRESTRICTION * pMQRestriction, 	// search criteria
            IN  const MQSORTSET *     pDsSortkey,        // sort keys array
            IN  const DWORD           cPropIDs,         // size of attributes array
            IN  const PROPID *        pPropIDs,         // attributes to be obtained
            OUT HANDLE *              phResult) 	    // result handle
{
    HRESULT             hr   = MQ_OK;

    R<IDirectorySearch> pDSSearch = NULL;

    ADS_SEARCH_HANDLE   hSearch;

    const MQClassInfo * pClassInfo;

    hr = DecideObjectClass( pPropIDs,
                           &pClassInfo ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    //
    //  Bind to IDirectorySearch interface of the specified object
    //
    P<CImpersonate> pCleanupRevertImpersonation;

    BOOL fSorting = FALSE ;
    if (pDsSortkey && (pDsSortkey->cCol >= 1))
    {
        fSorting = TRUE ;
    }

    hr = BindForSearch(Provider,
                      pClassInfo->context,
                      pRequestContext,
                      pguidUniqueId,
                      fSorting,
                      (VOID *)&pDSSearch,
                      &pCleanupRevertImpersonation);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }

    //
    //  Prepare search and sort data
    //
    ADS_SEARCHPREF_INFO prefs[15];
    AP<ADS_SORTKEY> pSortKeys = new ADS_SORTKEY[(pDsSortkey ? pDsSortkey->cCol : 1)];
    DWORD dwPrefs = 0;

    hr = FillSearchPrefs(prefs,
                         &dwPrefs,
                         SearchLevel,
                         pDsSortkey,
                         pSortKeys);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }

    //
    // Translate MQRestriction into the ADSI Filter
    //
    AP<WCHAR> pwszSearchFilter;
    hr = MQRestriction2AdsiFilter(
            pMQRestriction,
            *pClassInfo->ppwcsObjectCategory,
            pClassInfo->pwcsClassName,
            &pwszSearchFilter
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 40);
    }

    // Translate MQPropIDs to ADSI Names
    DWORD   cRequestedFromDS = cPropIDs + 2; //request also dn & guid

    PVP<LPWSTR> pwszAttributeNames = (LPWSTR *)PvAlloc(sizeof(LPWSTR) * cRequestedFromDS);

    hr = FillAttrNames( pwszAttributeNames,
                        &cRequestedFromDS,
                        cPropIDs,
                        pPropIDs);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50);
    }

    //
    //  Set search preferences
    //
    if (dwPrefs)
    {
        hr = pDSSearch->SetSearchPreference( prefs,
                                             dwPrefs ) ;
        ASSERT(SUCCEEDED(hr)) ; // we don't expect this to fail.
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 60);
        }
    }

    //
    //  Really execute search
    //
    hr = pDSSearch->ExecuteSearch(
                         pwszSearchFilter,
                         pwszAttributeNames,
                         cRequestedFromDS,
                        &hSearch);
    LogTraceQuery(pwszSearchFilter, s_FN, 69);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 70);
    }

    // Capturing search interface and handle in the internal search object
    CADSSearch *pSearchInt = new CADSSearch(
                        pDSSearch.get(),
                        pPropIDs,
                        cPropIDs,
                        cRequestedFromDS,
                        pClassInfo,
                        hSearch);

    // Returning handle-casted internal object pointer
    *phResult = (HANDLE)pSearchInt;

    return MQ_OK;
}

/*====================================================
    CADSI::LocateNext()
    Provides next search result
    Caller should free pPropVars by PVFree
=====================================================*/
HRESULT CADSI::LocateNext(
            IN     HANDLE          hSearchResult,   // result handle
            IN     CDSRequestContext *pRequestContext,
            IN OUT DWORD          *pcPropVars,      // IN num of variants; OUT num of results
            OUT    MQPROPVARIANT  *pPropVars)       // MQPROPVARIANT array
{
    HRESULT     hr = MQ_OK;
    CADSSearch *pSearchInt = (CADSSearch *)hSearchResult;
    // Save number of requested props
    DWORD cPropsRequested = *pcPropVars;
    *pcPropVars = 0;

    // Verify the handle
    try                    // guard against nonsence handle
    {
        if (!pSearchInt->Verify())
        {
           hr = MQ_ERROR_INVALID_PARAMETER;
        }
    }
    catch(...)
    {
        hr = MQ_ERROR_INVALID_PARAMETER;
        LogIllegalPoint(s_FN, 81);
    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 80);
    }

    IDirectorySearch  *pSearchObj = pSearchInt->pDSSearch();

    //
    //  Did we get S_ADS_NOMORE_ROWS in this query
    //
    if (  pSearchInt->WasLastResultReturned())
    {
        *pcPropVars = 0;
        return( MQ_OK);
    }

    // Compute number of full rows to return
    DWORD cRowsToReturn = cPropsRequested / pSearchInt->NumPropIDs();

    // got to request at least one row
    ASSERT(cRowsToReturn > 0);

    // pointer to next prop to be filled
    MQPROPVARIANT *pPropVarsProp = pPropVars;

    // number of returned props
    DWORD cPropVars = 0;

    // loop on requested rows
    for (DWORD dwRow = 0; dwRow < cRowsToReturn; dwRow++)
    {
        //  Get next row
        hr = pSearchObj->GetNextRow(pSearchInt->hSearch());
        //
        //  BUGBUG - sometimes gets E_ADS_LDAP_INAPPROPRIATE_MATCHING,
        //  to investgate more!!
        //
        if ( hr == HRESULT_FROM_WIN32(ERROR_DS_INAPPROPRIATE_MATCHING))
            break;
		
		// BUGBUG: sometimes gets E_ADS_LDAP_UNAVAILABLE_CRIT_EXTENSION on empty search
		// See example tests\sortnull (was repro) - to investigate more
		//
		if ( hr == HRESULT_FROM_WIN32(ERROR_DS_UNAVAILABLE_CRIT_EXTENSION))
		{
			hr = S_ADS_NOMORE_ROWS;
		}

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 90);
        }
        if (hr == S_ADS_NOMORE_ROWS)
        {
            *pcPropVars = cPropVars;
            pSearchInt->SetNoMoreResult();
            return MQ_OK;
        }
        //
        // Get object translate info
        //
        AP<WCHAR> pwszObjectDN;
        P<GUID> pguidObjectGuid;
        P<CMsmqObjXlateInfo> pcObjXlateInfo;

        // Get dn & guid from object (got to be there, because we asked for them)
        hr = GetDNGuidFromSearchObj(pSearchObj, pSearchInt->hSearch(), &pwszObjectDN, &pguidObjectGuid);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 100);
        }

        // Get translate info object
        hr = (*(pSearchInt->ClassInfo()->fnGetMsmqObjXlateInfo))(pwszObjectDN, pguidObjectGuid, pRequestContext, &pcObjXlateInfo);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 110);
        }

        // Tell the translate info object about the search object to use in order to get necessary DS props
        pcObjXlateInfo->InitGetDsProps(pSearchObj, pSearchInt->hSearch());

        // Loop by requested properties
        for (DWORD dwProp=0; dwProp < pSearchInt->NumPropIDs(); dwProp++, pPropVarsProp++, cPropVars++)
        {
            //
            //  vartype of all PROPVARIANT should be VT_NULL.
            //  ( user cannot specify buffers for results).
            //
            pPropVarsProp->vt = VT_NULL;

            //
            //  First check if the next property is in the DS
            //
            //
            // Get property info
            //
            const MQTranslateInfo *pTranslate;
            if(!g_PropDictionary.Lookup( pSearchInt->PropID(dwProp), pTranslate))
            {
                ASSERT(0);
                return LogHR(MQ_ERROR, s_FN, 1000);
            }

            // Maybe it is one of the known things?
            if (pTranslate->wcsPropid)
            {
                // We already know objectGuid, no need to ask once more
                if (wcscmp(pTranslate->wcsPropid, const_cast<LPWSTR>(x_AttrDistinguishedName)) == 0)
                {
                    pPropVarsProp->vt      = VT_LPWSTR;
                    pPropVarsProp->pwszVal = new WCHAR[wcslen(pwszObjectDN) + 1];
                    wcscpy(pPropVarsProp->pwszVal, pwszObjectDN);
                    continue;
                }

                // We already know objectGuid, no need to ask once more
                if (wcscmp(pTranslate->wcsPropid, const_cast<LPWSTR>(x_AttrObjectGUID)) == 0)
                {
                    if (pPropVarsProp->vt != VT_CLSID)
                    {
                        ASSERT(((pPropVarsProp->vt == VT_NULL) || (pPropVarsProp->vt == VT_EMPTY)));
                        pPropVarsProp->vt    = VT_CLSID;
                        pPropVarsProp->puuid = new GUID;
                    }
                    else if ( pPropVarsProp->puuid == NULL)
                    {
                        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 1010);
                    }

                    *pPropVarsProp->puuid = *pguidObjectGuid;
                    continue;
                }
            }

            //
            // if the property is not in the DS, call its retrieve routine
            //
            if (pTranslate->vtDS == ADSTYPE_INVALID)
            {
                if (pTranslate->RetrievePropertyHandle)
                {
                    //
                    //  Calculate its value
                    //
                    hr = pTranslate->RetrievePropertyHandle(
                            pcObjXlateInfo,
                            pPropVarsProp
                            );
                    if (FAILED(hr))
                    {
                        return LogHR(hr, s_FN, 120);
                    }
                    continue;
                }
                else
                {
                    //
                    // return error if no retrieve routine
                    //
                    ASSERT(0);
                    return LogHR(MQ_ERROR, s_FN, 1020);
                }
            }

            ADS_SEARCH_COLUMN Column;

            // Ask for the column itself
            hr = pSearchObj->GetColumn(
                         pSearchInt->hSearch(),
                         (LPWSTR)pTranslate->wcsPropid,
                         &Column);

            if (hr == E_ADS_COLUMN_NOT_SET)
            {
                //  The requested column has no value in DS
                hr = CopyDefaultValue(
                       pTranslate->pvarDefaultValue,
                       pPropVarsProp);
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 130);
                }
                continue;
            }
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 140);
            }

            hr = AdsiVal2MqPropVal(pPropVarsProp,
                                   pSearchInt->PropID(dwProp),
                                   Column.dwADsType,
                                   Column.dwNumValues,
                                   Column.pADsValues);
            pSearchObj->FreeColumn(&Column);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 150);
            }
        }
    }

    *pcPropVars = cPropVars;
    return MQ_OK;
}


/*====================================================
    CADSI::LocateEnd()
    Finishes directory search
=====================================================*/
HRESULT CADSI::LocateEnd(
        IN HANDLE phResult)     // result handle
{
    CADSSearch *pSearchInt = (CADSSearch *)phResult;
    HRESULT hr = MQ_OK;

    // Verify the handle
    try                    // guard against nonsence handle
    {
        if (!pSearchInt->Verify())
        {
           hr = MQ_ERROR_INVALID_PARAMETER;
        }
    }
    catch(...)
    {
        LogIllegalPoint(s_FN, 82);
        hr = MQ_ERROR_INVALID_PARAMETER;
    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }


    delete pSearchInt;      // inside: release interface and handle

    return MQ_OK;
}

/*====================================================
    CADSI::GetObjectProperties()
    Gets DS object's properties
=====================================================*/
HRESULT CADSI::GetObjectProperties(
            IN  DS_PROVIDER     Provider,		    // local DC or GC
            IN  CDSRequestContext *pRequestContext,
 	        IN  LPCWSTR         lpwcsPathName,      // object name
            IN  const GUID     *pguidUniqueId,      // unique id of object
            IN  DWORD           cPropIDs,           // number of attributes to retreive
            IN  const PROPID   *pPropIDs,           // attributes to retreive
            OUT MQPROPVARIANT  *pPropVars)          // output variant array
{
    HRESULT               hr;
    R<IADs>   pAdsObj        = NULL;

    const MQClassInfo * pClassInfo;

    hr = DecideObjectClass(
            pPropIDs,
            &pClassInfo
            );

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 170);
    }
    // Bind to the object either by GUID or by name
    P<CImpersonate> pCleanupRevertImpersonation;
    hr = BindToObject(
                Provider,
                pClassInfo->context,
                pRequestContext,
                lpwcsPathName,
                pguidUniqueId,
                IID_IADs,
                (VOID *)&pAdsObj,
                &pCleanupRevertImpersonation);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 180);
    }

    //
    //  verify that the bounded object is of the correct category
    //
    hr = VerifyObjectCategory( pAdsObj.get(),  *pClassInfo->ppwcsObjectCategory);
    if (FAILED(hr))
    {
        return LogHR( hr, s_FN, 117);
    }

    // Get properies
    hr = GetObjectPropsCached(
                        pAdsObj.get(),
                        cPropIDs,
                        pPropIDs,
                        pRequestContext,
                        pPropVars);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 190);
    }


    return MQ_OK;
}

/*====================================================
    CADSI::SetObjectProperties()
    Sets DS object's properties
=====================================================*/
HRESULT CADSI::SetObjectProperties(
            IN  DS_PROVIDER        provider,
            IN  CDSRequestContext *pRequestContext,
            IN  LPCWSTR            lpwcsPathName,     // object name
            IN  const GUID        *pguidUniqueId,     // unique id of object
            IN  DWORD               cPropIDs,         // number of attributes to set
            IN  const PROPID         *pPropIDs,           // attributes to set
            IN  const MQPROPVARIANT  *pPropVars,          // attribute values
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest) // optional request for object info
{
    HRESULT               hr;
    ASSERT( provider != eGlobalCatalog);

    // Working through cache
    R<IADs>   pAdsObj = NULL;
    const MQClassInfo * pClassInfo;

    hr = DecideObjectClass(
            pPropIDs,
            &pClassInfo
            );

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 200);
    }

    P<CImpersonate> pCleanupRevertImpersonation;
    hr = BindToObject(
                provider,
                pClassInfo->context,
                pRequestContext,
                lpwcsPathName,
                pguidUniqueId,
                IID_IADs,
                (VOID *)&pAdsObj,
                &pCleanupRevertImpersonation) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 210);
    }

    // Set properies
    hr = SetObjectPropsCached(
                        eSet,
                        pAdsObj.get(),
                        cPropIDs,
                        pPropIDs,
                        pPropVars);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 220);
    }

    // Finilize changes
    hr = pAdsObj->SetInfo();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 230);
    }

	// Set security if it was given
    hr = SetDirObjectProps(	eSet,
                            pAdsObj.get(),
                            cPropIDs,
                            pPropIDs,
                            pPropVars,
                            pClassInfo->dwObjectType ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 240);
    }
    //
    // get object info if requested. don't fail if the request fails,
    // just mark the failure in the request's status
    //
    if (pObjInfoRequest)
    {
        pObjInfoRequest->hrStatus =
              GetObjectPropsCached( pAdsObj.get(),
                                    pObjInfoRequest->cProps,
                                    pObjInfoRequest->pPropIDs,
                                    pRequestContext,
                                    pObjInfoRequest->pPropVars );
        if (FAILED(pObjInfoRequest->hrStatus))
        {
            //
            // Caller have permission to create an object, but
            // he doesn't have permission to look at the parent
            // container. That's OK.
            // Retrieve parent info using the context of the msmq
            // service itself.
            // For queue object, to retrieve Q_QMID we query the msmq
            // configuration object, so the computer object is the
            // parent in this case.
            //
            delete pCleanupRevertImpersonation.detach();

            pAdsObj.free();

            CDSRequestContext RequestContext ( e_DoNotImpersonate,
                                               e_ALL_PROTOCOLS ) ;
            hr = BindToObject( provider,
                               pClassInfo->context,
                               &RequestContext,
                               lpwcsPathName,
                               pguidUniqueId,
                               IID_IADs,
                               (VOID *)&pAdsObj,
                               &pCleanupRevertImpersonation) ;
            if (SUCCEEDED(hr))
            {
                pObjInfoRequest->hrStatus =
                      GetObjectPropsCached( pAdsObj.get(),
                                            pObjInfoRequest->cProps,
                                            pObjInfoRequest->pPropIDs,
                                            pRequestContext,
                                            pObjInfoRequest->pPropVars ) ;
            }
        }
    }

    return MQ_OK;
}

//+--------------------------------------
//
//  HRESULT  CADSI::GetParentInfo()
//
//+--------------------------------------

HRESULT  CADSI::GetParentInfo(
                       IN LPWSTR                      pwcsFullParentPath,
                       IN CDSRequestContext          *pRequestContext,
                       IN IADsContainer              *pContainer,
                       IN OUT MQDS_OBJ_INFO_REQUEST  *pParentInfoRequest,
                       IN P<CImpersonate>&            pImpersonation )
{
    R<IADs> pIADsParent;
    HRESULT hrTmp = pContainer->QueryInterface( IID_IADs,
                                                  (void **)&pIADsParent);
    if (FAILED(hrTmp))
    {
        return LogHR(hrTmp, s_FN, 1030);
    }

    hrTmp = GetObjectPropsCached( pIADsParent.get(),
                                  pParentInfoRequest->cProps,
                                  pParentInfoRequest->pPropIDs,
                                  pRequestContext,
                                  pParentInfoRequest->pPropVars );
    if (SUCCEEDED(hrTmp))
    {
        return LogHR(hrTmp, s_FN, 1040);
    }

    //
    // Caller have permission to create an object, but
    // he doesn't have permission to look at the parent
    // container. That's OK.
    // Retrieve parent info using the context of the msmq
    // service itself.
    //
    pImpersonation.free();

    pIADsParent.free();

    R<IADsContainer>      pBindContainer;

    hrTmp = ADsOpenObject( 
				pwcsFullParentPath,
				NULL,
				NULL,
				ADS_SECURE_AUTHENTICATION,
				IID_IADsContainer,
				(void**)&pBindContainer.ref()
				);

    LogTraceQuery(pwcsFullParentPath, s_FN, 1049);
    if (FAILED(hrTmp))
    {
        return LogHR(hrTmp, s_FN, 1050);
    }

    hrTmp = pBindContainer->QueryInterface( IID_IADs,
                                            (void **)&pIADsParent);
    if (FAILED(hrTmp))
    {
        return LogHR(hrTmp, s_FN, 1060);
    }

    hrTmp = GetObjectPropsCached( pIADsParent.get(),
                                  pParentInfoRequest->cProps,
                                  pParentInfoRequest->pPropIDs,
                                  pRequestContext,
                                  pParentInfoRequest->pPropVars );
    return LogHR(hrTmp, s_FN, 1070);
}

//+--------------------------------------
//
//  HRESULT  CADSI::CreateIDirectoryObject()
//
//+--------------------------------------
HRESULT CADSI::CreateIDirectoryObject(
            IN LPCWSTR				pwcsObjectClass,	
            IN IDirectoryObject *	pDirObj,
			IN LPCWSTR				pwcsFullChildPath,
            IN const DWORD			cPropIDs,
            IN const PROPID *		pPropIDs,
            IN const MQPROPVARIANT * pPropVar,
			IN const DWORD			dwObjectType,
            OUT IDispatch **		pDisp
			)
{
    HRESULT hr;

    R<IADsObjectOptions> pObjOptions = NULL ;

    //
    // Translate MQPROPVARIANT properties to ADSTYPE attributes
    //

    DWORD cAdsAttrs = 0;
	P<BYTE> pSD = NULL ;
	DWORD dwSDSize = 0 ;
	DWORD dwSDIndex = 0;
    AP<ADS_ATTR_INFO> AttrInfo = new ADS_ATTR_INFO[cPropIDs + 1];
	PVP<PADSVALUE> pAdsVals = (PADSVALUE *)PvAlloc( sizeof(PADSVALUE) * (cPropIDs + 1));

    //
    // The first attribute is the "objectClass"
    //
	pAdsVals[cAdsAttrs] = (ADSVALUE *)PvAllocMore( sizeof(ADSVALUE), pAdsVals);
    pAdsVals[cAdsAttrs]->dwType = ADSTYPE_CASE_IGNORE_STRING ;
    pAdsVals[cAdsAttrs]->CaseIgnoreString = const_cast<LPWSTR>(pwcsObjectClass) ;

    AttrInfo[cAdsAttrs].pszAttrName   = L"objectClass" ;
    AttrInfo[cAdsAttrs].dwControlCode = ADS_ATTR_UPDATE ;
    AttrInfo[cAdsAttrs].dwADsType     = ADSTYPE_CASE_IGNORE_STRING ;
    AttrInfo[cAdsAttrs].pADsValues    = pAdsVals[cAdsAttrs];
    AttrInfo[cAdsAttrs].dwNumValues   = 1;

    cAdsAttrs++;

    for (DWORD i = 0; i < cPropIDs; i++)
	{
        DWORD dwNumValues = 0;
		//
		//	Ignore the computer SID property when creating object.
		//	This is just a hack to pass in computer sid for SD translation
		//
		if ( pPropIDs[i] == PROPID_COM_SID)
		{
			continue;
		}
		//
		// Get property info
		//	
		const MQTranslateInfo *pTranslate;
		if(!g_PropDictionary.Lookup(pPropIDs[i], pTranslate))
		{
			ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 1080);
		}

		PROPID	propidToCreate = pPropIDs[i];
		const PROPVARIANT *	pvarToCrate = &pPropVar[i];
		CMQVariant propvarToCreate;
	
		if (pTranslate->vtDS == ADSTYPE_INVALID)
		{	
			//
			//	The property is not kept in the DS as is. If it has a set routine,
			//	use it to get the new property & value for create.
			//
			if ( pTranslate->CreatePropertyHandle == NULL)
			{
				continue;
			}
			hr = pTranslate->CreatePropertyHandle(
									&pPropVar[i],
									&propidToCreate,
									propvarToCreate.CastToStruct()
									);
			if (FAILED(hr))
			{
                 return LogHR(hr, s_FN, 1090);
			}
			ASSERT( propidToCreate != 0);
			pvarToCrate = propvarToCreate.CastToStruct();
			//
			//	Get replaced property info
			//
			if ( !g_PropDictionary.Lookup( propidToCreate, pTranslate))
			{
				ASSERT(0);
                return LogHR(MQ_ERROR, s_FN, 1100);
			}
								
		}
		if ( pTranslate->vtDS == ADSTYPE_NT_SECURITY_DESCRIPTOR )
		{	
            pAdsVals[cAdsAttrs] = (ADSVALUE *)PvAllocMore( sizeof(ADSVALUE), pAdsVals);
            pAdsVals[cAdsAttrs]->dwType = pTranslate->vtDS;

			PSID pComputerSid = NULL;

			for ( DWORD j = 0; j < cPropIDs; j++)
			{
				if ( pPropIDs[j] == PROPID_COM_SID)
				{
					pComputerSid = (PSID) pPropVar[j].blob.pBlobData;
					ASSERT(IsValidSid(pComputerSid));
					break;
				}
			}

			SECURITY_INFORMATION seInfo =  MQSEC_SD_ALL_INFO;

            if (dwObjectType == MQDS_MQUSER)
            {
                //
                // For the migrated user, we provide only the dacl.
                // we let DS to add the other components.
                //
			    seInfo =  DACL_SECURITY_INFORMATION ;
            }
            else
            {
    			//
	    		//	If the caller did not explicitely specify SACL info
                //	don't try to set it
			    //
                PACL  pAcl = NULL ;
                BOOL  bPresent = FALSE ;
                BOOL  bDefaulted ;

                BOOL bRet = GetSecurityDescriptorSacl(
                         (SECURITY_DESCRIPTOR*)pvarToCrate->blob.pBlobData,
                                                  &bPresent,
                                                  &pAcl,
                                                  &bDefaulted );
                ASSERT(bRet);

                if (!bPresent)
                {
			    	seInfo &= ~SACL_SECURITY_INFORMATION ; // turn off.
    			}

    			//
	    		//	Similarly, if the caller did not explicitely specify
                //  Owner, don't try to set it. Bug 5286.
			    //
                PSID pOwner = NULL ;
                bRet = GetSecurityDescriptorOwner(
                         (SECURITY_DESCRIPTOR*)pvarToCrate->blob.pBlobData,
                                                  &pOwner,
                                                  &bDefaulted );
                ASSERT(bRet);

                if (!pOwner)
                {
			    	seInfo &= ~OWNER_SECURITY_INFORMATION ; // turn off.
    			}
			}

            //
			// Get IADsObjectOptions interface pointer and
		    // set ObjectOption, specifying the SECURITY_INFORMATION we want to set.
		    //
			hr = pDirObj->QueryInterface (IID_IADsObjectOptions,(LPVOID *) &pObjOptions);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 250);
            }
	
			VARIANT var ;
			var.vt = VT_I4 ;
			var.ulVal = (ULONG) seInfo ;
	
			hr = pObjOptions->SetOption( ADS_OPTION_SECURITY_MASK, var ) ;
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 260);
            }
	
			//
			// Convert security descriptor to NT5 format.
			//
			BYTE   *pBlob = pvarToCrate->blob.pBlobData;
			DWORD   dwSize = pvarToCrate->blob.cbSize;
	
			hr = MQSec_ConvertSDToNT5Format( dwObjectType,
										     (SECURITY_DESCRIPTOR*)pBlob,
										     &dwSDSize,
										     (SECURITY_DESCRIPTOR **)&pSD,
                                             e_MakeDaclNonDefaulted,
											 pComputerSid ) ;
			if (FAILED(hr))
			{
                return LogHR(hr, s_FN, 1110);
			}
			else if (hr != MQSec_I_SD_CONV_NOT_NEEDED)
			{
				pBlob = pSD ;
				dwSize = dwSDSize ;
			}
			else
			{
				ASSERT(pSD == NULL) ;
			}

			if (pSD && !IsValidSecurityDescriptor(pSD))
			{
                return LogHR(MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR, s_FN, 1120);
			}
			//
			// Set property
			//
            dwNumValues = 1 ;
			pAdsVals[cAdsAttrs]->SecurityDescriptor.dwLength = dwSize ;
			pAdsVals[cAdsAttrs]->SecurityDescriptor.lpValue  = pBlob ;
			dwSDIndex = cAdsAttrs;
		}
        else
        {
			if ( ( pvarToCrate->vt & VT_VECTOR && pvarToCrate->cauuid.cElems == 0) || // counted array with 0 elements
				 ( pvarToCrate->vt == VT_BLOB && pvarToCrate->blob.cbSize == 0) || // an empty blob
				 ( pvarToCrate->vt == VT_LPWSTR && wcslen( pvarToCrate->pwszVal) == 0)) // an empty string
			{
				//
				//  ADSI doesn't allow to create an object while specifing
				//  some of its attributes as not-available. Therefore on
				//  create we ignore the "empty" properties
				//
				continue;	
			}
            hr = MqVal2AdsiVal( pTranslate->vtDS,
					            &dwNumValues,
								&pAdsVals[cAdsAttrs],
								pvarToCrate,
                                pAdsVals);
            if (FAILED(hr))
			{
                return LogHR(hr, s_FN, 1130);
			}
        }

		ASSERT(dwNumValues > 0) ;
		AttrInfo[cAdsAttrs].pszAttrName   = const_cast<LPWSTR>(pTranslate->wcsPropid) ;
		AttrInfo[cAdsAttrs].dwControlCode = ADS_ATTR_UPDATE ;
		AttrInfo[cAdsAttrs].dwADsType     = pAdsVals[cAdsAttrs]->dwType ;
		AttrInfo[cAdsAttrs].pADsValues    = pAdsVals[cAdsAttrs] ;
		AttrInfo[cAdsAttrs].dwNumValues   = dwNumValues ;

		cAdsAttrs++ ;
	}

    //
    // Create the queue object.
    //

    HRESULT hr2 = pDirObj->CreateDSObject(
						const_cast<WCHAR *>(pwcsFullChildPath),
                        AttrInfo,
                        cAdsAttrs,
                        pDisp
						);
    LogTraceQuery(const_cast<WCHAR *>(pwcsFullChildPath), s_FN, 1139);
    return LogHR(hr2, s_FN, 1140);
}

/*====================================================
    CADSI::CreateObject()
    Creates new DS object
=====================================================*/
HRESULT CADSI::CreateObject(
            IN DS_PROVIDER      Provider,		    // local DC or GC
            IN CDSRequestContext *pRequestContext,
            IN LPCWSTR          lpwcsObjectClass,   // object class
            IN LPCWSTR          lpwcsChildName,     // object name
            IN LPCWSTR          lpwsParentPathName, // object parent name
            IN DWORD            cPropIDs,                 // number of attributes
            IN const PROPID          *pPropIDs,           // attributes
            IN const MQPROPVARIANT   *pPropVars,          // attribute values
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,    // optional request for object info
            IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest) // optional request for parent info
{
    HRESULT             hr;
    const MQClassInfo * pClassInfo;

    hr = DecideObjectClass(
            pPropIDs,
            &pClassInfo
            );
    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 1606);

    ASSERT( Provider != eGlobalCatalog);
    //
    //  Add LDAP:// prefix to the parent name
    //
    DWORD len = wcslen(lpwsParentPathName);

    LPWSTR pszGCName = NULL ;
    PROPID *pIDs = const_cast<PROPID*> (pPropIDs) ;

    for ( DWORD j = 0 ; j < cPropIDs ; j++ )
    {
        if (pPropIDs[ j ] == PROPID_QM_MIG_GC_NAME)
        {
            if (pPropVars[ j ].vt == VT_LPWSTR)
            {
                pszGCName = pPropVars[ j ].pwszVal ;
                len += 1 + wcslen( pszGCName ) ;
                ASSERT(Provider == eDomainController) ;
            }

            ASSERT(pPropIDs[ j-1 ] == PROPID_QM_MIG_PROVIDER) ;
            ASSERT(pPropIDs[ j-2 ] == PROPID_QM_FULL_PATH) ;

            pIDs[ j ] = PROPID_QM_DONOTHING ;
            pIDs[ j-1 ] = PROPID_QM_DONOTHING ;
            pIDs[ j-2 ] = PROPID_QM_DONOTHING ;
        }
    }

    AP<WCHAR> pwcsFullParentPath = new WCHAR [  len + g_dwServerNameLength + x_providerPrefixLength + 2];

	bool fServerName = false;
    switch(Provider)
    {
    case eDomainController:
        if (pszGCName)
        {
            //
            // Add the known GC name to path.
            //
            swprintf( pwcsFullParentPath,
                      L"%s%s"
                      L"/",
                      x_LdapProvider,
                      pszGCName ) ;
			fServerName = true;
        }
        else
        {
            wcscpy(pwcsFullParentPath, x_LdapProvider);
        }
        break;

    case eLocalDomainController:
        swprintf(
            pwcsFullParentPath,
             L"%s%s"
             L"/",
            x_LdapProvider,
            g_pwcsServerName
            );
		fServerName = true;
        break;

    default:
        ASSERT(0);
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1150);
    }

    wcscat(pwcsFullParentPath,lpwsParentPathName);

    //
    //  Add CN= to the child name
    //
    len = wcslen(lpwcsChildName);
    AP<WCHAR> pwcsFullChildPath = new WCHAR[ len + x_CnPrefixLen + 1];

    swprintf(
        pwcsFullChildPath,
         TEXT("CN=")
         L"%s",
        lpwcsChildName
        );

    //
    // Impersonate the user
    //
    P<CImpersonate> pImpersonate = NULL ;
    BOOL fImpersonate = pRequestContext->NeedToImpersonate();

    if (fImpersonate)
    {
        hr = MQSec_GetImpersonationObject( fImpersonate,
                                           fImpersonate,
                                          &pImpersonate ) ;
        ASSERT(SUCCEEDED(hr)) ;

        if (pImpersonate->GetImpersonationStatus() != 0)
        {
            return LogHR(MQ_ERROR_CANNOT_IMPERSONATE_CLIENT, s_FN, 1160);
        }
    }
	//
    // First, we must bind to the parent container
	//
	R<IDirectoryObject> pParentDirObj = NULL;

	DWORD Flags = ADS_SECURE_AUTHENTICATION;
	if(fServerName)
	{
		Flags |= ADS_SERVER_BIND;
	}
    hr = ADsOpenObject(
                pwcsFullParentPath,
                NULL,
                NULL,
                Flags,
                IID_IDirectoryObject,
                (void**) &pParentDirObj
				);

    LogTraceQuery(pwcsFullParentPath, s_FN, 269);
    if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE))
    {
        //
        //  Most likely that this indicates that access is denied.
        //  LDAP doesn't return an access denied error in order not
        //  to have a security breach since the caller doesn't have
        //  permission to know that this attribute even exists.
        //
        hr = HRESULT_FROM_WIN32(MQ_ERROR_ACCESS_DENIED);
    }

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 270);
    }

    R<IADsContainer>  pContainer  = NULL;
	hr = pParentDirObj->QueryInterface( IID_IADsContainer, (LPVOID *) &pContainer);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 280);
    }
	//
    // Now we may create a child object
	//
    R<IDispatch> pDisp = NULL;
	hr = CreateIDirectoryObject(
				 lpwcsObjectClass,
				 pParentDirObj.get(),
				 pwcsFullChildPath,
				 cPropIDs,
                 pPropIDs,
                 pPropVars,
				 pClassInfo->dwObjectType,
				 &pDisp.ref());

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 290);
    }

    R<IADs> pChild  = NULL;


    if (pObjInfoRequest || pParentInfoRequest)
    {
        hr = pDisp->QueryInterface (IID_IADs,(LPVOID *) &pChild);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 300);
        }
    }

    //
    // get object info if requested. don't fail if the request fails,
    // just mark the failure in the request's status
    //
    if (pObjInfoRequest)
    {
        pObjInfoRequest->hrStatus =
            GetObjectPropsCached(pChild.get(),
                                 pObjInfoRequest->cProps,
                                 pObjInfoRequest->pPropIDs,
                                 pRequestContext,
                                 pObjInfoRequest->pPropVars
                                 );
    }

    //
    // get parent info if requested. don't fail if the request fails,
    // just mark the failure in the request's status
    //
    if (pParentInfoRequest)
    {
        pParentInfoRequest->hrStatus = GetParentInfo( pwcsFullParentPath,
                                                      pRequestContext,
                                                      pContainer.get(),
                                                      pParentInfoRequest,
                                                      pImpersonate ) ;
    }

    return MQ_OK;
}

/*====================================================
    CADSI::CreateOU()
    Creates new O object
=====================================================*/
HRESULT CADSI::CreateOU(
            IN DS_PROVIDER      Provider,		    // local DC or GC
            IN CDSRequestContext * /*pRequestContext*/,
            IN LPCWSTR          lpwcsChildName,     // object name
            IN LPCWSTR          lpwsParentPathName, // object parent name
            IN LPCWSTR          lpwcsDescription
            )
{
    HRESULT             hr;

    R<IADsContainer>  pContainer  = NULL;
    ASSERT( Provider != eGlobalCatalog);
    //
    //  Add LDAP:// prefix to the parent name
    //
    DWORD len = wcslen(lpwsParentPathName);
    AP<WCHAR> pwcsFullParentPath = new WCHAR [  len + g_dwServerNameLength + x_providerPrefixLength + 2];

	bool fServerName = false;
    switch(Provider)
    {
    case eDomainController:
        wcscpy(pwcsFullParentPath, x_LdapProvider);
        break;

    case eLocalDomainController:
        swprintf(
            pwcsFullParentPath,
             L"%s%s"
             L"/",
            x_LdapProvider,
            g_pwcsServerName
            );
		fServerName = true;
        break;

    default:
        ASSERT(0);
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1170);
    }

    wcscat(pwcsFullParentPath,lpwsParentPathName);

    //
    //  Add OU= to the child name
    //
    len = wcslen(lpwcsChildName);
    AP<WCHAR> pwcsFullChildPath = new WCHAR[ len + x_OuPrefixLen + 1];

        swprintf(
        pwcsFullChildPath,
        L"%s%s",
        x_OuPrefix,
        lpwcsChildName
        );

    // First, we must bind to the parent container
	DWORD Flags = ADS_SECURE_AUTHENTICATION;
	if(fServerName)
	{
		Flags |= ADS_SERVER_BIND;
	}

    hr = ADsOpenObject(
                pwcsFullParentPath,
                NULL,
                NULL,
                Flags,
                IID_IADsContainer,
                (void**)&pContainer
				);

    LogTraceQuery(pwcsFullParentPath, s_FN, 309);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 310);
    }

    // Now we may create a child object

    BS bsClass(L"organizationalUnit");

    BS bsName(pwcsFullChildPath);

    R<IDispatch> pDisp = NULL;

    hr = pContainer->Create(bsClass,
                            bsName,
                            &pDisp.ref());
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 320);
    }

    R<IADs> pChild  = NULL;

    hr = pDisp->QueryInterface (IID_IADs,(LPVOID *) &pChild);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 330);
    }

    if (lpwcsDescription != NULL)
    {
        BS bsPropName(L"description");
        VARIANT vProp;
        vProp.vt = VT_BSTR;
        vProp.bstrVal = SysAllocString(lpwcsDescription);

        hr = pChild->Put(bsPropName, vProp);
        LogTraceQuery(bsPropName, s_FN, 339);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 340);
        }
        VariantClear(&vProp);
    }

    //
    // Finalize creation - commit it and release the security variant
    //
    hr = pChild->SetInfo();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 350);
    }

    return MQ_OK;
}

/*====================================================
    CADSI::DeleteObject()
    Deletes specified DS object
        Accepts either lpwcsPathName or pguidUniqueId but not both
        Returns MQ_ERROR_INVALID_PARAMETER if both or none were given
=====================================================*/
HRESULT CADSI::DeleteObject(
        IN DS_PROVIDER      Provider,		    // local DC or GC
        IN DS_CONTEXT       Context,
        IN CDSRequestContext *pRequestContext,
        IN LPCWSTR          lpwcsPathName,      // object name
        IN const GUID *		pguidUniqueId,      // unique id of object
        IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,    // optional request for object info
        IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest) // optional request for parent info
{
    HRESULT               hr;
    BSTR                  bs;
    R<IADs>               pIADs       = NULL;
    R<IADsContainer>      pContainer  = NULL;
    ASSERT( Provider != eGlobalCatalog);
    const WCHAR *   pPath =  lpwcsPathName;

    AP<WCHAR> pwcsFullPath;
    if ( pguidUniqueId != NULL)
    {
        //
        //  GetParent of object bound according to GUID doesn't work
        //  That is why we translate it to pathname
        //
        DS_PROVIDER prov;
        hr = FindObjectFullNameFromGuid(
            Provider,		// local DC or GC
            Context,        // DS context
            pguidUniqueId,
            1,              // fTryGCToo
            &pwcsFullPath,
            &prov
            );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 1180);
        }
        pPath = pwcsFullPath;
    }


    // Bind to the object either by GUID or by name

    P<CImpersonate> pCleanupRevertImpersonation;
    hr = BindToObject(
            Provider,
            Context,
            pRequestContext,
            pPath,
            NULL,
            IID_IADs,
            (VOID *)&pIADs,
            &pCleanupRevertImpersonation);
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 1190);
        return( MQDS_OBJECT_NOT_FOUND);
    }

    //
    // get object info if requested. don't fail if the request fails,
    // just mark the failure in the request's status
    //
    if (pObjInfoRequest)
    {
        pObjInfoRequest->hrStatus =
            GetObjectPropsCached(pIADs.get(),
                                 pObjInfoRequest->cProps,
                                 pObjInfoRequest->pPropIDs,
                                 pRequestContext,
                                 pObjInfoRequest->pPropVars
                                 );
    }

    // Get parent ADSPath

    hr = pIADs->get_Parent(&bs);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 360);
    }
    BS  bstrParentADsPath(bs);
    SysFreeString(bs);

    // Get the container object.

    hr = ADsOpenObject( 
			bstrParentADsPath,
			NULL,
			NULL,
			ADS_SECURE_AUTHENTICATION,
			IID_IADsContainer,
			(void**)&pContainer
			);

    LogTraceQuery(bstrParentADsPath, s_FN, 369);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 370);
    }

    // Get the object relative name in container

    hr = pIADs->get_Name(&bs);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 380);
    }
    BS  bstrRDN(bs);
    SysFreeString(bs);

    // Get the object schema class

    hr = pIADs->get_Class(&bs);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 390);
    }
    BS  bstrClass(bs);
    SysFreeString(bs);


    // Release the object itself
    // NB: important to do it before deleting the underlying DS object
    IADs *pIADs1 = pIADs.detach();
    pIADs1->Release();

    // Finally, delete the object.

    hr = pContainer->Delete(bstrClass, bstrRDN);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 400);
    }

    //
    // get parent info if requested. don't fail if the request fails,
    // just mark the failure in the request's status
    //
    if (pParentInfoRequest)
    {
        pParentInfoRequest->hrStatus = GetParentInfo( bstrParentADsPath,
                                                      pRequestContext,
                                                      pContainer.get(),
                                                      pParentInfoRequest,
                                                      pCleanupRevertImpersonation) ;
    }

    return MQ_OK;
}

/*====================================================
    CADSI::DeleteContainerObjects()
    Deletes all the object of the specified container
=====================================================*/
HRESULT CADSI::DeleteContainerObjects(
            IN DS_PROVIDER      provider,
            IN DS_CONTEXT       Context,
            IN CDSRequestContext *pRequestContext,
            IN LPCWSTR          pwcsContainerName,
            IN const GUID *     pguidContainerId,
            IN LPCWSTR          pwcsObjectClass)
{
    HRESULT               hr;
    R<IADsContainer>      pContainer  = NULL;
    ASSERT( provider != eGlobalCatalog);
    //
    // Get container interface
    //
    P<CImpersonate> pCleanupRevertImpersonation;
    hr = BindToObject(provider,
                      Context,
                      pRequestContext,
                      pwcsContainerName,
                      pguidContainerId,
                      IID_IADsContainer,
                      (void**)&pContainer,
                      &pCleanupRevertImpersonation);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 410);
    }
    //
    //  Bind to IDirectorySearch interface of the requested container
    //
    R<IDirectorySearch> pDSSearch = NULL;
    ADS_SEARCH_HANDLE   hSearch;

    P<CImpersonate> pDummy;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = BindToObject(provider,
                      Context,
                      &requestDsServerInternal,
                      pwcsContainerName,
                      pguidContainerId,
                      IID_IDirectorySearch,
                      (VOID *)&pDSSearch,
                      &pDummy);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 420);
    }
    ADSVALUE adsv1;
    adsv1.dwType  = ADSTYPE_BOOLEAN;
    adsv1.Boolean = FALSE;

    ADS_SEARCHPREF_INFO pref;
    pref.dwSearchPref   = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
    pref.dwStatus       = ADS_STATUS_S_OK;
    CopyMemory(&pref.vValue, &adsv1, sizeof(ADSVALUE));

    hr = pDSSearch->SetSearchPreference(&pref, 1);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 430);
    }

    //
    //  Search for all the objects of the requested class
    //
    WCHAR pwszSearchFilter[200];

    swprintf(
         pwszSearchFilter,
         L"%s%s%s",
         x_ObjectClassPrefix,
         pwcsObjectClass,
         x_ObjectClassSuffix
         );
    LPWSTR pwcsAttribute =  const_cast<WCHAR*>(x_AttrCN);
    hr = pDSSearch->ExecuteSearch(
            pwszSearchFilter,
            &pwcsAttribute,
            1,
            &hSearch);
    LogTraceQuery(pwszSearchFilter, s_FN, 439);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 440);
    }

    CAutoCloseSearchHandle cCloseSearchHandle(pDSSearch.get(), hSearch);

    BS bstrClass(pwcsObjectClass);

    while ( SUCCEEDED(hr = pDSSearch->GetNextRow( hSearch))
          && ( hr != S_ADS_NOMORE_ROWS))
    {

        ADS_SEARCH_COLUMN Column;
        //
        // Ask for the column itself
        //
        hr = pDSSearch->GetColumn(
                     hSearch,
                     const_cast<WCHAR *>(x_AttrCN),
                     &Column);

        if (FAILED(hr))       //e.g.E_ADS_COLUMN_NOT_SET
        {
            //
            //  continue with deleting other objects in the container
            //
            continue;
        }

        CAutoReleaseColumn CleanColumn( pDSSearch.get(), &Column);

        DWORD dwNameLen = wcslen( Column.pADsValues->DNString);
        DWORD len = dwNameLen*2 + x_CnPrefixLen + 1;
        AP<WCHAR> pwcsRDN = new WCHAR[ len];

        wcscpy(pwcsRDN, x_CnPrefix);
        FilterSpecialCharacters(Column.pADsValues->DNString, dwNameLen, pwcsRDN + x_CnPrefixLen);

        BS bstrRDN( pwcsRDN);
        //
        //  delete the object
        //
        hr = pContainer->Delete(bstrClass, bstrRDN);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 450);
        }

    }
    return LogHR(hr, s_FN, 1200);
}



/*====================================================
    CADSI::GetParentName()
    Get the parent name of specified DS object
        Accepts  pguidUniqueId as identitiy of object
=====================================================*/
HRESULT CADSI::GetParentName(
            IN  DS_PROVIDER     Provider,		    // local DC or GC
            IN  DS_CONTEXT      Context,
            IN  CDSRequestContext *pRequestContext,
            IN  const GUID *    pguidUniqueId,      // unique id of object
            OUT LPWSTR *        ppwcsParentName
            )
{
    *ppwcsParentName = NULL;

    HRESULT               hr;
    BSTR                  bs;
    R<IADs>               pIADs       = NULL;
    R<IADsContainer>      pContainer  = NULL;

    // Bind to the object by GUID

    P<CImpersonate> pCleanupRevertImpersonation;
    hr = BindToObject(
            Provider,
            Context,
            pRequestContext,
            NULL,
            pguidUniqueId,
            IID_IADs,
            (VOID *)&pIADs,
            &pCleanupRevertImpersonation);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 460);
    }

    // Get parent ADSPath

    hr = pIADs->get_Parent(&bs);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 470);
    }
    PBSTR pClean( &bs);
    //
    //  Calculate the parent name length, allocate and copy
    //  without the LDAP:/ prefix
    //
    WCHAR * pwcs = bs;
    while ( *pwcs != L'/')
    {
        pwcs++;
    }
    pwcs += 2;
    if ( Provider == eLocalDomainController)
    {
        //
        //  skip theserver name
        //
        while ( *pwcs != L'/')
        {
            pwcs++;
        }
        pwcs++;
    }

    DWORD len = lstrlen(pwcs);
    *ppwcsParentName = new WCHAR[ len + 1];
    wcscpy( *ppwcsParentName, pwcs);

    return( MQ_OK);
}

/*====================================================
    CADSI::GetParentName()
    Get the parent name of specified DS object
        Accepts  pwcsChildName as the name of the child object
=====================================================*/
HRESULT CADSI::GetParentName(
            IN  DS_PROVIDER     Provider,		     // local DC or GC
            IN  DS_CONTEXT      Context,
            IN  CDSRequestContext *pRequestContext,
            IN  LPCWSTR         pwcsChildName,       //
            OUT LPWSTR *        ppwcsParentName
            )
{
    *ppwcsParentName = NULL;

    HRESULT               hr;
    BSTR                  bs;
    R<IADs>               pIADs       = NULL;
    R<IADsContainer>      pContainer  = NULL;

    // Bind to the object by GUID

    P<CImpersonate> pCleanupRevertImpersonation;
    hr = BindToObject(
            Provider,
            Context,
            pRequestContext,
            pwcsChildName,
            NULL,
            IID_IADs,
            (VOID *)&pIADs,
            &pCleanupRevertImpersonation);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 480);
    }

    // Get parent ADSPath

    hr = pIADs->get_Parent(&bs);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 490);
    }
    PBSTR pClean( &bs);
    //
    //  Calculate the parent name length, allocate and copy
    //  without the LDAP:/ prefix
    //
    WCHAR * pwcs = bs;
    while ( *pwcs != L'/')
    {
        pwcs++;
    }
    pwcs += 2;
    if ( Provider == eLocalDomainController)
    {
        //
        //  skip theserver name
        //
        while ( *pwcs != L'/')
        {
            pwcs++;
        }
        pwcs++;
    }

    DWORD len = lstrlen(pwcs);
    *ppwcsParentName = new WCHAR[ len + 1];
    wcscpy( *ppwcsParentName, pwcs);

    return( MQ_OK);
}

/*====================================================
    CADSI::BindRootOfForest()
=====================================================*/
HRESULT CADSI::BindRootOfForest(
                        OUT void           *ppIUnk)
{
    HRESULT hr;
    R<IADsContainer> pDSConainer = NULL;

	hr = ADsOpenObject(
            const_cast<WCHAR *>(x_GcRoot),
			NULL,
			NULL,
			ADS_SECURE_AUTHENTICATION, 
            IID_IADsContainer,
            (void**)&pDSConainer
			);

    LogTraceQuery(const_cast<WCHAR *>(x_GcRoot), s_FN, 1209);
    if FAILED((hr))
    {
        DBGMSG((DBGMOD_DS, DBGLVL_TRACE, TEXT("CADSI::BindRootOfForest failed to get object %lx"), hr));
        return LogHR(hr, s_FN, 1210);
    }
    R<IUnknown> pUnk = NULL;
    hr =  pDSConainer->get__NewEnum(
            (IUnknown **)&pUnk);
    if FAILED((hr))
    {
        DBGMSG((DBGMOD_DS, DBGLVL_TRACE, TEXT("CADSI::BindRootOfForest failed to get enum %lx"), hr));
        return LogHR(hr, s_FN, 1220);
    }

    R<IEnumVARIANT> pEnumerator = NULL;
    hr = pUnk->QueryInterface(
                    IID_IEnumVARIANT,
                    (void **)&pEnumerator);

    CAutoVariant varOneElement;
    ULONG cElementsFetched;
    hr =  ADsEnumerateNext(
            pEnumerator.get(),  //Enumerator object
            1,             //Number of elements requested
            &varOneElement,           //Array of values fetched
            &cElementsFetched  //Number of elements fetched
            );
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS, DBGLVL_TRACE, TEXT("CADSI::BindRootOfForest failed to enumerate next %lx"), hr));
        return LogHR(hr, s_FN, 1230);
    }
    if ( cElementsFetched == 0)
    {
        return LogHR(MQ_ERROR, s_FN, 1240);
    }

    hr = ((VARIANT &)varOneElement).punkVal->QueryInterface(
            IID_IDirectorySearch,
            (void**)ppIUnk);

    return LogHR(hr, s_FN, 1250);

}
/*====================================================
    CADSI::BindToObject()
    Binds to the DS object either by name or by GUID
        Accepts either lpwcsPathName or pguidUniqueId but not both
        Returns MQ_ERROR_INVALID_PARAMETER if both or none were given

=====================================================*/
HRESULT CADSI::BindToObject(
            IN DS_PROVIDER      Provider,		    // local DC or GC
            IN DS_CONTEXT       Context,            // DS context
            IN CDSRequestContext *pRequestContext,
            IN LPCWSTR          lpwcsPathName,      // object name
            IN const GUID      *pguidUniqueId,
            IN REFIID           riid,               // requwsted interface
            OUT void           *ppIUnk,
            OUT CImpersonate **    ppImpersonate)
{
    HRESULT             hr;

    ASSERT(  (pguidUniqueId != NULL) ^ (lpwcsPathName != NULL));
    if (pguidUniqueId == NULL && lpwcsPathName == NULL)
    {
        return LogHR(MQ_ERROR, s_FN, 1260);
    }
    BOOL fBindRootOfForestForSearch = FALSE;

    if (pguidUniqueId != NULL)
    {
        HRESULT hr2 = BindToGUID(
                            Provider,
                            Context,
                            pRequestContext,
                            pguidUniqueId,
                            riid,
                            ppIUnk,
                            ppImpersonate);
        return LogHR(hr2, s_FN, 1270);

    }
    else
    {
        ASSERT(lpwcsPathName != NULL);
    }

    DWORD len = wcslen( lpwcsPathName);

    //
    //  Add provider prefix
    //
    AP<WCHAR> pwdsADsPath = new
      WCHAR [  len + g_dwServerNameLength + x_providerPrefixLength + 2];

	bool fServerName = false;
    switch(Provider)
    {
    case eDomainController:
        wcscpy(pwdsADsPath, x_LdapProvider);
        break;

    case eGlobalCatalog:
        wcscpy(pwdsADsPath, x_GcProvider);
        if (riid ==  IID_IDirectorySearch)
        {
            fBindRootOfForestForSearch = TRUE;
        }
        break;

    case eLocalDomainController:
        swprintf(
            pwdsADsPath,
             L"%s%s"
             L"/",
            x_LdapProvider,
            g_pwcsServerName
            );
		fServerName = true;
        break;

	case eSpecificObjectInGlobalCatalog:
        wcscpy(pwdsADsPath, x_GcProvider);
		break;

    default:
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1300);
        break;
    }
    //
    //  Impersonation is postopend to after translating
    //  guid -> pathname
    //
    BOOL fImpersonate = pRequestContext->NeedToImpersonate();
    if ( fImpersonate)
    {
        hr = MQSec_GetImpersonationObject( fImpersonate,
                                           fImpersonate,
                                           ppImpersonate ) ;
        ASSERT(SUCCEEDED(hr)) ;

        if ((*ppImpersonate)->GetImpersonationStatus() != 0)
        {
            return LogHR(MQ_ERROR_CANNOT_IMPERSONATE_CLIENT, s_FN, 1310);
        }
    }

    if ( fBindRootOfForestForSearch)
    {
        hr = BindRootOfForest(
                (void**)ppIUnk);
    }
    else
    {
        wcscat(pwdsADsPath, lpwcsPathName);

		DWORD Flags = ADS_SECURE_AUTHENTICATION;
		if(fServerName)
		{
			Flags |= ADS_SERVER_BIND;
		}

        hr = ADsOpenObject( 
				pwdsADsPath,
				NULL,
				NULL,
				Flags,
				riid,
				(void**) ppIUnk
				);

		LOG_ADSI_ERROR(hr);
        LogTraceQuery(pwdsADsPath, s_FN, 1319);

        if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE))
        {
            //
            //  Most likely that this indicates that access is denied.
            //  LDAP doesn't return an access denied error in order not
            //  to have a security breach since the caller doesn't have
            //  permission to know that this attribute even exists.
            //
            //  The best that we can do is to return an object not found error
            //
            hr = HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT);
        }
    }
    return LogHR(hr, s_FN, 1320);

}

HRESULT CADSI::BindToGuidNotInLocalDC(
            IN DS_PROVIDER         Provider,		
            IN DS_CONTEXT          Context,         // DS context
            IN CDSRequestContext * pRequestContext,
            IN const GUID *        pguidObjectId,
            IN REFIID              riid,            // requested interface
            OUT VOID             *ppIUnk,            // Interface
            OUT CImpersonate **    ppImpersonate)
/*++

Routine Description:
    This routine handles bind to an object according to its guid, when the object
    is not on the local-DC. In such case using the format <GUID= ...> doesn't work.
    Therefore in this case we translate the guid to pathname.

Arguments:

Return Value:
--*/
{
    DS_PROVIDER bindProvider = Provider;
    //
    // Find object by GUID
    //
    //  Currently - locate the object according to its
    //  unique id, and find its distingushed name.
    //
	DS_PROVIDER providerFullPath = Provider;

	//
	//	Even though we locate a specific object in the DS,
	//  the guid to name translation should be performed
	//  from the root of the DS.
	//
	if ( providerFullPath == eSpecificObjectInGlobalCatalog)
	{
		providerFullPath = eGlobalCatalog;
	}
    AP<WCHAR> pwcsFullPathName;
    HRESULT hr;
    hr =  FindObjectFullNameFromGuid(
                    providerFullPath,
                    Context,
                    pguidObjectId,
                    TRUE, // try GC too
                    &pwcsFullPathName,
                    &bindProvider
                    );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1330);
    }

    //
    //  Decide which provider to use, according to the requested provider
    //  and the provider where the object was found
    //
    //  bindProvider will be different from the Provider: (bindProvider is either eLocalDomain or eGlobalDomain)
    // 1) Provider: eDomainController. In this case we want to change it only if
    //    the object was found in local-domain
    // 2) Provider: eSpecificObjectInGlobalCatalog. In this case ignore BindProvider
    //
    if (!(( Provider == eDomainController) &&
        ( bindProvider == eLocalDomainController)))
	{
		bindProvider = Provider;
	}
    HRESULT hr2 = BindToObject(
            bindProvider,		
            Context,
            pRequestContext,
            pwcsFullPathName,
            NULL,
            riid,
            ppIUnk,
            ppImpersonate);

    return LogHR(hr2, s_FN, 1340);
}

HRESULT CADSI::BindToGUID(
        IN DS_PROVIDER         Provider,		// local DC or GC
        IN DS_CONTEXT          Context,         // DS context
        IN CDSRequestContext * pRequestContext,
        IN const GUID *        pguidObjectId,
        IN REFIID              riid,            // requested interface
        OUT VOID*              ppIUnk,            // Interface
        OUT CImpersonate **    ppImpersonate)
/*++

Routine Description:
    This routine handles bind to an object according to its guid.

Arguments:

Return Value:
--*/
{
    HRESULT             hr;
    //
    //  We can use the guid format only if the object is in the local domain
    //  or in the GC.
    //
    if ( Provider == eDomainController)
    {
        HRESULT hr2 = BindToGuidNotInLocalDC(
                        Provider,
                        Context,
                        pRequestContext,
                        pguidObjectId,
                        riid,
                        ppIUnk,
                        ppImpersonate
                        );

        return LogHR(hr2, s_FN, 1350);

    }
    //
    // bind to object by GUID using the GUID format
    //
    ASSERT( Provider != eDomainController);

    //
    //  prepare the ADS string provider prefix
    //
    AP<WCHAR> pwdsADsPath = new
      WCHAR [ x_GuidPrefixLen +(2 * sizeof(GUID)) + g_dwServerNameLength + x_providerPrefixLength + 3];

	bool fServerName = false;
    switch(Provider)
    {
    case eGlobalCatalog:
	case eSpecificObjectInGlobalCatalog:
        wcscpy(pwdsADsPath, x_GcProvider);
        break;

    case eLocalDomainController:
        swprintf(
            pwdsADsPath,
             L"%s%s"
             L"/",
            x_LdapProvider,
            g_pwcsServerName
            );
		fServerName = true;
        break;

    default:
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1360);
        break;
    }
    //
    //  Impersonate the caller if required
    //
    BOOL fImpersonate = pRequestContext->NeedToImpersonate();
    if ( fImpersonate)
    {
        hr = MQSec_GetImpersonationObject( fImpersonate,
                                           fImpersonate,
                                           ppImpersonate ) ;
        ASSERT(SUCCEEDED(hr)) ;

        if ((*ppImpersonate)->GetImpersonationStatus() != 0)
        {
            return LogHR(MQ_ERROR_CANNOT_IMPERSONATE_CLIENT, s_FN, 1370);
        }
    }
    //
    //  prepare the guid string
    //
    WCHAR wcsGuid[1 + STRLEN(x_GuidPrefix) + 2 * sizeof(GUID) + 1];
    unsigned char * pTmp = (unsigned char *)pguidObjectId;
    wsprintf(  wcsGuid,
               L"%s%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%s",
               x_GuidPrefix,
               pTmp[0], pTmp[1], pTmp[2], pTmp[3], pTmp[4], pTmp[5], pTmp[6], pTmp[7],
               pTmp[8], pTmp[9], pTmp[10], pTmp[11], pTmp[12], pTmp[13], pTmp[14], pTmp[15],
               L">"
                );
    ASSERT(wcslen(wcsGuid) + 1 <= ARRAY_SIZE(wcsGuid));
    wcscat( pwdsADsPath, wcsGuid);

	DWORD Flags = ADS_SECURE_AUTHENTICATION;
	if(fServerName)
	{
		Flags |= ADS_SERVER_BIND;
	}

    hr = ADsOpenObject( 
			pwdsADsPath,
			NULL,
			NULL,
			Flags,
			riid,
			(void**) ppIUnk
			);

    LogTraceQuery(pwdsADsPath, s_FN, 1379);
    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE))
    {
        //
        //  Most likely that this indicates that access is denied.
        //  LDAP doesn't return an access denied error in order not
        //  to have a security breach since the caller doesn't have
        //  permission to know that this attribute even exists.
        //
        //  The best that we can do is to return an object not found error
        //
        hr = HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT);
    }

    return LogHR(hr, s_FN, 1380);
}



HRESULT CADSI::BindForSearch(
        IN DS_PROVIDER         Provider,		// local DC or GC
        IN DS_CONTEXT          Context,         // DS context
        IN CDSRequestContext * pRequestContext,
        IN const GUID *        pguidUniqueId,
        IN BOOL                fSorting,
        OUT VOID *             ppIUnk,            // Interface
        OUT CImpersonate **    ppImpersonate)
/*++

Routine Description:
    This routine handles bind when the requested interface is IDirectorySearch

Arguments:

Return Value:
--*/

{
    HRESULT             hr;
    BOOL fBindRootOfForestForSearch = FALSE;


    if (pguidUniqueId != NULL)
    {
        HRESULT hr2 = BindToGUID(
                            Provider,
                            Context,
                            pRequestContext,
                            pguidUniqueId,
                            IID_IDirectorySearch,
                            ppIUnk,
                            ppImpersonate);

        return LogHR(hr2, s_FN, 1390);
    }

    DWORD len = 0;
    //
    //  assume the length ( this is for locating of "known" folders
    //  under impersonation).
    //
    static DWORD dwMaxFolderNameLen = 0;
    if ( dwMaxFolderNameLen == 0)
    {
        dwMaxFolderNameLen = wcslen(g_pwcsLocalDsRoot) + wcslen(g_pwcsMsmqServiceContainer);
    }
    len =  dwMaxFolderNameLen;


    //
    //  Add provider prefix
    //
    WCHAR * pwcsFullPathName = NULL;
    AP<WCHAR> pwdsADsPath = new
      WCHAR [ (2 * len) + g_dwServerNameLength + x_providerPrefixLength + 2];
    //
    //  Try to use already bound search interfaces whenever possible ( to
    //  save the bind time)
    //
	bool fServerName = false;
    switch(Provider)
    {
    case eGlobalCatalog:
        if(( !pRequestContext->NeedToImpersonate()) &&
           ( Context == e_RootDSE )                 &&
           ( !fSorting )                            &&
           ( pguidUniqueId == NULL))
        {
            //
            // When sorting is needed, do not  use the global
            // IDirectorySearch pointer. Rather, create a new one.
            // Sorting need different preferences.
            //
            m_pSearchGlobalCatalogRoot->AddRef();

            *(IDirectorySearch **)ppIUnk = m_pSearchGlobalCatalogRoot.get();
            return MQ_OK;
        }

        fBindRootOfForestForSearch = TRUE;
        break;

    case eLocalDomainController:
        {
            if ( ( !pRequestContext->NeedToImpersonate()) &&
                ( pguidUniqueId == NULL))
            {
                switch ( Context)
                {
                case e_RootDSE:
                    m_pSearchLocalDomainController->AddRef();
                    *(IDirectorySearch **)ppIUnk = m_pSearchLocalDomainController.get();
                    return MQ_OK;
                    break;
                case e_ConfigurationContainer:
                    m_pSearchConfigurationContainerLocalDC->AddRef();
                    *(IDirectorySearch **)ppIUnk = m_pSearchConfigurationContainerLocalDC.get();
                    return MQ_OK;
                    break;
                case e_SitesContainer:
                    m_pSearchSitesContainerLocalDC->AddRef();
                    *(IDirectorySearch **)ppIUnk = m_pSearchSitesContainerLocalDC.get();
                    return MQ_OK;
                    break;
                case e_MsmqServiceContainer:
                    if (  m_pSearchMsmqServiceContainerLocalDC.get() != NULL)
                    {
                        m_pSearchMsmqServiceContainerLocalDC->AddRef();
                        *(IDirectorySearch **)ppIUnk = m_pSearchMsmqServiceContainerLocalDC.get();
                        return MQ_OK;
                    }
                    break;
                }
            }
            //
            //  The contaner name is resolved according to the context
            //
            switch (Context)
            {
            case e_RootDSE:
                pwcsFullPathName = g_pwcsLocalDsRoot;
                break;
            case e_ConfigurationContainer:
                pwcsFullPathName = g_pwcsConfigurationContainer;
                break;
            case e_SitesContainer:
                pwcsFullPathName = g_pwcsSitesContainer;
                break;
            case e_MsmqServiceContainer:
                pwcsFullPathName = g_pwcsMsmqServiceContainer;
                break;
            case e_ServicesContainer:
                pwcsFullPathName = g_pwcsServicesContainer;
                break;
            default:
                ASSERT(0);
                break;
            }
            swprintf(
                pwdsADsPath,
                 L"%s%s"
                 L"/",
                x_LdapProvider,
                g_pwcsServerName
                );
			fServerName = true;
        }
        break;

	case eSpecificObjectInGlobalCatalog:
        wcscpy(pwdsADsPath, x_GcProvider);
		break;


    default:
        ASSERT(0);
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1400);
        break;
    }
    //
    //  Impersonation is postopend to after translating
    //  guid -> pathname
    //
    BOOL fImpersonate = pRequestContext->NeedToImpersonate();
    if ( fImpersonate)
    {
        hr = MQSec_GetImpersonationObject( fImpersonate,
                                           fImpersonate,
                                           ppImpersonate ) ;
        ASSERT(SUCCEEDED(hr)) ;

        if ((*ppImpersonate)->GetImpersonationStatus() != 0)
        {
            return LogHR(MQ_ERROR_CANNOT_IMPERSONATE_CLIENT, s_FN, 1410);
        }
    }

    if ( fBindRootOfForestForSearch)
    {
        hr = BindRootOfForest( (void**)ppIUnk );
    }
    else
    {
        if (pwcsFullPathName != NULL)
        {
            wcscat(pwdsADsPath,pwcsFullPathName);
        }

		DWORD Flags = ADS_SECURE_AUTHENTICATION;
		if(fServerName)
		{
			Flags |= ADS_SERVER_BIND;
		}

        hr = ADsOpenObject( 
				pwdsADsPath,
				NULL,
				NULL,
				Flags,
				IID_IDirectorySearch,
				(void**) ppIUnk
				);

        LogTraceQuery(pwdsADsPath, s_FN, 1419);
    }
    return LogHR(hr, s_FN, 1420);
}


/*====================================================
    CADSI::SetObjectPropsCached()
    Sets properties of the opened IADS object (i.e.in cache)
=====================================================*/
HRESULT CADSI::SetObjectPropsCached(
        IN DS_OPERATION          operation,              // type of DS operation performed
        IN IADs *                pIADs,                  // object's pointer
        IN DWORD                 cPropIDs,               // number of attributes
        IN const PROPID *        pPropIDs,               // name of attributes
        IN const MQPROPVARIANT * pPropVars)              // attribute values
{
    HRESULT           hr;

    for (DWORD i = 0; i<cPropIDs; i++)
    {
        VARIANT vProp;
		VariantInit(&vProp);
 
        //
        // Get property info
        //
        const MQTranslateInfo *pTranslate;
        if(!g_PropDictionary.Lookup(pPropIDs[i], pTranslate))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 1430);
        }

        CMQVariant    propvarToSet;
        const PROPVARIANT * ppvarToSet;
        PROPID        dwPropidToSet;
        //
        // if the property is in the DS, set the given property with given value
        //
        if (pTranslate->vtDS != ADSTYPE_INVALID)
        {
            ppvarToSet = &pPropVars[i];
            dwPropidToSet = pPropIDs[i];
            //
            //  In addition if set routine is configured for this property call it
            //
            if ((pTranslate->SetPropertyHandle)  &&
                ( operation == eSet))
            {
                hr = pTranslate->SetPropertyHandle( pIADs, &pPropVars[i], &dwPropidToSet, propvarToSet.CastToStruct());
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 500);
                }
            }
       }
        else if (pTranslate->SetPropertyHandle)
        {
            //
            // the property is not in the DS, but has a set routine, use it
            // to get the new property & value to set
            //
            hr = pTranslate->SetPropertyHandle( pIADs, &pPropVars[i], &dwPropidToSet, propvarToSet.CastToStruct());
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 510);
            }
            ASSERT( dwPropidToSet != 0);
            ppvarToSet = propvarToSet.CastToStruct();
            //
            // Get replaced property info
            //
            if(!g_PropDictionary.Lookup(dwPropidToSet, pTranslate))
            {
                ASSERT(0);
                return LogHR(MQ_ERROR, s_FN, 1440);
            }
        }
        else
        {
            //
            // the property is not in the DS, and doesn't have a set routine.
            // ignore it.
            //
            continue;
        }

        BS bsPropName(pTranslate->wcsPropid);

        if ( ( ppvarToSet->vt & VT_VECTOR && ppvarToSet->cauuid.cElems == 0) || // counted array with 0 elements
             ( ppvarToSet->vt == VT_BLOB && ppvarToSet->blob.cbSize == 0) || // an empty blob
             ( ppvarToSet->vt == VT_LPWSTR && wcslen( ppvarToSet->pwszVal) == 0)) // an empty string
        {
            //
            //  ADSI doesn't allow to create an object while specifing
            //  some of its attributes as not-available. Therefore on
            //  create we ignore the "empty" properties
            //
            if ( operation == eCreate)
            {
                continue;
            }
            hr = pIADs->PutEx( ADS_PROPERTY_CLEAR,
                               bsPropName,
                               vProp);
            LogTraceQuery(bsPropName, s_FN, 519);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 520);
            }
        }
        else if (pTranslate->vtDS == ADSTYPE_NT_SECURITY_DESCRIPTOR)
        {
			//Security we set via IDirectoryObject later, here ignoring
		}
        else
        {
            hr = MqVal2Variant(&vProp, ppvarToSet, pTranslate->vtDS);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 530);
            }

            hr = pIADs->Put(bsPropName, vProp);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 540);
            }

            VariantClear(&vProp);
        }
    }

    return MQ_OK;
}

/*====================================================
    CADSI::SetDirObjectProps()
    Sets properties via IDirectoryObject
=====================================================*/

HRESULT CADSI::SetDirObjectProps(
        IN DS_OPERATION          operation,              // type of DS operation performed
        IN IADs *                pIADs,                  // object's pointer
        IN const DWORD           cPropIDs,               // number of attributes
        IN const PROPID *        pPropIDs,               // name of attributes
        IN const MQPROPVARIANT * pPropVars,              // attribute values
        IN const DWORD           dwObjectType,           // MSMQ1.0 obj type
        IN       BOOL            fUnknownUser )
{
    HRESULT           hr;
	UNREFERENCED_PARAMETER(operation);

    for (DWORD i = 0; i<cPropIDs; i++)
    {
        //
        // Get property info
        //
        const MQTranslateInfo *pTranslate;
        if(!g_PropDictionary.Lookup(pPropIDs[i], pTranslate))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 1450);
        }

        BS bsPropName(pTranslate->wcsPropid);

        if ( pTranslate->vtDS == ADSTYPE_NT_SECURITY_DESCRIPTOR )
        {
			//
            // Set Security via IDirectoryObject.
            // IADs require the security descriptor in a "object oriented"
            // form. Only IDIrectoryObject accept the "old" style of
            // SECURITY_DESCRIPTOR.
            //
            PSID pComputerSid = NULL ;
            BOOL fDefaultInfo = TRUE ;
            SECURITY_INFORMATION seInfo = MQSEC_SD_ALL_INFO ;
            if ((i == 0) && (cPropIDs == 2))
            {
                if ((pPropIDs[1] == PROPID_Q_SECURITY_INFORMATION) ||
                    (pPropIDs[1] == PROPID_QM_SECURITY_INFORMATION))
                {
                    seInfo = pPropVars[1].ulVal ;
                    fDefaultInfo = FALSE ;
                }
            }
            else
            {
                for ( DWORD j = 0 ; j < cPropIDs ; j++ )
                {
                    if (pPropIDs[j] == PROPID_COM_SID)
                    {
                        pComputerSid = (PSID) pPropVars[j].blob.pBlobData ;
                        ASSERT(IsValidSid(pComputerSid)) ;
                        break ;
                    }
                }
            }

            if (fUnknownUser && fDefaultInfo)
            {
                //
                // Don't set owner if impersonated as local user. It is set
                // by default by the ADS code.
                //
                seInfo &= (~(OWNER_SECURITY_INFORMATION |
                             GROUP_SECURITY_INFORMATION) ) ;
            }

            hr = SetObjectSecurity( pIADs,
                                    bsPropName,
                                    &pPropVars[i],
                                    pTranslate->vtDS,
                                    dwObjectType,
                                    seInfo,
                                    pComputerSid ) ;

            if ((hr == MQ_ERROR_ACCESS_DENIED) && fDefaultInfo)
            {
                ASSERT((seInfo == MQSEC_SD_ALL_INFO) || fUnknownUser) ;
                //
                // Caller did not explicitely specify the security_information
                // he wants to set. By default we try to set all components,
                // including SACL. For setting SACL, you must have the
                // SE_SECURITY privilege, and the call to DS will fail if
                // you don't have that privilege.
                // So check if SACL is indeed included in the security
                // descriptor. If not, call SetObjectSecurity() again,
                // without the SACL_SECURITY_INFORMATION bit.
                //
                SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR*)
                                            pPropVars[i].blob.pBlobData ;
                PACL  pAcl = NULL ;
                BOOL  bPresent = FALSE ;
                BOOL  bDefaulted ;

                BOOL bRet = GetSecurityDescriptorSacl( pSD,
                                                      &bPresent,
                                                      &pAcl,
                                                      &bDefaulted );
                ASSERT(bRet);
				DBG_USED(bRet);

                if (bPresent && pAcl)
                {
                    //
                    // Caller supplied a SACL. fail.
                    // This is an incompatibility with MSMQ1.0, because
                    // on MSMQ1.0, it was possible to call MQCreateQueue(),
                    // with a security descriptor that include a SACL and
                    // that call succeeded even if caller didn't have the
                    // SE_SECURITY privilege.
                    //
                    return LogHR(hr, s_FN, 1460);
                }

                seInfo &= ~SACL_SECURITY_INFORMATION ; // turn off.
                hr = SetObjectSecurity( pIADs,
                                        bsPropName,
                                        &pPropVars[i],
                                        pTranslate->vtDS,
                                        dwObjectType,
                                        seInfo,
                                        pComputerSid );
                LogHR(hr, s_FN, 1637);
            }

#ifdef _DEBUG
            if (FAILED(hr))
            {
                DWORD dwErr = GetLastError() ;
                ULONG dwLErr = LdapGetLastError() ;

                DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
                 "CADSI::SetObjectSecurity failed, LastErr- %lut, LDAPLastErr- %lut"),
                                           dwErr, dwLErr));
            }
#endif

            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 550);
            }
		}
    }

    return MQ_OK;
}

/*====================================================
    CADSI::GetObjectPropsCached()
    Gets properties of the opened IADS object (i.e.from cache)
=====================================================*/
HRESULT CADSI::GetObjectPropsCached(
        IN  IADs            *pIADs,                  // object's pointer
        IN  DWORD            cPropIDs,               // number of attributes
        IN  const PROPID    *pPropIDs,               // name of attributes
        IN  CDSRequestContext * pRequestContext,
        OUT MQPROPVARIANT   *pPropVars)              // attribute values
{
    HRESULT           hr;
    VARIANT           var;

    //
    // Get Object Class
    //
    const MQClassInfo * pClassInfo;
    hr = DecideObjectClass(
            pPropIDs,
            &pClassInfo
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 560);
    }

    //
    // Get DN & guid of object
    //
    AP<WCHAR>         pwszObjectDN;
    P<GUID>          pguidObjectGuid;
    hr = GetDNGuidFromIADs(pIADs, &pwszObjectDN, &pguidObjectGuid);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 570);
    }

    //
    // Get translate info object
    //
    P<CMsmqObjXlateInfo> pcObjXlateInfo;
    hr = (*(pClassInfo->fnGetMsmqObjXlateInfo))(pwszObjectDN, pguidObjectGuid, pRequestContext, &pcObjXlateInfo);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 590);
    }

    // Tell the translate info object about the IADs object to use in order to get necessary DS props
    pcObjXlateInfo->InitGetDsProps(pIADs);

    //
    // Get properties one by one
    //
    for (DWORD dwProp=0; dwProp<cPropIDs; dwProp++)
    {
        //
        // Get property info
        //
        const MQTranslateInfo *pTranslate;
        if(!g_PropDictionary.Lookup(pPropIDs[dwProp], pTranslate))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 1470);
        }

        //
        // if the property is not in the DS, call its retrieve routine
        //
        if (pTranslate->vtDS == ADSTYPE_INVALID)
        {
            if (pTranslate->RetrievePropertyHandle)
            {
                //
                //  Calculate its value
                //
                hr = pTranslate->RetrievePropertyHandle(
                        pcObjXlateInfo,
                        pPropVars + dwProp
                        );
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 600);
                }
                continue;
            }
            else
            {
                //
                // return error if no retrieve routine
                //
                ASSERT(0);
                return LogHR(MQ_ERROR, s_FN, 1480);
            }
        }

        BS bsName(pTranslate->wcsPropid);
        VariantInit(&var);
		BOOL fConvNeeed = TRUE;

        if (pTranslate->fMultiValue)
        {
            hr = pIADs->GetEx(bsName, &var);
            LogTraceQuery(bsName, s_FN, 609);
        }
        else if (pTranslate->vtDS == ADSTYPE_NT_SECURITY_DESCRIPTOR)
        {
            hr = GetObjectSecurity(
                        pIADs,                  // object's pointer
                        cPropIDs,               // number of attributes
                        pPropIDs,               // name of attributes
                        dwProp,                 // index to sec property
                        bsName,                 // name of property
                        pClassInfo->dwObjectType,
                        pPropVars ) ;           // attribute values
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 610);
            }

			fConvNeeed = FALSE;
        }
        else
        {
            hr = pIADs->Get(bsName, &var);
            LogTraceQuery(bsName, s_FN, 619);
        }

        if ( hr == E_ADS_PROPERTY_NOT_FOUND)
        {
            //
            //  No value set for this property,
            //  return the default value
            //
            if (pTranslate->pvarDefaultValue != NULL)
            {
                hr =CopyDefaultValue(
                       pTranslate->pvarDefaultValue,
                       pPropVars + dwProp
                        );
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 620);
                }
                continue;
            }
            else if (pTranslate->RetrievePropertyHandle)
            {
                //
                //  No default value, try to calculate its value
                //
                hr = pTranslate->RetrievePropertyHandle(
                        pcObjXlateInfo,
                        pPropVars + dwProp
                        );
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 630);
                }
                continue;
            }
            return LogHR(hr, s_FN, 1490);
        }

        // Translate OLE variant into MQ property
		if (fConvNeeed)
		{
			hr = Variant2MqVal(pPropVars + dwProp, &var, pTranslate->vtDS, pTranslate->vtMQ);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 640);
            }
		}

        VariantClear(&var);
    }
    return MQ_OK;
}

/*====================================================
    CADSI::FillAttrNames()
    Allocates with PV and fills array of attribite names
=====================================================*/
HRESULT CADSI::FillAttrNames(
            OUT LPWSTR    *          ppwszAttributeNames,  // Names array
            OUT DWORD *              pcRequestedFromDS,    // Number of attributes to pass to DS
            IN  DWORD                cPropIDs,             // Number of Attributes to translate
            IN  const PROPID *       pPropIDs)             // Attributes to translate
{
    DWORD   cRequestedFromDS = 0;
    ULONG   ul;
    BOOL fRequestedDN = FALSE;
    BOOL fRequestedGUID = FALSE;

    for (DWORD i=0; i<cPropIDs; i++)
    {
        //
        // Get property info
        //
        const MQTranslateInfo *pTranslate;
        if(!g_PropDictionary.Lookup(pPropIDs[i], pTranslate))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 1500);
        }

        if (pTranslate->vtDS != ADSTYPE_INVALID)
        {
            // Allocate and fill individual name memory
            ul = (wcslen(pTranslate->wcsPropid) + 1) * sizeof(WCHAR);
            ppwszAttributeNames[cRequestedFromDS] = (LPWSTR)PvAllocMore(ul, ppwszAttributeNames);
            wcscpy(ppwszAttributeNames[cRequestedFromDS], pTranslate->wcsPropid);
            cRequestedFromDS++;
            if (wcscmp(x_AttrDistinguishedName, pTranslate->wcsPropid) == 0)
            {
                fRequestedDN = TRUE;
            }
            else if (wcscmp(x_AttrObjectGUID, pTranslate->wcsPropid) == 0)
            {
                fRequestedGUID = TRUE;
            }
        }
    }

    //
    // Add request for dn if not requested already
    //
    if (!fRequestedDN)
    {
        LPCWSTR pwName = x_AttrDistinguishedName;
        ul = (wcslen(pwName) + 1) * sizeof(WCHAR);
        ppwszAttributeNames[cRequestedFromDS] = (LPWSTR)PvAllocMore(ul, ppwszAttributeNames);
        wcscpy(ppwszAttributeNames[cRequestedFromDS++], pwName);
    }

    //
    // Add request for guid if not requested already
    //
    if (!fRequestedGUID)
    {
        LPCWSTR pwName = x_AttrObjectGUID;
        ul = (wcslen(pwName) + 1) * sizeof(WCHAR);
        ppwszAttributeNames[cRequestedFromDS] = (LPWSTR)PvAllocMore(ul, ppwszAttributeNames);
        wcscpy(ppwszAttributeNames[cRequestedFromDS++], pwName);
    }

    *pcRequestedFromDS = cRequestedFromDS;
    return MQ_OK;
}


/*====================================================
    CADSI::FillSearchPrefs()
    Fills the caller-provided ADS_SEARCHPREF_INFO structure
=====================================================*/
HRESULT CADSI::FillSearchPrefs(
            OUT ADS_SEARCHPREF_INFO *pPrefs,        // preferences array
            OUT DWORD               *pdwPrefs,      // preferences counter
            IN  DS_SEARCH_LEVEL     SearchLevel,	// flat / 1 level / subtree
            IN  const MQSORTSET *   pDsSortkey,     // sort keys array
			OUT      ADS_SORTKEY *  pSortKeys)		// sort keys array in ADSI  format
{
    ADS_SEARCHPREF_INFO *pPref = pPrefs;

    //  Search preferences: Attrib types only = NO

    pPref->dwSearchPref   = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
    pPref->vValue.dwType  = ADSTYPE_BOOLEAN;
    pPref->vValue.Boolean = FALSE;

    pPref->dwStatus       = ADS_STATUS_S_OK;
    (*pdwPrefs)++;
	pPref++;

    //  Asynchronous

    pPref->dwSearchPref   = ADS_SEARCHPREF_ASYNCHRONOUS;
    pPref->vValue.dwType  = ADSTYPE_BOOLEAN;
    pPref->vValue.Boolean = TRUE;

    pPref->dwStatus       = ADS_STATUS_S_OK;
    (*pdwPrefs)++;
	pPref++;

    // Do not chase referrals

    pPref->dwSearchPref   = ADS_SEARCHPREF_CHASE_REFERRALS;
    pPref->vValue.dwType  = ADSTYPE_INTEGER;
    pPref->vValue.Integer = ADS_CHASE_REFERRALS_NEVER;

    pPref->dwStatus       = ADS_STATUS_S_OK;
    (*pdwPrefs)++;
	pPref++;

    // Search preferences: Scope

    pPref->dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE; //ADS_SEARCHPREF
    pPref->vValue.dwType= ADSTYPE_INTEGER;
    switch (SearchLevel)
    {
    case eOneLevel:
        pPref->vValue.Integer = ADS_SCOPE_ONELEVEL;
        break;
    case eSubTree:
        pPref->vValue.Integer = ADS_SCOPE_SUBTREE;
        break;
    default:
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1510);
        break;
    }

    pPref->dwStatus = ADS_STATUS_S_OK;
    (*pdwPrefs)++;
	pPref++;

	// Search preferences: sorting
	if (pDsSortkey && pDsSortkey->cCol)
	{
		for (DWORD i=0; i<pDsSortkey->cCol; i++)
		{
			const MQTranslateInfo *pTranslate;
			if(!g_PropDictionary.Lookup(pDsSortkey->aCol[i].propColumn, pTranslate))
			{
				ASSERT(0);			// Ask to sort on unexisting property
                return LogHR(MQ_ERROR, s_FN, 1520);
			}

			if (pTranslate->vtDS == ADSTYPE_INVALID)
			{
				ASSERT(0);			// Ask to sort on non-ADSI property
                return LogHR(MQ_ERROR, s_FN, 1530);
			}

			pSortKeys[i].pszAttrType = (LPWSTR) pTranslate->wcsPropid;
			pSortKeys[i].pszReserved   = NULL;
			pSortKeys[i].fReverseorder = (pDsSortkey->aCol[i].dwOrder == QUERY_SORTDESCEND);
                                        // Interpreting Descend as Reverse - is it correct?
		}

	    pPref->dwSearchPref  = ADS_SEARCHPREF_SORT_ON;
        pPref->vValue.dwType = ADSTYPE_PROV_SPECIFIC;
        pPref->vValue.ProviderSpecific.dwLength = sizeof(ADS_SORTKEY) * pDsSortkey->cCol;
        pPref->vValue.ProviderSpecific.lpValue =  (LPBYTE)pSortKeys;

	    pPref->dwStatus = ADS_STATUS_S_OK;
		(*pdwPrefs)++;
		pPref++;
	}
    else
    {
        //
        // Bug 299178, page size and sorting are note compatible.
        //
        pPref->dwSearchPref   = ADS_SEARCHPREF_PAGESIZE;
        pPref->vValue.dwType  = ADSTYPE_INTEGER;
        pPref->vValue.Integer = 12;

        pPref->dwStatus       = ADS_STATUS_S_OK;
        (*pdwPrefs)++;
    	pPref++;
    }

    return MQ_OK;
}

/*====================================================
    CADSI::MqPropVal2AdsiVal()
    Translate MQPropVal into ADSI value
=====================================================*/
HRESULT CADSI::MqPropVal2AdsiVal(
      OUT ADSTYPE       *pAdsType,
      OUT DWORD         *pdwNumValues,
      OUT PADSVALUE     *ppADsValue,
      IN  PROPID         propID,
      IN  const MQPROPVARIANT *pPropVar,
      IN  PVOID          pvMainAlloc)
{
    // Find out resulting ADSI type
    //
    // Get property info
    //
    const MQTranslateInfo *pTranslate;
    if(!g_PropDictionary.Lookup(propID, pTranslate))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1540);
    }

    VARTYPE vtSource = pTranslate->vtMQ;

    ASSERT(vtSource == pPropVar->vt);
	DBG_USED(vtSource);

    *pAdsType        = pTranslate->vtDS;

    HRESULT hr2 = MqVal2AdsiVal(
      *pAdsType,
      pdwNumValues,
      ppADsValue,
      pPropVar,
      pvMainAlloc);

    return LogHR(hr2, s_FN, 1550);

}

/*====================================================
    CADSI::AdsiVal2MqPropVal()
    Translates ADSI value into MQ PropVal
=====================================================*/
HRESULT CADSI::AdsiVal2MqPropVal(
      OUT MQPROPVARIANT *pPropVar,
      IN  PROPID        propID,
      IN  ADSTYPE       AdsType,
      IN  DWORD         dwNumValues,
      IN  PADSVALUE     pADsValue)
{

    // Find out target type
    //
    // Get property info
    //
    const MQTranslateInfo *pTranslate;
    if(!g_PropDictionary.Lookup(propID, pTranslate))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1560);
    }

    ASSERT(pTranslate->vtDS == AdsType);

    ASSERT( (dwNumValues == 1) ||
            (dwNumValues >  1) && pTranslate->fMultiValue );

    VARTYPE vtTarget = pTranslate->vtMQ;

    HRESULT hr2 = AdsiVal2MqVal(pPropVar, vtTarget, AdsType, dwNumValues, pADsValue);
    return LogHR(hr2, s_FN, 1570);
}

/*====================================================
    CADSI::MQRestriction2AdsiFilter()
    Translates MQ Restriction into the ADSI Filter format
=====================================================*/
HRESULT CADSI::MQRestriction2AdsiFilter(
        IN  const MQRESTRICTION * pMQRestriction,
        IN  LPCWSTR               pwcsObjectCategory,
        IN  LPCWSTR               pwszObjectClass,
        OUT LPWSTR   *            ppwszSearchFilter
        )
{
    HRESULT hr;
    *ppwszSearchFilter = new WCHAR[1000];   //BUGBUG

    if ((pMQRestriction == NULL) || (pMQRestriction->cRes == 0))
    {
        swprintf(
            *ppwszSearchFilter,
             L"%s%s%s",
            x_ObjectCategoryPrefix,
            pwcsObjectCategory,
            x_ObjectCategorySuffix
            );

        return MQ_OK;
    }
    LPWSTR pw = *ppwszSearchFilter;

    wcscpy(pw, L"(&");
    pw += wcslen(L"(&");
    //
    //  add the object class restriction
    //
    swprintf(
        pw,
         L"%s%s%s",
        x_ObjectCategoryPrefix,
        pwcsObjectCategory,
        x_ObjectCategorySuffix
        );
    pw += x_ObjectCategoryPrefixLen + wcslen(pwcsObjectCategory)+ x_ObjectClassSuffixLen;

    BOOL fNeedToCheckDefaultValues = FALSE;
    //
    //  For queue properties, there is special handling
    //  incase of default values
    //
    if (!wcscmp( MSMQ_QUEUE_CLASS_NAME, pwszObjectClass))
    {
        fNeedToCheckDefaultValues = TRUE;
    }

    for (DWORD iRes = 0; iRes < pMQRestriction->cRes; iRes++)
    {

        //
        // Get property info
        //
        const MQTranslateInfo *pTranslate;
        if(!g_PropDictionary.Lookup(pMQRestriction->paPropRes[iRes].prop, pTranslate))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 1580);
        }

        AP<WCHAR> pwszVal;

        // Get property value, string representation
        hr = MqPropVal2String(&pMQRestriction->paPropRes[iRes].prval,
                              pTranslate->vtDS,
                              &pwszVal);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 650);
        }

        //
        //  Is the property compared to its default value
        //
        BOOL    fAddPropertyNotPresent = FALSE;
        if ( fNeedToCheckDefaultValues)
        {
            fAddPropertyNotPresent = CompareDefaultValue(
                        pMQRestriction->paPropRes[iRes].rel,
                        &pMQRestriction->paPropRes[iRes].prval,
                        pTranslate->pvarDefaultValue);
        }
        DWORD dwBracks = 0;
        if ( fAddPropertyNotPresent)
        {
            //
            //  Add additional restriction that locate all object where
            //  the property is not present.
            //
            swprintf(
                pw,
                L"%s%s%s",
                x_AttributeNotIncludedPrefix,
                pTranslate->wcsPropid,
                x_AttributeNotIncludedSuffix
                );
            pw += x_AttributeNotIncludedPrefixLen + wcslen(pTranslate->wcsPropid) + x_AttributeNotIncludedSuffixLen;
            dwBracks++;
        }
        // Prefix part
        wcscpy(pw, x_PropertyPrefix);
        pw += x_PropertyPrefixLen;

        // Prefix part
        WCHAR wszRel[10];

        switch(pMQRestriction->paPropRes[iRes].rel)
        {
        case PRLT:
            wcscpy(pw, L"!(");
            pw += wcslen(L"!(");
            wcscpy(wszRel, L">=");
            dwBracks++;
            break;

        case PRLE:
            wcscpy(wszRel, L"<=");
            break;

        case PRGT:
            wcscpy(pw, L"!(");
            pw += wcslen(L"!(");
            wcscpy(wszRel, L"<=");
            dwBracks++;
            break;

        case PRGE:
            wcscpy(wszRel, L">=");
            break;

        case PREQ:
            wcscpy(wszRel, L"=");
            break;

        case PRNE:
            wcscpy(pw, L"!(");
            pw += wcslen(L"!(");
            wcscpy(wszRel, L"=");
            dwBracks++;
            break;

        default:
            return LogHR(MQ_ERROR_ILLEGAL_RELATION, s_FN, 1590);
        }

        // Property name
        wcscpy(pw, pTranslate->wcsPropid);
        pw += wcslen(pTranslate->wcsPropid);

        // Property condition
        wcscpy(pw, wszRel);
        pw += wcslen(wszRel);

        // Property value
        wcscpy(pw, pwszVal);
        pw += wcslen(pwszVal);

        // Property suffix
        for (DWORD is=0; is < dwBracks; is++)
        {
            wcscpy(pw, x_PropertySuffix);
            pw += x_PropertySuffixLen;
        }

        // Relation closing bracket
        wcscpy(pw, x_PropertySuffix);
        pw += x_PropertySuffixLen;
    }

    wcscpy(pw, x_PropertySuffix);
    pw += x_PropertySuffixLen;

    return MQ_OK;
}


HRESULT CADSI::LocateObjectFullName(
        IN DS_PROVIDER       Provider,		// local DC or GC
        IN DS_CONTEXT        Context,         // DS context
        IN  const GUID *     pguidObjectId,
        OUT WCHAR **         ppwcsFullName
        )
{
    R<IDirectorySearch> pDSSearch = NULL;
    ADS_SEARCH_HANDLE   hSearch;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    P<CImpersonate> pCleanupRevertImpersonation;
    HRESULT hr = BindForSearch(
                      Provider,
                      Context,
                      &requestDsServerInternal,         // translating guid -> pathname
                                            // should be according to the DS
                                            // server rights.
                      NULL,
                      FALSE,
                      (VOID *)&pDSSearch,
                      &pCleanupRevertImpersonation);
    if (FAILED(hr))                       // e.g. base object does not support search
    {
        return LogHR(hr, s_FN, 1600);
    }

    //
    //  Search the object according to its unique id
    //
    AP<WCHAR>   pwszVal;

    MQPROPVARIANT var;
    var.vt = VT_CLSID;
    var.puuid = const_cast<GUID *>(pguidObjectId);
    hr = MqPropVal2String(&var,
                          ADSTYPE_OCTET_STRING,
                          &pwszVal);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 660);
    }

    ADS_SEARCHPREF_INFO prefs[15];
    DWORD dwNumPrefs = 0;
    hr = FillSearchPrefs(prefs,
                         &dwNumPrefs,
                         eSubTree,
                         NULL,
                         NULL);

    hr = pDSSearch->SetSearchPreference( prefs, dwNumPrefs);
    ASSERT(SUCCEEDED(hr)) ;  // we don't expect this one to fail.
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 670);
    }

    WCHAR pwszSearchFilter[200];   // assuming - object-guid-id string is less than 200

    swprintf(
         pwszSearchFilter,
         L"(objectGUID="
         L"%s"
         L")\0",
         pwszVal
         );
    LPWSTR pwcsAttributes[] =  {const_cast<WCHAR*>(x_AttrDistinguishedName),
                                const_cast<WCHAR*>(x_AttrCN)};

    hr = pDSSearch->ExecuteSearch(
            pwszSearchFilter,
            pwcsAttributes,
            2,
            &hSearch);
    LogTraceQuery(pwszSearchFilter, s_FN, 679);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 680);
    }

    CAutoCloseSearchHandle cCloseSearchHandle(pDSSearch.get(), hSearch);

    //  Get next row
    hr = pDSSearch->GetNextRow( hSearch);
    if ( hr ==  S_ADS_NOMORE_ROWS)
    {
        hr = HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT);
    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 690);
    }

    //
    // Ask for the common name
    //
    ADS_SEARCH_COLUMN ColumnCN;
    hr = pDSSearch->GetColumn(
                 hSearch,
                 const_cast<WCHAR *>(x_AttrCN),
                 &ColumnCN);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 700);
    }

    CAutoReleaseColumn cAutoReleaseColumnCN(pDSSearch.get(), &ColumnCN);

    WCHAR * pwszCommonName = ColumnCN.pADsValues->DNString;
    if (pwszCommonName == NULL)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1610);
    }

    //
    // Ask for the Distinguished name
    //
    ADS_SEARCH_COLUMN ColumnDN;
    hr = pDSSearch->GetColumn(
                 hSearch,
                 const_cast<WCHAR *>(x_AttrDistinguishedName),
                 &ColumnDN);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 710);
    }

    CAutoReleaseColumn cAutoReleaseColumnDN(pDSSearch.get(), &ColumnDN);

    WCHAR * pwszDistinguishedName = ColumnDN.pADsValues->DNString;
    if (pwszDistinguishedName == NULL)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1620);
    }

    //
    // Filter special characters in the common name part of
    // the distinuished name
    //

    //
    // Length of the final buffer: Distinguished Name format is
    // CN=<common name>,....
    // When filtering it, we may add up to <length of common name> characters
    //
    *ppwcsFullName = new WCHAR[ wcslen(pwszDistinguishedName) + wcslen(pwszCommonName) + 1];

    LPWSTR pwstrOut = *ppwcsFullName;
    LPWSTR pwstrIn = pwszDistinguishedName;

    ASSERT(_wcsnicmp(pwstrIn, x_CnPrefix, x_CnPrefixLen) == 0); // "CN="

    wcsncpy(pwstrOut, pwstrIn, x_CnPrefixLen);

    //
    // Skip the prefix after copy
    //
    pwstrOut += x_CnPrefixLen;
    pwstrIn += x_CnPrefixLen;

    //
    // Take the name after the prefix, and filter the special characters out
    //
    DWORD_PTR dwCharactersProcessed;
    FilterSpecialCharacters(pwstrIn, wcslen(pwszCommonName), pwstrOut, &dwCharactersProcessed);
    pwstrOut += wcslen(pwstrOut);
    pwstrIn += dwCharactersProcessed;

    //
    // Copy the remainder of the distinguished name as is
    //
    wcscpy(pwstrOut, pwstrIn);

    return LogHR(hr, s_FN, 1630);
}

//+-----------------------------------------------------
//
//  HRESULT CADSI::FindComputerObjectFullPath()
//
//	pwcsComputerDnsName : if the caller pass the computer DNS name,
//						  (the search itself is according to the computer Netbios
//                         name), then for each result, we verify if the dns name match.
//
//+-----------------------------------------------------

HRESULT CADSI::FindComputerObjectFullPath(
            IN  DS_PROVIDER             provider,
            IN  enumComputerObjType     eComputerObjType,
			IN  LPCWSTR                 pwcsComputerDnsName,
            IN  const MQRESTRICTION *   pRestriction,
            OUT LPWSTR *                ppwcsFullPathName
            )
{
    IDirectorySearch * pDSSearch = NULL;
    ADS_SEARCH_HANDLE   hSearch;

    DWORD dwLen = x_providerPrefixLength + wcslen(g_pwcsServerName) + 10 ;
    P<WCHAR>  wszProvider = new WCHAR[ dwLen ] ;

	bool fServerName = false;
    switch (provider)
    {
    case eLocalDomainController:
        pDSSearch = m_pSearchPathNameLocalDC.get();
        swprintf(
             wszProvider,
             L"%s%s"
             L"/",
            x_LdapProvider,
            g_pwcsServerName
            );
		fServerName = true;
        break;

    case eGlobalCatalog:
        if (eComputerObjType ==  e_RealComputerObject)
        {
			if ( pwcsComputerDnsName == NULL )
			{
				pDSSearch = m_pSearchRealPathNameGC.get();
			}
			{
				//
				//	More than one computer may match the Netbios name.
				//  Use the query that reutrns more than one replay.
				//
				pDSSearch = m_pSearchMsmqPathNameGC.get();
			}
        }
        else
        {
            pDSSearch = m_pSearchMsmqPathNameGC.get();
        }
        wcscpy(wszProvider, x_GcProvider);
        break;

    default:
        ASSERT(0);
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1640);
    }

    //
    //  Search the object according to the given restriction
    //
    AP<WCHAR> pwszSearchFilter;
    HRESULT hr = MQRestriction2AdsiFilter(
            pRestriction,
            *g_MSMQClassInfo[e_MSMQ_COMPUTER_CLASS].ppwcsObjectCategory,
            g_MSMQClassInfo[e_MSMQ_COMPUTER_CLASS].pwcsClassName,
            &pwszSearchFilter
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1650);
    }

    AP<WCHAR>   pwszVal;

    LPWSTR pwcsAttributes[] =  {const_cast<WCHAR*>(x_AttrDistinguishedName),
                                const_cast<WCHAR*>(MQ_COM_DNS_HOSTNAME_ATTRIBUTE)};

	DWORD numAttributes = ( pwcsComputerDnsName == NULL) ? 1 : 2;
    hr = pDSSearch->ExecuteSearch(
            pwszSearchFilter,
            pwcsAttributes,
            numAttributes,
            &hSearch);
    LogTraceQuery(pwszSearchFilter, s_FN, 719);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 720);
    }

    CAutoCloseSearchHandle cCloseSearchHandle(pDSSearch, hSearch);

    hr = MQDS_OBJECT_NOT_FOUND ; // prepare return error.
    //
    //  Get first row from search.
    //
    HRESULT hrRow = pDSSearch->GetFirstRow( hSearch);

    while (SUCCEEDED(hrRow) && (hrRow !=  S_ADS_NOMORE_ROWS))
    {
        ADS_SEARCH_COLUMN Column;
        //
        // Ask for the column itself
        //
        hr = pDSSearch->GetColumn(
                      hSearch,
                      const_cast<WCHAR *>(x_AttrDistinguishedName),
                     &Column);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 730);
        }

        CAutoReleaseColumn cAutoReleaseColumnDN(pDSSearch, &Column);

        WCHAR * pwsz = Column.pADsValues->DNString;
        if (pwsz == NULL)
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 2100);
        }

		if ( pwcsComputerDnsName != NULL)
		{
			ASSERT( numAttributes == 2);
			//
			//	verify that the DNS host name of the computer match
			//
			ADS_SEARCH_COLUMN ColumnDns;

			hr = pDSSearch->GetColumn(
						  hSearch,
						  const_cast<WCHAR *>(MQ_COM_DNS_HOSTNAME_ATTRIBUTE),
						 &ColumnDns);
			if (FAILED(hr))
			{
				hrRow = pDSSearch->GetNextRow( hSearch );
				continue;
			}

			CAutoReleaseColumn cAutoReleaseColumnDNS(pDSSearch, &ColumnDns);
			WCHAR * pwszDns = ColumnDns.pADsValues->DNString;
			if ( (pwszDns == NULL) ||
				 (_wcsicmp( pwcsComputerDnsName,  pwszDns) != 0))
			{
				hrRow = pDSSearch->GetNextRow( hSearch );
				continue;
			}
		}


        if (eComputerObjType ==  e_RealComputerObject)
        {
            //
            // Return the distingushed name.
            // When looking for the "real" computer object, we return
            // the first one found, even if it does not contain the
            // msmqConfiguration object. In most cases, this will indeed
            // be the object we want. Especially for domain controllers
            // that look for their own computer object in local replica.
            //
            *ppwcsFullPathName = new WCHAR[ wcslen(pwsz) + 1];
            wcscpy(*ppwcsFullPathName, pwsz);
            return  MQ_OK ;
        }

        //
        // OK, we have the name of the computer. Let's see if it own a msmq
        // object. If not, let search for another computer with the same name.
        // This may happen if more than one computer object with same name
        // exist in different domains. This will happen in mix-mode scenario,
        // where many computers objects are create by the upgrade wizard in the
        // PEC domain, although the computers belong to different nt4 domains.
        // After such a nt4 domain upgrade to win2k, computers objects will be
        // created in the newly upgraded domain while the msmq object still
        // live under similar computer name in the PEC object.
        // This problem may also happen when a computer move between domains
        // but the msmqConfiguration object is still in the old domain.
        // Bind with ADS_SECURE_AUTHENTICATION to make sure that a real binding
        // is done with server. ADS_FAST_BIND won't really go to the server
        // when calling AdsOpenObject.
        //
        dwLen = wcslen(pwsz)                   +
                wcslen(wszProvider)            +
                x_MsmqComputerConfigurationLen +
                10 ;
        P<WCHAR> wszFullName = new WCHAR[ dwLen ] ;
        wsprintf(wszFullName, L"%s%s=%s,%s", wszProvider,
                                             x_AttrCN,
                                             x_MsmqComputerConfiguration,
                                             pwsz ) ;
        R<IDirectoryObject> pDirObj = NULL ;

		DWORD Flags = ADS_SECURE_AUTHENTICATION;
		if(fServerName)
		{
			Flags |= ADS_SERVER_BIND;
		}

        hr = ADsOpenObject( 
				wszFullName,
				NULL,
				NULL,
				Flags,
				IID_IDirectoryObject,
				(void**) &pDirObj 
				);

        LogTraceQuery(wszFullName, s_FN, 1659);
        if (FAILED(hr))
        {
            WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                             e_LogDS,
                             LOG_DS_CROSS_DOMAIN,
                     L"DSCore: FindComputer() failed, hr- %lxh, Path- %s",
                              hr,
                              wszFullName )) ;

            if (provider == eLocalDomainController)
            {
                //
                // No luck in local domain controller. Each domain can have
                // only one computer object with a given name, so don't
                // look for other objects.
                // We'll be called again to search in GC.
                //
                LogHR(hr, s_FN, 1660);
                return MQDS_OBJECT_NOT_FOUND ; // keep this error for compatibility.
            }
        }
        else
        {
            //
            // Return the distingushed name.
            // When looking for the "real" computer object, we return
            // the first one found, even if it does not contain the
            // msmqConfiguration object. In most cases, this will indeed
            // be the object we want.
            //
            *ppwcsFullPathName = new WCHAR[ wcslen(pwsz) + 1];
            wcscpy(*ppwcsFullPathName, pwsz);
            return  MQ_OK ;
        }

        hrRow = pDSSearch->GetNextRow( hSearch );
    }

    LogHR(hr, s_FN, 1670);
    return MQDS_OBJECT_NOT_FOUND ; // keep this error for compatibility.
}



/*====================================================
    CADSI::FindObjectFullNameFromGuid()
    Finds the distingushed name of an object according to its unique id
=====================================================*/
HRESULT CADSI::FindObjectFullNameFromGuid(
        IN DS_PROVIDER       Provider,		// local DC or GC
        IN DS_CONTEXT        Context,         // DS context
        IN  const GUID *     pguidObjectId,
        IN  BOOL             fTryGCToo,
        OUT WCHAR **         ppwcsFullName,
        OUT DS_PROVIDER *    pFoundObjectProvider
        )
{
    //
    //  Locate the object according to its unique id
    //
    //  BUGUBG : This is a temporary helper routine,
    //  that should be replaced with an ADSI API.
    //
    *ppwcsFullName = NULL;

    DS_PROVIDER dsProvider = Provider;
    if ( Provider == eDomainController)
    {
        //
        //  This provider is used only for set and delete
        //  operations of queue,machine and user objects.
        //
        //  In order to overcome replication delays, we will
        //  first try to locate the object in the local DC.
        //
        dsProvider = eLocalDomainController;
    }
    LPCWSTR pwcsContext;
    switch( Context)
    {
        case e_RootDSE:
            //
            //  When performing operations against the local
            //  domain controller, if it a dc in a child domain
            //  use the local domain root
            //
             if ( dsProvider == eLocalDomainController)
             {
                pwcsContext = g_pwcsLocalDsRoot;
             }
             else
             {
                pwcsContext = g_pwcsDsRoot;
             }
             break;

        case e_ConfigurationContainer:
             pwcsContext = g_pwcsConfigurationContainer;
             break;

        case e_SitesContainer:
             pwcsContext = g_pwcsSitesContainer;
             break;

        case e_MsmqServiceContainer:
            pwcsContext = g_pwcsMsmqServiceContainer;
            break;

        case e_ServicesContainer:
            pwcsContext = g_pwcsServicesContainer;
            break;

        default:
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 1680);
    }
    *pFoundObjectProvider = dsProvider;

    HRESULT hr = LocateObjectFullName(
        dsProvider,	
        Context,         // DS context
        pguidObjectId,
        ppwcsFullName
        );

    if (!fTryGCToo)
    {
        return LogHR(hr, s_FN, 1690);
    }

    //
    //  For queues, machines and users : for set and delete operations
    //  which are performed against the domain controller, we try
    //  again this time against the GC.
    //
    //
    if ( FAILED(hr) &&
       ( Provider == eDomainController))
    {
        //
        //  Try again this time against the GC
        //
        hr = LocateObjectFullName(
            eGlobalCatalog,
            e_RootDSE,
            pguidObjectId,
            ppwcsFullName
            );
        *pFoundObjectProvider = eGlobalCatalog;
    }
    return LogHR(hr, s_FN, 1700);
}

//+-------------------------------------------------------------------------
//
//  HRESULT CADSI::InitBindHandles()
//
//  For performance reasons, we keep open search handles, for queries that
//  are often performed by the DS server.
//
//+-------------------------------------------------------------------------

HRESULT CADSI::InitBindHandles()
{
    //
    //  IDirectorySearch of local domain root
    //
    ASSERT( g_dwServerNameLength > 0);
    AP<WCHAR> pwcsADsPath = new WCHAR[ wcslen(g_pwcsLocalDsRoot) + g_dwServerNameLength +
                            x_providerPrefixLength + 2];
    swprintf(
          pwcsADsPath,
          L"%s%s/%s",
          x_LdapProvider,
          g_pwcsServerName,
          g_pwcsLocalDsRoot
          );

    HRESULT hr;
    hr = ADsOpenObject( 
			pwcsADsPath,
			NULL,
			NULL,
			ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND,
			IID_IDirectorySearch,
			(void**)&m_pSearchLocalDomainController
			);

    LogTraceQuery(pwcsADsPath, s_FN, 1709);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1710);
    }
    //
    //  For translation of CN to Distingushed name, we also keep a search handle
    //  with specific prefernces.
    //
    hr = ADsOpenObject( 
			pwcsADsPath,
			NULL,
			NULL,
			ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND,
			IID_IDirectorySearch,
			(void**)&m_pSearchPathNameLocalDC
			);

    LogTraceQuery(pwcsADsPath, s_FN, 1719);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1720);
    }
    delete []pwcsADsPath.detach();

    //
    //  IDirectorySearch of configuration container in local domain
    //
   pwcsADsPath = new WCHAR[ wcslen(g_pwcsConfigurationContainer) + g_dwServerNameLength +
                            x_providerPrefixLength + 2];
    swprintf(
          pwcsADsPath,
          L"%s%s/%s",
          x_LdapProvider,
          g_pwcsServerName,
          g_pwcsConfigurationContainer
          );

    hr = ADsOpenObject( 
			pwcsADsPath,
			NULL,
			NULL,
			ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND,
			IID_IDirectorySearch,
			(void**)&m_pSearchConfigurationContainerLocalDC
			);

    LogTraceQuery(pwcsADsPath, s_FN, 1729);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1730);
    }

    //
    //  IDirectorySearch of sites container in local domain
    //
    delete []pwcsADsPath.detach();
    pwcsADsPath = new WCHAR[ wcslen(g_pwcsSitesContainer) + g_dwServerNameLength +
                            x_providerPrefixLength + 2];
    swprintf(
          pwcsADsPath,
          L"%s%s/%s",
          x_LdapProvider,
          g_pwcsServerName,
          g_pwcsSitesContainer
          );

    hr = ADsOpenObject( 
			pwcsADsPath,
			NULL,
			NULL,
			ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND,
			IID_IDirectorySearch,
			(void**)&m_pSearchSitesContainerLocalDC
			);

    LogTraceQuery(pwcsADsPath, s_FN, 1739);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1740);
    }
    //
    //  IDirectorySearch of msmq service container in local domain
    //

    if ( !g_fSetupMode)
    {
        delete []pwcsADsPath.detach();
        //
        //  In setup mode, the MSMQ enterprise object may not exist.
        //
        pwcsADsPath = new WCHAR[ wcslen(g_pwcsMsmqServiceContainer) + g_dwServerNameLength +
                                x_providerPrefixLength + 2];
        swprintf(
              pwcsADsPath,
              L"%s%s/%s",
              x_LdapProvider,
              g_pwcsServerName,
              g_pwcsMsmqServiceContainer
              );

		hr = ADsOpenObject( 
				pwcsADsPath,
				NULL,
				NULL,
				ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND,
				IID_IDirectorySearch,
				(void**)&m_pSearchMsmqServiceContainerLocalDC
				);

        LogTraceQuery(pwcsADsPath, s_FN, 1749);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 1750);
        }
    }
    //
    //  IDirectorySearch of GC forest root
    //

    hr = BindRootOfForest(
            &m_pSearchGlobalCatalogRoot);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1760);
    }
    //
    //  For translation of CN to Distingushed name, we also keep a search handle
    //  with specific prefernces.
    //
    hr = BindRootOfForest( &m_pSearchRealPathNameGC );
    if (FAILED(hr))
    {
        return(hr);
    }
    hr = BindRootOfForest( &m_pSearchMsmqPathNameGC );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1770);
    }

    //
    //  For m_pSearchPathNameLocalDC do a one time init
    //  of search preferences.
    //
    const DWORD x_dwNumPref = 7;
    DWORD dwNumPrefs = 0;
    ADS_SEARCHPREF_INFO prefs[x_dwNumPref];
    prefs[ dwNumPrefs].dwSearchPref   = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
    prefs[ dwNumPrefs].vValue.dwType  = ADSTYPE_BOOLEAN;
    prefs[ dwNumPrefs].vValue.Boolean = FALSE;
    dwNumPrefs++;
    //  Asynchronous
    prefs[ dwNumPrefs].dwSearchPref   = ADS_SEARCHPREF_ASYNCHRONOUS;
    prefs[ dwNumPrefs].vValue.dwType  = ADSTYPE_BOOLEAN;
    prefs[ dwNumPrefs].vValue.Boolean = TRUE;
    dwNumPrefs++;
    // Do not chase referrals
    prefs[ dwNumPrefs].dwSearchPref   = ADS_SEARCHPREF_CHASE_REFERRALS;
    prefs[ dwNumPrefs].vValue.dwType  = ADSTYPE_INTEGER;
    prefs[ dwNumPrefs].vValue.Integer = ADS_CHASE_REFERRALS_NEVER;
    dwNumPrefs;
    //  size limit
    prefs[ dwNumPrefs].dwSearchPref   = ADS_SEARCHPREF_SIZE_LIMIT;
    prefs[ dwNumPrefs].vValue.dwType  = ADSTYPE_INTEGER;
    prefs[ dwNumPrefs].vValue.Integer = 1;  // we are interestand in one response only
    prefs[ dwNumPrefs].dwStatus       = ADS_STATUS_S_OK;
    DWORD dwSizeLimitIndex = dwNumPrefs ;
	dwNumPrefs++;
    //  page size
    prefs[ dwNumPrefs].dwSearchPref   = ADS_SEARCHPREF_PAGESIZE;
    prefs[ dwNumPrefs].vValue.dwType  = ADSTYPE_INTEGER;
    prefs[ dwNumPrefs].vValue.Integer = 1;  // we are interestand in one response only
    prefs[ dwNumPrefs].dwStatus       = ADS_STATUS_S_OK;
	dwNumPrefs++;
    // Search preferences: Scope
    prefs[ dwNumPrefs].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    prefs[ dwNumPrefs].vValue.dwType= ADSTYPE_INTEGER;
    prefs[ dwNumPrefs].vValue.Integer = ADS_SCOPE_SUBTREE;
	dwNumPrefs++;
    ASSERT( dwNumPrefs< x_dwNumPref);

    hr = m_pSearchPathNameLocalDC->SetSearchPreference( prefs, dwNumPrefs);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1780);
    }

    hr = m_pSearchRealPathNameGC->SetSearchPreference( prefs, dwNumPrefs);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1785);
    }

    //
    // when searching for a computer object that contain a msmqConfiguration
    // object, we're ready to find up to 7 computer objects with the same
    // name...
    //
    prefs[ dwSizeLimitIndex ].vValue.Integer = 7;
    hr = m_pSearchMsmqPathNameGC->SetSearchPreference( prefs, dwNumPrefs);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1786);
    }

    return LogHR(hr, s_FN, 1790);
}

/*====================================================
    CADSI::GetRootDsName()
    Finds the name of the root DS
=====================================================*/

HRESULT CADSI::GetRootDsName(
            OUT LPWSTR *        ppwcsRootName,
            OUT LPWSTR *        ppwcsLocalRootName,
            OUT LPWSTR *        ppwcsSchemaNamingContext
            )
{
    HRESULT hr;
    R<IADs> pADs;

    //
    // Bind to the RootDSE to obtain information about the schema container
	//	( specify local server, to avoid access of remote server during setup)
    //
	ASSERT( g_pwcsServerName != NULL);
    AP<WCHAR> pwcsRootDSE = new WCHAR [  x_providerPrefixLength + g_dwServerNameLength + x_RootDSELength + 2];
        swprintf(
            pwcsRootDSE,
             L"%s%s"
             L"/%s",
            x_LdapProvider,
            g_pwcsServerName,
			x_RootDSE
            );

    hr = ADsOpenObject( 
			pwcsRootDSE,
			NULL,
			NULL,
			ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND,
			IID_IADs,
			(void**)&pADs
			);

    LogTraceQuery(pwcsRootDSE, s_FN, 1799);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT("CADSI::GetRootDsName(LDAP://RootDSE)=%lx"), hr));
        return LogHR(hr, s_FN, 1800);
    }

    //
    // Setting value to BSTR Root domain
    //
    BS bstrRootDomainNamingContext( L"rootDomainNamingContext");

    //
    // Reading the root domain name property
    //
    CAutoVariant    varRootDomainNamingContext;

    hr = pADs->Get(bstrRootDomainNamingContext, &varRootDomainNamingContext);
    LogTraceQuery(bstrRootDomainNamingContext, s_FN, 1809);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CADSI::GetRootDsName(RootNamingContext)=%lx"), hr));
        return LogHR(hr, s_FN, 1810);
    }
    ASSERT(((VARIANT &)varRootDomainNamingContext).vt == VT_BSTR);
    //
    //  calculate length, allocate and copy the string
    //
    DWORD len = wcslen( ((VARIANT &)varRootDomainNamingContext).bstrVal);
    if ( len == 0)
    {
        return LogHR(MQ_ERROR, s_FN, 1820);
    }
    *ppwcsRootName = new WCHAR[ len + 1];
    wcscpy( *ppwcsRootName, ((VARIANT &)varRootDomainNamingContext).bstrVal);


    //
    // Setting value to BSTR default naming context
    //
    BS bstrDefaultNamingContext( L"DefaultNamingContext");

    //
    // Reading the default name property
    //
    CAutoVariant    varDefaultNamingContext;

    hr = pADs->Get(bstrDefaultNamingContext, &varDefaultNamingContext);
    LogTraceQuery(bstrDefaultNamingContext, s_FN, 1839);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CADSI::GetRootDsName(DefaultNamingContext)=%lx"), hr));
        return LogHR(hr, s_FN, 1830);
    }
    ASSERT(((VARIANT &)varDefaultNamingContext).vt == VT_BSTR);
    //
    //  calculate length, allocate and copy the string
    //
    len = wcslen( ((VARIANT &)varDefaultNamingContext).bstrVal);
    if ( len == 0)
    {
        return LogHR(MQ_ERROR, s_FN, 1840);
    }
    *ppwcsLocalRootName = new WCHAR[ len + 1];
    wcscpy( *ppwcsLocalRootName, ((VARIANT &)varDefaultNamingContext).bstrVal);

    //
    // Setting value to BSTR schema naming context
    //
    BS bstrSchemaNamingContext( L"schemaNamingContext");

    //
    // Reading the schema name property
    //
    CAutoVariant    varSchemaNamingContext;

    hr = pADs->Get(bstrSchemaNamingContext, &varSchemaNamingContext);
    LogTraceQuery(bstrSchemaNamingContext, s_FN, 1859);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CADSI::GetRootDsName(SchemaNamingContext)=%lx"), hr));
        return LogHR(hr, s_FN, 1850);
    }
    ASSERT(((VARIANT &)varSchemaNamingContext).vt == VT_BSTR);
    //
    //  calculate length, allocate and copy the string
    //
    len = wcslen( ((VARIANT &)varSchemaNamingContext).bstrVal);
    if ( len == 0)
    {
        return LogHR(MQ_ERROR, s_FN, 1860);
    }
    *ppwcsSchemaNamingContext = new WCHAR[ len + 1];
    wcscpy( *ppwcsSchemaNamingContext, ((VARIANT &)varSchemaNamingContext).bstrVal);

    g_fLocalServerIsGC = DSCoreIsServerGC() ;

    return(MQ_OK);
}


/*====================================================
    CADSI::CopyDefaultValue()
    copy property's default value into user's mqpropvariant
=====================================================*/
HRESULT   CADSI::CopyDefaultValue(
           IN const MQPROPVARIANT *   pvarDefaultValue,
           OUT MQPROPVARIANT *        pvar
           )
{
    if ( pvarDefaultValue == NULL)
    {
        return LogHR(MQ_ERROR, s_FN, 1870);
    }
    switch ( pvarDefaultValue->vt)
    {
        case VT_I2:
        case VT_I4:
        case VT_I1:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
            //
            //  copy as is
            //
            *pvar = *pvarDefaultValue;
            break;

        case VT_LPWSTR:
            {
                DWORD len = wcslen( pvarDefaultValue->pwszVal);
                pvar->pwszVal = new WCHAR[ len + 1];
                wcscpy( pvar->pwszVal, pvarDefaultValue->pwszVal);
                pvar->vt = VT_LPWSTR;
            }
            break;
        case VT_BLOB:
            {
                DWORD len = pvarDefaultValue->blob.cbSize;
                if ( len > 0)
                {
                    pvar->blob.pBlobData = new unsigned char[ len];
                    memcpy(  pvar->blob.pBlobData,
                             pvarDefaultValue->blob.pBlobData,
                             len);
                }
                else
                {
                    pvar->blob.pBlobData = NULL;
                }
                pvar->blob.cbSize = len;
                pvar->vt = VT_BLOB;
            }
            break;

        case VT_CLSID:
            //
            //  This is a special case where we do not necessarily allocate the memory for the guid
            //  in puuid. The caller may already have puuid set to a guid, and this is indicated by the
            //  vt member on the given propvar. It could be VT_CLSID if guid already allocated, otherwise
            //  we allocate it (and vt should be VT_NULL (or VT_EMPTY))
            //
            if ( pvar->vt != VT_CLSID)
            {
                ASSERT(((pvar->vt == VT_NULL) || (pvar->vt == VT_EMPTY)));
                pvar->puuid = new GUID;
                pvar->vt = VT_CLSID;
            }
            else if ( pvar->puuid == NULL)
            {
                return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 1880);
            }
            *pvar->puuid = *pvarDefaultValue->puuid;
            break;

        case VT_VECTOR|VT_CLSID:
            {
                DWORD len = pvarDefaultValue->cauuid.cElems;
                if ( len > 0)
                {
                    pvar->cauuid.pElems = new GUID[ len];
                    memcpy( pvar->cauuid.pElems,
                           pvarDefaultValue->cauuid.pElems,
                           len*sizeof(GUID));
                }
                else
                {
                    pvar->cauuid.pElems = NULL;
                }
                pvar->cauuid.cElems = len;
                pvar->vt = VT_VECTOR|VT_CLSID;
            }
            break;

        case VT_VECTOR|VT_LPWSTR:
            {
                DWORD len = pvarDefaultValue->calpwstr.cElems;
                if ( len > 0)
                {
                    pvar->calpwstr.pElems = new LPWSTR[ len];
					for (DWORD i = 0; i < len; i++)
					{
						DWORD strlen = wcslen(pvarDefaultValue->calpwstr.pElems[i]) + 1;
						pvar->calpwstr.pElems[i] = new WCHAR[ strlen];
						wcscpy( pvar->calpwstr.pElems[i], pvarDefaultValue->calpwstr.pElems[i]);
					}
                }
                else
                {
                    pvar->calpwstr.pElems = NULL;
                }
                pvar->calpwstr.cElems = len;
                pvar->vt = VT_VECTOR|VT_LPWSTR;
            }
            break;


        default:
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 1890);

    }
    return(MQ_OK);
}
/*====================================================
    CADSI::CompareDefaultValue()
    check the user property val + rel indicates that the
    query should return objects with default values
=====================================================*/
BOOL CADSI::CompareDefaultValue(
           IN const ULONG           rel,
           IN const MQPROPVARIANT * pvarUser,
           IN const MQPROPVARIANT * pvarDefaultValue
           )
{
    if ( pvarDefaultValue == NULL)
    {
        return(FALSE);
    }
    if ( pvarUser->vt != pvarDefaultValue->vt )
    {
        return(FALSE);
    }
    switch ( pvarDefaultValue->vt)
    {
        case VT_I2:
            if ( rel == PREQ)
            {
                return( pvarDefaultValue->iVal == pvarUser->iVal);
            }
            if ( rel == PRNE)
            {
                return( pvarDefaultValue->iVal != pvarUser->iVal);
            }
            if (rel == PRGT)
            {
                 return( pvarDefaultValue->iVal > pvarUser->iVal);
            }
            if (rel == PRGE)
            {
                 return( pvarDefaultValue->iVal >= pvarUser->iVal);
            }
            if (rel == PRLT)
            {
                 return( pvarDefaultValue->iVal < pvarUser->iVal);
            }
            if (rel == PRLE)
            {
                 return( pvarDefaultValue->iVal <= pvarUser->iVal);
            }
            return(FALSE);
            break;

        case VT_I4:
            if ( rel == PREQ)
            {
                return( pvarDefaultValue->lVal == pvarUser->lVal);
            }
            if ( rel == PRNE)
            {
                return( pvarDefaultValue->lVal != pvarUser->lVal);
            }
            if (rel == PRGT)
            {
                 return( pvarDefaultValue->lVal > pvarUser->lVal);
            }
            if (rel == PRGE)
            {
                 return( pvarDefaultValue->lVal >= pvarUser->lVal);
            }
            if (rel == PRLT)
            {
                 return( pvarDefaultValue->lVal < pvarUser->lVal);
            }
            if (rel == PRLE)
            {
                 return( pvarDefaultValue->lVal <= pvarUser->lVal);
            }
            return(FALSE);
            break;

        case VT_UI1:
            if ( rel == PREQ)
            {
                return( pvarDefaultValue->bVal == pvarUser->bVal);
            }
            if ( rel == PRNE)
            {
                return( pvarDefaultValue->bVal != pvarUser->bVal);
            }
            if (rel == PRGT)
            {
                 return( pvarDefaultValue->bVal > pvarUser->bVal);
            }
            if (rel == PRGE)
            {
                 return( pvarDefaultValue->bVal >= pvarUser->bVal);
            }
            if (rel == PRLT)
            {
                 return( pvarDefaultValue->bVal < pvarUser->bVal);
            }
            if (rel == PRLE)
            {
                 return( pvarDefaultValue->bVal <= pvarUser->bVal);
            }
            return(FALSE);
            break;

        case VT_UI2:
            if ( rel == PREQ)
            {
                return( pvarDefaultValue->uiVal == pvarUser->uiVal);
            }
            if ( rel == PRNE)
            {
                return( pvarDefaultValue->uiVal != pvarUser->uiVal);
            }
            if (rel == PRGT)
            {
                 return( pvarDefaultValue->uiVal > pvarUser->uiVal);
            }
            if (rel == PRGE)
            {
                 return( pvarDefaultValue->uiVal >= pvarUser->uiVal);
            }
            if (rel == PRLT)
            {
                 return( pvarDefaultValue->uiVal < pvarUser->uiVal);
            }
            if (rel == PRLE)
            {
                 return( pvarDefaultValue->uiVal <= pvarUser->uiVal);
            }
            return(FALSE);
            break;

        case VT_UI4:
            if ( rel == PREQ)
            {
                return( pvarDefaultValue->ulVal == pvarUser->ulVal);
            }
            if ( rel == PRNE)
            {
                return( pvarDefaultValue->ulVal != pvarUser->ulVal);
            }
            if (rel == PRGT)
            {
                 return( pvarDefaultValue->ulVal > pvarUser->ulVal);
            }
            if (rel == PRGE)
            {
                 return( pvarDefaultValue->ulVal >= pvarUser->ulVal);
            }
            if (rel == PRLT)
            {
                 return( pvarDefaultValue->ulVal < pvarUser->ulVal);
            }
            if (rel == PRLE)
            {
                 return( pvarDefaultValue->ulVal <= pvarUser->ulVal);
            }
            return(FALSE);
            break;

        case VT_LPWSTR:
            if ( rel == PREQ)
            {
                return ( !wcscmp( pvarDefaultValue->pwszVal, pvarUser->pwszVal));
            }
            if ( rel == PRNE)
            {
                return ( wcscmp( pvarDefaultValue->pwszVal, pvarUser->pwszVal));
            }
            return(FALSE);
            break;

        case VT_BLOB:
            ASSERT( rel == PREQ);
            if ( pvarDefaultValue->blob.cbSize != pvarUser->blob.cbSize)
            {
                return(FALSE);
            }
            return( !memcmp( pvarDefaultValue->blob.pBlobData,
                             pvarUser->blob.pBlobData,
                             pvarUser->blob.cbSize));
            break;

        case VT_CLSID:
            if ( rel == PREQ)
            {
                return( *pvarDefaultValue->puuid == *pvarUser->puuid);
            }
            if ( rel == PRNE)
            {
                 return( *pvarDefaultValue->puuid != *pvarUser->puuid);
            }
            return(FALSE);
            break;


        default:
            ASSERT(0);
            return(FALSE);
            break;

    }
}


/*====================================================
    CADSI::DecideObjectClass()
    decide the requested object class
=====================================================*/
HRESULT CADSI::DecideObjectClass(
        IN  const PROPID *  pPropid,
        OUT const MQClassInfo **  ppClassInfo
        )
{
    //
    //  ASSUMPTION : find the object class
    //  according to the first requested propid
    //

    if ( ((*pPropid > MQDS_QUEUE *PROPID_OBJ_GRANULARITY) &&
          (*pPropid < MQDS_MACHINE * PROPID_OBJ_GRANULARITY)) ||
          (*pPropid == PROPID_Q_SECURITY) ||
          (*pPropid == PROPID_Q_OBJ_SECURITY))
    {
        // queue
        *ppClassInfo = &g_MSMQClassInfo[e_MSMQ_QUEUE_CLASS];
        return(MQ_OK);
    }
    if ( ((*pPropid > MQDS_MACHINE *PROPID_OBJ_GRANULARITY) &&
         (*pPropid < MQDS_SITE * PROPID_OBJ_GRANULARITY)) ||
          (*pPropid == PROPID_QM_SECURITY)    ||
          (*pPropid == PROPID_QM_SIGN_PK)     ||
          (*pPropid == PROPID_QM_ENCRYPT_PK) )
    {
        // machine
        *ppClassInfo = &g_MSMQClassInfo[e_MSMQ_COMPUTER_CONFIGURATION_CLASS];
        return(MQ_OK);
    }
    if ( ((*pPropid > (MQDS_SITE * PROPID_OBJ_GRANULARITY)) &&
          (*pPropid < (MQDS_DELETEDOBJECT * PROPID_OBJ_GRANULARITY))) ||
          (*pPropid == PROPID_S_SECURITY)                             ||
          (*pPropid == PROPID_S_PSC_SIGNPK) )
    {
        // site
        *ppClassInfo = &g_MSMQClassInfo[e_MSMQ_SITE_CLASS];
        return(MQ_OK);
    }
    if ( ((*pPropid > MQDS_ENTERPRISE *PROPID_OBJ_GRANULARITY) &&
         (*pPropid < MQDS_USER * PROPID_OBJ_GRANULARITY)) ||
         (*pPropid == PROPID_E_SECURITY))
    {
        // enterprise
        *ppClassInfo = &g_MSMQClassInfo[e_MSMQ_SERVICE_CLASS];
        return(MQ_OK);
    }
    if ( (*pPropid > MQDS_USER *PROPID_OBJ_GRANULARITY) &&
         (*pPropid < MQDS_SITELINK * PROPID_OBJ_GRANULARITY))
    {
        // user
        *ppClassInfo = &g_MSMQClassInfo[e_MSMQ_USER_CLASS];
        return(MQ_OK);
    }

    if ( (*pPropid > MQDS_MQUSER *PROPID_OBJ_GRANULARITY) &&
         (*pPropid < (MQDS_MQUSER+1) * PROPID_OBJ_GRANULARITY))
    {
        // mq user
        *ppClassInfo = &g_MSMQClassInfo[e_MSMQ_MQUSER_CLASS];
        return(MQ_OK);
    }

    if ( (*pPropid > ( MQDS_SITELINK    * PROPID_OBJ_GRANULARITY)) &&
         (*pPropid < ((MQDS_SITELINK+1) * PROPID_OBJ_GRANULARITY)))
    {
        // site link
        *ppClassInfo = &g_MSMQClassInfo[e_MSMQ_SITELINK_CLASS];
        return(MQ_OK);
    }

    if ( (*pPropid > MQDS_SERVER * PROPID_OBJ_GRANULARITY) &&
         (*pPropid < MQDS_SETTING * PROPID_OBJ_GRANULARITY))
    {
        // server
        *ppClassInfo = &g_MSMQClassInfo[e_MSMQ_SERVER_CLASS];
        return(MQ_OK);
    }
    if ( (*pPropid > MQDS_SETTING * PROPID_OBJ_GRANULARITY) &&
         (*pPropid < (MQDS_COMPUTER) * PROPID_OBJ_GRANULARITY))
    {
        // setting
        *ppClassInfo = &g_MSMQClassInfo[e_MSMQ_SETTING_CLASS];
        return(MQ_OK);
    }
    if ( (*pPropid > MQDS_COMPUTER * PROPID_OBJ_GRANULARITY) &&
         (*pPropid < (MQDS_COMPUTER + 1) * PROPID_OBJ_GRANULARITY))
    {
         // setting
        *ppClassInfo = &g_MSMQClassInfo[e_MSMQ_COMPUTER_CLASS];
        return(MQ_OK);
    }

    if (*pPropid == PROPID_CN_SECURITY)
    {
         // setting
        *ppClassInfo = &g_MSMQClassInfo[e_MSMQ_CN_CLASS];
        return(MQ_OK);
    }

    return LogHR(MQ_ERROR, s_FN, 1900);

}


HRESULT CADSI::DoesObjectExists(
    IN  DS_PROVIDER     Provider,
    IN  DS_CONTEXT      Context,
    IN  CDSRequestContext *pRequestContext,
    IN  LPCWSTR         pwcsObjectName
    )
/*====================================================
    CADSI::DoesObjectExists()
    Binds to an object in order to check its existence
=====================================================*/
{
    R<IADs>   pAdsObj        = NULL;

    P<CImpersonate> pCleanupRevertImpersonation;
    // Bind to the object
    HRESULT hr = BindToObject(
                Provider,
                Context,
                pRequestContext,
                pwcsObjectName,
                NULL,
                IID_IADs,
                (VOID *)&pAdsObj,
                &pCleanupRevertImpersonation);

    return LogHR(hr, s_FN, 1910);
}





/*====================================================
    CADSSearch::CADSSearch()
    Constructor for the search-capturing class
=====================================================*/
CADSSearch::CADSSearch(IDirectorySearch  *pIDirSearch,
                       const PROPID      *pPropIDs,
                       DWORD             cPropIDs,
                       DWORD             cRequestedFromDS,
                       const MQClassInfo *      pClassInfo,
                       ADS_SEARCH_HANDLE hSearch)
{
    m_pDSSearch = pIDirSearch;      // capturing interface
    m_pDSSearch->AddRef();
    m_cPropIDs       = cPropIDs;
    m_cRequestedFromDS = cRequestedFromDS;
    m_pClassInfo = pClassInfo;
    m_fNoMoreResults = FALSE;
    m_pPropIDs = new PROPID[ cPropIDs];
    CopyMemory(m_pPropIDs, pPropIDs, sizeof(PROPID) * cPropIDs);

    m_hSearch = hSearch;            // keeping handle

    m_dwSignature = 0x1234;         // signing
}


/*====================================================
    CADSSearch::~CADSSearch()
    Destructor for the search-capturing class
=====================================================*/
CADSSearch::~CADSSearch()
{
    // Closing search handle
    m_pDSSearch->CloseSearchHandle(m_hSearch);

    // Releasinf IDirectorySearch interface itself
    m_pDSSearch->Release();

    // Freeing propid array
    delete [] m_pPropIDs;

    // Unsigning
    m_dwSignature = 0;
}


/*====================================================
    static helper functions
=====================================================*/

STATIC HRESULT GetDNGuidFromAdsval(IN const ADSVALUE * padsvalDN,
                                   IN const ADSVALUE * padsvalGuid,
                                   OUT LPWSTR * ppwszObjectDN,
                                   OUT GUID **  ppguidObjectGuid)
/*++
    given adsvalue for DN & GUID, returns the appropriate values
--*/
{
    AP<WCHAR> pwszObjectDN;
    P<GUID>  pguidObjectGuid;

    //
    // copy dn
    //
    if ((padsvalDN->dwType != ADSTYPE_DN_STRING) ||
        (!padsvalDN->DNString))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1920);
    }
    pwszObjectDN = new WCHAR[ 1+wcslen(padsvalDN->DNString)];
    wcscpy(pwszObjectDN, padsvalDN->DNString);

    //
    // copy guid
    //
    if ((padsvalGuid->dwType != ADSTYPE_OCTET_STRING) ||
        (padsvalGuid->OctetString.dwLength != sizeof(GUID)))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1930);
    }
    pguidObjectGuid = new GUID;
    memcpy(pguidObjectGuid, padsvalGuid->OctetString.lpValue, sizeof(GUID));

    //
    // return values
    //
    *ppwszObjectDN    = pwszObjectDN.detach();
    *ppguidObjectGuid = pguidObjectGuid.detach();
    return MQ_OK;
}

static HRESULT VerifyObjectCategory( IN IADs * pIADs,
                                  IN const WCHAR * pwcsExpectedCategory
                                 )
/*++
    Given an IADs object, verify that its category is the same as the expected one
--*/
{
    CAutoVariant varCategory;
    HRESULT hr;
    BS bsName;

    //
    // Get the object caegory
    //
    bsName = x_AttrObjectCategory;
    hr = pIADs->Get(bsName, &varCategory);
    if (FAILED(hr))
    {
        return hr;
    }


    VARIANT * pvarTmp = &varCategory;
    if ((pvarTmp->vt != VT_BSTR) ||
        (!pvarTmp->bstrVal))
    {
        ASSERT(("Wrong object category variant", 0));
        return MQ_ERROR_DS_ERROR;
    }
    if ( 0 != _wcsicmp(pvarTmp->bstrVal, pwcsExpectedCategory))
    {
        return MQ_ERROR_NOT_A_CORRECT_OBJECT_CLASS;
    }
    return MQ_OK;

}

STATIC HRESULT GetDNGuidFromSearchObj(IN IDirectorySearch  *pSearchObj,
                                      ADS_SEARCH_HANDLE  hSearch,
                                      OUT LPWSTR * ppwszObjectDN,
                                      OUT GUID **  ppguidObjectGuid)
/*++
    Given a search object and handle, returns the DN & GUID of object in current row
    It is assumed that these props were requested in the search.
--*/
{
    AP<WCHAR> pwszObjectDN;
    P<GUID>  pguidObjectGuid;
    ADS_SEARCH_COLUMN columnDN, columnGuid;
    HRESULT hr;

    //
    // Get DN
    //
    hr = pSearchObj->GetColumn(hSearch, const_cast<LPWSTR>(x_AttrDistinguishedName), &columnDN);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 740);
    }
    //
    // Make sure the column is freed eventually
    //
    CAutoReleaseColumn cAutoReleaseColumnDN(pSearchObj, &columnDN);

    //
    // Get GUID
    //
    hr = pSearchObj->GetColumn(hSearch, const_cast<LPWSTR>(x_AttrObjectGUID), &columnGuid);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 750);
    }
    //
    // Make sure the column is freed eventually
    //
    CAutoReleaseColumn cAutoReleaseColumnGuid(pSearchObj, &columnGuid);

    //
    // get the DN & guid from the ADSVALUE structs
    //
    hr = GetDNGuidFromAdsval(columnDN.pADsValues,
                             columnGuid.pADsValues,
                             &pwszObjectDN,
                             &pguidObjectGuid);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 760);
    }

    //
    // return values
    //
    *ppwszObjectDN    = pwszObjectDN.detach();
    *ppguidObjectGuid = pguidObjectGuid.detach();
    return MQ_OK;
}


STATIC HRESULT GetDNGuidFromIADs(IN IADs * pIADs,
                                 OUT LPWSTR * ppwszObjectDN,
                                 OUT GUID **  ppguidObjectGuid)
/*++
    Given an IADs object, returns the DN & GUID of the object
--*/
{
    AP<WCHAR> pwszObjectDN;
    P<GUID>   pguidObjectGuid;
    CAutoVariant varDN, varGuid;
    HRESULT hr;
    BS bsName;

    //
    // Get DN
    //
    bsName = x_AttrDistinguishedName;
    hr = pIADs->Get(bsName, &varDN);
    LogTraceQuery(bsName, s_FN, 769);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 770);
    }

    //
    // Get GUID
    //
    bsName = x_AttrObjectGUID;
    hr = pIADs->Get(bsName, &varGuid);
    LogTraceQuery(bsName, s_FN, 779);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 780);
    }

    //
    // copy DN
    //
    VARIANT * pvarTmp = &varDN;
    if ((pvarTmp->vt != VT_BSTR) ||
        (!pvarTmp->bstrVal))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1940);
    }
    pwszObjectDN = new WCHAR[  1+wcslen(pvarTmp->bstrVal)];
    wcscpy(pwszObjectDN, pvarTmp->bstrVal);

    //
    // copy GUID
    //
    pvarTmp = &varGuid;
    if ((pvarTmp->vt != (VT_ARRAY | VT_UI1)) ||
        (!pvarTmp->parray))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1950);
    }
    else if (SafeArrayGetDim(pvarTmp->parray) != 1)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1960);
    }
    LONG lLbound, lUbound;
    if (FAILED(SafeArrayGetLBound(pvarTmp->parray, 1, &lLbound)) ||
        FAILED(SafeArrayGetUBound(pvarTmp->parray, 1, &lUbound)))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1970);
    }
    if (lUbound - lLbound + 1 != sizeof(GUID))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1980);
    }
    pguidObjectGuid = new GUID;
    LPBYTE pTmp = (LPBYTE)((GUID *)pguidObjectGuid);
    for (LONG lTmp = lLbound; lTmp <= lUbound; lTmp++)
    {
        hr = SafeArrayGetElement(pvarTmp->parray, &lTmp, pTmp);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 790);
        }
        pTmp++;
    }

    //
    // return values
    //
    *ppwszObjectDN    = pwszObjectDN.detach();
    *ppguidObjectGuid = pguidObjectGuid.detach();
    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\dscore.cpp ===
/*++

Copyright (c) 1997-8  Microsoft Corporation

Module Name:

    dscore.cpp

Abstract:

    Implementation of  ds core API, ( of MQNT5 provider).

Author:

    ronit hartmann ( ronith)

--*/

#include "ds_stdh.h"
#include "adstempl.h"
#include "dsutils.h"
#include "_dsads.h"
#include "dsads.h"
#include "utils.h"
#include "mqads.h"
#include "coreglb.h"
#include "mqadsp.h"
#include "mqutil.h"
#include "hquery.h"
#include "dscore.h"
#include <mqsec.h>
#include <mqdsdef.h>

#include "dscore.tmh"

static WCHAR *s_FN=L"mqdscore/dscore";

/*====================================================

RoutineName: DSCoreCreateObject

Arguments:

Return Value:

=====================================================*/
HRESULT
DSCoreCreateObject(
                 DWORD        dwObjectType,
                 LPCWSTR      pwcsPathName,
                 DWORD        cp,
                 PROPID       aProp[  ],
                 PROPVARIANT  apVar[  ],
                 DWORD        cpEx,
                 PROPID       aPropEx[  ],
                 PROPVARIANT  apVarEx[  ],
                 IN CDSRequestContext * pRequestContext,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,    // optional request for object info
                 IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest) // optional request for parent info
{

    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>

    //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }


    switch ( dwObjectType)
    {
        case MQDS_USER:
            //
            //  Add MSMQ specific properties to an existing user object
            //
            hr = MQADSpCreateUserObject(
                         pwcsPathName,
                         cp,
                         aProp,
                         apVar,
                         pRequestContext
                         );
            break;

        case MQDS_QUEUE:
            //
            //  Create queue object
            //
            hr = MQADSpCreateQueue(
                         pwcsPathName,
                         cp,
                         aProp,
                         apVar,
                         pRequestContext,
                         pObjInfoRequest,
                         pParentInfoRequest
                         );

            break;
        case MQDS_MACHINE:
        case MQDS_MSMQ10_MACHINE:
            //
            //  create machine object
            //
            hr = MQADSpCreateMachine(
                         pwcsPathName,
                         dwObjectType,
                         cp,
                         aProp,
                         apVar,
                         cpEx,
                         aPropEx,
                         apVarEx,
                         pRequestContext,
                         pObjInfoRequest,
                         pParentInfoRequest
                         );

            break;
        case MQDS_COMPUTER:
            //
            //  create computer object
            //
            hr = MQADSpCreateComputer(
                         pwcsPathName,
                         cp,
                         aProp,
                         apVar,
                         cpEx,
                         aPropEx,
                         apVarEx,
                         pRequestContext,
                         NULL
                         );
            break;
        case MQDS_SITE:
            //
            //  create site object
            //
            hr = MQADSpCreateSite(
                         pwcsPathName,
                         cp,
                         aProp,
                         apVar,
                         cpEx,
                         aPropEx,
                         apVarEx,
                         pRequestContext
                         );
            break;

        case MQDS_CN:
            //
            // We support only creation of foreign CN (i.e., foreign sites
            // in win2k active directory).
            //
            hr = MQADSpCreateCN(
                         pwcsPathName,
                         cp,
                         aProp,
                         apVar,
                         cpEx,
                         aPropEx,
                         apVarEx,
                         pRequestContext
                         );
            break;

        case MQDS_ENTERPRISE:
            //
            //  Create MSMQ_service object
            //
            hr = MQADSpCreateEnterprise(
                         pwcsPathName,
                         cp,
                         aProp,
                         apVar,
                         pRequestContext
                         );
            break;
        case MQDS_SITELINK:
            //
            //  Create a Site_Link object
            //
            hr = MQADSpCreateSiteLink(
                         pwcsPathName,
                         cp,
                         aProp,
                         apVar,
                         pObjInfoRequest,
                         pParentInfoRequest,
                         pRequestContext
                         );

            break;
        default:
            ASSERT(0);
            hr = MQ_ERROR;
            break;
    }

    HRESULT hr2 = MQADSpFilterAdsiHResults( hr, dwObjectType );
    return LogHR(hr2, s_FN, 20);

}

/*====================================================

RoutineName: DSCoreDeleteObject

Arguments:

Return Value:

=====================================================*/
HRESULT
DSCoreDeleteObject(  DWORD        dwObjectType,
                     LPCWSTR      pwcsPathName,
                     CONST GUID * pguidIdentifier,
                     IN CDSRequestContext * pRequestContext,
                     IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest)
{
    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>

     //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }

    switch( dwObjectType)
    {
        case    MQDS_USER:
            //
            //  This is a special case, pguidIdentifier contains
            //  a digest and not a unique id of a user object.
            //  Therefore we need to perform a query on the GC,
            //  to find the unqiue id of the the user object.
            //
            ASSERT( pwcsPathName == NULL);
            ASSERT( pguidIdentifier != NULL);
            hr = MQADSpDeleteUserObject(
                                pguidIdentifier,
                                pRequestContext
                                );
            break;

        case    MQDS_CN:
            //
            //  CN are not supported in NT5. The explorer
            //  is not supposed to issue such delete request
            //
            //  MSMQ 1.0 explorer may issue such request.
            //
            hr = MQ_ERROR_FUNCTION_NOT_SUPPORTED;
            break;

        case    MQDS_SITE:
            //
            //  Not supported
            //
            hr = MQ_ERROR;
            break;

        case    MQDS_MACHINE:
            //
            //  This is a special case, if the machine is a server
            //  need to remove MSMQ-setting of this server
            //
            hr = MQADSpDeleteMachineObject(
                              pwcsPathName,
                              pguidIdentifier,
                              pRequestContext
                              );
            break;

        case    MQDS_QUEUE:
        {
            //
            // Delete Queue. convert path name to full name.
            //
            hr = MQ_OK ;
            AP<WCHAR> pwcsFullPathName = NULL ;
            DS_PROVIDER deleteProvider = eDomainController;
            if  (pwcsPathName)
            {
                //
                //  Path name format is machine1\queue1.
                //  expand machine1 name to a full computer path name
                //
                hr =  MQADSpComposeFullPathName( MQDS_QUEUE,
                                                 pwcsPathName,
                                                 &pwcsFullPathName,
                                                 &deleteProvider);
            }
            else if (!(pRequestContext->IsKerberos()))
            {
                //
                // Wow, what's this for ???
                // to workaround nt bug 403193.
                // Quite late in the game (post RC2 of RTM) we found that
                // serverless bind, when impersonating as non-win2k user,
                // will fail with error NO_SUCH_DOMAIN. Such a user is not
                // authenticating with Kerberos, so we know that mqdssrv
                // code will call us only if object is local, on local
                // domain controller. So change the provider, and the
                // binding string will include local server name.
                //
                deleteProvider = eLocalDomainController;
            }

            if (SUCCEEDED(hr))
            {
                hr = g_pDS->DeleteObject( deleteProvider,
                                        e_RootDSE,
                                        pRequestContext,
                                        pwcsFullPathName,
                                        pguidIdentifier,
                                        NULL /*pObjInfoRequest*/,
                                        pParentInfoRequest);
            }
            break ;
        }

        default:
            //
            //  Perform the request
            //
            ASSERT( (dwObjectType == MQDS_ENTERPRISE) ||
                    (dwObjectType == MQDS_SITELINK));
            ASSERT(pParentInfoRequest == NULL);
            hr = g_pDS->DeleteObject( eLocalDomainController,
                                    e_ConfigurationContainer,
                                    pRequestContext,
                                    pwcsPathName,
                                    pguidIdentifier,
                                    NULL /*pObjInfoRequest*/,
                                    pParentInfoRequest
                                    );
            break;
    }

    HRESULT hr2 = MQADSpFilterAdsiHResults( hr, dwObjectType);
    return LogHR(hr2, s_FN, 40);
}

/*====================================================

RoutineName: DSCoreGetProps

Arguments:

Return Value:

=====================================================*/
HRESULT
DSCoreGetProps(
             IN  DWORD              dwObjectType,
             IN  LPCWSTR            pwcsPathName,
             IN  CONST GUID *       pguidIdentifier,
             IN  DWORD              cp,
             IN  PROPID             aProp[  ],
             IN  CDSRequestContext *pRequestContext,
             OUT PROPVARIANT        apVar[  ])
{
    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>

     //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50);
    }

    switch ( dwObjectType)
    {
        case MQDS_CN:
            hr = MQADSpGetCnProperties(
                        pwcsPathName,
                        pguidIdentifier,
                        cp,
                        aProp,
                        pRequestContext,
                        apVar
                        );

            break;

        case MQDS_QUEUE:
            hr = MQADSpGetQueueProperties(
                        pwcsPathName,
                        pguidIdentifier,
                        cp,
                        aProp,
                        pRequestContext,
                        apVar
                        );
            break;
        case MQDS_MACHINE:
            hr = MQADSpGetMachineProperties(
                        pwcsPathName,
                        pguidIdentifier,
                        cp,
                        aProp,
                        pRequestContext,
                        apVar
                        );
            break;
        case MQDS_ENTERPRISE:
            hr = MQADSpGetEnterpriseProperties(
                        pwcsPathName,
                        pguidIdentifier,
                        cp,
                        aProp,
                        pRequestContext,
                        apVar
                        );
            break;
        case MQDS_SITELINK:
            hr = MQADSpGetSiteLinkProperties(
                    pwcsPathName,
                    pguidIdentifier,
                    cp,
                    aProp,
                    pRequestContext,
                    apVar
                    );
            break;
        case MQDS_USER:
            hr = MQADSpGetUserProperties(
                    pwcsPathName,
                    pguidIdentifier,
                    cp,
                    aProp,
                    pRequestContext,
                    apVar
                    );
            break;

        case MQDS_SITE:
            hr = MQADSpGetSiteProperties(
                    pwcsPathName,
                    pguidIdentifier,
                    cp,
                    aProp,
                    pRequestContext,
                    apVar
                    );
            break;
        case MQDS_COMPUTER:
            hr = MQADSpGetComputerProperties(
                pwcsPathName,
                pguidIdentifier,
                cp,
                aProp,
                pRequestContext,
                apVar
                );
            break;
        default:
            ASSERT(0);
            hr = MQ_ERROR;
            break;
    }

    HRESULT hr2 = MQADSpFilterAdsiHResults( hr, dwObjectType);
    return LogHR(hr2, s_FN, 60);
}

/*====================================================

RoutineName: InitPropertyTranslationMap

Arguments:  initialize property translation map

Return Value: none

=====================================================*/
STATIC void InitPropertyTranslationMap()
{
    // Populate  g_PropDictionary
    // maybe: reading from schema MQ propid<-->propname table

    for (ULONG i=0; i<g_cMSMQClassInfo; i++)
    {
        const MQClassInfo *pInfo = g_MSMQClassInfo + i;

        for (ULONG j=0; j<pInfo->cProperties; j++)
        {
            const MQTranslateInfo * pProperty = pInfo->pProperties + j;

            g_PropDictionary.SetAt(pProperty->propid, pProperty);
        }
    }
}


/*====================================================

RoutineName: DSCoreInit

Arguments:
    IN BOOL  fReplicaionMode - TRUE when called from the replication
                service. The replication service do not use the QM scheduler,
                so this flag tell us to ignore QM initialization.

Return Value:

=====================================================*/
HRESULT 
DSCoreInit(
	IN BOOL                  fSetupMode,
	IN BOOL                  fReplicationMode
	)
{
    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>

     //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 70);
    }

    g_fSetupMode = fSetupMode;

    InitPropertyTranslationMap();


    //
    //  start with finding the computer name
    //
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    g_pwcsServerName = new WCHAR[dwSize];

    hr = GetComputerNameInternal(
                g_pwcsServerName,
                &dwSize
                );
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("DSCoreInit : failed to get computer name %lx"),hr));
        return LogHR(hr, s_FN, 80);
    }
    g_dwServerNameLength = wcslen( g_pwcsServerName);

	g_pDS = new CADSI;

    //
    //  Build global DS path names
    //
    hr = MQADSpInitDsPathName();
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("DSCoreInit : Failed to initialize global path names %lx"),hr));
        return LogHR(hr, s_FN, 90);
    }

    //
    //  Initialize DS bind handles
    //
    hr = g_pDS->InitBindHandles();
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("DSCoreInit : Failed to initialize bind handles %lx"),hr));
        return LogHR(hr, s_FN, 100);
    }

    if ( !fSetupMode)
    {
        dwSize = sizeof(GUID);
        DWORD dwType = REG_BINARY;
        long rc = GetFalconKeyValue(MSMQ_QMID_REGNAME, &dwType, &g_guidThisServerQMId, &dwSize);
        if (rc != ERROR_SUCCESS)
        {
            DBGMSG((DBGMOD_DS, DBGLVL_WARNING, TEXT("Can't get QM ID from registery. Error %d"), hr));
            LogNTStatus(rc, s_FN, 110);
            return(MQDS_ERROR);
        }
    }

    //
    //  Retrieve information about this server's site
    //  BUGBUG : assuming one site only
    //
	g_pMySiteInformation = new CSiteInformation;
    hr = g_pMySiteInformation->Init(fReplicationMode);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
         "DSInitInternal : Failed to retrieve this site'a information %lx"),hr));
        return LogHR(hr, s_FN, 120);
    }

    //
    //  Build site routing table (needed for IPAddress-to-site mapping class)
    //
	g_pSiteRoutingTable = new CSiteRoutingInformation;
    hr = g_pSiteRoutingTable->Init( 
			g_pMySiteInformation->GetSiteId(),
			fReplicationMode 
			);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT("DSCoreInit : Failed to build site route table %lx"),hr));
        return LogHR(hr, s_FN, 130);
    }

    //
    //  Build IPAddress-to-site mapping class
    //
	g_pcIpSite = new CIpSite;
    hr = g_pcIpSite->Initialize(fReplicationMode);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
         "DSInitInternal : Failed to build IPAddress-to-site mapping class %lx"),hr));
        return LogHR(hr, s_FN, 140);
    }

    return LogHR(hr, s_FN, 150);

}


/*====================================================

RoutineName: DSCoreLookupBegin

Arguments:

Return Value:


=====================================================*/
HRESULT
DSCoreLookupBegin(
                IN  LPWSTR          pwcsContext,
                IN  MQRESTRICTION   *pRestriction,
                IN  MQCOLUMNSET     *pColumns,
                IN  MQSORTSET       *pSort,
                IN  CDSRequestContext * pRequestContext,
                IN  HANDLE          *pHandle)
{
    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>

     //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }
    hr = QueryParser(
                 pwcsContext,
                 pRestriction,
                 pColumns,
                 pSort,
                 pRequestContext,
                 pHandle);

    return LogHR(hr, s_FN, 170);
}

/*====================================================

RoutineName: MQDSLookupNext

Arguments:

Return Value:


=====================================================*/
HRESULT
DSCoreLookupNext(
                     HANDLE             handle,
                     DWORD  *           pdwSize,
                     PROPVARIANT  *     pbBuffer)
{
    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>

     //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 180);
    }

    CBasicQueryHandle * phQuery = (CBasicQueryHandle *)handle;

    CDSRequestContext requestContext( e_DoNotImpersonate,  // we don't perfome impersonation at locate next
                                phQuery->GetRequesterProtocol());

    hr = phQuery->LookupNext(
                &requestContext,
                pdwSize,
                pbBuffer);

    return LogHR(hr, s_FN, 190);
}


/*====================================================

RoutineName: DSCoreLookupEnd

Arguments:

Return Value:

=====================================================*/
HRESULT
DSCoreLookupEnd(
    IN HANDLE handle)
{
    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>

     //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 200);
    }

    CBasicQueryHandle * phQuery = (CBasicQueryHandle *)handle;

    hr = phQuery->LookupEnd();
    return LogHR(hr, s_FN, 210);
}


/*====================================================

RoutineName: DSCoreTerminate

Arguments:

Return Value:

=====================================================*/
void
DSCoreTerminate()
{
    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>

     //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
		ASSERT(("CoInitialize failed", 0));
        return;
    }

	//
	// Free global objects that may cause AV on unload
	//
	g_pcIpSite.free();
	g_pSiteRoutingTable.free();
	g_pMySiteInformation.free();
	g_pDS.free();
}

/*====================================================

RoutineName: MQADSGetComputerSites

Arguments:

Return Value:

=====================================================*/
HRESULT
DSCoreGetComputerSites(
            IN  LPCWSTR     pwcsComputerName,
            OUT DWORD  *    pdwNumSites,
            OUT GUID **     ppguidSites
            )
{

    *pdwNumSites = 0;
    *ppguidSites = NULL;
    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>

     //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 220);
    }

    AP<IPSITE_SiteArrayEntry> rgSites;
    ULONG cSites;
    //
    //  Calculate the computer's sites according to its addresses
    //
    hr = g_pcIpSite->FindSitesByComputerName(
							pwcsComputerName,
							NULL, /* pwcsComputerDnsName */
							&rgSites,
							&cSites,
							NULL, /* prgAddrs*/
							NULL  /* pcAddrs*/
							);
    if (FAILED(hr))
    {
       DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("MQDSGetComputerSites() failed to find machine's sites hr=0x%x"), hr));
       return LogHR(hr, s_FN, 230);
    }
    if (cSites == 0)
    {
        //
        //  This can happen if no ip subnets where configured.
        //  In such case, we return the site of DS server as
        //  the client site
        //
        const GUID * pguidSite;
        pguidSite = g_pMySiteInformation->GetSiteId();

        *ppguidSites = new GUID;
        **ppguidSites = *pguidSite;
        *pdwNumSites = 1;
        return LogHR(MQDS_INFORMATION_SITE_NOT_RESOLVED, s_FN, 240);
    }
    AP<GUID> pguidSites = new GUID[cSites];
    //
    //  Copy and filter out duplicate site-ids.
    //
    //  This API is called by setup, which set the returned value
    //  in PROPID_QM_SITE_IDS. ADSI doesn't allow to set duplicate
    //  value in multi-value attribute.
    //
    DWORD dwNumNonDuplictaeSites = 0;

    for (DWORD i = 0; i <  cSites; i++)
    {
        BOOL fDuplicate = FALSE;
        for (DWORD j = 0; j < i; j++)
        {
            if (rgSites[i].guidSite == rgSites[j].guidSite)
            {
                fDuplicate = TRUE;
                break;
            }
        }
        if ( !fDuplicate)
        {
            pguidSites[dwNumNonDuplictaeSites] = rgSites[i].guidSite;
            dwNumNonDuplictaeSites++;
        }
    }
    *pdwNumSites = dwNumNonDuplictaeSites;
    *ppguidSites = pguidSites.detach();

    return(MQ_OK);

}


HRESULT DSCoreSetObjectProperties(
                IN const  DWORD         dwObjectType,
                IN LPCWSTR              pwcsPathName,
                IN const GUID *         pguidIdentifier,
                IN const DWORD          cp,
                IN const PROPID         aProp[],
                IN const PROPVARIANT    apVar[],
                IN CDSRequestContext *  pRequestContext,
                IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest
                )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>

     //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 250);
    }
    AP<WCHAR> pwcsFullPathName;
    DS_PROVIDER setProvider = eDomainController;
    if ( pwcsPathName)
    {
        hr = MQADSpComposeFullPathName(
                    dwObjectType,
                    pwcsPathName,
                    &pwcsFullPathName,
                    &setProvider
                    );
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_TRACE,TEXT("MQADSpSetObjectProperties : failed to compose full path name %lx"),hr));
            return LogHR(hr, s_FN, 260);
        }
    }
    else if (!(pRequestContext->IsKerberos()))
    {
        //
        // Wow, what's this for ???
        // look in DSCoreDeleteObject for details.
        //
        setProvider = eLocalDomainController;
    }

    // [adsrv] In principle, we should treat here PROPID_QM_SERVICE setting (replace with 3 bits)
    // But it may come only from old clients upgrade to server (still with pre-B3 software).
    // Design doc says it is prohibited - see limitation 2.
    // But let's at least cry if it occurs
    BOOL    fQmChangedSites = FALSE;
    DWORD   dwSiteIdsIndex = cp;   // past the end of aProp

    for (DWORD i=0; i<cp; i++)
    {
        if (aProp[i] == PROPID_QM_SERVICE || aProp[i] == PROPID_SET_SERVICE)
        {
            ASSERT(0); // Means we have to interpret service type setting
        }
        //
        //  Detect if the QM had change sites, for servers we need to take care of
        //  msmq-settings objects
        //
        if (aProp[i] == PROPID_QM_SITE_IDS)
        {
            fQmChangedSites = TRUE;
            dwSiteIdsIndex = i;
        }
    }

    if ( fQmChangedSites)
    {
		ASSERT(dwSiteIdsIndex < cp);

        HRESULT hr2 = MQADSpSetMachinePropertiesWithSitesChange(
                            dwObjectType,
                            setProvider,
                            pRequestContext,
                            pwcsFullPathName,
                            pguidIdentifier,
                            cp,
                            aProp,
                            apVar,
                            dwSiteIdsIndex,
                            pObjInfoRequest
                            );
        return LogHR(hr2, s_FN, 270);
    }

    hr = g_pDS->SetObjectProperties(
                    setProvider,
                    pRequestContext,
                    pwcsFullPathName,
                    pguidIdentifier,
                    cp,
                    aProp,
                    apVar,
                    pObjInfoRequest
                    );

    HRESULT hr3 = MQADSpFilterAdsiHResults( hr, dwObjectType);
    return LogHR(hr3, s_FN, 280);

}


//+--------------------------------------------------
//
//    HRESULT DSCOreGetFullComputerPathName()
//
//+--------------------------------------------------

HRESULT
DSCoreGetFullComputerPathName(
	IN  LPCWSTR                    pwcsComputerCn,
	IN  enum  enumComputerObjType  eComputerObjType,
	OUT LPWSTR *                   ppwcsFullPathName 
	)
{
    DS_PROVIDER  CreateProvider;

    HRESULT hr =  MQADSpGetFullComputerPathName( 
						pwcsComputerCn,
						eComputerObjType,
						ppwcsFullPathName,
						&CreateProvider 
						);
    return LogHR(hr, s_FN, 290);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\dijkstra.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dijkstra.h

Abstract:

	CDijkstraTree Class definition
		
Author:

	Lior Moshaiov (LiorM)


--*/
#ifndef __DIJKSTRA_H__
#define __DIJKSTRA_H__


#include "routtbl.h"

class CDijkstraTree
{
	public:
   		CDijkstraTree();
  		~CDijkstraTree();
		void			SetRoot(IN const CSiteRoutingNode* pRoot);
		const CCost&	GetCost(IN CSiteRoutingNode* pTarget) const;
		void			MoveMinimal(IN OUT CDijkstraTree& OtherTree,
									OUT CSiteRoutingNode** ppMinNode,
									OUT CNextHop **ppMinNextHop,
									OUT BOOL *pfFlag);
		void			Add(IN CSiteRoutingNode* pNode,
							IN CNextHop* pNextHop);
		void			Print(IN const CSiteDB* pRoutingDB) const;
		HRESULT			UpdateRoutingTable(IN OUT CRoutingTable *pTbl) const;
		
	private:
		CDijkstraTree(const CDijkstraTree &other);		 		// no definition - to find out unintentionaly copies
		void	operator=(const CDijkstraTree &other);			// no definition - to find out unintentionaly copies

		CRoutingTable m_list;
			
};

inline		CDijkstraTree::CDijkstraTree(){};

inline		CDijkstraTree::~CDijkstraTree(){};

inline void	CDijkstraTree::Add(CSiteRoutingNode *pNode,CNextHop* pNextHop)
{
	CSiteRoutingNode * pDupNode = pNode->Duplicate();

	m_list[pDupNode] = pNextHop;

}


extern HRESULT Dijkstra(
                IN CSiteDB* pRoutingDB,
                IN OUT CRoutingTable *pTbl);

			

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\ds_stdh.h ===
#include "..\h\ds_stdh.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\dsmigrat.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    dsmigrat.cpp

Abstract:

    1. DS code which is needed only for migration.
    2. DS code that specifically look for a GC server.
    Note- 1 and 2 are related, as migration code in general need a GC.
          So both kinds of queries and operations are in this file.

Author:

    Doron Juster (DoronJ)

--*/

#include "ds_stdh.h"
#include "adstempl.h"
#include "dsutils.h"
#include "_dsads.h"
#include "dsads.h"
#include "utils.h"
#include "mqads.h"
#include "coreglb.h"
#include "mqadsp.h"
#include "dscore.h"
#include "dsmixmd.h"
#include <_mqini.h>

#include "dsmigrat.tmh"

static WCHAR *s_FN=L"mqdscore/dsmigrat";

//+------------------------------
//
//  void  _AllocateNewProps()
//
//+------------------------------

STATIC void  _AllocateNewProps( IN DWORD            cp,
                                IN PROPID           aProp[  ],
                                IN PROPVARIANT      apVar[  ],
                                IN DWORD            dwDelta,
                                OUT PROPID         *paProp[  ],
                                OUT PROPVARIANT    *papVar[  ] )
{
    ASSERT((cp != 0) && (dwDelta != 0)) ;

    *paProp = new PROPID[ cp + dwDelta ] ;
    memcpy( *paProp, aProp, (cp * sizeof(PROPID)) ) ;

    *papVar = new PROPVARIANT[ cp + dwDelta ] ;
    memcpy( *papVar, apVar, (cp * sizeof(PROPVARIANT)) ) ;
}

//+------------------------------------
//
//  HRESLUT  _QueryDCName()
//
//+------------------------------------

STATIC HRESULT  _QueryDCName( IN  IDirectorySearch   *pDSSearch,
                              IN  ADS_SEARCH_HANDLE   hSearch,
                              OUT WCHAR             **ppwszDCName )
{
    ADS_SEARCH_COLUMN columnDN;
    HRESULT  hr = pDSSearch->GetColumn( hSearch,
                              const_cast<LPWSTR> (x_AttrDistinguishedName),
                                        &columnDN ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    WCHAR *pDN = wcsstr(columnDN.pADsValues->DNString, L",") ;
    ASSERT(pDN) ;
    if (pDN)
    {
        pDN++ ;

        AP<WCHAR> pPath = new
                    WCHAR[ wcslen(pDN) + x_providerPrefixLength + 1 ] ;
        swprintf( pPath, L"%s%s", x_LdapProvider, pDN ) ;

        //
        // now pPath is the parent object. Use it to query for server name.
        //
        R<IDirectoryObject> pObject = NULL ;

		hr = ADsOpenObject(
				pPath,
				NULL,
				NULL,
				ADS_SECURE_AUTHENTICATION,
				IID_IDirectoryObject,
				(void**)&pObject
				);

        LogTraceQuery(pPath, s_FN, 12);
        if (SUCCEEDED(hr))
        {
            LPWSTR  ppAttrNames[1] = { L"dnsHostName" } ;
            DWORD   dwAttrCount = 0 ;
            ADS_ATTR_INFO *padsAttr ;

            hr = pObject->GetObjectAttributes( ppAttrNames,
                             (sizeof(ppAttrNames) / sizeof(ppAttrNames[0])),
                                              &padsAttr,
                                              &dwAttrCount ) ;
            if (dwAttrCount == 1)
            {
            	ADsFreeAttr pClean( padsAttr);
                ADS_ATTR_INFO adsInfo = padsAttr[0] ;
                ASSERT(adsInfo.dwADsType == ADSTYPE_CASE_IGNORE_STRING) ;

                ADSVALUE *pAdsVal = adsInfo.pADsValues ;
                LPWSTR lpW = pAdsVal->CaseIgnoreString ;
                *ppwszDCName = new WCHAR[ wcslen(lpW) + 1 ] ;
                wcscpy(*ppwszDCName, lpW) ;
            }
        }
        else
        {
            LogHR(hr, s_FN, 15);
        }
    }

    pDSSearch->FreeColumn(&columnDN);
    return MQ_OK ;
}

//+---------------------------------------------------------
//
//  HRESULT  _GCLookupNext()
//
//+---------------------------------------------------------

STATIC  HRESULT  _GCLookupNext( IN  IDirectorySearch   *pDSSearch,
                                IN  ADS_SEARCH_HANDLE   hSearch,
                                OUT WCHAR             **ppwszDCName )
{
    HRESULT hr = pDSSearch->GetNextRow(hSearch);

    if (SUCCEEDED(hr) && (hr != S_ADS_NOMORE_ROWS))
    {
        HRESULT hrE = _QueryDCName(  pDSSearch,
                                     hSearch,
                                     ppwszDCName ) ;
        ASSERT(SUCCEEDED(hrE)) ;
        LogHR(hrE, s_FN, 1607);
    }

    return LogHR(hr, s_FN, 20);
}

//+---------------------------------------------------------
//
//  HRESULT  _GCLookupBegin()
//
//+---------------------------------------------------------

STATIC HRESULT  _GCLookupBegin( IN  const WCHAR        *pszDomainName,
                                OUT IDirectorySearch  **ppDSSearch,
                                OUT ADS_SEARCH_HANDLE  *phSearch,
                                OUT WCHAR             **ppwszDCName )
{
    //
    // Bind to Sites container.
    //
    DWORD dwLen = wcslen(g_pwcsSitesContainer) ;
    AP<WCHAR> pwcsFullPath = new WCHAR[ dwLen + x_providerPrefixLength + 2 ] ;

    swprintf( pwcsFullPath,
              L"%s%s",
              x_LdapProvider, g_pwcsSitesContainer) ;

	HRESULT hr = ADsOpenObject(
					pwcsFullPath,
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IDirectorySearch,
					(void**)ppDSSearch
					);

    LogTraceQuery(pwcsFullPath, s_FN, 29);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }

    //
    // Set search preference
    //
    ADS_SEARCHPREF_INFO         sSearchPrefs[2];

    sSearchPrefs[0].dwSearchPref   = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
    sSearchPrefs[0].vValue.dwType  = ADSTYPE_BOOLEAN;
    sSearchPrefs[0].vValue.Boolean = FALSE;

    sSearchPrefs[1].dwSearchPref   = ADS_SEARCHPREF_SEARCH_SCOPE;
    sSearchPrefs[1].vValue.dwType  = ADSTYPE_INTEGER;
    sSearchPrefs[1].vValue.Integer = ADS_SCOPE_SUBTREE;

    hr = (*ppDSSearch)->SetSearchPreference( sSearchPrefs,
                                             ARRAY_SIZE(sSearchPrefs) );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 40);
    }

    LPWSTR sSearchAttrs[] =
                      { const_cast<LPWSTR> (x_AttrDistinguishedName) } ;

    AP<WCHAR>  wszFilter = new WCHAR[ x_GCLookupSearchFilterLength +
                                     wcslen(pszDomainName) + 4 ] ;
    swprintf( wszFilter,
              L"%s%s))",
              x_GCLookupSearchFilter, pszDomainName) ;

    hr = (*ppDSSearch)->ExecuteSearch( wszFilter,
                                       sSearchAttrs,
                                       ARRAY_SIZE(sSearchAttrs),
                                       phSearch ) ;
    LogTraceQuery(wszFilter, s_FN, 49);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50);
    }

    hr = (*ppDSSearch)->GetFirstRow(*phSearch);
    if (SUCCEEDED(hr) && (hr != S_ADS_NOMORE_ROWS))
    {
        HRESULT hrE = _QueryDCName( *ppDSSearch,
                                    *phSearch,
                                     ppwszDCName ) ;
        ASSERT(SUCCEEDED(hrE)) ;
        LogHR(hrE, s_FN, 1608);
    }

    return LogHR(hr, s_FN, 60);
}

//+------------------------------------------------------------------------
//
//  HRESUT  DSCoreCreateMigratedObject()
//
// This function is called only by migration tool and replication service
// to create machine and queue objects with predefined object guid.
//
// There are two requirements for creating objects with predefined guid:
// 1. you must have the "AddGuid" permission.
// 2. the "Create" operation must be done on a GC machine.
//
// By design, the migration tool and replication service run on a GC machine.
// So all MSMQ1.0 objects which belong to the local domain are created OK.
// For objects that belong to other domains, we must find a GC in the other
// domain, and make an explicit refferal to that Gc machine (i.e., use the
// following path when creating the object- LDAP://RemoteGcName/objectpath).
// The DS does not have this functionality.
//
// We'll call this function only for queue and machine objects. All other
// objects are created under the "configuration" naming context which is a
// local operation without refferals.
//
//+------------------------------------------------------------------------

HRESULT
DSCoreCreateMigratedObject(
     IN DWORD                  dwObjectType,
     IN LPCWSTR                pwcsPathName,
     IN DWORD                  cp,
     IN PROPID                 aProp[  ],
     IN PROPVARIANT            apVar[  ],
     IN DWORD                  cpEx,
     IN PROPID                 aPropEx[  ],
     IN PROPVARIANT            apVarEx[  ],
     IN CDSRequestContext * pRequestContext,
     IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,    // optional request for object info
     IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest, // optional request for parent info
     //
     // if fReturnProperties
     // we have to return full path name and provider
     // if fUseProperties we have to use these values
     //
     IN BOOL                    fUseProperties,
     IN BOOL                    fReturnProperties,
     IN OUT LPWSTR              *ppwszFullPathName,
     IN OUT ULONG               *pulProvider
	 )
{
    HRESULT hr = MQ_OK;

    CDSRequestContext requestDsServerInternal(e_DoNotImpersonate, e_IP_PROTOCOL);
    CDSRequestContext *pRequestDsServerInternal = pRequestContext;
    if (!pRequestDsServerInternal)
    {
        pRequestDsServerInternal = &requestDsServerInternal;
    }

    if ((dwObjectType != MQDS_QUEUE) && (dwObjectType != MQDS_MACHINE))
    {
        hr = DSCoreCreateObject(
					dwObjectType,
					pwcsPathName,
					cp,
					aProp,
					apVar,
					cpEx,
					aPropEx,
					apVarEx,
					pRequestDsServerInternal,
					pObjInfoRequest,
					pParentInfoRequest
					);
        return LogHR(hr, s_FN, 70);
    }

    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its
                     // destructor (CoUninitialize) is called after the
                     // release of all R<xxx> or P<xxx>

    hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 80);
    }

    static AP<WCHAR> s_pszTmpFullDCName;
    static WCHAR   *s_pszMyDomainName = NULL;

    if (!s_pszMyDomainName)
    {
        //
        // Initialize my own local domain name.
        // Need for optimization (below). Ignore errors.
        //
        ASSERT(g_pwcsServerName);
        if (g_pwcsServerName)
        {
            DS_PROVIDER createProviderTmp ;
            hr = MQADSpGetFullComputerPathName(
						g_pwcsServerName,
						e_RealComputerObject,
						&s_pszTmpFullDCName,
						&createProviderTmp
						);
            ASSERT((SUCCEEDED(hr)) && s_pszTmpFullDCName);
            if (s_pszTmpFullDCName)
            {
                s_pszMyDomainName = wcsstr(s_pszTmpFullDCName, x_DcPrefix);
                if (!s_pszMyDomainName)
                {
                    ASSERT(s_pszMyDomainName);
                    s_pszTmpFullDCName.free();
                }
            }
        }
    }

    //
    // Get full path of object. We need to extract the domain name from
    // the full path and then look for a GC in that domain.
    //
    WCHAR  *pszMachineName = const_cast<LPWSTR> (pwcsPathName);
    AP<unsigned short> pwcsTmpMachineName;

    if (dwObjectType == MQDS_QUEUE)
    {
        AP<unsigned short> pwcsQueueName;

        hr = MQADSpSplitAndFilterQueueName(
					pwcsPathName,
					&pwcsTmpMachineName,
					&pwcsQueueName
					);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 90);
        }
        pszMachineName = pwcsTmpMachineName;
    }

    AP<WCHAR> pwcsFullPathName;
    DS_PROVIDER createProvider;

    if (!fUseProperties)
    {
        hr = MQADSpGetFullComputerPathName(
					pszMachineName,
					e_MsmqComputerObject,
					&pwcsFullPathName,
					&createProvider
					);
        if ((hr == MQDS_OBJECT_NOT_FOUND) && (dwObjectType == MQDS_MACHINE))
        {
            //
            // We're trying to create a msmqConfiguration object, so it's ok
            // if we get this error when trying to find this object...
            // (e_MsmqComputerObject look for a computer object that already
            //  contain a msmqConfiguration object).
            // So just look for a computer object, don't check if it already
            // has a msmqConfiguration one.
            // The reason we first look for a computer that already has a msmq
            // object is to support the upgrade wizard on PSC and in recovery
            // mode, when most objects already exist. In those cases, if we'll
            // first look for any computer object, we may find a second one with
            // a duplicate name and try to create the msmqConfiguration object
            // again on that wrong computer object. Too bad. Creation will fail
            // because of duplicate guid.
            //
            hr = MQADSpGetFullComputerPathName(
						pszMachineName,
						e_RealComputerObject,
						&pwcsFullPathName,
						&createProvider
						);
        }
    }
    else
    {
        //
        // we already know full path name and provider
        //
        ASSERT(*ppwszFullPathName);
        pwcsFullPathName = new WCHAR[wcslen(*ppwszFullPathName) + 1];
        wcscpy(pwcsFullPathName, *ppwszFullPathName);

        createProvider = (DS_PROVIDER) *pulProvider;
        ASSERT(createProvider >= eDomainController &&
               createProvider <= eSpecificObjectInGlobalCatalog);
    }

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100);
    }

    //
    // extract domain name
    //
    WCHAR *pszDomainName = wcsstr(pwcsFullPathName, x_DcPrefix);
    ASSERT(pszDomainName);
    if (!pszDomainName)
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 110);
    }

    //
    // Let's improve performance and pass machine full name to
    // CoreCreateObject(), saving an LDAP query.
    //
    AP<PROPID>       paNewProp;
    AP<PROPVARIANT>  paNewVar;

    _AllocateNewProps(
			cp,
			aProp,
			apVar,
			3,
			&paNewProp,
			&paNewVar
			);

    DWORD dwIndex = 0;
    paNewProp[cp + dwIndex] = PROPID_QM_FULL_PATH;
    paNewVar[cp + dwIndex].vt = VT_LPWSTR;
    paNewVar[cp + dwIndex].pwszVal = pwcsFullPathName;

    dwIndex++;
    DWORD dwProvIndex = cp + dwIndex;
    paNewProp[dwProvIndex] = PROPID_QM_MIG_PROVIDER;
    paNewVar[dwProvIndex].vt = VT_UI4;
    paNewVar[dwProvIndex].ulVal = (ULONG) createProvider;

    dwIndex++;
    ULONG dwGcIndex = cp + dwIndex;
    paNewProp[dwGcIndex] = PROPID_QM_MIG_GC_NAME;
    paNewVar[dwGcIndex].vt = VT_EMPTY;

    dwIndex++;
    ASSERT(dwIndex == MIG_EXTRA_PROPS);

    if (fReturnProperties)
    {
        *pulProvider = (ULONG) createProvider;
        *ppwszFullPathName = new WCHAR[wcslen(pwcsFullPathName) + 1];
        wcscpy(*ppwszFullPathName, pwcsFullPathName);
    }

    if (lstrcmpi(s_pszMyDomainName, pszDomainName) == 0)
    {
        if (DSCoreIsServerGC())
        {
            //
            // Object in local domain. Local server is also GC so it
            // supports creating objects with predefined GUIDs.
            // Go ahead, no need for refferals.
            //
            ASSERT(createProvider == eLocalDomainController);

            hr = DSCoreCreateObject(
						dwObjectType,
						pwcsPathName,
						(cp + dwIndex),
						paNewProp,
						paNewVar,
						cpEx,
						aPropEx,
						apVarEx,
						pRequestDsServerInternal,
						pObjInfoRequest,
						pParentInfoRequest
						);
            if (FAILED(hr))
            {
                WRITE_MSMQ_LOG((
					MSMQ_LOG_ERROR,
					e_LogDS,
					LOG_DS_CREATE_ON_GC,
					L"DSCore: CreateMigrated on GC failed, hr- %lxh, Path- %s",
					hr,
					pwcsFullPathName
					));
            }
            return LogHR(hr, s_FN, 120);
        }
        else
        {
            //
            // Look for a rmote GC, even for local domain.
            //
            createProvider = eDomainController;
            paNewVar[ dwProvIndex ].ulVal = (ULONG) createProvider;
        }
    }

    ASSERT(createProvider == eDomainController);

    //
    // OK, it's time to query the local DS and find the GC in the remote
    // domain.
    //
    R<IDirectorySearch> pDSSearch = NULL;
    ADS_SEARCH_HANDLE   hSearch ;
    AP<WCHAR>           pwszDCName;

    hr = _GCLookupBegin(
				pszDomainName,
				&pDSSearch.ref(),
				&hSearch,
				&pwszDCName
				);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 130);
    }

    CAutoCloseSearchHandle cCloseSearchHandle(pDSSearch.get(), hSearch);

    do
    {
        if (pwszDCName)
        {
            paNewVar[dwGcIndex].vt = VT_LPWSTR;
            paNewVar[dwGcIndex].pwszVal = pwszDCName;
        }
        else
        {
            //
            // If first query to find a remote GC fail then try local DC.
            //
        }

        hr = DSCoreCreateObject(
					dwObjectType,
					pwcsPathName,
					(cp + dwIndex),
					paNewProp,
					paNewVar,
					cpEx,
					aPropEx,
					apVarEx,
					pRequestDsServerInternal,
					pObjInfoRequest,
					pParentInfoRequest
					);
        LogHR(hr, s_FN, 140);

        if (SUCCEEDED(hr) || !pwszDCName)
        {
            return hr ;
        }

        if ((hr == MQ_ERROR_MACHINE_EXISTS) ||
            (hr == MQ_ERROR_QUEUE_EXISTS))
        {
            //
            // Object already exist. No need to try other GCs...
            //
            return hr;
        }

        //
        // Log the failure
        //
        WRITE_MSMQ_LOG((
			MSMQ_LOG_ERROR,
			e_LogDS,
			LOG_DS_CREATE_ON_GC,
			L"DSCore: CreateMigrated failed, hr- %lxh, DC- %s, Path- %s",
			hr,
			pwszDCName,
			pwcsFullPathName
			));

        pwszDCName.free();

         _GCLookupNext(
				pDSSearch.get(),
				hSearch,
				&pwszDCName
				);
    }
    while (pwszDCName);

    return LogHR(MQ_ERROR_CANNOT_CREATE_ON_GC, s_FN, 150);
}

//+-----------------------------------------------------------------------
//
//  HRESULT DSCoreGetGCListInDomain()
//
//  Look for msmq servers on GC server in a specific domain. The result
//  is returned in a list that has the format needed by mqdscli, i.e.,
//  "11Server1,11Server2,11Server3".
//
//+-----------------------------------------------------------------------

HRESULT
DSCoreGetGCListInDomain(
	IN  LPCWSTR              pwszComputerName,
	IN  LPCWSTR              pwszDomainName,
	OUT LPWSTR              *lplpwszGCList
	)
{
    *lplpwszGCList = NULL;

    if (pwszComputerName != NULL)
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 200);
    }

    R<IDirectorySearch> pDSSearch = NULL;
    ADS_SEARCH_HANDLE   hSearch;
    AP<WCHAR> pwszDCName;

    HRESULT hr = _GCLookupBegin(
						pwszDomainName,
						&pDSSearch.ref(),
						&hSearch,
						&pwszDCName
						);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 600);
    }

    CAutoCloseSearchHandle cCloseSearchHandle(pDSSearch.get(), hSearch);

    if (pwszDCName == NULL)
    {
        WRITE_MSMQ_LOG((
			MSMQ_LOG_ERROR,
			e_LogDS,
			LOG_DS_CREATE_ON_GC,
			L"DSCore: GetGCList(), no GC in %s",
			pwszDomainName
			));

        return MQ_ERROR_NO_GC_IN_DOMAIN;
    }

    WCHAR wszServersList[MAX_REG_DSSERVER_LEN] = {0};

    do
    {
        //
        // Check if this GC also has msmq server running on it.
        //
        AP<WCHAR> pwcsFullPathName;
        DS_PROVIDER createProvider;

        hr = MQADSpGetFullComputerPathName(
					pwszDCName,
					e_MsmqComputerObject,
					&pwcsFullPathName,
					&createProvider
					);
        if (SUCCEEDED(hr))
        {
            DWORD dwLen = wcslen(wszServersList) +
                          wcslen(pwszDCName)     +
                          4 ;

            if (dwLen >= (sizeof(wszServersList) / sizeof(wszServersList[0])))
            {
                //
                // string got too long. quit loop.
                //
                break ;
            }

            wcscat(wszServersList, L"11");
            wcscat(wszServersList, pwszDCName);
            wcscat(wszServersList, L",");
        }

        pwszDCName.free();

        _GCLookupNext(
			pDSSearch.get(),
			hSearch,
			&pwszDCName
			);
    }
    while (pwszDCName);

    DWORD dwLen = wcslen(wszServersList);
    if (dwLen > 3)
    {
        wszServersList[dwLen - 1] = 0; // remove last comma.
        *lplpwszGCList = new WCHAR[dwLen];
        wcscpy(*lplpwszGCList, wszServersList);
        return MQ_OK;
    }

    return LogHR(MQ_ERROR_NO_MSMQ_SERVERS_ON_GC, s_FN, 610);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\dsmixmd.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dsmixmd.h

Abstract:

    definitions used for migration or mixed mode or  support of NT4 clients.

Author:

    Doron Juster (DoronJ)

--*/

//
// This is the search filter for finding the GC.
// We only have to append the domain name.
// Don't ask why it is correct. I don't know. DS people told us to use it.
// We're so happy that it does what we need that no further questions were
// ever asked.
//
const WCHAR x_GCLookupSearchFilter[] =
L"(&(objectCategory=ntdsDsa)(options:1.2.840.113556.1.4.804:=1)(hasMasterNcs=" ;
const DWORD x_GCLookupSearchFilterLength =
                  (sizeof( x_GCLookupSearchFilter ) /sizeof(WCHAR)) -1 ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\hquery.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
	hquery.cpp

Abstract:
	Implementation of different query handles
	
Author:

    Ronit Hartmann (ronith)

--*/
#include "ds_stdh.h"
#include "mqadsp.h"
#include "coreglb.h"
#include "hquery.h"

#include "hquery.tmh"

static WCHAR *s_FN=L"mqdscore/hquery";

/*====================================================

CQueryHandle::LookupNext

Arguments:
      pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
      pbBuffer- a caller allocated buffer



Performs Locate next on the DS directly
=====================================================*/

HRESULT CQueryHandle::LookupNext(
                IN     CDSRequestContext *  pRequestContext,
                IN OUT DWORD  *             pdwSize,
                OUT    PROPVARIANT  *       pbBuffer)
{
        HRESULT hr;

    DWORD  NoOfRecords;

    //
    // Calculate the number of records ( == results) to be read
    //
    NoOfRecords = *pdwSize /  m_dwNoPropsInResult;

    if ( NoOfRecords == 0)
    {
        //
        //  Number of properties is not big enough to hold one result
        //
        *pdwSize = 0;
        return LogHR(MQ_ERROR_RESULT_BUFFER_TOO_SMALL, s_FN, 10);
    }

    hr =    g_pDS->LocateNext(
            m_hCursor.GetHandle(),
            pRequestContext,
            pdwSize ,
            pbBuffer
            );


    return LogHR(hr, s_FN, 20);

}

/*====================================================

CUserCertQueryHandle::LookupNext

Arguments:
      pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
      pbBuffer- a caller allocated buffer



simulates query functionality on array of user-signed-certificates.
=====================================================*/
HRESULT CUserCertQueryHandle::LookupNext(
                IN      CDSRequestContext *    /*pRequestContext*/,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer)
{
    if ( m_blobNT5UserCert.pBlobData == NULL &&
         m_blobNT4UserCert.pBlobData == NULL)
    {
        *pdwSize = 0;
        return(MQ_OK);
    }
    //
    //   m_blobNT?UserCert contains all the user certificates
    //
    CUserCertBlob * pNT5UserCertBlob = reinterpret_cast<CUserCertBlob *>(m_blobNT5UserCert.pBlobData);
    CUserCertBlob * pNT4UserCertBlob = reinterpret_cast<CUserCertBlob *>(m_blobNT4UserCert.pBlobData);
    //
    //   return the requested amount of responses
    //
    DWORD dwNT5NuberOfUserCertificates = 0;
    if ( pNT5UserCertBlob != NULL)
    {
        dwNT5NuberOfUserCertificates= pNT5UserCertBlob->GetNumberOfCerts();
    }
    DWORD dwNT4NuberOfUserCertificates = 0;
    if ( pNT4UserCertBlob != NULL)
    {
        dwNT4NuberOfUserCertificates= pNT4UserCertBlob->GetNumberOfCerts();
    }
    DWORD dwNuberOfUserCertificates = dwNT5NuberOfUserCertificates + dwNT4NuberOfUserCertificates;
    if ( dwNuberOfUserCertificates - m_dwNoCertRead == 0)
    {
       //
       //   No more responses left
       //
       *pdwSize = 0;
       return(MQ_OK);
    }
    DWORD dwNumResponses = (dwNuberOfUserCertificates - m_dwNoCertRead) > *pdwSize?
                *pdwSize:  (dwNuberOfUserCertificates - m_dwNoCertRead);

    HRESULT hr = MQ_OK;
    for (DWORD i = 0; i < dwNumResponses; i++)
    {
        if ( m_dwNoCertRead + i + 1 <=  dwNT5NuberOfUserCertificates)
        {
            hr = pNT5UserCertBlob->GetCertificate(
                            i + m_dwNoCertRead,
                            &pbBuffer[ i]
                            );
        }
        else
        {
            hr = pNT4UserCertBlob->GetCertificate(
                            i + m_dwNoCertRead - dwNT5NuberOfUserCertificates,
                            &pbBuffer[ i]
                            );
        }
		if (FAILED(hr))
		{
			break;
		}
    }
    m_dwNoCertRead += dwNumResponses;
    return LogHR(hr, s_FN, 30);
}




/*====================================================

CRoutingServerQueryHandle::LookupNext

Arguments:
      pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
      pbBuffer- a caller allocated buffer


=====================================================*/
HRESULT CRoutingServerQueryHandle::LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer)
{
    HRESULT hr;

    DWORD  NoOfRecords;
    DWORD NoResultRead = 0;

    //
    // Calculate the number of records ( == results) to be read
    //
    NoOfRecords = *pdwSize /  m_cCol;

    if ( NoOfRecords == 0)
    {
        //
        //  Number of properties is not big enough to hold one result
        //
        *pdwSize = 0;
        return LogHR(MQ_ERROR_RESULT_BUFFER_TOO_SMALL, s_FN, 40);
    }
    //
    //  From the DS read the unique ids of the FRSs
    //
    DWORD cp = NoOfRecords;
    AP<MQPROPVARIANT> pvarFRSid = new MQPROPVARIANT[cp];


    hr =    g_pDS->LocateNext(
            m_hCursor.GetHandle(),
            pRequestContext,
            &cp ,
            pvarFRSid
            );

    if (FAILED(hr))
    {
        //
        // BUGBUG - are there other indication to failure of Locate next?
        return LogHR(hr, s_FN, 50);
    }

    //
    //  For each of the results, retreive the properties
    //  the user asked for in locate begin
    //
    MQPROPVARIANT * pvar = pbBuffer;
    for (DWORD j = 0; j < *pdwSize; j++, pvar++)
    {
        pvar->vt = VT_NULL;
    }
    pvar = pbBuffer;

    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    for (DWORD i = 0; i < cp; i++)
    {
        hr = g_pDS->GetObjectProperties(
                    eGlobalCatalog,	
                    &requestDsServerInternal,  // internal DS server operation
 	                NULL,
                    pvarFRSid[i].puuid,
                    m_cCol,
                    m_aCol,
                    pvar);

        delete pvarFRSid[i].puuid;
        if (FAILED(hr))
        {
            continue;
        }
        pvar+= m_cCol;
        NoResultRead++;
    }
    *pdwSize = NoResultRead * m_cCol;
    return(MQ_OK);
}


HRESULT CSiteQueryHandle::FillInOneResponse(
                IN   const GUID *          pguidSiteId,
                IN   LPCWSTR               pwcsSiteName,
                OUT  PROPVARIANT *         pbBuffer)
{
    AP<GUID> paSiteGates;
    DWORD    dwNumSiteGates = 0;
    HRESULT hr;

    if ( m_fSiteGatesRequired)
    {
        //
        //  Fetch the site gates of this site
        //
        CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr = MQADSpGetSiteGates(
                   pguidSiteId,
                   &requestDsServerInternal,     // internal DS server operation
                   &dwNumSiteGates,
                   &paSiteGates
                   );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 60);
        }
    }

    //
    //  Fill in the values into the variant array
    //
    hr = MQ_OK;
    for (DWORD i = 0; i < m_cCol; i++)
    {
        switch  (m_aCol[i])
        {
            case PROPID_S_PATHNAME:
                {
                pbBuffer[i].vt = VT_LPWSTR;
                DWORD len = wcslen(pwcsSiteName);
                pbBuffer[i].pwszVal = new WCHAR[len + 1];
                wcscpy( pbBuffer[i].pwszVal, pwcsSiteName);
                }
                break;

            case PROPID_S_SITEID:
                pbBuffer[i].vt = VT_CLSID;
                pbBuffer[i].puuid = new GUID ;
                *pbBuffer[i].puuid = *pguidSiteId;
                break;

            case PROPID_S_GATES:
                pbBuffer[i].vt = VT_CLSID | VT_VECTOR;
                pbBuffer[i].cauuid.cElems = dwNumSiteGates;
                pbBuffer[i].cauuid.pElems = paSiteGates.detach();
                break;

            case PROPID_S_PSC:
                pbBuffer[i].vt = VT_LPWSTR;
                pbBuffer[i].pwszVal = new WCHAR[ 3];
                wcscpy( pbBuffer[i].pwszVal, L"");
                break;

            default:
                ASSERT(0);
                hr = MQ_ERROR;
                break;
        }
    }
    return LogHR(hr, s_FN, 70);

}


/*====================================================

CSiteQueryHandle::LookupNext

Arguments:
      pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
      pbBuffer- a caller allocated buffer

Performs locate next of site objects ( need to make sure if it is an MSMQ site or not)
=====================================================*/
HRESULT CSiteQueryHandle::LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer)
{
    HRESULT hr;

    DWORD  NoOfRecords;
    DWORD NoResultRead = 0;

    //
    // Calculate the number of records ( == results) to be read
    //
    NoOfRecords = *pdwSize /  m_cCol;

    if ( NoOfRecords == 0)
    {
        //
        //  Number of properties is not big enough to hold one result
        //
        *pdwSize = 0;
        return LogHR(MQ_ERROR_RESULT_BUFFER_TOO_SMALL, s_FN, 80);
    }

    while ( NoResultRead < NoOfRecords)
    {
        //
        //  Retrieve the site id and name
        //
        DWORD cp = 2;
        MQPROPVARIANT var[2];
        var[0].vt = VT_NULL;
        var[1].vt = VT_NULL;

        hr = g_pDS->LocateNext(
            m_hCursor.GetHandle(),
            pRequestContext,
            &cp ,
            var
            );
        if (FAILED(hr) || ( cp == 0))
        {
            //
            //  no more sites
            //
            break;
        }
        P<GUID> pguidSiteId = var[0].puuid;
        AP<WCHAR> pwcsSiteName = var[1].pwszVal;

        hr =  FillInOneResponse(
                pguidSiteId,
                pwcsSiteName,
                &pbBuffer[ m_cCol * NoResultRead]);
        if (FAILED(hr))
        {
            //
            //  continue to next site
            //
            continue;
        }
        NoResultRead++;

    }
    *pdwSize = NoResultRead * m_cCol;
    return(MQ_OK);
}



/*====================================================

CConnectorQueryHandle::LookupNext

Arguments:
      pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
      pbBuffer- a caller allocated buffer

=====================================================*/
HRESULT CConnectorQueryHandle::LookupNext(
                IN      CDSRequestContext * /*pRequestContext*/,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer)
{
    HRESULT hr;

    DWORD NoOfRecords;
    DWORD NoResultRead = 0;

    //
    // Calculate the number of records ( == results) to be read
    //
    NoOfRecords = *pdwSize /  m_cCol;

    if ( NoOfRecords == 0)
    {
        //
        //  Number of properties is not big enough to hold one result
        //
        *pdwSize = 0;
        return LogHR(MQ_ERROR_RESULT_BUFFER_TOO_SMALL, s_FN, 90);
    }
    MQPROPVARIANT * pvar = pbBuffer;
    for (DWORD j = 0; j < *pdwSize; j++, pvar++)
    {
        pvar->vt = VT_NULL;
    }
    pvar = pbBuffer;


    while ( NoResultRead < NoOfRecords)
    {
        if ( m_dwNumGatesReturned == m_pSiteGateList->GetNumberOfGates())
        {
            //
            //  no more gates to return
            //
            break;
        }

        //
        //  Retreive the properties
        //  the user asked for in locate begin
        //
        CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr = g_pDS->GetObjectProperties(
                    eGlobalCatalog,	
                    &requestDsServerInternal,   // internal DS server operation
 	                NULL,
                    m_pSiteGateList->GetSiteGate(m_dwNumGatesReturned),
                    m_cCol,
                    m_aCol,
                    pvar);
        if (FAILED(hr))
        {
            //
            //  BUGBUG - what to do in case of failure ??
            //
            break;
        }
        m_dwNumGatesReturned++;

        NoResultRead++;
        pvar += m_cCol;
    }
    *pdwSize = NoResultRead * m_cCol;
    return(MQ_OK);
}


/*====================================================

CCNsQueryHandle::LookupNext

Arguments:
      pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
      pbBuffer- a caller allocated buffer

=====================================================*/
HRESULT CCNsQueryHandle::LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer)
{

    DWORD NoOfRecords;
    DWORD NoResultRead = 0;
    ASSERT( m_aCol[0] == PROPID_CN_PROTOCOLID);
    ASSERT( m_aCol[1] == PROPID_CN_GUID);
    ASSERT( m_cCol == 2);

    //
    // Calculate the number of records ( == results) to be read
    //
    NoOfRecords = *pdwSize /  m_cCol;

    if ( NoOfRecords == 0)
    {
        //
        //  Number of properties is not big enough to hold one result
        //
        *pdwSize = 0;
        return LogHR(MQ_ERROR_RESULT_BUFFER_TOO_SMALL, s_FN, 100);
    }

    //
    //  Read the sites
    //
    HRESULT hr;
    while ( NoResultRead < NoOfRecords) 
    {
        //
        //  Retrieve the site-id and foreign
        //
        const DWORD cNumProps = 2;
        DWORD cp =  cNumProps;
        MQPROPVARIANT var[cNumProps];
        var[0].vt = VT_NULL;
        var[1].vt = VT_NULL;

        hr = g_pDS->LocateNext(
                    m_hCursor.GetHandle(),
                    pRequestContext,
                    &cp,
                    var
                    );
        if ((FAILED(hr)) || ( cp == 0))
        {
            //
            //  No more results to return
            //
            break;
        }
        AP<GUID> pguidSiteId = var[0].puuid;

        MQPROPVARIANT * pvar = pbBuffer + m_cCol * NoResultRead;
        for ( DWORD i = 0; i < m_cCol; i++)
        {
            if (m_aCol[i] == PROPID_CN_PROTOCOLID)
            {
                //
                //  Is it a foreign site
                //
                if ( var[1].bVal != 0)
                {
                    pvar->bVal = FOREIGN_ADDRESS_TYPE;
                }
                else
                {
                     pvar->bVal = IP_ADDRESS_TYPE;
                }
                pvar->vt = VT_UI1;
            }
            if (m_aCol[i] == PROPID_CN_GUID)
            {
                pvar->vt = VT_CLSID;
                pvar->puuid = new GUID;
                *pvar->puuid = *pguidSiteId;
            }
            pvar++;
        }
        NoResultRead++;

    }
    *pdwSize =  m_cCol * NoResultRead;

    return(MQ_OK);
}



/*====================================================

CCNsProtocolQueryHandle::LookupNext

Arguments:
      pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
      pbBuffer- a caller allocated buffer

=====================================================*/
HRESULT CCNsProtocolQueryHandle::LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer)
{

    DWORD NoOfRecords;
    DWORD NoResultRead = 0;
    ASSERT( m_aCol[0] == PROPID_CN_NAME);
    ASSERT( m_aCol[1] == PROPID_CN_GUID);
    ASSERT( m_cCol == 2);

    //
    // Calculate the number of records ( == results) to be read
    //
    NoOfRecords = *pdwSize /  m_cCol;

    if ( NoOfRecords == 0)
    {
        //
        //  Number of properties is not big enough to hold one result
        //
        *pdwSize = 0;
        return LogHR(MQ_ERROR_RESULT_BUFFER_TOO_SMALL, s_FN, 110);
    }
    //
    //  In locate begin 3 properties were asked:
    //  PROPID_S_PATHNAME, PROPID_S_SITEID, PROPID_S_FOREIGN
    //

    //
    //  Read the sites
    //
    HRESULT hr;
    while ( NoResultRead < NoOfRecords)
    {
        //
        //  Retrieve the site-id and foreign
        //
        const DWORD cNumProps = 3;
        DWORD cp =  cNumProps;
        MQPROPVARIANT var[cNumProps];
        var[0].vt = VT_NULL;
        var[1].vt = VT_NULL;
        var[2].vt = VT_NULL;

        hr = g_pDS->LocateNext(
                    m_hCursor.GetHandle(),
                    pRequestContext,
                    &cp,
                    var
                    );
        if ((FAILED(hr)) || ( cp == 0))
        {
            //
            //  No more results to return
            //
            break;
        }
        AP<GUID> pguidSiteId = var[1].puuid;
        AP<WCHAR> pwcsSiteName = var[0].pwszVal;

        //
        //  If it is a foreign site - don't return it as either ip or ipx site
        //
        if ( var[2].bVal > 0)
        {
            continue;
        }

        MQPROPVARIANT * pvar = pbBuffer + m_cCol * NoResultRead;
        for ( DWORD i = 0; i < m_cCol; i++)
        {
            if (m_aCol[i] == PROPID_CN_GUID)
            {
                pvar->vt = VT_CLSID;
                pvar->puuid = pguidSiteId.detach();
            }
            if (m_aCol[i] == PROPID_CN_NAME)
            {
                pvar->vt = VT_LPWSTR;
                pvar->pwszVal = pwcsSiteName.detach();
            }
            pvar++;
        }

        NoResultRead++;
    }
    *pdwSize =  m_cCol * NoResultRead;

    return(MQ_OK);
}


/*====================================================

CMqxploreCNsQueryHandle::LookupNext

Arguments:
      pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
      pbBuffer- a caller allocated buffer

=====================================================*/
HRESULT CMqxploreCNsQueryHandle::LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer)
{
    DWORD NoOfRecords;
    DWORD NoResultRead = 0;

    //
    // See reqparse.cpp, MqxploreQueryCNs(), for explanation about these
    // asserts and "if"s.
    //
    if ( m_cCol == 4)
    {
        ASSERT( m_aCol[0] == PROPID_CN_NAME);
        ASSERT( m_aCol[1] == PROPID_CN_NAME);
        ASSERT( m_aCol[2] == PROPID_CN_GUID);
        ASSERT( m_aCol[3] == PROPID_CN_PROTOCOLID);
    }
    else if ( m_cCol == 3)
    {
        ASSERT( m_aCol[0] == PROPID_CN_NAME);
        ASSERT( m_aCol[1] == PROPID_CN_PROTOCOLID);
        ASSERT( m_aCol[2] == PROPID_CN_GUID);
    }
    else
    {
        ASSERT(0) ;
    }

    //
    // Calculate the number of records ( == results) to be read
    //
    NoOfRecords = *pdwSize /  m_cCol;

    if ( NoOfRecords == 0)
    {
        //
        //  Number of properties is not big enough to hold one result
        //
        *pdwSize = 0;
        return LogHR(MQ_ERROR_RESULT_BUFFER_TOO_SMALL, s_FN, 120);
    }
    //
    //  In locate begin 3 properties were asked:
    //  PROPID_S_PATHNAME, PROPID_S_SITEID, PROPID_S_FOREIGN
    //

    //
    //  Read the sites
    //
    HRESULT hr;
    while ( NoResultRead < NoOfRecords)
    {
        //
        //  Retrieve the site-name, site-id and foreign
        //
        const DWORD cNumProps = 3;
        DWORD cp =  cNumProps;
        MQPROPVARIANT var[cNumProps];
        var[0].vt = VT_NULL;
        var[1].vt = VT_NULL;
        var[2].vt = VT_NULL;

        hr = g_pDS->LocateNext(
                    m_hCursor.GetHandle(),
                    pRequestContext,
                    &cp,
                    var
                    );
        if ((FAILED(hr)) || ( cp == 0))
        {
            //
            //  No more results to return
            //
            break;
        }
        AP<GUID> pguidSiteId = var[1].puuid;
        AP<WCHAR> pwcsSiteName = var[0].pwszVal;

        //
        //  Don't return foreign sites. This means that when using nt4
        //  mqxplore, you cannot add a foreign CN to a "real" machine, and
        //  when you try to create foreign machine, you get a dialog without
        //  any foreign CNs. workaround- use win2k mmc.
        //
        if (var[2].bVal > 0)
        {
            continue;
        }

        MQPROPVARIANT * pvar = pbBuffer + m_cCol * NoResultRead;
        for ( DWORD i = 0; i < m_cCol; i++)
        {
            if (m_aCol[i] == PROPID_CN_GUID)
            {
                pvar->vt = VT_CLSID;
                pvar->puuid = pguidSiteId.detach();
            }
            if (m_aCol[i] == PROPID_CN_NAME)
            {
                pvar->vt = VT_LPWSTR;
                DWORD len = wcslen( pwcsSiteName);
                pvar->pwszVal = new WCHAR[ len + 1];
                wcscpy( pvar->pwszVal, pwcsSiteName);
            }
            if (m_aCol[i] == PROPID_CN_PROTOCOLID)
            {
                pvar->vt = VT_UI1;
                pvar->bVal = IP_ADDRESS_TYPE;
            }
            pvar++;
        }

        NoResultRead++;
    }
    *pdwSize =  m_cCol * NoResultRead;

    return(MQ_OK);
}

/*====================================================

CFilterLinkResultsHandle::LookupNext

Arguments:
      pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
      pbBuffer- a caller allocated buffer

=====================================================*/
HRESULT CFilterLinkResultsHandle::LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer)
{

    DWORD NoOfRecords;
    DWORD NoResultRead = 0;

    //
    // Calculate the number of records ( == results) to be read
    //
    NoOfRecords = *pdwSize /  m_cCol;

    if ( NoOfRecords == 0)
    {
        //
        //  Number of properties is not big enough to hold one result
        //
        *pdwSize = 0;
        return LogHR(MQ_ERROR_RESULT_BUFFER_TOO_SMALL, s_FN, 130);
    }

    //
    //  Read the results one by one and check the validity of the site-link
    //
    HRESULT hr;
    PROPVARIANT * pbNextResultToFill = pbBuffer;

    while ( NoResultRead < NoOfRecords)
    {
        DWORD dwOneResultSize = m_cCol;

        hr =  g_pDS->LocateNext(
                m_hCursor.GetHandle(),
                pRequestContext,
                &dwOneResultSize,
                pbNextResultToFill
                );
        if (FAILED(hr) || (dwOneResultSize == 0))
        {
            break;
        }
        //
        //  validate siteLink
        //
        if (m_indexNeighbor1Column != m_cCol)
        {
            if ((pbNextResultToFill+m_indexNeighbor1Column)->vt == VT_EMPTY)
            {
                continue;
            }
        }
        if (m_indexNeighbor2Column != m_cCol)
        {
            if ((pbNextResultToFill+m_indexNeighbor2Column)->vt == VT_EMPTY)
            {
                continue;
            }
        }
        NoResultRead++;
        pbNextResultToFill += m_cCol;
    }
    *pdwSize =  m_cCol * NoResultRead;

    return(MQ_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\ipsite.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ipsite.h

Abstract:

    Definitions of CIpSite class, finding NT5 sites of a machine given IP/Name

Author:

    Raanan Harari (RaananH)

--*/

#ifndef __IPSITE_H_
#define __IPSITE_H_

#include <Ex.h>

struct IPSITE_SiteArrayEntry
{
    AP<WCHAR> pwszSiteDN;
    GUID      guidSite;
    ULONG     ulIpAddress;
};

//----------------------------------------------------------------------------
//
// Structure describing several subnets.
//
// The most significant byte of an IP address is used to index into an array
// of SubTrees.  Each Subtree entry has either a pointer to the next level of
// the tree (to be indexed into with the next byte of the IP address) or a
// pointer to an IPSITE_SUBNET leaf identifying the subnet this IP address is on.
//
// Both pointers can be NULL indicating that the subnet isn't registered.
//
// Both pointers can be non-NULL indicating that both a non-specific and specific
// subnet may be available.  The most specific subnet available for a particular
// IP address should be used.
//
//
// Multiple entries can point to the same IPSITE_SUBNET leaf.  If the subnet mask is
// not an even number of bytes long, all of the entries represent IP addresses
// that correspond to the subnet mask will point to the subnet mask.
//

//
// Structure describing a single subnet.
//
struct IPSITE_SUBNET
{
    LIST_ENTRY Next;        // Link for m_SubnetList
    ULONG SubnetAddress;    // Subnet address. (Network bytes order)
    ULONG SubnetMask;       // Subnet mask. (Network byte order)
    AP<WCHAR> SiteDN;       // DN of site this subnet is in
    GUID SiteGuid;          // guid of site this subnet is in
    ULONG ReferenceCount;   // Reference Count
    BYTE SubnetBitCount;    // Number of bits in the subnet mask
};

struct IPSITE_SUBNET_TREE;  //fwd declaration
struct IPSITE_SUBNET_TREE_ENTRY
{
    IPSITE_SUBNET_TREE *Subtree;    // Link to the next level of the tree
    IPSITE_SUBNET *Subnet;          // Pointer to the subnet itself.
};

struct IPSITE_SUBNET_TREE
{
    IPSITE_SUBNET_TREE_ENTRY Subtree[256];
};

//
// Class that holds the tree & performs the translations site/subnet/ip
//
class CIpSite
{
public:
    CIpSite();
    virtual ~CIpSite();
    HRESULT Initialize( DWORD dwMinTimeToAllowNextRefresh,
                        BOOL fReplicationMode ) ;
    HRESULT Initialize(BOOL fReplicationMode);
    HRESULT FindSiteByIpAddress(IN ULONG ulIpAddress,
                                OUT LPWSTR * ppwszSiteDN,
                                OUT GUID * pguidSite);
    HRESULT FindSitesByComputerName(IN LPCWSTR pwszComputerName,
                                    IN LPCWSTR pwszComputerDnsName,
                                    OUT IPSITE_SiteArrayEntry ** prgSites,
                                    OUT ULONG * pcSites,
                                    OUT ULONG ** prgAddrs,
                                    OUT ULONG * pcAddrs);


private:
    HRESULT FillSubnetSiteTree(IN IPSITE_SUBNET_TREE_ENTRY* pRootSubnetTree);
    HRESULT AddSubnetSiteToTree(IN LPCWSTR pwszSubnetName,
                                IN LPCWSTR pwszSiteDN,
                                IN const GUID * pguidSite,
                                IPSITE_SUBNET_TREE_ENTRY* pRootSubnetTree);
    void FindSubnetEntry(IN LPCWSTR pwszSiteDN,
                         IN const GUID * pguidSite,
                         IN ULONG ulSubnetAddress,
                         IN ULONG ulSubnetMask,
                         IN BYTE bSubnetBitCount,
                         OUT IPSITE_SUBNET** ppSubnet);
    BOOL InternalFindSiteByIpAddress(IN ULONG ulIpAddress,
                                     OUT LPWSTR * ppwszSiteDN,
                                     OUT GUID * pguidSite);

    HRESULT Refresh();
    //
    //  Refresh the subnet tree cache
    //

    static void WINAPI RefrshSubnetTreeCache(
                IN CTimer* pTimer
               );



    CCriticalSection m_csTree;     // critical section for tree manipulation
    LIST_ENTRY m_SubnetList;       // List of all IPSITE_SUBNET entries
    IPSITE_SUBNET_TREE_ENTRY m_SubnetTree;     // Tree of subnets.
    DWORD m_dwMinTimeToAllowNextRefresh; // min time between subsequent refreshes (in millisecs)

    CTimer m_RefreshTimer;
    BOOL   m_fInitialize;          // indication that initialization succedded

};

//-----------------------------
#endif //__IPSITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\fornsite.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    fornsite.cpp

Abstract:

    MQDSCORE library,
    A class that keeps a map of foreign sites.

Author:

    ronit hartmann (ronith)  

--*/
#ifndef __FORNSITE_H_
#define __FORNSITE_H_



class CMapForeignSites 
{
public:
    CMapForeignSites();
    ~CMapForeignSites();

	BOOL IsForeignSite( const GUID * pguidSite);


private:
	CCriticalSection m_cs;
	CMap<GUID , GUID , BOOL, BOOL> m_mapForeignSites;

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\ipsite.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ipsite.cpp

Abstract:

    Implementation of CIpSite class, finding NT5 sites of a machine given IP/Name
    Major parts ported from NT5 netlogon service.
    List manipulation ported from nthack.h

    About the main algorithm ported from netlogon service (nlsite.c):

    The most significant byte of an IP address is used to index into an array
    of SubTrees.  Each Subtree entry has either a pointer to the next level of
    the tree (to be indexed into with the next byte of the IP address) or a
    pointer to an IPSITE_SUBNET leaf identifying the subnet this IP address is on.

    Both pointers can be NULL indicating that the subnet isn't registered.

    Both pointers can be non-NULL indicating that both a non-specific and specific
    subnet may be available.  The most specific subnet available for a particular
    IP address should be used.

    Multiple entries can point to the same IPSITE_SUBNET leaf.  If the subnet mask is
    not an even number of bytes long, all of the entries represent IP addresses
    that correspond to the subnet mask will point to the subnet mask.


Author:

    Raanan Harari (RaananH)
    Ilan Herbst    (ilanh)   9-July-2000 

--*/

#include "ds_stdh.h"
#include "uniansi.h"
#include <activeds.h>
#include <winsock.h>
#include "dsutils.h"
#include "mqads.h"
#include "ipsite.h"
#include "mqdsname.h"
#include "_mqini.h"
#include "_registr.h"
#include "coreglb.h"
#include "utils.h"
#include "ex.h"

#include "ipsite.tmh"

static WCHAR *s_FN=L"mqdscore/ipsite";

//----------------------------------------------------------------------------

const LPCWSTR x_IPSITE_SUBNETS_DN = L"LDAP://CN=Subnets,CN=Sites,";

//----------------------------------------------------------------------------
// fwd static function declaration
//
STATIC HRESULT ParseSubnetString(IN LPCWSTR pwszSubnetName,
                                 OUT ULONG * pulSubnetAddress,
                                 OUT ULONG * pulSubnetMask,
                                 OUT BYTE  * pbSubnetBitCount);
STATIC void RefSubnet(IPSITE_SUBNET* pSubnet);
STATIC void DerefSubnet(IPSITE_SUBNET* pSubnet);
STATIC void DeleteSubnetSiteTree(IPSITE_SUBNET_TREE_ENTRY* pRootSubnetTree);
HRESULT WideToAnsiStr(LPCWSTR pwszUnicode, LPSTR * ppszAnsi);
STATIC HRESULT GetConfigurationDN(OUT LPWSTR * ppwszConfigDN);
//BUGBUG: move func below to utils.h & use it in conversions
STATIC HRESULT VariantGuid2Guid(IN VARIANT * pvarGuid, OUT GUID * pguid);
//BUGBUG: move func below to utils.h, maybe someone needs it
/*====================================================
DestructElements of LPCWSTR
=====================================================*/
static void AFXAPI DestructElements(LPCWSTR* ppDNs, int n)
{
    for ( ; n--; )
        delete[] (WCHAR*)*ppDNs++;
}

/*====================================================
CompareElements  of LPCWSTR
=====================================================*/
static BOOL AFXAPI  CompareElements(const LPCWSTR* pwszDN1, const LPCWSTR* pwszDN2)
{
    return (CompareStringsNoCaseUnicode(*pwszDN1, *pwszDN2) == 0);
}

/*====================================================
HashKey  of LPCWSTR
=====================================================*/
UINT AFXAPI HashKey(LPCWSTR key)
{
	UINT nHash = 0;
	while (*key)
		nHash = (nHash<<5) + nHash + *key++;
	return nHash;
}


/*====================================================
CGetSiteGuidFromDN - This class is used to convert DN Name to GUID.
    it keeps a cache of the names, and update it from ADSI
    when needed. (QFE 5462, YoelA, 16-Aug-2000)
=====================================================*/
class CGetSiteGuidFromDN
{
public:
    HRESULT GetSiteGuidFromDN(IN LPWSTR pwszDN, OUT GUID * pguid);

private:
    CMap<LPCWSTR, LPCWSTR, GUID, const GUID&> m_DNToGuidMap;

    HRESULT GetGuidFromDNInAdsi(IN LPCWSTR pwszDN, OUT GUID * pguid);
};


//----------------------------------------------------------------------------
//taken from nthack.h
//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  VOID InsertHeadList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry);
//
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//  VOID RemoveEntryList(PLIST_ENTRY Entry);
//
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//----------------------------------------------------------------------------
//helper auto classes

class CAutoEnumerator
/*++
    Auto release of IEnumVARIANT interface
--*/
{
public:
    CAutoEnumerator::CAutoEnumerator()
    {
        m_p = NULL;
    }

    CAutoEnumerator::~CAutoEnumerator()
    {
        if (m_p)
            ADsFreeEnumerator(m_p);
    }

    operator IEnumVARIANT*() const {return m_p;}
    IEnumVARIANT ** operator&()    {return &m_p;}
private:
    IEnumVARIANT * m_p;
};


class CAutoDerefSubnet
/*++
    Auto deref of subnet
--*/
{
public:
    CAutoDerefSubnet(
        CCriticalSection * pcCritSect,
        IPSITE_SUBNET* pSubnet
        )
    {
        m_pcCritSect = pcCritSect;
        m_pSubnet = pSubnet;
    }

    ~CAutoDerefSubnet()
    {
        CS lock(*m_pcCritSect);
        DerefSubnet(m_pSubnet);
    }

private:
    CCriticalSection * m_pcCritSect;
    IPSITE_SUBNET* m_pSubnet;
};


class CAutoDeleteSubnetTree
/*++
    Auto delete of subnets tree
--*/
{
public:
    CAutoDeleteSubnetTree(
        CCriticalSection * pcCritSect,
        IPSITE_SUBNET_TREE_ENTRY* pSubnetTree
        )
    {
        m_pSubnetTree = pSubnetTree;
        m_pcCritSect = pcCritSect;
    }

    ~CAutoDeleteSubnetTree()
    {
        if (m_pSubnetTree)
        {
            CS lock(*m_pcCritSect);
            DeleteSubnetSiteTree(m_pSubnetTree);
        }
    }

    IPSITE_SUBNET_TREE_ENTRY* detach()
    {
        IPSITE_SUBNET_TREE_ENTRY* pRetSubnetTree = m_pSubnetTree;
        m_pSubnetTree = NULL;
        return pRetSubnetTree;
    }

private:
    CCriticalSection * m_pcCritSect;
    IPSITE_SUBNET_TREE_ENTRY* m_pSubnetTree;
};


class CAutoWSACleanup
/*++
    Auto cleanup for previous WSAStartup()
--*/
{
public:
    CAutoWSACleanup() {}

    ~CAutoWSACleanup()
    {
        WSACleanup();
    }
};

//----------------------------------------------------------------------------
//CIpSite implementation

CIpSite::CIpSite() :
        m_RefreshTimer(RefrshSubnetTreeCache),
        m_fInitialize(FALSE)
/*++

Routine Description:
    Class consructor. Sets the tree to an empty tree

Arguments:
    None

Return Value:
    None

--*/
{
    InitializeListHead(&m_SubnetList);
    ZeroMemory(&m_SubnetTree, sizeof(IPSITE_SUBNET_TREE_ENTRY));
    m_dwMinTimeToAllowNextRefresh = 0;
}


CIpSite::~CIpSite()
/*++

Routine Description:
    Class destructor. Deletes the subnet tree
    (also debug verifies there are no subnets left around)

Arguments:
    None

Return Value:
    None

--*/
{
    DeleteSubnetSiteTree(&m_SubnetTree);

    //
    // following list should be empty
    //
    // ISSUE-2000-08-22-yoela
    //         Initialize wakes up every hour (by default - can be changed using 
    //         DSAdsRefreshIPSitesIntervalSecs in registry). If it happens to wake up
    //         during cleanup, the assert will be fired. g_pcIpSite is not protected
    //         by critical section to avoid that.
    //
    //         Bug # 5937
    //
    ASSERT(IsListEmpty(&m_SubnetList));

	ExCancelTimer(&m_RefreshTimer);
}


HRESULT CIpSite::Initialize(DWORD dwMinTimeToAllowNextRefresh,
                            BOOL  fReplicationMode)
/*++

Routine Description:
    Basic initialization. Fills the tree with information from the DS

Arguments:
    dwMinTimeToAllowNextRefresh -
        specify a period of time (in milliseconds) that has to pass since the last
        refresh in order to honor a subsequent refresh request.

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // remember minimum time to allow next refresh
    //
    m_dwMinTimeToAllowNextRefresh = dwMinTimeToAllowNextRefresh;

    //
    // update the site tree from DS
    //
    hr = Refresh();
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CIpSite::Initialize:Refresh()=%lx"), hr));
        return LogHR(hr, s_FN, 10);
    }
    m_fInitialize = TRUE;

    //
    //  schedule a refresh of the subnet-tree-cache
	//
	if ( !g_fSetupMode && !fReplicationMode)
    {
	    ExSetTimer(
			&m_RefreshTimer, 
			CTimeDuration::FromMilliSeconds(m_dwMinTimeToAllowNextRefresh)
			);
    }

    return S_OK;
}


HRESULT CIpSite::Initialize(BOOL fReplicationMode)
/*++

Routine Description:
    Basic initialization as above, but gets the interval from registry

Arguments:

Return Value:
    HRESULT

--*/
{
    //
    // Read minimum interval between successive ADS searches (seconds)
    //
    DWORD dwValue;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    DWORD dwDefault = MSMQ_DEFAULT_IPSITE_ADSSEARCH_INTERVAL ;
    LONG rc = GetFalconKeyValue( MSMQ_IPSITE_ADSSEARCH_INTERVAL_REGNAME,
                                 &dwType,
                                 &dwValue,
                                 &dwSize,
                                 (LPCTSTR) &dwDefault );
    if (rc != ERROR_SUCCESS)
    {
        ASSERT(0);
        dwValue = dwDefault;
    }

    //
    // convert to millisec and initialize
    //
    dwValue *= 1000;
    HRESULT hr2 = Initialize(dwValue, fReplicationMode) ;
    return LogHR(hr2, s_FN, 20);

}


HRESULT CIpSite::Refresh()
/*++

Routine Description:
    This routine updates the tree of subnets. It uses a temporary tree, then
    sets the real tree with the temporary one

Arguments:
    None

Return Value:
    S_OK    - refresh was done
    S_FALSE - refresh was not done because last refresh operation was done very recently
               (i.e. done at less than m_dwMinTimeToAllowNextRefresh msecs ago)
    other HRESULT errors

--*/
{
    HRESULT hr;
    IPSITE_SUBNET_TREE_ENTRY TmpSubnetTree;

    //
    // we need to refresh
    //
    //
    // Init tmp tree
    //
    ZeroMemory(&TmpSubnetTree, sizeof(IPSITE_SUBNET_TREE_ENTRY));

    //
    // Clear this tmp tree on cleanup
    //
    CAutoDeleteSubnetTree cDelTree(&m_csTree, &TmpSubnetTree);

    //
    // Fill the temporary tree
    //
    hr = FillSubnetSiteTree(&TmpSubnetTree);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CIpSite::Refresh:FillSubnetSiteTree()=%lx"), hr));
        return LogHR(hr, s_FN, 30);
    }

    //
    // Enter critical section (auto leave)
    //
    CS cs(m_csTree);

    //
    // Now we can delete the existing tree, and set the new one.
    //
    DeleteSubnetSiteTree(&m_SubnetTree);

    //
    // set the real tree from the temporary one by copying the root node
    //
    m_SubnetTree = TmpSubnetTree;


    //
    // we must not cleanup the temporary tree after we set it to the real tree
    //
    cDelTree.detach();

    return S_OK;
}


HRESULT CIpSite::FindSiteByIpAddress(IN ULONG ulIpAddress,
                                     OUT LPWSTR * ppwszSiteDN,
                                     OUT GUID * pguidSite)
/*++

Routine Description:
    This routine looks up the specified IP address and returns the site which
    contains this address.
    If requested it attempts to do a refresh and retry the lookup in case no site
    was found in the first try.

Arguments:
    ulIpAddress        - IP Address to lookup
    ppwszSiteDN        - Returned site DN
    pguidSite          - Returned site

Return Value:
    S_OK        - pguidSite,ppwszSiteDN set to the site
    S_FALSE     - no site for this address, pguidSite, ppwszSiteDN not set
    other       - HRESULT errors, pguidSite,ppwszSiteDN not set

--*/
{
    AP<WCHAR> pwszSiteDN;
    GUID guidSite;

    //
    // lookup the site for the ip address
    //
    BOOL fFound = InternalFindSiteByIpAddress(ulIpAddress, &pwszSiteDN, &guidSite);

    //
    //  Even though failed to find the site, we don't
    //  try to refresh the subnet-tree. This is
    //  because this method is called in the context of a user
    //  that called a certain DS API. If user does not have
    //  sufficient permissions it will fail to retrieve information
    //  or ( even worse) will be
    //  succeeded to retrieve partial information.
    //  Therefore refresh is performed only from a rescheduled routine,
    //  in the context of the QM.
    //

    //
    // if site was not found we return S_FALSE
    //
    if (!fFound)
    {
        LogBOOL(fFound, s_FN, 40);
        return S_FALSE;
    }

    //
    // return the site associated with the ipaddress
    //
    *ppwszSiteDN = pwszSiteDN.detach();
    *pguidSite = guidSite;
    return S_OK;
}


HRESULT CIpSite::FindSitesByComputerName(IN LPCWSTR pwszComputerName,
                                         IN LPCWSTR pwszComputerDnsName,
                                         OUT IPSITE_SiteArrayEntry ** prgSites,
                                         OUT ULONG * pcSites,
                                         OUT ULONG ** prgAddrs,
                                         OUT ULONG * pcAddrs)
/*++

Routine Description:
    This routine looks up the specified computer name and returns the site names
    it belongs to, along with the IP addresses that correspond to the sites

Arguments:
    pwszComputerName    - computer name to lookup
    pwszComputerDnsName - computer dns name to lookup ( optional)
    prgSites            - Returned sites array
    pcSites             - Returned number of sites in array
    prgAddrs            - Returned address array
    pcAddrs             - Returned number of addresses in array

Return Value:
    S_OK        - prgSites, pcSites are set
    other       - HRESULT errors. prgSites, pcSites are set

--*/
{
    HRESULT hr;

    //
    // Lookup Sock addresses for the computer
    //
    AP<char> pszAnsiComputerDnsName;
    AP<char> pszAnsiComputerName;
    if ( pwszComputerDnsName != NULL)
    {
        //
        //  Start the lookup according to the DNS name of the
        //  computer
        //

        hr = WideToAnsiStr(pwszComputerDnsName, &pszAnsiComputerDnsName);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CIpSite::FindSitesByComputerName:WideToAnsiStr(%ls)=%lx"), pwszComputerDnsName, hr));
            return LogHR(hr, s_FN, 50);
        }
    }
    else
    {
        hr = WideToAnsiStr(pwszComputerName, &pszAnsiComputerName);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CIpSite::FindSitesByComputerName:WideToAnsiStr(%ls)=%lx"), pwszComputerName, hr));
            return LogHR(hr, s_FN, 60);
        }
    }

    //
    // initialize winsock
    //
    WSADATA WSAData ;
    int iRc = WSAStartup(MAKEWORD(1,1), &WSAData);
    if (iRc != 0)
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("FindSitesByComputerName: WSAStartup()=%lx"), iRc));
        return LogHR(HRESULT_FROM_WIN32(iRc), s_FN, 70);
    }
    CAutoWSACleanup cWSACleanup; // make sure it is de-initilaized

    //
    // init returned variables
    //
    AP<IPSITE_SiteArrayEntry> rgSites;          // array of sites
    ULONG cSites = 0;                           // number of sites filled
    AP<ULONG> rgAddrs;                          // array of addresses
    ULONG cAddrs = 0;                           // number of addresses filled

    //
    // get sock addresses
    //
    PHOSTENT pHostNet = NULL;
    if ( pszAnsiComputerDnsName != NULL)
    {
        pHostNet = gethostbyname(pszAnsiComputerDnsName);
    }
    //
    //  if either
    //  1) DNS name of the computer was not supplied
    //  2) Failed to get host name according to its DNS name
    //  then try according to netbios name
    //
    if ( pHostNet == NULL)
    {
        if ( pszAnsiComputerName == NULL)
        {
            //
            //  Can only happen if first attempt to get host name
            //  failed.
            //
            hr = WideToAnsiStr(pwszComputerName, &pszAnsiComputerName);
            if (FAILED(hr))
            {
                DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CIpSite::FindSitesByComputerName:WideToAnsiStr(%ls)=%lx"), pwszComputerName, hr));
                return LogHR(hr, s_FN, 80);
            }
        }
        pHostNet = gethostbyname(pszAnsiComputerName);
    }
    if (pHostNet == NULL)
    {
        //
        // gethostbyname() returned NULL
        // we ignore specific errors, bottom line is that no addresses are found for this computer
        // we do nothing here because return values are already initialized for this case
        //
    }
    else
    {
        //
        // pHostNet != NULL, count returned addresses
        //
        for (char ** ppAddr = pHostNet->h_addr_list; *ppAddr != NULL; ppAddr++)
        {
            cAddrs++;
        };

        //
        // save addresses from hostnet now (we might later make other winsock calls)
        //
        rgAddrs = new ULONG[cAddrs];
        for (ULONG ulTmp = 0; ulTmp < cAddrs; ulTmp++)
        {
            //
            // save the u_long member of the address
            //
            rgAddrs[ulTmp] = ((in_addr *)(pHostNet->h_addr_list[ulTmp]))->S_un.S_addr;
        }

        //
        // Allocate return array
        //
        rgSites = new IPSITE_SiteArrayEntry[cAddrs];
        IPSITE_SiteArrayEntry * pSite = rgSites;    // next site to fill

        //
        // loop over all addresses and find the sites
        //
        for (ulTmp = 0; ulTmp < cAddrs; ulTmp++)
        {
            AP<WCHAR> pwszSiteDN;
            GUID guidSite;

            hr = FindSiteByIpAddress(rgAddrs[ulTmp], &pwszSiteDN, &guidSite);
            if (FAILED(hr))
            {
                DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CIpSite::FindSitesByComputerName:FindSiteByIpAddress(%lx)=%lx"), rgAddrs[ulTmp], hr));
                return LogHR(hr, s_FN, 90);
            }

            //
            // hr can also be S_FALSE if ip address not known, so ignore this case
            //
            if (hr != S_FALSE)
            {
                //
                // Fill site entry
                //
                pSite->pwszSiteDN = pwszSiteDN.detach();
                pSite->guidSite = guidSite;
                pSite->ulIpAddress  = rgAddrs[ulTmp];
                cSites++;
                pSite++;
            }
        }
    }

    //
    // return the sites associated with the computer
    //
    *prgSites   = rgSites.detach();
    *pcSites    = cSites;
    if ( prgAddrs != NULL)
    {
        *prgAddrs = rgAddrs.detach();
    }
    if ( pcAddrs != NULL)
    {
        ASSERT( prgAddrs != NULL);
        *pcAddrs = cAddrs;
    }
    return S_OK;
}


HRESULT CIpSite::FillSubnetSiteTree(IN IPSITE_SUBNET_TREE_ENTRY* pRootSubnetTree)
/*++

Routine Description:
    This routine fills a tree of subnets.

Arguments:
    pRootSubnetTree - tree to fill

Return Value:
    HRESULT

--*/
#ifndef DEBUG_NO_DS
{
    AP<WCHAR> pwszConfigDN;
    AP<WCHAR> pwszSubnetsDN;
    R<IADsContainer> pContSubnets;
    CAutoEnumerator pEnumSubnets;
    HRESULT hr;

    //
    // compute DN of subnets container
    //
    hr = GetConfigurationDN(&pwszConfigDN);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("FillSubnetSiteTree:GetConfigurationDN()=%lx"), hr));
        return LogHR(hr, s_FN, 100);
    }
    pwszSubnetsDN = new WCHAR[1+wcslen(x_IPSITE_SUBNETS_DN)+wcslen(pwszConfigDN)];
    swprintf(pwszSubnetsDN, L"%s%s", x_IPSITE_SUBNETS_DN, pwszConfigDN);

    //
    // bind to subnets container
    //
	hr = ADsOpenObject(
			pwszSubnetsDN,
			NULL,
			NULL,
			ADS_SECURE_AUTHENTICATION,
			IID_IADsContainer,
			(void**)&pContSubnets
			);
        
    LogTraceQuery(pwszSubnetsDN, s_FN, 109);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("FillSubnetSiteTree:ADsOpenObject(%ls)=%lx"), (LPWSTR)pwszSubnetsDN, hr));
        return LogHR(hr, s_FN, 110);
    }

    //
    // build enumerator for contained subnets
    //
    hr = ADsBuildEnumerator(pContSubnets.get(), &pEnumSubnets);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("FillSubnetSiteTree:ADsBuildEnumerator()=%lx"), hr));
        return LogHR(hr, s_FN, 120);
    }

    //
    // loop over the subnets
    //
    BOOL fDone = FALSE;

    //
    // Site guid from site DN translator
    //
    CGetSiteGuidFromDN guidFromDNObj;

    while (!fDone)
    {
        CAutoVariant varSubnet;
        ULONG cSubnets;

        //
        // get next subnet
        //
        hr = ADsEnumerateNext(pEnumSubnets, 1, &varSubnet, &cSubnets);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("FillSubnetSiteTree:ADsEnumerateNext()=%lx"), hr));
            return LogHR(hr, s_FN, 130);
        }

        //
        // check if we are done
        //
        if (cSubnets < 1)
        {
            fDone = TRUE;
        }
        else
        {
            R<IADs> padsSubnet;
            BS bstrName;
            CAutoVariant varSubnetName, varSiteDN;
            GUID guidSite;

            //
            // get IADs interface
            //
            hr = V_DISPATCH(&varSubnet)->QueryInterface(IID_IADs, (void**)&padsSubnet);
            if (FAILED(hr))
            {
                DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("FillSubnetSiteTree:QueryInterface(IADs)=%lx"), hr));
                return LogHR(hr, s_FN, 140);
            }

            //
            // get subnet name
            //
            bstrName = L"name";
            hr = padsSubnet->Get(bstrName, &varSubnetName);
            if (hr == E_ADS_PROPERTY_NOT_FOUND)
            {
                // no name, ignore this subnet
                continue;
            }
            else if (FAILED(hr))
            {
                DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("FillSubnetSiteTree:Get(name)=%lx"), hr));
                return LogHR(hr, s_FN, 150);
            }

            //
            // get subnet site
            //
            bstrName = L"siteObject";
            hr = padsSubnet->Get(bstrName, &varSiteDN);
            if (hr == E_ADS_PROPERTY_NOT_FOUND)
            {
                // no site object, ignore this subnet
                continue;
            }
            else if (FAILED(hr))
            {
                DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("FillSubnetSiteTree:Get(siteObject)=%lx"), hr));
                return LogHR(hr, s_FN, 160);
            }

            //
            // get site guid from site dn
            //
            hr = guidFromDNObj.GetSiteGuidFromDN(V_BSTR(&varSiteDN), &guidSite);
            if (FAILED(hr))
            {
                // bad site DN, ignore this subnet
                DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("FillSubnetSiteTree:GetSiteGuidFromDN(%ls)=%lx, skipping"), V_BSTR(&varSiteDN), hr));
                LogHR(hr, s_FN, 1641);
                continue;
            }

            //
            // add subnet,site to tree
            //
            hr = AddSubnetSiteToTree(V_BSTR(&varSubnetName), V_BSTR(&varSiteDN), &guidSite, pRootSubnetTree);
            if (FAILED(hr))
            {
                DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("FillSubnetSiteTree:AddSubnetSiteToTree(%ls,%ls)=%lx"), V_BSTR(&varSubnetName), V_BSTR(&varSiteDN), hr));
                return LogHR(hr, s_FN, 170);
            }
        }
    }

    //
    // return
    //
    return S_OK;
}
#else // ifndef DEBUG_NO_DS
{
    static LPSTR rgSubnets[] = {"157.59.184.0", "163.59.0.0", "163.59.224.0"};
    static ULONG rgbits[] = {22, 16, 20};
    static LPWSTR rgSiteDNs[]    = {L"SITE_157.59.184.0", L"SITE_163.59.0.0", L"SITE_163.59.224.0"};
    static GUID rgSiteGUIDs[]  = {(GUID)0, (GUID)1, (GUID)2};

    for (ULONG ulTmp = 0; ulTmp < 3; ulTmp++)
    {
        LPSTR pszTmp = rgSubnets[ulTmp];
        AP<WCHAR> pwszSubnet;
        pwszSubnet = new WCHAR[1+strlen(pszTmp)+30];
        int iTmp = MultiByteToWideChar(CP_ACP, 0, pszTmp, -1, pwszSubnet, 1+strlen(pszTmp));

        swprintf((LPWSTR)pwszSubnet + wcslen(pwszSubnet), L"/%ld", rgbits[ulTmp]);
        HRESULT hr = AddSubnetSiteToTree(pwszSubnet, rgSiteDNs[ulTmp], &rgSiteGUIDs[ulTmp], pRootSubnetTree);
    }

    //
    // return
    //
    return S_OK;
}
#endif // ifndef DEBUG_NO_DS


HRESULT CIpSite::AddSubnetSiteToTree(IN LPCWSTR pwszSubnetName,
                                     IN LPCWSTR pwszSiteDN,
                                     IN const GUID * pguidSite,
                                     IPSITE_SUBNET_TREE_ENTRY* pRootSubnetTree)
/*++

Routine Description:
    This routine adds a subnet to a tree of subnets. Assumes it is a temporary
    tree, therefore doesn't lock the critical section for the tree, only locks
    the subnets list.

Arguments:
    pwszSubnetName  - subnet to be added
    pwszSiteDN      - DN of the site the subnet is in.
    pguidSite       - GUID of the site the subnet is in.
    pRootSubnetTree - tree to add to

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // Parse the subnet name
    //
    ULONG ulSubnetAddress, ulSubnetMask;
    BYTE bSubnetBitCount;
    hr = ParseSubnetString(pwszSubnetName, &ulSubnetAddress, &ulSubnetMask, &bSubnetBitCount);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("AddSubnetSiteToTree:ParseSubnetString(%ls)=%lx"), pwszSubnetName, hr));
        return LogHR(hr, s_FN, 180);
    }

    //
    // Find or allocate an entry for the subnet
    //
    IPSITE_SUBNET* pSubnet;
    FindSubnetEntry(pwszSiteDN, pguidSite, ulSubnetAddress, ulSubnetMask, bSubnetBitCount, &pSubnet);

    //
    // always deref it when done
    //
    CAutoDerefSubnet cDerefSubnet(&m_csTree, pSubnet);

    //
    // Loop for each byte in the subnet address
    //
    IPSITE_SUBNET_TREE_ENTRY* pSubnetTreeEntry = pRootSubnetTree;
    LPBYTE pbSubnetBytePointer = (LPBYTE) (&pSubnet->SubnetAddress);
    while (bSubnetBitCount != 0)
    {
        //
        // If there isn't a tree branch for the current node, create one.
        //
        if (pSubnetTreeEntry->Subtree == NULL)
        {
            pSubnetTreeEntry->Subtree = new IPSITE_SUBNET_TREE;
            ZeroMemory(pSubnetTreeEntry->Subtree, sizeof(IPSITE_SUBNET_TREE));
        }

        //
        // If this is the last byte of the subnet address,
        //  link the subnet onto the tree here.
        //
        if (bSubnetBitCount <= 8)
        {
            //
            // The caller indexes into this array with an IP address.
            // Create a link to our subnet for each possible IP addresses
            // that map onto this subnet.
            //
            // Between 1 and 128 IP addresses map onto this subnet address.
            //
            ULONG ulLoopCount = 1 << (8-bSubnetBitCount);

            for (ULONG iTmp=0; iTmp<ulLoopCount; iTmp++)
            {
                IPSITE_SUBNET_TREE_ENTRY* pSubtree;
                ULONG ulSubnetIndex;

                //
                // Compute which entry is to be updated.
                //
                ulSubnetIndex = (*pbSubnetBytePointer) + iTmp;
                ASSERT(ulSubnetIndex <= 255);
                pSubtree = &pSubnetTreeEntry->Subtree->Subtree[ulSubnetIndex];

                //
                // If there already is a subnet linked off the tree here,
                //  handle it.
                //
                if (pSubtree->Subnet != NULL)
                {
                    //
                    //  If the entry is for a less specific subnet
                    //  delete the current entry.
                    //
                    if (pSubtree->Subnet->SubnetBitCount < pSubnet->SubnetBitCount)
                    {
                        CS lock(m_csTree);
                        DerefSubnet(pSubtree->Subnet);
                        pSubtree->Subnet = NULL;
                    }
                    else
                    {
                        //
                        // Otherwise,
                        //  use the current entry since it is better than this one.
                        //
                        continue;
                    }
                }

                //
                // Link the subnet into the tree.
                // Increment the reference count.
                //
                {
                    CS lock(m_csTree);
                    RefSubnet(pSubnet);
                    pSubtree->Subnet = pSubnet;
                }
            }

            //
            // we are done going over the meaningful bytes of the subnet address
            //
            break;
        }

        //
        // Move on to the next meaningful byte of the subnet address
        //
        pSubnetTreeEntry = &pSubnetTreeEntry->Subtree->Subtree[*pbSubnetBytePointer];
        bSubnetBitCount -= 8;
        pbSubnetBytePointer++;
    }

    return S_OK;
}


void CIpSite::FindSubnetEntry(IN LPCWSTR pwszSiteDN,
                              IN const GUID * pguidSite,
                              IN ULONG ulSubnetAddress,
                              IN ULONG ulSubnetMask,
                              IN BYTE bSubnetBitCount,
                              OUT IPSITE_SUBNET** ppSubnet)
/*++

Routine Description:
    This routine finds a subnet entry for a particular subnet name.  If one
    does not exist, one is created.

Arguments:
    pwszSiteDN       - DN of the site the subnet covers.
    pguidSite        - GUID of the site the subnet covers.
    ulSubnetAddress  - Subnet Address for the subnet to find.
    ulSubnetMask     - Subnet mask for the subnet to find.
    ulSubnetBitCount - Subnet bit count for the subnet to find.
    ppSubnet       - Returned subnet entry, entry should be dereferenced when done.

Return Value:
    void

--*/
{
    PLIST_ENTRY pListEntry;
    P<IPSITE_SUBNET> pNewSubnet;

    //
    // Enter critical section (auto leave)
    //
    CS cs(m_csTree);

    //
    // If the subnet entry already exists, return a pointer to it.
    //
    for (pListEntry = m_SubnetList.Flink; pListEntry != &m_SubnetList; pListEntry = pListEntry->Flink)
    {
        IPSITE_SUBNET* pSubnet = CONTAINING_RECORD(pListEntry, IPSITE_SUBNET, Next);

        if ((pSubnet->SubnetAddress == ulSubnetAddress) &&
            (pSubnet->SubnetBitCount == bSubnetBitCount) &&
            (pSubnet->SubnetMask == ulSubnetMask) &&
            (pSubnet->SiteGuid == *pguidSite))
        {
            RefSubnet(pSubnet);    // reference it for caller
            *ppSubnet = pSubnet;
            return;
        }
    }

    //
    // If not, allocate one.
    //
    pNewSubnet = new IPSITE_SUBNET;

    //
    // Fill it in.
    //
    pNewSubnet->ReferenceCount    = 1;    // reference it for caller
    pNewSubnet->SubnetAddress     = ulSubnetAddress;
    pNewSubnet->SubnetMask        = ulSubnetMask;
    pNewSubnet->SubnetBitCount    = bSubnetBitCount;
    pNewSubnet->SiteDN            = new WCHAR[1+wcslen(pwszSiteDN)];
    wcscpy(pNewSubnet->SiteDN, pwszSiteDN);
    pNewSubnet->SiteGuid          = *pguidSite;
    InsertHeadList(&m_SubnetList, &pNewSubnet->Next);

    //
    // return new subnet entry
    //
    *ppSubnet = pNewSubnet.detach();
    return;
}


BOOL CIpSite::InternalFindSiteByIpAddress(IN ULONG ulIpAddress,
                                          OUT LPWSTR * ppwszSiteDN,
                                          OUT GUID * pguidSite)
/*++

Routine Description:
    This routine looks up the specified IP address and returns the site which
    contains this address

Arguments:
    ulIpAddress     - IP Address to lookup
    ppwszSiteDN     - Returned site DN
    pguidSite       - Returned site

Return Value:
    TRUE        - pguidSite,ppwszSiteDN set to the site
    FALSE       - no site for this address, pguidSite, ppwszSiteDN not set

--*/
{
    //
    // Enter critical section (auto leave)
    //
    CS cs(m_csTree);

    IPSITE_SUBNET* pSubnet = NULL;
    IPSITE_SUBNET_TREE_ENTRY* pSubnetTreeEntry = &m_SubnetTree;
    //
    // Loop for each byte in the Ip address
    //
    for (ULONG ulByteIndex=0; ulByteIndex<sizeof(ulIpAddress); ulByteIndex++)
    {
        //
        // If there is no subtree, we're done.
        //
        ULONG ulSubnetIndex = ((LPBYTE)(&ulIpAddress))[ulByteIndex];
        if (pSubnetTreeEntry->Subtree == NULL)
        {
            break;
        }

        //
        // Compute which entry is being referenced
        //
        pSubnetTreeEntry = &pSubnetTreeEntry->Subtree->Subtree[ulSubnetIndex];

        //
        // If there already is a subnet linked off here, use it.
        // (but continue walking down the tree trying to find a more explicit entry.)
        //
        if (pSubnetTreeEntry->Subnet != NULL)
        {
            pSubnet = pSubnetTreeEntry->Subnet;
        }
    }

    //
    // If we didn't find a subnet, return S_FALSE
    //
    if (pSubnet == NULL)
    {
        LogBOOL(FALSE, s_FN, 190);
        return FALSE;
    }

    //
    // return the site associated with the subnet
    //
    AP<WCHAR> pwszSiteDN = new WCHAR[1+wcslen(pSubnet->SiteDN)];
    wcscpy(pwszSiteDN, pSubnet->SiteDN);
    *ppwszSiteDN = pwszSiteDN.detach();
    *pguidSite = pSubnet->SiteGuid;
    return TRUE;
}

void WINAPI CIpSite::RefrshSubnetTreeCache(
                IN CTimer* pTimer
                   )
{
    CIpSite * pIpSite = CONTAINING_RECORD(pTimer, CIpSite, m_RefreshTimer);
    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>

     //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 1609);
    //
    //  ignore failure -> reschedule
    //

    pIpSite->Refresh();

    //
    //  reschedule
	//
    ASSERT(!g_fSetupMode);

	ExSetTimer(
		&pIpSite->m_RefreshTimer, 
		CTimeDuration::FromMilliSeconds(pIpSite->m_dwMinTimeToAllowNextRefresh)
		);
    
}





//-----------------------------
//static functions
#if 0
STATIC HRESULT GetSiteNameFromSiteDN(IN LPCWSTR pwszSiteDN,
                                     OUT LPWSTR * ppwszSiteName);
/*++

Routine Description:
    returns site name from site DN

Arguments:
    pwszSiteDN      - Site DN
    ppwszSiteName   - Returned site name

Return Value:
    HRESULT

--*/
{
    //
    // copy so we can change it
    //
    AP<WCHAR> pwszSite = new WCHAR[1+wcslen(pwszSiteDN)];
    wcscpy(pwszSite, pwszSiteDN);

    //
    // find the = in the first CN=
    //
    LPWSTR pwszStartSiteName = wcschr(pwszSite, L'=');
    if (!pwszStartSiteName)
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetSiteNameFromSiteDN:no = sign in %ls"), (LPWSTR)pwszSite));
        return LogHR(E_FAIL, s_FN, 200);
    }
    pwszStartSiteName++;

    //
    // Replace the comma in CN=xxx, with NULL terminator
    //
    LPWSTR pwszEndSiteName = wcschr(pwszStartSiteName, L',');
    if (pwszEndSiteName)
    {
        *pwszEndSiteName = '\0';
    }

    //
    // create a copy of the name
    //
    AP<WCHAR> pwszName = new WCHAR[1+wcslen(pwszStartSiteName)];
    wcscpy(pwszName, pwszStartSiteName);

    //
    // return the name
    //
    *ppwszSiteName = pwszName.detach();
    return S_OK;
}
#endif

STATIC HRESULT ParseSubnetString(IN LPCWSTR pwszSubnetName,
                                 OUT ULONG * pulSubnetAddress,
                                 OUT ULONG * pulSubnetMask,
                                 OUT BYTE  * pbSubnetBitCount)
/*++

Routine Description:
    Convert the subnet name to address and bit count.

Arguments:
    pwszSubnetName      - Subnet string
    pulSubnetAddress    - Returns the subnet number in Network byte order.
    pulSubnetMask       - Returns the subnet mask in network byte order
    pulSubnetBitCount   - Returns the number of leftmost significant bits in the
                           SubnetAddress

Return Value:
    HRESULT

--*/
{
    static ULONG BitMask[] =
        {0x00000000, 0x00000080, 0x000000C0, 0x000000E0, 0x000000F0, 0x000000F8, 0x000000FC, 0x000000FE,
         0x000000FF, 0x000080FF, 0x0000C0FF, 0x0000E0FF, 0x0000F0FF, 0x0000F8FF, 0x0000FCFF, 0x0000FEFF,
         0x0000FFFF, 0x0080FFFF, 0x00C0FFFF, 0x00E0FFFF, 0x00F0FFFF, 0x00F8FFFF, 0x00FCFFFF, 0x00FEFFFF,
         0x00FFFFFF, 0x80FFFFFF, 0xC0FFFFFF, 0xE0FFFFFF, 0xF0FFFFFF, 0xF8FFFFFF, 0xFCFFFFFF, 0xFEFFFFFF,
         0xFFFFFFFF };

    //
    // Copy the string to where we can munge it.
    //
    AP<WCHAR> pwszLocalSubnetName = new WCHAR[1+wcslen(pwszSubnetName)];
    wcscpy(pwszLocalSubnetName, pwszSubnetName);

    //
    // Find the subnet bit count.
    //
    LPWSTR pwszSlashPointer = wcschr(pwszLocalSubnetName, L'/');
    if (!pwszSlashPointer)
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("ParseSubnetString: %ls: bit count missing"), pwszSubnetName));
        return LogHR(MQ_ERROR, s_FN, 210);
    }

    //
    // Zero terminate the address portion of the subnet name.
    //
    *pwszSlashPointer = L'\0';

    //
    // Get the BitCount portion.
    //
    LPWSTR pwszEnd;
    ULONG ulLocalBitCount = wcstoul(pwszSlashPointer+1, &pwszEnd, 10);

    if ((ulLocalBitCount == 0) || (ulLocalBitCount > 32))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("ParseSubnetString: %ls: bit count %ld is bad"), pwszSubnetName, ulLocalBitCount));
        return LogHR(MQ_ERROR, s_FN, 220);
    }

    if (*pwszEnd != L'\0')
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("ParseSubnetString: %ls: bit count not at the end"), pwszSubnetName));
        return LogHR(MQ_ERROR, s_FN, 230);
    }

    BYTE bSubnetBitCount = (BYTE)ulLocalBitCount;

    //
    // Convert the address portion to binary.
    //
#if 0
    SOCKADDR_IN SockAddrIn;
    INT iSockAddrSize = sizeof(SockAddrIn);

    INT iWsaStatus = WSAStringToAddressW(pwszLocalSubnetName,
                                         AF_INET,
                                         NULL,
                                         (PSOCKADDR)&SockAddrIn,
                                         &iSockAddrSize);
    if (iWsaStatus != 0)
    {
        iWsaStatus = WSAGetLastError();
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("ParseSubnetString: %ls: WSAStringToAddressW()=%lx"), (LPWSTR)pwszLocalSubnetName, (long)iWsaStatus));
        LogNTStatus(iWsaStatus, s_FN, 240);
        return MQ_ERROR;
    }

    if (SockAddrIn.sin_family != AF_INET)
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("ParseSubnetString: %ls: not AF_INET"), (LPWSTR)pwszLocalSubnetName));
        return LogHR(MQ_ERROR, s_FN, 250);
    }

    ULONG ulSubnetAddress = SockAddrIn.sin_addr.S_un.S_addr;
#else
    AP<char> pszAnsiSubnetName;
    HRESULT hr = WideToAnsiStr(pwszLocalSubnetName, &pszAnsiSubnetName);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("ParseSubnetString:WideToAnsiStr(%ls)=%lx"), (LPWSTR)pwszLocalSubnetName, hr));
        return LogHR(hr, s_FN, 260);
    }

    ULONG ulSubnetAddress = inet_addr(pszAnsiSubnetName);
    if (ulSubnetAddress == INADDR_NONE)
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("ParseSubnetString: %ls: not a valid subnet address"), (LPWSTR)pwszLocalSubnetName));
        return LogHR(MQ_ERROR, s_FN, 270);
    }
#endif //0
    ULONG ulSubnetMask = BitMask[bSubnetBitCount];

    //
    // Ensure there are no bits set that aren't included in the subnet mask.
    //
    if (ulSubnetAddress & (~ulSubnetMask))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("ParseSubnetString: %ls: bits not in subnet mask %8.8lX %8.8lX"), pwszSubnetName, ulSubnetAddress, ulSubnetMask));
        return LogHR(MQ_ERROR, s_FN, 280);
    }

    //
    // return values
    //
    *pbSubnetBitCount = bSubnetBitCount;
    *pulSubnetAddress = ulSubnetAddress;
    *pulSubnetMask    = ulSubnetMask;
    return S_OK;
}


STATIC void RefSubnet(IPSITE_SUBNET* pSubnet)
/*++

Routine Description:
    Reference a subnet

Arguments:
    pSubnet  - Entry to be Referenced.

Return Value:
    None.

--*/
{
    pSubnet->ReferenceCount++;
}


STATIC void DerefSubnet(IPSITE_SUBNET* pSubnet)
/*++

Routine Description:
    Dereference a subnet entry.
    If the reference count goes to zero, the subnet entry will be deleted.

Arguments:
    pSubnet  - Entry to be dereferenced.

Return Value:
    None.

--*/
{
    if ((--(pSubnet->ReferenceCount)) == 0)
    {
        //
        // Remove the subnet from the global list
        //
        RemoveEntryList(&pSubnet->Next);

        //
        // destruct the Subnet entry itself.
        //
        delete pSubnet;
    }
}


STATIC void DeleteSubnetSiteTree(IN IPSITE_SUBNET_TREE_ENTRY* pRootSubnetTree)
/*++

Routine Description:
    This routine deletes a tree of subnets recursively.
    Assumes critical section is locked.

Arguments:
    pRootSubnetTree - tree to delete, cannot be NULL.

Return Value:
    void

--*/
{
    //
    // pRootSubnetTree cannot be NULL
    //
    ASSERT(pRootSubnetTree);

    //
    // If there are children, delete them.
    //
    if (pRootSubnetTree->Subtree != NULL)
    {
        //
        // recurse into children
        // passed parameter is not NULL because it is an address
        //
        for (ULONG i=0; i<256; i++)
        {
            DeleteSubnetSiteTree(&pRootSubnetTree->Subtree->Subtree[i]);
        }

        delete pRootSubnetTree->Subtree;
        pRootSubnetTree->Subtree = NULL;
    }

    //
    // If there is a subnet, dereference it.
    //
    if (pRootSubnetTree->Subnet != NULL)
    {
        DerefSubnet(pRootSubnetTree->Subnet);
        pRootSubnetTree->Subnet = NULL;
    }
}


HRESULT WideToAnsiStr(LPCWSTR pwszUnicode, LPSTR * ppszAnsi)
/*++

Routine Description:
    Converts from wide char to ansi

Arguments:
    pwszUnicode - wide char string
    ppszAnsi    - returned ansi string

Return Value:
    HRESULT

--*/
{
    AP<char> pszAnsi;

    //
    // Get size of buffer
    //
    int iSize = WideCharToMultiByte(CP_ACP, 0, pwszUnicode, -1, NULL, 0, NULL, NULL);
    pszAnsi = new char[iSize + 1];

    //
    // Perform conversion
    //
    int iRes = WideCharToMultiByte(CP_ACP, 0, pwszUnicode, -1, pszAnsi, iSize, NULL, NULL);
    if (iRes == 0)
    {
        HRESULT hr = GetLastError();
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("WideToAnsiStr: WideCharToMultiByte(%ls)=%lx"), pwszUnicode, hr));
        return LogHR(hr, s_FN, 290);
    }
    pszAnsi[iSize] = '\0';

    //
    // return results
    //
    *ppszAnsi = pszAnsi.detach();
    return S_OK;
}


STATIC HRESULT GetConfigurationDN(OUT LPWSTR * ppwszConfigDN)
/*++

Routine Description:
      Finds the DN of the configuration container of the active directory

Arguments:
      ppwszConfigDN - where the configuration DN is put

Return Value:
    HRESULT

--*/
{
    HRESULT hr;
    R<IADs> pADs;
    BS      bstrTmp;
    CAutoVariant    varTmp;
    AP<WCHAR>       pwszConfigDN;

    //
    // Bind to the RootDSE to obtain information
    //
	//	( specify local server, to avoid access of remote server during setup)
    //
	ASSERT( g_pwcsServerName != NULL); 
    AP<WCHAR> pwcsRootDSE = new WCHAR [  x_providerPrefixLength + g_dwServerNameLength + x_RootDSELength + 2];
        swprintf(
            pwcsRootDSE,
             L"%s%s"
             L"/%s",
            x_LdapProvider,
            g_pwcsServerName,
			x_RootDSE
            );

	hr = ADsOpenObject( 
			pwcsRootDSE,
			NULL,
			NULL,
			ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND,
			IID_IADs,
			(void**)&pADs
			);

    LogTraceQuery(pwcsRootDSE, s_FN, 299);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetConfigDN:ADsOpenObject(LDAP://RootDSE)=%lx"), hr));
        return LogHR(hr, s_FN, 300);
    }

    //
    // Setting value to BSTR
    //
    bstrTmp = TEXT("configurationNamingContext");
    //
    // Reading the property
    //
    hr = pADs->Get(bstrTmp, &varTmp);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetConfigDN:Get(configurationNamingContext)=%lx"), hr));
        return LogHR(hr, s_FN, 310);
    }
    ASSERT(((VARIANT &)varTmp).vt == VT_BSTR);

    //
    // copy DN
    //
    pwszConfigDN  = new WCHAR[1+wcslen(V_BSTR(&varTmp))];
    wcscpy(pwszConfigDN, V_BSTR(&varTmp));

    //
    // Return configuration DN
    //
    *ppwszConfigDN  = pwszConfigDN.detach();
    return S_OK;
}


STATIC HRESULT VariantGuid2Guid(IN VARIANT * pvarGuid, OUT GUID * pguid)
/*++

Routine Description:
      converts from VARIANT guid (i.e. safe array of bytes) to real guid

Arguments:
    pvarGuid - variant to convert
    pguid    - where to store the result guid

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // check the variant
    //
    if ((pvarGuid->vt != (VT_ARRAY | VT_UI1)) ||
        (!pvarGuid->parray))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 320);
    }
    else if (SafeArrayGetDim(pvarGuid->parray) != 1)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 330);
    }
    LONG lLbound, lUbound;
    if (FAILED(SafeArrayGetLBound(pvarGuid->parray, 1, &lLbound)) ||
        FAILED(SafeArrayGetUBound(pvarGuid->parray, 1, &lUbound)))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 340);
    }
    if (lUbound - lLbound + 1 != sizeof(GUID))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 350);
    }

    //
    // Get the guid value
    //
    GUID guid;
    LPBYTE pTmp = (LPBYTE)&guid;
    for (LONG lTmp = lLbound; lTmp <= lUbound; lTmp++)
    {
        hr = SafeArrayGetElement(pvarGuid->parray, &lTmp, pTmp);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("VariantGuid2Guid:SafeArrayGetElement(%ld)=%lx"), lTmp, hr));
            return LogHR(hr, s_FN, 360);
        }
        pTmp++;
    }

    //
    // return values
    //
    *pguid = guid;
    return MQ_OK;
}


HRESULT CGetSiteGuidFromDN::GetGuidFromDNInAdsi(IN LPCWSTR pwszDN, OUT GUID * pguid)
/*++

Routine Description:
      gets the object's GUID given the object's DN. Does it by binding to it in ADSI.

Arguments:
    pwszDN   - Object's DN
    pguid    - where to store the result guid

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // Create ADSI path
    //
    AP<WCHAR> pwszPath = new WCHAR[1+wcslen(L"LDAP://")+wcslen(pwszDN)];
    wcscpy(pwszPath, L"LDAP://");
    wcscat(pwszPath, pwszDN);

    //
    // bind to the obj
    //
    R<IADs> pIADs;

	hr = ADsOpenObject(
			pwszPath,
			NULL,
			NULL,
			ADS_SECURE_AUTHENTICATION,
			IID_IADs,
			(void**)&pIADs
			);

    LogTraceQuery(pwszPath, s_FN, 369);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetGuidFromDNInAdsi:ADsOpenObject(%ls)=%lx"), (LPWSTR)pwszPath, hr));
        return LogHR(hr, s_FN, 370);
    }

    //
    // Get GUID
    //
    CAutoVariant varGuid;
    BS bsName = x_AttrObjectGUID;
    hr = pIADs->Get(bsName, &varGuid);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetGuidFromDNInAdsi:pIADs->Get(guid)=%lx"), hr));
        return LogHR(hr, s_FN, 380);
    }

    //
    // copy GUID
    //
    GUID guid;
    hr = VariantGuid2Guid(&varGuid, &guid);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetGuidFromDNInAdsi:VariantGuid2Guid()=%lx"), hr));
        return LogHR(hr, s_FN, 390);
    }

    //
    // return values
    //
    *pguid = guid;
    return MQ_OK;
}

HRESULT CGetSiteGuidFromDN::GetSiteGuidFromDN(IN LPWSTR pwszDN, OUT GUID * pguid)
/*++

Routine Description:
      gets the object's GUID given the object's DN. Keeps a cache and looks at the cache or at ADSI.

Arguments:
    pwszDN   - Object's DN
    pguid    - where to store the result guid

Return Value:
    HRESULT

--*/
{   
    //
    // Only the site name itself will be used as key. The site name begins
    // at the forth character (after "CN=") and ends before the first occurence 
    // of ",". To avoid unnacessary copies, we use the original string and replace the first ","
    // by NULL to get a short string.
    //
    //
    // find the = in the first CN=
    //
    LPWSTR pwstrSiteName = wcschr(pwszDN, L'=');
    if (0 == pwstrSiteName)
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetSiteGuidFromDN:no = sign in %ls"), pwszDN));
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 400);
    }
    pwstrSiteName++;

    LPWSTR pwstrFirstComma = wcschr(pwstrSiteName, L',');
    if (0 == pwstrFirstComma)
    {
        //
        // Legal name should contain a comma
        //
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetSiteGuidFromDN:no , sign in %ls"), pwszDN));
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 410);
    }
    ASSERT(*pwstrFirstComma == L',');

    //
    // Replace the comma with a NULL, so pwstrSiteName will point to the site name only
    // Then, we can perform the lookup. After the lookpup, put the comma back in, so 
    // pwszDN will contain a valid value again.
    //
    *pwstrFirstComma = 0;
    BOOL fFound = m_DNToGuidMap.Lookup(pwstrSiteName, *pguid);
    *pwstrFirstComma = L',';

    if (fFound)
    {
        return MQ_OK;
    }

    HRESULT hr = GetGuidFromDNInAdsi(pwszDN, pguid);
    if (SUCCEEDED(hr))
    {
        //
        // Copy the name up to the first comma and use it as a key.
        //
        DWORD dwSiteNameLen = numeric_cast<DWORD>(pwstrFirstComma - pwstrSiteName);
        AP<WCHAR> wszDNKey = new WCHAR[dwSiteNameLen + 1];
        wcsncpy(wszDNKey, pwstrSiteName, dwSiteNameLen);
        wszDNKey[dwSiteNameLen] = 0;

        m_DNToGuidMap[wszDNKey.detach()] = *pguid;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\hquery.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
	hquery.h

Abstract:
	query handle classes, for locate nect of different queries

Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __HQUERY_H__
#define __HQUERY_H__

#include "dsads.h"
#include "usercert.h"
#include "adstempl.h"
#include "siteinfo.h"
//-----------------------------------------------------------------------------------
//
//      CBasicQueryHandle
//
//  Virtual class, all query-handle classes are derived from this class.
//
//-----------------------------------------------------------------------------------
class CBasicQueryHandle
{
public:
    CBasicQueryHandle( enumRequesterProtocol eRequesterProtocol);

	~CBasicQueryHandle();
	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer) = 0;
    virtual HRESULT LookupEnd() = 0;
    enumRequesterProtocol GetRequesterProtocol() const;
private:
    enumRequesterProtocol m_eRequesterProtocol;
};
inline     CBasicQueryHandle::CBasicQueryHandle( enumRequesterProtocol eRequesterProtocol)
                :m_eRequesterProtocol(eRequesterProtocol)
{};
inline CBasicQueryHandle::~CBasicQueryHandle()
{};
inline enumRequesterProtocol CBasicQueryHandle::GetRequesterProtocol() const
{
    return( m_eRequesterProtocol);
}


//-----------------------------------------------------------------------------------
//
//      CQueryHandle
//
//  This class is suitable for all queries, where locate next is referred 
//  directly to the DS (i.e. no additional translation or checking is required).
//
//-----------------------------------------------------------------------------------
class CQueryHandle : public CBasicQueryHandle
{
public:
    //
    //  CQueryHandle
    //
    //  hCursor             - a cursor returned from Locate Begin operation performed on the DS
    //  dwNoPropsInResult   - number of peroperties to be retrieve in each result
    CQueryHandle( 
               IN  HANDLE               hCursor,
               IN  DWORD                dwNoPropsInResult,
               IN  enumRequesterProtocol eRequesterProtocol
               );

	~CQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    DWORD               m_dwNoPropsInResult;
    CDsQueryHandle      m_hCursor;

};

inline CQueryHandle::CQueryHandle( 
               IN  HANDLE               hCursor,
               IN  DWORD                dwNoPropsInResult,
               IN  enumRequesterProtocol eRequesterProtocol
               ):  CBasicQueryHandle(eRequesterProtocol), m_dwNoPropsInResult( dwNoPropsInResult)
{
    m_hCursor.SetHandle( hCursor);
}

inline CQueryHandle::~CQueryHandle()
{
};

inline HRESULT CQueryHandle::LookupEnd()
{
    delete this;
    return(MQ_OK);
}
//-----------------------------------------------------------------------------------
//
//      CUserCertQueryHandle
//
//  This class simulates query functionality on array of user-signed-certificates.
//-----------------------------------------------------------------------------------
class CUserCertQueryHandle : public CBasicQueryHandle
{
public:
    //
    //  CUserCertQueryHandle
    //
    //  pblob - a blob containing user-signed-certificates.
    CUserCertQueryHandle(
                IN const BLOB * pblobNT5User,
                IN const BLOB * pblobNT4User,
                IN enumRequesterProtocol eRequesterProtocol
               );

	~CUserCertQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    DWORD               m_dwNoCertRead;
    BLOB                m_blobNT5UserCert;
    BLOB                m_blobNT4UserCert;

};

inline  CUserCertQueryHandle::CUserCertQueryHandle(
                IN const BLOB * pblobNT5User,
                IN const BLOB * pblobNT4User,
                IN enumRequesterProtocol eRequesterProtocol
                ): CBasicQueryHandle(eRequesterProtocol), 
                   m_dwNoCertRead(0)
{
    m_blobNT5UserCert.cbSize = pblobNT5User->cbSize;
    if ( m_blobNT5UserCert.cbSize != 0)
    {
        m_blobNT5UserCert.pBlobData = new BYTE[ m_blobNT5UserCert.cbSize];
        memcpy( m_blobNT5UserCert.pBlobData, pblobNT5User->pBlobData, m_blobNT5UserCert.cbSize);
    }
    else
    {
        m_blobNT5UserCert.pBlobData = NULL;
    }
    m_blobNT4UserCert.cbSize = pblobNT4User->cbSize;
    if ( m_blobNT4UserCert.cbSize != 0)
    {
        m_blobNT4UserCert.pBlobData = new BYTE[ m_blobNT4UserCert.cbSize];
        memcpy( m_blobNT4UserCert.pBlobData, pblobNT4User->pBlobData, m_blobNT4UserCert.cbSize);
    }
    else
    {
        m_blobNT4UserCert.pBlobData = NULL;
    }
}

inline CUserCertQueryHandle::~CUserCertQueryHandle()
{
    delete []m_blobNT5UserCert.pBlobData;
    delete []m_blobNT4UserCert.pBlobData;

}
inline HRESULT CUserCertQueryHandle::LookupEnd()
{
    delete this;
    return(MQ_OK);
}

//-----------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------
class CRoutingServerQueryHandle : public CBasicQueryHandle
{
public:
    CRoutingServerQueryHandle(
                 IN  const MQCOLUMNSET    *pColumns,
                 IN  HANDLE hCursor,
                 IN  enumRequesterProtocol eRequesterProtocol
               );

	~CRoutingServerQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    ULONG               m_cCol;
    PROPID *            m_aCol;
    CDsQueryHandle      m_hCursor;
};


inline CRoutingServerQueryHandle::CRoutingServerQueryHandle(
                 IN  const MQCOLUMNSET    *pColumns,
                 IN  HANDLE hCursor,
                 IN  enumRequesterProtocol eRequesterProtocol
                 ):  CBasicQueryHandle(eRequesterProtocol)

{
        m_aCol = new PROPID[ pColumns->cCol];
        memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
        m_cCol = pColumns->cCol;
        m_hCursor.SetHandle( hCursor);
}

inline 	CRoutingServerQueryHandle::~CRoutingServerQueryHandle()
{
    delete []m_aCol;
}

inline DWORD  CRoutingServerQueryHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CRoutingServerQueryHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}



//-----------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------

class CSiteQueryHandle : public CBasicQueryHandle
{
public:
    CSiteQueryHandle(
                 IN  HANDLE hCursor,
                 IN  const MQCOLUMNSET    *pColumns,
                 IN  enumRequesterProtocol eRequesterProtocol
               );

	~CSiteQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:

    HRESULT FillInOneResponse(
                IN   const GUID *          pguidSiteId,
                IN   LPCWSTR               pwcsSiteName,
                OUT  PROPVARIANT *         pbBuffer);


    CDsQueryHandle      m_hCursor;
    ULONG               m_cCol;
    PROPID *            m_aCol;
    BOOL                m_fSiteGatesRequired;
};


inline CSiteQueryHandle::CSiteQueryHandle(
                 IN  HANDLE hCursor,
                 IN  const MQCOLUMNSET    *pColumns,
                 IN  enumRequesterProtocol eRequesterProtocol
                 ):  CBasicQueryHandle(eRequesterProtocol)

{
    m_aCol = new PROPID[ pColumns->cCol];
    memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
    m_cCol = pColumns->cCol;

    m_fSiteGatesRequired = FALSE;
    for (DWORD i = 0; i < m_cCol; i++)
    {
        if ( m_aCol[i] == PROPID_S_GATES)
        {
            m_fSiteGatesRequired = TRUE;
            break;
        }
    }
    m_hCursor.SetHandle( hCursor);
}

inline 	CSiteQueryHandle::~CSiteQueryHandle()
{
    delete [] m_aCol;
}

inline DWORD  CSiteQueryHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CSiteQueryHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}

//-------------------------------------------------------------------------
//
//        CConnectorQueryHandle
//
//
//  This query handle is used when locating a foreign
//  machine connectors.
//
//-------------------------------------------------------------------------


class CConnectorQueryHandle : public CBasicQueryHandle
{
public:
    CConnectorQueryHandle(
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  CSiteGateList *        pSiteGateList,
                 IN  enumRequesterProtocol  eRequesterProtocol
               );

	~CConnectorQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    ULONG               m_cCol; // number of columns the user asked
    PROPID *            m_aCol; // propids of the columns the user asked
    CDsQueryHandle      m_hCursor;  // DS query handle
    DWORD               m_dwNumGatesReturned;   // index of the last gates returned
    CSiteGateList *     m_pSiteGateList;
};


inline CConnectorQueryHandle::CConnectorQueryHandle(
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  CSiteGateList *        pSiteGateList,
                 IN  enumRequesterProtocol eRequesterProtocol
             ):  CBasicQueryHandle(eRequesterProtocol),
                 m_pSiteGateList( pSiteGateList),
                 m_dwNumGatesReturned(0)

{
        m_aCol = new PROPID[ pColumns->cCol];
        memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
        m_cCol = pColumns->cCol;
}

inline 	CConnectorQueryHandle::~CConnectorQueryHandle()
{
    delete []m_aCol;
    delete m_pSiteGateList;
}

inline DWORD  CConnectorQueryHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CConnectorQueryHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}


//-------------------------------------------------------------------------
//
//        CCNsQueryHandle
//
//
//  This query handle is used when locating a CNs
//
//-------------------------------------------------------------------------


class CCNsQueryHandle : public CBasicQueryHandle
{
public:
    CCNsQueryHandle(
                 IN  HANDLE                 hCursor,
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  enumRequesterProtocol  eRequesterProtocol
               );

	~CCNsQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    ULONG               m_cCol; // number of columns the user asked
    PROPID *            m_aCol; // propids of the columns the user asked
    CDsQueryHandle      m_hCursor;
};


inline CCNsQueryHandle::CCNsQueryHandle(
                 IN  HANDLE                 hCursor,
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  enumRequesterProtocol eRequesterProtocol
               ):  CBasicQueryHandle(eRequesterProtocol)
{
        m_aCol = new PROPID[ pColumns->cCol];
        memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
        m_cCol = pColumns->cCol;
        m_hCursor.SetHandle( hCursor);
}

inline 	CCNsQueryHandle::~CCNsQueryHandle()
{
    delete []m_aCol;
}

inline DWORD  CCNsQueryHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CCNsQueryHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}


//-------------------------------------------------------------------------
//
//        CMqxploreCNsQueryHandle
//
//
//  This query handle is used when MQXPLORE (MSMQ 1.0) locates all CNs
//
//-------------------------------------------------------------------------


class CMqxploreCNsQueryHandle : public CBasicQueryHandle
{
public:
    CMqxploreCNsQueryHandle(
                 IN  HANDLE                 hCursor,
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  enumRequesterProtocol  eRequesterProtocol
               );

	~CMqxploreCNsQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    ULONG               m_cCol; // number of columns the user asked
    PROPID *            m_aCol; // propids of the columns the user asked
    CDsQueryHandle      m_hCursor;
};


inline CMqxploreCNsQueryHandle::CMqxploreCNsQueryHandle(
                 IN  HANDLE                 hCursor,
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  enumRequesterProtocol eRequesterProtocol
               ):  CBasicQueryHandle(eRequesterProtocol)
{
        m_aCol = new PROPID[ pColumns->cCol];
        memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
        m_cCol = pColumns->cCol;
        m_hCursor.SetHandle( hCursor);
}

inline 	CMqxploreCNsQueryHandle::~CMqxploreCNsQueryHandle()
{
    delete []m_aCol;
}

inline DWORD  CMqxploreCNsQueryHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CMqxploreCNsQueryHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}



//-------------------------------------------------------------------------
//
//        CCNsProtocolQueryHandle
//
//
//  This query handle is used when locating all CNs that support a specific protocol
//
//-------------------------------------------------------------------------


class CCNsProtocolQueryHandle : public CBasicQueryHandle
{
public:
    CCNsProtocolQueryHandle(
                 IN  HANDLE                 hCursor,
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  enumRequesterProtocol  eRequesterProtocol
               );

	~CCNsProtocolQueryHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    ULONG               m_cCol; // number of columns the user asked
    PROPID *            m_aCol; // propids of the columns the user asked
    CDsQueryHandle      m_hCursor;
};


inline CCNsProtocolQueryHandle::CCNsProtocolQueryHandle(
                 IN  HANDLE                 hCursor,
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  enumRequesterProtocol eRequesterProtocol
               ):  CBasicQueryHandle(eRequesterProtocol)
{
        m_aCol = new PROPID[ pColumns->cCol];
        memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
        m_cCol = pColumns->cCol;
        m_hCursor.SetHandle( hCursor);
}

inline 	CCNsProtocolQueryHandle::~CCNsProtocolQueryHandle()
{
    delete []m_aCol;
}

inline DWORD  CCNsProtocolQueryHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CCNsProtocolQueryHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}


//-------------------------------------------------------------------------
//
//        CFilterLinkResultsHandle
//
//
//  This query handle is used when locating site links.
//  It used to filter out site-links that are no longer valid.
//
//-------------------------------------------------------------------------


class CFilterLinkResultsHandle : public CBasicQueryHandle
{
public:
    CFilterLinkResultsHandle(
                 IN  HANDLE                 hCursor,
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  enumRequesterProtocol  eRequesterProtocol
               );

	~CFilterLinkResultsHandle();

    DWORD  GetNoPropsInResult();

	virtual HRESULT LookupNext(
                IN      CDSRequestContext * pRequestContext,
                IN OUT  DWORD  *            pdwSize,
                OUT     PROPVARIANT  *      pbBuffer);

    virtual HRESULT LookupEnd();


private:
    ULONG               m_cCol; // number of columns the user asked
    PROPID *            m_aCol; // propids of the columns the user asked
    CDsQueryHandle      m_hCursor;
    ULONG               m_indexNeighbor1Column;
    ULONG               m_indexNeighbor2Column;
};


inline CFilterLinkResultsHandle::CFilterLinkResultsHandle(
                 IN  HANDLE                 hCursor,
                 IN  const MQCOLUMNSET *    pColumns,
                 IN  enumRequesterProtocol eRequesterProtocol
               ):  CBasicQueryHandle(eRequesterProtocol)
{
    m_aCol = new PROPID[ pColumns->cCol];
    memcpy( m_aCol, pColumns->aCol,  pColumns->cCol* sizeof(PROPID));
    m_cCol = pColumns->cCol;
    m_hCursor.SetHandle( hCursor);
    m_indexNeighbor1Column = m_cCol;
    m_indexNeighbor2Column = m_cCol;
    
    for ( DWORD i = 0; i < m_cCol; i++)
    {
        if ( m_aCol[i] == PROPID_L_NEIGHBOR1)
        {
            m_indexNeighbor1Column = i;
            continue;
        }
        if ( m_aCol[i] == PROPID_L_NEIGHBOR2)
        {
            m_indexNeighbor2Column = i;
            continue;
        }
    }

}

inline 	CFilterLinkResultsHandle::~CFilterLinkResultsHandle()
{
    delete []m_aCol;
}

inline DWORD  CFilterLinkResultsHandle::GetNoPropsInResult()
{
    return(m_cCol);
}

inline HRESULT CFilterLinkResultsHandle::LookupEnd()
{
    delete  this;
    return(MQ_OK);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\dsntlm.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:  dsntlm.cpp

Abstract:  code to handle ntlm clients.

  With NT5 MSMQ servers, Kerberos clients can create objects anywhere
  in the forest/domains tree, as Kerberos allow for delegation of
  authentication. however, ntlm clients can't be delegated.

  So for ntlm clients, check if local server is the proper one, i.e., it's
  the domain controller which contain the container where object will be
  created. If it's not, then return MQ_ERROR_NO_DS. Upon receiving this
  error, clients will try other servers. So if client's site host several
  domain controllers of several domains, and client want to create object
  in one of these domains, it'll eventually find a domain controller which
  can create the object locally, without delegation.

  This is the way MSMQ2.0 support ntlm clients. If client's site does not
  include a domain controller for the relevant domain, client won't be
  able to create its object. That's a backward compatibility limitation.

Author:

    Doron Juster (DoronJ)

--*/

#include "ds_stdh.h"
#include "coreglb.h"
#include "dsads.h"
#include "dsutils.h"
#include "mqadsp.h"

#include "dsntlm.tmh"

static WCHAR *s_FN=L"mqdscore/dsntlm";

HRESULT FindUserAccordingToSid(
                IN  BOOL            fOnlyLocally,
                IN  BOOL            fOnlyInGC,
                IN  BLOB *          pblobUserSid,
                IN  PROPID          propSID,
                IN  DWORD           dwNumProps,
                IN  const PROPID *  propToRetrieve,
                IN OUT PROPVARIANT* varResults ) ;

HRESULT FindUserAccordingToDigest(
                IN  BOOL            fOnlyLocally,
                IN  const GUID *    pguidDigest,
                IN  PROPID          propDigest,
                IN  DWORD           dwNumProps,
                IN  const PROPID *  propToRetrieve,
                IN OUT PROPVARIANT* varResults ) ;

//+------------------------------------------------------------------------
//
//  HRESULT _CheckIfNtlmUserExistForCreate()
//
//+------------------------------------------------------------------------

STATIC HRESULT _CheckIfNtlmUserExistForCreate(
                                      IN  BOOL       fOnlyLocally,
                                      IN  BOOL       fOnlyInGC,
                                      IN  BLOB      *psidBlob )
{
    //
    //  search for "User" object in local replica
    //
    PROPID propSID = PROPID_U_SID ;
    PROPID propDigest = PROPID_U_DIGEST;

    const DWORD cNumProperties = 1;
    PROPID prop[cNumProperties] = { propDigest } ;
    MQPROPVARIANT var[ cNumProperties];
    var[0].vt = VT_NULL;
    var[0].cauuid.pElems = NULL ;
    var[0].cauuid.cElems = 0 ;

    HRESULT hr =  FindUserAccordingToSid( fOnlyLocally,
                                          fOnlyInGC,
                                          psidBlob,
                                          propSID,
                                          cNumProperties,
                                          prop,
                                          var );
    LogHR(hr, s_FN, 43);
    P<GUID> pCleanGuid = var[0].cauuid.pElems ;
    if (SUCCEEDED(hr))
    {
        ASSERT(var[0].vt == (VT_CLSID | VT_VECTOR));
        return hr ;
    }
    else if (hr != MQDS_OBJECT_NOT_FOUND)
    {
        //
        // Problems with Query. return OK, to be on the safe side.
        //
        return MQ_OK ;
    }
    ASSERT(!pCleanGuid) ;

    //
    // Try MigratedUser.
    //
    propSID = PROPID_MQU_SID ;
    propDigest = PROPID_MQU_DIGEST ;
    prop[0] =  propDigest  ;
    var[0].vt = VT_NULL;
    var[0].cauuid.pElems = NULL ;
    var[0].cauuid.cElems = 0 ;

    hr =  FindUserAccordingToSid( fOnlyLocally,
                                  fOnlyInGC,
                                  psidBlob,
                                  propSID,
                                  cNumProperties,
                                  prop,
                                  var );
    LogHR(hr, s_FN, 10);
    pCleanGuid = var[0].cauuid.pElems ;
    if (SUCCEEDED(hr))
    {
        ASSERT(var[0].vt == (VT_CLSID | VT_VECTOR));
        return hr ;
    }
    else if (hr != MQDS_OBJECT_NOT_FOUND)
    {
        //
        // Problems with Query. return OK, to be on the safe side.
        //
        return MQ_OK ;
    }
    ASSERT(!pCleanGuid) ;
    return hr;
}

//+------------------------------------------------------------------------
//
//  HRESULT _CheckIfNtlmUserExistForDelete()
//
//+------------------------------------------------------------------------

STATIC HRESULT _CheckIfNtlmUserExistForDelete( IN const GUID  *pguidDigest )
{
    //
    //  search for "User" object in local replica
    //
    PROPID propUID = PROPID_U_ID ;
    PROPID propDigest = PROPID_U_DIGEST;

    const DWORD cNumProperties = 1;
    PROPID prop[cNumProperties] = { propUID } ;
    MQPROPVARIANT var[ cNumProperties];
    var[0].vt = VT_NULL;
    var[0].puuid = NULL ;

    HRESULT hr = FindUserAccordingToDigest( TRUE,  // fOnlyLocally
                                            pguidDigest,
                                            propDigest,
                                            cNumProperties,
                                            prop,
                                            var ) ;
    LogHR(hr, s_FN, 44);
    P<GUID> pCleanGuid = var[0].puuid ;
    if (SUCCEEDED(hr))
    {
        ASSERT(var[0].vt == VT_CLSID) ;
        return hr ;
    }
    else if (hr != MQDS_OBJECT_NOT_FOUND)
    {
        //
        // Problems with Query. return OK, to be on the safe side.
        //
        return MQ_OK ;
    }
    ASSERT(!pCleanGuid) ;

    //
    // Try MigratedUser.
    //
    propUID = PROPID_MQU_ID ;
    propDigest = PROPID_MQU_DIGEST ;
    prop[0] =  propUID  ;
    var[0].vt = VT_NULL;
    var[0].puuid = NULL ;

    hr = FindUserAccordingToDigest( TRUE,  // fOnlyLocally
                                    pguidDigest,
                                    propDigest,
                                    cNumProperties,
                                    prop,
                                    var ) ;
    LogHR(hr, s_FN, 42);
    pCleanGuid = var[0].puuid ;
    if (SUCCEEDED(hr))
    {
        ASSERT(var[0].vt == VT_CLSID) ;
        return hr ;
    }
    else if (hr != MQDS_OBJECT_NOT_FOUND)
    {
        //
        // Problems with Query. return OK, to be on the safe side.
        //
        return MQ_OK ;
    }
    ASSERT(!pCleanGuid) ;
    return LogHR(hr, s_FN, 20);
}

//+------------------------------------------------------------------------
//
// HRESULT _CheckIfLocalNtlmUser()
//
//  We check if ntlm user has an object in local replica of active directory
//  database. When adding a certificate:
//  1. first look for a "normal" user object.
//  2. if not found, look for a MigratedUser object. This object represents
//     a NT4 user that does not yet have a "user" object in the active
//     directory.
//  3. if still not found, look in GC. If found in GC, then return NO_DS,
//     otherwise, return MQ_OK and a MigratedUser object will be created.
//
//  When deleting a certificate, just check local replica. If not found
//  then return NO_DS and client will seek another server.
//
//+------------------------------------------------------------------------

STATIC HRESULT _CheckIfLocalNtlmUser(
                 IN  const GUID        *pguidDigest,
                 IN  enum enumNtlmOp    eNtlmOp )
{
    HRESULT hr = MQ_OK ;

    if (eNtlmOp == e_Delete)
    {
        hr = _CheckIfNtlmUserExistForDelete( pguidDigest ) ;

        if (SUCCEEDED(hr) || (hr != MQDS_OBJECT_NOT_FOUND))
        {
            return MQ_OK ;
        }
        LogHR(hr, s_FN, 30);
        return MQ_ERROR_NO_DS;
    }
    else if (eNtlmOp != e_Create)
    {
        //
        // We don't expect to reach here with Get or Locate operations,
        // and we don't handle them.
        //
        ASSERT(eNtlmOp == e_Create) ;
        return MQ_OK ;
    }

    P<SID> pCallerSid = NULL ;
    {
        //
        // We need the impersonated state only here, to retrieve the SID.
        // when block end, so end the impersonation.
        //
        P<CImpersonate> pImpersonate = NULL ;

        hr = MQSec_GetImpersonationObject( TRUE,
                                           TRUE,
                                          &pImpersonate ) ;
        LogHR(hr, s_FN, 45);
        if (FAILED(hr))
        {
            return MQ_OK ;
        }

        BOOL fGet = pImpersonate->GetThreadSid( (BYTE**) &pCallerSid ) ;
        if (!fGet)
        {
            return MQ_OK ;
        }
    }

    BLOB   sidBlob ;
    PSID pTmp =  pCallerSid ;
    sidBlob.pBlobData =  (BYTE*) pTmp ;
    sidBlob.cbSize = GetLengthSid( pCallerSid ) ;

    hr = _CheckIfNtlmUserExistForCreate( TRUE,   //  fOnlyLocally,
                                         FALSE,  //  fOnlyInGC,
                                        &sidBlob ) ;
    LogHR(hr, s_FN, 41);
    if (SUCCEEDED(hr) || (hr != MQDS_OBJECT_NOT_FOUND))
    {
        //
        // If user found, or there was a problem with the query itself,
        // return OK. With the ntlm checks we're conservative and prefer
        // safeness. If we're not sure what happen, return OK.
        //
        return MQ_OK ;
    }

    //
    // OK. User not found in local replica. now try GC.
    //
    hr = _CheckIfNtlmUserExistForCreate( FALSE,   //  fOnlyLocally,
                                         TRUE,    //  fOnlyInGC,
                                        &sidBlob ) ;
    LogHR(hr, s_FN, 40);

    if (SUCCEEDED(hr))
    {
        //
        // User no in local replica, but he's in GC. Return NO_DS, so ntlm
        // client will switch to another server.
        //
        return LogHR(MQ_ERROR_NO_DS, s_FN, 1915);
    }
    else if (hr == MQDS_OBJECT_NOT_FOUND)
    {
        //
        // User not found anywhere.
        // Create MigratedUser in local replica.
        //
        return MQ_OK ;
    }

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT  DSCoreCheckIfGoodNtlmServer()
//
//  To be on the safe side, if any operation fail, then return MQ_OK.
//  Return MQ_ERROR_NO_DS only if we know for sure that the object will
//  be created on another domain.
//
//+-----------------------------------------------------------------------

HRESULT  DSCoreCheckIfGoodNtlmServer( IN DWORD            dwObjectType,
                                      IN LPCWSTR          pwcsPathName,
                                      IN const GUID      *pObjectGuid,
                                      IN DWORD            cProps,
                                      IN const PROPID    *pPropIDs,
                                      IN enum enumNtlmOp  eNtlmOp )
{
    //
    // First make some simple checks that do not require DS queries.
    //
    if (g_fLocalServerIsGC)
    {
        //
        // All MSMQ queries for Machines, queues and user certificates
        // are first done on local replica and then (if failed on local
        // replica) on GC. So if local server is also a GC, the query
        // will always be done locally, without going over the network
        // to a remote GC. So NTLM users should not see any problems
        // because of delegation.
        // Similarly, Lookup operation are always done on GC.
        //
        if (eNtlmOp == e_Locate)
        {
            return MQ_OK ;
        }
        if (eNtlmOp == e_GetProps)
        {
            if (dwObjectType != MQDS_MACHINE)
            {
                return MQ_OK ;
            }
            //
            // But, not all attributes are kept in GC. So if the query is
            // for such attribute, go on and check if object is on local
            // domain replica.
            //
            DS_PROVIDER dsGetProvider =
                        MQADSpDecideComputerProvider( cProps,
                                                      pPropIDs ) ;
            if (dsGetProvider == eGlobalCatalog)
            {
                //
                // Query can be done on GC. return OK.
                //
                return MQ_OK ;
            }
        }
    }

    enum DS_CONTEXT dsContext = e_RootDSE ;

    ASSERT(pPropIDs) ;
    if (pPropIDs)
    {
        ASSERT(*pPropIDs) ;
        const MQClassInfo * pClassInfo;

        HRESULT hr = g_pDS->DecideObjectClass(  pPropIDs,
                                             &pClassInfo );
        if (FAILED(hr))
        {
            return MQ_OK ;
        }
        dsContext = pClassInfo->context ;
    }

    if (dsContext != e_RootDSE)
    {
        //
        // If the operation is on objects under the configuration container,
        // then go ahead. it's locally, and queries are not even impersonated.
        //
        return MQ_OK ;
    }
    else if ((eNtlmOp == e_Locate)  &&
             (!g_fLocalServerIsGC))
    {
        //
        // We're not a Global Catalog.
        // For locate of users, machines and queues object, we'll
        // have to go over the network to a remote GC and this will fail
        // for NTLM clients. So retun NO_DS.
        //
        return LogHR(MQ_ERROR_NO_DS, s_FN, 50);
    }

    CCoInit cCoInit;
    //
    // Should be before any R<xxx> or P<xxx> so that its destructor
    // (CoUninitialize) is called after the release of all R<xxx> or P<xxx>
    //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 60);
        return MQ_OK ;
    }

    if (dwObjectType == MQDS_USER)
    {
        //
        // For user certificate, we must search for a user object or a
        // MigratedUser object. We don't have object guid, only SID.
        //
        hr = _CheckIfLocalNtlmUser( pObjectGuid,
                                    eNtlmOp ) ;
        return LogHR(hr, s_FN, 70);
    }
    else if (pObjectGuid)
    {
        P<WCHAR>  pwcsFullPathName = NULL ;
        DS_PROVIDER bindProvider = eDomainController ;

        //
        // We look in GC too. We'll return OK if object is not found.
        // We'll return NO_DS only if we know for sure that object exist
        // in GC but not in our local DS.
        //
        hr =  g_pDS->FindObjectFullNameFromGuid(
                                       eDomainController,
                                       dsContext,
                                       pObjectGuid,
                                       TRUE, //  try GC too
                                      &pwcsFullPathName,
                                      &bindProvider );
        LogHR(hr, s_FN, 46);
        if (SUCCEEDED(hr))
        {
            if (bindProvider == eGlobalCatalog)
            {
                //
                // Object only in GC, not in local DS.
                //
                return LogHR(MQ_ERROR_NO_DS, s_FN, 80);
            }
            ASSERT(bindProvider == eLocalDomainController) ;
        }
        else
        {
            //
            // Just assert that we also look  in GC.
            //
            ASSERT(bindProvider == eGlobalCatalog) ;
        }

        //
        // Object does not exist at all, or it's in local DS.
        //
        return MQ_OK ;
    }
    else if (pwcsPathName)
    {
        LPWSTR pTmpMachine = NULL ;
        P<WCHAR> pwcsMachineName = NULL ;
        P<WCHAR> pwcsQueueName;

        if (dwObjectType == MQDS_QUEUE)
        {
            hr = MQADSpSplitAndFilterQueueName( pwcsPathName,
                                                &pwcsMachineName,
                                                &pwcsQueueName );
            if (FAILED(hr))
            {
                LogHR(hr, s_FN, 90);
                return MQ_OK ;
            }
            pTmpMachine = pwcsMachineName ;
        }
        else if (dwObjectType == MQDS_MACHINE)
        {
            pTmpMachine = const_cast<LPWSTR> (pwcsPathName) ;
        }
        else
        {
            //
            // All other objects are under the configuration container
            // and can be queried locally by any domain controller.
            // Anyway, we should not even reach here, because of the simple
            // check at the beginning of the function.
            //
            ASSERT(0) ;
            return MQ_OK ;
        }

        if (!pTmpMachine)
        {
            //
            // Weird. We don't have the machine name.
            //
            ASSERT(pTmpMachine) ;
            return MQ_OK ;
        }

        MQPROPERTYRESTRICTION propRestriction;
        propRestriction.rel = PREQ;
        propRestriction.prop = PROPID_QM_PATHNAME;
        propRestriction.prval.vt = VT_LPWSTR;
        propRestriction.prval.pwszVal = const_cast<WCHAR*>(pTmpMachine);

        MQRESTRICTION restriction;
        restriction.cRes = 1;
        restriction.paPropRes = &propRestriction;

        PROPID prop = PROPID_COM_FULL_PATH;
        P<WCHAR> pwcsFullPathName = NULL ;

        hr = SearchFullComputerPathName( eLocalDomainController,
                                         e_MsmqComputerObject,
										 NULL,	//pwcsComputerDnsName
                                         g_pwcsLocalDsRoot,
                                        &restriction,
                                        &prop,
                                        &pwcsFullPathName ) ;
        if (SUCCEEDED(hr))
        {
            //
            // Object found in local DS.
            //
            return MQ_OK ;
        }

        ASSERT(pwcsFullPathName == NULL) ;
        //
        // We look in GC too. We'll return OK if object is not found.
        // We'll return NO_DS only if we know for sure that object exist
        // in GC but not in our local DS.
        //
        hr = SearchFullComputerPathName( eGlobalCatalog,
                                         e_MsmqComputerObject,
										 NULL,	//pwcsComputerDnsName
                                         g_pwcsLocalDsRoot,
                                        &restriction,
                                        &prop,
                                        &pwcsFullPathName ) ;
        if (SUCCEEDED(hr))
        {
            //
            // Object found in GC. we're not a good server.
            //
            return LogHR(MQ_ERROR_NO_DS, s_FN, 1916);
        }

        //
        // Object not found at all !
        //
        return MQ_OK ;
    }
    else if (dwObjectType == MQDS_MACHINE)
    {
        //
        // This can happen when a client learn its topology. This query
        // means it wants addresses of local server. see qm\topology.cpp,
        // in void CClientTopologyRecognition::LearnFromDSServer().
        //
        ASSERT(eNtlmOp == e_GetProps) ;
    }
    else
    {
        ASSERT(0) ;
    }

    return MQ_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\fornsite.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    fornsite.cpp

Abstract:

    MQDSCORE library,
    A class that keeps a map of foreign sites.

Author:

    ronit hartmann (ronith)  

--*/

#include "ds_stdh.h"
#include "dsads.h"
#include "adstempl.h"
#include "coreglb.h"
#include "fornsite.h"

#include "fornsite.tmh"

static WCHAR *s_FN=L"mqdscore/fornsite";

UINT AFXAPI HashKey(GUID g)
{
    return (g.Data1);
}

CMapForeignSites::CMapForeignSites()
{
}

CMapForeignSites::~CMapForeignSites()
{
}

BOOL  CMapForeignSites::IsForeignSite( const GUID * pguidSite)
/*++

Routine Description:
    First tries to find the site in the g_mapForeignSites.
    If the site is not found in the map, retreive this information
    from the DS, and update the map.

    There is no refresh mechanism for the map

Arguments:
        pguidSite :  the site guid

Return Value:
--*/
{
    BOOL result;
	{
		CS Lock( m_cs);
		if ( m_mapForeignSites.Lookup( *pguidSite, result))
		{
			return result;
		}
	}
    //
    //  read the site info from the DS
    //
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    HRESULT hr;
    PROPID prop = PROPID_S_FOREIGN;
    PROPVARIANT var;
    var.vt = VT_NULL;

    hr = g_pDS->GetObjectProperties(
                eLocalDomainController,	
                &requestDsServerInternal,
 	            NULL,
                const_cast<GUID *>(pguidSite),
                1,
                &prop,
                &var);
    if (FAILED(hr))
    {
        //
        //  unknown site, assume not foreign
        //
        LogHR(hr, s_FN, 47);
        return(FALSE);
    }
    result = (var.bVal > 0) ?  TRUE: FALSE;
	{
		CS Lock( m_cs);
		m_mapForeignSites[*pguidSite] = result;
	}
    return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\mqcmachn.cpp ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    mqcmachn.cpp

Abstract:

    MQDSCORE library,
    Internal functions for ADS operations on msmqConfiguration object.

Author:

    ronit hartmann (ronith)  (first version in mqadsp.cpp)
    Doron Juster   (DoronJ)  split files.

--*/

#include "ds_stdh.h"
#include <_propvar.h>
#include "mqadsp.h"
#include "dsads.h"
#include "mqattrib.h"
#include "mqads.h"
#include "usercert.h"
#include "hquery.h"
#include "siteinfo.h"
#include "adstempl.h"
#include "coreglb.h"
#include "adserr.h"
#include "dsutils.h"
#include "dscore.h"
#include <notify.h>
#include <lmaccess.h>

#include "mqcmachn.tmh"

static WCHAR *s_FN=L"mqdscore/mqcmachn";

//+-------------------------------------------
//
//  HRESULT  SetDefaultMachineSecurity()
//
//+-------------------------------------------

static
HRESULT  
SetDefaultMachineSecurity( 
	IN  DWORD           dwObjectType,
	IN  PSID            pComputerSid,
	IN OUT DWORD       *pcp,
	IN OUT PROPID       aProp[  ],
	IN OUT PROPVARIANT  apVar[  ],
	IN BOOL             fImpersonate,
    IN BOOL             fIncludeOwner,
	OUT PSECURITY_DESCRIPTOR* ppMachineSD 
	)
{
    //
    // If the computer sid is null, then most probably the setup will fail.
    // (that is, if we can't retrieve the computer sid, why would we be able
    // to create the msmqConfiguration object under the computer object.
    // failing to retrieve the sid may be the result of broken trust or because
    // the computer object really does not exist or was not yet replicated).
    // The "good" solution is to completely fail setup right now. But to
    // reduce risks and avoid regressions, let's build a security descriptor
    // without the computer sid and proceed with setup.
    // If setup do succeed, then the msmq service on the machine that run
    // setup may fail to update its own properties, if it need to update them.
    // the admin can always use mmc and add the computer account to the dacl.
    // bug 4950.
    //
    ASSERT(pComputerSid);

    //
    // If PROPID_QM_SECURITY already present, then return. This happen
    // in Migration code.
    //
    for (DWORD j = 0; j < *pcp; j++)
    {
        if (aProp[j] == PROPID_QM_SECURITY)
        {
            return MQ_OK;
        }
    }

    //
    // See if caller supply a Owner SID. If yes, then this SID is granted
    // full control on the msmq configuration object.
    // This "owner" is usually the user SID that run setup. The "owner" that
    // is retrieved below from the default security descriptor is usually
    // (for clients) the SID of the computer object, as the msmqConfiguration
    // object is created by the msmq service (on client machines).
    //
    PSID pUserSid = NULL ;
    for ( j = 0 ; j < *pcp ; j++ )
    {
        if (aProp[j] == PROPID_QM_OWNER_SID)
        {
            aProp[j] = PROPID_QM_DONOTHING ;
            pUserSid = apVar[j].blob.pBlobData ;
            ASSERT(IsValidSid(pUserSid)) ;
            break ;
        }
    }

    //
    // Build a security descriptor that include only owner and group.
    // Owner is needed to build the DACL.
    //
    PSECURITY_DESCRIPTOR  psdOwner ;

    HRESULT hr = MQSec_GetDefaultSecDescriptor( dwObjectType,
                                               &psdOwner,
                                                fImpersonate,
                                                NULL,
                                                DACL_SECURITY_INFORMATION,
                                                e_UseDefaultDacl ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }
    P<BYTE> pTmp = (BYTE*) psdOwner ;

    PSID pOwner = NULL;
    BOOL bOwnerDefaulted = FALSE ;
    BOOL bRet = GetSecurityDescriptorOwner( psdOwner,
                                           &pOwner,
                                           &bOwnerDefaulted);
    ASSERT(bRet);

    PSID pWorldSid = MQSec_GetWorldSid() ;
    ASSERT(IsValidSid(pWorldSid)) ;

    //
    // Build the default machine DACL.
    //
    DWORD dwAclSize = sizeof(ACL)                                +
              (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))) +
              GetLengthSid(pWorldSid)                            +
              GetLengthSid(pOwner) ;

    if (pComputerSid)
    {
        dwAclSize += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                      GetLengthSid(pComputerSid) ;
    }
    if (pUserSid)
    {
        dwAclSize += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                      GetLengthSid(pUserSid) ;
    }

    AP<char> DACL_buff = new char[ dwAclSize ];
    PACL pDacl = (PACL)(char*)DACL_buff;
    InitializeAcl(pDacl, dwAclSize, ACL_REVISION);

    //
    // See if it's a foreign machine. If yes, then allow everyone to create
    // queue. a foreign machine is not a real msmq machine, so there is no
    // msmq service that can create queues on behalf of users that run on
    // that machine.
    // Similarly, check if it's a group on a cluster machine.
    //
    BOOL fAllowEveryoneCreateQ = FALSE ;

    for ( j = 0 ; j < *pcp ; j++ )
    {
        if (aProp[j] == PROPID_QM_FOREIGN)
        {
            if (apVar[j].bVal == FOREIGN_MACHINE)
            {
                fAllowEveryoneCreateQ = TRUE ;
                break ;
            }
        }
        else if (aProp[j] == PROPID_QM_GROUP_IN_CLUSTER)
        {
            if (apVar[j].bVal == MSMQ_GROUP_IN_CLUSTER)
            {
                aProp[j] = PROPID_QM_DONOTHING ;
                fAllowEveryoneCreateQ = TRUE ;
                break ;
            }
        }
    }

    DWORD dwWorldAccess = 0 ;

    if (fAllowEveryoneCreateQ)
    {
        dwWorldAccess = MQSEC_MACHINE_GENERIC_WRITE;
    }
    else
    {
        switch (dwObjectType)
        {
        case MQDS_MACHINE:
            dwWorldAccess = MQSEC_MACHINE_WORLD_RIGHTS ;
            break;

        case MQDS_MSMQ10_MACHINE:
            dwWorldAccess = MQSEC_MACHINE_GENERIC_WRITE;
            break;

        default:
            break;
        }
    }

    ASSERT(dwWorldAccess != 0) ;

    BOOL fAdd = AddAccessAllowedAce( pDacl,
                                     ACL_REVISION,
                                     dwWorldAccess,
                                     pWorldSid );
    ASSERT(fAdd) ;

    //
    // Add the owner with full control.
    //
    fAdd = AddAccessAllowedAce( pDacl,
                                ACL_REVISION,
                                MQSEC_MACHINE_GENERIC_ALL,
                                pOwner);
    ASSERT(fAdd) ;

    //
    // Add the computer account.
    //
    if (pComputerSid)
    {
        fAdd = AddAccessAllowedAce( pDacl,
                                    ACL_REVISION,
                                    MQSEC_MACHINE_SELF_RIGHTS,
                                    pComputerSid);
        ASSERT(fAdd) ;
    }

    if (pUserSid)
    {
        fAdd = AddAccessAllowedAce( pDacl,
                                    ACL_REVISION,
                                    MQSEC_MACHINE_GENERIC_ALL,
                                    pUserSid);
        ASSERT(fAdd) ;
    }

    //
    // build absolute security descriptor.
    //
    SECURITY_DESCRIPTOR  sd ;
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

    if (fIncludeOwner)
    {
		bRet = SetSecurityDescriptorOwner(&sd, pOwner, bOwnerDefaulted);
		ASSERT(bRet);

		PSID pGroup = NULL;
		BOOL bGroupDefaulted = FALSE;

		bRet = GetSecurityDescriptorGroup( psdOwner,
										  &pGroup,
										  &bGroupDefaulted);
		ASSERT(bRet && IsValidSid(pGroup));

		bRet = SetSecurityDescriptorGroup(&sd, pGroup, bGroupDefaulted);
		ASSERT(bRet);
    }

    bRet = SetSecurityDescriptorDacl(&sd, TRUE, pDacl, TRUE);
    ASSERT(bRet);

    //
    // Convert the descriptor to a self relative format.
    //
    DWORD dwSDLen = 0;
    hr = MQSec_MakeSelfRelative( (PSECURITY_DESCRIPTOR) &sd,
                                  ppMachineSD,
                                 &dwSDLen ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }
    ASSERT(dwSDLen != 0) ;

    aProp[ *pcp ] = PROPID_QM_SECURITY ;
    apVar[ *pcp ].blob.cbSize = dwSDLen ;
    apVar[ *pcp ].blob.pBlobData = (BYTE*) *ppMachineSD ;
    (*pcp)++ ;

    return MQ_OK ;
}

//+--------------------------------------------
//
//  HRESULT MQADSpCreateMachineComputer()
//
//+--------------------------------------------

HRESULT MQADSpCreateMachineComputer(
                IN  LPCWSTR         pwcsPathName,
                IN  CDSRequestContext *pRequestContext,
                OUT WCHAR **        ppwcsFullPathName
                                    )
/*++

Routine Description:
    This routine creates computer object for a specific MSMQ-machine.

Arguments:

Return Value:
--*/
{

    //
    // The PROPID_COM_SAM_ACCOUNT contains the first MAX_COM_SAM_ACCOUNT_LENGTH (19)
    // characters of the computer name, as unique ID. (6295 - ilanh - 03-Jan-2001)
    //
	DWORD len = __min(wcslen(pwcsPathName), MAX_COM_SAM_ACCOUNT_LENGTH);
    AP<WCHAR> pwcsMachineNameWithDollar = new WCHAR[len + 2];
	wcsncpy(pwcsMachineNameWithDollar, pwcsPathName, len);
	pwcsMachineNameWithDollar[len] = L'$';
	pwcsMachineNameWithDollar[len + 1] = L'\0';

    const DWORD xNumCreateCom = 2;
    PROPID propCreateComputer[xNumCreateCom];
    PROPVARIANT varCreateComputer[xNumCreateCom];
    DWORD j = 0;
    propCreateComputer[ j] = PROPID_COM_SAM_ACCOUNT;
    varCreateComputer[j].vt = VT_LPWSTR;
    varCreateComputer[j].pwszVal = pwcsMachineNameWithDollar;
    j++;

    propCreateComputer[j] = PROPID_COM_ACCOUNT_CONTROL ;
    varCreateComputer[j].vt = VT_UI4 ;
    varCreateComputer[j].ulVal = DEFAULT_COM_ACCOUNT_CONTROL ;
    j++;
    ASSERT(j == xNumCreateCom);

    HRESULT hr = MQADSpCreateComputer(
             pwcsPathName,
             j,
             propCreateComputer,
             varCreateComputer,
             0,
             NULL,
             NULL,
             pRequestContext,
             ppwcsFullPathName
             );

    return LogHR(hr, s_FN, 30);
}

//+-------------------------------------
//
//  HRESULT MQADSpCreateMachine()
//
//+-------------------------------------

HRESULT 
MQADSpCreateMachine(
     IN  LPCWSTR            pwcsPathName,
     IN  DWORD              dwObjectType,
     IN  const DWORD        cp,
     IN  const PROPID       aProp[  ],
     IN  const PROPVARIANT  apVar[  ],
     IN  const DWORD        cpEx,
     IN  const PROPID       aPropEx[  ],
     IN  const PROPVARIANT  apVarEx[  ],
     IN  CDSRequestContext *pRequestContext,
     IN OUT MQDS_OBJ_INFO_REQUEST * pObjectInfoRequest,
     IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
     )
/*++

Routine Description:
    This routine creates MQDS_MACHINE.
    For independent clients: msmqConfiguration is created under the computer object.
    For servers: in addition to msmqConfiguration, msmqSettings is created under site\servers

Arguments:

Return Value:
--*/
{
    HRESULT hr;
    BOOL    fLookForWorkgroup = TRUE;

    //
    // This function can be called recursively.
    // When a workgoup machine join domain, we need to create the
    // msmqConfiguration object on a GC server. That's exactly same
    // requirement as for migrated objects. so we call CreateMigratedObject().
    // CreateMigratedObject() will call us, after it find a proper GC server.
    // So make sure we don't enter endless recursion.
    //
    for (DWORD jcp = 0; jcp < cp; jcp++)
    {
        if (aProp[jcp] == PROPID_QM_MIG_PROVIDER)
        {
            //
            // we're called from CreateMigratedObject().
            //
            fLookForWorkgroup = FALSE;
            break;
        }
    }

    if (fLookForWorkgroup)
    {
        for (DWORD jcp = 0; jcp < cp; jcp++)
        {
            if (aProp[jcp] == PROPID_QM_WORKGROUP_ID)
            {
                //
                // Need to call CreateMigratedObject().
                //
                hr = DSCoreCreateMigratedObject(
                                dwObjectType,
                                pwcsPathName,
                                cp,
                                const_cast<PROPID*>      (aProp),
                                const_cast<PROPVARIANT*> (apVar),
                                cpEx,
                                const_cast<PROPID*>      (aPropEx),
                                const_cast<PROPVARIANT*> (apVarEx),
                                pRequestContext,
                                pObjectInfoRequest,
                                pParentInfoRequest,
                                FALSE,
                                FALSE,
                                NULL,
                                NULL
								);
                return LogHR(hr, s_FN, 50);
            }
        }
    }

    ASSERT(pParentInfoRequest == NULL); // not used at present.

    //
    // Find out the type of service provided by this QM service and
    // the machine's sites
    //
    BOOL fServer = FALSE;
    DWORD dwService; 
	DWORD dwOldService = 0;
    const GUID * pSite = NULL;
    DWORD dwNumSites = 0;
    GUID * pCNs = NULL;
    DWORD dwNumCNs = 0;
    BOOL fCheckIfNeedToCreateComputerObject = FALSE;

    // [adsrv] We may get either old PROPID_QM_SERVICE or new 3 server-type-specific booleans
    // We must write 3 new specific ones
    BOOL fRouter      = FALSE,      // values
         fDSServer    = FALSE,
         fDepClServer = FALSE,
         fSetQmOldService = FALSE;

    BOOL fSetSiteIDs = TRUE;
    BOOL fForeign = FALSE;

#define MAX_NEW_PROPS  31

    //
    // We will reformat properties to include new server type control and
    // maybe SITE_IDS and maybe computer SID. and QM_SECURITY.
    //
    ASSERT((cp + 6)   < MAX_NEW_PROPS);
    ASSERT((cpEx + 4) < MAX_NEW_PROPS);

    DWORD        cp1 = 0;
    PROPID       aProp1[MAX_NEW_PROPS];
    PROPVARIANT  apVar1[MAX_NEW_PROPS];

    //
    //  We need to handle both new and old setups.
    //  Some may pass PROPID_QM_SITE_ID and some
    //  PROPID_QM_SITE_IDS
    //

    for (DWORD i = 0; i< cp ; i++)
    {
        BOOL fCopy = TRUE;
        switch (aProp[i])
        {
        // [adsrv] Even if today we don't get new server-type-specific props, we may tomorrow.
        case PROPID_QM_SERVICE_ROUTING:
            fRouter = (apVar[i].bVal != 0);
            fCopy   = FALSE;
            break;

        case PROPID_QM_SERVICE_DSSERVER:
            fDSServer  = (apVar[i].bVal != 0);
            fCopy      = FALSE;
            break;

        case PROPID_QM_SERVICE_DEPCLIENTS:
            fDepClServer = (apVar[i].bVal != 0);
            fCopy        = FALSE;
            break;

        case PROPID_QM_SERVICE:
            switch (apVar[i].ulVal)
            {
                case SERVICE_SRV:
                    fRouter = TRUE;
                    fDepClServer = TRUE;
                    dwService = apVar[i].ulVal;
                    break;

                case SERVICE_BSC:
                case SERVICE_PSC:
                case SERVICE_PEC:
                    fDSServer = TRUE;
                    fRouter = TRUE;
                    fDepClServer = TRUE;
                    dwService = apVar[i].ulVal;
                    break;

                default:
                    break;
            }

            fCopy = FALSE;
            break;

        case PROPID_QM_OLDSERVICE:
            dwOldService = apVar[i].ulVal;
            fSetQmOldService  = TRUE;
            break;

        case PROPID_QM_SITE_ID:
            pSite = apVar[i].puuid;
            dwNumSites = 1;
            fCopy = FALSE;
            //
            //  PROPID_QM_SITE_ID is used only by old setup.
            //  For old setup we need to check if computer object
            //  exist in the DS ( and if not to create one).
            //  This support is required for Win9x computers.
            //
            fCheckIfNeedToCreateComputerObject = TRUE;
            break;

        case PROPID_QM_SITE_IDS:
            pSite = apVar[i].cauuid.pElems;
            dwNumSites = apVar[i].cauuid.cElems;
            fSetSiteIDs = FALSE;
            break;

        case PROPID_QM_CNS:
            pCNs = apVar[i].cauuid.pElems;
            dwNumCNs = apVar[i].cauuid.cElems;
            break;

        case PROPID_QM_FOREIGN:
            fForeign = (apVar[i].bVal != 0);
            break;

        default:
            break;

        }
        // Copy property to the new array
        if (fCopy)
        {
            aProp1[cp1] = aProp[i];
            apVar1[cp1] = apVar[i];  // yes, there may be ptrs, but no problem - apVar is here
            cp1++;
        }

    }

    if (fRouter || fDSServer)
    {
        fServer = TRUE;  // For the case it was set by new attributes
    }

    //
    // For foreign machine definition of sites in NT5 is equal to CNs in NT4.
    // If this machine is foreign and we got PROPID_QM_CNS (it means that
    // creation was performed on NT4 PSC/BSC) we have to define PROPID_QM_SITE_IDS
    //
    if(fForeign && fSetSiteIDs)
    {
        ASSERT(dwNumCNs);
        aProp1[cp1] = PROPID_QM_SITE_IDS;
        apVar1[cp1].vt = VT_CLSID|VT_VECTOR;
        apVar1[cp1].cauuid.pElems = pCNs;
        apVar1[cp1].cauuid.cElems = dwNumCNs;
        cp1++;
    }
	else if ( fSetSiteIDs)
	{
		ASSERT(	pSite != 0);
        aProp1[cp1] = PROPID_QM_SITE_IDS;
        apVar1[cp1].vt = VT_CLSID|VT_VECTOR;
        apVar1[cp1].cauuid.pElems = const_cast<GUID *>(pSite);
        apVar1[cp1].cauuid.cElems = dwNumSites;
        cp1++;
	}

    // [adsrv] Now we add new server type attributes
    aProp1[cp1] = PROPID_QM_SERVICE_ROUTING;
    apVar1[cp1].bVal = (UCHAR)fRouter;
    apVar1[cp1].vt = VT_UI1;
    cp1++;

    aProp1[cp1] = PROPID_QM_SERVICE_DSSERVER;
    apVar1[cp1].bVal = (UCHAR)fDSServer;
    apVar1[cp1].vt = VT_UI1;
    cp1++;

    aProp1[cp1] = PROPID_QM_SERVICE_DEPCLIENTS;
    apVar1[cp1].bVal = (UCHAR)fDepClServer;
    apVar1[cp1].vt = VT_UI1;
    cp1++;
    // [adsrv] end

    DWORD dwNumofProps = cp1;

    AP<WCHAR> pwcsFullPathName;
    DS_PROVIDER createProvider;

    hr =  GetFullComputerPathName( 
				pwcsPathName,
				e_RealComputerObject,
				dwNumofProps,
				aProp1,
				apVar1,
				&pwcsFullPathName,
				&createProvider 
				);
    //
    //  If computer object not found and the
    //  caller is MSMQ 1.0 setup : create computer object
    //
    bool fDoNotImpersonateConfig = false;

    if ( (hr == MQDS_OBJECT_NOT_FOUND) &&
          fCheckIfNeedToCreateComputerObject)
    {
        hr = MQADSpCreateMachineComputer(
                    pwcsPathName,
                    pRequestContext,
                    &pwcsFullPathName
                    );

        if (SUCCEEDED(hr))
        {
            //
            // A computer object was successfully created, while
            // impersonating the caller. The MQADSpCreateMachineComputer()
            // code grant the caller the permission to create child objects
            // below the computer object (i.e., the msmqConfiguration object).
            // So we know caller can create the configuration object.
            // We also know that for msmq1.0 setup, the configuration object
            // must be created with given GUID, which need the special
            // add-guid permission. The caller usually do not have the
            // add-guid permission, but the local system account does have
            // it. So do not impersonate while creating the msmqConfigration
            // object and let the local msmq service do it.
            // bug 6294.
            //
            fDoNotImpersonateConfig = true;
        }

    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 60);
    }
    //
    //  Create Computer-MSMQ-Configuration under the computer
    //
    MQDS_OBJ_INFO_REQUEST * pObjInfoRequest = NULL;
    MQDS_OBJ_INFO_REQUEST  sMachineInfoRequest;
    CAutoCleanPropvarArray cCleanQmPropvars;
    PROPID sMachineGuidProps[] = {PROPID_QM_MACHINE_ID};
    ULONG idxQmGuid = 0; //index of qm guid property in requested qm object info

    if (pObjectInfoRequest)
    {
        ASSERT(pObjectInfoRequest->cProps == ARRAY_SIZE(sMachineGuidProps));
        ASSERT(pObjectInfoRequest->pPropIDs[0] == sMachineGuidProps[0]);

        pObjInfoRequest = pObjectInfoRequest;
    }
    else if (fServer)
    {
        //
        // fetch the QM id while creating it
        //
        sMachineInfoRequest.cProps = ARRAY_SIZE(sMachineGuidProps);
        sMachineInfoRequest.pPropIDs = sMachineGuidProps;
        sMachineInfoRequest.pPropVars =
                 cCleanQmPropvars.allocClean(ARRAY_SIZE(sMachineGuidProps));

        pObjInfoRequest = &sMachineInfoRequest;
    }

    //
    // After msmqConfiguration object is created, Grant the computer account
    // read/write rights on the object. That's necessary in order for the
    // MSMQ service (on the new machine) to be able to update its type and
    // other properties, while it's talking with a domain controller from a
    // different domain.
    //
    // First, read computer object SID from ActiveDirectory.
    //
    CDSRequestContext RequestContextSid(e_DoNotImpersonate, e_ALL_PROTOCOLS);
    PROPID propidSid = PROPID_COM_SID;
    MQPROPVARIANT   PropVarSid;
    PropVarSid.vt = VT_NULL;
    PropVarSid.blob.pBlobData = NULL;
    P<BYTE> pSid = NULL;

    hr = g_pDS->GetObjectProperties( 
					createProvider,
					&RequestContextSid,
					pwcsFullPathName,
					NULL, // pGuid
					1,    // cPropIDs
					&propidSid,
					&PropVarSid 
					);
    if (SUCCEEDED(hr))
    {
        pSid = PropVarSid.blob.pBlobData;
        aProp1[dwNumofProps] = PROPID_COM_SID;
        apVar1[dwNumofProps] = PropVarSid;
        dwNumofProps++;
    }

    //
    // Time to create the default security descriptor.
    //
    P<BYTE> pMachineSD = NULL;
    BOOL fIncludeOwner = TRUE;
    if (pRequestContext->NeedToImpersonate() && fDoNotImpersonateConfig)
    {
        //
        // By default, include owner component in the security descriptor.
        // Do not include it if called from RPC (i.e., need impersonation),
        // and we decided to create the msmqConfiguration object without
        // impersonation. This is for bug 6294.
        //
        fIncludeOwner = FALSE;
    }

    //
    // Include the owner and group in security descriptor only if we're
    // going to impersonate when creating the configuration object.
    //

    hr = SetDefaultMachineSecurity( 
				dwObjectType,
				pSid,
				&dwNumofProps,
				aProp1,
				apVar1,
				pRequestContext->NeedToImpersonate(),
				 fIncludeOwner,
				(PSECURITY_DESCRIPTOR*) &pMachineSD 
				);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 70);
    }
    ASSERT(dwNumofProps < MAX_NEW_PROPS);

    CDSRequestContext RequestContextConfig = *pRequestContext;
    if (fDoNotImpersonateConfig)
    {
        RequestContextConfig.SetDoNotImpersonate2();
    }

    hr = g_pDS->CreateObject(
            createProvider,
            &RequestContextConfig,
            MSMQ_COMPUTER_CONFIGURATION_CLASS_NAME,   // object class
            x_MsmqComputerConfiguration,     // object name
            pwcsFullPathName,                // the computer name
            dwNumofProps,
            aProp1,
            apVar1,
            pObjInfoRequest,
            NULL /*pParentInfoRequest*/
			);

    if (!fServer)
    {
        return LogHR(hr, s_FN, 80);
    }

    //
    //  For servers only!
    //  Find all sites which match this server addresses and create the
    //  MSMQSetting object.
    //

    GUID guidObject;

    if (FAILED(hr))
    {
        if ( hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) ||       // BUGBUG: alexdad
             hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS))  // to throw away after transition
        {
            //
            // The MSMQConfiguration object already exist. So create the
            // MSMQSetting objects. This case may happen, for example, if
            // server setup was terminated before its end.
            // First step, get the MSMQConfiguration guid.
            //
            PROPID       aProp[1] = {PROPID_QM_MACHINE_ID};
            PROPVARIANT  apVar[1];

            apVar[0].vt = VT_CLSID;
            apVar[0].puuid = &guidObject;
            CDSRequestContext requestDsServerInternal(e_DoNotImpersonate, e_IP_PROTOCOL);
            hr =  MQADSpGetMachineProperties( 
						pwcsPathName,
						NULL,  // guid
						1,
						aProp,
						&requestDsServerInternal,
						apVar
						);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 90);
            }
        }
        else
        {
            return LogHR(hr, s_FN, 100);
        }
    }
    else
    {
        ASSERT(pObjInfoRequest);
        hr = RetreiveObjectIdFromNotificationInfo( 
					pObjInfoRequest,
					idxQmGuid,
					&guidObject 
					);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 110);
        }
    }

    hr = MQADSpCreateMachineSettings(
            dwNumSites,
            pSite,
            pwcsPathName,
            fRouter,              // [adsrv] dwService,
            fDSServer,
            fDepClServer,
            fSetQmOldService,
            dwOldService,
            &guidObject,
            cpEx,
            aPropEx,
            apVarEx,
            pRequestContext
            );

    return LogHR(hr, s_FN, 120);

#undef MAX_NEW_PROPS
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\notify.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
    notify.cpp

Abstract:
    notifications to owners of changed objects

Author:

    Raanan Harari (raananh)
    Ilan Herbst    (ilanh)   9-July-2000 

--*/
#include "ds_stdh.h"
#include "bupdate.h"
#include "dsutils.h"
#include "mqads.h"
#include "coreglb.h"
#include "privque.h"
#include "pnotify.h"
#include "notify.h"
#include "dscore.h"
#include "rpccli.h"

#include "notify.tmh"

const UCHAR x_bDS_NOTIFICATION_MSG_PRIORITY = DEFAULT_M_PRIORITY;
const DWORD x_dwDS_NOTIFICATION_MSG_TIMEOUT = (5 * 60);    /* 5 min */

static WCHAR *s_FN=L"mqdscore/notify";

//
// queue properties that are needed for create queue notification
//
extern const PROPID g_rgNotifyCreateQueueProps[] =
{
    PROPID_Q_TYPE,
    PROPID_Q_INSTANCE,
    PROPID_Q_BASEPRIORITY,
    PROPID_Q_JOURNAL,
    PROPID_Q_QUOTA,
    PROPID_Q_JOURNAL_QUOTA,
    PROPID_Q_CREATE_TIME,
    PROPID_Q_MODIFY_TIME,
    PROPID_Q_SECURITY,
    PROPID_Q_PATHNAME,
    PROPID_Q_LABEL,
    PROPID_Q_AUTHENTICATE,
    PROPID_Q_PRIV_LEVEL,
    PROPID_Q_TRANSACTION
};
extern const ULONG g_cNotifyCreateQueueProps = ARRAY_SIZE(g_rgNotifyCreateQueueProps);
static enum // keep in the same order as above array
{
    e_idxQType,
    e_idxQInstance,
    e_idxQBasePriority,
    e_idxQJournal,
    e_idxQQuota,
    e_idxQJournalQuota,
    e_idxQCreateTime,
    e_idxQModifyTime,
    e_idxQSecurity,
    e_idxQPathname,
    e_idxQLabel,
    e_idxQAuthenticate,
    e_idxQPrivLevel,
    e_idxQTransaction
};
extern const ULONG g_idxNotifyCreateQueueInstance = e_idxQInstance;

//
// QM properties that are needed for notifications
//
extern const PROPID g_rgNotifyQmProps[] = 
{
    PROPID_QM_MACHINE_ID,
    PROPID_QM_FOREIGN
};
extern const ULONG g_cNotifyQmProps = ARRAY_SIZE(g_rgNotifyQmProps);
static enum // keep in the same order as above array
{
    e_idxQmId,
    e_idxQmForeign
};

//
// queue properties that are needed for create queue write request
// same as notify, but with PROPID_Q_SCOPE
//
const PROPID x_rgWritereqCreateQueueProps[] =
{
    PROPID_Q_TYPE,
    PROPID_Q_INSTANCE,
    PROPID_Q_BASEPRIORITY,
    PROPID_Q_JOURNAL,
    PROPID_Q_QUOTA,
    PROPID_Q_JOURNAL_QUOTA,
    PROPID_Q_CREATE_TIME,
    PROPID_Q_MODIFY_TIME,
    PROPID_Q_SECURITY,
    PROPID_Q_PATHNAME,
    PROPID_Q_LABEL,
    PROPID_Q_AUTHENTICATE,
    PROPID_Q_PRIV_LEVEL,
    PROPID_Q_TRANSACTION,
    PROPID_Q_SCOPE
};
const ULONG x_cWritereqCreateQueueProps = ARRAY_SIZE(x_rgWritereqCreateQueueProps);

//
// queue properties that are needed for update queue notification
//
const PROPID x_rgNotifyUpdateQueueProps[] = 
{
    PROPID_Q_QMID,
};
const ULONG x_cNotifyUpdateQueueProps = ARRAY_SIZE(x_rgNotifyUpdateQueueProps);
static enum // keep in the same order as above array
{
    e_idxQueueQmId
};

//
// describes where to take the notification value for update notification props
//
static enum
{
    e_ValueInUpdProps,    // value is in original update props supplied by caller
    e_ValueInRequestProps // value is in props requested from the DS upon setting
};

//
// fwd declaration of static funcs
//
STATIC HRESULT BuildSendNotification(
                      IN GUID*               pguidDestinationQmId,
                      IN unsigned char       ucOperation,
                      IN LPCWSTR             pwcsPathName,
                      IN const GUID*         pguidIdentifier,
                      IN ULONG               cProps,
                      IN const PROPID *      rgPropIDs,
                      IN const PROPVARIANT * rgPropVars);
//-------------------------------------------------------------
// Functions
//-------------------------------------------------------------


HRESULT NotifyCreateQueue(IN const MQDS_OBJ_INFO_REQUEST * pQueueInfoRequest,
                          IN const MQDS_OBJ_INFO_REQUEST * pQmInfoRequest,
                          IN LPCWSTR                       pwcsPathName)
/*++

Routine Description:
    Sends a notification for the owner QM of the queue that was created

Arguments:
    pQueueInfoRequest - queue props as defined in g_rgNotifyCreateQueueProps
    pQmInfoRequest    - owner qm props as defined in g_rgNotifyQmProps
    pwcsPathName      - pathname of created queue

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // bail if info requests failed
    //
    if (FAILED(pQueueInfoRequest->hrStatus) ||
        FAILED(pQmInfoRequest->hrStatus))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("NotifyCreateQueue:notification prop request failed Q:%lx QM:%lx"), pQueueInfoRequest->hrStatus, pQmInfoRequest->hrStatus));
        LogHR(pQueueInfoRequest->hrStatus, s_FN, 10);
        LogHR(pQmInfoRequest->hrStatus, s_FN, 11);
        return MQ_ERROR;
    }

    //
    // send notification only if owner QM not foreign
    //
    if (!(pQmInfoRequest->pPropVars[e_idxQmForeign].bVal))
    {
        //
        // send notification to owner QM
        //
        ASSERT( g_rgNotifyQmProps[ e_idxQmId] ==  PROPID_QM_MACHINE_ID);

        hr = BuildSendNotification(
                      pQmInfoRequest->pPropVars[e_idxQmId].puuid,
                      DS_UPDATE_CREATE,
                      pwcsPathName,
                      NULL /*pguidIdentifier*/,
                      pQueueInfoRequest->cProps,
                      pQueueInfoRequest->pPropIDs,
                      pQueueInfoRequest->pPropVars);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("NotifyCreateQueue:BuildSendNotification()=%lx"), hr));
            return LogHR(hr, s_FN, 20);
        }
    }

    return MQ_OK;
}


HRESULT NotifyDeleteQueue(IN const MQDS_OBJ_INFO_REQUEST * pQmInfoRequest,
                          IN LPCWSTR                       pwcsPathName,
                          IN const GUID *                  pguidIdentifier)
/*++

Routine Description:
    Sends a notification for the owner QM of the queue that was deleted

Arguments:
    pQmInfoRequest    - owner qm props as defined in g_rgNotifyQmProps
    pwcsPathName      - pathname of deleted queue
    pguidIdentifier   - guid of deleted queue (incase pwcsPathName is NULL)

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // bail if info requests failed
    //
    if (FAILED(pQmInfoRequest->hrStatus))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("NotifyDeleteQueue:notification prop request failed QM:%lx"), pQmInfoRequest->hrStatus));
        LogHR(pQmInfoRequest->hrStatus, s_FN, 30);
        return MQ_ERROR;
    }

    //
    // send notification only if owner QM not foreign
    //
    ASSERT( g_rgNotifyQmProps[ e_idxQmForeign] ==  PROPID_QM_FOREIGN);
    if (!(pQmInfoRequest->pPropVars[e_idxQmForeign].bVal))
    {
        //
        // Got to have 2 props, and the second prop MUST be PROPID_D_OBJTYPE
        // (used by pUpdate->GetObjectType() when it is a delete notification)
        // about the first prop - I'm not sure if it used at all by QM1.0, but
        // DS1.0 sent it to QM1.0, and we want to do the same.
        //
        static const PROPID rgPropIDs[] = {PROPID_D_SCOPE, PROPID_D_OBJTYPE};
        PROPVARIANT rgPropVars[ARRAY_SIZE(rgPropIDs)];
        rgPropVars[0].vt = VT_UI1;
        rgPropVars[0].bVal = ENTERPRISE_SCOPE;
        rgPropVars[1].vt = VT_UI1;
        rgPropVars[1].bVal = MQDS_QUEUE;

        //
        // send notification to owner QM
        //
        hr = BuildSendNotification(
                      pQmInfoRequest->pPropVars[e_idxQmId].puuid,
                      DS_UPDATE_DELETE,
                      pwcsPathName,
                      pguidIdentifier,
                      ARRAY_SIZE(rgPropIDs),
                      rgPropIDs,
                      rgPropVars);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("NotifyDeleteQueue:BuildSendNotification()=%lx"), hr));
            return LogHR(hr, s_FN, 40);
        }
    }

    return MQ_OK;
}


HRESULT NotifyUpdateObj(IN DWORD                         dwObjectType,
                        IN const MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,
                        IN LPCWSTR                       pwcsPathName,
                        IN const GUID *                  pguidIdentifier,
                        IN ULONG                         cUpdProps,    /*debug only*/
                        IN const PROPID *                rgUpdPropIDs, /*debug only*/
                        IN const PROPVARIANT *           rgUpdPropVars,
                        IN ULONG                         cNotifyProps,
                        IN const PROPID *                rgNotifyPropIDs,
                        IN const MQDS_NotifyTable *      rgNotifyPropTbl)
/*++

Routine Description:
    Sends a notification for the owner QM of the object that was updated.
    The notification props are given. Where to take their values (i.e. from the
    original update props or from the info request props) is determined by the given
    notification table.

Arguments:
    dwObjectType      - object type (queue, QM)
    pObjInfoRequest   - requested obj props
    pwcsPathName      - pathname of updated obj
    pguidIdentifier   - guid of updated obj (incase pwcsPathName is NULL)
    cUpdProps         - updated props (count)
    rgUpdPropIDs      - updated props (propids)
    rgUpdPropVars     - updated props (propvars)
    cNotifyProps      - notification props (count)
    cNotifyPropIDs    - notification props (propids)
    rgNotifyPropTbl   - notification props (value location)

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // bail if info requests failed
    //
    if (FAILED(pObjInfoRequest->hrStatus))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("NotifyUpdateObj:notification prop request failed: %lx"), pObjInfoRequest->hrStatus));
        LogHR(pObjInfoRequest->hrStatus, s_FN, 50);
        return MQ_ERROR;
    }

    //
    // exit if no properties for the notification
    //
    if (cNotifyProps == 0)
    {
        return MQ_OK;
    }

    //
    // we need to check whether the owner QM is foreign, and get an index
    // to the owner QM prop in the requested props
    //
    BOOL fQmForeign;
    ULONG idxQmId;
    switch(dwObjectType)
    {
    case MQDS_QUEUE:
        {
            //
            // we have the owner QM guid in the queue info request, and we go to the DS
            //
            static const PROPID rgPropIDs[] = {PROPID_QM_FOREIGN};
            CMQVariant varForeign;

            CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
            hr = DSCoreGetProps(
                        MQDS_MACHINE,          
                         NULL,    
                        pObjInfoRequest->pPropVars[e_idxQueueQmId].puuid,    
                        ARRAY_SIZE(rgPropIDs),
                        const_cast<PROPID *>(rgPropIDs), 
                        &requestDsServerInternal,
                        varForeign.CastToStruct());
            if (FAILED(hr))
            {
                DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("NotifyUpdateObj:DSCoreGetProps(foreign)=%lx"), hr));
                LogHR(hr, s_FN, 60);
                return MQ_ERROR;
            }

            fQmForeign = (varForeign.CastToStruct())->bVal;
        }
        idxQmId = e_idxQueueQmId; //index of QM id in queue info request
        break;

    case MQDS_MACHINE:
        //
        // we have the foreign property in the QM info request
        //
        fQmForeign = pObjInfoRequest->pPropVars[e_idxQmForeign].bVal;
        idxQmId = e_idxQmId;      //index of QM id in QM info request
        break;

    default:
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 70);
        break;
    }

    //
    // don't send notifications to foreign QM
    //
    if (fQmForeign)
    {
        return MQ_OK;
    }

    //
    // create notification prop values arrays and fill the values for the
    // notification props from the appropriate place
    //
    AP<PROPVARIANT> rgNotifyPropVars = new PROPVARIANT[cNotifyProps];
    for (ULONG ulTmp = 0; ulTmp < cNotifyProps; ulTmp++)
    {
        const MQDS_NotifyTable * pNotifyPropTbl = &rgNotifyPropTbl[ulTmp];
        const PROPVARIANT * pvarsArray;
        const PROPID * pidArray;
        ULONG cArray;

        //
        // the location of the value is in the notification table
        //
        switch (pNotifyPropTbl->wValueLocation)
        {

        case e_ValueInUpdProps:
            //
            // value is in original update props supplied by caller
            //
            pvarsArray = rgUpdPropVars;
            pidArray = rgUpdPropIDs;
            cArray = cUpdProps;
            break;

        case e_ValueInRequestProps:
            //
            // value is in props requested from the DS upon setting
            //
            pvarsArray = pObjInfoRequest->pPropVars;
            pidArray = pObjInfoRequest->pPropIDs;
            cArray = pObjInfoRequest->cProps;
            break;

        default:
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 80);
            break;
        }

        //
        // set the value in the notification propvar array from the appropriate array
        // the index of the value is in the notification table
        // we don't duplicate the new propvar, just use it as is,
        // consequently we don't need to clear it afterwards
        //
        ASSERT(pNotifyPropTbl->idxValue < cArray);
        ASSERT(rgNotifyPropIDs[ulTmp] == pidArray[pNotifyPropTbl->idxValue]);
        rgNotifyPropVars[ulTmp] = pvarsArray[pNotifyPropTbl->idxValue];
    }

    //
    // send notification to owner QM
    //
    hr = BuildSendNotification(
                      pObjInfoRequest->pPropVars[idxQmId].puuid,    
                      DS_UPDATE_SET,
                      pwcsPathName,
                      pguidIdentifier,
                      cNotifyProps,
                      rgNotifyPropIDs,
                      rgNotifyPropVars);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("NotifyUpdateObj:BuildSendNotification()=%lx"), hr));
        return LogHR(hr, s_FN, 90);
    }

    return MQ_OK;
}


static
ULONG
DscpPrivateGuidToFormatName(
    const GUID* pg,
	ULONG Uniquifier,
    ULONG buff_size,
    LPWSTR pfn
    )
/*++

Routine Description:
    Convert a guid to private FormatName.

Arguments:
    pg - pointer to guid
    Uniquifier - 
    buff_size - pfn max size
    pfn - pointer to buffer

Return Value:
    pfn length.

--*/
{
    _snwprintf(
        pfn,
        buff_size,
        FN_PRIVATE_TOKEN        // "PRIVATE"
        FN_EQUAL_SIGN           // "="
        GUID_FORMAT             // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        FN_PRIVATE_SEPERATOR    // "\\"
        FN_PRIVATE_ID_FORMAT,      // "xxxxxxxx"
        GUID_ELEMENTS(pg),
        Uniquifier
        );
    
    //
    //  return format name buffer length *not* including suffix length
    //  "PRIVATE=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\\xxxxxxxx\0"
    //
    return (
        FN_PRIVATE_TOKEN_LEN + 1 + 
        GUID_STR_LENGTH + 1 + 8 + 1
        );
} // DscpPrivateGuidToFormatName


STATIC HRESULT BuildSendNotification(
                      IN GUID*               pguidDestinationQmId,
                      IN unsigned char       ucOperation,
                      IN LPCWSTR             pwcsPathName,
                      IN const GUID*         pguidIdentifier,
                      IN ULONG               cProps,
                      IN const PROPID *      rgPropIDs,
                      IN const PROPVARIANT * rgPropVars)
/*++

Routine Description:
    Sends a notification for destination QM

Arguments:
    pguidDestinationQmId - guid of destination QM
    ucOperation          - operation (create, delete, etc)
    pwcsPathName         - pathname of object
    pguidIdentifier      - guid of object (incase pwcsPathName is NULL)
    cProps               - notification props (count)
    rgPropIDs            - notification props (propids)
    rgPropVars           - notification props (propvars)

Return Value:
    HRESULT

--*/
{
	HRESULT hr;
    CDSBaseUpdate cUpdate;
    CSeqNum snSmallestValue;    // dummy
    GUID guidNULL = GUID_NULL;

    if (pwcsPathName)
    {
        hr = cUpdate.Init(
                        &guidNULL,             // not applicable
                        snSmallestValue,       // not applicable
                        snSmallestValue,       // not applicable
                        snSmallestValue,       // not applicable
                        FALSE,                 // not applicable
                        ucOperation,
                        UPDATE_NO_COPY_NO_DELETE,   // the Update class will be deleted here, before data expires
                        const_cast<LPWSTR>(pwcsPathName),
                        cProps,
                        const_cast<PROPID *>(rgPropIDs),
                        const_cast<PROPVARIANT *>(rgPropVars));
    }
    else
    {
        hr = cUpdate.Init(
                        &guidNULL,             // not applicable
                        snSmallestValue,       // not applicable
                        snSmallestValue,       // not applicable
                        snSmallestValue,       // not applicable
                        FALSE,                 // not applicable
                        ucOperation,
                        UPDATE_NO_COPY_NO_DELETE,   // the Update class will be deleted here, before data expires
                        pguidIdentifier,
                        cProps,
                        const_cast<PROPID *>(rgPropIDs),
                        const_cast<PROPVARIANT *>(rgPropVars));
    }
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("BuildSendNotification:cUpdate.Init()=%lx"), hr));
        return LogHR(hr, s_FN, 100);
    }

    //
    //  Prepare the packet
    //  Currently it contains one notification only
    //
    DWORD size, tmpSize;
    size = sizeof(CNotificationHeader);
    hr = cUpdate.GetSerializeSize(&tmpSize);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("BuildSendNotification:cUpdate.GetSerializeSize()=%lx"), hr));
        return LogHR(hr, s_FN, 110);
    }

    size += tmpSize;
    AP<unsigned char> pBuffer = new unsigned char[size];
    CNotificationHeader * pNotificationHeader = (CNotificationHeader *)( unsigned char *)pBuffer;
    pNotificationHeader->SetVersion( DS_NOTIFICATION_MSG_VERSION);
    pNotificationHeader->SetNoOfNotifications(1);
    hr = cUpdate.Serialize(pNotificationHeader->GetPtrToData(), &tmpSize, FALSE);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("BuildSendNotification:cUpdate.Serialize()=%lx"), hr));
        return LogHR(hr, s_FN, 120);
    }

    //
    //  send the message
    //

    handle_t hBind = NULL;
    hr = GetRpcClientHandle(&hBind);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 125);   // MQ_E_GET_RPC_HANDLE
    }
    ASSERT(hBind);

	//
	// Convert the guid to format name
	//
	WCHAR lpwszDestination[128];
	ULONG ulDestinationNameLen = sizeof(lpwszDestination)/sizeof(WCHAR);

	ulDestinationNameLen = DscpPrivateGuidToFormatName(
								 pguidDestinationQmId,
								 NOTIFICATION_QUEUE_ID,
 								 ulDestinationNameLen,
								 lpwszDestination
								 );
	hr = QMRpcSendMsg(
				hBind,
				lpwszDestination, // &QueueFormat
				size,
				pBuffer,
				x_dwDS_NOTIFICATION_MSG_TIMEOUT,
				MQMSG_ACKNOWLEDGMENT_NONE,
				x_bDS_NOTIFICATION_MSG_PRIORITY,
				NULL		// RespQueue 
				);

    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("BuildSendNotification:QMSendPacket()=%lx"), hr));
        return LogHR(hr, s_FN, 130);
    }
    
    return MQ_OK;
}


HRESULT RetreiveQueueInstanceFromNotificationInfo(
                          IN  const MQDS_OBJ_INFO_REQUEST * pQueueInfoRequest,
                          IN  ULONG                         idxQueueGuid,
                          OUT GUID *                        pguidObject)
/*++

Routine Description:
    Fill the queue's instance

Arguments:
    pQueueInfoRequest - queue props as defined in g_rgNotifyUpdateQueueProps
    idxQueueGuid      - index of PROPID_Q_INSTANCE in above info request
    pguidObject       - place to fill in he queue's instance

Return Value:
    HRESULT

--*/
{
    ASSERT(pQueueInfoRequest->pPropIDs[idxQueueGuid] == PROPID_Q_INSTANCE);
    //
    // bail if info requests failed
    //
    if (FAILED(pQueueInfoRequest->hrStatus))
    {
        LogHR(pQueueInfoRequest->hrStatus, s_FN, 140);
        return MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }
    *pguidObject = *pQueueInfoRequest->pPropVars[idxQueueGuid].puuid;
    return MQ_OK;
}


HRESULT RetreiveObjectIdFromNotificationInfo(
                          IN  const MQDS_OBJ_INFO_REQUEST * pObjectInfoRequest,
                          IN  ULONG                         idxObjectGuid,
                          OUT GUID *                        pguidObject)
/*++

Routine Description:
    Fill the object's instance

Arguments:
    pObjectInfoRequest - object props 
    idxObjectGuid      - index of object's unique id property in above info request
    pguidObject        - place to fill in he queue's instance

Return Value:
    HRESULT

--*/
{
    //
    // bail if info requests failed
    //
    if (FAILED(pObjectInfoRequest->hrStatus))
    {
        LogHR(pObjectInfoRequest->hrStatus, s_FN, 150);
        return MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }
    *pguidObject = *pObjectInfoRequest->pPropVars[idxObjectGuid].puuid;
    return MQ_OK;
}


HRESULT GetNotifyUpdateObjProps(IN DWORD dwObjectType,
                                IN ULONG cUpdProps,
                                IN const PROPID * rgUpdPropIDs,
                                OUT ULONG * pcObjRequestProps,
                                OUT PROPID ** prgObjRequestPropIDs,
                                OUT ULONG * pcNotifyProps,
                                OUT PROPID ** prgNotifyPropIDs,
                                OUT MQDS_NotifyTable ** prgNotifyPropTbl)
/*++

Routine Description:
    returns the props that should be requested for the object upon setting, the props
    that should be notified to the owner QM, and a notification table that for each
    notification prop describes from where to take the value to notify, whether from
    the original update props, or from the requested-upon-setting props

Arguments:
    dwObjectType          - object type (queue, QM)
    cUpdProps             - props to set (count)
    rgUpdPropIDs          - props to set (propids)
    pcObjRequestProps     - props to request back upon set (count)
    prgObjRequestPropIDs  - props to request back upon set (propids)
    pcNotifyProps         - notification props (count)
    pcNotifyPropIDs       - notification props (propids)
    prgNotifyPropTbl      - notification props (value location)

Return Value:
    HRESULT

--*/
{
    const PROPID * pMustRequestProps;
    ULONG cMustRequestProps;

    switch (dwObjectType)
    {
    case MQDS_QUEUE:
        pMustRequestProps = x_rgNotifyUpdateQueueProps;
        cMustRequestProps = x_cNotifyUpdateQueueProps;
        break;
    case MQDS_MACHINE:
        pMustRequestProps = g_rgNotifyQmProps;
        cMustRequestProps = g_cNotifyQmProps;
        break;
    default:
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 160);
        break;
    }

    //
    // init requested props. The must props have to be there,
    // we need to keep place for the replacing props as well, and the worst
    // case is that all of the update props need to be replaced.
    //
    AP<PROPID> rgObjRequestPropIDs = new PROPID [cMustRequestProps + cUpdProps];

    //
    // first copy must request props
    //
    memcpy((PROPID *)rgObjRequestPropIDs, pMustRequestProps, sizeof(PROPID)*cMustRequestProps);
    ULONG cObjRequestProps = cMustRequestProps;

    //
    // init notification props. the worst case is that all of the update props
    // or their replacements need to be notified.
    //
    AP<PROPID> rgNotifyPropIDs = new PROPID [cUpdProps];
    AP<MQDS_NotifyTable> rgNotifyPropTbl = new MQDS_NotifyTable [cUpdProps];
    ULONG cNotifyProps = 0;

    //
    // loop over the update props. for each property find out how to notify
    // it to QM1.0
    //
    for (ULONG ulTmp = 0; ulTmp < cUpdProps; ulTmp++)
    {
        //
        // find translation info for the property
        //
        const MQTranslateInfo *pTranslate;
        if(!g_PropDictionary.Lookup(rgUpdPropIDs[ulTmp], pTranslate))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 170);
        }

        //
        // check how to notify to QM1.0
        //
        switch(pTranslate->wQM1Action)
        {
        
        case e_NOTIFY_WRITEREQ_QM1_AS_IS:
            //
            // notify property as is
            // add the property to the notification props
            // value should be taken from the UPDATE props
            //
            rgNotifyPropIDs[cNotifyProps] = rgUpdPropIDs[ulTmp];
            rgNotifyPropTbl[cNotifyProps].wValueLocation = e_ValueInUpdProps;
            rgNotifyPropTbl[cNotifyProps].idxValue = ulTmp;
            cNotifyProps++;
            break;

        case e_NOTIFY_WRITEREQ_QM1_REPLACE:
            {
                //
                // add the REPLACING property to the notification props
                // value should be taken from the REQUEST props
                //
                ASSERT(pTranslate->propidReplaceNotifyQM1 != 0);
                //
                // check that we don't have the replacing property already in the notification props.
                // this is when several NT5 props map to the same NT4 prop (like in QM_SERVICE)
                //
                BOOL fReplacingPropNotFoundYet = TRUE;
                for (ULONG ulTmp1 = 0; (ulTmp1 < cNotifyProps) && fReplacingPropNotFoundYet; ulTmp1++)
                {
                    if (rgNotifyPropIDs[ulTmp1] == pTranslate->propidReplaceNotifyQM1)
                    {
                        //
                        // the replacing prop is already in the notification props, exit loop.
                        //
                        fReplacingPropNotFoundYet = FALSE;
                    }
                }

                //
                // add the replacing property to the notification props only if it wasn't there already
                //
                if (fReplacingPropNotFoundYet)
                {
                    rgNotifyPropIDs[cNotifyProps] = pTranslate->propidReplaceNotifyQM1;
                    rgNotifyPropTbl[cNotifyProps].wValueLocation = e_ValueInRequestProps;
                    rgNotifyPropTbl[cNotifyProps].idxValue = cObjRequestProps;
                    cNotifyProps++;
                    //
                    // request the replacing property upon setting
                    //
                    rgObjRequestPropIDs[cObjRequestProps] = pTranslate->propidReplaceNotifyQM1;
                    cObjRequestProps++;
                }
            }
            break;

        case e_NO_NOTIFY_NO_WRITEREQ_QM1:
        case e_NO_NOTIFY_ERROR_WRITEREQ_QM1:
            //
            // ignore this property
            //
            break;

        default:
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 180);
            break;
        }
    }

    //
    // return values
    //
    *pcObjRequestProps = cObjRequestProps;
    *prgObjRequestPropIDs = rgObjRequestPropIDs.detach();
    *pcNotifyProps = cNotifyProps;
    *prgNotifyPropIDs = rgNotifyPropIDs.detach();
    *prgNotifyPropTbl = rgNotifyPropTbl.detach();
    return MQ_OK;
}


HRESULT ConvertToNT4Props(ULONG cProps,
                          const PROPID * rgPropIDs,
                          const PROPVARIANT * rgPropVars,
                          ULONG * pcNT4Props,
                          PROPID ** prgNT4PropIDs,
                          PROPVARIANT ** prgNT4PropVars)
/*++

Routine Description:
    replaces NT5 props with the corresponding NT4 props (if possible) and removes
    NT5 specific props that don't have NT4 match.

Arguments:
    cProps               - given props (count)
    rgPropIDs            - given props (propids)
    rgPropVars           - given props (propvars)
    pcNT4CreateProps     - returned NT4 props (count)
    prgNT4CreatePropIDs  - returned NT4 props (propids)
    prgNT4CreatePropVars - returned NT4 props (propvars)

Return Value:
    HRESULT

--*/
{
    HRESULT hr;
    //
    // Alloc place for converted NT4 props with propvar release
    //
    CAutoCleanPropvarArray cCleanNT4Props;
    PROPVARIANT * rgNT4PropVars = cCleanNT4Props.allocClean(cProps);
    AP<PROPID> rgNT4PropIDs = new PROPID[cProps];
    ULONG cNT4Props = 0;

    //
    // Init replacing props. Since there are situations where several NT5 props can map
    // to the same NT4 prop (like in QM_SERVICE) we make sure only one replacing prop is
    // generated.
    //
    AP<PROPID> rgReplacingPropIDs = new PROPID[cProps];
    ULONG cReplacingProps = 0;
    
    for (ULONG ulProp = 0; ulProp < cProps; ulProp++)
    {
        //
        // Get property info
        //
        const MQTranslateInfo *pTranslate;
        if(!g_PropDictionary.Lookup(rgPropIDs[ulProp], pTranslate))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 190);
        }

        //
        // Check what we need to do with this property
        //
        switch (pTranslate->wQM1Action)
        {
        case e_NOTIFY_WRITEREQ_QM1_REPLACE:
            //
            // it is NT5 only property which has a similar property in NT4
            // Convert it to NT4 property (may lose information on the way)
            //
            {
                ASSERT(pTranslate->propidReplaceNotifyQM1 != 0);
                ASSERT(pTranslate->QM1SetPropertyHandle);

                //
                // check that we didn't generate the replacing property already.
                // this is when several NT5 props map to the same NT4 prop (like in QM_SERVICE)
                //
                BOOL fReplacingPropNotFoundYet = TRUE;
                for (ULONG ulTmp = 0; (ulTmp < cReplacingProps) && fReplacingPropNotFoundYet; ulTmp++)
                {
                    if (rgReplacingPropIDs[ulTmp] == pTranslate->propidReplaceNotifyQM1)
                    {
                        //
                        // the replacing prop is already in the notification props, exit loop.
                        //
                        fReplacingPropNotFoundYet = FALSE;
                    }
                }

                //
                // generate replacing property if not generated yet
                //
                if (fReplacingPropNotFoundYet)
                {
                    if (pTranslate->QM1SetPropertyHandle)
                    {
                        hr = pTranslate->QM1SetPropertyHandle(cProps,
                                                              rgPropIDs,
                                                              rgPropVars,
                                                              ulProp,
                                                              &rgNT4PropVars[cNT4Props]);
                        if (FAILED(hr))
                        {
                            DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("ConvertToNT4Props:pTranslate->ConvertToQM1Handle(%lx)=%lx"), rgPropIDs[ulProp], hr));
                            return LogHR(hr, s_FN, 200);
                        }
                        rgNT4PropIDs[cNT4Props] = pTranslate->propidReplaceNotifyQM1;
                        //
                        // increment NT4 props
                        //
                        cNT4Props++;

                        //
                        // mark that the replacing property was already generated
                        //
                        rgReplacingPropIDs[cReplacingProps] = pTranslate->propidReplaceNotifyQM1; 
                        cReplacingProps++;
                    }
                }
            }
            break;

        case e_NOTIFY_WRITEREQ_QM1_AS_IS:
            {
                //
                // it is a property that NT4 understands.
                // duplicate the property into auto release propvar
                //
                CMQVariant varTmp(rgPropVars[ulProp]);
                //
                // put it in the propvars array, and detach the auto release propvar
                //
                rgNT4PropVars[cNT4Props] = *(varTmp.CastToStruct());
                varTmp.CastToStruct()->vt = VT_EMPTY;
                //
                // copy the propid
                //
                rgNT4PropIDs[cNT4Props] = rgPropIDs[ulProp];
                //
                // increment NT4 props
                //
                cNT4Props++;
            }
            break;

        case e_NO_NOTIFY_NO_WRITEREQ_QM1:
            //
            // it is a dummy property, ignore it
            //
            break;

        case e_NO_NOTIFY_ERROR_WRITEREQ_QM1:
            //
            // it is NT5 only property, we cannot put it in a write request
            // so we generate an error
            //
            return LogHR(MQ_ERROR, s_FN, 210); //BUGBUG: we need to have a better error code
            break;

        default:
            ASSERT(0);
            break;
        }
    }

    //
    // return values
    //
    *pcNT4Props = cNT4Props;
    if (cNT4Props > 0)
    {
        *prgNT4PropIDs = rgNT4PropIDs.detach();
        *prgNT4PropVars = rgNT4PropVars;
        cCleanNT4Props.detach();
    }
    else
    {
        *prgNT4PropIDs = NULL;
        *prgNT4PropVars = NULL;
    }
    return MQ_OK;
}


PROPVARIANT * FindPropInArray(PROPID propid,
                              ULONG cProps,
                              const PROPID * rgPropIDs,
                              PROPVARIANT * rgPropVars)
/*++

Routine Description:
    finds a value for a property in given props.

Arguments:
    propid - propid to search
    cProps               - given props (count)
    rgPropIDs            - given props (propids)
    rgPropVars           - given props (propvars)

Return Value:
    If property was found - a pointer to its value
    otherwise - NULL

--*/
{
    for (ULONG ulProp = 0; ulProp < cProps; ulProp++)
    {
        if (rgPropIDs[ulProp] == propid)
        {
            return (&rgPropVars[ulProp]);
        }
    }
    return NULL;
}


HRESULT GetNT4CreateQueueProps(ULONG cProps,
                               const PROPID * rgPropIDs,
                               const PROPVARIANT * rgPropVars,
                               ULONG * pcNT4CreateProps,
                               PROPID ** prgNT4CreatePropIDs,
                               PROPVARIANT ** prgNT4CreatePropVars)
/*++

Routine Description:
    Gets create-queue props (might contain QM2.0 props), and returns props suitable
    for create-queue-write-request to an NT4 PSC.
    It replaces NT5 props with the corresponding NT4 props (if possible), removes
    NT5 specific props that don't have NT4 match, and adds default values to props
    that are needed and not supplied (in NT5 we put in the DS only values that are
    not default)

Arguments:
    cProps               - given create-queue props (count)
    rgPropIDs            - given create-queue props (propids)
    rgPropVars           - given create-queue props (propvars)
    pcNT4CreateProps     - returned NT4 create-queue props (count)
    prgNT4CreatePropIDs  - returned NT4 create-queue props (propids)
    prgNT4CreatePropVars - returned NT4 create-queue props (propvars)

Return Value:
    HRESULT

--*/
{
    //
    // Convert given props to NT4 props
    //
    ULONG cNT4Props;
    AP<PROPID> rgNT4PropIDs;
    PROPVARIANT * rgNT4PropVars;
    HRESULT hr = ConvertToNT4Props(cProps,
                                   rgPropIDs,
                                   rgPropVars,
                                   &cNT4Props,
                                   &rgNT4PropIDs,
                                   &rgNT4PropVars);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("GetNT4CreateQueueProps:ConvertToNT4Props()=%lx"), hr));
        return LogHR(hr, s_FN, 220);
    }
    //
    // remember to free converted NT4 props
    //
    CAutoCleanPropvarArray cCleanNT4Props;
    cCleanNT4Props.attach(cNT4Props, rgNT4PropVars);

    //
    // alloc new propvars, the size of the create queue write request props
    //
    CAutoCleanPropvarArray cCleanNT4CreateProps;
    PROPVARIANT * rgNT4CreatePropVars = cCleanNT4CreateProps.allocClean(x_cWritereqCreateQueueProps);
    AP<PROPID> rgNT4CreatePropIDs = new PROPID[x_cWritereqCreateQueueProps];
    ULONG cNT4CreateProps = 0;

    //
    // fill the create queue propvars
    //
    time_t tCurTime = time(NULL);
    PROPVARIANT * pNT4CreatePropVar = rgNT4CreatePropVars;
    for (ULONG ulTmp = 0; ulTmp < x_cWritereqCreateQueueProps; ulTmp++)
    {
        PROPID propid = x_rgWritereqCreateQueueProps[ulTmp];
        BOOL fPropIsFilled = FALSE;

        //
        // fill prop
        //
        switch(propid)
        {
        case PROPID_Q_INSTANCE:
            {
                //
                // for PROPID_Q_INSTANCE we get a new GUID
                //
                pNT4CreatePropVar->puuid = new GUID;
                pNT4CreatePropVar->vt = VT_CLSID;
                RPC_STATUS rpcstat = UuidCreate(pNT4CreatePropVar->puuid);
                if (rpcstat != RPC_S_OK)
                {
                    DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Failed to create queue UUID, UuidCreate=%lx"), (DWORD)rpcstat));
                    LogRPCStatus(rpcstat, s_FN, 230);
                    return MQ_ERROR;
                }
                fPropIsFilled = TRUE;
            }
            break;

        case PROPID_Q_CREATE_TIME:
        case PROPID_Q_MODIFY_TIME:
            //
            // set current time
            //
            pNT4CreatePropVar->lVal = INT_PTR_TO_INT(tCurTime); //BUGBUG bug year 2038
            pNT4CreatePropVar->vt = VT_I4;
            fPropIsFilled = TRUE;
            break;
        
        case PROPID_Q_SCOPE:
            //
            // set to enterprise scope
            // IMPORTANT, without using this property in the write request, the queue
            // on MSMQ 1.0 PSC will not replicate.
            // somehow this property is still used in MSMQ 1.0 PSC replication even
            // though it should have been disabled there.
            //
            pNT4CreatePropVar->bVal = ENTERPRISE_SCOPE;
            pNT4CreatePropVar->vt = VT_UI1;
            fPropIsFilled = TRUE;
            break;

        default:
            {
                //
                // not a special prop, use the given property if exists, or a default value
                //
                PROPVARIANT * pNT4PropVar = FindPropInArray(propid,
                                                        cNT4Props,
                                                        rgNT4PropIDs,
                                                        rgNT4PropVars);
                if (pNT4PropVar)
                {
                    //
                    // we have the property in the converted props. Since the converted
                    // props are temporary, we use it w/o allocating, and nullify the temporary
                    // converted prop.
                    //
                    *pNT4CreatePropVar = *pNT4PropVar;
                    pNT4PropVar->vt = VT_EMPTY;
                    fPropIsFilled = TRUE;
                }
                else
                {
                    //
                    // property was not supplied. We check if we have a default value for it
                    // Get property info
                    //
                    const MQTranslateInfo *pTranslate;
                    if(!g_PropDictionary.Lookup(propid, pTranslate))
                    {
                        ASSERT(0);
                        return LogHR(MQ_ERROR, s_FN, 240);
                    }
                    if (pTranslate->pvarDefaultValue)
                    {
                        //
                        // we have a default value, duplicate it
                        //
                        CMQVariant varTmp(*pTranslate->pvarDefaultValue);
                        *pNT4CreatePropVar = *(varTmp.CastToStruct());
                        varTmp.CastToStruct()->vt = VT_EMPTY;
                        fPropIsFilled = TRUE;
                    }
                    else
                    {
                        //
                        // the property was not given, and no default value.
                        // ignore this property.
                        //
                        ASSERT(0);
                        //return LogHR(MQ_ERROR, s_FN, 250);
                    }
                }
            }
            break;
        }

        //
        // finish handling the property
        //
        if (fPropIsFilled)
        {
            pNT4CreatePropVar++;
            rgNT4CreatePropIDs[cNT4CreateProps] = propid;
            cNT4CreateProps++;
        }
    }

    //
    // return results
    //
    *pcNT4CreateProps = cNT4CreateProps;
    if (cNT4CreateProps > 0)
    {
        *prgNT4CreatePropIDs = rgNT4CreatePropIDs.detach();
        *prgNT4CreatePropVars = rgNT4CreatePropVars;
        cCleanNT4CreateProps.detach();
    }
    else
    {
        *prgNT4CreatePropIDs = NULL;
        *prgNT4CreatePropVars = NULL;
    }
    return MQ_OK;
}


void GetThisMqDsInfo(GUID * pguidSiteId,
                     LPWSTR * ppwszServerName)
/*++

Routine Description:
    returns information about this MSMQ DS

Arguments:
    pguidSiteId     - returned site id of this DS
    ppwszServerName - returned server name

Return Value:
    None

--*/
{
    const GUID * pguid = g_pMySiteInformation->GetSiteId();
    ASSERT(pguid);
    *pguidSiteId = *pguid;

    ASSERT(g_pwcsServerName);
    AP<WCHAR> pwszServerName = new WCHAR[1 + g_dwServerNameLength];
    wcscpy(pwszServerName, g_pwcsServerName);
    *ppwszServerName = pwszServerName.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\reqparse.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
	reqparse.cpp

Abstract:
	Parser of DS locate requests
	
	Each request is handled separtly
Author:

    Ronit Hartmann (ronith)

--*/
#include "ds_stdh.h"
#include "mqads.h"
#include "dsads.h"
#include "hquery.h"
#include "mqadsp.h"
#include "coreglb.h"

#include "reqparse.tmh"

static WCHAR *s_FN=L"mqdscore/reqparse";

/*====================================================


QueryLinks()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryLinks( 
                 IN  LPWSTR         /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET*     /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    HRESULT hr;
    *pHandle = NULL;

    ASSERT( pRestriction->cRes == 1);
    ASSERT( (pRestriction->paPropRes[0].prop == PROPID_L_NEIGHBOR1) ||
            (pRestriction->paPropRes[0].prop == PROPID_L_NEIGHBOR2));

    //
    //  Translate the site-id to the site DN
    //
    PROPID prop = PROPID_S_FULL_NAME;

    PROPVARIANT var;
    var.vt = VT_NULL;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = g_pDS->GetObjectProperties(
                eLocalDomainController,		        // local DC or GC
                &requestDsServerInternal,
 	            NULL,                               // object name
                pRestriction->paPropRes[0].prval.puuid,  
                1,                                  // number of attributes to retreive
                &prop,                              // attributes to retreive
                &var);                              // output variant array
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    AP<WCHAR> pClean = var.pwszVal;
    //
    //  Prepare a query according to the neighbor DN
    //
    MQRESTRICTION restriction;
    restriction.cRes = 1;

    MQPROPERTYRESTRICTION proprstr;
    proprstr.rel = PREQ;
    proprstr.prop = (pRestriction->paPropRes[0].prop == PROPID_L_NEIGHBOR1) ?
                    PROPID_L_NEIGHBOR1_DN : PROPID_L_NEIGHBOR2_DN;
    proprstr.prval.vt = VT_LPWSTR;
    proprstr.prval.pwszVal = var.pwszVal;
    restriction.paPropRes = &proprstr;

    //
    //  Locate all the links
    //  
    HANDLE hCursor;

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eLocalDomainController,	
            pRequestContext,
            NULL,
            &restriction,
            NULL,
            pColumns->cCol,    // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CFilterLinkResultsHandle * phQuery = new CFilterLinkResultsHandle(
                                                hCursor,
                                                pColumns,
                                                pRequestContext->GetRequesterProtocol()
                                                );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 20);
}


/*====================================================


QueryMachineQueues()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryMachineQueues( 
                 IN  LPWSTR         /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET*     /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    HRESULT hr;
    *pHandle = NULL;
    //
    //  Get the name of the machine
    //
    //  PROPID_Q_QMID is the unique id of machine\msmq-computer-configuration
    //
    ASSERT( pRestriction->cRes == 1);
    ASSERT( pRestriction->paPropRes[0].prop == PROPID_Q_QMID);

    //
    //  Locate all the queues of that machine under the msmq-configuration
    //  
    HANDLE hCursor;

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eSpecificObjectInGlobalCatalog,
            pRequestContext, 
            pRestriction->paPropRes[0].prval.puuid,
            NULL,
            NULL,
            pColumns->cCol,    // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CQueryHandle * phQuery = new CQueryHandle( hCursor,
                                                   pColumns->cCol,
                                                   pRequestContext->GetRequesterProtocol()
                                                   );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 30);
}
/*====================================================


QuerySiteName()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QuerySiteName( 
                 IN  LPWSTR         /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET *    /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    HRESULT hr;
    *pHandle = NULL;
    //
    //  Get the name of a site
    //
    ASSERT( pRestriction->cRes == 1);
    ASSERT( pRestriction->paPropRes[0].prop == PROPID_S_SITEID);


    //
    //  Query the site name, even though we know its unique id
    //  
    HANDLE hCursor;

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eLocalDomainController,
            pRequestContext,
            NULL,
            pRestriction,	// search criteria
            NULL,
            pColumns->cCol,    // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CQueryHandle * phQuery = new CQueryHandle(hCursor,
                                                  pColumns->cCol,
                                                  pRequestContext->GetRequesterProtocol()
                                                    );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 40);
}

/*====================================================


QueryForeignSites()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryForeignSites( 
                 IN  LPWSTR         /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET *    /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    HRESULT hr;
    *pHandle = NULL;
    //
    //  Get the name of a site
    //
    ASSERT( pRestriction->cRes == 1);
    ASSERT( pRestriction->paPropRes[0].prop == PROPID_S_FOREIGN);


    //
    //  Query all foreign sites
    //  
    HANDLE hCursor;

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eLocalDomainController,
            pRequestContext,
            NULL,
            pRestriction,	// search criteria
            NULL,
            pColumns->cCol,    // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CQueryHandle * phQuery = new CQueryHandle(hCursor,
                                                  pColumns->cCol,
                                                  pRequestContext->GetRequesterProtocol()
                                                    );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 50);
}

/*====================================================


QuerySiteLinks()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QuerySiteLinks( 
                 IN  LPWSTR         /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET *    /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    ASSERT( pRestriction == NULL);
    UNREFERENCED_PARAMETER( pRestriction);

    HRESULT hr;
    *pHandle = NULL;
    //
    //  Retrieve all site-links
    //
    //
    //  All the site-links are under the MSMQ-service container
    //  
    HANDLE hCursor;

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eLocalDomainController,
            pRequestContext,
            NULL,
            NULL,
            NULL,
            pColumns->cCol,    // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CFilterLinkResultsHandle * phQuery = new CFilterLinkResultsHandle(
                                                  hCursor,
                                                  pColumns,
                                                  pRequestContext->GetRequesterProtocol()
                                                  );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 60);
}
/*====================================================


QueryEntepriseName()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryEntepriseName( 
                 IN  LPWSTR          /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET *    /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    HRESULT hr;
    *pHandle = NULL;
    //
    //  Retrieve all site-links
    //
    ASSERT( pRestriction == NULL);
    UNREFERENCED_PARAMETER( pRestriction);
    //
    //  All the site-links are under the MSMQ-service container
    //  
    HANDLE hCursor;

    hr = g_pDS->LocateBegin( 
            eOneLevel,
            eLocalDomainController,
            pRequestContext,
            NULL,
            NULL,
            NULL,
            pColumns->cCol,    // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CQueryHandle * phQuery = new CQueryHandle(hCursor,
                                                  pColumns->cCol,
                                                  pRequestContext->GetRequesterProtocol()
                                                    );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 70);
}


/*====================================================


QuerySites()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QuerySites( 
                 IN  LPWSTR         pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{

    ASSERT( pwcsContext == NULL);
    ASSERT( pRestriction == NULL);
    ASSERT( pSort == NULL);
    UNREFERENCED_PARAMETER( pSort);
    UNREFERENCED_PARAMETER( pRestriction);
    UNREFERENCED_PARAMETER( pwcsContext);

    //
    //  Need to find all the sites 
    //

    HANDLE hCursor;
    PROPID prop[2] = { PROPID_S_SITEID, PROPID_S_PATHNAME};
    HRESULT hr;
    

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eLocalDomainController,
            pRequestContext,
            NULL, 
            NULL,
            NULL,
            2,    // attributes to be obtained
            prop, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CSiteQueryHandle * phQuery = new CSiteQueryHandle(
                                                hCursor,
                                                pColumns,
                                                pRequestContext->GetRequesterProtocol()
                                                );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 80);
}

/*====================================================


QueryCNs()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryCNs( 
                 IN  LPWSTR         pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    ASSERT( pwcsContext == NULL);
    ASSERT( pRestriction == NULL);
    ASSERT( pSort == NULL);
    UNREFERENCED_PARAMETER( pSort);
    UNREFERENCED_PARAMETER( pRestriction);
    UNREFERENCED_PARAMETER( pwcsContext);
    ASSERT( pColumns->aCol[0] == PROPID_CN_PROTOCOLID);
    ASSERT( pColumns->aCol[1] == PROPID_CN_GUID);
    ASSERT( pColumns->cCol == 2);

    //
    //  Each non-foreign site will be returned as IP CN.
    //  
    HANDLE hCursor;
    PROPID prop[2] = { PROPID_S_SITEID, PROPID_S_FOREIGN};
    HRESULT hr;
    

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eLocalDomainController,
            pRequestContext,
            NULL, 
            NULL,
            NULL,
            2,    // attributes to be obtained
            prop, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
       CCNsQueryHandle * phQuery = new CCNsQueryHandle(
                                                  hCursor,
                                                  pColumns,
                                                  pRequestContext->GetRequesterProtocol()
                                                  );
        *pHandle = (HANDLE)phQuery;
    }
    return LogHR(hr, s_FN, 90);
}


/*====================================================


MqxploreQueryCNs()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MqxploreQueryCNs( 
                 IN  LPWSTR         pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    //
    //  Supporting MQXPLORE (MSMQ 1.0) CNs query
    //
    ASSERT( pwcsContext == NULL);
    ASSERT( pRestriction == NULL);
    ASSERT( pSort == NULL);
    UNREFERENCED_PARAMETER( pSort);
    UNREFERENCED_PARAMETER( pRestriction);
    UNREFERENCED_PARAMETER( pwcsContext);

	if (pColumns->cCol == 4)
	{
        //
        // this query is done by the mqxpore when it display the CN
        // folder. And yes, it asks for PROPID_CN_NAME twice.
        // That's a mqxplore bug, Ignore it.
        //
		ASSERT( pColumns->aCol[0] == PROPID_CN_NAME);
		ASSERT( pColumns->aCol[1] == PROPID_CN_NAME);
		ASSERT( pColumns->aCol[2] == PROPID_CN_GUID);
		ASSERT( pColumns->aCol[3] == PROPID_CN_PROTOCOLID);
    }
	else if (pColumns->cCol == 3)
	{
        //
        // This query is done when displaying the  the network tab of a
        // computer object in nt4 mqxplore or when trying to create a foreign
        // computer from mqxplore.
        //
        ASSERT( pColumns->aCol[0] == PROPID_CN_NAME);
        ASSERT( pColumns->aCol[1] == PROPID_CN_PROTOCOLID);
        ASSERT( pColumns->aCol[2] == PROPID_CN_GUID);
    }
    else
    {
        ASSERT(0) ;
    }

    //
    //  Each non-foreign site will be returned as IP CN.
    //  
    HANDLE hCursor;
    const DWORD xNumProps = 3;
    PROPID prop[xNumProps] = { PROPID_S_PATHNAME, PROPID_S_SITEID, PROPID_S_FOREIGN};
    HRESULT hr;
    

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eLocalDomainController,
            pRequestContext,
            NULL, 
            NULL,
            NULL,
            xNumProps,    // attributes to be obtained
            prop, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
       CMqxploreCNsQueryHandle * phQuery = new CMqxploreCNsQueryHandle(
                                                  hCursor,
                                                  pColumns,
                                                  pRequestContext->GetRequesterProtocol()
                                                  );
        *pHandle = (HANDLE)phQuery;
    }
    return LogHR(hr, s_FN, 100);
}
/*====================================================


QueryCNsProtocol()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryCNsProtocol( 
                 IN  LPWSTR         pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    ASSERT( pwcsContext == NULL);
    ASSERT( pSort == NULL);
    UNREFERENCED_PARAMETER( pSort);
    UNREFERENCED_PARAMETER( pwcsContext);
    ASSERT( pRestriction->paPropRes[0].prop == PROPID_CN_PROTOCOLID);
    UNREFERENCED_PARAMETER( pRestriction);

    ASSERT( pColumns->aCol[0] == PROPID_CN_NAME);
    ASSERT( pColumns->aCol[1] == PROPID_CN_GUID);
    ASSERT( pColumns->cCol == 2);


    //
    //  BUGBUG  : ignoring IPX 
    //  
    HANDLE hCursor;
    PROPID prop[3] = { PROPID_S_PATHNAME, PROPID_S_SITEID, PROPID_S_FOREIGN};
    HRESULT hr;
    

    hr = g_pDS->LocateBegin( 
            eOneLevel,	
            eLocalDomainController,
            pRequestContext,
            NULL, 
            NULL,
            NULL,
            3,    // attributes to be obtained
            prop, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
       CCNsProtocolQueryHandle * phQuery = new CCNsProtocolQueryHandle(
                                                  hCursor,
                                                  pColumns,
                                                  pRequestContext->GetRequesterProtocol()
                                                  );
        *pHandle = (HANDLE)phQuery;
    }
    return LogHR(hr, s_FN, 110);
}

/*====================================================


QueryUserCert()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryUserCert( 
                 IN  LPWSTR          /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET *    /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    HRESULT hr;
    *pHandle = NULL;
    //
    //  Get all the user certificates
    //  In NT5, a single attribute PROPID_U_SIGN_CERTIFICATE
    //  containes all the certificates
    //  
    PROPVARIANT varNT5User;
    hr = LocateUser(
				 FALSE,  // fOnlyLocally
				 FALSE,  // fOnlyInGC
                 pRestriction,
                 pColumns,
                 pRequestContext,    
                 &varNT5User
                 );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 120);
    }
    //
    //  Get all the user certificates of MQUser
    //  A single attribute PROPID_MQU_SIGN_CERTIFICATE
    //  containes all the certificates
    //  
    pRestriction->paPropRes[0].prop = PROPID_MQU_SID;
    switch(pColumns->aCol[0])
    {
        case PROPID_U_SIGN_CERT:
            pColumns->aCol[0] = PROPID_MQU_SIGN_CERT;
            break;
        case PROPID_U_DIGEST:
            pColumns->aCol[0] = PROPID_MQU_DIGEST;
            break;
        default:
            ASSERT(0);
            break;
    }

    PROPVARIANT varMqUser;
    hr = LocateUser(
				 FALSE,  // fOnlyLocally
				 FALSE,  // fOnlyInGC
                 pRestriction,
                 pColumns,
                 pRequestContext,    
                 &varMqUser
                 );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 130);
    }

    AP<BYTE> pClean = varNT5User.blob.pBlobData;
    AP<BYTE> pClean1 = varMqUser.blob.pBlobData;
    //
    // keep the result for lookup next
    //
    CUserCertQueryHandle * phQuery = new CUserCertQueryHandle(
                                              &varNT5User.blob,
                                              &varMqUser.blob,
                                              pRequestContext->GetRequesterProtocol()
                                              );
    *pHandle = (HANDLE)phQuery;
    
    return(MQ_OK);
}


/*====================================================


NullRestrictionParser()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI NullRestrictionParser( 
                 IN  LPWSTR         pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    ASSERT( pRestriction == NULL);
    HRESULT hr;
    //
    //  Identify the query according to the requested
    //  properties
    //
	//  IMPORTANT: if this switch is changed, then please update
	//    (if necessray) mqads\mqdsapi.cpp, LookupBegin(), to continue
	//     support of nt4 (ntlm) clients.
	//
    switch (pColumns->aCol[0])
    {
        case PROPID_L_NEIGHBOR1:
            hr = QuerySiteLinks(
                    pwcsContext,
                    pRestriction,
                    pColumns,
                    pSort,
                    pRequestContext,
                    pHandle);
            break;

        case PROPID_S_SITEID:
        case PROPID_S_PATHNAME:
            hr = QuerySites(
                    pwcsContext,
                    pRestriction,
                    pColumns,
                    pSort,
                    pRequestContext,
                    pHandle);
            break;

        case PROPID_CN_PROTOCOLID:
            hr = QueryCNs(
                    pwcsContext,
                    pRestriction,
                    pColumns,
                    pSort,
                    pRequestContext,
                    pHandle);
            break;

        case PROPID_CN_NAME:
            hr = MqxploreQueryCNs(
                    pwcsContext,
                    pRestriction,
                    pColumns,
                    pSort,
                    pRequestContext,
                    pHandle);
            break;

        case PROPID_E_NAME:
        case PROPID_E_ID:
		case PROPID_E_VERSION:
            hr = QueryEntepriseName(
                    pwcsContext,
                    pRestriction,
                    pColumns,
                    pSort,
                    pRequestContext,
                    pHandle);
            break;

        case PROPID_Q_INSTANCE:
        case PROPID_Q_TYPE:
        case PROPID_Q_PATHNAME:
        case PROPID_Q_JOURNAL:
        case PROPID_Q_QUOTA:
        case PROPID_Q_BASEPRIORITY:
        case PROPID_Q_JOURNAL_QUOTA:
        case PROPID_Q_LABEL:
        case PROPID_Q_CREATE_TIME:
        case PROPID_Q_MODIFY_TIME:
        case PROPID_Q_AUTHENTICATE:
        case PROPID_Q_PRIV_LEVEL:
        case PROPID_Q_TRANSACTION:
            {
                HANDLE hCursur;
                hr =  g_pDS->LocateBegin( 
                        eSubTree,
                        eGlobalCatalog,
                        pRequestContext,
                        NULL,      
                        pRestriction,   
                        pSort,
                        pColumns->cCol,                 
                        pColumns->aCol,           
                        &hCursur);
                if ( SUCCEEDED(hr))
                {
                    CQueryHandle * phQuery = new CQueryHandle( hCursur,
                                                               pColumns->cCol,
                                                               pRequestContext->GetRequesterProtocol()
                                                               );
                    *pHandle = (HANDLE)phQuery;
                }
            }
            break;

        default:
            hr = MQ_ERROR;
            ASSERT(0);
            break;
    }
    return LogHR(hr, s_FN, 140);
}
/*====================================================


QuerySiteFRSs()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QuerySiteFRSs( 
                 IN  LPWSTR          /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    *pHandle = NULL;

    ASSERT( pRestriction->paPropRes[0].prop == PROPID_QM_SERVICE);   //[adsrv] Not changing - because this comes from MSMQ1
    ASSERT( pRestriction->paPropRes[1].prop == PROPID_QM_SITE_ID);
    ASSERT( pSort == NULL);
    UNREFERENCED_PARAMETER( pSort);

    //
    //  Find all the FRSs under \configuration\Sites\MySite\servers  
    //
    HRESULT hr2 = MQADSpQuerySiteFRSs( 
                 pRestriction->paPropRes[1].prval.puuid,
                 pRestriction->paPropRes[0].prval.ulVal,
                 pRestriction->paPropRes[0].rel,
                 pColumns,
                 pRequestContext,
                 pHandle
                 );

    return LogHR(hr2, s_FN, 150);
}
/*====================================================


QueryConnectors()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryConnectors( 
                 IN  LPWSTR         pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    ASSERT( pSort == NULL);
    UNREFERENCED_PARAMETER( pSort);
    ASSERT( pwcsContext == NULL);
    UNREFERENCED_PARAMETER( pwcsContext);
    //
    //  In the restriction there is the list of the foreign
    //  machine's sites.
    //
    //  BUGBUG - the code handles one site only
    CACLSID  * pcauuidSite;
    if ( pRestriction->paPropRes[1].prop == PROPID_QM_CNS)
    {
        pcauuidSite =  &pRestriction->paPropRes[1].prval.cauuid;
    }
    else if ( pRestriction->paPropRes[2].prop == PROPID_QM_CNS)
    {
        pcauuidSite =  &pRestriction->paPropRes[2].prval.cauuid;
    }
    else
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 160);
    }
    UNREFERENCED_PARAMETER( pRestriction);
    ASSERT( pcauuidSite->cElems == 1);
    //
    HRESULT hr;
    *pHandle = NULL;
    P<CSiteGateList> pSiteGateList = new CSiteGateList;

    //
    //  Translate site guid into its DN name
    //
    PROPID prop = PROPID_S_FULL_NAME;
    PROPVARIANT var;
    var.vt = VT_NULL;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    hr = g_pDS->GetObjectProperties(
                eLocalDomainController,		    // local DC or GC
                &requestDsServerInternal,
 	            NULL,      // object name
                pcauuidSite->pElems,      // unique id of object
                1,          
                &prop,       
                &var);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("QueryConnectors : Failed to retrieve the DN of the site %lx"),hr));
        return LogHR(hr, s_FN, 170);
    }
    AP<WCHAR> pwcsSiteDN = var.pwszVal;

    hr = MQADSpQueryNeighborLinks(
                        eLinkNeighbor1,
                        pwcsSiteDN,
                        pRequestContext,
                        pSiteGateList
                        );
    if ( FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_TRACE,TEXT("QueryConnectors : Failed to query neighbor1 links %lx"),hr));
        return LogHR(hr, s_FN, 180);
    }

    hr = MQADSpQueryNeighborLinks(
                        eLinkNeighbor2,
                        pwcsSiteDN,
                        pRequestContext,
                        pSiteGateList
                        );
    if ( FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_TRACE,TEXT("QueryConnectors : Failed to query neighbor2 links %lx"),hr));
        return LogHR(hr, s_FN, 190);
    }
    
    //
    // keep the results for lookup next
    //
    CConnectorQueryHandle * phQuery = new CConnectorQueryHandle(
                                              pColumns,
                                              pSiteGateList,
                                              pRequestContext->GetRequesterProtocol()
                                              );
    *pHandle = (HANDLE)phQuery;
    pSiteGateList.detach();
    
    return(MQ_OK);

}
/*====================================================


QueryNT4MQISServers()

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI QueryNT4MQISServers( 
                 IN  LPWSTR         /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET *    /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    HRESULT hr;
    *pHandle = NULL;

    ASSERT( pRestriction->cRes == 2);
    ASSERT( pRestriction->paPropRes[0].prop == PROPID_SET_SERVICE);
    ASSERT( pRestriction->paPropRes[1].prop == PROPID_SET_NT4);

    // [adsrv] We must be sure to keep PROPID_SET_OLDSERVICE with existing service type attribute
    // BUGBUG 

    pRestriction->paPropRes[0].prop = PROPID_SET_OLDSERVICE;          //[adsrv] PROPID_SET_SERVICE 

    //
    //  Query NT4 MQIS Servers (PSCs or BSCs according to restriction)
    //  
    HANDLE hCursor;

    hr = g_pDS->LocateBegin( 
            eSubTree,	
            eLocalDomainController,
            pRequestContext,
            NULL,
            pRestriction,	// search criteria
            NULL,
            pColumns->cCol,    // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CQueryHandle * phQuery = new CQueryHandle(hCursor,
                                                  pColumns->cCol,
                                                  pRequestContext->GetRequesterProtocol()
                                                    );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 200);
}


/*====================================================


QuerySiteMachines()

Arguments:

Return Value:

This support is required for backward compatibility of
MSMQ 1.0 explorer. 
=====================================================*/
HRESULT WINAPI QuerySiteMachines( 
                 IN  LPWSTR         /*pwcsContext*/,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET *    /*pSort*/,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    HRESULT hr;
    *pHandle = NULL;

    ASSERT( pRestriction->cRes == 1);
    ASSERT( pRestriction->paPropRes[0].prop == PROPID_QM_SITE_ID);

    //
    //  Locate all machine that belong to a specific site
    //
    MQRESTRICTION restriction;
    MQPROPERTYRESTRICTION propertyRestriction;
   
    restriction.cRes = 1;
    restriction.paPropRes = &propertyRestriction;
    propertyRestriction.rel = PREQ;
    propertyRestriction.prop = PROPID_QM_SITE_IDS;
    propertyRestriction.prval.vt = VT_CLSID;
    propertyRestriction.prval.puuid = pRestriction->paPropRes[0].prval.puuid;


    HANDLE hCursor;

    hr = g_pDS->LocateBegin( 
            eSubTree,	
            eGlobalCatalog,	
            pRequestContext,
            NULL,
            &restriction,	// search criteria
            NULL,
            pColumns->cCol,    // attributes to be obtained
            pColumns->aCol, // size of pAttributeNames array
            &hCursor	        // result handle
            );

    if (SUCCEEDED(hr))
    {
        CQueryHandle * phQuery = new CQueryHandle(hCursor,
                                                  pColumns->cCol,
                                                  pRequestContext->GetRequesterProtocol()
                                                    );
        *pHandle = (HANDLE)phQuery;
    }

    return LogHR(hr, s_FN, 210);
}



//
//  BugBug - fill in

//
QUERY_FORMAT SupportedQueriesFormat[] = {
//
// no-rest | handler              | rest 1                 | rest 2                 | rest 3                 | rest 4                 | rest 5                 | rest 6                 | rest 7                 | rest 8                 | rest 9                 | rest 10                | DS_CONTEXT       |
//---------|----------------------|------------------------|------------------------|------------------------|------------------------|------------------------|------------------------|------------------------|------------------------|------------------------|------------------------|------------------|
{ 1,        QueryMachineQueues  ,  PREQ, PROPID_Q_QMID,     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                       e_RootDSE},
{ 2,        QuerySiteFRSs       ,  PRGE, PROPID_QM_SERVICE, PREQ, PROPID_QM_SITE_ID, 0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_SitesContainer},
{ 1,        QuerySiteName       ,  PREQ, PROPID_S_SITEID,   0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_SitesContainer},
{ 1,        QueryUserCert       ,  PREQ, PROPID_U_SID,      0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_RootDSE},
{ 4,        QuerySiteFRSs       ,  PRGE, PROPID_QM_SERVICE, PREQ, PROPID_QM_SITE_ID, PREQ|PRAll, PROPID_QM_CNS, PRGE, PROPID_QM_OS,    0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                       e_SitesContainer},
{ 4,        QuerySiteFRSs       ,  PRGE, PROPID_QM_SERVICE, PREQ, PROPID_QM_SITE_ID, PREQ|PRAny, PROPID_QM_CNS, PRGE, PROPID_QM_OS,    0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_SitesContainer},
{ 3,        QuerySiteFRSs       ,  PRGE, PROPID_QM_SERVICE, PREQ, PROPID_QM_SITE_ID, PREQ|PRAll, PROPID_QM_CNS, 0,0,                   0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_SitesContainer},
{ 3,        QuerySiteFRSs       ,  PRGE, PROPID_QM_SERVICE, PREQ, PROPID_QM_SITE_ID, PREQ|PRAny, PROPID_QM_CNS, 0,0,                   0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_SitesContainer},
{ 2,        QuerySiteFRSs       ,  PRGT, PROPID_QM_SERVICE, PREQ, PROPID_QM_SITE_ID, 0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_SitesContainer},
{ 3,        QuerySiteFRSs       ,  PRGE, PROPID_QM_SERVICE, PREQ, PROPID_QM_SITE_ID, PRGE, PROPID_QM_OS,      0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_SitesContainer},
{ 2,        QueryConnectors     ,  PRGE, PROPID_QM_SERVICE, PREQ|PRAny, PROPID_QM_CNS, 0,0,                   0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_RootDSE},
{ 3,        QueryConnectors     ,  PRGE, PROPID_QM_OS,      PRGE, PROPID_QM_SERVICE, PREQ|PRAny, PROPID_QM_CNS, 0,0,                   0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_RootDSE},
{ 1,        QueryForeignSites   ,  PREQ, PROPID_S_FOREIGN,  0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_RootDSE},
{ 1,        QueryCNsProtocol    ,  PREQ, PROPID_CN_PROTOCOLID,0,0,                   0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_RootDSE},
{ 2,        QueryNT4MQISServers ,  PREQ, PROPID_SET_SERVICE,PRGE, PROPID_SET_NT4,    0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_RootDSE},
{ 2,        QueryNT4MQISServers ,  PREQ, PROPID_SET_SERVICE,PREQ, PROPID_SET_NT4,    0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,					   e_RootDSE},
{ 1,        QueryLinks          ,  PREQ, PROPID_L_NEIGHBOR1,0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                       e_ConfigurationContainer},           
{ 1,        QueryLinks          ,  PREQ, PROPID_L_NEIGHBOR2,0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                       e_ConfigurationContainer},
{ 1,        QuerySiteMachines   ,  PREQ, PROPID_QM_SITE_ID, 0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                     0,0,                       e_RootDSE}
};

//+-------------------------
//
//  BOOL  FindQueryIndex()
//
//+-------------------------

BOOL FindQueryIndex( IN  MQRESTRICTION  *pRestriction,
					 OUT DWORD          *pdwIndex,
					 OUT DS_CONTEXT     *pdsContext )
{
    DWORD noQueries = sizeof(SupportedQueriesFormat) /
			                            sizeof(QUERY_FORMAT) ;
    DWORD index = 0;
    //
    //  Check if the query match one of the "known" queries.
    //
    if ( pRestriction != NULL)
    {
        ASSERT(pRestriction->cRes <= NO_OF_RESTRICITIONS);
        while ( index < noQueries)
        {
            //
            //  Make sure that number of restrictions match
            //

            if ( pRestriction->cRes == SupportedQueriesFormat[index].dwNoRestrictions)
            {
                BOOL fFoundMatch = TRUE;
                for ( DWORD i = 0; i < pRestriction->cRes; i++)
                {
                    //
                    //  ASSUMPTION : order of restrictions is fixed
                    //
                    if (( pRestriction->paPropRes[i].prop !=
                          SupportedQueriesFormat[index].restrictions[i].propId) ||
                        ( pRestriction->paPropRes[i].rel !=
                          SupportedQueriesFormat[index].restrictions[i].rel))
                    {
                        fFoundMatch = FALSE;
                        break;
                    }
                }
                if ( fFoundMatch)
                {
					*pdwIndex = index ;
					if (pdsContext)
					{
							*pdsContext = SupportedQueriesFormat[index].queryContext ;
					}
                    return TRUE ;
                }
            }
            //
            // Try next query
            //
            index++;
        }
    }

	return FALSE ;
}

/*====================================================


QueryParser()

Arguments:

Return Value:

=====================================================*/

HRESULT QueryParser(
                 IN  LPWSTR          pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle)
{
    DWORD dwIndex = 0;
    //
    //  Check if the query match one of the "known" queries.
    //
	BOOL fFound = FindQueryIndex( pRestriction,
								 &dwIndex,
								  NULL ) ;
	if (fFound)
	{
        HRESULT hr2 = SupportedQueriesFormat[dwIndex].QueryRequestHandler(
                                         pwcsContext,
                                         pRestriction,
                                         pColumns,
                                         pSort,
                                         pRequestContext,
                                         pHandle );
        return LogHR(hr2, s_FN, 220);
    }

    //
    //  If doesn't match any of the pre-defined formats, check
    //  is it a free-format queue locate query.
    //
    HRESULT hr = MQ_ERROR;
    if ( pRestriction)
    {
        BOOL fQueueQuery = TRUE;
        for ( DWORD i = 0; i < pRestriction->cRes; i++)
        {
            if (( pRestriction->paPropRes[i].prop <= PROPID_Q_BASE) ||
                ( pRestriction->paPropRes[i].prop > LAST_Q_PROPID))
            {
                fQueueQuery = FALSE;
                break;
            }
        }
        if ( !fQueueQuery)
        {
            //
            //  The query PROPID_QM_SERVICE == SERVICE_PEC is not supported
            //  ( and shouldn't generate an assert). This query is generated
            //  by MSMQ 1.0 explorer, and doesn't have meaning in NT5
            //  environment. 
            //
#ifdef _DEBUG
            if (!( ( pRestriction->cRes == 1) &&
                   ( pRestriction->paPropRes[0].prop == PROPID_QM_SERVICE) &&
                   ( pRestriction->paPropRes[0].prval.ulVal == SERVICE_PEC)))
            {
                ASSERT( hr == MQ_OK); // to catch unhandled queries
            }
#endif
            return LogHR(hr, s_FN, 230);
        }

        HANDLE hCursur;
        hr =  g_pDS->LocateBegin( 
                eSubTree,	
                eGlobalCatalog,	
                pRequestContext,
                NULL,      
                pRestriction,   
                pSort,
                pColumns->cCol,                 
                pColumns->aCol,           
                &hCursur);
        if ( SUCCEEDED(hr))
        {
            CQueryHandle * phQuery = new CQueryHandle( hCursur,
                                                       pColumns->cCol,
                                                       pRequestContext->GetRequesterProtocol()
                                                       );
            *pHandle = (HANDLE)phQuery;
        }
        return LogHR(hr, s_FN, 240);
    }
    else
    {
        //
        //  Other queries with no restirctions
        //
        hr =  NullRestrictionParser( 
                     pwcsContext,
                     pRestriction,
                     pColumns,
                     pSort,
                     pRequestContext,
                     pHandle);
    }


    return LogHR(hr, s_FN, 250);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\mqadsp.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mqadsp.cpp

Abstract:

    MQADS DLL private internal functions for
    DS queries, etc.

Author:

    ronit hartmann ( ronith)

--*/

#include "ds_stdh.h"
#include <_propvar.h>
#include "mqadsp.h"
#include "dsads.h"
#include "mqattrib.h"
#include "mqads.h"
#include "usercert.h"
#include "hquery.h"
#include "siteinfo.h"
#include "adstempl.h"
#include "coreglb.h"
#include "adserr.h"
#include "dsutils.h"
#include "notify.h"
#include "fntoken.h"
#include <_secutil.h>
#include <mqsec.h>
#include <mqdsdef.h>
#include <lmaccess.h>

#include "mqadsp.tmh"

static WCHAR *s_FN=L"mqdscore/mqadsp";

// this is the CRC table for the 5213724743 (0x136C32047) polynomial, seed(p/2)=9B619023
static const unsigned long CRCTable[256] = {
 0x00000000, 0x82E0FE45, 0x3302DCCD, 0xB1E22288, 0x6605B99A,	//   0 -   4
 0xE4E547DF, 0x55076557, 0xD7E79B12, 0xCC0B7334, 0x4EEB8D71,	//   5 -   9
 0xFF09AFF9, 0x7DE951BC, 0xAA0ECAAE, 0x28EE34EB, 0x990C1663,	//  10 -  14
 0x1BECE826, 0xAED5C62F, 0x2C35386A, 0x9DD71AE2, 0x1F37E4A7,	//  15 -  19
 0xC8D07FB5, 0x4A3081F0, 0xFBD2A378, 0x79325D3D, 0x62DEB51B,	//  20 -  24
 0xE03E4B5E, 0x51DC69D6, 0xD33C9793, 0x04DB0C81, 0x863BF2C4,	//  25 -  29
 0x37D9D04C, 0xB5392E09, 0x6B68AC19, 0xE988525C, 0x586A70D4,	//  30 -  34
 0xDA8A8E91, 0x0D6D1583, 0x8F8DEBC6, 0x3E6FC94E, 0xBC8F370B,	//  35 -  39
 0xA763DF2D, 0x25832168, 0x946103E0, 0x1681FDA5, 0xC16666B7,	//  40 -  44
 0x438698F2, 0xF264BA7A, 0x7084443F, 0xC5BD6A36, 0x475D9473,	//  45 -  49
 0xF6BFB6FB, 0x745F48BE, 0xA3B8D3AC, 0x21582DE9, 0x90BA0F61,	//  50 -  54
 0x125AF124, 0x09B61902, 0x8B56E747, 0x3AB4C5CF, 0xB8543B8A,	//  55 -  59
 0x6FB3A098, 0xED535EDD, 0x5CB17C55, 0xDE518210, 0xD6D15832,	//  60 -  64
 0x5431A677, 0xE5D384FF, 0x67337ABA, 0xB0D4E1A8, 0x32341FED,	//  65 -  69
 0x83D63D65, 0x0136C320, 0x1ADA2B06, 0x983AD543, 0x29D8F7CB,	//  70 -  74
 0xAB38098E, 0x7CDF929C, 0xFE3F6CD9, 0x4FDD4E51, 0xCD3DB014,	//  75 -  79
 0x78049E1D, 0xFAE46058, 0x4B0642D0, 0xC9E6BC95, 0x1E012787,	//  80 -  84
 0x9CE1D9C2, 0x2D03FB4A, 0xAFE3050F, 0xB40FED29, 0x36EF136C,	//  85 -  89
 0x870D31E4, 0x05EDCFA1, 0xD20A54B3, 0x50EAAAF6, 0xE108887E,	//  90 -  94
 0x63E8763B, 0xBDB9F42B, 0x3F590A6E, 0x8EBB28E6, 0x0C5BD6A3,	//  95 -  99
 0xDBBC4DB1, 0x595CB3F4, 0xE8BE917C, 0x6A5E6F39, 0x71B2871F,	// 100 - 104
 0xF352795A, 0x42B05BD2, 0xC050A597, 0x17B73E85, 0x9557C0C0,	// 105 - 109
 0x24B5E248, 0xA6551C0D, 0x136C3204, 0x918CCC41, 0x206EEEC9,	// 110 - 114
 0xA28E108C, 0x75698B9E, 0xF78975DB, 0x466B5753, 0xC48BA916,	// 115 - 119
 0xDF674130, 0x5D87BF75, 0xEC659DFD, 0x6E8563B8, 0xB962F8AA,	// 120 - 124
 0x3B8206EF, 0x8A602467, 0x0880DA22, 0x9B619023, 0x19816E66,	// 125 - 129
 0xA8634CEE, 0x2A83B2AB, 0xFD6429B9, 0x7F84D7FC, 0xCE66F574,	// 130 - 134
 0x4C860B31, 0x576AE317, 0xD58A1D52, 0x64683FDA, 0xE688C19F,	// 135 - 139
 0x316F5A8D, 0xB38FA4C8, 0x026D8640, 0x808D7805, 0x35B4560C,	// 140 - 144
 0xB754A849, 0x06B68AC1, 0x84567484, 0x53B1EF96, 0xD15111D3,	// 145 - 149
 0x60B3335B, 0xE253CD1E, 0xF9BF2538, 0x7B5FDB7D, 0xCABDF9F5,	// 150 - 154
 0x485D07B0, 0x9FBA9CA2, 0x1D5A62E7, 0xACB8406F, 0x2E58BE2A,	// 155 - 159
 0xF0093C3A, 0x72E9C27F, 0xC30BE0F7, 0x41EB1EB2, 0x960C85A0,	// 160 - 164
 0x14EC7BE5, 0xA50E596D, 0x27EEA728, 0x3C024F0E, 0xBEE2B14B,	// 165 - 169
 0x0F0093C3, 0x8DE06D86, 0x5A07F694, 0xD8E708D1, 0x69052A59,	// 170 - 174
 0xEBE5D41C, 0x5EDCFA15, 0xDC3C0450, 0x6DDE26D8, 0xEF3ED89D,	// 175 - 179
 0x38D9438F, 0xBA39BDCA, 0x0BDB9F42, 0x893B6107, 0x92D78921,	// 180 - 184
 0x10377764, 0xA1D555EC, 0x2335ABA9, 0xF4D230BB, 0x7632CEFE,	// 185 - 189
 0xC7D0EC76, 0x45301233, 0x4DB0C811, 0xCF503654, 0x7EB214DC,	// 190 - 194
 0xFC52EA99, 0x2BB5718B, 0xA9558FCE, 0x18B7AD46, 0x9A575303,	// 195 - 199
 0x81BBBB25, 0x035B4560, 0xB2B967E8, 0x305999AD, 0xE7BE02BF,	// 200 - 204
 0x655EFCFA, 0xD4BCDE72, 0x565C2037, 0xE3650E3E, 0x6185F07B,	// 205 - 209
 0xD067D2F3, 0x52872CB6, 0x8560B7A4, 0x078049E1, 0xB6626B69,	// 210 - 214
 0x3482952C, 0x2F6E7D0A, 0xAD8E834F, 0x1C6CA1C7, 0x9E8C5F82,	// 215 - 219
 0x496BC490, 0xCB8B3AD5, 0x7A69185D, 0xF889E618, 0x26D86408,	// 220 - 224
 0xA4389A4D, 0x15DAB8C5, 0x973A4680, 0x40DDDD92, 0xC23D23D7,	// 225 - 229
 0x73DF015F, 0xF13FFF1A, 0xEAD3173C, 0x6833E979, 0xD9D1CBF1,	// 230 - 234
 0x5B3135B4, 0x8CD6AEA6, 0x0E3650E3, 0xBFD4726B, 0x3D348C2E,	// 235 - 239
 0x880DA227, 0x0AED5C62, 0xBB0F7EEA, 0x39EF80AF, 0xEE081BBD,	// 240 - 244
 0x6CE8E5F8, 0xDD0AC770, 0x5FEA3935, 0x4406D113, 0xC6E62F56,	// 245 - 249
 0x77040DDE, 0xF5E4F39B, 0x22036889, 0xA0E396CC, 0x1101B444,	// 250 - 254
 0x93E14A01 };

static DWORD CalHashKey( IN LPCWSTR pwcsPathName)
/*++

Routine Description:
    Calculates a hash

Arguments:
    pwcsPathName - the string on which the hash is calculated

Return Value:
    hash value.

--*/
{
	unsigned long dwCrc = 0;
    WCHAR wcsLowChar[2];
    wcsLowChar[1] = '\0';
	unsigned char * pucLowCharBuf = ( unsigned char *)wcsLowChar;

	while( *pwcsPathName != '\0' )
	{
		wcsLowChar[0] = *pwcsPathName++;
		CharLower( wcsLowChar );	// convert one char to lowercase

		// compute the CRC on hi and lo bytes
		dwCrc = (dwCrc >> 8) ^ CRCTable[ (unsigned char)dwCrc ^ pucLowCharBuf[1] ];
		dwCrc = (dwCrc >> 8) ^ CRCTable[ (unsigned char)dwCrc ^ pucLowCharBuf[0] ];
	}

    return( dwCrc );
}
STATIC HRESULT MQADSpComposeName(
               IN  LPCWSTR   pwcsPrefix,
               IN  LPCWSTR   pwcsSuffix,
               OUT LPWSTR * pwcsFullName
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    //
    //  compose a distinguished name of an object
    //  format : CN=prefix, suffix
    //

    DWORD LenSuffix = lstrlen(pwcsSuffix);
    DWORD LenPrefix = lstrlen(pwcsPrefix);
    DWORD Length =
            x_CnPrefixLen +                   // "CN="
            LenPrefix +                       // "pwcsPrefix"
            1 +                               //","
            LenSuffix +                       // "pwcsSuffix"
            1;                                // '\0'

    *pwcsFullName = new WCHAR[Length];

    swprintf(
        *pwcsFullName,
         L"%s"             // "CN="
         L"%s"             // "pwcsPrefix"
         TEXT(",")
         L"%s",            // "pwcsSuffix"
        x_CnPrefix,
        pwcsPrefix,
        pwcsSuffix
        );

    return(MQ_OK);


}

//+-------------------------------------------------------------------------
//
//  HRESULT  GetFullComputerPathName()
//
//  Query the DS to find full computer path name (its distinguished name).
//  When called from migration tool or replication service, then we already
//  have this path. So save an extra DS query.
//
//+-------------------------------------------------------------------------

HRESULT  GetFullComputerPathName(
                IN  LPCWSTR              pwcsComputerName,
                IN  enumComputerObjType  eComputerObjType,
                IN  const DWORD          cp,
                IN  const PROPID         aProp[  ],
                IN  const PROPVARIANT    apVar[  ],
                OUT LPWSTR *             ppwcsFullPathName,
                OUT DS_PROVIDER *        pCreateProvider )
{
    for ( DWORD j = 0 ; j < cp ; j++ )
    {
        if (aProp[ j ] == PROPID_QM_MIG_GC_NAME)
        {
            ASSERT(aProp[ j-1 ] == PROPID_QM_MIG_PROVIDER) ;
            *pCreateProvider = (enum DS_PROVIDER) apVar[ j-1 ].ulVal ;

            ASSERT(aProp[ j-2 ] == PROPID_QM_FULL_PATH) ;
            *ppwcsFullPathName = new WCHAR[ 1 + wcslen(apVar[ j-2 ].pwszVal) ] ;
            wcscpy(*ppwcsFullPathName, apVar[ j-2 ].pwszVal) ;

            return MQ_OK ;
        }
    }

    HRESULT hr = MQADSpGetFullComputerPathName( pwcsComputerName,
                                                eComputerObjType,
                                                ppwcsFullPathName,
                                                pCreateProvider ) ;
    return LogHR(hr, s_FN, 10);
}


HRESULT MQADSpCreateMachineSettings(
            IN DWORD                dwNumSites,
            IN const GUID *         pSite,
            IN LPCWSTR              pwcsPathName,
            IN BOOL                 fRouter,         // [adsrv] DWORD                dwService,
            IN BOOL                 fDSServer,
            IN BOOL                 fDepClServer,
            IN BOOL                 fSetQmOldService,
            IN DWORD                dwOldService,
            IN  const GUID *        pguidObject,
            IN  const DWORD         cpEx,
            IN  const PROPID        aPropEx[  ],
            IN  const PROPVARIANT   apVarEx[  ],
            IN  CDSRequestContext * pRequestContext
            )
/*++

Routine Description:
    This routine creates settings object in each of the server's sites.

Arguments:

Return Value:
--*/
{
    HRESULT hr = MQ_OK;
    //
    //  Prepare the attributes of the setting object
    //
    DWORD dwNumofProps = 0 ;
    PROPID aSetProp[20];
    MQPROPVARIANT aSetVar[20];

    // [adsrv] Reformat Setting properties to include new server attributes
    for ( DWORD i = 0; i< cpEx ; i++)
    {
        switch (aPropEx[i])
        {
        case PROPID_SET_SERVICE_ROUTING:
        case PROPID_SET_SERVICE_DSSERVER:
        case PROPID_SET_SERVICE_DEPCLIENTS:
        case PROPID_SET_OLDSERVICE:
            break;

        default:
            aSetProp[dwNumofProps] = aPropEx[i];
            aSetVar[dwNumofProps]  = apVarEx[i];  // yes, there may be ptrs, but no problem - apVar is here
            dwNumofProps++;
            break;
        }
    }

    // [adsrv] It was added always
    aSetProp[ dwNumofProps ] = PROPID_SET_QM_ID;
    aSetVar[ dwNumofProps ].vt = VT_CLSID;
    aSetVar[ dwNumofProps ].puuid =  const_cast<GUID *>(pguidObject);
    dwNumofProps++ ;

    // [adsrv] Now we add new server type attributes
    aSetProp[dwNumofProps] = PROPID_SET_SERVICE_ROUTING;
    aSetVar[dwNumofProps].vt   = VT_UI1;
    aSetVar[dwNumofProps].bVal = (UCHAR)fRouter;
    dwNumofProps++;

    aSetProp[dwNumofProps] = PROPID_SET_SERVICE_DSSERVER;
    aSetVar[dwNumofProps].vt   = VT_UI1;
    aSetVar[dwNumofProps].bVal = (UCHAR)fDSServer;
    dwNumofProps++;

    aSetProp[dwNumofProps] = PROPID_SET_SERVICE_DEPCLIENTS;
    aSetVar[dwNumofProps].vt   = VT_UI1;
    aSetVar[dwNumofProps].bVal = (UCHAR)fDepClServer;
    dwNumofProps++;

    if (fSetQmOldService)
    {
        aSetProp[dwNumofProps] = PROPID_SET_OLDSERVICE;
        aSetVar[dwNumofProps].vt   = VT_UI4;
        aSetVar[dwNumofProps].ulVal = dwOldService;
        dwNumofProps++;
    }
    // [adsrv] end

    ASSERT(dwNumofProps <= 20) ;

    WCHAR *pwcsServerNameNB = const_cast<WCHAR *>(pwcsPathName);
    AP<WCHAR> pClean;
    //
    //  Is the computer name specified in DNS format ?
    //  If so, find the NetBios name and create the server object with
    //  "netbios" name, to be compatible with the way servers objects
    //  are created by dcpromo.
    //
    WCHAR * pwcsEndMachineName = wcschr( pwcsPathName, L'.');
    if ( pwcsEndMachineName != NULL)
    {
        pClean = new WCHAR[ pwcsEndMachineName - pwcsPathName + 1 ];
        wcsncpy( pClean, pwcsPathName, pwcsEndMachineName - pwcsPathName);
        pClean[pwcsEndMachineName - pwcsPathName] = L'\0';
        pwcsServerNameNB = pClean;
    }


    //
    //  Create a settings object in each of the server's sites
    //
    for ( i = 0; i < dwNumSites ; i++)
    {
        AP<WCHAR> pwcsSiteName;
        //
        //  Translate site-id to site name
        //
        hr = MQADSpGetSiteName(
            &pSite[i],
            &pwcsSiteName
            );
        if (FAILED(hr))
        {
            //
            //  BUGBUG - to clean computer configuration & server objects
            //
            return LogHR(hr, s_FN, 20);
        }
        DWORD len = wcslen(pwcsSiteName);
        const WCHAR x_wcsCnServers[] =  L"CN=Servers,";
        const DWORD x_wcsCnServersLength = (sizeof(x_wcsCnServers)/sizeof(WCHAR)) -1;
        AP<WCHAR> pwcsServersContainer =  new WCHAR [ len + x_wcsCnServersLength + 1];
        swprintf(
             pwcsServersContainer,
             L"%s%s",
             x_wcsCnServers,
             pwcsSiteName
             );

        //
        //  create MSMQ-Setting & server in the site container
        //
        PROPID prop = PROPID_SRV_NAME;
        MQPROPVARIANT var;
        var.vt = VT_LPWSTR;
        var.pwszVal = pwcsServerNameNB;

        hr = g_pDS->CreateObject(
                eLocalDomainController,
                pRequestContext,
                MSMQ_SERVER_CLASS_NAME,  // object class
                pwcsServerNameNB,        // object name (server netbiod name).
                pwcsServersContainer,    // parent name
                1,
                &prop,
                &var,
                NULL /*pObjInfoRequest*/,
                NULL /*pParentInfoRequest*/);
        if (FAILED(hr) && ( hr != HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) &&   //BUGBUG alexdad: to throw after transition
                          ( hr != HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS))    ) // if server object exists it is ok
        {
            //
            //  BUGBUG - to clean computer configuration
            //
            return LogHR(hr, s_FN, 30);
        }

        AP<WCHAR> pwcsServerNameDN; // full distinguished name of server.
        hr = MQADSpComposeName(
                            pwcsServerNameNB,
                            pwcsServersContainer,
                            &pwcsServerNameDN);
        if (FAILED(hr))
        {
            //
            //  BUGBUG - to clean computer configuration & server objects
            //
           return LogHR(hr, s_FN, 40);
        }

        hr = g_pDS->CreateObject(
                eLocalDomainController,
                pRequestContext,
                MSMQ_SETTING_CLASS_NAME,   // object class
                x_MsmqSettingName,         // object name
                pwcsServerNameDN,          // parent name
                dwNumofProps,
                aSetProp,
                aSetVar,
                NULL /*pObjInfoRequest*/,
                NULL /*pParentInfoRequest*/);

        //
        //  If the object exists :Delete the object, and re-create it
        //  ( this can happen, if msmq-configuration was deleted and
        //   msmq-settings was not)
        //
        if ( hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS))
        {
            DWORD dwSettingLen =  wcslen(pwcsServerNameDN) +
                                  x_MsmqSettingNameLen     +
                                  x_CnPrefixLen + 2 ;
            AP<WCHAR> pwcsSettingObject = new WCHAR[ dwSettingLen ] ;
            swprintf(
                 pwcsSettingObject,
                 L"%s%s,%s",
                 x_CnPrefix,
                 x_MsmqSettingName,
                 pwcsServerNameDN
                 );

            hr = g_pDS->DeleteObject(
                    eLocalDomainController,
                    e_ConfigurationContainer,
                    pRequestContext,
                    pwcsSettingObject,
                    NULL,
                    NULL,
                    NULL);
            if (SUCCEEDED(hr))
            {
                hr = g_pDS->CreateObject(
                        eLocalDomainController,
                        pRequestContext,
                        MSMQ_SETTING_CLASS_NAME,   // object class
                        x_MsmqSettingName,         // object name
                        pwcsServerNameDN,          // parent name
                        dwNumofProps,
                        aSetProp,
                        aSetVar,
                        NULL /*pObjInfoRequest*/,
                        NULL /*pParentInfoRequest*/);
            }
        }
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 50);
        }

    }

    return LogHR(hr, s_FN, 60);
}

HRESULT MQADSpCreateQueue(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  CDSRequestContext *   pRequestContext,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pQueueInfoRequest,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pQmInfoRequest
                 )
/*++

Routine Description:
    This routine creates a queue object under msmqConfiguration
    of the specified computer

Arguments:
    pwcsPathName : computer-name\queue-name
    cp :           size of aProp & apVar arrays
    aProp :        ids of specified queue properties
    apVar :        values of specified properties
    pQueueInfoRequest : request for queue info for notification (can be NULL)
    pQmInfoRequest    : request for owner-QM info for notification (can be NULL)

Return Value:
--*/
{
    HRESULT hr;
    DWORD cpInternal = cp;
    const PROPID * aPropInternal =  aProp;
    const PROPVARIANT *  apVarInternal = apVar;
    //
    //  Path name format is machine1\queue1.
    //  Split it into machine name and queue name
    //
    AP<WCHAR> pwcsMachineName;
    AP<WCHAR> pwcsQueueName;

    hr = MQADSpSplitAndFilterQueueName(
                      pwcsPathName,
                      &pwcsMachineName,
                      &pwcsQueueName
                      );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 70);
    }

    //
    //  prepare full path name of the queue
    //
    AP<WCHAR> pwcsFullPathName;
    DS_PROVIDER createProvider;

    hr =  GetFullComputerPathName( pwcsMachineName,
                                   e_MsmqComputerObject,
                                   cp,
                                   aProp,
                                   apVar,
                                  &pwcsFullPathName,
                                  &createProvider ) ;
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 80);
        return(MQ_ERROR_INVALID_OWNER);
    }
    //
    //  add MSMQ-configuration
    //
    AP<WCHAR> pwcsMsmq;
    hr = MQADSpComposeName(
            x_MsmqComputerConfiguration,
            pwcsFullPathName,
            &pwcsMsmq
            );
    //
    //  Is the queue-name within the size limit of CN
    //
    DWORD len = wcslen(pwcsQueueName);
    WCHAR * pwcsPrefixQueueName = pwcsQueueName;
    AP<WCHAR> pwcsCleanPrefixQueueName;
    AP<WCHAR> pwcsSuffixQueueName;
    AP<PROPID> pCleanPropid;
    AP<PROPVARIANT> pCleanPropvariant;

    if ( len > x_PrefixQueueNameLength)
    {
        //
        //  Split the queue name
        //
        pwcsCleanPrefixQueueName = new WCHAR[ x_PrefixQueueNameLength + 1 + 1];
        DWORD dwSuffixLength =  len - ( x_PrefixQueueNameLength + 1 - x_SplitQNameIdLength);
        pwcsSuffixQueueName = new WCHAR[ dwSuffixLength + 1];
        pwcsPrefixQueueName =  pwcsCleanPrefixQueueName;
        memcpy( pwcsCleanPrefixQueueName, pwcsQueueName, (x_PrefixQueueNameLength + 1 - x_SplitQNameIdLength) * sizeof(WCHAR));
        DWORD dwHash = CalHashKey(pwcsQueueName);
        _snwprintf(
        pwcsCleanPrefixQueueName+( x_PrefixQueueNameLength + 1 - x_SplitQNameIdLength),
        x_SplitQNameIdLength,
        L"-%08x",
        dwHash
        );

        pwcsCleanPrefixQueueName[x_PrefixQueueNameLength + 1 ] = '\0';
        memcpy( pwcsSuffixQueueName , (pwcsQueueName + x_PrefixQueueNameLength + 1 - x_SplitQNameIdLength), dwSuffixLength * sizeof(WCHAR));
        pwcsSuffixQueueName[ dwSuffixLength] = '\0';

        //
        //  insert the name suffix to the arrays of props and varaints
        //
        pCleanPropid = new PROPID[ cp + 1];
        pCleanPropvariant = new PROPVARIANT[ cp + 1];
        memcpy( pCleanPropid, aProp, sizeof(PROPID) * cp);
        memcpy( pCleanPropvariant, apVar, sizeof(PROPVARIANT) * cp);
        cpInternal = cp + 1;
        aPropInternal = pCleanPropid;
        apVarInternal = pCleanPropvariant;
        pCleanPropid[cp] =  PROPID_Q_NAME_SUFFIX;
        pCleanPropvariant[cp].vt = VT_LPWSTR;
        pCleanPropvariant[cp].pwszVal = pwcsSuffixQueueName;

    }


    hr = g_pDS->CreateObject(
            createProvider,
            pRequestContext,
            MSMQ_QUEUE_CLASS_NAME,   // object class
            pwcsPrefixQueueName,     // object name
            pwcsMsmq,   // msmq-configuration name
            cpInternal,
            aPropInternal,
            apVarInternal,
            pQueueInfoRequest,
            pQmInfoRequest);

    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
    {
        return LogHR(MQ_ERROR_INVALID_OWNER, s_FN, 90);
    }

    return LogHR(hr, s_FN, 100);

}

HRESULT MQADSpCreateEnterprise(
                 IN  LPCWSTR            /*pwcsPathName*/,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  CDSRequestContext *   pRequestContext
                 )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    HRESULT hr;
    //
    //  Create MSMQ-service under configuration\services
    //
    //  Note - the caller supplied path-name is ignored,
    //  the object is created with
    //
    hr = g_pDS->CreateObject(
            eLocalDomainController,
            pRequestContext,
            MSMQ_SERVICE_CLASS_NAME,   // object class
            x_MsmqServicesName,     // object name
            g_pwcsServicesContainer,
            cp,
            aProp,
            apVar,
            NULL /*pObjInfoRequest*/,
            NULL /*pParentInfoRequest*/);


    return LogHR(hr, s_FN, 110);

}


HRESULT MQADSpCreateSiteLink(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN OUT MQDS_OBJ_INFO_REQUEST * pObjectInfoRequest,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest,
                 IN  CDSRequestContext *   pRequestContext
                 )
/*++

Routine Description:
    This routine creates a site-link object. For that
    it composes the link name from the two site ids.

Arguments:

Return Value:
--*/
{
    //
    //  NO pathname is supplied
    //
    ASSERT( pwcsPathName == NULL);
    UNREFERENCED_PARAMETER( pwcsPathName);

    //
    //  The link path name will be composed
    //  from the ids of the sites it links.
    //
    GUID * pguidNeighbor1 = NULL;
    GUID * pguidNeighbor2 = NULL;
    DWORD dwToFind = 2;
    for (DWORD i = 0; i < cp; i++)
    {
        if ( aProp[i] == PROPID_L_NEIGHBOR1)
        {
            pguidNeighbor1 = apVar[i].puuid;
            if ( --dwToFind == 0)
            {
                break;
            }
        }
        if ( aProp[i] == PROPID_L_NEIGHBOR2)
        {
            pguidNeighbor2 = apVar[i].puuid;
            if ( --dwToFind == 0)
            {
                break;
            }
        }
    }
    ASSERT( pguidNeighbor1 != NULL);
    ASSERT( pguidNeighbor2 != NULL);
    //
    //  cn has a size limit of 64.
    //  Therefore guid format is without '-'
    //

const WCHAR x_GUID_FORMAT[] = L"%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x";
const DWORD x_GUID_STR_LENGTH = (8 + 4 + 4 + 4 + 12 + 1);

    WCHAR strUuidSite1[x_GUID_STR_LENGTH];
    WCHAR strUuidSite2[x_GUID_STR_LENGTH];

    _snwprintf(
        strUuidSite1,
        x_GUID_STR_LENGTH,
        x_GUID_FORMAT,
        pguidNeighbor1->Data1, pguidNeighbor1->Data2, pguidNeighbor1->Data3,
        pguidNeighbor1->Data4[0], pguidNeighbor1->Data4[1],
        pguidNeighbor1->Data4[2], pguidNeighbor1->Data4[3],
        pguidNeighbor1->Data4[4], pguidNeighbor1->Data4[5],
        pguidNeighbor1->Data4[6], pguidNeighbor1->Data4[7]
        );
    strUuidSite1[ TABLE_SIZE(strUuidSite1)-1] = L'\0' ;

    _snwprintf(
        strUuidSite2,
        x_GUID_STR_LENGTH,
        x_GUID_FORMAT,
        pguidNeighbor2->Data1, pguidNeighbor2->Data2, pguidNeighbor2->Data3,
        pguidNeighbor2->Data4[0], pguidNeighbor2->Data4[1],
        pguidNeighbor2->Data4[2], pguidNeighbor2->Data4[3],
        pguidNeighbor2->Data4[4], pguidNeighbor2->Data4[5],
        pguidNeighbor2->Data4[6], pguidNeighbor2->Data4[7]
        );
    strUuidSite2[ TABLE_SIZE(strUuidSite2)-1] = L'\0' ;


    //
    //  The link name will start with the smaller site id
    //
    WCHAR strLinkName[2 * x_GUID_STR_LENGTH + 1];
    if ( wcscmp( strUuidSite1, strUuidSite2) < 0)
    {
        swprintf(
             strLinkName,
             L"%s%s",
             strUuidSite1,
             strUuidSite2
             );

    }
    else
    {
        swprintf(
             strLinkName,
             L"%s%s",
             strUuidSite2,
             strUuidSite1
             );
    }
    //
    //  Create the link object under msmq-service
    //
    HRESULT hr = g_pDS->CreateObject(
            eLocalDomainController,
            pRequestContext,
            MSMQ_SITELINK_CLASS_NAME,   // object class
            strLinkName,     // object name
            g_pwcsMsmqServiceContainer,
            cp,
            aProp,
            apVar,
            pObjectInfoRequest,
            pParentInfoRequest);



    return LogHR(hr, s_FN, 120);
}


HRESULT MQADSpGetQueueProperties(
               IN  LPCWSTR          pwcsPathName,
               IN  const GUID *     pguidIdentifier,
               IN  DWORD            cp,
               IN  const PROPID     aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT      apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
   AP<WCHAR> pwcsFullPathName;
   HRESULT hr = MQ_OK;

   DS_PROVIDER WhichDCProvider = eLocalDomainController;   // either local-DC or DC
   if  (pwcsPathName)
   {
        //
        //  Path name format is machine1\queue1.
        //  expand machine1 name to a full computer path name
        //
        hr =  MQADSpComposeFullPathName(
                MQDS_QUEUE,
                pwcsPathName,
                &pwcsFullPathName,
                &WhichDCProvider
                );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 130);
        }
    }
    //
    //  Try to retrieve properties from the local DC,
    //  if failed try the GC.
    //
    //  For most operation this will not add overhead.
    //  This solve problems like create queue on a DC which is not
    //  a GC followed by open queue. The open queue will succeed with
    //  out the GC replication delay.
    //

    BOOL firstTry = TRUE;
    //
    //  BUGBUG - performance: to do impersonation only once
    //

    if ( WhichDCProvider == eLocalDomainController)
    {
        hr = g_pDS->GetObjectProperties(
            eLocalDomainController,		    // local DC or GC
            pRequestContext,
 	        pwcsFullPathName,      // object name
            pguidIdentifier,      // unique id of object
            cp,
            aProp,
            apVar);
        if (SUCCEEDED(hr))
        {
            return(hr);
        }
        firstTry = FALSE;
    }
    if ( firstTry ||
        (pwcsPathName == NULL))
    {
        //
        //  We may get here:
        //  1) Queue's name == NULL ( in this case
        //     we didn't expand the queue name, and if it was not found on
        //     local-DC we try once more.
        //  2) Queue's name != NULL, and while expanding the queue name it was
        //     not found in the local-DC
        //
         hr = g_pDS->GetObjectProperties(
                eGlobalCatalog,		    // local DC or GC
                pRequestContext,
 	            pwcsFullPathName,      // object name
                pguidIdentifier,      // unique id of object
                cp,
                aProp,
                apVar);

    }
    return LogHR(hr, s_FN, 140);

}

STATIC HRESULT MQADSpGetCnNameAndProtocol(
               IN  LPCWSTR          pwcsPathName,
               IN  const GUID *     pguidIdentifier,
               IN  DWORD            cp,
               IN  const PROPID     aProp[],
               IN  CDSRequestContext*  pRequestContext,
               OUT PROPVARIANT      apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    UNREFERENCED_PARAMETER( pwcsPathName);
    ASSERT((cp == 2) &&
           (aProp[0] == PROPID_CN_PROTOCOLID) &&
           ( aProp[1] == PROPID_CN_NAME));

    UNREFERENCED_PARAMETER( cp);
    UNREFERENCED_PARAMETER( aProp);

    //
    //  Get the site name and foreign indication
    //
    // Note we are reading the results into the caller supplied variants
    //
    const DWORD cNumProperties = 2;
    PROPID prop[cNumProperties] = { PROPID_S_FOREIGN, PROPID_S_PATHNAME};

    HRESULT hr = g_pDS->GetObjectProperties(
            eLocalDomainController,
            pRequestContext,
 	        NULL,      // object name
            pguidIdentifier,      // unique id of object
            cNumProperties,
            prop,
            apVar);
    //
    //  Return CN protocol id according site's foreign
    //
    ASSERT( prop[0] ==  PROPID_S_FOREIGN);
    apVar[0].vt = VT_UI1;
    if ( apVar[0].bVal != 0)
    {
        //
        //  It is a foreign site
        //
        apVar[0].bVal = FOREIGN_ADDRESS_TYPE;
    }
    else
    {
        //
        //  Assume IP address ( no support of IPX)
        //
        apVar[0].bVal = IP_ADDRESS_TYPE;
    }

    return LogHR(hr, s_FN, 150);
}

STATIC HRESULT MQADSpGetCnGuidAndProtocol(
               IN  LPCWSTR       pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD         cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext *pRequestContext,
               OUT PROPVARIANT  apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    UNREFERENCED_PARAMETER( pguidIdentifier);
    ASSERT((cp == 2) &&
           (aProp[0] == PROPID_CN_GUID) &&
           ( aProp[1] == PROPID_CN_PROTOCOLID));

    ASSERT(pwcsPathName);

    UNREFERENCED_PARAMETER( cp);
    UNREFERENCED_PARAMETER( aProp);
    //
    //  Expand the site name into a full path name
    //
    HRESULT hr;
    AP<WCHAR> pwcsFullPathName;
    DS_PROVIDER dsTmp;
    hr =  MQADSpComposeFullPathName(
                MQDS_SITE,
                pwcsPathName,
                &pwcsFullPathName,
                &dsTmp
                );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }


    //
    //  Get the site guid and foreign indication
    //
    // Note we are reading the results into the caller supplied variants
    //
    const DWORD cNumProperties = 2;
    PROPID prop[cNumProperties] = { PROPID_S_SITEID, PROPID_S_FOREIGN };

    hr = g_pDS->GetObjectProperties(
            eLocalDomainController,
            pRequestContext,
 	        pwcsFullPathName,      // object name
            NULL,      // unique id of object
            cNumProperties,
            prop,
            apVar);
    //
    //  Return CN protocol id according site's foreign
    //
    ASSERT( prop[1] ==  PROPID_S_FOREIGN);
    apVar[1].vt = VT_UI1;
    if ( apVar[1].bVal != 0)
    {
        //
        //  It is a foreign site
        //
        apVar[1].bVal = FOREIGN_ADDRESS_TYPE;
    }
    else
    {
        //
        //  Assume IP address ( no support of IPX)
        //
        apVar[1].bVal = IP_ADDRESS_TYPE;
    }

    return LogHR(hr, s_FN, 170);
}


STATIC HRESULT MQADSpGetCnName(
               IN  LPCWSTR          pwcsPathName,
               IN  const GUID *     pguidIdentifier,
               IN  DWORD            cp,
               IN  const PROPID     aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT      apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    UNREFERENCED_PARAMETER( pwcsPathName);
    ASSERT((cp == 1) &&
           ( aProp[0] == PROPID_CN_NAME));

    UNREFERENCED_PARAMETER( cp);
    UNREFERENCED_PARAMETER( aProp);

    //
    //  Get the site name and foreign indication
    //
    // Note we are reading the results into the caller supplied variants
    //
    const DWORD cNumProperties = 1;
    PROPID prop[cNumProperties] = {  PROPID_S_PATHNAME};

    HRESULT hr = g_pDS->GetObjectProperties(
            eLocalDomainController,
            pRequestContext,
 	        NULL,      // object name
            pguidIdentifier,      // unique id of object
            cNumProperties,
            prop,
            apVar);
    return LogHR(hr, s_FN, 180);
}


HRESULT MQADSpGetCnProperties(
               IN  LPCWSTR          pwcsPathName,
               IN  const GUID *     pguidIdentifier,
               IN  DWORD            cp,
               IN  const PROPID     aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT      apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    //
    //  A limited support for backward compatability
    //

    if (( cp == 1) &&
        (aProp[0] == PROPID_CN_NAME))
    {
        //
        //  retrieve CN name
        //
        HRESULT hr2 = MQADSpGetCnName(
                    pwcsPathName,
                    pguidIdentifier,
                    cp,
                    aProp,
                    pRequestContext,
                    apVar);
        return LogHR(hr2, s_FN, 190);

    }

    if ( ( cp == 2) &&
         (aProp[0] == PROPID_CN_PROTOCOLID) &&
         (aProp[1] == PROPID_CN_NAME))
    {
        //
        //  retrieve CN name and protocol
        //
        HRESULT hr2 = MQADSpGetCnNameAndProtocol(
                    pwcsPathName,
                    pguidIdentifier,
                    cp,
                    aProp,
                    pRequestContext,
                    apVar);
        return LogHR(hr2, s_FN, 200);

    }

    if ((cp == 2) && (aProp[0] == PROPID_CN_GUID)
            && ( aProp[1] == PROPID_CN_PROTOCOLID))
    {
        ASSERT(pwcsPathName);
        ASSERT(!pguidIdentifier);

        //
        //  retrieve CN guid and protocol
        //
        HRESULT hr2 = MQADSpGetCnGuidAndProtocol(
                    pwcsPathName,
                    pguidIdentifier,
                    cp,
                    aProp,
                    pRequestContext,
                    apVar);
        return LogHR(hr2, s_FN, 210);

    }

    if ((cp == 3)                     &&
        (aProp[0] == PROPID_CN_NAME)  &&
        (aProp[1] == PROPID_CN_GUID)  &&
        (aProp[2] == PROPID_CN_PROTOCOLID))
    {
        //
        // This query is done by nt4 mqxplore, after creating a foreign cn.
        // first retrieve guid, then internal name.
        //
        ASSERT(pwcsPathName) ;
        ASSERT(!pguidIdentifier) ;

        HRESULT hr2 = MQADSpGetCnGuidAndProtocol(
                                pwcsPathName,
                                pguidIdentifier,
                                2,
                               &(aProp[1]),
                                pRequestContext,
                               &(apVar[1]) ) ;
        if (FAILED(hr2))
        {
            return LogHR(hr2, s_FN, 1180);
        }

        GUID *pGuid = apVar[1].puuid ;

        hr2 = MQADSpGetCnName( pwcsPathName,
                               pGuid,
                               1,
                               aProp,
                               pRequestContext,
                               apVar );
        return LogHR(hr2, s_FN, 1190);
    }

    ASSERT(0) ;
    return LogHR(MQ_ERROR, s_FN, 220);
}


HRESULT MQADSpGetMachineProperties(
               IN  LPCWSTR          pwcsPathName,
               IN  const GUID *     pguidIdentifier,
               IN  DWORD            cp,
               IN  const PROPID     aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT      apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    AP<WCHAR> pwcsFullPathName;
    HRESULT hr;

    //
    // workaround - if no identifier is supplied for machine, get the
    // DS Server machine itself.
    //
    if ( (pwcsPathName == NULL) &&
         (pguidIdentifier == NULL))
    {
        pguidIdentifier = &g_guidThisServerQMId;
    }
    //
    //  Workaround
    //  This Get request is initiated by servers to learn on which
    //  addresses they should listen for topology broadcasts.
    //  It is important to  return all the addresses of the server.
    //
    //  Therefore ignore the protocol on which the RPC call was received,
    //  and return all the server's addresses
    //
    if ( ( cp == 3) &&
         ( aProp[0] == PROPID_QM_ADDRESS) &&
         ( aProp[1] == PROPID_QM_CNS) &&
         ( aProp[2] == PROPID_QM_SITE_ID))
    {
        pRequestContext->SetAllProtocols();
    }


    DS_PROVIDER WhichDCProvider = eLocalDomainController; // either local-DC or DC

    if  (pwcsPathName)
    {
        //
        //  Get full computer pathname
        //

        hr =  MQADSpComposeFullPathName(
                        MQDS_MACHINE,
                        pwcsPathName,
                        &pwcsFullPathName,
                        &WhichDCProvider
                        );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 230);
        }

    }
    //
    //  Decide provider according to requested properties
    //
    DS_PROVIDER dsProvider = MQADSpDecideComputerProvider( cp, aProp);

    hr = MQDS_OBJECT_NOT_FOUND;
    //
    //  BUGBUG - performance: to do impersonation only once
    //

    //
    //  if we found the computer on the local-DC : get properties from it.
    //  ( it doesn't matter if  dsProvider is GC or not)
    //
    BOOL firstTry = TRUE;
    if ( WhichDCProvider == eLocalDomainController)
    {
        hr = g_pDS->GetObjectProperties(
                eLocalDomainController,		    // local DC or GC
                pRequestContext,
 	            pwcsFullPathName,      // object name
                pguidIdentifier,      // unique id of object
                cp,
                aProp,
                apVar);
        if (SUCCEEDED(hr))
        {
            return(hr);
        }
        firstTry = FALSE;
    }
    if ( firstTry ||
        (pwcsPathName == NULL))
    {
        //
        //  We may get here:
        //  1) Computer's name == NULL ( in this case
        //     we didn't expand the queue name, and if it was not found on
        //     local-DC we try once more.
        //  2) Computer's name != NULL, and while expanding the queue name it was
        //     not found in the local-DC
        //

        hr = g_pDS->GetObjectProperties(
                dsProvider,		    // local DC or GC
                pRequestContext,
 	            pwcsFullPathName,      // object name
                pguidIdentifier,      // unique id of object
                cp,
                aProp,
                apVar);
    }

    //
    //  BUGBUG - to add return code filtering
    //
    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
    {
        return LogHR(MQDS_OBJECT_NOT_FOUND, s_FN, 240);
    }

    return LogHR(hr, s_FN, 250);

}

HRESULT MQADSpGetComputerProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT  apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    AP<WCHAR> pwcsFullPathName;
    HRESULT hr;


    DS_PROVIDER WhichDCProvider = eLocalDomainController; // either local-DC or DC

    if  (pwcsPathName)
    {
        //
        //  Get full computer pathname
        //

        hr =  MQADSpGetFullComputerPathName(
                        pwcsPathName,
                        e_RealComputerObject,
                        &pwcsFullPathName,
                        &WhichDCProvider
                        );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 260);
        }

    }
    hr = MQDS_OBJECT_NOT_FOUND;
    //
    //  BUGBUG - performance: to do impersonation only once
    //

    //
    //  if we found the computer on the local-DC : get properties from it.
    //  ( it doesn't matter if  dsProvider is GC or not)
    //
    if ( WhichDCProvider == eLocalDomainController)
    {
        hr = g_pDS->GetObjectProperties(
                eLocalDomainController,		    // local DC or GC
                pRequestContext,
 	            pwcsFullPathName,      // object name
                pguidIdentifier,      // unique id of object
                cp,
                aProp,
                apVar);
        if (SUCCEEDED(hr))
        {
            return(hr);
        }
    }
    hr = g_pDS->GetObjectProperties(
            eGlobalCatalog,		    // local DC or GC
            pRequestContext,
 	        pwcsFullPathName,      // object name
            pguidIdentifier,      // unique id of object
            cp,
            aProp,
            apVar);
    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
    {
        return LogHR(MQDS_OBJECT_NOT_FOUND, s_FN, 270);
    }

    return LogHR(hr, s_FN, 280);

}


HRESULT MQADSpGetEnterpriseProperties(
               IN  LPCWSTR          pwcsPathName,
               IN  const GUID *     pguidIdentifier,
               IN  DWORD            cp,
               IN  const PROPID     aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT      apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    HRESULT hr;

    //
    //  Note - pwcsPathName is ignored.
    //  Enterprise object is allways located
    //  under g_pwcsServicesContainer
    //
    //  Ignore  pguidIdentifier, this is done in order to over come
    //  changes of enterprise guid.
    //
    hr = g_pDS->GetObjectProperties(
            eLocalDomainController,	
            pRequestContext,
 	        g_pwcsMsmqServiceContainer, // object name
            NULL,      // unique id of object
            cp,
            aProp,
            apVar);
    return LogHR(hr, s_FN, 290);

}



HRESULT MQADSpQuerySiteFRSs(
                 IN  const GUID *         pguidSiteId,
                 IN  DWORD                dwService,
                 IN  ULONG                relation,
                 IN  const MQCOLUMNSET *  pColumns,
                 IN  CDSRequestContext *  pRequestContext,
                 OUT HANDLE         *     pHandle)
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    HRESULT hr;
    *pHandle = NULL;

    //
    //  Find all the FRSs under pguidSiteId site
    //
    MQRESTRICTION restrictionFRS;
    MQPROPERTYRESTRICTION   propertyRestriction;

    restrictionFRS.cRes = 1;
    restrictionFRS.paPropRes = &propertyRestriction;

    // [adsrv] start
    // The comment above is not exact - it is either finding FRSs, or finding DS servers.
    // To find FRSs, MSMQ1 uses PRGE with SERVICE_SRV
    // To find DS servers, MSMQ1 uses PRGT with SERVICE_SRV.
    // Explorer used also PRNE, but MSMQ2 B2 ignored it and it was OK, so ignoring too.
    // We must provide both.

    propertyRestriction.rel = PRNE;
    propertyRestriction.prval.ulVal = 0;   //VARIANT_BOOL boolVal
    propertyRestriction.prval.vt = VT_UI1;

    if (relation == PRGT)
    {
        // MSMQ1 was looking for DS Servers (>SERVICE_SRV)
        ASSERT(dwService == SERVICE_SRV);
        propertyRestriction.prop = PROPID_SET_SERVICE_DSSERVER;
    }
    else
    {
        // MSMQ1 was looking for FRSs (>=SERVICE_SRV)
        ASSERT(relation == PRGE);
        ASSERT(dwService == SERVICE_SRV);
        propertyRestriction.prop = PROPID_SET_SERVICE_ROUTING;
    }
    // [adsrv] end
    UNREFERENCED_PARAMETER( dwService);

    PROPID  prop = PROPID_SET_QM_ID;

    HANDLE hCursor;

    hr = g_pDS->LocateBegin(
            eSubTree,	
            eLocalDomainController,
            pRequestContext,
            pguidSiteId,
            &restrictionFRS,
            NULL,
            1,
            &prop,
            &hCursor	        // result handle
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 300);
    }
    //
    // keep the result for lookup next
    //
    CRoutingServerQueryHandle * phQuery = new CRoutingServerQueryHandle(
                                              pColumns,
                                              hCursor,
                                              pRequestContext->GetRequesterProtocol()
                                              );
    *pHandle = (HANDLE)phQuery;

    return(MQ_OK);

}



HRESULT MQADSpFilterSiteGates(
              IN  const GUID *      pguidSiteId,
              IN  const DWORD       dwNumGatesToFilter,
              IN  const GUID *      pguidGatesToFilter,
              OUT DWORD *           pdwNumGatesFiltered,
              OUT GUID **           ppguidGatesFiltered
              )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{

    HRESULT hr;
    *pdwNumGatesFiltered = 0;
    *ppguidGatesFiltered = NULL;

    //
    //  Find all the FRSs under pguidSiteId site
    //
    MQRESTRICTION restrictionFRS;
    MQPROPERTYRESTRICTION   propertyRestriction;

    restrictionFRS.cRes = 1;
    restrictionFRS.paPropRes = &propertyRestriction;

    propertyRestriction.rel = PRNE;
    propertyRestriction.prop = PROPID_SET_SERVICE_ROUTING;
    propertyRestriction.prval.vt = VT_UI1;
    propertyRestriction.prval.ulVal = 0;

    PROPID  prop = PROPID_SET_QM_ID;

    CDsQueryHandle hCursor;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = g_pDS->LocateBegin(
            eSubTree,	
            eLocalDomainController,
            &requestDsServerInternal,     // should be performed according to DS server rights
            pguidSiteId,
            &restrictionFRS,
            NULL,
            1,
            &prop,
            hCursor.GetPtr()
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 310);
    }

    DWORD cp;
    MQPROPVARIANT var;
    DWORD   dwNumGates = 0;
    AP<GUID> pguidGates = new GUID[ dwNumGatesToFilter];

    while (SUCCEEDED(hr))
    {
        //
        //  retrieve unique id of one FRS
        //
        cp = 1;
        var.vt = VT_NULL;
        hr = g_pDS->LocateNext(
                hCursor.GetHandle(),
                &requestDsServerInternal,
                &cp,
                &var
                );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 320);
        }
        if ( cp == 0)   // no more results
        {
            break;
        }
        //
        //  is the FRS one of the site-gates
        //
        for ( DWORD j = 0; j < dwNumGatesToFilter; j++)
        {
            if( pguidGatesToFilter[j] == *var.puuid)
            {
                //
                //  verify that the msmq-setting object is not a duplicate
                //  ( this can happen, when the server object is morphed)
                //
                BOOL fAlreadyFound = FALSE;
                for ( DWORD k = 0; k < dwNumGates; k++)
                {
                    if (  pguidGates[k] == *var.puuid)
                    {
                        fAlreadyFound = TRUE;
                        break;
                    }
                }
                if (fAlreadyFound)
                {
                    break;
                }
                //
                //  copy into temporary buffer
                //
                pguidGates[ dwNumGates] = *var.puuid;
                dwNumGates++;
                break;

            }
        }
        delete var.puuid;
    }
    //
    //  return results
    //
    if ( dwNumGates)
    {
        *ppguidGatesFiltered = new GUID[ dwNumGates];
        memcpy( *ppguidGatesFiltered, pguidGates, sizeof(GUID) * dwNumGates);
        *pdwNumGatesFiltered = dwNumGates;
    }
    return(MQ_OK);

}

STATIC HRESULT MQADSpGetUniqueIdOfComputer(
                IN  LPCWSTR             pwcsCNComputer,
                IN  CDSRequestContext * pRequestContext,
                OUT GUID* const         pguidId,
                OUT BOOL* const         pfServer,
                OUT DS_PROVIDER *       pSetAndDeleteProvider
                )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    HRESULT hr;
    AP<WCHAR> pwcsFullPathName;

    hr = MQADSpComposeFullPathName(
                MQDS_MACHINE,
                pwcsCNComputer,
                &pwcsFullPathName,
                pSetAndDeleteProvider
                );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 330);
    }
    //
    //  Read the following two properties
    //


    PROPID  prop[] = {PROPID_QM_MACHINE_ID,
                      PROPID_QM_SERVICE_ROUTING,
                      PROPID_QM_SERVICE_DSSERVER};   // [adsrv] PROPID_QM_SERVICE
    const DWORD x_count = sizeof(prop)/sizeof(prop[0]);

    MQPROPVARIANT var[x_count];
    var[0].vt = VT_NULL;
    var[1].vt = VT_NULL;
    var[2].vt = VT_NULL;

    hr = g_pDS->GetObjectProperties(
                eGlobalCatalog,	
                pRequestContext,
 	            pwcsFullPathName,
                NULL,
                x_count,
                prop,
                var);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 340);
    }
    ASSERT( prop[0] == PROPID_QM_MACHINE_ID);
    P<GUID> pClean = var[0].puuid;
    *pguidId = *var[0].puuid;
    ASSERT( prop[1] == PROPID_QM_SERVICE_ROUTING);   // [adsrv] PROPID_QM_SERVICE
    ASSERT( prop[2] == PROPID_QM_SERVICE_DSSERVER);
    *pfServer = ( (var[1].bVal!=0) || (var[2].bVal!=0));  // [adsrv] SERVICE_SRV
    return(MQ_OK);
}

HRESULT MQADSpDeleteMachineObject(
                IN LPCWSTR           pwcsPathName,
                IN const GUID *      pguidIdentifier,
                IN CDSRequestContext * pRequestContext
                )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    //
    //  If the computer is MSMQ server, then delete MSMQ-setting
    //  of that computer also.
    //
    HRESULT hr;
    GUID guidComputerId;
    BOOL fServer;

    DS_PROVIDER deleteProvider = eDomainController; // assumption - until we know more
    if ( pwcsPathName)
    {
        ASSERT( pguidIdentifier == NULL);
        CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr = MQADSpGetUniqueIdOfComputer(
                    pwcsPathName,
                    &requestDsServerInternal,     // DS server operation
                    &guidComputerId,
                    &fServer,
                    &deleteProvider
                    );
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADSpDeleteMachineObject : cannot find computer %ls"),pwcsPathName));
            return LogHR(hr, s_FN, 350);
        }
    }
    else
    {
        ASSERT( pwcsPathName == NULL);
        guidComputerId = *pguidIdentifier;
        //
        //  Assume it is a server
        //
        fServer = TRUE;
    }
    //
    //  BUGBUG - transaction !!!
    //

    //
    //  First delete queues
    //
    hr = g_pDS->DeleteContainerObjects(
            deleteProvider,
            e_RootDSE,
            pRequestContext,
            NULL,
            &guidComputerId,
            MSMQ_QUEUE_CLASS_NAME);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 360);
    }

    //
    //  delete MSMQ-configuration object
    //
    if (!(pRequestContext->IsKerberos()))
    {
        //
        // Wow, what's this for ???
        // look in DSCoreDeleteObject for details.
        //
        // Specific comments for uninstall of msmq:
        // When calling DeleteContainerObjects() above, we're binding with
        // guid, so use eDomainController, because server binding
        // (LDAP://server/guid=...) would eventually fail when calling
        // pContainer->Delete(queue).
        // But DeleteObject() use distinguished name, so here we must use
        // server binding if called from nt4 user.
        //
        deleteProvider = eLocalDomainController;
    }

    hr = g_pDS->DeleteObject(
                    deleteProvider,
                    e_RootDSE,
                    pRequestContext,
                    NULL,
                    &guidComputerId,
                    NULL /*pObjInfoRequest*/,
                    NULL /*pParentInfoRequest*/);
    if (FAILED(hr))
    {
        if ( hr == HRESULT_FROM_WIN32(ERROR_DS_CANT_ON_NON_LEAF))
        {
            return LogHR(MQDS_E_MSMQ_CONTAINER_NOT_EMPTY, s_FN, 370);
        }
        return LogHR(hr, s_FN, 380);
    }
    //
    //  delete MSMQ-setting
    //
    if ( fServer)
    {
        hr = MQADSpDeleteMsmqSetting(
                        &guidComputerId,
                        pRequestContext
                        );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 390);
        }
    }
    return(MQ_OK);
}

HRESULT MQADSpComposeFullPathName(
                IN const DWORD          dwObjectType,
                IN LPCWSTR              pwcsPathName,
                OUT LPWSTR *            ppwcsFullPathName,
                OUT DS_PROVIDER *       pSetAndDeleteProvider
                )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    HRESULT hr = MQ_OK;
    *ppwcsFullPathName = NULL;
    *pSetAndDeleteProvider = eDomainController;

    switch( dwObjectType)
    {
        case MQDS_USER:
            ASSERT( pwcsPathName == NULL);
            hr = MQ_OK;
            break;

        case MQDS_QUEUE:
            {
                //
                //  complete the machine name to full computer path name
                //
                //  Path name format is machine1\queue1.
                //  Split it into machine name and queue name
                //
                AP<WCHAR> pwcsMachineName;
                AP<WCHAR> pwcsQueueName;

                hr = MQADSpSplitAndFilterQueueName(
                                  pwcsPathName,
                                  &pwcsMachineName,
                                  &pwcsQueueName
                                  );
                ASSERT( hr == MQ_OK);
                AP<WCHAR> pwcsFullComputerName;

                hr = MQADSpGetFullComputerPathName(
                                pwcsMachineName,
                                e_MsmqComputerObject,
                                &pwcsFullComputerName,
                                pSetAndDeleteProvider);
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 400);
                }
                //
                //  concatenate msmq-configuration to the computer name
                //
                AP<WCHAR> pwcsMsmq;
                hr = MQADSpComposeName(
                        x_MsmqComputerConfiguration,
                        pwcsFullComputerName,
                        &pwcsMsmq
                        );
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 410);
                }
                //
                //  Does the queue-name exceeds the limit ?
                //
                DWORD len = wcslen(pwcsQueueName);
                if ( len == x_PrefixQueueNameLength + 1)
                {
                    //
                    //  Special case : we cannot differntiate
                    //  if the original queue name was 64, or if this is
                    //  the morphed queue name.
                    //

                    hr = MQADSpComposeFullQueueName(
                            pwcsMsmq,
                            pwcsQueueName,
                            ppwcsFullPathName
                            );
                    if (FAILED(hr))
                    {
                        return LogHR(hr, s_FN, 420);
                    }
                    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
                    hr = g_pDS->DoesObjectExists(
                                eDomainController,
                                e_RootDSE,
                                &requestDsServerInternal, // internal DS server operation
                                *ppwcsFullPathName
                                );
                    if (SUCCEEDED(hr))
                    {
                        return(hr);
                    }

                }
                if (len > x_PrefixQueueNameLength )
                {
                    //
                    //  Queue name was splitted to two attributes
                    //
                    //  Calculate the prefix part ( ASSUMMING unique
                    //  hash function)
                    //
                    DWORD dwHash = CalHashKey(pwcsQueueName);
                    //
                    //  Over-write the buffer
                    _snwprintf(
                    pwcsQueueName+( x_PrefixQueueNameLength + 1 - x_SplitQNameIdLength),
                    x_SplitQNameIdLength,
                    L"-%08x",
                    dwHash
                    );

                    pwcsQueueName[x_PrefixQueueNameLength + 1 ] = '\0';

                }

                //
                //  concatenate  queue name
                //
                hr = MQADSpComposeFullQueueName(
                            pwcsMsmq,
                            pwcsQueueName,
                            ppwcsFullPathName
                            );
            }
            break;
        case MQDS_MACHINE:
            {
                //
                //  Retrieve full computer name
                //
                AP<WCHAR> pwcsComputerName;
                hr = MQADSpGetFullComputerPathName(
                            pwcsPathName,
                            e_MsmqComputerObject,
                            &pwcsComputerName,
                            pSetAndDeleteProvider);
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 430);
                }
                hr =  MQADSpComposeName(
                            x_MsmqComputerConfiguration,
                            pwcsComputerName,
                            ppwcsFullPathName
                            );


            }
            break;

        case MQDS_SITE:
        case MQDS_CN:
            //
            // Full site path name.
            // MQDS_CN is supported for update of security of foreign sites.
            //
            hr =   MQADSpComposeName(
                        pwcsPathName,
                        g_pwcsSitesContainer,       // the site name
                        ppwcsFullPathName
                        );
            *pSetAndDeleteProvider = eLocalDomainController;
            break;

        case MQDS_ENTERPRISE:
            {
                DWORD len = lstrlen( g_pwcsMsmqServiceContainer);
                *ppwcsFullPathName = new WCHAR[ len + 1];
                lstrcpy( *ppwcsFullPathName,  g_pwcsMsmqServiceContainer);
                *pSetAndDeleteProvider = eLocalDomainController;
                hr = MQ_OK;
            }
            break;
        case MQDS_SITELINK:
            {
                DWORD Length =
                        x_CnPrefixLen +                     // "CN="
                        wcslen(pwcsPathName) +              // the site-link name
                        1 +                                 //","
                        wcslen(g_pwcsMsmqServiceContainer)+ // "enterprise object"
                        1;                                  // '\0'

                *ppwcsFullPathName = new WCHAR[Length];

                swprintf(
                    *ppwcsFullPathName,
                    L"%s"             // "CN="
                    L"%s"             // "the site-link name"
                    TEXT(",")
                    L"%s",            // "enterprise object"
                    x_CnPrefix,
                    pwcsPathName,
                    g_pwcsMsmqServiceContainer
                    );

                *pSetAndDeleteProvider = eLocalDomainController;
                hr = MQ_OK;
            };
            break;


        default:
            ASSERT(0);
            hr = MQ_ERROR;
            break;
    }
    return LogHR(hr, s_FN, 440);
}

const WCHAR x_limitedChars[] = {L'\n',L'/',L'#',L'>',L'<', L'=', 0x0a, 0};
const DWORD x_numLimitedChars = sizeof(x_limitedChars)/sizeof(WCHAR) - 1;

/*====================================================
    FilterSpecialCharaters()
    Pares the object (queue) name and add escape character before limited chars

    If pwcsOutBuffer is NULL, the function allocates a new buffer and return it as
    return value. Otherwise, it uses pwcsOutBuffer, and return it. If pwcsOutBuffer is not
    NULL, it should point to a buffer of lenght dwNameLength*2 +1, at least.

  NOTE: dwNameLength does not contain existing escape characters, if any
=====================================================*/
WCHAR * FilterSpecialCharacters(
            IN     LPCWSTR          pwcsObjectName,
            IN     const DWORD      dwNameLength,
            IN OUT LPWSTR pwcsOutBuffer /* = 0 */,
            OUT    DWORD_PTR* pdwCharactersProcessed /* = 0 */)

{
    AP<WCHAR> pBufferToRelease;
    LPWSTR pname;

    if (pwcsOutBuffer != 0)
    {
        pname = pwcsOutBuffer;
    }
    else
    {
        pBufferToRelease = new WCHAR[ (dwNameLength *2) + 1];
        pname = pBufferToRelease;
    }

    const WCHAR * pInChar = pwcsObjectName;
    WCHAR * pOutChar = pname;
    for ( DWORD i = 0; i < dwNameLength; i++, pInChar++, pOutChar++)
    {
        //
        // Ignore current escape characters
        //
        if (*pInChar == L'\\')
        {
            *pOutChar = *pInChar;
            pOutChar++;
            pInChar++;
        }
        else
        {
            //
            // Add backslash before special characters, unless it was there
            // already.
            //
            if ( 0 != wcschr(x_limitedChars, *pInChar))
            {
                *pOutChar = L'\\';
                pOutChar++;
            }
        }

        *pOutChar = *pInChar;
    }
    *pOutChar = L'\0';

    pBufferToRelease.detach();

    if (pdwCharactersProcessed != 0)
    {
        *pdwCharactersProcessed = pInChar - pwcsObjectName;
    }
    return( pname);
}


HRESULT MQADSpSplitAndFilterQueueName(
                IN  LPCWSTR             pwcsPathName,
                OUT LPWSTR *            ppwcsMachineName,
                OUT LPWSTR *            ppwcsQueueName
                )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    DWORD dwLen = lstrlen( pwcsPathName);
    LPCWSTR pChar= pwcsPathName + dwLen;


    //
    //  Skip the queue name
    //
    for ( DWORD i = dwLen ; i  ; i--, pChar--)
    {
        if (*pChar == PN_DELIMITER_C)
        {
            break;
        }
    }
    ASSERT(i );

    AP<WCHAR> pwcsMachineName = new WCHAR [i + 1];

    memcpy( pwcsMachineName, pwcsPathName, sizeof(WCHAR)* i);
    pwcsMachineName[i] = '\0';

    AP<WCHAR> pwcsQueueName = FilterSpecialCharacters((pwcsPathName + i + 1), dwLen - i - 1);


    *ppwcsMachineName = pwcsMachineName.detach();
    *ppwcsQueueName = pwcsQueueName.detach();
    return(MQ_OK);
}

//+----------------------------------------------
//
//  HRESULT SearchFullComputerPathName()
//
//+----------------------------------------------

HRESULT SearchFullComputerPathName(
            IN  DS_PROVIDER             provider,
            IN  enumComputerObjType     eComputerObjType,
			IN	LPCWSTR					pwcsComputerDnsName,
            IN  LPCWSTR                 pwcsRoot,
            IN  const MQRESTRICTION *   pRestriction,
            IN  PROPID *                pProp,
            OUT LPWSTR *                ppwcsFullPathName
            )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    HRESULT hr2 = g_pDS->FindComputerObjectFullPath(
            provider,
            eComputerObjType,
			pwcsComputerDnsName,
            pRestriction,
            ppwcsFullPathName
            );
    return LogHR(hr2, s_FN, 450);

}



HRESULT MQADSpGetFullComputerPathName(
                IN  LPCWSTR              pwcsComputerName,
                IN  enumComputerObjType  eComputerObjType,
                OUT LPWSTR *             ppwcsFullPathName,
                OUT DS_PROVIDER *        pCreateProvider
                )
/*++

Routine Description:

Arguments:
    eComputerObjType - indicate which computer object we're looking for.
      There is a "built-in" problem in mix-mode, or when a computer move
      between domains, that you may find two computers objects that represent
      the same single physical computer. In most cases, the msmqConfiguration
      object will be found under the computer object that was the first one
      created in the active directory forest.
      In that case, sometimes we need the object that contain the
      msmqConfiguration object and some other times we need the "real"
      computer object that represent the "real" physical computer in its
      present domain.
      For example- when looking for the "trust-for-delegation" bit, we want
      the "real" object, while when creating queues, we look for the computer
      object that contain the msmqConfiguration object.


Return Value:
    pProvider - if the object was found when performing the query
                against the local DC : eLocalDomainController,
                else eDomainController. This information is for create purposes.
--*/
{
    HRESULT hr;
    *pCreateProvider = eLocalDomainController;
    const WCHAR * pwcsComputerCN =  pwcsComputerName;
    const WCHAR * pwcsFullDNSName = NULL;
    AP<WCHAR> pwcsNetbiosName;
    //
    //   If computer name is specified in DNS format:
    //      perform a query according to the Netbios part of the computer
	//		dns name
    //
    //	 In both cases the query is comparing the netbios name + $
	//	to the samAccountName attribute of computer objects

    WCHAR * pwcsEndMachineCN = wcschr( pwcsComputerName, L'.');
    //
    //  Is the computer name is specified in DNS format
    //
    DWORD len, len1;
    if (pwcsEndMachineCN != NULL)
    {
        pwcsFullDNSName = pwcsComputerName;
        len1 = numeric_cast<DWORD>(pwcsEndMachineCN - pwcsComputerName);
    }
	else
    {
		len1 = wcslen(pwcsComputerCN);
    }

    //
    // The PROPID_COM_SAM_ACCOUNT contains the first MAX_COM_SAM_ACCOUNT_LENGTH (19)
    // characters of the computer name, as unique ID. (6295 - ilanh - 03-Jan-2001)
    //
    len = __min(len1, MAX_COM_SAM_ACCOUNT_LENGTH);

	pwcsNetbiosName = new WCHAR[len + 2];
	wcsncpy(pwcsNetbiosName, pwcsComputerName, len);
	pwcsNetbiosName[len] = L'$';
	pwcsNetbiosName[len + 1] = L'\0';

    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;
    propRestriction.prval.vt = VT_LPWSTR;
	propRestriction.prval.pwszVal = pwcsNetbiosName;
    propRestriction.prop = PROPID_COM_SAM_ACCOUNT;

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;

    PROPID prop = PROPID_COM_FULL_PATH;

    //
    //  First perform the operation against the local domain controller
    //  then against the global catalog.
    //
    //  The purpose of this is to be able to "find" queue or machine
    //  that were created or modified on the local domain, and not
    //  yet replicated to the global catalog.
    //
    hr = SearchFullComputerPathName(
            eLocalDomainController,
            eComputerObjType,
			pwcsFullDNSName,
            g_pwcsLocalDsRoot,
            &restriction,
            &prop,
            ppwcsFullPathName
            );
    if (FAILED(hr))
    {
        hr = SearchFullComputerPathName(
                eGlobalCatalog,
                eComputerObjType,
				pwcsFullDNSName,
                g_pwcsDsRoot,
                &restriction,
                &prop,
                ppwcsFullPathName
                );


        *pCreateProvider = eDomainController;
    }
    return LogHR(hr, s_FN, 460);

}

HRESULT MQADSpComposeFullQueueName(
                        IN  LPCWSTR        pwcsMsmqConfigurationName,
                        IN  LPCWSTR        pwcsQueueName,
                        OUT LPWSTR *       ppwcsFullPathName
                        )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    //
    //  compose a distinguished name of a queue object
    //  format : CN=queue-name, msmq-configuration-distinguished name
    //

    DWORD LenComputer = lstrlen(pwcsMsmqConfigurationName);
    DWORD LenQueue = lstrlen(pwcsQueueName);
    DWORD Length =
            x_CnPrefixLen +                     // "CN="
            LenQueue +                          // "pwcsQueueName"
            1 +                                 //","
            LenComputer +                       // "pwcsMsmqConfigurationName"
            1;                                  // '\0'

    *ppwcsFullPathName = new WCHAR[Length];

    swprintf(
        *ppwcsFullPathName,
        L"%s"             // "CN="
        L"%s"             // "pwcsQueueName"
        TEXT(",")
        L"%s",            // "pwcsFullComputerNameName"
        x_CnPrefix,
        pwcsQueueName,
        pwcsMsmqConfigurationName
        );

    return(MQ_OK);

}




HRESULT MQADSpInitDsPathName()
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    HRESULT hr;
    AP<WCHAR> pwcsSchemaContainer;

    hr = g_pDS->GetRootDsName(
        &g_pwcsDsRoot,
        &g_pwcsLocalDsRoot,
        &pwcsSchemaContainer
        );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 470);
    }
    //
    //  build services, sites and msmq-service path names
    //
    DWORD len = wcslen( g_pwcsDsRoot);

    g_pwcsConfigurationContainer = new WCHAR[ len +  x_ConfigurationPrefixLen + 2];
    swprintf(
        g_pwcsConfigurationContainer,
         L"%s"
         TEXT(",")
         L"%s",
        x_ConfigurationPrefix,
        g_pwcsDsRoot
        );


    g_pwcsServicesContainer = new WCHAR[ len +  x_ServiceContainerPrefixLen + 2];
    swprintf(
        g_pwcsServicesContainer,
         L"%s"
         TEXT(",")
         L"%s",
        x_ServicesContainerPrefix,
        g_pwcsDsRoot
        );

    g_pwcsMsmqServiceContainer = new WCHAR[ len + x_MsmqServiceContainerPrefixLen + 2];
    swprintf(
        g_pwcsMsmqServiceContainer,
         L"%s"
         TEXT(",")
         L"%s",
        x_MsmqServiceContainerPrefix,
        g_pwcsDsRoot
        );

    g_pwcsSitesContainer = new WCHAR[ len +  x_SitesContainerPrefixLen + 2];

    swprintf(
        g_pwcsSitesContainer,
         L"%s"
         TEXT(",")
         L"%s",
        x_SitesContainerPrefix,
        g_pwcsDsRoot
        );

    //
    //  prepare the different object category names
    //
    len = wcslen( pwcsSchemaContainer);


    for ( DWORD i = e_MSMQ_COMPUTER_CONFIGURATION_CLASS; i < e_MSMQ_NUMBER_OF_CLASSES; i++)
    {
        *g_MSMQClassInfo[i].ppwcsObjectCategory = new WCHAR[ len + g_MSMQClassInfo[i].dwCategoryLen + 2];
        swprintf(
             *g_MSMQClassInfo[i].ppwcsObjectCategory,
             L"%s"
             TEXT(",")
             L"%s",
             g_MSMQClassInfo[i].pwcsCategory,
             pwcsSchemaContainer
            );
    }


    return(MQ_OK);
}



HRESULT MQADSpFilterAdsiHResults(
                         IN HRESULT hrAdsi,
                         IN DWORD   dwObjectType)
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    switch ( hrAdsi)
    {
        case HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS):
        case HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS):  //BUGBUG alexdad to throw after transition
        {
        //
        //  Object exists
        //
            switch( dwObjectType)
            {
            case MQDS_QUEUE:
                return LogHR(MQ_ERROR_QUEUE_EXISTS, s_FN, 480);
                break;
            case MQDS_SITELINK:
                return LogHR(MQDS_E_SITELINK_EXISTS, s_FN, 490);
                break;
            case MQDS_USER:
                return LogHR(MQ_ERROR_INTERNAL_USER_CERT_EXIST, s_FN, 500);
                break;
            case MQDS_MACHINE:
            case MQDS_MSMQ10_MACHINE:
                return LogHR(MQ_ERROR_MACHINE_EXISTS, s_FN, 510);
                break;
            case MQDS_COMPUTER:
                return LogHR(MQDS_E_COMPUTER_OBJECT_EXISTS, s_FN, 520);
                break;
            default:
                return LogHR(hrAdsi, s_FN, 530);
                break;
            }
        }
        break;

        case HRESULT_FROM_WIN32(ERROR_DS_DECODING_ERROR):
        case HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT):
        {
        //
        //  Object not found
        //
            switch( dwObjectType)
            {
            case MQDS_QUEUE:
                return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 540);
                break;
           case MQDS_MACHINE:
           case MQDS_MSMQ10_MACHINE:
                return LogHR(MQ_ERROR_MACHINE_NOT_FOUND, s_FN, 550);
                break;
            default:
                return LogHR(MQDS_OBJECT_NOT_FOUND, s_FN, 560);
                break;
            }
        }
        break;

        case E_ADS_BAD_PATHNAME:
        {
            //
            //  wrong pathname
            //
            switch( dwObjectType)
            {
            case MQDS_QUEUE:
                //
                // creating queue with not allowed chars
                //
                return LogHR(MQ_ERROR_ILLEGAL_QUEUE_PATHNAME, s_FN, 570);
                break;

            default:
                return LogHR(hrAdsi, s_FN, 580);
                break;
            }

        }
        break;

        case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
            return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 590);

            break;

        //
        // This is an internal warning that should not be returned out of the DS.
        // Returning it will cause NT4 Explorer to fail (Bug 3778, YoelA, 3-Jan-99)
        //
        case MQSec_I_SD_CONV_NOT_NEEDED:
            return(MQ_OK);
            break;

        default:
            return LogHR(hrAdsi, s_FN, 600);
            break;
    }
}


HRESULT  MQADSpDeleteMsmqSetting(
              IN const GUID *        pguidComputerId,
              IN CDSRequestContext * pRequestContext
              )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    //
    //  Find the distinguished name of the msmq-setting
    //
    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;
    propRestriction.prop = PROPID_SET_QM_ID;
    propRestriction.prval.vt = VT_CLSID;
    propRestriction.prval.puuid = const_cast<GUID*>(pguidComputerId);

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;

    PROPID prop = PROPID_SET_FULL_PATH;

    CDsQueryHandle hQuery;
    HRESULT hr;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = g_pDS->LocateBegin(
            eSubTree,	
            eLocalDomainController,	
            &requestDsServerInternal,     // internal DS server operation
            NULL,
            &restriction,
            NULL,
            1,
            &prop,
            hQuery.GetPtr());
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADSpDeleteMsmqSetting : Locate begin failed %lx"),hr));
        return LogHR(hr, s_FN, 610);
    }
    //
    //  Read the results ( choose the first one)
    //

    DWORD cp = 1;
    MQPROPVARIANT var;
	HRESULT hr1 = MQ_OK;


    while (SUCCEEDED(hr))
	{
		var.vt = VT_NULL;

		hr  = g_pDS->LocateNext(
					hQuery.GetHandle(),
					&requestDsServerInternal,
					&cp,
					&var
					);
		if (FAILED(hr))
		{
			DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADSpDeleteMsmqSetting : Locate next failed %lx"),hr));
            return LogHR(hr, s_FN, 620);
		}
		if ( cp == 0)
		{
			//
			//  Not found -> nothing to delete.
			//
			return(MQ_OK);
		}
		AP<WCHAR> pClean = var.pwszVal;
		//
		//  delete the msmq-setting object
		//
		hr1 = g_pDS->DeleteObject(
						eLocalDomainController,
						e_ConfigurationContainer,
						pRequestContext,
						var.pwszVal,
						NULL,
						NULL /*pObjInfoRequest*/,
						NULL /*pParentInfoRequest*/
						);
		if (FAILED(hr1))
		{
			//
			//	just report it, and continue to next object
			//
			DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADSpDeleteMsmqSetting : failed to delete %ls, hr = %lx"),var.pwszVal,hr1));
		}
	}

    return LogHR(hr1, s_FN, 630);
}


DS_PROVIDER MQADSpDecideComputerProvider(
             IN  const DWORD   cp,
             IN  const PROPID  aProp[  ]
             )
/*++

Routine Description:
    The routine decides to retrieve the computer
    properties from the domain-controller or the
    global catalog.

Arguments:
    cp :    number of propids on aProp parameter
    aProp : array of PROPIDs

Return Value:
    the DS_PROVIDER on which to perform the retrieve
    operation

--*/
{
    const MQTranslateInfo* pTranslateInfo;
    const PROPID * pProp = aProp;

    for ( DWORD i = 0; i < cp; i++, pProp++)
    {
        if (g_PropDictionary.Lookup( *pProp, pTranslateInfo))
        {
            if ((!pTranslateInfo->fPublishInGC) &&
                 (pTranslateInfo->vtDS != ADSTYPE_INVALID))
            {
                return( eDomainController);
            }
        }
        else
        {
            ASSERT(0);
        }
    }
    return( eGlobalCatalog);
}


HRESULT MQADSpCreateComputer(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  const DWORD        cpEx,
                 IN  const PROPID       aPropEx[  ],
                 IN  const PROPVARIANT  apVarEx[  ],
                 IN  CDSRequestContext *pRequestContext,
                 OUT WCHAR            **ppwcsFullPathName
                 )
/*++

Routine Description:
    The routine creates computer object in the DS.
    Falcon creates computer object:
    1. During setup of Win95, if there isn't a computer
       object. Or setup of computer that belong to a nt4 domain so its
       computer object is not in the win2k active directory.
    2. During migration ( stub-computer objects) for
       computers that aren't in the DS.
    3. During replication between NT4 and Win2K (replication service).
    4. For Cluster virtual server.

Arguments:
    cp :    number of propids on aProp and apVar parameter
    aProp : array of PROPIDs
    apVar : array of propvariant
    cpEx  : number of extended aPropEx and apVarEx
    aPropEx : array of PROPIDs
    apVarEx : array of propvariants
    pRequestContext:
    ppwcsFullPathName:

Return Value:
    the DS_PROVIDER on which to perform the retrieve
    operation

--*/
{
    //
    //  The user can specify ( in the extended props) the
    //  container under which the computer object will be created
    //
    LPCWSTR  pwcsParentPathName;
    if ( cpEx > 0)
    {
        ASSERT( cpEx == 1);
        ASSERT( aPropEx[0] == PROPID_COM_CONTAINER);
        ASSERT( apVarEx[0].vt == VT_LPWSTR);
        if (aPropEx[0] !=  PROPID_COM_CONTAINER)
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 640);
        }
        pwcsParentPathName = apVarEx[0].pwszVal;
    }
    else
    {
        //
        //  we create the computer object in default container
        //
        static WCHAR * s_pwcsComputersContainer = NULL;
        if ( s_pwcsComputersContainer == NULL)
        {
            DWORD len = wcslen( g_pwcsLocalDsRoot) + x_ComputersContainerPrefixLength + 2;
            s_pwcsComputersContainer = new WCHAR [len];
            swprintf(
                s_pwcsComputersContainer,
                L"%s"             // "CN=Computers"
                TEXT(",")
                L"%s",            // g_pwcsDsRoot
                x_ComputersContainerPrefix,
                g_pwcsLocalDsRoot
                );
        }
        pwcsParentPathName =  s_pwcsComputersContainer;
    }

    //
    //  verify that  PROPID_COM_ACCOUNT_CONTROL is one of the properties
    //  if not add it ( otherwise MMC display red X on the computer
    //  object
    //
    BOOL fNeedToAddAccountControl = TRUE;
    for (DWORD i = 0; i < cp; i++)
    {
        if ( aProp[i] == PROPID_COM_ACCOUNT_CONTROL)
        {
            fNeedToAddAccountControl = FALSE;
            break;
        }
    }
    DWORD dwCreateNum = cp;
    PROPID * pCreateProps = const_cast<PROPID *>(aProp);
    PROPVARIANT * pCreateVar = const_cast<PROPVARIANT *>(apVar);

    AP<PROPID> pNewProps;
    AP<PROPVARIANT> pNewVars;

    if ( fNeedToAddAccountControl)
    {
        pNewProps = new PROPID[ cp + 1];
        pNewVars = new PROPVARIANT[ cp + 1];
        memcpy( pNewProps, aProp, sizeof(PROPID) * cp);
        memcpy( pNewVars, apVar, sizeof(PROPVARIANT) * cp);
        //
        //  Set  PROPID_COM_ACCOUNT_CONTROL
        //
        pNewProps[ cp] = PROPID_COM_ACCOUNT_CONTROL;
        pNewVars[ cp].vt = VT_UI4;
        pNewVars[ cp].ulVal =  DEFAULT_COM_ACCOUNT_CONTROL;
        dwCreateNum = cp + 1;
        pCreateProps = pNewProps;
        pCreateVar = pNewVars;
    }

    DS_PROVIDER dsProvider = eDomainController ;
    if (!(pRequestContext->IsKerberos()))
    {
        //
        // Wow, what's that for ???
        // look in DSCoreDeleteObject for details.
        //
        dsProvider = eLocalDomainController ;
    }

    HRESULT hr = g_pDS->CreateObject(
            dsProvider,
            pRequestContext,
            MSMQ_COMPUTER_CLASS_NAME,
            pwcsPathName,
            pwcsParentPathName,
            dwCreateNum,
            pCreateProps,
            pCreateVar,
            NULL /* pObjInfoRequest*/,
            NULL /* pParentInfoRequest*/);

    if (FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS))
    {
        return LogHR(hr, s_FN, 650);
    }

    //
    //  Get full path name
    //
    AP<WCHAR> pFullPathName;
    hr = MQADSpComposeName(pwcsPathName, pwcsParentPathName, &pFullPathName);

    if (SUCCEEDED(hr))
    {
        //
        // Grant the user creating the computer account the permission to
        // create child object (msmqConfiguration). that was done by the
        // DS itself by default up to beta3, and then disabled.
        // Ignore errors. If caller is admin, then the security setting
        // is not needed. If he's a non-admin, then you can always use
        // mmc and grant this permission manually. so go on even if this
        // call fail.
        //
        HRESULT hr1 = DSCoreSetOwnerPermission( pFullPathName,
                        (ACTRL_DS_CREATE_CHILD | ACTRL_DS_DELETE_CHILD) ) ;
        ASSERT(SUCCEEDED(hr1)) ;
        LogHR(hr1, s_FN, 48);

        if (ppwcsFullPathName != NULL)
        {
            (*ppwcsFullPathName) = pFullPathName.detach();
        }
    }

    return LogHR(hr, s_FN, 655);
}


HRESULT MQADSpTranslateLinkNeighbor(
                 IN  const GUID *    pguidSiteId,
                 IN  CDSRequestContext *pRequestContext,
                 OUT WCHAR**         ppwcsSiteDn)
/*++

Routine Description:
    The routine trnslate site id to site-DN.

Arguments:
    pguidSiteId:        the site id
    ppwcsSiteDn:        the site DN

Return Value:
    DS error codes

--*/
{
    PROPID prop = PROPID_S_FULL_NAME;
    PROPVARIANT var;

    var.vt = VT_NULL;
    HRESULT hr = g_pDS->GetObjectProperties(
                    eLocalDomainController,	
                    pRequestContext,
 	                NULL,      // object name
                    pguidSiteId,      // unique id of object
                    1,
                    &prop,
                    &var);
    if (SUCCEEDED(hr))
    {
        *ppwcsSiteDn= var.pwszVal;
    }
    return LogHR(hr, s_FN, 660);
}


HRESULT MQADSpCreateSite(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  const DWORD        /*cpEx*/,
                 IN  const PROPID *      /*aPropEx[  ]*/,
                 IN  const PROPVARIANT*  /*apVarEx[  ]*/,
                 IN  CDSRequestContext *pRequestContext
                 )
/*++

Routine Description:
    This routine creates a site.

Arguments:

Return Value:
--*/
{
    HRESULT hr;

    hr = g_pDS->CreateObject(
            eLocalDomainController,
            pRequestContext,
            MSMQ_SITE_CLASS_NAME,   // object class
            pwcsPathName,     // object name
            g_pwcsSitesContainer,
            cp,
            aProp,
            apVar,
            NULL /*pObjInfoRequest*/,
            NULL /*pParentInfoRequest*/);

   return LogHR(hr, s_FN, 670);
}


HRESULT  MQADSpDeleteMsmqSettingOfServerInSite(
              IN const GUID *        pguidComputerId,
              IN const WCHAR *       pwcsSite
              )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{

    //
    //  Find the distinguished name of the msmq-setting
    //
    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;
    propRestriction.prop = PROPID_SET_QM_ID;
    propRestriction.prval.vt = VT_CLSID;
    propRestriction.prval.puuid = const_cast<GUID*>(pguidComputerId);

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;

    PROPID prop = PROPID_SET_FULL_PATH;

    CDsQueryHandle hQuery;
    HRESULT hr;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = g_pDS->LocateBegin(
            eSubTree,	
            eLocalDomainController,	
            &requestDsServerInternal,     // internal DS server operation
            NULL,
            &restriction,
            NULL,
            1,
            &prop,
            hQuery.GetPtr());
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADSpDeleteMsmqSetting : Locate begin failed %lx"),hr));
        return LogHR(hr, s_FN, 680);
    }
    //
    //  Read the results ( choose the first one)
    //
    while ( SUCCEEDED(hr))
    {
        DWORD cp = 1;
        MQPROPVARIANT var;
        var.vt = VT_NULL;

        hr = g_pDS->LocateNext(
                    hQuery.GetHandle(),
                    &requestDsServerInternal,
                    &cp,
                    &var
                    );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 690);
        }
        if ( cp == 0)
        {
            //
            //  Not found -> nothing to delete.
            //
            return(MQ_OK);
        }
        AP<WCHAR> pClean = var.pwszVal;
        //
        //  Get the parent, which is the server object
        //
        AP<WCHAR> pwcsServerName;
        hr = g_pDS->GetParentName(
            eLocalDomainController,
            e_SitesContainer,
            &requestDsServerInternal,
            var.pwszVal,
            &pwcsServerName);
        if (FAILED(hr))
        {
            continue;
        }
        AP<WCHAR> pwcsServer;

        hr = g_pDS->GetParentName(
            eLocalDomainController,
            e_SitesContainer,
            &requestDsServerInternal,
            pwcsServerName,
            &pwcsServer);
        if (FAILED(hr))
        {
            continue;
        }
        //
        //  Get site name
        //
        AP<WCHAR> pwcsSiteDN;

        hr = g_pDS->GetParentName(
            eLocalDomainController,
            e_SitesContainer,
            &requestDsServerInternal,
            pwcsServer,
            &pwcsSiteDN);
        if (FAILED(hr))
        {
            continue;
        }

        //
        //  Is it the correct site
        //
        DWORD len = wcslen(pwcsSite);
        if ( (!wcsncmp( pwcsSiteDN + x_CnPrefixLen, pwcsSite, len)) &&
             ( pwcsSiteDN[ x_CnPrefixLen + len] == L',') )
        {

            //
            //  delete the msmq-setting object
            //
            hr = g_pDS->DeleteObject(
                            eLocalDomainController,
                            e_ConfigurationContainer,
                            &requestDsServerInternal,
                            var.pwszVal,
                            NULL,
                            NULL /*pObjInfoRequest*/,
                            NULL /*pParentInfoRequest*/
                            );
            break;
        }
    }

    return LogHR(hr, s_FN, 700);
}



HRESULT MQADSpSetMachinePropertiesWithSitesChange(
            IN  const  DWORD         dwObjectType,
            IN  DS_PROVIDER          provider,
            IN  CDSRequestContext *  pRequestContext,
            IN  LPCWSTR              lpwcsPathName,
            IN  const GUID *         pguidUniqueId,
            IN  const DWORD          cp,
            IN  const PROPID *       pPropIDs,
            IN  const MQPROPVARIANT *pPropVars,
            IN  DWORD                dwSiteIdsIndex,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest
            )
/*++

Routine Description:
    This routine creates a site.

Arguments:

Return Value:
--*/
{
    //
    //  First let's verify that this is a server and the
    //  current sites it belongs to
    //
    const DWORD cNum = 6;
    PROPID prop[cNum] = { PROPID_QM_SERVICE_DSSERVER,
                          PROPID_QM_SERVICE_ROUTING,
                          PROPID_QM_SITE_IDS,
                          PROPID_QM_MACHINE_ID,
                          PROPID_QM_PATHNAME,
                          PROPID_QM_OLDSERVICE};
    PROPVARIANT var[cNum];
    var[0].vt = VT_NULL;
    var[1].vt = VT_NULL;
    var[2].vt = VT_NULL;
    var[3].vt = VT_NULL;
    var[4].vt = VT_NULL;
    var[5].vt = VT_NULL;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    HRESULT hr1 =  g_pDS->GetObjectProperties(
            eLocalDomainController,		
            &requestDsServerInternal,
 	        lpwcsPathName,
            pguidUniqueId,
            cNum,
            prop,
            var);
    if (FAILED(hr1))
    {
        hr1 =  g_pDS->GetObjectProperties(
            eGlobalCatalog,		
            &requestDsServerInternal,
 	        lpwcsPathName,
            pguidUniqueId,
            cNum,
            prop,
            var);
        if (FAILED(hr1))
        {
            return LogHR(hr1, s_FN, 710);
        }
    }
    AP<GUID> pguidOldSiteIds = var[2].cauuid.pElems;
    DWORD dwNumOldSites = var[2].cauuid.cElems;
    P<GUID> pguidMachineId = var[3].puuid;
    AP<WCHAR> pwcsMachineName = var[4].pwszVal;
    BOOL fNeedToOrganizeSettings = FALSE;

    if ( var[0].bVal > 0 ||   // ds server
         var[1].bVal > 0)     // routing server
    {
        fNeedToOrganizeSettings = TRUE;
    }

    //
    //  Set the machine properties
    //
    HRESULT hr;
    hr = g_pDS->SetObjectProperties(
                    provider,
                    pRequestContext,
                    lpwcsPathName,
                    pguidUniqueId,
                    cp,
                    pPropIDs,
                    pPropVars,
                    pObjInfoRequest
                    );

    MQADSpFilterAdsiHResults( hr, dwObjectType);

    if ( FAILED(hr) ||
         !fNeedToOrganizeSettings)
    {
        return LogHR(hr, s_FN, 720);
    }

    //
    //  Compare the old and new site lists
    //  and delete or create msmq-settings accordingly
    //
    GUID * pguidNewSiteIds = pPropVars[dwSiteIdsIndex].cauuid.pElems;
    DWORD dwNumNewSites = pPropVars[dwSiteIdsIndex].cauuid.cElems;

    for (DWORD i = 0; i <  dwNumNewSites; i++)
    {
        //
        //  Is it a new site
        //
        BOOL fOldSite = FALSE;
        for (DWORD j = 0; j < dwNumOldSites; j++)
        {
            if (pguidNewSiteIds[i] == pguidOldSiteIds[j])
            {
                fOldSite = TRUE;
                //
                // to indicate that msmq-setting should be left in this site
                //
                pguidOldSiteIds[j] = GUID_NULL;
                break;
            }
        }
        if ( !fOldSite)
        {
            //
            //  create msmq-setting in this new site
            //
            hr1 = MQADSpCreateMachineSettings(
                        1,  // number sites
                        &pguidNewSiteIds[i], // site guid
                        pwcsMachineName,
                        var[1].bVal > 0, // fRouter
                        var[0].bVal > 0, // fDSServer
                        TRUE,            // fDepClServer
                        TRUE,            // fSetQmOldService
                        var[5].ulVal,    // dwOldService
                        pguidMachineId,
                        0,               // cpEx
                        NULL,            // aPropEx
                        NULL,            // apVarEx
                        &requestDsServerInternal
                        );
            //
            //  ignore the error
			//	
			//	For foreign site this operation will always fail, because
			//	we don't create servers container and server objects for foreign sites.
			//
			//	For non-foreign sites, we just try the best we can.
            //
        }
    }
    //
    //  Go over th list of old site and for each old site that
    //  is not in-use, delete the msmq-settings
    //
    for ( i = 0; i < dwNumOldSites; i++)
    {
        if (pguidOldSiteIds[i] != GUID_NULL)
        {
            PROPID propSite = PROPID_S_PATHNAME;
            PROPVARIANT varSite;
            varSite.vt = VT_NULL;

            hr1 = g_pDS->GetObjectProperties(
                        eLocalDomainController,		
                        &requestDsServerInternal,
 	                    NULL,
                        &pguidOldSiteIds[i],
                        1,
                        &propSite,
                        &varSite);
            if (FAILED(hr1))
            {
                ASSERT(SUCCEEDED(hr1));
                LogHR(hr1, s_FN, 1611);
                continue;
            }
            AP<WCHAR> pCleanSite = varSite.pwszVal;

            //
            //  delete the msmq-setting in this site
            //
            hr1 = MQADSpDeleteMsmqSettingOfServerInSite(
                        pguidMachineId,
                        varSite.pwszVal
                        );
            ASSERT(SUCCEEDED(hr1));
            LogHR(hr1, s_FN, 1612);

        }
    }

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\mqcuser.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mqcuser.cpp

Abstract:

    MQDSCORE library,
    private internal functions for DS operations of user objects.

Author:

    ronit hartmann (ronith)

--*/
#include "ds_stdh.h"
#include <_propvar.h>
#include "mqadsp.h"
#include "dsads.h"
#include "mqattrib.h"
#include "mqads.h"
#include "usercert.h"
#include "adstempl.h"
#include "coreglb.h"
#include "adserr.h"
#include "dsutils.h"
#include <aclapi.h>
#include "..\..\mqsec\inc\permit.h"

#include "mqcuser.tmh"

static WCHAR *s_FN=L"mqdscore/mqcuser";

//+-------------------------------------
//
//  HRESULT _LocateUserByProvider()
//
//+-------------------------------------

STATIC HRESULT _LocateUserByProvider(
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  CDSRequestContext *pRequestContext,
                 IN  DS_PROVIDER     eDSProvider,
                 OUT PROPVARIANT    *pvar,
                 OUT DWORD          *pdwNumofProps,
                 OUT BOOL           *pfUserFound )
{
    *pfUserFound = FALSE ;
    CDsQueryHandle hCursor;

    HRESULT hr = g_pDS->LocateBegin(
            eSubTree,	
            eDSProvider,
            pRequestContext,
            NULL,
            pRestriction,
            NULL,
            pColumns->cCol,
            pColumns->aCol,
            hCursor.GetPtr()
            );
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
          "_LocateUserByProvider: LocateBegin(prov- %lut) failed, hr- %lx"),
                                          (ULONG) eDSProvider, hr)) ;
        return LogHR(hr, s_FN, 10);
    }
    //
    //  read the user certificate attribute
    //
    DWORD cp = 1;
    DWORD *pcp = pdwNumofProps ;
    if (!pcp)
    {
        pcp = &cp ;
    }

    pvar->vt = VT_NULL;

    hr =  g_pDS->LocateNext(
                hCursor.GetHandle(),
                pRequestContext,
                pcp,
                pvar
                );
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
            "_LocateUserByProvider: LocateNext() failed, hr- %lx"), hr));
        return LogHR(hr, s_FN, 20);
    }

	if (*pcp == 0)
	{
		//
		// Didn't find any certificate.
		//
		pvar->blob.cbSize = 0 ;
		pvar->blob.pBlobData = NULL ;
	}
    else
    {
        *pfUserFound = TRUE ;
    }

    return (MQ_OK);
}
//+------------------------------------------------------------------------
//
//  HRESULT LocateUser()
//
// Input Parameters:
//   IN  BOOL  fOnlyLocally- TRUE if caller want to locate the user object
//      only locally, in local replica of domain controller. that feature
//      is used when handling NT4 machines or users that do not support
//      Kerberos and can not delegate to other domain controllers.
//
//+------------------------------------------------------------------------

HRESULT LocateUser( IN  BOOL               fOnlyLocally,
                    IN  BOOL               fOnlyInGC,
                    IN  MQRESTRICTION     *pRestriction,
                    IN  MQCOLUMNSET       *pColumns,
                    IN  CDSRequestContext *pRequestContext,
                    OUT PROPVARIANT       *pvar,
                    OUT DWORD             *pdwNumofProps,
                    OUT BOOL              *pfUserFound )
{
    //
    // first query in local domain conroller.
    //
    DWORD dwNumOfProperties = 0 ;
    if (pdwNumofProps)
    {
        dwNumOfProperties = *pdwNumofProps;
    }
    BOOL fUserFound ;
    BOOL *pfFound = pfUserFound ;
    if (!pfFound)
    {
        pfFound = &fUserFound ;
    }
    *pfFound = FALSE ;

    DS_PROVIDER  eDSProvider = eLocalDomainController ;
    if (fOnlyInGC)
    {
        eDSProvider = eGlobalCatalog ;
    }

    HRESULT hr = _LocateUserByProvider( pRestriction,
                                        pColumns,
                                        pRequestContext,
                                        eDSProvider,
                                        pvar,
                                        pdwNumofProps,
                                        pfFound ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }
    else if (*pfFound)
    {
        return LogHR(hr, s_FN, 40);
    }
    else if (fOnlyLocally || fOnlyInGC)
    {
        //
        // Don't look (again) in Global Catalog.
        // Search only in local domain controller, or ONLY in GC. done!
        //
        return LogHR(hr, s_FN, 50);
    }

    //
    // If user not found in local domain controller, then query GC.
    //
    if (pdwNumofProps)
    {
        *pdwNumofProps = dwNumOfProperties;
    }
    hr = _LocateUserByProvider( pRestriction,
                                pColumns,
                                pRequestContext,
                                eGlobalCatalog,
                                pvar,
                                pdwNumofProps,
                                pfFound ) ;
    return LogHR(hr, s_FN, 60);
}


HRESULT FindUserAccordingToSid(
                IN  BOOL            fOnlyLocally,
                IN  BOOL            fOnlyInGC,
                IN  BLOB *          pblobUserSid,
                IN  PROPID          propSID,
                IN  DWORD           dwNumProps,
                IN  const PROPID *  propToRetrieve,
                IN OUT PROPVARIANT* varResults
                )
/*++

Routine Description:
    The routine finds a user or MQUser object according to SID, and retrieves
    the requested properties

Arguments:
    pblobUserSid - the user SID


Return Value:
    The status of the ds operation.

--*/
{
    //
    // Only one of these two flags can be true.
    //
    ASSERT(!(fOnlyLocally && fOnlyInGC)) ;

    //
    //  Find the user object according to its SID
    //
    HRESULT hr;
    MQRESTRICTION restriction;
    MQPROPERTYRESTRICTION propertyRestriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propertyRestriction;
    propertyRestriction.rel = PREQ;
    propertyRestriction.prop = propSID;
    propertyRestriction.prval.vt = VT_BLOB;
    propertyRestriction.prval.blob = *pblobUserSid;

    DWORD dwNumResults = dwNumProps ;
    BOOL fUserFound = FALSE ;
    MQCOLUMNSET  Columns = { dwNumProps,
                             const_cast<PROPID*> (propToRetrieve) } ;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = LocateUser( fOnlyLocally,
                     fOnlyInGC,
                     &restriction,
                     &Columns,
                     &requestDsServerInternal,
                     varResults,
                    &dwNumResults,
                    &fUserFound ) ;

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 70);
    }
    else if (!fUserFound)
    {
        //
        //  failed to find user object
        //
        return LogHR(MQDS_OBJECT_NOT_FOUND, s_FN, 80);
    }

    ASSERT(dwNumResults ==  dwNumProps);
    return(MQ_OK);
}

HRESULT FindUserAccordingToDigest(
                IN  BOOL            fOnlyLocally,
                IN  const GUID *    pguidDigest,
                IN  PROPID          propDigest,
                IN  DWORD           dwNumProps,
                IN  const PROPID *  propToRetrieve,
                IN OUT PROPVARIANT* varResults
                )
/*++

Routine Description:
    The routine finds a user object according to digest, and retrieves
    the requested properties

Arguments:


Return Value:
    The status of the ds operation.

--*/
{
    //
    //  Find the user object according to its digest
    //
    HRESULT hr;
    MQRESTRICTION restriction;
    MQPROPERTYRESTRICTION propertyRestriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propertyRestriction;
    propertyRestriction.rel = PREQ;
    propertyRestriction.prop = propDigest;
    propertyRestriction.prval.vt = VT_CLSID;
    propertyRestriction.prval.puuid = const_cast<GUID *>(pguidDigest);

    DWORD dwNumResults = dwNumProps ;
    BOOL fUserFound = FALSE ;
    MQCOLUMNSET  Columns = {dwNumProps,
                             const_cast<PROPID*> (propToRetrieve) } ;

    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate,
                                               e_IP_PROTOCOL );
    hr = LocateUser( fOnlyLocally,
                     FALSE, // fOnlyInGC
                    &restriction,
                     &Columns,
                     &requestDsServerInternal,
                     varResults,
                    &dwNumResults,
                    &fUserFound ) ;

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 90);
    }
    else if (!fUserFound)
    {
        //
        //  failed to find user object
        //
        return LogHR(MQDS_OBJECT_NOT_FOUND, s_FN, 100);
    }

    ASSERT(dwNumResults ==  dwNumProps);
    return(MQ_OK);
}

BOOL GetTextualSid(
    IN      PSID pSid,            // binary Sid
    IN      LPTSTR TextualSid,    // buffer for Textual representation of Sid
    IN OUT  LPDWORD lpdwBufferLen // required/provided TextualSid buffersize
    )
/*++

Routine Description:
    The routine translates a Sid to a textual string

Arguments:
    pSid        - the user SID
    TextualSid  - string buffer
    lpdwBufferLen - IN: buffer length, OUT string length

Return Value:

--*/
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    // Validate the binary SID.

    if(!IsValidSid(pSid)) return LogBOOL(FALSE, s_FN, 110);

    // Get the identifier authority value from the SID.

    psia = GetSidIdentifierAuthority(pSid);

    // Get the number of subauthorities in the SID.

    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    // Compute the buffer length.
    // S-SID_REVISION- + IdentifierAuthority- + subauthorities- + NULL

    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    // Check input buffer length.
    // If too small, indicate the proper size and set last error.

    if (*lpdwBufferLen < dwSidSize)
    {
        *lpdwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return LogBOOL(FALSE, s_FN, 120);
    }

    // Add 'S' prefix and revision number to the string.

    dwSidSize=wsprintf(TextualSid, TEXT("S-%lu-"), dwSidRev );

    // Add SID identifier authority to the string.

    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    }
    else
    {
        dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                    TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    // Add SID subauthorities to the string.
    //
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        dwSidSize+=wsprintf(TextualSid + dwSidSize, TEXT("-%lu"),
                    *GetSidSubAuthority(pSid, dwCounter) );
    }
    *lpdwBufferLen = dwSidSize;
    return TRUE;
}

STATIC HRESULT PrepareUserName(
                IN  PSID        pSid,
                OUT WCHAR **    ppwcsUserName
                               )
/*++

Routine Description:
    The routine prepare a name string for a mq-user object
    according to its sid

Arguments:
    pSid        - the user SID
    ppwcsUserName  - name string

Return Value:

--*/
{
    //
    //  First try to translate sid to user name
    //
    const DWORD  cLen = 512;
    WCHAR  szTextualSid[cLen ];
    DWORD  dwTextualSidLen = cLen ;
    //
    //  Translate the SID into a string
    //
    if (GetTextualSid(
        pSid,
        szTextualSid,
        &dwTextualSidLen
        ))
    {
        //
        //  return to the user the last 64 WCHARs ( length limit of cn attribute)
        //
        if ( dwTextualSidLen < 64)
        {
            *ppwcsUserName = new WCHAR[dwTextualSidLen + 1];
            wcscpy( *ppwcsUserName, szTextualSid);
        }
        else
        {
            *ppwcsUserName = new WCHAR[64 + 1];
            wcscpy( *ppwcsUserName, &szTextualSid[dwTextualSidLen - 64 - 1]);
        }
        return(MQ_OK);
    }
    else
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 140);
    }
}

//+--------------------------------
//
//  void  _PrepareCert()
//
//+--------------------------------

void  _PrepareCert(
            IN  PROPVARIANT * pvar,
            IN  GUID *        pguidDigest,
            IN  GUID *        pguidId,
            OUT BYTE**        ppbAllocatedCertBlob
            )
/*++

Routine Description:
    The routine prepares the certificate blob according to the structure
    that we keep in the DS

Arguments:

Return Value:

--*/
{
    ULONG ulUserCertBufferSize = CUserCert::CalcSize( pvar->blob.cbSize);
    AP<unsigned char> pBuffUserCert = new unsigned char[ ulUserCertBufferSize];

#ifdef _DEBUG
#undef new
#endif
    CUserCert * pUserCert = new(pBuffUserCert) CUserCert(
                                   *pguidDigest,
                                   *pguidId,
                                   pvar->blob.cbSize,
                                   pvar->blob.pBlobData);
    AP<BYTE> pbTmp;
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    pbTmp = new BYTE[ CUserCertBlob::CalcSize() + ulUserCertBufferSize ];
#ifdef _DEBUG
#undef new
#endif
    CUserCertBlob * pUserCertBlob = new(pbTmp) CUserCertBlob(
                                pUserCert);
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    pUserCertBlob->MarshaleIntoBuffer( pbTmp);
    pvar->blob.cbSize = CUserCertBlob::CalcSize() + ulUserCertBufferSize;
    *ppbAllocatedCertBlob = pbTmp;
    pvar->blob.pBlobData= pbTmp.detach();

}

//+----------------------------------
//
//   HRESULT _CreateMQUser()
//
//+----------------------------------

HRESULT _CreateMQUser(
            IN CDSRequestContext   *pRequestContext,
            IN LPCWSTR              pwcsUserName,       // object name
            IN LPCWSTR              pwcsParentPathName, // object parent name
            IN DWORD                cPropIDs,           // number of attributes
            IN const PROPID        *pPropIDs,           // attributes
            IN const MQPROPVARIANT *pPropVars )         // attribute values
{
    HRESULT hr = g_pDS->CreateObject( eLocalDomainController,
                                    pRequestContext,
                                    MSMQ_MQUSER_CLASS_NAME,
                                    pwcsUserName,
                                    pwcsParentPathName,
                                    cPropIDs,
                                    pPropIDs,
                                    pPropVars,
                                    NULL,    /* pObjInfoRequest*/
                                    NULL ) ; /* pParentInfoRequest*/
    return LogHR(hr, s_FN, 150);
}

//+------------------------------------------
//
//   HRESULT  MQADSpCreateMQUser()
//
//+------------------------------------------

HRESULT  MQADSpCreateMQUser(
                 IN  LPCWSTR            pwcsPathName,
                 IN  DWORD              dwIndexSidProp,
                 IN  DWORD              dwIndexCertProp,
                 IN  DWORD              dwIndexDigestProp,
                 IN  DWORD              dwIndexIdProp,
                 IN  const DWORD        cp,
                 IN  const PROPID       aPropIn[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  CDSRequestContext *pRequestContext
                                   )
{
    ASSERT(pwcsPathName == NULL);
	DBG_USED(pwcsPathName);

    //
    //  translate the SID into a user name
    //
    PSID pUserSid = apVar[ dwIndexSidProp].blob.pBlobData ;
    ASSERT(IsValidSid(pUserSid)) ;

    AP<WCHAR> pwcsUserName;
    HRESULT hr =  PrepareUserName( pUserSid,
                                  &pwcsUserName ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }
    AP<WCHAR> pwcsParentPathName =
              new WCHAR[ wcslen(g_pwcsLocalDsRoot) + x_msmqUsersOULen + 2] ;
    swprintf(
            pwcsParentPathName,
            L"%s,%s",
            x_msmqUsersOU,
            g_pwcsLocalDsRoot );
    //
    //  Prepare the certificate attribute
    //
    DWORD cNewProps = cp + 1 ;
    P<PROPID> pPropId = new PROPID[ cNewProps ] ;
    memcpy( pPropId, aPropIn, sizeof(PROPID) * cp);
    AP<PROPVARIANT> pvarTmp = new PROPVARIANT[ cNewProps ];
    memcpy( pvarTmp, apVar, sizeof(PROPVARIANT) * cp);

    AP<BYTE> pCleanBlob;
    _PrepareCert(
            &pvarTmp[dwIndexCertProp],
            pvarTmp[dwIndexDigestProp].puuid,
            pvarTmp[dwIndexIdProp].puuid,
            &pCleanBlob
            );

    //
    // Prepare security descriptor.
    // This code may be called from the upgrade wizard or replication service
    // so we can not impersonte in order to get user sid. Instead, we'll
    // create an input security descriptor that contain only the owner.
    //
    SECURITY_DESCRIPTOR sd ;
    BOOL fSec = InitializeSecurityDescriptor( &sd,
                                            SECURITY_DESCRIPTOR_REVISION ) ;
    ASSERT(fSec) ;
    fSec = SetSecurityDescriptorOwner( &sd, pUserSid, TRUE ) ;
    ASSERT(fSec) ;

    pPropId[ cp ] = PROPID_MQU_SECURITY ;
    PSECURITY_DESCRIPTOR psd = NULL ;

    hr =  MQSec_GetDefaultSecDescriptor( MQDS_MQUSER,
                                         &psd,
                                         FALSE, /* fImpersonate */
                                         &sd,
                                         (OWNER_SECURITY_INFORMATION |
                                          GROUP_SECURITY_INFORMATION),
                                         e_UseDefaultDacl ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 170);
    }
    ASSERT(psd && IsValidSecurityDescriptor(psd)) ;
    P<BYTE> pAutoDef = (BYTE*) psd ;
    pvarTmp[ cp ].blob.pBlobData = (BYTE*) psd ;
    pvarTmp[ cp ].blob.cbSize = GetSecurityDescriptorLength(psd) ;

    hr = _CreateMQUser( pRequestContext,
                        pwcsUserName,
                        pwcsParentPathName,
                        cNewProps,
                        pPropId,
                        pvarTmp ) ;

    if (hr == HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM))
    {
        //
        // Ignore the object guid when creating the msmqMigratedUser object.
        // Why don't I change this property in the first call ?
        // to avoid regressions.
        // Using the object guid is fine if we're running on a GC. Migration
        // code (both wizard and replication service) run on GC so they
        // should be fine with first call. Only msmq server on non-GC domain
        // controllers will see this problem, when users will try to register
        // certificate for the first time (when this object doesn't yet
        // exist). So for these cases, try again without the guid.
        //
        pPropId[ dwIndexIdProp ] = PROPID_QM_DONOTHING  ;

        hr = _CreateMQUser( pRequestContext,
                            pwcsUserName,
                            pwcsParentPathName,
                            cNewProps,
                            pPropId,
                            pvarTmp ) ;
    }

    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
    {
        //
        //  try to create msmqUsers ( it is probably not there)
        //  and try again to recreate the user
        //
        hr = g_pDS->CreateOU(
                eLocalDomainController,
                pRequestContext,
                x_msmqUsers,
                g_pwcsLocalDsRoot,
                L"Default container for MSMQ certificates of Windows NT 4.0 domain users");
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
               "mqcuser.cpp, Failed to create msmqUsers OU, hr- %lx"), hr)) ;

            return LogHR(hr, s_FN, 175);
        }

        hr = _CreateMQUser( pRequestContext,
                            pwcsUserName,
                            pwcsParentPathName,
                            cNewProps,
                            pPropId,
                            pvarTmp ) ;
    }

    return LogHR(hr, s_FN, 180);
}

//+---------------------------------------
//
//  HRESULT _DeleteUserObject()
//
//+---------------------------------------

STATIC  HRESULT _DeleteUserObject(
                        IN const GUID *         pDigest,
                        IN  CDSRequestContext  *pRequestContext,
                        IN  PROPID             *propIDs,
                        IN  PROPID              propDigest )
/*++

Routine Description:
    The routine deletes user object according to its digest

Arguments:
    pDigest - the digest of the user object to be deleted

Return Value:
    The status of the ds operation.

--*/
{
    HRESULT hr;
    //
    //  This routine deletes a user certificate according to its
    //  digest.
    //  A user object may contain multiple digests and certificates
    //

    //
    //  Find the user object
    //
    DWORD cp = 3;
    MQPROPVARIANT propvar[3];
    propvar[0].vt = VT_NULL;    // BUGBUG - to define a init routine
    propvar[1].vt = VT_NULL;
    propvar[2].vt = VT_NULL;

    hr =  FindUserAccordingToDigest(
                    FALSE,  // fOnlyLocally
                    pDigest,
                    propDigest,
                    cp,
                    propIDs,
                    propvar
                    );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 190);
    }

    ASSERT( propvar[0].vt == VT_CLSID);
    P<GUID> pguidUserId = propvar[0].puuid;

    ASSERT( propvar[1].vt == (VT_CLSID | VT_VECTOR));
    AP<GUID> pDigestArray = propvar[1].cauuid.pElems;

    ASSERT( propvar[2].vt == VT_BLOB);
    P<BYTE> pbyteCertificate = propvar[2].blob.pBlobData;

    if ( propvar[1].cauuid.cElems == 1)
    {
        //
        //  Last digest and certificate
        //
        propvar[1].cauuid.cElems = 0;
        propvar[2].blob.cbSize = 0;
    }
    else
    {
        BOOL fFoundDigest = FALSE;
        //
        //  remove the requested digest for the digest-vector
        //
        for ( DWORD i = 0 ; i < propvar[1].cauuid.cElems; i++)
        {
            if ( propvar[1].cauuid.pElems[i] == *pDigest)
            {
                fFoundDigest = TRUE;
                //
                //  found the entry to remove
                //
                for ( DWORD j = i + 1; j < propvar[1].cauuid.cElems; j++)
                {
                    propvar[1].cauuid.pElems[ j - 1] = propvar[1].cauuid.pElems[j];
                }
                break;
            }
        }
        propvar[1].cauuid.cElems--;
        ASSERT( fFoundDigest);
        //
        //  Remove the certificate
        //
        CUserCertBlob * pUserCertBlob =
            reinterpret_cast<CUserCertBlob *>( propvar[2].blob.pBlobData);

        DWORD dwSizeToRemoveFromBlob;
        hr = pUserCertBlob->RemoveCertificateFromBuffer(
                            pDigest,
                            propvar[2].blob.cbSize,
                            &dwSizeToRemoveFromBlob);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 200);
        }
        propvar[2].blob.cbSize -=  dwSizeToRemoveFromBlob;

    }

    //
    //  Update user properties with new values
    //
    hr =  g_pDS->SetObjectProperties(
                eDomainController,
                pRequestContext,
                NULL,             // object name
                pguidUserId,      // unique id of object
                2,
                &propIDs[1],
                &propvar[1],
                NULL /*pObjInfoRequest*/);

   return LogHR(hr, s_FN, 210);
}

//+----------------------------------------
//
//  HRESULT MQADSpDeleteUserObject()
//
//+----------------------------------------

HRESULT MQADSpDeleteUserObject(
                         IN const GUID *        pDigest,
                         IN CDSRequestContext  *pRequestContext
                         )
/*++

Routine Description:
    The routine deletes user object.
    It first tries to find the digest in USER object, and
    if not found it tries in MIGRATED-USER

Arguments:
    pDigest - the digest of the user object to be deleted
    pRequestContext - the requester context

Return Value:
    The status of the ds operation.

--*/
{
    //
    // First try to delete from a User object.
    //
    PROPID UserProp[3] = { PROPID_U_ID,
                           PROPID_U_DIGEST,
                           PROPID_U_SIGN_CERT};

    HRESULT hr = _DeleteUserObject( pDigest,
                                    pRequestContext,
                                    UserProp,
                                    PROPID_U_DIGEST) ;

    if (hr == MQDS_OBJECT_NOT_FOUND)
    {
        //
        // User objectnot found. Try computer object.
        //
        PROPID ComUserProp[3] = { PROPID_COM_ID,
                                  PROPID_COM_DIGEST,
                                  PROPID_COM_SIGN_CERT };
        //
        // try to find this object in the msmqUsers container
        //
        hr = _DeleteUserObject( pDigest,
                                pRequestContext,
                                ComUserProp,
                                PROPID_COM_DIGEST ) ;
    }

    if (hr == MQDS_OBJECT_NOT_FOUND)
    {
        //
        // Computer objectnot found. Try msmqUser object.
        //
        PROPID MQUserProp[3] = { PROPID_MQU_ID,
                                 PROPID_MQU_DIGEST,
                                 PROPID_MQU_SIGN_CERT };
        //
        // try to find this object in the msmqUsers container
        //
        hr = _DeleteUserObject( pDigest,
                                pRequestContext,
                                MQUserProp,
                                PROPID_MQU_DIGEST ) ;
    }

    return LogHR(hr, s_FN, 220);
}

//+-------------------------------------------
//
//  HRESULT _GetUserProperties()
//
//+-------------------------------------------

STATIC HRESULT _GetUserProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidDigest,
               IN  PROPID        propidDigest,
               IN  DWORD         cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * /*pRequestContext*/,
               OUT PROPVARIANT  apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    ASSERT( pwcsPathName == NULL);
    UNREFERENCED_PARAMETER( pwcsPathName);
    HRESULT hr;
    //
    //  Find the user object according to the digest
    //

    CAutoCleanPropvarArray propArray;
    MQPROPVARIANT * ppropvar = new MQPROPVARIANT[ cp];
    propArray.attachClean( cp, ppropvar);

    hr = FindUserAccordingToDigest(
                    FALSE,  // fOnlyLocally
                    pguidDigest,
                    propidDigest,
                    cp,
                    aProp,
                    ppropvar
                    );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 230);
    }
    //
    //  Is one of the properties is PROPID_U_SIGN_CERT ?
    //
    DWORD i;
    BOOL  fGetCert = FALSE;
    for ( i =0; i < cp; i++)
    {
        if ( aProp[i] == PROPID_U_SIGN_CERT   ||
             aProp[i] == PROPID_COM_SIGN_CERT ||
             aProp[i] == PROPID_MQU_SIGN_CERT)
        {
            fGetCert = TRUE;
            break;
        }
    }
    //
    //  Parse the user certificates array, and return only the certificate
    //  associate with the requested digest
    //
    if( fGetCert)
    {
        ASSERT( i < cp);
        CUserCertBlob * pUserCertBlob =
            reinterpret_cast<CUserCertBlob *>( ppropvar[i].blob.pBlobData);

        const CUserCert * pUserCert = NULL;
        hr = pUserCertBlob->GetUserCert( pguidDigest,
                                         &pUserCert );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 240);
        }
        hr = pUserCert->CopyIntoBlob(&apVar[i]);
        {
            if ( FAILED(hr))
            {
                return LogHR(hr, s_FN, 250);
            }
        }
    }

    //
    //  Copy the rest of proerties
    //
    for ( DWORD j = 0; j < cp; j++)
    {
        //
        //  don't copy the user cert property
        //
        if ( j != i)
        {
            apVar[j] = ppropvar[j];
            ppropvar[j].vt = VT_NULL;    // not to free allocated buffers
        }
    }


   return(MQ_OK);


}

//+-----------------------------------------
//
//  HRESULT MQADSpGetUserProperties()
//
//+-----------------------------------------

HRESULT MQADSpGetUserProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD         cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT  apVar[]
               )
/*++

Routine Description:
    The routine retrieve user object.
    It first tries to find the digest in USER object, and
    if not found it tries in MIGRATED-USER

Arguments:
    pDigest - the digest of the user object to be deleted
    pRequestContext - the requester context

Return Value:
    The status of the ds operation.

--*/
{
    //
    //  BUGBUG - performance : two impersonations
    //
    HRESULT hr = _GetUserProperties(
                        pwcsPathName,
                        pguidIdentifier,
                        PROPID_U_DIGEST,
                        cp,
                        aProp,
                        pRequestContext,
                        apVar
                        );

    if ( hr == MQDS_OBJECT_NOT_FOUND )
    {
        //
        // try to find it in a computer object.
        //
        // Change propid from _U_ property to _COM_
        // ( hack : object class is resolved according to the first propid)
        //
        AP<PROPID> tmpProp = new PROPID[ cp ];
        switch(aProp[0])
        {
            case PROPID_U_ID:
                tmpProp[0] = PROPID_COM_ID;
                break;
            case PROPID_U_DIGEST:
                tmpProp[0] = PROPID_COM_DIGEST;
                break;
            case PROPID_U_SIGN_CERT:
                tmpProp[0] = PROPID_COM_SIGN_CERT;
                break;
            case PROPID_U_SID:
                tmpProp[0] = PROPID_COM_SID;
                break;
            default:
                ASSERT(0);
                break;
        }

        for (DWORD i=1; i<cp; i++)
        {
            tmpProp[i] = aProp[i];
        }

        hr = _GetUserProperties(
                    pwcsPathName,
                    pguidIdentifier,
                    PROPID_COM_DIGEST,
                    cp,
                    tmpProp,
                    pRequestContext,
                    apVar
                    );
    }

    if ( hr == MQDS_OBJECT_NOT_FOUND )
    {
        //
        // try to find it in the msmqUsers container
        //
        // Change propid from _U_ property to _MQU_
        // ( hack : object class is resolved according to the first propid)
        //
        AP<PROPID> tmpProp = new PROPID[ cp ];
        switch(aProp[0])
        {
            case PROPID_U_ID:
                tmpProp[0] = PROPID_MQU_ID;
                break;
            case PROPID_U_DIGEST:
                tmpProp[0] = PROPID_MQU_DIGEST;
                break;
            case PROPID_U_SIGN_CERT:
                tmpProp[0] = PROPID_MQU_SIGN_CERT;
                break;
            case PROPID_U_SID:
                tmpProp[0] = PROPID_MQU_SID;
                break;
            default:
                ASSERT(0);
                break;
        }

        for (DWORD i=1; i<cp; i++)
        {
            tmpProp[i] = aProp[i];
        }

        hr = _GetUserProperties(
                    pwcsPathName,
                    pguidIdentifier,
                    PROPID_MQU_DIGEST,
                    cp,
                    tmpProp,
                    pRequestContext,
                    apVar
                    );
    }

    return LogHR(hr, s_FN, 260);
}

//+----------------------------------------
//
//   HRESULT  _CreateUserObject()
//
//+----------------------------------------

STATIC HRESULT  _CreateUserObject(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  CDSRequestContext *   pRequestContext
                 )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    ASSERT( pwcsPathName == NULL);
    UNREFERENCED_PARAMETER( pwcsPathName);
    //
    //  search the user according to its SID
    //
    DWORD dwNeedToFind = 3;
    BLOB blobUserSid;
    BLOB blobSignCert = {0, 0};
    GUID * pguidDigest = NULL;
    GUID * pguidId = NULL;  // if the caller doesn't supply it, use the digest as
                            // the id

    PROPID propSID = (PROPID)-1;
    for ( DWORD i = 0 ; i < cp; i++)
    {
        if ( (aProp[i] == PROPID_U_SID)    ||
             (aProp[i] == PROPID_COM_SID)  ||
             (aProp[i] == PROPID_MQU_SID) )
        {
            blobUserSid= apVar[i].blob;
            propSID = aProp[i];
            --dwNeedToFind;
        }
        if ( (aProp[i] == PROPID_U_SIGN_CERT)   ||
             (aProp[i] == PROPID_COM_SIGN_CERT) ||
             (aProp[i] == PROPID_MQU_SIGN_CERT) )
        {
            blobSignCert = apVar[i].blob;
            --dwNeedToFind;
        }
        if ( (aProp[i] == PROPID_U_DIGEST)   ||
             (aProp[i] == PROPID_COM_DIGEST) ||
             (aProp[i] == PROPID_MQU_DIGEST) )
        {
            pguidDigest = apVar[i].puuid;
            --dwNeedToFind;
        }
        if ( (aProp[i] == PROPID_U_ID)   ||
             (aProp[i] == PROPID_COM_ID) ||
             (aProp[i] == PROPID_MQU_ID) )
        {
            pguidId = apVar[i].puuid;
        }
    }

    PROPID propDigest = PROPID_U_DIGEST;
    if (propSID == PROPID_COM_SID)
    {
        propDigest = PROPID_COM_DIGEST;
    }
    else if (propSID == PROPID_MQU_SID)
    {
        propDigest = PROPID_MQU_DIGEST;
    }

    if ( dwNeedToFind != 0)
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("_CreateUserObject : Wrong input properties")));
        return LogHR(MQ_ERROR, s_FN, 270);
    }
    if ( pguidId == NULL)
    {
        //
        //  Use the digest as the id ( for replication to NT4 only)
        //
        pguidId = pguidDigest;
    }
    //
    //  Find the user object according to its SID
    //
    HRESULT hr;
    const DWORD cNumProperties = 3;
    PROPID prop[cNumProperties] = { propDigest,
                                    PROPID_U_SIGN_CERT,
                                    PROPID_U_ID};
    MQPROPVARIANT var[ cNumProperties];
    var[0].vt = VT_NULL;
    var[1].vt = VT_NULL;
    var[2].vt = VT_NULL;
    ASSERT( cNumProperties == 3);

    hr =  FindUserAccordingToSid(
                 FALSE,  // fOnlyLocally
                 FALSE,  // fOnlyInGC
                &blobUserSid,
                propSID,
                cNumProperties,
                prop,
                var
                );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 280);
    }
    AP<GUID> pCleanDigest =  var[0].cauuid.pElems;
    AP<BYTE> pCleanCert = var[1].blob.pBlobData;
    P<GUID> pCleanId =  var[2].puuid;

    //
    // Check if it's a new user certificate or one that is already registered.
    // Control panel code first try to register old certificate (to verify
    // that user indeed has write permission in the active directory to do
    // that) and only then create a new certificate and register it. So
    // this case (trying to register an existing certificate) is legitimate
    // and mqrt.dll + control panel handle it correctly.
    //
    DWORD dwSize = var[0].cauuid.cElems;
    for ( DWORD j = 0; j < dwSize; j++)
    {
        if ( pCleanDigest[j] == *pguidDigest)
        {
            return LogHR(MQDS_CREATE_ERROR, s_FN, 290); // for compatability : RT translates to MQ_ERROR_INTERNAL_USER_CERT_EXIST
        }
    }

    //
    //  Now add the digest and certificate to the array of values
    //
    //
    //  First digest array
    //
    AP<GUID> pGuids = new GUID[ dwSize  + 1];
    if ( dwSize)
    {
        memcpy( pGuids, pCleanDigest, dwSize * sizeof(GUID));  // old array content
    }
    memcpy( &pGuids[ dwSize], pguidDigest, sizeof(GUID));    // new addition
    var[0].cauuid.cElems += 1;
    var[0].cauuid.pElems = pGuids;
    //
    //  Second user certificate
    //
    ASSERT( prop[1] == PROPID_U_SIGN_CERT);

    dwSize = var[1].blob.cbSize;
    ULONG ulUserCertBufferSize = CUserCert::CalcSize( blobSignCert.cbSize);
    AP<unsigned char> pBuffUserCert = new unsigned char[ ulUserCertBufferSize];

#ifdef _DEBUG
#undef new
#endif
    CUserCert * pUserCert = new(pBuffUserCert) CUserCert(
                                   *pguidDigest,
                                   *pguidId,
                                   blobSignCert.cbSize,
                                   blobSignCert.pBlobData);
    AP<BYTE> pbTmp;
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    if ( dwSize)
    {
        pbTmp = new BYTE[ dwSize + ulUserCertBufferSize];
        //
        //  there are already certificates for this user
        //
        CUserCertBlob * pUserCertBlob =
            reinterpret_cast<CUserCertBlob *>( var[1].blob.pBlobData);

        pUserCertBlob->IncrementNumCertificates();
        memcpy( pbTmp, var[1].blob.pBlobData, dwSize);
        pUserCert->MarshaleIntoBuffer( &pbTmp[ dwSize]);
        var[1].blob.cbSize = dwSize + ulUserCertBufferSize;

    }
    else
    {
        pbTmp = new BYTE[ CUserCertBlob::CalcSize() + ulUserCertBufferSize ];
#ifdef _DEBUG
#undef new
#endif
        CUserCertBlob * pUserCertBlob = new(pbTmp) CUserCertBlob(
                                    pUserCert);
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

        pUserCertBlob->MarshaleIntoBuffer( pbTmp);
        var[1].blob.cbSize = CUserCertBlob::CalcSize() + ulUserCertBufferSize;

    }

    var[1].blob.pBlobData = pbTmp;

    //
    //  Update the user object with the new values
    //
    hr = g_pDS->SetObjectProperties(
                eDomainController,
                pRequestContext,
                NULL,
                var[2].puuid,      // unique id of this user
                2,
                prop,
                var,
                NULL /*pObjInfoRequest*/);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADSpCreateUser : failed to update user props %lx"),hr));
    }
    return LogHR(hr, s_FN, 300);
}

//+------------------------------------
//
//  HRESULT MQADSpCreateUserObject()
//
//  Register a certificate.
//
//+------------------------------------

HRESULT MQADSpCreateUserObject(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  CDSRequestContext *   pRequestContext
                 )
{
    //
    // First try "standard" user objects.
    //
    HRESULT hr = _CreateUserObject(
                         pwcsPathName,
                         cp,
                         aProp,
                         apVar,
                         pRequestContext
                         );
    if (hr !=  MQDS_OBJECT_NOT_FOUND)
    {
        return LogHR(hr, s_FN, 310);
    }

    for (DWORD i = 0 ; i < cp ; i++ )
    {
        if (aProp[i] == PROPID_COM_SID)
        {
            //
            // Computer object for registering a certificate from service
            // must be found in the Active Directory. If not found, it's
            // a weird error. quit !
            //
            return LogHR(hr, s_FN, 320);
        }
    }

    //
    // try to find the user object in the msmqUsers container
    //
    // create new PROPID array with PROPID_MQU_* property
    // instead of PROPID_U_*
    //
    DWORD dwSIDPropNum = cp;
    DWORD dwCertPropNum = cp;
    DWORD dwDigestPropNum = cp;
    DWORD dwIdPropNum = cp;
    AP<PROPID> tmpProp = new PROPID[ cp ];
    for ( i=0; i<cp; i++)
    {
        switch ( aProp[i])
        {
            case PROPID_U_SID:
                dwSIDPropNum = i;
                tmpProp[i] = PROPID_MQU_SID;
                break;
            case PROPID_U_SIGN_CERT:
                dwCertPropNum = i;
                tmpProp[i] = PROPID_MQU_SIGN_CERT;
                break;
            case PROPID_U_MASTERID:
                tmpProp[i] = PROPID_MQU_MASTERID;
                break;
            case PROPID_U_SEQNUM:
                tmpProp[i] = PROPID_MQU_SEQNUM;
                break;
            case PROPID_U_DIGEST:
                dwDigestPropNum = i;
                tmpProp[i] = PROPID_MQU_DIGEST;
                break;
            case PROPID_U_ID:
                dwIdPropNum = i;
                tmpProp[i] = PROPID_MQU_ID;
                break;
            default:
                ASSERT(0);
                break;
        }
    }

    if ( (dwSIDPropNum == cp) || (dwDigestPropNum == cp) ||
         (dwIdPropNum == cp) ||  (dwCertPropNum == cp))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("MQADSpCreateUser : Wrong input properties")));
        return LogHR(MQ_ERROR, s_FN, 330);
    }
    hr = _CreateUserObject(
                     pwcsPathName,
                     cp,
                     tmpProp,
                     apVar,
                     pRequestContext
                     );
    if ( hr !=  MQDS_OBJECT_NOT_FOUND)
    {
        return LogHR(hr, s_FN, 340);
    }
    //
    //  No User or MQUser object were found ( for this SID).
    //  We assume it is a NT4 user and we'll create MQUser for
    //  it (in which we'll store the certificates).
    //  Creating the msmqMigratedUser (and its OU) are done in the context
    //  of the msmq service (or migration code), not in the context of the
    //  user. That's similar to regular Windows 2000 users, that are not the
    //  owner of their user object and have no permissions on that object.
    //
    CDSRequestContext RequestContextOU ( e_DoNotImpersonate,
                                         e_ALL_PROTOCOLS ) ;
    hr = MQADSpCreateMQUser(
                     pwcsPathName,
                     dwSIDPropNum,
                     dwCertPropNum,
                     dwDigestPropNum,
                     dwIdPropNum,
                     cp,
                     tmpProp,
                     apVar,
                     &RequestContextOU
                     );
    return LogHR(hr, s_FN, 350);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\mqcsite.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mqcsite.cpp

Abstract:

    MQDSCORE library,
    private internal functions for DS queries of site objects.

Author:

    ronit hartmann (ronith)  (first version in mqadsp.cpp)
    Doron Juster   (DoronJ)  split files and add sign key query.

--*/

#include "ds_stdh.h"
#include <_propvar.h>
#include "mqadsp.h"
#include "dsads.h"
#include "mqattrib.h"
#include "mqads.h"
#include "usercert.h"
#include "hquery.h"
#include "siteinfo.h"
#include "adstempl.h"
#include "coreglb.h"
#include "adserr.h"
#include "dsutils.h"
#include "dscore.h"

#include "mqcsite.tmh"

static WCHAR *s_FN=L"mqdscore/mqcsite";

//+-------------------------------------
//
//  HRESULT MQADSpGetSiteProperties()
//
//+-------------------------------------

HRESULT MQADSpGetSiteProperties(
               IN  LPCWSTR       pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD         cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT   apVar[] )
{
    AP<WCHAR> pwcsFullPathName;
    HRESULT hr;

    if (pwcsPathName)
    {
        //
        //  Path name format is machine1\queue1.
        //  expand machine1 name to a full computer path name
        //
        DS_PROVIDER not_in_use_provider;

        hr =  MQADSpComposeFullPathName(
                        MQDS_SITE,
                        pwcsPathName,
                        &pwcsFullPathName,
                        &not_in_use_provider );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 10);
        }
    }

    hr = g_pDS->GetObjectProperties(
            eLocalDomainController,		    // local DC or GC
            pRequestContext,
 	        pwcsFullPathName,      // object name
            pguidIdentifier,      // unique id of object
            cp,
            aProp,
            apVar);
    return LogHR(hr, s_FN, 20);

}


HRESULT MQADSpGetSiteLinkProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT  apVar[]
               )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    HRESULT hr;

    AP<WCHAR> pwcsFullPathName;

    if  (pwcsPathName)
    {
        //
        //  expand link name to a full DN name
        //
        DS_PROVIDER not_in_use_provider;

        hr =  MQADSpComposeFullPathName(
                MQDS_SITELINK,
                pwcsPathName,
                &pwcsFullPathName,
                &not_in_use_provider
                );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 30);
        }
    }

    hr = g_pDS->GetObjectProperties(
            eLocalDomainController,
            pRequestContext,
 	        pwcsFullPathName,
            pguidIdentifier,      // unique id of object
            cp,
            aProp,
            apVar);
    return LogHR(hr, s_FN, 40);
}

HRESULT MQADSpGetSiteGates(
                 IN  const GUID * pguidSiteId,
                 IN  CDSRequestContext * /*pRequestContext*/,
                 OUT DWORD *      pdwNumSiteGates,
                 OUT GUID **      ppaSiteGates
                 )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    //
    //  Is it my site
    //
    if ( g_pMySiteInformation->IsThisSite(pguidSiteId))
    {
        //
        //  return the list of session concentration site-gates
        //  ( i.e. site-gates that belong to this site only)
        //  on any of this site links
        //
        HRESULT hr2 = g_pMySiteInformation->FillSiteGates(
                pdwNumSiteGates,
                ppaSiteGates
                );
        return LogHR(hr2, s_FN, 50);
    }

    //
    //  another site
    //
    *pdwNumSiteGates = 0;
    *ppaSiteGates = NULL;
    CSiteGateList SiteGateList;
    HRESULT hr;
    //
    //  Translate site guid into its DN name
    //
    PROPID prop = PROPID_S_FULL_NAME;
    PROPVARIANT var;
    var.vt = VT_NULL;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    hr = g_pDS->GetObjectProperties(
                eLocalDomainController,
                &requestDsServerInternal,     // internal operation of the DS server
 	            NULL,      // object name
                pguidSiteId,      // unique id of object
                1,
                &prop,
                &var);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("MQADSpGetSiteGates : Failed to retrieve the DN of the site %lx"),hr));
        return LogHR(hr, s_FN, 60);
    }
    AP<WCHAR> pwcsSiteDN = var.pwszVal;


    //
    //  retrieve all site-gates where this site
    //  is specified as neighbor-1
    //
    CDSRequestContext requestDsServerInternal1( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr =  MQADSpQueryNeighborLinks(
                        eLinkNeighbor1,
                        pwcsSiteDN,
                        &requestDsServerInternal,     // internal operation of the DS server
                        &SiteGateList
                        );
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("MQADSpGetSiteGates : Failed to query neighbor1 links %lx"),hr));
        return LogHR(hr, s_FN, 70);

    }

    //
    //  retrieve all site-gates where this site
    //  is specified as neighbor-2
    //
    CDSRequestContext requestDsServerInternal2( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr =  MQADSpQueryNeighborLinks(
                        eLinkNeighbor2,
                        pwcsSiteDN,
                        &requestDsServerInternal2,     // internal operation of the DS server
                        &SiteGateList
                        );
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("MQADSpGetSiteGates : Failed to query neighbor2 links %lx"),hr));
        return LogHR(hr, s_FN, 80);

    }

    //
    //  Fill in the results
    //
    AP<GUID> pguidLinkSiteGates;
    DWORD dwNumLinkSiteGates = 0;

    SiteGateList.CopySiteGates(
               &pguidLinkSiteGates,
               &dwNumLinkSiteGates
               );

    if ( dwNumLinkSiteGates == 0)
    {
        *pdwNumSiteGates = 0;
        *ppaSiteGates = NULL;
        return(MQ_OK);
    }
    //
    //  Filter the list of site-gates,
    //  and return only gates that belong
    //  to the requested site ( they may
    //  belong to more than one site)
    //
    hr = MQADSpFilterSiteGates(
            pguidSiteId,
            dwNumLinkSiteGates,
            pguidLinkSiteGates,
            pdwNumSiteGates,
            ppaSiteGates
            );
    return LogHR(hr, s_FN, 90);

}

//+----------------------------------
//
// HRESULT MQADSpGetSiteName()
//
//+----------------------------------

HRESULT MQADSpGetSiteName(
                IN const GUID *     pguidSite,
                OUT LPWSTR *        ppwcsSiteName )
{

    //
    //  Find site
    //
    MQRESTRICTION restrictionSite;
    MQPROPERTYRESTRICTION   propertyRestriction;

    restrictionSite.cRes = 1;
    restrictionSite.paPropRes = &propertyRestriction;

    propertyRestriction.rel = PREQ;
    propertyRestriction.prop = PROPID_S_SITEID;
    propertyRestriction.prval.vt = VT_CLSID;
    propertyRestriction.prval.puuid = const_cast<GUID*>(pguidSite);

    PROPID  prop = PROPID_S_FULL_NAME;

    CDsQueryHandle  hQuery;
    HRESULT hr;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = g_pDS->LocateBegin(
            eSubTree,	
            eLocalDomainController,
            &requestDsServerInternal,     // internal DS server operation
            NULL,
            &restrictionSite,
            NULL,
            1,
            &prop,
            hQuery.GetPtr()
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100);
    }
    DWORD cp = 1;
    MQPROPVARIANT var;
    var.vt = VT_NULL;

    hr = g_pDS->LocateNext(
                hQuery.GetHandle(),
                &requestDsServerInternal,
                &cp,
                &var);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 110);
    }

    ASSERT( cp == 1);
    ASSERT( var.vt == VT_LPWSTR);

    *ppwcsSiteName = var.pwszVal;
    return( MQ_OK);
}

HRESULT MQADSpTranslateGateDn2Id(
        IN  const PROPVARIANT*  pvarGatesDN,
        OUT GUID **      ppguidLinkSiteGates,
        OUT DWORD *      pdwNumLinkSiteGates
        )
/*++

Routine Description:
    This routine translate PROPID_L_GATES_DN into unique-id array
    of the gates.

Arguments:
    pvarGatesDN -   varaint containing PROPID_L_GATES_DN

Return Value:
--*/
{
    //
    //  For each gate translate its DN to unique id
    //
    if ( pvarGatesDN->calpwstr.cElems == 0)
    {
        *pdwNumLinkSiteGates = 0;
        *ppguidLinkSiteGates = NULL;
        return( MQ_OK);
    }
    //
    //  there are gates
    //
    AP<GUID> pguidGates = new GUID[ pvarGatesDN->calpwstr.cElems];
    PROPID prop = PROPID_QM_MACHINE_ID;
    DWORD  dwNextToFill = 0;
    PROPVARIANT var;
    var.vt = VT_CLSID;
    HRESULT hr;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    for ( DWORD i = 0; i < pvarGatesDN->calpwstr.cElems; i++)
    {
        var.puuid = &pguidGates[ dwNextToFill];

        hr = g_pDS->GetObjectProperties(
                    eGlobalCatalog,		    // local DC or GC
                    &requestDsServerInternal,
 	                pvarGatesDN->calpwstr.pElems[i],      // object name
                    NULL,      // unique id of object
                    1,
                    &prop,
                    &var);
        if ( SUCCEEDED(hr))
        {
            dwNextToFill++;
        }


    }
    if ( dwNextToFill > 0)
    {
        //
        //  succeeded to translate some or all gates, return them
        //
        *pdwNumLinkSiteGates = dwNextToFill;
        *ppguidLinkSiteGates = pguidGates.detach();
        return( MQ_OK);

    }
    //
    //  Failed to translate gates
    //
    *pdwNumLinkSiteGates = 0;
    *ppguidLinkSiteGates = NULL;
    return MQ_OK;
}


HRESULT MQADSpQueryLinkSiteGates(
                IN  const GUID * pguidSiteId1,
                IN  const GUID * pguidSiteId2,
                IN  CDSRequestContext *pRequestContext,
                OUT GUID **      ppguidLinkSiteGates,
                OUT DWORD *      pdwNumLinkSiteGates
                )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    *pdwNumLinkSiteGates = 0;
    *ppguidLinkSiteGates = NULL;
    HRESULT hr;
    //
    //  BUGBUG - performance: to do impersonation only once
    //
    //
    //  First translate site id to site DN
    //
    AP<WCHAR> pwcsNeighbor1Dn;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr =  MQADSpTranslateLinkNeighbor(
                 pguidSiteId1,
                 &requestDsServerInternal,    // internal DS operation
                 &pwcsNeighbor1Dn);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 130);
    }

    AP<WCHAR> pwcsNeighbor2Dn;
    CDSRequestContext requestDsServerInternal1( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr =  MQADSpTranslateLinkNeighbor(
                 pguidSiteId2,
                 &requestDsServerInternal1,    // internal DS operation
                 &pwcsNeighbor2Dn);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 140);
    }

    //
    //  Prepare a restriction where neighbor1_DN == pwcsNeighbor1Dn
    //  and neighbor2_DN == pwcsNeighbor2Dn
    //
    MQPROPERTYRESTRICTION propRestriction[2];
    propRestriction[0].rel = PREQ;
    propRestriction[0].prop = PROPID_L_NEIGHBOR1_DN;
    propRestriction[0].prval.vt = VT_LPWSTR;
    propRestriction[0].prval.pwszVal = pwcsNeighbor1Dn;

    propRestriction[1].rel = PREQ;
    propRestriction[1].prop = PROPID_L_NEIGHBOR2_DN;
    propRestriction[1].prval.vt = VT_LPWSTR;
    propRestriction[1].prval.pwszVal = pwcsNeighbor2Dn;

    MQRESTRICTION restriction;
    restriction.cRes = 2;
    restriction.paPropRes = propRestriction;

    PROPID prop = PROPID_L_GATES_DN;

    CDsQueryHandle hQuery;

    hr = g_pDS->LocateBegin(
            eOneLevel,	
            eLocalDomainController,	
            pRequestContext,
            NULL,
            &restriction,
            NULL,
            1,
            &prop,
            hQuery.GetPtr());
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADSpQueryLinkSiteGates : Locate begin failed %lx"),hr));
        return LogHR(hr, s_FN, 150);
    }
    //
    //  Read the result ( maximim one result)
    //
    DWORD cp = 1;
    CMQVariant var;
    var.SetNULL();

    hr = g_pDS->LocateNext(
                hQuery.GetHandle(),
                pRequestContext,
                &cp,
                var.CastToStruct()
                );
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADSpQueryLinkSiteGates : Locate next failed %lx"),hr));
        return LogHR(hr, s_FN, 160);
    }
    ASSERT( cp <= 1);
    if ( cp == 1)
    {
        HRESULT hr2 = MQADSpTranslateGateDn2Id(
                var.CastToStruct(),
                ppguidLinkSiteGates,
                pdwNumLinkSiteGates);
        return LogHR(hr2, s_FN, 170);

    }
    return(MQ_OK);

}


HRESULT MQADSpFindLink(
                IN  const GUID * pguidSiteId1,
                IN  const GUID * pguidSiteId2,
                IN  CDSRequestContext *pRequestContext,
                OUT GUID **      ppguidLinkGates,
                OUT DWORD *      pdwNumLinkGates
                )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{

    //
    //  The link between the two site can be
    //  either s1<->s2 or s2<->s1
    //  But not as both!!! (BUGBUG is this assumption still valid)
    //
    HRESULT hr;
    //
    //  Query link between neighbor1 and neighbor2
    //
    hr = MQADSpQueryLinkSiteGates(
                pguidSiteId1,
                pguidSiteId2,
                pRequestContext,
                ppguidLinkGates,
                pdwNumLinkGates
                );
    if (FAILED(hr) || (*pdwNumLinkGates == 0))
    {

    //
    //  Query link between neighbor2 and neighbor1
    //
        hr = MQADSpQueryLinkSiteGates(
                    pguidSiteId2,
                    pguidSiteId1,
                    pRequestContext,
                    ppguidLinkGates,
                    pdwNumLinkGates
                    );

    }
    return LogHR(hr, s_FN, 180);
}

//+------------------------------------------
//
//  HRESULT MQADSpQueryNeighborLinks()
//
//+------------------------------------------

HRESULT MQADSpQueryNeighborLinks(
                        IN  eLinkNeighbor      LinkNeighbor,
                        IN  LPCWSTR            pwcsNeighborDN,
                        IN  CDSRequestContext *pRequestContext,
                        IN OUT CSiteGateList * pSiteGateList
                        )

/*++

Routine Description:

Arguments:
        eLinkNeighbor :  specify according to which neighbor property, to perform
                         the locate ( PROPID_L_NEIGHBOR1 or PROPID_L_NEIGHBOR2)
        pwcsNeighborDN : the DN name of the site

        CSiteGateList : list of site-gates

Return Value:
--*/
{
    //
    //  Query the gates on all the links of a specific site ( pwcsNeighborDN).
    //  But only on links where the site is specified as
    //  neighbor-i ( 1 or 2)
    //
    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;

    if ( LinkNeighbor == eLinkNeighbor1)
    {
        propRestriction.prop = PROPID_L_NEIGHBOR1_DN;
    }
    else
    {
        propRestriction.prop = PROPID_L_NEIGHBOR2_DN;
    }

    propRestriction.prval.vt = VT_LPWSTR;
    propRestriction.prval.pwszVal = const_cast<WCHAR*>(pwcsNeighborDN);


    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;

    PROPID prop = PROPID_L_GATES_DN;

    CDsQueryHandle hQuery;
    HRESULT hr;

    hr = g_pDS->LocateBegin(
            eOneLevel,	
            eLocalDomainController,
            pRequestContext,
            NULL,
            &restriction,
            NULL,
            1,
            &prop,
            hQuery.GetPtr());
    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADSpQueryNeighborLinks : MsmqServices not found %lx"),hr));
        return(MQ_OK);
    }
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADSpQueryNeighborLinks : Locate begin failed %lx"),hr));
        return LogHR(hr, s_FN, 190);
    }
    //
    //  Read the results one by one
    //

    DWORD cp = 1;

    while (SUCCEEDED(hr))
    {
        cp = 1;
        CMQVariant var;
        var.SetNULL();

        hr = g_pDS->LocateNext(
                    hQuery.GetHandle(),
                    pRequestContext,
                    &cp,
                    var.CastToStruct()
                    );
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADSpQueryNeighborLinks : Locate next failed %lx"),hr));
            return LogHR(hr, s_FN, 200);
        }
        if ( cp == 0)
        {
            //
            //  no more results
            //
            break;
        }
        //
        //  Add to list
        //

        if ( var.GetCALPWSTR()->cElems > 0)
        {
            AP<GUID> pguidGates;
            DWORD    dwNumGates;
            HRESULT hr1 = MQADSpTranslateGateDn2Id(
                var.CastToStruct(),
                &pguidGates,
                &dwNumGates);
            if (SUCCEEDED(hr1) && (dwNumGates > 0))
            {
                ASSERT( dwNumGates > 0);

                pSiteGateList->AddSiteGates(
                         dwNumGates,
                         pguidGates
                         );
            }
        }
    }

    return(MQ_OK);
}

//+------------------------------------------------------
//
//  HRESULT DSCoreGetNT4PscName()
//
//  Retrieve the name of a NT4 PSC, given its site guid.
//
//+------------------------------------------------------

HRESULT DSCoreGetNT4PscName( IN  const GUID   *pguidSiteId,
                             IN  LPCWSTR       pwszSiteName,
                             OUT WCHAR       **pwszServerName )
{
    #define NUMOF_REST  3
    MQPROPERTYRESTRICTION propertyRestriction[ NUMOF_REST ];

    MQRESTRICTION restrictionNT4Psc;
    restrictionNT4Psc.cRes = NUMOF_REST ;
    restrictionNT4Psc.paPropRes = propertyRestriction;

    ULONG cIndex = 0 ;
    propertyRestriction[ cIndex ].rel = PREQ ;
    propertyRestriction[ cIndex ].prop = PROPID_SET_OLDSERVICE;
    propertyRestriction[ cIndex ].prval.vt = VT_UI4;
    propertyRestriction[ cIndex ].prval.ulVal = SERVICE_PSC;
    cIndex++ ;

    propertyRestriction[ cIndex ].rel = PREQ ;
    propertyRestriction[ cIndex ].prop = PROPID_SET_NT4;
    propertyRestriction[ cIndex ].prval.vt = VT_UI4;
    propertyRestriction[ cIndex ].prval.ulVal = 1;
    cIndex++ ;

    if (pguidSiteId)
    {
        propertyRestriction[ cIndex ].rel = PREQ ;
        propertyRestriction[ cIndex ].prop = PROPID_SET_MASTERID;
        propertyRestriction[ cIndex ].prval.vt = VT_CLSID;
        propertyRestriction[ cIndex ].prval.puuid =
                                       const_cast<GUID*> (pguidSiteId) ;
    }
    else if (pwszServerName)
    {
        propertyRestriction[ cIndex ].rel = PREQ ;
        propertyRestriction[ cIndex ].prop = PROPID_SET_SITENAME ;
        propertyRestriction[ cIndex ].prval.vt = VT_LPWSTR ;
        propertyRestriction[ cIndex ].prval.pwszVal =
                                     const_cast<LPWSTR> (pwszSiteName) ;
    }
    else
    {
        ASSERT(0) ;
    }
    cIndex++ ;
    ASSERT(cIndex == NUMOF_REST) ;

    //
    // start search
    //
    CDsQueryHandle hCursor; // auto close.

    DWORD cProps = 1 ;
    PROPID propId = PROPID_SET_FULL_PATH ;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    HRESULT hr = g_pDS->LocateBegin( eSubTree,	
                                   eLocalDomainController,
                                   &requestDsServerInternal,
                                   NULL,
                                   &restrictionNT4Psc,
                                   NULL,
                                   cProps,
                                  &propId,
                                   hCursor.GetPtr()	) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 210);
    }

    MQPROPVARIANT var ;
    var.vt = VT_NULL ;

    hr =  g_pDS->LocateNext( hCursor.GetHandle(),
                           &requestDsServerInternal,
                           &cProps,
                           &var ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 220);
    }
    else if (cProps != 1)
    {
        return LogHR(MQDS_OBJECT_NOT_FOUND, s_FN, 230);
    }

    ASSERT( var.vt == VT_LPWSTR );

    P<WCHAR> pwcsSettingName = var.pwszVal;
    P<WCHAR> pwcsServerName;
    CDSRequestContext requestDsServerInternal1( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = g_pDS->GetParentName( eLocalDomainController,
                             e_ConfigurationContainer,
                             &requestDsServerInternal1,        // local DS server operation
                             pwcsSettingName,
                            &pwcsServerName );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 240);
    }

    //
    // Yeah, do some text processing to isolate server name from full DN.
    //
    WCHAR  *pwcsStartServer = pwcsServerName + x_CnPrefixLen;
    WCHAR  *pwcsEndServer = pwcsStartServer ;
    while ( *pwcsEndServer != L',')
    {
        pwcsEndServer++;
    }

    DWORD_PTR dwSize = (pwcsEndServer - pwcsStartServer) + 1 ;
    WCHAR *pServerName = new WCHAR[ dwSize ] ;
    memcpy(pServerName, pwcsStartServer, (dwSize * sizeof(WCHAR))) ;
    pServerName[ dwSize-1 ] = 0 ;

    *pwszServerName = pServerName ;

    return LogHR(hr, s_FN, 250);
}

//+---------------------------------------------------
//
//  HRESULT MQADSpGetSiteSignPK()
//
//  Retrieve the signing public key of the PSC.
//
//+---------------------------------------------------

HRESULT MQADSpGetSiteSignPK(
                 IN  const GUID  *pguidSiteId,
                 OUT BYTE       **pBlobData,
                 OUT DWORD       *pcbSize )
{
    //
    // first, retrieve PSC name from site guid.
    //
    P<WCHAR> pwszServerName = NULL ;
    HRESULT hr = DSCoreGetNT4PscName( pguidSiteId,
                                      NULL,
                                      &pwszServerName ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 260);
    }

    //
    // Now retrieve the public key from machine object.
    //
    PROPID PscSignPk = PROPID_QM_SIGN_PK;
    PROPVARIANT PscSignPkVar ;
	PscSignPkVar.vt = VT_NULL ;	

    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr =  DSCoreGetProps( MQDS_MACHINE,
                          pwszServerName,
                          NULL,
                          1,
                          &PscSignPk,
                          &requestDsServerInternal,
                          &PscSignPkVar ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 270);
    }

    *pBlobData = PscSignPkVar.blob.pBlobData ;
    *pcbSize   = PscSignPkVar.blob.cbSize ;

    return LogHR(hr, s_FN, 280);
}

//+-------------------------------------------------------------------
//
//  HRESULT MQADSpCreateCN()
//
//  Create only foreign CN. Reject calls to create IP or IPX cns,
//  as these ones are supported anymore on win2k.
//
//+-------------------------------------------------------------------

HRESULT MQADSpCreateCN(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  const DWORD        cpEx,
                 IN  const PROPID       aPropEx[  ],
                 IN  const PROPVARIANT  apVarEx[  ],
                 IN  CDSRequestContext *pRequestContext )
{
	for (DWORD j = 0 ; j < cp ; j++ )
	{
		if (aProp[j] == PROPID_CN_PROTOCOLID)
		{
			if (apVar[j].uiVal != FOREIGN_ADDRESS_TYPE)
			{
                return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 400) ;
			}
			else
			{
				break;
			}
		}
	}

    if (j == cp)
    {
        //
        // protocol id not found in input.
        //
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 410) ;
    }

	//
	// we are here if this CN is foreign CN.
    // Convert CN properties to Site ones.
	//
    #define MAX_SITE_PROPS  6
	DWORD cIndex = 0;
	
    PROPID       aSiteProp[ MAX_SITE_PROPS ] ;
    PROPVARIANT  apSiteVar[ MAX_SITE_PROPS ] ;

	for (j = 0 ; j < cp ; j++ )
	{
        if (cIndex >= MAX_SITE_PROPS)
        {
            ASSERT(cIndex < MAX_SITE_PROPS) ;
            return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 420) ;
        }

		switch (aProp[j])
		{
		case PROPID_CN_PROTOCOLID:
			aSiteProp[ cIndex ] = PROPID_S_FOREIGN;		
            apSiteVar[ cIndex ].vt = VT_UI1 ;
            apSiteVar[ cIndex ].bVal = TRUE ;
            cIndex++ ;
			break;

		case PROPID_CN_NAME:
			aSiteProp[ cIndex ] = PROPID_S_PATHNAME;			
            apSiteVar[ cIndex ] = apVar[ j ] ;
            cIndex++ ;
			break;

		case PROPID_CN_GUID:
            //
            // Ignore guid. no one really need this one specifically.
            // This is to support legacy nt4 code that supply the guid
            // when calling DSCreateObject.
            // All our tools (mqxplore and mqforgn) will live ok with
            // guid that are generated by the active directory.
            //
			break;
			
		case PROPID_CN_SEQNUM:
		case PROPID_CN_MASTERID:
            //
            // note relevant on win2k.
            //
			break;

		default:
            //
            // This fucntion was added to support nt4 mqxplore and the
            // mqforgn tool that was supplied to level8.
            // These tools do not use any other propid than those
            // handled above.
            //
			ASSERT(0);
            return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 460) ;
			break;
		}
	}

    HRESULT hr = MQADSpCreateSite( pwcsPathName,
                                   cIndex,
                                   aSiteProp,
                                   apSiteVar,
                                   cpEx,
                                   aPropEx,
                                   apVarEx,
                                   pRequestContext );
    return LogHR(hr, s_FN, 440) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\routtbl.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routtbl.cpp

Abstract:

    Routing Table implementation

Author:

    Shai Kariv  (shaik)  05-Apr-2001

--*/

#include "ds_stdh.h"
#include "routtbl.h"

#include "routtbl.tmh"


//
// Class CSiteRoutingNode
//

CSiteRoutingNode::CSiteRoutingNode()
{
    memset(&m_Guid,0,sizeof(GUID));
};

CSiteRoutingNode::CSiteRoutingNode(const GUID& guid)
{
    m_Guid=guid;
};

CSiteRoutingNode::~CSiteRoutingNode()
{
};

UINT    CSiteRoutingNode::GetHashKey() const
{
        return((UINT)m_Guid.Data1);
};

void    CSiteRoutingNode::Print() const
{
        DBGMSG((DBGMOD_ROUTING,DBGLVL_INFO,TEXT("SiteNode %!guid!"), &m_Guid));
};

int     CSiteRoutingNode::operator==(const CSiteRoutingNode & other) const
{
    const CSiteRoutingNode* pOther = (const CSiteRoutingNode *) &other;
    return (!(memcmp((const GUID *)&m_Guid, (const GUID *) &pOther->m_Guid, sizeof(GUID))));
};

CSiteRoutingNode*    CSiteRoutingNode::Duplicate() const
{
    return (new CSiteRoutingNode(m_Guid));
};

const GUID&  CSiteRoutingNode::GetNode() const
{
    return ((const GUID &)m_Guid);
};

void CSiteRoutingNode::SetNode(IN const GUID& guid)
{
    m_Guid=guid;
};


//
// Class CSiteGate
//

CSiteGate::CSiteGate(BOOL fSiteGate):m_fSiteGate(fSiteGate)
{
};

CSiteGate::~CSiteGate()
{
};

CSiteGate 
CSiteGate::operator+(const CSiteGate& second) const 
{
    return m_fSiteGate | second.m_fSiteGate;
};


void  
CSiteGate::Print() const 
{ 
    DBGMSG((DBGMOD_ROUTING,DBGLVL_INFO,TEXT("sitegate %u "),m_fSiteGate));
};


void
CSiteGate::operator=(IN BOOL fSiteGate)
{
    m_fSiteGate = fSiteGate;
}

BOOL
CSiteGate::IsThereASiteGate() const
{
    return( m_fSiteGate);
}

//
// Class CCost
//

CCost::CCost(DWORD cost):m_Cost(cost)
{
};

CCost::~CCost()
{
};

CCost 
CCost::operator+(const CCost& second) const 
{
    return m_Cost + second.m_Cost;
};

BOOL  
CCost::operator<(const CCost& second) const 
{
    return m_Cost < second.m_Cost;
};

void  
CCost::Print() const 
{ 
    DBGMSG((DBGMOD_ROUTING,DBGLVL_INFO,TEXT("cost %u "),m_Cost));
};

int  
CCost::operator==(const CCost & other) const
{
    return (!(memcmp((const DWORD *)&m_Cost, (const DWORD *) &other.m_Cost, sizeof(DWORD))));
};

void
CCost::operator=(IN DWORD cost)
{
    m_Cost = cost;
}

//
// Class CNextHop
//

CNextHop::~CNextHop()
{
    delete m_pNextNode;
};

CNextHop::CNextHop(const CSiteRoutingNode* pNextNode) : m_Cost(0)
{
    m_pNextNode = pNextNode->Duplicate();
};

CNextHop::CNextHop(const CSiteRoutingNode* pNextNode, const CCost& Cost, 
                           const CSiteGate& SiteGate)
{
    m_Cost = Cost;
    m_SiteGate = SiteGate;
    m_pNextNode = pNextNode->Duplicate();
};

const   CCost&  CNextHop::GetCost() const
{
    return m_Cost;
};

const   CSiteGate& CNextHop::GetSiteGate() const
{
    return m_SiteGate;
}

const   CSiteRoutingNode*   CNextHop::GetNextNode() const
{
    return m_pNextNode;
};

void    CNextHop::Print() const
{
    m_pNextNode->Print();
    m_Cost.Print();
    m_SiteGate.Print();
};

//
// Class CSiteLinksInfo
//

CSiteLinksInfo::CSiteLinksInfo() : m_NoAllocated(0),
                                          m_NoOfNeighbors(0),
                                          m_pNeighbors(NULL),
                                          m_pCosts(NULL),
                                          m_pfSiteGates(NULL)
{
}

CSiteLinksInfo::~CSiteLinksInfo()
{
    delete []m_pNeighbors;
    delete []m_pCosts;
    delete []m_pfSiteGates;
}

DWORD   CSiteLinksInfo::GetNoOfNeighbors()  const
{
    return(m_NoOfNeighbors);
}

DWORD   CSiteLinksInfo::GetCost(IN DWORD i) const
{
    ASSERT(i < m_NoOfNeighbors);

    return(m_pCosts[i]);
}

DWORD  CSiteLinksInfo::IsThereSiteGate(IN DWORD i) const
{
    ASSERT(i < m_NoOfNeighbors);

    return(m_pfSiteGates[i]);
}

CSiteRoutingNode*   CSiteLinksInfo::GetNeighbor(IN DWORD i) const
{
    ASSERT(i < m_NoOfNeighbors);

    return(&m_pNeighbors[i]);
}

//
// Class
//

CSiteDB::CSiteDB(): m_pos(0)
{
};

CSiteDB::~CSiteDB()
{
};


HRESULT    CSiteDB::Init(  IN const GUID& guidMySite)
{
    m_MySiteNode.SetNode(guidMySite);
    //
    //  Read site links info
    //
    return(GetAllSiteLinks());
}

const CSiteRoutingNode* CSiteDB::GetMyNode() const
{
    return &m_MySiteNode;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\mqadsp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
	mqadsp.h

Abstract:
    MQADS DLL private internal functions for
    DS queries, etc.

Author:
    ronith


--*/


#ifndef __MQADSP_H__
#define __MQADSP_H__
#include "siteinfo.h"
#include "dsads.h"
#include "dsreqinf.h"

//
//  Deletes a user object according to its digest
//
HRESULT MQADSpDeleteUserObject(
                 IN const GUID *      pDigest,
                 IN CDSRequestContext * pRequestContext
                 );

HRESULT MQADSpCreateUserObject(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  CDSRequestContext *pRequestContext
                 );


HRESULT SearchFullComputerPathName(
            IN  DS_PROVIDER             provider,
            IN  enumComputerObjType     eComputerObjType,
			IN	LPCWSTR					pwcsComputerDnsName,
            IN  LPCWSTR                 pwcsRoot,
            IN  const MQRESTRICTION *   pRestriction,
            IN  PROPID *                pProp,
            OUT LPWSTR *                ppwcsFullPathName
            ) ;

/*====================================================

FilterSpecialCharacters

  Put escape codes before special characters (like #, =, /) in an object name

Arguments:
        pwcsObjectName :  Name of original object
        dwNameLength   :  Length of original object
        pwcsOutBuffer  :  Optional output buffer. If NULL, the function allocates an output buffer
                          and return it (caller must release). Otherwise, it writes the output to the
                          output buffer and returns it.

=====================================================*/
WCHAR * FilterSpecialCharacters(
            IN     LPCWSTR          pwcsObjectName,
            IN     const DWORD      dwNameLength,
            IN OUT LPWSTR pwcsOutBuffer = 0,
            OUT    DWORD_PTR* pdwCharactersProcessed = 0);

/*====================================================

MQADSpGetFullComputerPathName

Arguments:
        pwcsComputerCn :  the cn value of the computer object
        ppwcsFullPathName :  the full path name of the computer object

  It is the caller responsibility to release ppwcsFullPathName.

=====================================================*/

HRESULT MQADSpGetFullComputerPathName(
                IN  LPCWSTR                    pwcsComputerCn,
                IN  enum  enumComputerObjType  eCopmuterObjType,
                OUT LPWSTR *                   ppwcsFullPathName,
                OUT DS_PROVIDER *              pProvider
                );


/*====================================================

MQADSpSplitAndFilterQueueName

Arguments:
        pwcsPathName :  the queue name. Format machine1\queue1
        pwcsMachineName :  the machine portion of the name
        pwcsQueueName :    the queue portion of the name

  It is the caller responsibility to release pwcsMachineName and
  pwcsQueueName.

=====================================================*/
HRESULT MQADSpSplitAndFilterQueueName(
                IN  LPCWSTR             pwcsPathName,
                OUT LPWSTR *            ppwcsMachineName,
                OUT LPWSTR *            ppwcsQueueName
                );


HRESULT MQADSpCreateQueue(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  CDSRequestContext *pRequestContext,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pQueueInfoRequest,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pQmInfoRequest
                 );

HRESULT MQADSpCreateEnterprise(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  CDSRequestContext *pRequestContext
                 );

HRESULT MQADSpCreateSiteLink(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN OUT MQDS_OBJ_INFO_REQUEST * pObjectInfoRequest,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest,
                 IN  CDSRequestContext *   pRequestContext
                 );

HRESULT MQADSpGetQueueProperties(
               IN  LPCWSTR          pwcsPathName,
               IN  const GUID *     pguidIdentifier,
               IN  DWORD            cp,
               IN  const PROPID     aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT      apVar[]
               );
HRESULT MQADSpGetCnProperties(
               IN  LPCWSTR          pwcsPathName,
               IN  const GUID *     pguidIdentifier,
               IN  DWORD            cp,
               IN  const PROPID     aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT      apVar[]
               );
HRESULT MQADSpGetSiteProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT  apVar[]
               );

HRESULT MQADSpGetMachineProperties(
               IN  LPCWSTR       pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD         cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext *   pRequestContext,
               OUT PROPVARIANT   apVar[]
               );

HRESULT MQADSpGetComputerProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT  apVar[]
               );


HRESULT MQADSpGetEnterpriseProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT  apVar[]
               );


HRESULT MQADSpGetSiteLinkProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT  apVar[]
               );

HRESULT MQADSpGetUserProperties(
               IN  LPCWSTR pwcsPathName,
               IN  const GUID *  pguidIdentifier,
               IN  DWORD cp,
               IN  const PROPID  aProp[],
               IN  CDSRequestContext * pRequestContext,
               OUT PROPVARIANT  apVar[]
               );


HRESULT MQADSpQuerySiteFRSs(
                 IN  const GUID *         pguidSiteId,
                 IN  DWORD                dwService,
                 IN  ULONG                relation,
                 IN  const MQCOLUMNSET *  pColumns,
                 IN  CDSRequestContext *  pRequestContext,
                 OUT HANDLE         *     pHandle
                 );

HRESULT MQADSpGetSiteSignPK(
                 IN  const GUID  *pguidSiteId,
                 OUT BYTE       **pBlobData,
                 OUT DWORD       *pcbSize ) ;

HRESULT MQADSpGetSiteGates(
                 IN  const GUID * pguidSiteId,
                 IN  CDSRequestContext *pRequestContext,
                 OUT DWORD *      pdwNumSiteGates,
                 OUT GUID **      ppaSiteGates
                 );

HRESULT MQADSpFindLink(
                IN  const GUID * pguidSiteId1,
                IN  const GUID * pguidSiteId2,
                IN  CDSRequestContext *pRequestContext,
                OUT GUID **      ppguidLinkSiteGates,
                OUT DWORD *      pdwNumLinkSiteGates
                );

HRESULT QueryParser(
                 IN  LPWSTR          pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle
                 );


HRESULT MQADSpCreateMachine(
                 IN  LPCWSTR            pwcsPathName,
                 IN  DWORD              dwObjectType,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  const DWORD        cpEx,
                 IN  const PROPID       aPropEx[  ],
                 IN  const PROPVARIANT  apVarEx[  ],
                 IN  CDSRequestContext *pRequestContext,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pObjectInfoRequest,
                 IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest
                 );

HRESULT MQADSpCreateComputer(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  const DWORD        cpEx,
                 IN  const PROPID       aPropEx[  ],
                 IN  const PROPVARIANT  apVarEx[  ],
                 IN  CDSRequestContext *pRequestContext,
                 OUT WCHAR            **ppwcsFullPathName
                 );

/*====================================================

MQADSpDeleteMachineObject

Arguments:
        pwcsPathName :  the cn of the computer object (may be NULL)
        pguidIdentifier : the unique id of the computer object ( may be NULL)

        Either pwcsPathName or pguidIdentifier must be not NULL ( but not both)

=====================================================*/
HRESULT MQADSpDeleteMachineObject(
                IN LPCWSTR           pwcsPathName,
                IN const GUID *      pguidIdentifier,
                IN  CDSRequestContext * pRequestContext
                );



HRESULT MQADSpDeleteMsmqSetting(
                IN const GUID *        pguidIdentifier,
                IN  CDSRequestContext *pRequestContext
                );


HRESULT MQADSpComposeFullPathName(
                IN const DWORD          dwObjectType,
                IN LPCWSTR              pwcsPathName,
                OUT LPWSTR *            ppwcsFullPathName,
                OUT DS_PROVIDER *       pSetAndDeleteProvider
                );

HRESULT MQADSpQueryNeighborLinks(
                        IN  eLinkNeighbor      LinkNeighbor,
                        IN  LPCWSTR            pwcsNeighborDN,
                        IN  CDSRequestContext *pRequestContext,
                        IN OUT CSiteGateList * pSiteGateList
                        );


/*====================================================

MQADSpComposeFullQueueName

Arguments:
        pwcsFullComputerNameName : full distinguished name of the computer object
        pwcsQueueName : the queue name (cn)

        ppwcsFullPathName : full distinguished name of the queue object

  It is the caller responsibility to release ppwcsFullPathName
=====================================================*/
HRESULT MQADSpComposeFullQueueName(
                        IN  LPCWSTR        pwcsFullComputerNameName,
                        IN  LPCWSTR        pwcsQueueName,
                        OUT LPWSTR *       ppwcsFullPathName
                        );

HRESULT MQADSpInitDsPathName();

HRESULT MQADSpGetSiteName(
        IN const GUID *       pguidSite,
        OUT LPWSTR *          ppwcsSiteName
        );


HRESULT MQADSpFilterAdsiHResults(
                         IN HRESULT hrAdsi,
                         IN DWORD   dwObjectType);


DS_PROVIDER MQADSpDecideComputerProvider(
             IN  const DWORD   cp,
             IN  const PROPID  aProp[  ]
             );

HRESULT MQADSpTranslateLinkNeighbor(
                 IN  const GUID *    pguidSiteId,
                 IN  CDSRequestContext *pRequestContext,
                 OUT WCHAR**         ppwcsSiteDn);


HRESULT MQADSpCreateSite(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  const DWORD        cpEx,
                 IN  const PROPID       aPropEx[  ],
                 IN  const PROPVARIANT  apVarEx[  ],
                 IN  CDSRequestContext *pRequestContext
                 );

HRESULT MQADSpCreateCN(
                 IN  LPCWSTR            pwcsPathName,
                 IN  const DWORD        cp,
                 IN  const PROPID       aProp[  ],
                 IN  const PROPVARIANT  apVar[  ],
                 IN  const DWORD        cpEx,
                 IN  const PROPID       aPropEx[  ],
                 IN  const PROPVARIANT  apVarEx[  ],
                 IN  CDSRequestContext *pRequestContext
                 ) ;

HRESULT MQADSpFilterSiteGates(
              IN  const GUID *      pguidSiteId,
              IN  const DWORD       dwNumGatesToFilter,
              IN  const GUID *      pguidGatesToFilter,
              OUT DWORD *           pdwNumGatesFiltered,
              OUT GUID **           ppguidGatesFiltered
              );

HRESULT LocateUser(
                 IN  BOOL            fOnlyLocally,
                 IN  BOOL            fOnlyInGC,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  CDSRequestContext *pRequestContext,
                 OUT PROPVARIANT    *pvar,
                 OUT DWORD          *pdwNumofProps = NULL,
                 OUT BOOL           *pfUserFound = NULL
                 );

HRESULT MQADSpCreateMachineSettings(
            IN DWORD                dwNumSites,
            IN const GUID *         pSite,
            IN LPCWSTR              pwcsPathName,
            IN BOOL                 fRouter,         // [adsrv] DWORD                dwService,
            IN BOOL                 fDSServer,
            IN BOOL                 fDepClServer,
            IN BOOL                 fSetQmOldService,
            IN DWORD                dwOldService,
            IN  const GUID *        pguidObject,
            IN  const DWORD         cpEx,
            IN  const PROPID        aPropEx[  ],
            IN  const PROPVARIANT   apVarEx[  ],
            IN  CDSRequestContext * pRequestContext
            ) ;

HRESULT MQADSpSetMachinePropertiesWithSitesChange(
            IN  const  DWORD         dwObjectType,
            IN  DS_PROVIDER          provider,
            IN  CDSRequestContext *  pRequestContext,
            IN  LPCWSTR              lpwcsPathName,
            IN  const GUID *         pguidUniqueId,
            IN  const DWORD          cp,
            IN  const PROPID *       pPropIDs,
            IN  const MQPROPVARIANT *pPropVars,
            IN  DWORD                dwSiteIdsIndex,
            IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest
            );

HRESULT  SetDefaultMachineSecurity( IN  DWORD           dwObjectType,
                                    IN  PSID            pComputerSid,
                                    IN OUT DWORD       *pcp,
                                    IN OUT PROPID       aProp[  ],
                                    IN OUT PROPVARIANT  apVar[  ],
                                    OUT PSECURITY_DESCRIPTOR* ppMachineSD ) ;

HRESULT  GetFullComputerPathName(
                IN  LPCWSTR                    pwcsComputerName,
                IN  enum  enumComputerObjType  eCopmuterObjType,
                IN  const DWORD                cp,
                IN  const PROPID               aProp[  ],
                IN  const PROPVARIANT          apVar[  ],
                OUT LPWSTR *                   ppwcsFullPathName,
                OUT DS_PROVIDER *              pCreateProvider ) ;

HRESULT MQADSpTranslateGateDn2Id(
        IN  const PROPVARIANT*  pvarGatesDN,
        OUT GUID **      ppguidLinkSiteGates,
        OUT DWORD *      pdwNumLinkSiteGates
        );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\siteinfo.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    siteinfo.h

Abstract:

    Site information Class definition

Author:

    ronit hartmann (ronith)


--*/
#ifndef __SITEINFO_H__
#define __SITEINFO_H__

#include <Ex.h>

class CSiteGateList
{
    public:
        CSiteGateList();
        ~CSiteGateList();
        HRESULT AddSiteGates(
                    IN const DWORD  num,
                    IN const GUID * pguidGates
                    );
        HRESULT CopySiteGates(
                OUT GUID **      ppguidLinkSiteGates,
                OUT DWORD *      pdwNumLinkSiteGates
                ) const;

        const GUID * GetSiteGate(
                IN  const DWORD  dwIndex
                ) const;

        DWORD GetNumberOfGates() const;

    private:
        DWORD   m_dwNumAllocated;
        DWORD   m_dwNumFilled;
        GUID *  m_pguidGates;

};

inline CSiteGateList::CSiteGateList() :
                      m_dwNumAllocated(0),
                      m_dwNumFilled(0),
                      m_pguidGates(NULL)
{
}

inline DWORD CSiteGateList::GetNumberOfGates() const
{
    return( m_dwNumFilled);
}


inline HRESULT CSiteGateList::AddSiteGates(
                    IN const DWORD  dwNum,
                    IN const GUID * pguidGates
                    )
{
    const DWORD cNumToAllocate = 20;

    //
    //  Not enough space allocated
    //
    if ( m_dwNumFilled + dwNum > m_dwNumAllocated)
    {
        DWORD dwToAllocate = ( m_dwNumFilled + dwNum > m_dwNumAllocated + cNumToAllocate) ?
            m_dwNumFilled + dwNum : m_dwNumAllocated + cNumToAllocate;
        GUID * pguidTmp = new GUID [dwToAllocate];
        //
        //  copy old list if exist
        //
        if ( m_pguidGates)
        {
            memcpy( pguidTmp, m_pguidGates,  m_dwNumFilled * sizeof(GUID));
            delete [] m_pguidGates;
        }
        m_pguidGates = pguidTmp;
        m_dwNumAllocated = dwToAllocate;
    }
    //
    //  add gates
    //
    memcpy( &m_pguidGates[ m_dwNumFilled], pguidGates, dwNum * sizeof(GUID));
    m_dwNumFilled += dwNum;
    return(MQ_OK);
}

inline HRESULT CSiteGateList::CopySiteGates(
                OUT GUID **      ppguidLinkSiteGates,
                OUT DWORD *      pdwNumLinkSiteGates
                ) const
{
    //
    //  allocate the output buffer and copy the site-gates
    //
    if ( m_dwNumFilled)
    {
        *ppguidLinkSiteGates = new GUID[ m_dwNumFilled];
        memcpy( *ppguidLinkSiteGates, m_pguidGates, m_dwNumFilled * sizeof(GUID));
        *pdwNumLinkSiteGates =  m_dwNumFilled;
    }
    return(MQ_OK);
}



inline CSiteGateList::~CSiteGateList()
{
    delete [] m_pguidGates;
}

inline const GUID * CSiteGateList::GetSiteGate(
                IN  const DWORD  dwIndex
                ) const
{
    ASSERT( dwIndex < m_dwNumFilled);
    return( &m_pguidGates[dwIndex]);
}


enum eLinkNeighbor
{
    eLinkNeighbor1,
    eLinkNeighbor2
};

//
//  BUGBUG CSiteInformation - one site only ( what if DC belongs to two sites ?)
//
class CSiteInformation
{
    public:
		CSiteInformation();
        ~CSiteInformation();

        HRESULT Init(BOOL fReplicationMode);

        BOOL IsThisSite (
                const GUID * guidSiteId
                );

        const GUID * GetSiteId();

        //
        //  This routine returns the list and number of site-gates
        //
        //  The routines allocate the site-gates array and
        //  it is the responsibility of the caller to release it
        //
        HRESULT FillSiteGates(
                OUT DWORD * pdwNumSiteGates,
                OUT GUID ** ppguidSiteGates
                );


        BOOL CheckMachineIsSitegate(
                        IN const GUID * pguidMachine);


    private:
        //
        //  Refresh the list of the site-gates that
        //  belong to this site.
        //
        //  The site-gates of this site are all the session
        //  concentration site-gates
        //  ( i.e. site-gates that belong to this site only)
        //  on any of this site links
        //

        static void WINAPI RefreshSiteInfo(
                IN CTimer* pTimer
                   );

        HRESULT RefreshSiteInfoInternal();

        HRESULT QueryLinkGates(
                OUT GUID **      ppguidLinkSiteGates,
                OUT DWORD *      pdwNumLinkSiteGates
                );

        GUID                m_guidSiteId;
        GUID *              m_pguidSiteGates;
        DWORD               m_dwNumSiteGates;
	    CCriticalSection	m_cs;
        BOOL                m_fInitialized;

        CTimer m_RefreshTimer;


};

inline BOOL CSiteInformation::IsThisSite (
                const GUID * guidSiteId
                )
{
    return( m_guidSiteId == *guidSiteId);
}


inline  HRESULT CSiteInformation::FillSiteGates(
                OUT DWORD * pdwNumSiteGates,
                OUT GUID ** ppguidSiteGates
                )
{
    CS lock(m_cs);
    if (  m_dwNumSiteGates)
    {
        *ppguidSiteGates = new GUID[ m_dwNumSiteGates];
        memcpy( *ppguidSiteGates, m_pguidSiteGates, m_dwNumSiteGates * sizeof(GUID));
    }
    else
    {
        *ppguidSiteGates = NULL;
    }

    *pdwNumSiteGates = m_dwNumSiteGates;
    return(MQ_OK);
}

inline const GUID * CSiteInformation::GetSiteId()
{
    return (&m_guidSiteId);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\siterout.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    siterout.cpp

Abstract:

    Site routing table  Class

Author:

    ronit hartmann (ronith)
    Ilan Herbst    (ilanh)   9-July-2000 


--*/
#include "ds_stdh.h"
#include "siterout.h"
#include "cs.h"
#include "dijkstra.h"
#include "dsutils.h"
#include "coreglb.h"
#include "ex.h"

#include "siterout.tmh"

const time_t x_refreshDeltaTime = ( 1 * 60 * 60 * 1000); /* 1 hours */

static WCHAR *s_FN=L"mqdscore/siterout";

CSiteRoutingInformation::~CSiteRoutingInformation()
/*++

Routine Description:
    destructor.

Arguments:

Return Value:

--*/
{

	ExCancelTimer(&m_RefreshTimer);

}



HRESULT CSiteRoutingInformation::Init(
                IN const GUID *     pguidThisSiteId,
                IN BOOL             fReplicationMode )
/*++

Routine Description:
    Iniitalize site routing table.

Arguments:
    pguidThisSiteId     - site guid

Return Value:
MQ_OK - success
Other HRESULT errors

--*/
{
    m_guidThisSiteId = *pguidThisSiteId;

    HRESULT hr = RefreshSiteRoutingTableInternal();
    if (SUCCEEDED(hr))
    {
        m_fInitialized = TRUE;
        //
        //  schedule a refresh of the site-route-table
		//
		if ( !g_fSetupMode && !fReplicationMode)
        {
			ExSetTimer(
				&m_RefreshTimer, 
				CTimeDuration::FromMilliSeconds(x_refreshDeltaTime)
				);
        }
    }
    return LogHR(hr, s_FN, 10);

}

HRESULT CSiteRoutingInformation::CheckIfSitegateOnRouteToSite(
                        IN const GUID * pguidSite,
						OUT BOOL * pfSitegateOnRoute)
/*++

Routine Description:
    checks if there is a sitegate on the route to a site.
    attempts a refresh if the site is not found.

Arguments:
    pguidSite          - site guid
    pfSitegateOnRoute   - return whether there is a sitegate on the route

Return Value:
MQ_OK - success
MQDS_UNKNOWN_SITE_ID - pguidSite is not found
Other HRESULT errors

--*/
{
    //
    //  Is it a known site
    //
    CSiteRoutingNode Site( *pguidSite);
    CNextHop * pNextHop;

    CS lock(m_cs);
    if ( m_SiteRoutingTable.Lookup( &Site, pNextHop))
    {
        CSiteGate SiteGate = pNextHop->GetSiteGate();
        *pfSitegateOnRoute = SiteGate.IsThereASiteGate();
        return( MQ_OK);
    }
    //
    //  Even though failed to find the site, we don't
    //  try to refresh the site-routing table. This is
    //  because this method is called in the context of a user
    //  that called a certain DS API. If user does not have
    //  sufficient permissions it will fail to retrieve information
    //  or ( even worse) will be
    //  succeeded to retrieve partial information.
    //  Therefore refresh is performed only from a rescheduled routine,
    //  in the context of the QM.
    //

    return LogHR(MQDS_UNKNOWN_SITE_ID, s_FN, 20);

}

HRESULT CSiteRoutingInformation::FindBestSiteFromHere(
                                IN const ULONG   cSites,
	                            IN const GUID *  pguidSites,
            	                OUT GUID *       pguidBestSite,
                        	    OUT BOOL *       pfSitegateOnRoute)
/*++

Routine Description:
    finds the site with the least cost from a given array of site, and whether there is a sitegate on the route to it.
    attempts a refresh if no site is found.

Arguments:
    cSites              - number of sites in the passed array
    rgguidSites        - array of sites
    pguidBestSite      - returned site with least cost from here
    pfSitegateOnRoute   - return whether there is a sitegate on the route

Return Value:
	MQ_OK - success
	MQDS_UNKNOWN_SITE_ID - no site was found

	Other HRESULT errors

--*/

{
    CCost costMinimal(0xffffffff);
    ULONG indexMinimal = cSites + 1;
    CNextHop * pMinimalHop = NULL;

    CS lock(m_cs);
    for ( ULONG i = 0; i < cSites; i++)
    {

        CSiteRoutingNode Site( pguidSites[i]);
        CNextHop * pNextHop;
        //
        //  Is it a known site
        //
        if ( m_SiteRoutingTable.Lookup( &Site, pNextHop))
        {
            //
            //  Is it less than the other sites costs
            //
            CCost cost = pNextHop->GetCost();
            if ( cost < costMinimal)
            {
                costMinimal = cost;
                indexMinimal = i;
                pMinimalHop = pNextHop;
            }
        }
    }
    //
    //  Even though failed to find the site, we don't
    //  try to refresh the site-routing table. This is
    //  because this method is called in the context of a user
    //  that called a certain DS API. If user does not have
    //  sufficient permissions it will fail to retrieve information
    //  or ( even worse) will be
    //  succeeded to retrieve partial information.
    //  Therefore refresh is performed only from a rescheduled routine,
    //  in the context of the QM.
    //


    //
    //  if no site was found, return error
    //
    if ( pMinimalHop == NULL)
    {
        return LogHR(MQDS_UNKNOWN_SITE_ID, s_FN, 30);
    }

    ASSERT( indexMinimal < cSites);
    *pguidBestSite = pguidSites[ indexMinimal];
    CSiteGate SiteGate = pMinimalHop->GetSiteGate();
    *pfSitegateOnRoute = SiteGate.IsThereASiteGate();
    return( MQ_OK);
}

HRESULT CSiteRoutingInformation::RefreshSiteRoutingTableInternal()
{
    HRESULT hr = MQ_OK;

    //
    //  rebuild routing table
    //

    CSiteDB SiteDB;
    hr = SiteDB.Init( m_guidThisSiteId);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 40);
    }

    CS lock(m_cs);
    hr = Dijkstra(&SiteDB, &m_SiteRoutingTable);


    return LogHR(hr, s_FN, 50);

}


void WINAPI CSiteRoutingInformation::RefrshSiteRouteTable(
                IN CTimer* pTimer
                   )
{
    CSiteRoutingInformation * pSiteRouteInfo = CONTAINING_RECORD(pTimer, CSiteRoutingInformation, m_RefreshTimer);
    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>

     //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 1614);
    //
    //  ignore failure -> reschedule
    //

    pSiteRouteInfo->RefreshSiteRoutingTableInternal();

    //
    //  reschedule
	//
    ASSERT(!g_fSetupMode);

	ExSetTimer(
		&pSiteRouteInfo->m_RefreshTimer, 
		CTimeDuration::FromMilliSeconds(x_refreshDeltaTime)
		);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\siteinfo.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    siteinfo.cpp

Abstract:

    Site information Class

Author:

    ronit hartmann (ronith)
    Ilan Herbst    (ilanh)   9-July-2000 


--*/
#include "ds_stdh.h"
#include "siteinfo.h"
#include "cs.h"
#include "hquery.h"
#include "mqads.h"
#include "mqadsp.h"
#include "adserr.h"
#include "mqutil.h"
#include "dsutils.h"
#include "ex.h"

#include "siteinfo.tmh"

//
//  refreshinterval of site gates info of a site
//
const DWORD cRefreshSiteInformation ( 1 * 60 * 60 * 1000); /* 1 hour */

static WCHAR *s_FN=L"mqdscore/siteinfo";


/*====================================================

CSiteInformation::CSiteInformation

Arguments:

Return Value:

=====================================================*/
CSiteInformation::CSiteInformation():
                  m_pguidSiteGates(NULL),
                  m_dwNumSiteGates(0),
                  m_fInitialized(FALSE),
                  m_RefreshTimer( RefreshSiteInfo)
{
    //
    //  The object is left in an uninitialized state.
    //  DS operation will be performed in the init method.
    //
}

/*====================================================

CSiteInformation::~CSiteInformation

Arguments:

Return Value:

=====================================================*/
CSiteInformation::~CSiteInformation()
{
    delete [] m_pguidSiteGates;

	ExCancelTimer(&m_RefreshTimer);
}


/*====================================================

CSiteInformation::Init

Arguments:

Return Value:

=====================================================*/

HRESULT CSiteInformation::Init(BOOL fReplicationMode)
{
    ASSERT( m_fInitialized == FALSE);
    HRESULT hr;
    //
    //  First find the unique id of this site
    //
    ASSERT( g_pwcsServerName != NULL);
    //
    //  Find the server in the configuration\sites folder.
    //
    //  In setup mode we just find the first server object with this computer
    //  name.
    //
    //  Not in setup mode, a server object with this computer name may appear
    //  in several sites, and only in some of them msmq-settings is defined.
    //  This can happen in migration.
    //  Therefore we locate the msmq-settings according to this QM-Id
    //
    AP<WCHAR> pwcsServerContainerName;
    if ( g_fSetupMode)
    {
        //
        //  Next find this server in the configuration\sites folder
        //
        MQPROPERTYRESTRICTION propRestriction;
        propRestriction.rel = PREQ;
        propRestriction.prop = PROPID_SRV_NAME;
        propRestriction.prval.vt = VT_LPWSTR;
        propRestriction.prval.pwszVal = g_pwcsServerName;


        MQRESTRICTION restriction;
        restriction.cRes = 1;
        restriction.paPropRes = &propRestriction;

        PROPID prop = PROPID_SRV_FULL_PATH;

        CDsQueryHandle hQuery;
        CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

        hr = g_pDS->LocateBegin(
                eSubTree,	
                eLocalDomainController,	
                &requestDsServerInternal,     // internal DS server operation
                NULL,
                &restriction,
                NULL,
                1,
                &prop,
                hQuery.GetPtr());
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CSiteInformation::init : Locate begin failed %lx"),hr));
            return LogHR(hr, s_FN, 10);
        }
        //
        //  Read the results
        //  BUGBUG - assuming one result ( no support of DC in multiple sites)
        //

        DWORD cp = 1;
        MQPROPVARIANT var;
        var.vt = VT_NULL;

        hr = g_pDS->LocateNext(
                    hQuery.GetHandle(),
                    &requestDsServerInternal,
                    &cp,
                    &var
                    );
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("CSiteInformation::Init : Locate next failed %lx"),hr));
            return LogHR(hr, s_FN, 20);
        }
        if ( cp != 1)
        {
            //
            //  This DS server object was not found
            //
            DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("CSiteInformation::Init : server object not found")));
            return LogHR(MQ_ERROR, s_FN, 30);
        }
        AP<WCHAR> pwcsServerFullPath = var.pwszVal;      // for clean-up purposes
        //
        //  From the unique id of the server get the server container name
        //
        hr = g_pDS->GetParentName(
                eLocalDomainController,
                e_ConfigurationContainer,
                &requestDsServerInternal,        // local DS server operation
                pwcsServerFullPath,
                &pwcsServerContainerName
                );
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CSiteInformation::Init : cannot get servers container name")));
            LogHR(hr, s_FN, 40);
            return MQ_ERROR;
        }
    }
    else
    {
        //
        //  Not in setup mode
        //
        DWORD dwValueType = REG_BINARY ;
        DWORD dwValueSize = sizeof(GUID);
        GUID guidQMId;

        LONG rc = GetFalconKeyValue(MSMQ_QMID_REGNAME,
                                   &dwValueType,
                                   &guidQMId,
                                   &dwValueSize);

        if (rc != ERROR_SUCCESS)
        {
            DBGMSG((DBGMOD_ALL,
                 DBGLVL_ERROR,
                 TEXT("CSiteInformation::Init Can't read QM Guid. Error %d"), GetLastError()));
            LogNTStatus(rc, s_FN, 50);
            return MQ_ERROR;
        }

        MQPROPERTYRESTRICTION propRestriction;
        propRestriction.rel = PREQ;
        propRestriction.prop = PROPID_SET_QM_ID;
        propRestriction.prval.vt = VT_CLSID;
        propRestriction.prval.puuid = &guidQMId;


        MQRESTRICTION restriction;
        restriction.cRes = 1;
        restriction.paPropRes = &propRestriction;

        PROPID prop = PROPID_SET_FULL_PATH;

        CDsQueryHandle hQuery;
        CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

        hr = g_pDS->LocateBegin(
                eSubTree,	
                eLocalDomainController,
                &requestDsServerInternal,     // internal DS server operation
                NULL,
                &restriction,
                NULL,
                1,
                &prop,
                hQuery.GetPtr());
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CSiteInformation::init : Locate begin failed %lx"),hr));
            return LogHR(hr, s_FN, 60);
        }
        //
        //  Read the results
        //  BUGBUG - assuming one result ( no support of DC in multiple sites)
        //

        DWORD cp = 1;
        MQPROPVARIANT var;
        var.vt = VT_NULL;

        hr = g_pDS->LocateNext(
                    hQuery.GetHandle(),
                    &requestDsServerInternal,
                    &cp,
                    &var
                    );
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("CSiteInformation::Init : Locate next failed %lx"),hr));
            return LogHR(hr, s_FN, 70);
        }
        if ( cp != 1)
        {
            //
            //  This server msmq-setting object was not found
            //
            DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("CSiteInformation::Init : server object not found")));
            return LogHR(MQ_ERROR, s_FN, 80);
        }
        AP<WCHAR> pwcsSettingName = var.pwszVal;
        AP<WCHAR> pwcsServerName;

        hr = g_pDS->GetParentName(
                eLocalDomainController,
                e_ConfigurationContainer,
                &requestDsServerInternal,        // local DS server operation
                pwcsSettingName,
                &pwcsServerName
                );

        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CSiteInformation::Init : cannot get server name")));
            LogHR(hr, s_FN, 90);
            return MQ_ERROR;
        }

        hr = g_pDS->GetParentName(
                eLocalDomainController,
                e_ConfigurationContainer,
                &requestDsServerInternal,        // local DS server operation
                pwcsServerName,
                &pwcsServerContainerName
                );

        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CSiteInformation::Init : cannot get server container name")));
            LogHR(hr, s_FN, 100);
            return MQ_ERROR;
        }

    }

    AP<WCHAR> pwcsSiteName;
    //
    //  Get the site name ( site object is the container of the servers container)
    //
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr = g_pDS->GetParentName(
            eLocalDomainController,
            e_ConfigurationContainer,
            &requestDsServerInternal,        // local DS server operation
            pwcsServerContainerName,
            &pwcsSiteName
            );
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CSiteInformation::Init : cannot get site name")));
        LogHR(hr, s_FN, 110);
        return MQ_ERROR;
    }

    //
    //  Finally, from the site-name get the site id
    //
    PROPID prop = PROPID_S_SITEID;
    PROPVARIANT var;
    var.vt = VT_NULL;

    hr = g_pDS->GetObjectProperties(
                eLocalDomainController,	
                &requestDsServerInternal,     // internal operation of the DS server
 	            pwcsSiteName,
                NULL,
                1,
                &prop,
                &var);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CSiteInformation::Init : cannot get site unique id")));
        LogHR(hr, s_FN, 120);
        return MQ_ERROR;
    }
    m_guidSiteId = *var.puuid;


    //
    //  Query the site-gates
    //
    hr = RefreshSiteInfoInternal();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 130);
    }

    m_fInitialized = TRUE;

    //
    //  schedule a refresh
	//
    if ( !g_fSetupMode && !fReplicationMode )
    {
		ExSetTimer(
			&m_RefreshTimer, 
			CTimeDuration::FromMilliSeconds(cRefreshSiteInformation)
			);
    }

    return(MQ_OK);
}



HRESULT CSiteInformation::QueryLinkGates(
                OUT GUID **      ppguidLinkSiteGates,
                OUT DWORD *      pdwNumLinkSiteGates
                )
{
    *pdwNumLinkSiteGates = 0;
    *ppguidLinkSiteGates = NULL;
    CSiteGateList SiteGateList;
    HRESULT hr;
    //
    //  Translate site guid into its DN name
    //
    PROPID prop = PROPID_S_FULL_NAME;
    PROPVARIANT var;
    var.vt = VT_NULL;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    hr = g_pDS->GetObjectProperties(
                eLocalDomainController,
                &requestDsServerInternal,     // internal operation of the DS server
 	            NULL,      // object name
                &m_guidSiteId,      // unique id of object
                1,
                &prop,
                &var);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CSiteInformation::QueryLinkGates : Failed to retrieve the DN of the site %lx"),hr));
        return LogHR(hr, s_FN, 140);
    }
    AP<WCHAR> pwcsSiteDN = var.pwszVal;


    //
    //  retrieve all site-gates where this site
    //  is specified as neighbor-1
    //
    CDSRequestContext requestDsServerInternal1( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr =  MQADSpQueryNeighborLinks(
                        eLinkNeighbor1,
                        pwcsSiteDN,
                        &requestDsServerInternal,     // internal operation of the DS server
                        &SiteGateList
                        );
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CSiteInformation::QueryLinkGates : Failed to query neighbor1 links %lx"),hr));
        return LogHR(hr, s_FN, 150);

    }

    //
    //  retrieve all site-gates where this site
    //  is specified as neighbor-2
    //
    CDSRequestContext requestDsServerInternal2( e_DoNotImpersonate, e_IP_PROTOCOL);
    hr =  MQADSpQueryNeighborLinks(
                        eLinkNeighbor2,
                        pwcsSiteDN,
                        &requestDsServerInternal2,     // internal operation of the DS server
                        &SiteGateList
                        );
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("CSiteInformation::QueryLinkGates : Failed to query neighbor2 links %lx"),hr));
        return LogHR(hr, s_FN, 160);

    }

    //
    //  Fill in the results
    //
    SiteGateList.CopySiteGates(
               ppguidLinkSiteGates,
               pdwNumLinkSiteGates
               );

    return(MQ_OK);

}


HRESULT CSiteInformation::RefreshSiteInfoInternal()
{
    //
    //  retrieve new info
    //

    DWORD dwNumSiteGates;
    AP<GUID> pguidSiteGates;
    HRESULT hr;

    hr = QueryLinkGates(
                &pguidSiteGates,
                &dwNumSiteGates
                );
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("CSiteInformation::RefreshSiteInfo :  failed to retrieve new info")));
        return LogHR(hr, s_FN, 170);
    }
    DWORD dwNumThisSiteGates = 0;
    AP<GUID> pGuidThisSiteGates;
    if (dwNumSiteGates > 0)
    {
        //
        //  Filter the list of site-gates,
        //  and return only gates that belong
        //  to the this site ( they may
        //  belong to more than one site)
        //
        hr = MQADSpFilterSiteGates(
                &m_guidSiteId,
                dwNumSiteGates,
                pguidSiteGates,
                &dwNumThisSiteGates,
                &pGuidThisSiteGates
                );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 180);
        }
    }

    //
    //  Replace old info with new one
    //
    CS  lock( m_cs);
    delete [] m_pguidSiteGates;
    if ( dwNumThisSiteGates > 0)
    {
        m_pguidSiteGates = pGuidThisSiteGates.detach();
    }
    else
    {
        m_pguidSiteGates = NULL;
    }
    m_dwNumSiteGates = dwNumThisSiteGates;
    return LogHR(hr, s_FN, 190);

}


void WINAPI CSiteInformation::RefreshSiteInfo(
                IN CTimer* pTimer
                   )
{
    CSiteInformation * pSiteInfo = CONTAINING_RECORD(pTimer, CSiteInformation, m_RefreshTimer);;
    CCoInit cCoInit; // should be before any R<xxx> or P<xxx> so that its destructor (CoUninitialize)
                     // is called after the release of all R<xxx> or P<xxx>

     //
    // Initialize OLE with auto uninitialize
    //
    HRESULT hr = cCoInit.CoInitialize();
    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 1613);
    //
    //  ignore failure -> reschedule
    //

    pSiteInfo->RefreshSiteInfoInternal();

    //
    //  reschedule
	//
	ASSERT(!g_fSetupMode);

	ExSetTimer(
		&pSiteInfo->m_RefreshTimer, 
		CTimeDuration::FromMilliSeconds(cRefreshSiteInformation)
		);

}


BOOL CSiteInformation::CheckMachineIsSitegate(
                        IN const GUID * pguidMachine)
/*++

Routine Description:
    checks whether a machine is a sitegate

Arguments:
    pguidMachine     -  the unique id of the machine

Return Value:
    TRUE - if the requested machine is a site-gate, false otherwise

--*/
{
    CS lock(m_cs);
    for ( DWORD i = 0; i <  m_dwNumSiteGates; i++)
    {
        if ( *pguidMachine ==  m_pguidSiteGates[i])
        {
            return(TRUE);
        }
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\sitedb.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ctdb.h

Abstract:

    CCTDB Class Implementation

Author:

    Lior Moshaiov (LiorM)


--*/

#include "ds_stdh.h"
#include "routtbl.h"
#include "_rstrct.h"
#include "dscore.h"
#include "adserr.h"

#include "sitedb.tmh"

CCost   g_InfiniteCost(0xffffffff);

#ifdef _DEBUG
extern BOOL g_fSetupMode ;
#endif

static WCHAR *s_FN=L"mqdscore/sitedb";

/*====================================================

GetStartNeighborPosition

Arguments:

Return Value:

Thread Context: main

=====================================================*/
POSITION    CSiteDB::GetStartNeighborPosition(IN const CSiteRoutingNode* pSrc)
{

    const CSiteRoutingNode* pSrcSite = (const CSiteRoutingNode *) pSrc;
    GUID guid;
    CSiteLinksInfo *pLinksInfo;

    m_pos = 0;

    guid = pSrcSite->GetNode();

    if (!(m_SiteLinksMap.Lookup(guid,pLinksInfo)))
    {
        return(NULL);
    }

    if (pLinksInfo->GetNoOfNeighbors() == 0)
    {
        return(NULL);
    }

    return((POSITION)pLinksInfo);
}

/*====================================================

GetNextNeighborAssoc

Arguments:

Return Value:

Thread Context: main

=====================================================*/
void    CSiteDB::GetNextNeighborAssoc(  IN OUT POSITION& pos,
                                        OUT const CSiteRoutingNode*& pKey,
                                        OUT CCost& val,
                                        OUT CSiteGate& SiteGate)
{


    DWORD   dwNeighbors;
    CSiteLinksInfo  *pLinksInfo = (CSiteLinksInfo*) pos;
    ASSERT(pos != NULL);

    pos = NULL;

    dwNeighbors = pLinksInfo->GetNoOfNeighbors();
    ASSERT(m_pos < dwNeighbors);


    CCost cost(pLinksInfo->GetCost(m_pos));
    CSiteGate sitegate(pLinksInfo->IsThereSiteGate(m_pos));
    pKey = pLinksInfo->GetNeighbor(m_pos);
    val = cost;
    SiteGate = sitegate;
    if (m_pos + 1 < dwNeighbors)
    {
        m_pos++;
        pos = (POSITION) pLinksInfo;
    }

    return;

}

//
//  Helper class
//
class CClearCALWSTR
{
public:
    CClearCALWSTR( PROPVARIANT * pVar)    { m_pVar = pVar; }
    ~CClearCALWSTR();
private:
    PROPVARIANT * m_pVar;
};

CClearCALWSTR::~CClearCALWSTR()
{
    for(DWORD i = 0; i < m_pVar->calpwstr.cElems; i++)
    {
        delete[] m_pVar->calpwstr.pElems[i];
    }
    delete [] m_pVar->calpwstr.pElems;

}


/*====================================================

GetAllSiteLinks

Arguments:

Return Value:

Thread Context: main

=====================================================*/
HRESULT CSiteDB::GetAllSiteLinks( )
{
extern HRESULT WINAPI QuerySiteLinks(
                 IN  LPWSTR         pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle);

    HANDLE hQuery;
#define MAX_NO_OF_PROPS 30
    DWORD   dwProps = MAX_NO_OF_PROPS;
    PROPVARIANT result[ MAX_NO_OF_PROPS];
    PROPVARIANT*    pvar;
    DWORD i,nCol;
    HRESULT hr;


    //
    // read all site links information
    //

    //
    //  set Column Set values
    //
    CColumns Colset1;

    Colset1.Add(PROPID_L_NEIGHBOR1);
    Colset1.Add(PROPID_L_NEIGHBOR2);
    Colset1.Add(PROPID_L_COST);
    Colset1.Add(PROPID_L_GATES_DN);
    nCol = 4;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    hr =  QuerySiteLinks(
                  NULL,
                  NULL,
                  Colset1.CastToStruct(),
                  0,
                  &requestDsServerInternal,
                  &hQuery);


    if ( FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
        {
            //
            // In "normal" mode, this call should succeed. If there are no
            // site linkes then the following "LookupNext" will not return
            // any value. that's legal.
            // However, in setup mode, on fresh machine, the above function
            // will fail because the "msmqService" object is not yet defined.
            // So we return MQ_OK always but assert for setup-mode.
            //
            ASSERT(g_fSetupMode) ;
            return MQ_OK ;
        }
        return LogHR(hr, s_FN, 10);
    }



    while ( SUCCEEDED ( hr = DSCoreLookupNext( hQuery, &dwProps, result)))
    {
        //
        //  No more results to retrieve
        //
        if (!dwProps)
            break;
        pvar = result;

        //
        //      Set the link information
        //
        for     ( i=dwProps/nCol; i > 0 ; i--,pvar+=nCol)
        {
            CClearCALWSTR pClean( (pvar+3));
            //
            //  Verify that this is a valid link ( both sites were
            //  not deleted)
            //
            if ( pvar->vt == VT_EMPTY ||
                 (pvar+1)->vt == VT_EMPTY)
            {
                continue;
            }
            //
            //  Set it in neighbor1
 