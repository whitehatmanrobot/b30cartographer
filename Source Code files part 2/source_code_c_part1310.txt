96 - 1999
//
//  File:       provider.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  WintrustAddProvider
//              WintrustRemoveProvider
//
//  History:    30-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "cryptreg.h"

static void inline MySetRegProvider(
    GUID *pgActionID,
    WCHAR *pwszRegKey,
    WCHAR *pwszDLLName,
    WCHAR *pwszFuncName,
    BOOL *pfRet,
    DWORD *pdwErr
    )
{
    BOOL fRet;

    fRet = SetRegProvider(pgActionID, pwszRegKey, pwszDLLName, pwszFuncName);
    if (!fRet && *pfRet) {
        *pfRet = FALSE;
        *pdwErr = GetLastError();
    }
}

BOOL WINAPI WintrustAddActionID(IN GUID *pgActionID, 
                                IN DWORD fdwFlags,
                                IN CRYPT_REGISTER_ACTIONID *psProvInfo)
{
    if (!(psProvInfo) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_REGISTER_ACTIONID, psProvInfo->cbStruct, sTestPolicyProvider)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    BOOL    fRet;
    DWORD   dwErr;

    fRet = TRUE;
    dwErr = 0;

    MySetRegProvider(pgActionID, 
                   REG_INIT_PROVIDER_KEY,
                   psProvInfo->sInitProvider.pwszDLLName,
                   psProvInfo->sInitProvider.pwszFunctionName,
                   &fRet,
                   &dwErr);

    MySetRegProvider(pgActionID, 
                   REG_OBJTRUST_PROVIDER_KEY,
                   psProvInfo->sObjectProvider.pwszDLLName,
                   psProvInfo->sObjectProvider.pwszFunctionName,
                   &fRet,
                   &dwErr);

    MySetRegProvider(pgActionID, 
                   REG_SIGTRUST_PROVIDER_KEY,
                   psProvInfo->sSignatureProvider.pwszDLLName,
                   psProvInfo->sSignatureProvider.pwszFunctionName,
                   &fRet,
                   &dwErr);

    MySetRegProvider(pgActionID, 
                   REG_CERTTRUST_PROVIDER_KEY,
                   psProvInfo->sCertificateProvider.pwszDLLName,
                   psProvInfo->sCertificateProvider.pwszFunctionName,
                   &fRet,
                   &dwErr);

    MySetRegProvider(pgActionID, 
                   REG_CERTPOL_PROVIDER_KEY,
                   psProvInfo->sCertificatePolicyProvider.pwszDLLName,
                   psProvInfo->sCertificatePolicyProvider.pwszFunctionName,
                   &fRet,
                   &dwErr);

    MySetRegProvider(pgActionID, 
                   REG_FINALPOL_PROVIDER_KEY,
                   psProvInfo->sFinalPolicyProvider.pwszDLLName,
                   psProvInfo->sFinalPolicyProvider.pwszFunctionName,
                   &fRet,
                   &dwErr);

    MySetRegProvider(pgActionID, 
                   REG_TESTPOL_PROVIDER_KEY,
                   psProvInfo->sTestPolicyProvider.pwszDLLName,
                   psProvInfo->sTestPolicyProvider.pwszFunctionName,
                   &fRet,
                   &dwErr);

    // this member was added 7/23/1997 pberkman
    if (WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_REGISTER_ACTIONID, psProvInfo->cbStruct, sCleanupProvider))
    {
        MySetRegProvider(pgActionID, 
                       REG_CLEANUP_PROVIDER_KEY,
                       psProvInfo->sCleanupProvider.pwszDLLName,
                       psProvInfo->sCleanupProvider.pwszFunctionName,
                       &fRet,
                       &dwErr);
    }

    if (!fRet && (fdwFlags & WT_ADD_ACTION_ID_RET_RESULT_FLAG))
    {
        SetLastError(dwErr);
        return FALSE;
    } else {
        return TRUE;
    }
}


BOOL WINAPI  WintrustRemoveActionID(IN GUID *pgActionID)
{
    RemoveRegProvider(pgActionID, REG_INIT_PROVIDER_KEY);
    RemoveRegProvider(pgActionID, REG_OBJTRUST_PROVIDER_KEY);
    RemoveRegProvider(pgActionID, REG_SIGTRUST_PROVIDER_KEY);
    RemoveRegProvider(pgActionID, REG_CERTTRUST_PROVIDER_KEY);
    RemoveRegProvider(pgActionID, REG_CERTPOL_PROVIDER_KEY);
    RemoveRegProvider(pgActionID, REG_FINALPOL_PROVIDER_KEY);
    RemoveRegProvider(pgActionID, REG_TESTPOL_PROVIDER_KEY);
    RemoveRegProvider(pgActionID, REG_CLEANUP_PROVIDER_KEY);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\provload.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       provload.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  WintrustLoadFunctionPointers
//              WintrustFindProvider
//              WintrustUnloadProviderList
//
//              *** local functions ***
//              _CheckLoadedProviders
//              _CheckRegisteredProviders
//              _provLoadDLL
//              _provUnloadDLL
//              _provLoadFunction
//
//  History:    29-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "cryptreg.h"
#include    "eventlst.h"

LOADED_PROVIDER *_CheckLoadedProviders(GUID *pgActionID);
LOADED_PROVIDER *_CheckRegisteredProviders(GUID *pgActionID);

BOOL _provLoadDLL(WCHAR *pwszDLL, HINSTANCE *phDLL);
void _provUnloadDLL(HINSTANCE hDLL, WCHAR *pwszDLLName);
BOOL _provLoadFunction(char *pszFunc, HINSTANCE hDLL, void **pfn);

LOADED_PROVIDER                     *pProviderList  = NULL;


BOOL WINAPI WintrustLoadFunctionPointers(GUID *pgActionID, CRYPT_PROVIDER_FUNCTIONS *pPfns)
{
    LOADED_PROVIDER *pProvFuncs;

    if (!(pPfns) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_PROVIDER_FUNCTIONS, pPfns->cbStruct, psUIpfns)))
    {
        return(FALSE);
    }

    if (!(pProvFuncs = WintrustFindProvider(pgActionID)))
    {
        return(FALSE);
    }

    pPfns->pfnAlloc             = WVTNew;
    pPfns->pfnFree              = WVTDelete;
    pPfns->pfnAddStore2Chain    = WVTAddStore;
    pPfns->pfnAddSgnr2Chain     = WVTAddSigner;
    pPfns->pfnAddCert2Chain     = WVTAddCertContext;
    pPfns->pfnAddPrivData2Chain = WVTAddPrivateData;

    pPfns->pfnInitialize        = pProvFuncs->pfnInitialize;
    pPfns->pfnObjectTrust       = pProvFuncs->pfnObjectTrust;
    pPfns->pfnSignatureTrust    = pProvFuncs->pfnSignatureTrust;
    pPfns->pfnCertificateTrust  = pProvFuncs->pfnCertificateTrust;
    pPfns->pfnFinalPolicy       = pProvFuncs->pfnFinalPolicy;
    pPfns->pfnCertCheckPolicy   = pProvFuncs->pfnCertCheckPolicy;
    pPfns->pfnTestFinalPolicy   = pProvFuncs->pfnTestFinalPolicy;
    
    if (WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_PROVIDER_FUNCTIONS, pPfns->cbStruct, pfnCleanupPolicy))
    {
        pPfns->pfnCleanupPolicy = pProvFuncs->pfnCleanupPolicy;
    }

    return(TRUE);
}



LOADED_PROVIDER *WintrustFindProvider(GUID *pgActionID)
{
    LOADED_PROVIDER *pProvider;

    if (!(pProvider = _CheckLoadedProviders(pgActionID)))
    {
#       if (DBG)
            DbgPrintf(DBG_SS, "Loading Provider: %08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n",
                        pgActionID->Data1, pgActionID->Data2, pgActionID->Data3, pgActionID->Data4[0],
                        pgActionID->Data4[1], pgActionID->Data4[2], pgActionID->Data4[3], pgActionID->Data4[4],
                        pgActionID->Data4[5], pgActionID->Data4[6], pgActionID->Data4[7]);
#       endif // DBG

        pProvider = _CheckRegisteredProviders(pgActionID);
    }

#   if (DBG)

        if (!(pProvider))
        {
            DbgPrintf(DBG_SS, "PROV NOT FOUND: %08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n",
                        pgActionID->Data1, pgActionID->Data2, pgActionID->Data3, pgActionID->Data4[0],
                        pgActionID->Data4[1], pgActionID->Data4[2], pgActionID->Data4[3], pgActionID->Data4[4],
                        pgActionID->Data4[5], pgActionID->Data4[6], pgActionID->Data4[7]);
        }

#   endif

    return(pProvider);
}

LOADED_PROVIDER *_CheckLoadedProviders(GUID *pgActionID)
{
    LOADED_PROVIDER     *pProvider;

    AcquireReadLock(sProvLock);

    pProvider = pProviderList;

    while (pProvider)
    {
        if (memcmp(pgActionID, &pProvider->gActionID, sizeof(GUID)) == 0)
        {
            ReleaseReadLock(sProvLock);

            return(pProvider);
        }

        pProvider = pProvider->pNext;
    }

    ReleaseReadLock(sProvLock);

    return(NULL);
}

BOOL WintrustUnloadProviderList(void)
{
    LOADED_PROVIDER *pProvider;
    LOADED_PROVIDER *pProvHold;

    AcquireWriteLock(sProvLock);

    pProvider = pProviderList;

    while (pProvider)
    {
        if (pProvider->hInitDLL)            FreeLibrary(pProvider->hInitDLL);
        if (pProvider->hObjectDLL)          FreeLibrary(pProvider->hObjectDLL);
        if (pProvider->hSignatureDLL)       FreeLibrary(pProvider->hSignatureDLL);
        if (pProvider->hCertTrustDLL)       FreeLibrary(pProvider->hCertTrustDLL);
        if (pProvider->hFinalPolicyDLL)     FreeLibrary(pProvider->hFinalPolicyDLL);
        if (pProvider->hCertPolicyDLL)      FreeLibrary(pProvider->hCertPolicyDLL);
        if (pProvider->hTestFinalPolicyDLL) FreeLibrary(pProvider->hTestFinalPolicyDLL);
        if (pProvider->hCleanupPolicyDLL)   FreeLibrary(pProvider->hCleanupPolicyDLL);

#       if (DBG)
            DbgPrintf(DBG_SS, "Unloading Provider: %08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n",
                        pProvider->gActionID.Data1, pProvider->gActionID.Data2, pProvider->gActionID.Data3, 
                        pProvider->gActionID.Data4[0], pProvider->gActionID.Data4[1], 
                        pProvider->gActionID.Data4[2], pProvider->gActionID.Data4[3], 
                        pProvider->gActionID.Data4[4], pProvider->gActionID.Data4[5], 
                        pProvider->gActionID.Data4[6], pProvider->gActionID.Data4[7]);
#       endif // DBG

        pProvHold = pProvider->pNext;

        delete pProvider;

        pProvider = pProvHold;
    }

    pProviderList = NULL;

    ReleaseWriteLock(sProvLock);

    return(TRUE);
}

LOADED_PROVIDER *_CheckRegisteredProviders(GUID *pgActionID)
{
    LOADED_PROVIDER *pProvider;
    BOOL            fRet;

    WCHAR           wszInitDLL[REG_MAX_KEY_NAME];
    WCHAR           wszObjTrustDLL[REG_MAX_KEY_NAME];
    WCHAR           wszSigTrustDLL[REG_MAX_KEY_NAME];
    WCHAR           wszCertTrustDLL[REG_MAX_KEY_NAME];
    WCHAR           wszCertPolDLL[REG_MAX_KEY_NAME];
    WCHAR           wszFinalPolDLL[REG_MAX_KEY_NAME];
    WCHAR           wszTestFinalPolDLL[REG_MAX_KEY_NAME];
    WCHAR           wszCleanupPolDLL[REG_MAX_KEY_NAME];

    char            szInitFunc[REG_MAX_FUNC_NAME];
    char            szObjTrustFunc[REG_MAX_FUNC_NAME];
    char            szSigTrustFunc[REG_MAX_FUNC_NAME];
    char            szCertTrustFunc[REG_MAX_FUNC_NAME];
    char            szCertPolFunc[REG_MAX_FUNC_NAME];
    char            szFinalPolFunc[REG_MAX_FUNC_NAME];
    char            szTestFinalPolFunc[REG_MAX_FUNC_NAME];
    char            szCleanupPolFunc[REG_MAX_FUNC_NAME];
    
    if (!(GetRegProvider(pgActionID, REG_CERTTRUST_PROVIDER_KEY, &wszCertTrustDLL[0], &szCertTrustFunc[0])))
    {
        return(NULL);
    }

    if (!(GetRegProvider(pgActionID, REG_FINALPOL_PROVIDER_KEY, &wszFinalPolDLL[0], &szFinalPolFunc[0])))
    {
        return(NULL);
    }

    // optional!
    GetRegProvider(pgActionID, REG_INIT_PROVIDER_KEY, &wszInitDLL[0], &szInitFunc[0]);
    GetRegProvider(pgActionID, REG_OBJTRUST_PROVIDER_KEY, &wszObjTrustDLL[0], &szObjTrustFunc[0]);
    GetRegProvider(pgActionID, REG_SIGTRUST_PROVIDER_KEY, &wszSigTrustDLL[0], &szSigTrustFunc[0]);
    GetRegProvider(pgActionID, REG_CERTPOL_PROVIDER_KEY, &wszCertPolDLL[0], &szCertPolFunc[0]);
    GetRegProvider(pgActionID, REG_TESTPOL_PROVIDER_KEY, &wszTestFinalPolDLL[0], &szTestFinalPolFunc[0]);
    GetRegProvider(pgActionID, REG_CLEANUP_PROVIDER_KEY, &wszCleanupPolDLL[0], &szCleanupPolFunc[0]);

    AcquireWriteLock(sProvLock);

    if (!(pProvider = (LOADED_PROVIDER *)WVTNew(sizeof(LOADED_PROVIDER))))
    {
        ReleaseWriteLock(sProvLock);
        return(NULL);
    }

    memset(pProvider, 0x00, sizeof(LOADED_PROVIDER));

    memcpy(&pProvider->gActionID, pgActionID, sizeof(GUID));

    fRet = TRUE;

    fRet &= _provLoadDLL(&wszCertTrustDLL[0],        &pProvider->hCertTrustDLL);
    fRet &= _provLoadDLL(&wszFinalPolDLL[0],         &pProvider->hFinalPolicyDLL);
    
    // optional!
    _provLoadDLL(&wszInitDLL[0],                     &pProvider->hInitDLL);
    _provLoadDLL(&wszObjTrustDLL[0],                 &pProvider->hObjectDLL);
    _provLoadDLL(&wszSigTrustDLL[0],                 &pProvider->hSignatureDLL);
    _provLoadDLL(&wszCertPolDLL[0],                  &pProvider->hCertPolicyDLL);
    _provLoadDLL(&wszTestFinalPolDLL[0],             &pProvider->hTestFinalPolicyDLL);
    _provLoadDLL(&wszCleanupPolDLL[0],               &pProvider->hCleanupPolicyDLL);

    fRet &= _provLoadFunction(&szCertTrustFunc[0], pProvider->hCertTrustDLL, (void **)&pProvider->pfnCertificateTrust);
    fRet &= _provLoadFunction(&szFinalPolFunc[0],  pProvider->hFinalPolicyDLL, (void **)&pProvider->pfnFinalPolicy);

    // optional!
    _provLoadFunction(&szInitFunc[0],                pProvider->hInitDLL, (void **)&pProvider->pfnInitialize);
    _provLoadFunction(&szObjTrustFunc[0],            pProvider->hObjectDLL, (void **)&pProvider->pfnObjectTrust);
    _provLoadFunction(&szSigTrustFunc[0],            pProvider->hSignatureDLL, (void **)&pProvider->pfnSignatureTrust);
    _provLoadFunction(&szCertPolFunc[0],             pProvider->hCertPolicyDLL, (void **)&pProvider->pfnCertCheckPolicy);
    _provLoadFunction(&szTestFinalPolFunc[0],        pProvider->hTestFinalPolicyDLL, (void **)&pProvider->pfnTestFinalPolicy);
    _provLoadFunction(&szCleanupPolFunc[0],          pProvider->hCleanupPolicyDLL, (void **)&pProvider->pfnCleanupPolicy);

    if (!(fRet))
    {
        ReleaseWriteLock(sProvLock);

        _provUnloadDLL(pProvider->hInitDLL,              &wszInitDLL[0]);
        _provUnloadDLL(pProvider->hObjectDLL,            &wszObjTrustDLL[0]);
        _provUnloadDLL(pProvider->hSignatureDLL,         &wszSigTrustDLL[0]);
        _provUnloadDLL(pProvider->hCertTrustDLL,         &wszCertTrustDLL[0]);
        _provUnloadDLL(pProvider->hFinalPolicyDLL,       &wszFinalPolDLL[0]);
        _provUnloadDLL(pProvider->hCertPolicyDLL,        &wszCertPolDLL[0]);
        _provUnloadDLL(pProvider->hTestFinalPolicyDLL,   &wszTestFinalPolDLL[0]);
        _provUnloadDLL(pProvider->hCleanupPolicyDLL,     &wszCleanupPolDLL[0]);

        delete pProvider;
        
        return(NULL);
    }

    pProvider->pNext            = pProviderList;
    pProvider->pPrev            = NULL;

    if (pProvider->pNext)
    {
        pProvider->pNext->pPrev = pProvider;
    }

    pProviderList = pProvider;

    ReleaseWriteLock(sProvLock);

    return(pProvider);
}

BOOL _provLoadDLL(WCHAR *pwszDLL, HINSTANCE *phDLL)
{
    *phDLL = NULL;

    if (!(pwszDLL[0]))
    {
        return(FALSE);
    }

    if (_wcsicmp(pwszDLL, W_MY_NAME) == 0)
    {
        *phDLL = (HINSTANCE)hMeDLL;
    }
    else
    {
        *phDLL = LoadLibraryU(pwszDLL);
    }

    if (*phDLL)
    {
        return(TRUE);
    }

    return(FALSE);
}

BOOL _provLoadFunction(char *pszFunc, HINSTANCE hDLL, void **pfn)
{
    *pfn = NULL;

    if (!(pszFunc[0]) ||
        !(hDLL))
    {
        return(FALSE);
    }

    *pfn = (void *)GetProcAddress(hDLL, pszFunc);

    if (*pfn)
    {
        return(TRUE);
    }

    return(FALSE);
}

void _provUnloadDLL(HINSTANCE hDLL, WCHAR *pwszDLLName)
{
    if ((hDLL) &&
        (_wcsicmp(pwszDLLName, W_MY_NAME) != 0))
    {
        FreeLibrary(hDLL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\storprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       storprov.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  StoreProviderGetStore
//              StoreProviderUnload
//
//              *** local functions ***
//              _RefreshStores
//              _OpenStore
//
//  History:    15-Oct-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

void        _RefreshStores(HCRYPTPROV hProv);
HCERTSTORE  _OpenStore(HCRYPTPROV hProv, DWORD dwFlags, WCHAR *pszStoreName);

static STORE_REF KnownStores[] =
{
    CERT_SYSTEM_STORE_CURRENT_USER,     L"ROOT",        NULL,
    CERT_SYSTEM_STORE_CURRENT_USER,     L"TRUST",       NULL,
    CERT_SYSTEM_STORE_CURRENT_USER,     L"CA",          NULL,
    CERT_SYSTEM_STORE_CURRENT_USER,     L"MY",          NULL,
    CERT_SYSTEM_STORE_LOCAL_MACHINE,    L"SPC",         NULL,
    0, NULL, NULL
};

HCERTSTORE StoreProviderGetStore(HCRYPTPROV hProv, DWORD dwStoreId)
{
#if (!(USE_IEv4CRYPT32))

    if (!(FIsWinNT()))
    {

#endif
        return(_OpenStore(hProv, KnownStores[dwStoreId].dwFlags, KnownStores[dwStoreId].pwszStoreName));

#if (!(USE_IEv4CRYPT32))
    }

    HCERTSTORE  hStore;

    if (WaitForSingleObject(hStoreEvent, 0) == WAIT_OBJECT_0)
    {
        ResetListEvent(hStoreEvent);
        _RefreshStores(hProv);
    }

    AcquireReadLock(sStoreLock);

    if (KnownStores[dwStoreId].hStore)
    {
        hStore = CertDuplicateStore(KnownStores[dwStoreId].hStore);
    }
    else
    {
        hStore = NULL;
    }
 
    ReleaseReadLock(sStoreLock);

    return(hStore);

#endif  // ! USE_IEv4CRYPT32
}

BOOL StoreProviderUnload(void)
{
#if (!(USE_IEv4CRYPT32))

    AcquireWriteLock(sStoreLock);

    STORE_REF   *pRef;

    pRef = &KnownStores[0];

    while (pRef->pwszStoreName)
    {
        if (pRef->hStore)
        {
            CertCloseStore(pRef->hStore, 0);
            pRef->hStore = NULL;
        }

        pRef++;
    }

    ReleaseWriteLock(sStoreLock);

#endif  // ! USE_IEv4CRYPT32

    return(TRUE);
}


void _RefreshStores(HCRYPTPROV hProv)
{
#if (!(USE_IEv4CRYPT32))

    AcquireWriteLock(sStoreLock);

    STORE_REF   *pRef;

    pRef = &KnownStores[0];

    while (pRef->pwszStoreName)
    {
        if (pRef->hStore)
        {
            CertControlStore(pRef->hStore, 0, CERT_STORE_CTRL_RESYNC, NULL);
        }
        else
        {
            pRef->hStore = _OpenStore(hProv, pRef->dwFlags, pRef->pwszStoreName);
            //
            //  tell crypt32 to notify use if a cert is added or deleted.
            //
            if (pRef->hStore)
            {
                CertControlStore(pRef->hStore, 0, CERT_STORE_CTRL_NOTIFY_CHANGE, &hStoreEvent);
            }

        }

        pRef++;
    }

    ResetListEvent(hStoreEvent);

    ReleaseWriteLock(sStoreLock);

#endif  // ! USE_IEv4CRYPT32
}

HCERTSTORE _OpenStore(HCRYPTPROV hProv, DWORD dwFlags, WCHAR *pwszStoreName)
{
    HCERTSTORE  hStore;

    //
    // first try read/write... just in case the user goes into cryptui and changes something.
    //
    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W, 0, hProv,
                           CERT_STORE_NO_CRYPT_RELEASE_FLAG | 
                           CERT_STORE_OPEN_EXISTING_FLAG | dwFlags,
                           pwszStoreName);

    if (!(hStore))
    {
        hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W, 0, hProv,
                               CERT_STORE_NO_CRYPT_RELEASE_FLAG |
                               CERT_STORE_READONLY_FLAG | dwFlags,
                               pwszStoreName);
    }

    return(hStore);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\registry.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       registry.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  WintrustGetRegPolicyFlags
//              GetRegProvider
//              SetRegProvider
//              GetRegSecuritySettings
//
//  History:    28-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "cryptreg.h"


#define     SZIE30SAFTYLEVEL            L"Software\\Microsoft\\Internet Explorer\\Security"
#define     SZIE30SAFTYLEVELNAME        L"Safety Warning Level"
#define     STATUS_SIZE                 64

BOOL GetRegProvider(GUID *pgActionID, WCHAR *pwszRegKey, WCHAR *pwszRetDLLName, char *pszRetFuncName)
{
    HKEY            hKey;
    WCHAR           wsz[REG_MAX_KEY_NAME];
    WCHAR           wszGuid[REG_MAX_GUID_TEXT];
    DWORD           dwType;
    DWORD           dwSize;

    if (!(pgActionID) ||
        !(pwszRegKey) ||
        !(pwszRetDLLName) ||
        !(pszRetFuncName))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    pwszRetDLLName[0]       = NULL;
    pszRetFuncName[0]       = NULL;


    if (!(guid2wstr(pgActionID, &wszGuid[0])))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    wcscpy(&wsz[0], pwszRegKey);
    wcscat(&wsz[0], L"\\");
    wcscat(&wsz[0], &wszGuid[0]);

    if (RegOpenKeyExU(  HKEY_LOCAL_MACHINE,
                        &wsz[0],
                        0,
                        KEY_READ,
                        &hKey) != ERROR_SUCCESS)
    {
        return(FALSE);
    }

    dwType = 0;
    dwSize = (REG_MAX_KEY_NAME) * sizeof(WCHAR);

    if (RegQueryValueExU(   hKey, 
                            REG_DLL_NAME,
                            NULL, 
                            &dwType,
                            (BYTE *)pwszRetDLLName,
                            &dwSize) != ERROR_SUCCESS)
    {
        pwszRetDLLName[0] = NULL;
        RegCloseKey(hKey);
        return(FALSE);
    }


    dwType = 0;
    dwSize = (REG_MAX_FUNC_NAME) * sizeof(WCHAR);

    if (RegQueryValueExU(   hKey, 
                            REG_FUNC_NAME,
                            NULL, 
                            &dwType,
                            (BYTE *)&wsz[0],
                            &dwSize) != ERROR_SUCCESS)
    {
        pszRetFuncName[0] = NULL;
        RegCloseKey(hKey);
        return(FALSE);
    }

    if (WideCharToMultiByte(0, 0, &wsz[0], wcslen(&wsz[0]) + 1,
                            pszRetFuncName, REG_MAX_FUNC_NAME, NULL, NULL) < 1)
    {
        RegCloseKey(hKey);
        return(FALSE);
    }


    RegCloseKey(hKey);

    return(TRUE);
}

BOOL SetRegProvider(GUID *pgActionID, WCHAR *pwszRegKey, WCHAR *pwszDLLName, WCHAR *pwszFuncName)
{
    HRESULT         hr;
    DWORD           dwDisposition;
    HKEY            hKey;
    WCHAR           wsz[REG_MAX_KEY_NAME];
    WCHAR           wszGuid[REG_MAX_GUID_TEXT];

    if (!(pgActionID) ||
        !(pwszRegKey) ||
        !(pwszDLLName) ||
        !(pwszFuncName))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(guid2wstr(pgActionID, &wszGuid[0])))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    wcscpy(&wsz[0], pwszRegKey);
    wcscat(&wsz[0], L"\\");
    wcscat(&wsz[0], &wszGuid[0]);

    hr = RegCreateKeyExU(HKEY_LOCAL_MACHINE,
                        &wsz[0],
                        0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                        &hKey, &dwDisposition);
    if (hr != ERROR_SUCCESS)
    {
        SetLastError(hr);
        return(FALSE);
    }

    hr = RegSetValueExU(hKey, REG_DLL_NAME,
                        0, REG_SZ,
                        (BYTE *)pwszDLLName,
                        (wcslen(pwszDLLName) + 1) * sizeof(WCHAR));

    hr |= RegSetValueExU(hKey, REG_FUNC_NAME,
                        0, REG_SZ,
                        (BYTE *)pwszFuncName,
                        (wcslen(pwszFuncName) + 1) * sizeof(WCHAR));


    RegCloseKey(hKey);

    if (hr != ERROR_SUCCESS)
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL RemoveRegProvider(GUID *pgActionID, WCHAR *pwszRegKey)
{
    WCHAR           wsz[REG_MAX_KEY_NAME];
    WCHAR           wszGuid[REG_MAX_GUID_TEXT];

    if (!(pgActionID) ||
        !(pwszRegKey))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(guid2wstr(pgActionID, &wszGuid[0])))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    wcscpy(&wsz[0], pwszRegKey);
    wcscat(&wsz[0], L"\\");
    wcscat(&wsz[0], &wszGuid[0]);

    if (RegDeleteKeyU(HKEY_LOCAL_MACHINE, &wsz[0]) != ERROR_SUCCESS)
    {
        return(FALSE);
    }

    return(TRUE);
}

void GetRegSecuritySettings(DWORD *pdwState)
{
    HKEY    hKeyRoot;
    WCHAR   wszBuffer[STATUS_SIZE];
    DWORD   dwType;
    DWORD   dwSize;

    dwType      = 0;
    dwSize      = STATUS_SIZE * sizeof(WCHAR);

    *pdwState = 2;  // Default to high

    if (RegOpenHKCUKeyExU(  HKEY_CURRENT_USER,
                            SZIE30SAFTYLEVEL,
                            0,                  // dwReserved
                            KEY_READ,
                            &hKeyRoot) != ERROR_SUCCESS)
    {
        return;
    }

    if (RegQueryValueExU(   hKeyRoot, 
                            SZIE30SAFTYLEVELNAME,
                            NULL, 
                            &dwType,
                            (BYTE *)&wszBuffer[0], 
                            &dwSize) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyRoot);
        return;
    }

    RegCloseKey(hKeyRoot);

    if (dwType == REG_SZ) 
    {
        if      (wcscmp(&wszBuffer[0], L"FailInform") == 0)
        {
            *pdwState = 2;
        }
        else if (wcscmp(&wszBuffer[0], L"Query") == 0)
        {
            *pdwState = 1;
        }
        else if (wcscmp(&wszBuffer[0], L"SucceedSilent") == 0)
        {
            *pdwState = 0;
        }
    } 
}

void WINAPI WintrustGetRegPolicyFlags(DWORD *pdwState) 
{
	HKEY    hKey;
	DWORD   dwDisposition;
	DWORD   lErr;
    DWORD   dwType;
    DWORD   cbData;

    *pdwState   = 0;

    cbData      = sizeof(DWORD);

    // Open the registry and get to the state var
    if (RegCreateHKCUKeyExU(HKEY_CURRENT_USER,
                            REGPATH_WINTRUST_POLICY_FLAGS,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ,
                            NULL,
                            &hKey,
                            &dwDisposition) != ERROR_SUCCESS)
    {
        return;
    }

	// read the state var
    if (RegQueryValueExU(   hKey,
                            REGNAME_WINTRUST_POLICY_FLAGS,
                            NULL,
                            &dwType,
                            (BYTE *)pdwState,
                            &cbData) != ERROR_SUCCESS)
    {
        *pdwState = 0;
        RegCloseKey(hKey);
        return;
    }

    RegCloseKey(hKey);

    if ((dwType != REG_DWORD) &&
        (dwType != REG_BINARY))
    {
        *pdwState = 0;
        return;
    }
}

BOOL WINAPI WintrustSetRegPolicyFlags(DWORD dwState) 
{
	HKEY    hKey;
	DWORD   dwDisposition;
	DWORD   lErr;
    DWORD   dwType;
    DWORD   cbData;

    cbData      = sizeof(DWORD);

    if (RegCreateHKCUKeyExU(HKEY_CURRENT_USER,
                        REGPATH_WINTRUST_POLICY_FLAGS,
                        0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                        &hKey, &dwDisposition) != ERROR_SUCCESS)
    {
        return(FALSE);
    }

    if (RegSetValueExU(hKey, 
                        REGNAME_WINTRUST_POLICY_FLAGS,
                        0,
                        REG_DWORD,
                        (BYTE *)&dwState,
                        sizeof(DWORD)) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return(FALSE);
    }

    RegCloseKey(hKey);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\storprov.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       storprov.h
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  History:    15-Oct-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef STORPROV_H
#define STORPROV_H

#ifdef __cplusplus
extern "C" 
{
#endif


#define     WVT_STOREID_ROOT        0
#define     WVT_STOREID_TRUST       1
#define     WVT_STOREID_CA          2
#define     WVT_STOREID_MY          3
#define     WVT_STOREID_SPC         4
#define     WVT_STOREID_MAX         5

typedef struct STORE_REF_
{
    DWORD       dwFlags;
    WCHAR       *pwszStoreName;
    HCERTSTORE  hStore;
} STORE_REF;


extern HCERTSTORE   StoreProviderGetStore(HCRYPTPROV hProv, DWORD dwStoreId);
extern BOOL         StoreProviderUnload(void);


#ifdef __cplusplus
}
#endif

#endif // STORPROV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\trustapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       trustapi.cpp
//
//  Contents:   Microsoft Internet Security Trust APIs
//
//  Functions:  TrustFindIssuerCertificate
//              TrustOpenStores
//              TrustDecode
//              TrustFreeDecode
//
//              *** local functions ***
//              _CompareAuthKeyId
//              _CompareAuthKeyId2
//              _SetCertErrorAndHygiene
//              _GetExternalIssuerCert
//
//  History:    20-Nov-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


BOOL _CompareAuthKeyId(DWORD dwEncoding, PCCERT_CONTEXT pChildContext, 
                       PCCERT_CONTEXT pParentContext);
BOOL _CompareAuthKeyId2(DWORD dwEncoding, PCCERT_CONTEXT pChildContext, 
                        PCCERT_CONTEXT pParentContext);
BOOL _SetCertErrorAndHygiene(PCCERT_CONTEXT pSubjectContext, 
                             PCCERT_CONTEXT pIssuerContext,
                             DWORD dwCurrentConfidence, DWORD *pdwError);
PCCERT_CONTEXT _GetExternalIssuerCert(PCCERT_CONTEXT pContext, 
                                      DWORD dwEncoding,
                                      DWORD *pdwRetError, 
                                      DWORD *pdwConfidence,
                                      FILETIME *psftVerifyAsOf);

void _SetConfidenceOnIssuer(DWORD dwEncoding, PCCERT_CONTEXT pChildCert, PCCERT_CONTEXT pTestIssuerCert, 
                            DWORD dwVerificationFlag, FILETIME *psftVerifyAsOf, DWORD *pdwConfidence, 
                            DWORD *pdwError);

PCCERT_CONTEXT WINAPI TrustFindIssuerCertificate(PCCERT_CONTEXT pChildContext,
                                                 DWORD dwEncoding,
                                                 DWORD chStores,
                                                 HCERTSTORE  *pahStores,
                                                 FILETIME *psftVerifyAsOf,
                                                 DWORD *pdwConfidence,
                                                 DWORD *pdwError,
                                                 DWORD dwFlags)
{
    if (!(pChildContext) ||
        !(pahStores) ||
        !(psftVerifyAsOf) ||
        (dwFlags != 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    PCCERT_CONTEXT  pCertContext;
    DWORD           fdwRetError;
    DWORD           fdwWork;
    DWORD           dwError;
    PCCERT_CONTEXT  pCertWithHighestConfidence;
    DWORD           dwHighestConfidence;
    DWORD           dwConfidence;

    if (pdwError)
    {
        *pdwError       = ERROR_SUCCESS;
    }

    dwConfidence    = 0;

    dwHighestConfidence         = 0;
    pCertWithHighestConfidence  = NULL;

    fdwRetError                 = 0;
    fdwWork                     = 0;

    for (int i = 0; i < (int)chStores; i++)
    {
        fdwWork         = CERT_STORE_SIGNATURE_FLAG;

        pCertContext    = NULL;

        while (pCertContext = CertGetIssuerCertificateFromStore(pahStores[i],
                                                                pChildContext,
                                                                pCertContext,
                                                                &fdwWork))
        {
            _SetConfidenceOnIssuer(dwEncoding, pChildContext, pCertContext, fdwWork,
                                   psftVerifyAsOf, &dwConfidence, &dwError);
        
            if (dwConfidence > dwHighestConfidence)
            {
                if (pCertWithHighestConfidence)
                {
                    CertFreeCertificateContext(pCertWithHighestConfidence);
                }

                dwHighestConfidence         = dwConfidence;
                pCertWithHighestConfidence  = CertDuplicateCertificateContext(pCertContext);
                fdwRetError                 = dwError;
            }

            if (dwConfidence >= CERT_CONFIDENCE_HIGHEST)
            {
                if (pdwError)
                {
                    *pdwError       = dwError;
                }

                if (pdwConfidence)
                {
                    *pdwConfidence  = dwConfidence;
                }

                CertFreeCertificateContext(pCertContext);

                return(pCertWithHighestConfidence);
            }

            fdwWork = CERT_STORE_SIGNATURE_FLAG;
        }
    }

    if (!(dwHighestConfidence & CERT_CONFIDENCE_HYGIENE))
    {
        if (pCertContext = _GetExternalIssuerCert(pChildContext, 
                                                  dwEncoding,
                                                  &fdwRetError, 
                                                  &dwConfidence,
                                                  psftVerifyAsOf))
        {
            if (dwHighestConfidence < dwConfidence)
            {
                CertFreeCertificateContext(pCertWithHighestConfidence);

                pCertWithHighestConfidence  = pCertContext;

                dwHighestConfidence         = dwConfidence;
            }
        }
    }

    if (pdwError)
    {
        *pdwError       = fdwRetError;
    }

    if (pdwConfidence)
    {
        *pdwConfidence  = dwHighestConfidence;
    }

    return(pCertWithHighestConfidence);
}

BOOL WINAPI TrustOpenStores(HCRYPTPROV hProv, OUT DWORD *pchStores, 
                            HCERTSTORE *pahStores, DWORD dwFlags)
{
    BOOL        fRet;
    DWORD       cs = 0;
    HCERTSTORE  pas[WVT_STOREID_MAX];

    fRet = FALSE;

    if (!(pchStores) ||
        (dwFlags != 0))
    {
        goto ErrorInvalidParam;
    }


    //
    //  ROOT store - ALWAYS #0 !!!!
    //
    if (!(pas[cs] = StoreProviderGetStore(hProv, WVT_STOREID_ROOT)))
    {
        goto ErrorNoRootStore;
    }

    cs++;

    if (pas[cs] = StoreProviderGetStore(hProv, WVT_STOREID_TRUST))
    {
        cs++;
    }

    if (pas[cs] = StoreProviderGetStore(hProv, WVT_STOREID_CA))
    {
        cs++;
    }
    
    if (pas[cs] = StoreProviderGetStore(hProv, WVT_STOREID_MY))
    {
        cs++;
    }

    if ((pahStores) && (cs > *pchStores))
    {
        *pchStores = cs;
        goto ErrorMoreData;
    }

    *pchStores = cs;

    fRet = TRUE;

    if (!(pahStores))
    {
        goto ErrorMoreData;
    }

    DWORD   i;

    for (i = 0; i < cs; i++)
    {
        pahStores[i] = pas[i];
    }

CommonReturn:
    return(fRet);


ErrorReturn:
    while (cs > 0)
    {
        CertCloseStore(pas[cs - 1], 0);
        cs--;
    }

    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, ErrorMoreData,     ERROR_MORE_DATA);
    SET_ERROR_VAR_EX(DBG_SS, ErrorNoRootStore,  TRUST_E_SYSTEM_ERROR);
    SET_ERROR_VAR_EX(DBG_SS, ErrorInvalidParam, ERROR_INVALID_PARAMETER);
}


BOOL WINAPI TrustIsCertificateSelfSigned(PCCERT_CONTEXT pContext,
                                         DWORD dwEncoding, 
                                         DWORD dwFlags)
{
    if (!(pContext) ||
        (dwFlags != 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(CertCompareCertificateName(dwEncoding, 
                                     &pContext->pCertInfo->Issuer,
                                     &pContext->pCertInfo->Subject)))
    {
        return(FALSE);
    }

    DWORD   dwFlag;

    dwFlag = CERT_STORE_SIGNATURE_FLAG;

    if (!(CertVerifySubjectCertificateContext(pContext, pContext, &dwFlag)) || 
        (dwFlag & CERT_STORE_SIGNATURE_FLAG))
    {
        return(FALSE);
    }

    return(TRUE);
}

#define sz_CRYPTNET_DLL                 "cryptnet.dll"
#define sz_CryptGetObjectUrl            "CryptGetObjectUrl"
#define sz_CryptRetrieveObjectByUrlW    "CryptRetrieveObjectByUrlW"
typedef BOOL (WINAPI *PFN_CRYPT_GET_OBJECT_URL)(
    IN LPCSTR pszUrlOid,
    IN LPVOID pvPara,
    IN DWORD dwFlags,
    OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
    IN OUT DWORD* pcbUrlArray,
    OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
    IN OUT OPTIONAL DWORD* pcbUrlInfo,
    IN OPTIONAL LPVOID pvReserved
    );

typedef BOOL (WINAPI *PFN_CRYPT_RETRIEVE_OBJECT_BY_URLW)(
    IN LPCWSTR pszUrl,
    IN LPCSTR pszObjectOid,
    IN DWORD dwRetrievalFlags,
    IN DWORD dwTimeout,
    OUT LPVOID* ppvObject,
    IN HCRYPTASYNC hAsyncRetrieve,
    IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
    IN OPTIONAL LPVOID pvVerify,
    IN OPTIONAL LPVOID pvReserved
    );


PCCERT_CONTEXT _GetExternalIssuerCert(PCCERT_CONTEXT pContext, 
                                      DWORD dwEncoding,
                                      DWORD *pdwRetError,
                                      DWORD *pdwConfidence,
                                      FILETIME *psftVerifyAsOf)
{
    *pdwConfidence  = 0;

#if (USE_IEv4CRYPT32)

    return(NULL);

#else


    DWORD                       cbUrlArray;
    CRYPT_URL_ARRAY             *pUrlArray;
    PCCERT_CONTEXT              pIssuer;
    PCCERT_CONTEXT              pCertBestMatch;
    DWORD                       dwHighestConfidence;
    DWORD                       dwConfidence;
    DWORD                       dwStatus;
    DWORD                       dwError;
    DWORD                       i;

    pCertBestMatch      = NULL;
    pIssuer             = NULL;
    pUrlArray           = NULL;
    cbUrlArray          = 0;
    dwHighestConfidence = 0;

    HMODULE hDll = NULL;
    PFN_CRYPT_GET_OBJECT_URL pfnCryptGetObjectUrl;
    PFN_CRYPT_RETRIEVE_OBJECT_BY_URLW pfnCryptRetrieveObjectByUrlW;

    if (NULL == (hDll = LoadLibraryA(sz_CRYPTNET_DLL)))
        goto LoadCryptNetDllError;

    if (NULL == (pfnCryptGetObjectUrl =
            (PFN_CRYPT_GET_OBJECT_URL) GetProcAddress(hDll,
                sz_CryptGetObjectUrl)))
        goto CryptGetObjectUrlProcAddressError;

    if (NULL == (pfnCryptRetrieveObjectByUrlW =
            (PFN_CRYPT_RETRIEVE_OBJECT_BY_URLW) GetProcAddress(hDll,
                sz_CryptRetrieveObjectByUrlW)))
        goto CryptRetrieveObjectByUrlWProcAddressError;


    if (!(pfnCryptGetObjectUrl(URL_OID_CERTIFICATE_ISSUER, (void *)pContext, 0, NULL, &cbUrlArray, NULL, NULL, NULL)) ||
        (cbUrlArray < 1))
    {
        goto GetObjectUrlFailed;
    }

    if (!(pUrlArray = (CRYPT_URL_ARRAY *) new BYTE[cbUrlArray]))
    {
        goto MemoryError;
    }

    memset(pUrlArray, 0x00, cbUrlArray);

    if (!(pfnCryptGetObjectUrl(URL_OID_CERTIFICATE_ISSUER, (void *)pContext, 0, pUrlArray, &cbUrlArray, NULL, NULL, NULL)))
    {
        goto GetObjectUrlFailed;
    }

    for (i = 0; i < pUrlArray->cUrl; i++)
    {
        if (pIssuer)
        {
            CertFreeCertificateContext(pIssuer);
            pIssuer = NULL;
        }

        if (pfnCryptRetrieveObjectByUrlW(pUrlArray->rgwszUrl[i], CONTEXT_OID_CERTIFICATE, 0, 0, (void **)&pIssuer,
                                      NULL, NULL, NULL, NULL))
        {
            if (!(CertCompareCertificateName(X509_ASN_ENCODING, &pContext->pCertInfo->Issuer,
                                             &pIssuer->pCertInfo->Subject)))
            {
                continue;
            }
    
            dwStatus = CERT_STORE_SIGNATURE_FLAG;

            if (!(CertVerifySubjectCertificateContext(pContext, pIssuer, &dwStatus)))
            {
                continue;
            }

            dwError = 0;
            _SetConfidenceOnIssuer(dwEncoding, pContext, pIssuer, dwStatus, psftVerifyAsOf, 
                                   &dwConfidence, &dwError);

            if (dwError != 0)
            {
                continue;
            }

            if (dwConfidence > dwHighestConfidence)
            {
                if (pCertBestMatch)
                {
                    CertFreeCertificateContext(pCertBestMatch);
                }

                dwHighestConfidence = dwConfidence;
                pCertBestMatch      = CertDuplicateCertificateContext(pIssuer);
            }

            if (dwConfidence >= CERT_CONFIDENCE_HIGHEST)
            {
                goto CommonReturn;
            }
        }
    }

    goto RetrieveObjectFailed;


CommonReturn:
    if (hDll)
        FreeLibrary(hDll);

    if (pIssuer)
    {
        CertFreeCertificateContext(pIssuer);
    }

    if (pUrlArray)
    {
        delete pUrlArray;
    }

    *pdwConfidence  = dwHighestConfidence;

    return(pCertBestMatch);

ErrorReturn:
    
    if (pCertBestMatch)
    {
        CertFreeCertificateContext(pCertBestMatch);
        pCertBestMatch = NULL;
    }

    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, LoadCryptNetDllError)
    TRACE_ERROR_EX(DBG_SS, CryptGetObjectUrlProcAddressError)
    TRACE_ERROR_EX(DBG_SS, CryptRetrieveObjectByUrlWProcAddressError)

    TRACE_ERROR_EX(DBG_SS, GetObjectUrlFailed);
    TRACE_ERROR_EX(DBG_SS, RetrieveObjectFailed);

    SET_ERROR_VAR_EX(DBG_SS, MemoryError, ERROR_NOT_ENOUGH_MEMORY);

#endif // USE_IEv4CRYPT32
}

BOOL WINAPI TrustDecode(DWORD dwModuleId, BYTE **ppbRet, DWORD *pcbRet, DWORD cbHint,
                        DWORD dwEncoding, const char *pcszOID, const BYTE *pbEncoded, DWORD cbEncoded,
                        DWORD dwDecodeFlags)
{
    if (!(*ppbRet = new BYTE[cbHint]))
    {
        goto MemoryError;
    }

    *pcbRet = cbHint;

    if (!(CryptDecodeObject(dwEncoding, pcszOID, pbEncoded, cbEncoded, dwDecodeFlags,
                            *ppbRet, pcbRet)))
    {
        if (GetLastError() != ERROR_MORE_DATA)
        {
            goto DecodeError;
        }
    }

    if (cbHint < *pcbRet)
    {
        DBG_PRINTF((DBG_SS, "****** TrustDecode(0x%08.8lX): recalling due to bad size: hint: %lu actual: %lu\r\n", 
                    dwModuleId, cbHint, *pcbRet));

        DELETE_OBJECT(*ppbRet);

        return(TrustDecode(dwModuleId, ppbRet, pcbRet, *pcbRet, dwEncoding, pcszOID, 
                           pbEncoded, cbEncoded, dwDecodeFlags));
    }

#   if DBG
        if ((cbHint / 3) > *pcbRet)
        {
            DBG_PRINTF((DBG_SS, "TrustDecode(0x%08.8lX): hint too big. hint: %lu actual: %lu\r\n", 
                        dwModuleId, cbHint, *pcbRet));
        }
#   endif

    return(TRUE);

ErrorReturn:
    DELETE_OBJECT(*ppbRet);
    return(FALSE);

    TRACE_ERROR_EX(DBG_SS, DecodeError);
    SET_ERROR_VAR_EX(DBG_SS, MemoryError, ERROR_NOT_ENOUGH_MEMORY);
}

BOOL WINAPI TrustFreeDecode(DWORD dwModuleId, BYTE **pbAllocated)
{
    DELETE_OBJECT(*pbAllocated);

    return(TRUE);
}

void _SetConfidenceOnIssuer(DWORD dwEncoding, PCCERT_CONTEXT pChildCert, PCCERT_CONTEXT pTestIssuerCert, 
                            DWORD dwVerificationFlag, FILETIME *psftVerifyAsOf, DWORD *pdwConfidence, 
                            DWORD *pdwError)
{
    *pdwConfidence = 0;

    if (!(dwVerificationFlag & CERT_STORE_SIGNATURE_FLAG))
    {
        *pdwConfidence  |= CERT_CONFIDENCE_SIG;
    }

    if (CertVerifyTimeValidity(psftVerifyAsOf, pTestIssuerCert->pCertInfo) == 0)
    {
        *pdwConfidence  |= CERT_CONFIDENCE_TIME;
    }

    if (CertVerifyValidityNesting(pChildCert->pCertInfo, pTestIssuerCert->pCertInfo))
    {
        *pdwConfidence  |= CERT_CONFIDENCE_TIMENEST;
    }

    if (_CompareAuthKeyId(dwEncoding, pChildCert, pTestIssuerCert))
    {
        *pdwConfidence  |= CERT_CONFIDENCE_AUTHIDEXT;
    }
    else if (_CompareAuthKeyId2(dwEncoding, pChildCert, pTestIssuerCert))
    {
        *pdwConfidence  |= CERT_CONFIDENCE_AUTHIDEXT;
    }

    if (_SetCertErrorAndHygiene(pChildCert, pTestIssuerCert, *pdwConfidence, pdwError))
    {
        *pdwConfidence  |= CERT_CONFIDENCE_HYGIENE;
    }
}

BOOL _SetCertErrorAndHygiene(PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pIssuerContext,
                             DWORD dwCurrentConfidence, DWORD *pdwError)
{
    *pdwError = ERROR_SUCCESS;

    if (!(dwCurrentConfidence & CERT_CONFIDENCE_SIG))
    {
        *pdwError = TRUST_E_CERT_SIGNATURE;
        return(FALSE);
    }

    if ((dwCurrentConfidence & CERT_CONFIDENCE_SIG)        &&
        (dwCurrentConfidence & CERT_CONFIDENCE_TIME)       &&
        (dwCurrentConfidence & CERT_CONFIDENCE_TIMENEST)   &&
        (dwCurrentConfidence & CERT_CONFIDENCE_AUTHIDEXT))
    {
        return(TRUE);
    }

    if (dwCurrentConfidence & CERT_CONFIDENCE_AUTHIDEXT)
    {
        return(TRUE);
    }

    return(FALSE);
}


BOOL _CompareAuthKeyId2(DWORD dwEncoding, PCCERT_CONTEXT pChildContext, PCCERT_CONTEXT pParentContext)
{
    DWORD                           i;
    PCERT_EXTENSION                 pExt;
    DWORD                           cbIdInfo;
    PCERT_AUTHORITY_KEY_ID2_INFO    pIdInfo;
    BOOL                            fRet;


    pIdInfo = NULL;

    if (pChildContext->pCertInfo->cExtension < 1)
    {
        goto NoExtensions;
    }

    if (!(pExt = CertFindExtension(szOID_AUTHORITY_KEY_IDENTIFIER2, pChildContext->pCertInfo->cExtension,
                                   pChildContext->pCertInfo->rgExtension)))
    {
        goto NoExtensions;
    }

    if (!(TrustDecode(WVT_MODID_WINTRUST, (BYTE **)&pIdInfo, &cbIdInfo, 103, 
                      dwEncoding, X509_AUTHORITY_KEY_ID2, pExt->Value.pbData, pExt->Value.cbData,
                      CRYPT_DECODE_NOCOPY_FLAG)))
    {
        goto DecodeFailed;
    }
    
    for (i = 0; i < pIdInfo->AuthorityCertIssuer.cAltEntry; i++)
    {
        if (pIdInfo->AuthorityCertIssuer.rgAltEntry[i].dwAltNameChoice == 
                        CERT_ALT_NAME_DIRECTORY_NAME)
        {
            break;
        }
    }

    if (i == pIdInfo->AuthorityCertIssuer.cAltEntry)
    {
        goto NoAltDirectoryName;
    }

    if (!(CertCompareCertificateName(dwEncoding, 
                                     &pIdInfo->AuthorityCertIssuer.rgAltEntry[i].DirectoryName,
                                     &pParentContext->pCertInfo->Issuer)))
    {
        goto IncorrectIssuer;
    }

    //
    //  issuer certificate's serial number must match
    //
    if (!(CertCompareIntegerBlob(&pIdInfo->AuthorityCertSerialNumber,
                                 &pParentContext->pCertInfo->SerialNumber)))
    {
        goto IncorrectIssuer;
    }

    fRet = TRUE;

CommonReturn:
    if (pIdInfo)
    {
        TrustFreeDecode(WVT_MODID_WINTRUST, (BYTE **)&pIdInfo);
    }
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, NoExtensions);
    TRACE_ERROR_EX(DBG_SS, DecodeFailed);
    TRACE_ERROR_EX(DBG_SS, IncorrectIssuer);
    TRACE_ERROR_EX(DBG_SS, NoAltDirectoryName);
}

BOOL _CompareAuthKeyId(DWORD dwEncoding, PCCERT_CONTEXT pChildContext, PCCERT_CONTEXT pParentContext)
{
    PCERT_EXTENSION             pExt;
    PCERT_AUTHORITY_KEY_ID_INFO pChildKeyIdInfo;
    DWORD                       cbKeyIdInfo;
    BOOL                        fRet;

    pChildKeyIdInfo = NULL;
    pExt            = NULL;

    if (pChildContext->pCertInfo->cExtension < 1)
    {
        goto NoExtensions;
    }

    pChildKeyIdInfo     = NULL;

    if (!(pExt = CertFindExtension(szOID_AUTHORITY_KEY_IDENTIFIER,
                                   pChildContext->pCertInfo->cExtension,
                                   pChildContext->pCertInfo->rgExtension)))
    {
        goto NoExtensions;
    }

    if (!(TrustDecode(WVT_MODID_WINTRUST, (BYTE **)&pChildKeyIdInfo, &cbKeyIdInfo, 104, 
                      dwEncoding, X509_AUTHORITY_KEY_ID, pExt->Value.pbData, pExt->Value.cbData,
                      CRYPT_DECODE_NOCOPY_FLAG)))
    {
        goto DecodeFailed;
    }
    
    if ((pChildKeyIdInfo->CertIssuer.cbData < 1) ||
        (pChildKeyIdInfo->CertSerialNumber.cbData < 1))
    {
        goto NoKeyId;
    }

    //
    //  issuer certificate's issuer name must match
    //
    if (!(CertCompareCertificateName(dwEncoding, &pChildKeyIdInfo->CertIssuer, 
                                     &pParentContext->pCertInfo->Issuer)))
    {
        goto IncorrectIssuer;
    }

    //
    //  issuer certificate's serial number must match
    //
    if (!(CertCompareIntegerBlob(&pChildKeyIdInfo->CertSerialNumber,
                                 &pParentContext->pCertInfo->SerialNumber)))
    {
        goto IncorrectIssuer;
    }

    fRet = TRUE;

CommonReturn:
    if (pChildKeyIdInfo)
    {
        TrustFreeDecode(WVT_MODID_WINTRUST, (BYTE **)&pChildKeyIdInfo);
    }
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, NoExtensions);
    TRACE_ERROR_EX(DBG_SS, DecodeFailed);
    TRACE_ERROR_EX(DBG_SS, NoKeyId);
    TRACE_ERROR_EX(DBG_SS, IncorrectIssuer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\wtasn.h ===
/* Copyright (C) Microsoft Corporation, 1996 - 1999 All rights reserved. */
/* ASN.1 definitions for Indirect data contents */

#ifndef _WTASN_Module_H_
#define _WTASN_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1intx_t HUGEINTEGER;

typedef ASN1bitstring_t BITSTRING;

typedef ASN1octetstring_t OCTETSTRING;

typedef ASN1open_t NOCOPYANY;

typedef ASN1charstring_t NUMERICSTRING;

typedef ASN1charstring_t PRINTABLESTRING;

typedef ASN1charstring_t TELETEXSTRING;

typedef ASN1charstring_t T61STRING;

typedef ASN1charstring_t VIDEOTEXSTRING;

typedef ASN1charstring_t IA5STRING;

typedef ASN1charstring_t GRAPHICSTRING;

typedef ASN1charstring_t VISIBLESTRING;

typedef ASN1charstring_t ISO646STRING;

typedef ASN1charstring_t GENERALSTRING;

typedef ASN1char32string_t UNIVERSALSTRING;

typedef ASN1char16string_t BMPSTRING;

typedef ASN1objectidentifier2_t ObjectID;
#define ObjectID_PDU 0
#define SIZE_WTASN_Module_PDU_0 sizeof(ObjectID)

typedef OCTETSTRING SpcUuid;

typedef ASN1bitstring_t SpcPeImageFlags;
#define includeResources 0x80
#define includeDebugInfo 0x40
#define includeImportAddressTable 0x20

typedef ASN1bool_t SpcMinimalCriteria;
#define SpcMinimalCriteria_PDU 1
#define SIZE_WTASN_Module_PDU_1 sizeof(SpcMinimalCriteria)

typedef ASN1utctime_t UtcTime;
#define UtcTime_PDU 2
#define SIZE_WTASN_Module_PDU_2 sizeof(UtcTime)

typedef struct AlgorithmIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID algorithm;
#   define parameters_present 0x80
    NOCOPYANY parameters;
} AlgorithmIdentifier;

typedef struct DigestInfo {
    AlgorithmIdentifier digestAlgorithm;
    OCTETSTRING digest;
} DigestInfo;

typedef struct SpcAttributeTypeAndOptionalValue {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID type;
#   define value_present 0x80
    NOCOPYANY value;
} SpcAttributeTypeAndOptionalValue;

typedef struct SpcString {
    ASN1choice_t choice;
    union {
#	define unicode_chosen 1
	BMPSTRING unicode;
#	define ascii_chosen 2
	IA5STRING ascii;
    } u;
} SpcString;

typedef struct SpcSerializedObject {
    SpcUuid classId;
    OCTETSTRING serializedData;
} SpcSerializedObject;

typedef struct SpcLink {
    ASN1choice_t choice;
    union {
#	define url_chosen 1
	IA5STRING url;
#	define moniker_chosen 2
	SpcSerializedObject moniker;
#	define file_chosen 3
	SpcString file;
    } u;
} SpcLink;
#define SpcLink_PDU 3
#define SIZE_WTASN_Module_PDU_3 sizeof(SpcLink)

typedef struct SpcPeImageData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define flags_present 0x80
    SpcPeImageFlags flags;
#   define file_present 0x40
    SpcLink file;
} SpcPeImageData;
#define SpcPeImageData_PDU 4
#define SIZE_WTASN_Module_PDU_4 sizeof(SpcPeImageData)

typedef struct SpcSigInfo {
    ASN1int32_t dwSIPversion;
    SpcUuid gSIPguid;
    ASN1int32_t dwReserved1;
    ASN1int32_t dwReserved2;
    ASN1int32_t dwReserved3;
    ASN1int32_t dwReserved4;
    ASN1int32_t dwReserved5;
} SpcSigInfo;
#define SpcSigInfo_PDU 5
#define SIZE_WTASN_Module_PDU_5 sizeof(SpcSigInfo)

typedef struct SpcImage {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define imageLink_present 0x80
    SpcLink imageLink;
#   define bitmap_present 0x40
    OCTETSTRING bitmap;
#   define metafile_present 0x20
    OCTETSTRING metafile;
#   define enhancedMetafile_present 0x10
    OCTETSTRING enhancedMetafile;
#   define gifFile_present 0x8
    OCTETSTRING gifFile;
} SpcImage;

typedef struct SpcFinancialCriteria {
    ASN1bool_t financialInfoAvailable;
    ASN1bool_t meetsCriteria;
} SpcFinancialCriteria;
#define SpcFinancialCriteria_PDU 6
#define SIZE_WTASN_Module_PDU_6 sizeof(SpcFinancialCriteria)

typedef struct SpcStatementType {
    ASN1uint32_t count;
    ObjectID *value;
} SpcStatementType;
#define SpcStatementType_PDU 7
#define SIZE_WTASN_Module_PDU_7 sizeof(SpcStatementType)

typedef struct SpcSpOpusInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define programName_present 0x80
    SpcString programName;
#   define moreInfo_present 0x40
    SpcLink moreInfo;
#   define publisherInfo_present 0x20
    SpcLink publisherInfo;
} SpcSpOpusInfo;
#define SpcSpOpusInfo_PDU 8
#define SIZE_WTASN_Module_PDU_8 sizeof(SpcSpOpusInfo)

typedef struct NameValue {
    BMPSTRING refname;
    ASN1int32_t typeaction;
    OCTETSTRING value;
} NameValue;
#define NameValue_PDU 9
#define SIZE_WTASN_Module_PDU_9 sizeof(NameValue)

typedef struct NameValues {
    ASN1uint32_t count;
    struct NameValue *value;
} NameValues;
#define NameValues_PDU 10
#define SIZE_WTASN_Module_PDU_10 sizeof(NameValues)

typedef struct MemberInfo {
    BMPSTRING subguid;
    ASN1int32_t certversion;
} MemberInfo;
#define MemberInfo_PDU 11
#define SIZE_WTASN_Module_PDU_11 sizeof(MemberInfo)

typedef struct SpcIndirectDataContent {
    SpcAttributeTypeAndOptionalValue data;
    DigestInfo messageDigest;
} SpcIndirectDataContent;
#define SpcIndirectDataContent_PDU 12
#define SIZE_WTASN_Module_PDU_12 sizeof(SpcIndirectDataContent)

typedef struct SpcSpAgencyInformation {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define policyInformation_present 0x80
    SpcLink policyInformation;
#   define policyDisplayText_present 0x40
    SpcString policyDisplayText;
#   define logoImage_present 0x20
    SpcImage logoImage;
#   define logoLink_present 0x10
    SpcLink logoLink;
} SpcSpAgencyInformation;
#define SpcSpAgencyInformation_PDU 13
#define SIZE_WTASN_Module_PDU_13 sizeof(SpcSpAgencyInformation)

extern SpcPeImageFlags SpcPeImageData_flags_default;

extern ASN1module_t WTASN_Module;
extern void ASN1CALL WTASN_Module_Startup(void);
extern void ASN1CALL WTASN_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _WTASN_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\winvtrst.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       winvtrst.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  WinVerifyTrustEx
//              WinVerifyTrust
//              WTHelperGetFileHash
//
//              *** local functions ***
//              _VerifyTrust
//              _FillProviderData
//              _CleanupProviderData
//              _CleanupProviderNonStateData
//              _WVTSipFreeSubjectInfo
//              _WVTSipFreeSubjectInfoKeepState
//              _WVTSetupProviderData
//
//  History:    31-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "wvtver1.h"
#include    "softpub.h"
#include    "imagehlp.h"

LONG _VerifyTrust(
    IN HWND hWnd,
    IN GUID *pgActionID,
    IN OUT PWINTRUST_DATA pWinTrustData,
    OUT OPTIONAL BYTE *pbSubjectHash,
    IN OPTIONAL OUT DWORD *pcbSubjectHash,
    OUT OPTIONAL ALG_ID *pHashAlgid
    );

BOOL    _FillProviderData(CRYPT_PROVIDER_DATA *pProvData, HWND hWnd, WINTRUST_DATA *pWinTrustData);
void    _CleanupProviderData(CRYPT_PROVIDER_DATA *pProvData);
void    _CleanupProviderNonStateData(CRYPT_PROVIDER_DATA *ProvData);

BOOL    _WVTSipFreeSubjectInfo(SIP_SUBJECTINFO *pSubj);
BOOL    _WVTSetupProviderData(CRYPT_PROVIDER_DATA *psProvData,
                             CRYPT_PROVIDER_DATA *psStateProvData);
BOOL    _WVTSipFreeSubjectInfoKeepState(SIP_SUBJECTINFO *pSubj);


VOID FreeWintrustStateData (WINTRUST_DATA* pWintrustData);

extern CCatalogCache g_CatalogCache;

//////////////////////////////////////////////////////////////////////////////////////
//
// WinVerifyTrustEx
//
//
extern "C" HRESULT WINAPI WinVerifyTrustEx(HWND hWnd, GUID *pgActionID, WINTRUST_DATA *pWinTrustData)
{
    return((HRESULT)WinVerifyTrust(hWnd, pgActionID, pWinTrustData));
}

#define PE_EXE_HEADER_TAG       "MZ"
#define PE_EXE_HEADER_TAG_LEN   2

BOOL _IsUnsignedPEFile(
    PWINTRUST_FILE_INFO pFileInfo
    )
{
    BOOL fIsUnsignedPEFile = FALSE;
    HANDLE hFile = NULL;
    BOOL fCloseFile = FALSE;
    BYTE rgbHeader[PE_EXE_HEADER_TAG_LEN];
    DWORD dwBytesRead;
    DWORD dwCertCnt;
    

    hFile = pFileInfo->hFile;
    if (NULL == hFile || INVALID_HANDLE_VALUE == hFile) {
        hFile = CreateFileU(
            pFileInfo->pcwszFilePath,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,                   // lpsa
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL                    // hTemplateFile
            );
        if (INVALID_HANDLE_VALUE == hFile)
            goto CreateFileError;
        fCloseFile = TRUE;
    }

    if (0 != SetFilePointer(
            hFile,
            0,              // lDistanceToMove
            NULL,           // lpDistanceToMoveHigh
            FILE_BEGIN
            ))
        goto SetFilePointerError;

    dwBytesRead = 0;
    if (!ReadFile(
            hFile,
            rgbHeader,
            PE_EXE_HEADER_TAG_LEN,
            &dwBytesRead,
            NULL                //  lpOverlapped
            ) || PE_EXE_HEADER_TAG_LEN != dwBytesRead)
        goto ReadFileError;

    if (0 != memcmp(rgbHeader, PE_EXE_HEADER_TAG, PE_EXE_HEADER_TAG_LEN))
        goto NotPEFile;


    // Now see if the PE file is signed
    dwCertCnt = 0;
    if (!ImageEnumerateCertificates(
            hFile,
            CERT_SECTION_TYPE_ANY,
            &dwCertCnt,
            NULL,                   // Indices
            0                       // IndexCount
            ) || 0 == dwCertCnt)
        fIsUnsignedPEFile = TRUE;

CommonReturn:
    if (fCloseFile)
        CloseHandle(hFile);
    return fIsUnsignedPEFile;

ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(CreateFileError)
TRACE_ERROR(SetFilePointerError)
TRACE_ERROR(ReadFileError)
TRACE_ERROR(NotPEFile)
}

extern "C" LONG WINAPI WinVerifyTrust(HWND hWnd, GUID *pgActionID, LPVOID pOld)
{
    PWINTRUST_DATA pWinTrustData = (PWINTRUST_DATA) pOld;

    // For SAFER, see if this is a unsigned PE file 
    if (_ISINSTRUCT(WINTRUST_DATA, pWinTrustData->cbStruct, dwProvFlags) &&
            (pWinTrustData->dwProvFlags & WTD_SAFER_FLAG) &&
            (WTD_STATEACTION_IGNORE == pWinTrustData->dwStateAction) &&
            (WTD_CHOICE_FILE == pWinTrustData->dwUnionChoice)) {
        if (_IsUnsignedPEFile(pWinTrustData->pFile)) {
            SetLastError((DWORD) TRUST_E_NOSIGNATURE);
            return (LONG) TRUST_E_NOSIGNATURE;
        }
    }

    return _VerifyTrust(
        hWnd,
        pgActionID,
        pWinTrustData,
        NULL,               // pbSubjectHash
        NULL,               // pcbSubjectHash
        NULL                // pHashAlgid
        );
}

// Returns S_OK and the hash if the file was signed and contains a valid
// hash
extern "C" LONG WINAPI WTHelperGetFileHash(
    IN LPCWSTR pwszFilename,
    IN DWORD dwFlags,
    IN OUT OPTIONAL PVOID *pvReserved,
    OUT OPTIONAL BYTE *pbFileHash,
    IN OUT OPTIONAL DWORD *pcbFileHash,
    OUT OPTIONAL ALG_ID *pHashAlgid
    )
{
    GUID wvtFileActionID = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_FILE_INFO wvtFileInfo;
    WINTRUST_DATA wvtData;

    //
    // Initialize the _VerifyTrust input data structure
    //
    memset(&wvtData, 0, sizeof(wvtData));   // default all fields to 0
    wvtData.cbStruct = sizeof(wvtData);
    // wvtData.pPolicyCallbackData =        // use default code signing EKU
    // wvtData.pSIPClientData =             // no data to pass to SIP

    wvtData.dwUIChoice = WTD_UI_NONE;

    // wvtData.fdwRevocationChecks =        // do revocation checking if
                                            // enabled by admin policy or
                                            // IE advanced user options
    wvtData.dwUnionChoice = WTD_CHOICE_FILE;
    wvtData.pFile = &wvtFileInfo;

    // wvtData.dwStateAction =              // default verification
    // wvtData.hWVTStateData =              // not applicable for default
    // wvtData.pwszURLReference =           // not used

    // Only want to get the hash
    wvtData.dwProvFlags = WTD_HASH_ONLY_FLAG;

    //
    // Initialize the WinVerifyTrust file info data structure
    //
    memset(&wvtFileInfo, 0, sizeof(wvtFileInfo));   // default all fields to 0
    wvtFileInfo.cbStruct = sizeof(wvtFileInfo);
    wvtFileInfo.pcwszFilePath = pwszFilename;
    // wvtFileInfo.hFile =              // allow WVT to open
    // wvtFileInfo.pgKnownSubject       // allow WVT to determine

    //
    // Call _VerifyTrust
    //
    return _VerifyTrust(
            NULL,               // hWnd
            &wvtFileActionID,
            &wvtData,
            pbFileHash,
            pcbFileHash,
            pHashAlgid
            );
}

LONG _VerifyTrust(
    IN HWND hWnd,
    IN GUID *pgActionID,
    IN OUT PWINTRUST_DATA pWinTrustData,
    OUT OPTIONAL BYTE *pbSubjectHash,
    IN OPTIONAL OUT DWORD *pcbSubjectHash,
    OUT OPTIONAL ALG_ID *pHashAlgid
    )
{
    CRYPT_PROVIDER_DATA     sProvData;
    CRYPT_PROVIDER_DATA     *pStateProvData;
    HRESULT                 hr;
    BOOL                    fVersion1;
    BOOL                    fCacheableCall;
    PCATALOG_CACHED_STATE   pCachedState = NULL;
    BOOL                    fVersion1WVTCalled = FALSE;
    DWORD                   cbInSubjectHash;
    DWORD                   dwLastError = 0;

    hr                      = TRUST_E_PROVIDER_UNKNOWN;
    pStateProvData          = NULL;

    if (pcbSubjectHash)
    {
        cbInSubjectHash = *pcbSubjectHash;
        *pcbSubjectHash = 0;
    }
    else
    {
        cbInSubjectHash = 0;
    }

    if (pHashAlgid)
        *pHashAlgid = 0;

    fCacheableCall = g_CatalogCache.IsCacheableWintrustCall( pWinTrustData );

    if ( fCacheableCall == TRUE )
    {
        g_CatalogCache.LockCache();

        if ( pWinTrustData->dwStateAction == WTD_STATEACTION_AUTO_CACHE_FLUSH )
        {
            g_CatalogCache.FlushCache();
            g_CatalogCache.UnlockCache();

            return( ERROR_SUCCESS );
        }

        pCachedState = g_CatalogCache.FindCachedState( pWinTrustData );

        g_CatalogCache.AdjustWintrustDataToCachedState(
                             pWinTrustData,
                             pCachedState,
                             FALSE
                             );
    }

    if (WintrustIsVersion1ActionID(pgActionID))
    {
        fVersion1 = TRUE;
    }
    else
    {
        fVersion1 = FALSE;

        if (_ISINSTRUCT(WINTRUST_DATA, pWinTrustData->cbStruct, hWVTStateData))
        {
            if ((pWinTrustData->dwStateAction == WTD_STATEACTION_VERIFY) ||
                (pWinTrustData->dwStateAction == WTD_STATEACTION_CLOSE))
            {
                pStateProvData = WTHelperProvDataFromStateData(pWinTrustData->hWVTStateData);

                if (pWinTrustData->dwStateAction == WTD_STATEACTION_CLOSE)
                {
                    if (pWinTrustData->hWVTStateData)
                    {
                        _CleanupProviderData(pStateProvData);
                        DELETE_OBJECT(pWinTrustData->hWVTStateData);
                    }

                    assert( fCacheableCall == FALSE );

                    return(ERROR_SUCCESS);
                }
            }
        }
    }

    if (_WVTSetupProviderData(&sProvData, pStateProvData))
    {
        sProvData.pgActionID  = pgActionID;


        if (!(pStateProvData))
        {
            if (!(WintrustLoadFunctionPointers(pgActionID, sProvData.psPfns)))
            {
                //
                //  it may be that we are looking for a version 1 trust provider.
                //
                hr = Version1_WinVerifyTrust(hWnd, pgActionID, pWinTrustData);
                fVersion1WVTCalled = TRUE;
            }

            if ( fVersion1WVTCalled == FALSE )
            {
                if (fVersion1)
                {
                    //
                    //  backwards compatibility with IE3.x and previous
                    //
                    WINTRUST_DATA       sWinTrustData;
                    WINTRUST_FILE_INFO  sWinTrustFileInfo;

                    pWinTrustData   = ConvertDataFromVersion1(hWnd, pgActionID, &sWinTrustData, &sWinTrustFileInfo,
                                                              pWinTrustData);
                }

                if (!_FillProviderData(&sProvData, hWnd, pWinTrustData))
                {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorCase;
                }
            }
        }

        // On July 27, 2000 removed support for the IE4 way of chain building.
        sProvData.dwProvFlags |= CPD_USE_NT5_CHAIN_FLAG;

        if ( fVersion1WVTCalled == FALSE )
        {
            if (sProvData.psPfns->pfnInitialize)
            {
                (*sProvData.psPfns->pfnInitialize)(&sProvData);
            }

            if (sProvData.psPfns->pfnObjectTrust)
            {
                (*sProvData.psPfns->pfnObjectTrust)(&sProvData);
            }

            if (sProvData.psPfns->pfnSignatureTrust)
            {
                (*sProvData.psPfns->pfnSignatureTrust)(&sProvData);
            }

            if (sProvData.psPfns->pfnCertificateTrust)
            {
                (*sProvData.psPfns->pfnCertificateTrust)(&sProvData);
            }

            if (sProvData.psPfns->pfnFinalPolicy)
            {
                hr = (*sProvData.psPfns->pfnFinalPolicy)(&sProvData);
            }

            if (sProvData.psPfns->pfnTestFinalPolicy)
            {
                (*sProvData.psPfns->pfnTestFinalPolicy)(&sProvData);
            }

            if (sProvData.psPfns->pfnCleanupPolicy)
            {
                (*sProvData.psPfns->pfnCleanupPolicy)(&sProvData);
            }

            dwLastError = sProvData.dwFinalError;
            if (0 == dwLastError)
            {
                dwLastError = (DWORD) hr;
            }

            if (pcbSubjectHash && hr != TRUST_E_NOSIGNATURE)
            {
                // Return the subject's hash

                DWORD cbHash;
                if (sProvData.pPDSip && sProvData.pPDSip->psIndirectData)
                {
                    cbHash = sProvData.pPDSip->psIndirectData->Digest.cbData;
                }
                else
                {
                    cbHash = 0;
                }

                if (cbHash > 0)
                {
                    *pcbSubjectHash = cbHash;
                    if (pbSubjectHash)
                    {
                        if (cbInSubjectHash >= cbHash)
                        {
                            memcpy(pbSubjectHash,
                                sProvData.pPDSip->psIndirectData->Digest.pbData,
                                cbHash);
                        }
                        else if (S_OK == hr)
                        {
                            hr = ERROR_MORE_DATA;
                        }
                    }

                    if (pHashAlgid)
                    {
                        *pHashAlgid = CertOIDToAlgId(
                            sProvData.pPDSip->psIndirectData->DigestAlgorithm.pszObjId);
                    }
                }
            }

            if (!(pStateProvData))
            {
                //
                //  no previous state saved
                //
                if ((_ISINSTRUCT(WINTRUST_DATA, pWinTrustData->cbStruct, hWVTStateData)) &&
                    (pWinTrustData->dwStateAction == WTD_STATEACTION_VERIFY))
                {
                    //
                    //  first time call and asking to maintain state...
                    //
                    if (!(pWinTrustData->hWVTStateData = (HANDLE)WVTNew(sizeof(CRYPT_PROVIDER_DATA))))
                    {
                        _CleanupProviderData(&sProvData);
                        hr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        _CleanupProviderNonStateData(&sProvData);

                        memcpy(pWinTrustData->hWVTStateData, &sProvData, sizeof(CRYPT_PROVIDER_DATA));
                    }
                }
                else
                {
                    _CleanupProviderData(&sProvData);
                }
            }
            else
            {
                //
                //  only free up memory specific to this object/member
                //
                _CleanupProviderNonStateData(&sProvData);
                memcpy(pWinTrustData->hWVTStateData, &sProvData, sizeof(CRYPT_PROVIDER_DATA));
            }

            //
            //  in version 1, when called by IE3.x and earlier, if security level is HIGH,
            //  then the no bad UI is set.  If we had an error, we want to
            //  set the error to TRUST_E_FAIL.  If we do not trust the object, every other
            //  case sets it to TRUST_E_SUBJECT_NOT_TRUSTED and IE throws NO UI....
            //
            if (fVersion1)
            {
                if (hr != ERROR_SUCCESS)
                {
                    if ((pWinTrustData) &&
                        (_ISINSTRUCT(WINTRUST_DATA, pWinTrustData->cbStruct, dwUIChoice)))
                    {
                        if (pWinTrustData->dwUIChoice == WTD_UI_NOBAD)
                        {
                            hr = TRUST_E_FAIL;  // ie throws UI.
                        }
                        else
                        {
                            hr = TRUST_E_SUBJECT_NOT_TRUSTED; // ie throws no UI.
                        }
                    }
                    else
                    {
                        hr = TRUST_E_SUBJECT_NOT_TRUSTED; // ie throws no UI.
                    }
                }
            }
        }
    }
    else
    {
        hr = TRUST_E_SYSTEM_ERROR;
    }

ErrorCase:

    if ( fCacheableCall == TRUE )
    {
        if ( pCachedState == NULL )
        {
            if ( g_CatalogCache.CreateCachedStateFromWintrustData(
                                       pWinTrustData,
                                       &pCachedState
                                       ) == TRUE )
            {
                g_CatalogCache.AddCachedState( pCachedState );
            }
        }

        if ( pCachedState == NULL )
        {
            FreeWintrustStateData( pWinTrustData );
        }

        g_CatalogCache.AdjustWintrustDataToCachedState(
                             pWinTrustData,
                             pCachedState,
                             TRUE
                             );

        g_CatalogCache.ReleaseCachedState( pCachedState );

        g_CatalogCache.UnlockCache();
    }

    SetLastError(dwLastError);

    return (LONG) hr;
}

//////////////////////////////////////////////////////////////////////////////////////
//
//  local utility functions
//
//
BOOL _FillProviderData(CRYPT_PROVIDER_DATA *pProvData, HWND hWnd, WINTRUST_DATA *pWinTrustData)
{
    BOOL fHasTrustPubFlags;

    //
    //  remember:  we do NOT want to return FALSE unless it is an absolutely
    //              catastrophic error!  Let the Trust provider handle (eg: none!)
    //

    if (pWinTrustData && _ISINSTRUCT(WINTRUST_DATA,
            pWinTrustData->cbStruct, dwProvFlags))
        pProvData->dwProvFlags = pWinTrustData->dwProvFlags &
            WTD_PROV_FLAGS_MASK;

    if ((hWnd == INVALID_HANDLE_VALUE) || !(hWnd))
    {
        if (pWinTrustData->dwUIChoice != WTD_UI_NONE)
        {
            hWnd = GetDesktopWindow();
        }
    }
    pProvData->hWndParent       = hWnd;
    pProvData->hProv            = I_CryptGetDefaultCryptProv(0);  // get the default and DONT RELEASE IT!!!!
    pProvData->dwEncoding       = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
    pProvData->pWintrustData    = pWinTrustData;
    pProvData->dwError          = ERROR_SUCCESS;

    // allocate errors
    if (!(pProvData->padwTrustStepErrors))
    {
        if (!(pProvData->padwTrustStepErrors = (DWORD *)WVTNew(TRUSTERROR_MAX_STEPS * sizeof(DWORD))))
        {
            pProvData->dwError = GetLastError();
            // 
            // NOTE!! this is currently the only FALSE return, so the caller will
            // assume ERROR_NOT_ENOUGH_MEMORY if FALSE is returned from this function
            //
            return(FALSE);  
        }

        pProvData->cdwTrustStepErrors = TRUSTERROR_MAX_STEPS;
    }

    memset(pProvData->padwTrustStepErrors, 0x00, sizeof(DWORD) * TRUSTERROR_MAX_STEPS);

    WintrustGetRegPolicyFlags(&pProvData->dwRegPolicySettings);
    GetRegSecuritySettings(&pProvData->dwRegSecuritySettings);

    fHasTrustPubFlags = I_CryptReadTrustedPublisherDWORDValueFromRegistry(
        CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME,
        &pProvData->dwTrustPubSettings
        );

    if (fHasTrustPubFlags)
    {
        if (pProvData->dwTrustPubSettings &
                (CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST |
                    CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST))
        {
            // End User trust not allowed
            pProvData->dwRegPolicySettings =
                WTPF_IGNOREREVOKATION           |
                    WTPF_IGNOREREVOCATIONONTS   |
                    WTPF_OFFLINEOK_IND          |
                    WTPF_OFFLINEOK_COM          |
                    WTPF_OFFLINEOKNBU_IND       |
                    WTPF_OFFLINEOKNBU_COM       |
                    WTPF_ALLOWONLYPERTRUST;
        }

        // Allow the safer UI to enable revocation checking

        if (pProvData->dwTrustPubSettings &
                CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG)
        {
            pProvData->dwRegPolicySettings &= ~WTPF_IGNOREREVOKATION;
            pProvData->dwRegPolicySettings      |=
                    WTPF_OFFLINEOK_IND          |
                    WTPF_OFFLINEOK_COM          |
                    WTPF_OFFLINEOKNBU_IND       |
                    WTPF_OFFLINEOKNBU_COM;
        }

        if (pProvData->dwTrustPubSettings &
                CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG)
        {
            pProvData->dwRegPolicySettings &= ~WTPF_IGNOREREVOCATIONONTS;
            pProvData->dwRegPolicySettings      |=
                    WTPF_OFFLINEOK_IND          |
                    WTPF_OFFLINEOK_COM          |
                    WTPF_OFFLINEOKNBU_IND       |
                    WTPF_OFFLINEOKNBU_COM;
        }
    }


    if (!(pWinTrustData) ||
        !(_ISINSTRUCT(WINTRUST_DATA, pWinTrustData->cbStruct, dwUIChoice)))

    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] = (DWORD)ERROR_INVALID_PARAMETER;
    }

    return(TRUE);
}

void _CleanupProviderData(CRYPT_PROVIDER_DATA *pProvData)
{
    // pProvData->hProv: we're using crypt32's default

    // pProvData->pWintrustData->xxx->hFile
    if ((pProvData->fOpenedFile) && (pProvData->pWintrustData != NULL))
    {
        HANDLE  *phFile;

        phFile  = NULL;

        switch (pProvData->pWintrustData->dwUnionChoice)
        {
            case WTD_CHOICE_FILE:
                phFile = &pProvData->pWintrustData->pFile->hFile;
                break;

            case WTD_CHOICE_CATALOG:
                phFile = &pProvData->pWintrustData->pCatalog->hMemberFile;
                break;
        }

        if ((phFile) && (*phFile) && (*phFile != INVALID_HANDLE_VALUE))
        {
            CloseHandle(*phFile);
            *phFile = INVALID_HANDLE_VALUE;
            pProvData->fOpenedFile = FALSE;
        }
    }

    if (pProvData->dwSubjectChoice == CPD_CHOICE_SIP)
    {
        DELETE_OBJECT(pProvData->pPDSip->pSip);
        DELETE_OBJECT(pProvData->pPDSip->pCATSip);

        _WVTSipFreeSubjectInfo(pProvData->pPDSip->psSipSubjectInfo);
        DELETE_OBJECT(pProvData->pPDSip->psSipSubjectInfo);

        _WVTSipFreeSubjectInfo(pProvData->pPDSip->psSipCATSubjectInfo);
        DELETE_OBJECT(pProvData->pPDSip->psSipCATSubjectInfo);

        TrustFreeDecode(WVT_MODID_WINTRUST, (BYTE **)&pProvData->pPDSip->psIndirectData);

        DELETE_OBJECT(pProvData->pPDSip);
    }


    if (pProvData->hMsg)
    {
        CryptMsgClose(pProvData->hMsg);
        pProvData->hMsg = NULL;
    }

    // signer structure
    for (int i = 0; i < (int)pProvData->csSigners; i++)
    {
        TrustFreeDecode(WVT_MODID_WINTRUST, (BYTE **)&pProvData->pasSigners[i].psSigner);

        DeallocateCertChain(pProvData->pasSigners[i].csCertChain,
                            &pProvData->pasSigners[i].pasCertChain);

        DELETE_OBJECT(pProvData->pasSigners[i].pasCertChain);

        if (_ISINSTRUCT(CRYPT_PROVIDER_SGNR,
                    pProvData->pasSigners[i].cbStruct, pChainContext) &&
                pProvData->pasSigners[i].pChainContext)
            CertFreeCertificateChain(pProvData->pasSigners[i].pChainContext);

        // counter signers
        for (int i2 = 0; i2 < (int)pProvData->pasSigners[i].csCounterSigners; i2++)
        {
            TrustFreeDecode(WVT_MODID_WINTRUST, (BYTE **)&pProvData->pasSigners[i].pasCounterSigners[i2].psSigner);

            DeallocateCertChain(pProvData->pasSigners[i].pasCounterSigners[i2].csCertChain,
                                &pProvData->pasSigners[i].pasCounterSigners[i2].pasCertChain);

            DELETE_OBJECT(pProvData->pasSigners[i].pasCounterSigners[i2].pasCertChain);
            if (_ISINSTRUCT(CRYPT_PROVIDER_SGNR,
                    pProvData->pasSigners[i].pasCounterSigners[i2].cbStruct,
                        pChainContext) &&
                    pProvData->pasSigners[i].pasCounterSigners[i2].pChainContext)
                CertFreeCertificateChain(
                    pProvData->pasSigners[i].pasCounterSigners[i2].pChainContext);
        }

        DELETE_OBJECT(pProvData->pasSigners[i].pasCounterSigners);
    }

    DELETE_OBJECT(pProvData->pasSigners);

    // MUST BE DONE LAST!!!  Using the force flag!!!
    if (pProvData->pahStores)
    {
        DeallocateStoreChain(pProvData->chStores, pProvData->pahStores);

        DELETE_OBJECT(pProvData->pahStores);
    }

    pProvData->chStores = 0;

    // pProvData->padwTrustStepErrors
    DELETE_OBJECT(pProvData->padwTrustStepErrors);

    // pProvData->pasProvPrivData
    DELETE_OBJECT(pProvData->pasProvPrivData);
    pProvData->csProvPrivData = 0;

    // pProvData->psPfns
    if (pProvData->psPfns)
    {
        if (pProvData->psPfns->psUIpfns)
        {
            DELETE_OBJECT(pProvData->psPfns->psUIpfns->psUIData);
            DELETE_OBJECT(pProvData->psPfns->psUIpfns);
        }

        DELETE_OBJECT(pProvData->psPfns);
    }
}

void _CleanupProviderNonStateData(CRYPT_PROVIDER_DATA *pProvData)
{
    // pProvData->hProv: we're using default!

    // pProvData->pWintrustData->xxx->hFile: close!
    if ((pProvData->fOpenedFile) && (pProvData->pWintrustData != NULL))
    {
        HANDLE  *phFile;

        phFile  = NULL;

        switch (pProvData->pWintrustData->dwUnionChoice)
        {
            case WTD_CHOICE_FILE:
                phFile = &pProvData->pWintrustData->pFile->hFile;
                break;

            case WTD_CHOICE_CATALOG:
                phFile = &pProvData->pWintrustData->pCatalog->hMemberFile;
                break;
        }

        if ((phFile) && (*phFile) && (*phFile != INVALID_HANDLE_VALUE))
        {
            CloseHandle(*phFile);
            *phFile = INVALID_HANDLE_VALUE;
            pProvData->fOpenedFile = FALSE;
        }
    }

    if (pProvData->dwSubjectChoice == CPD_CHOICE_SIP)
    {
        DELETE_OBJECT(pProvData->pPDSip->pSip);

        _WVTSipFreeSubjectInfoKeepState(pProvData->pPDSip->psSipSubjectInfo);

        // pProvData->pPDSip->psSipSubjectInfo: keep

        // pProvData->pPDSip->pCATSip: keep

        // pProvData->pPDSip->psSipCATSubjectInfo: keep

        TrustFreeDecode(WVT_MODID_WINTRUST, (BYTE **)&pProvData->pPDSip->psIndirectData);

        // pProvData->pPDSip: keep
    }


    // pProvData->hMsg: keep

    // signer structure: keep

    // pProvData->pahStores: keep

    // pProvData->padwTrustStepErrors: keep

    // pProvData->pasProvPrivData: keep

    // pProvData->psPfns: keep
}

BOOL _WVTSipFreeSubjectInfo(SIP_SUBJECTINFO *pSubj)
{
    if (!(pSubj))
    {
        return(FALSE);
    }

    DELETE_OBJECT(pSubj->pgSubjectType);

    switch(pSubj->dwUnionChoice)
    {
        case MSSIP_ADDINFO_BLOB:
            DELETE_OBJECT(pSubj->psBlob);
            break;

        case MSSIP_ADDINFO_CATMEMBER:
            if (pSubj->psCatMember)
            {
                // The following APIs are in DELAYLOAD'ed mscat32.dll. If the
                // DELAYLOAD fails an exception is raised.
                __try {
                    CryptCATClose(
                        CryptCATHandleFromStore(pSubj->psCatMember->pStore));
                } __except(EXCEPTION_EXECUTE_HANDLER) {
                    DWORD dwExceptionCode = GetExceptionCode();
                }

                DELETE_OBJECT(pSubj->psCatMember);
            }
            break;
    }

    return(TRUE);
}

BOOL _WVTSipFreeSubjectInfoKeepState(SIP_SUBJECTINFO *pSubj)
{
    if (!(pSubj))
    {
        return(FALSE);
    }

    DELETE_OBJECT(pSubj->pgSubjectType);

    switch(pSubj->dwUnionChoice)
    {
        case MSSIP_ADDINFO_BLOB:
            DELETE_OBJECT(pSubj->psBlob);
            break;

        case MSSIP_ADDINFO_CATMEMBER:
            break;
    }

    return(TRUE);
}

BOOL _WVTSetupProviderData(CRYPT_PROVIDER_DATA *psProvData, CRYPT_PROVIDER_DATA *psState)
{
    if (psState)
    {
        memcpy(psProvData, psState, sizeof(CRYPT_PROVIDER_DATA));

        if (_ISINSTRUCT(CRYPT_PROVIDER_DATA, psProvData->cbStruct, fRecallWithState))
        {
            psProvData->fRecallWithState = TRUE;
        }

        return(TRUE);
    }

    memset(psProvData, 0x00, sizeof(CRYPT_PROVIDER_DATA));

    psProvData->cbStruct    = sizeof(CRYPT_PROVIDER_DATA);

    if (!(psProvData->psPfns = (CRYPT_PROVIDER_FUNCTIONS *)WVTNew(sizeof(CRYPT_PROVIDER_FUNCTIONS))))
    {
        return(FALSE);
    }
    memset(psProvData->psPfns, 0x00, sizeof(CRYPT_PROVIDER_FUNCTIONS));
    psProvData->psPfns->cbStruct = sizeof(CRYPT_PROVIDER_FUNCTIONS);

    if (!(psProvData->psPfns->psUIpfns = (CRYPT_PROVUI_FUNCS *)WVTNew(sizeof(CRYPT_PROVUI_FUNCS))))
    {
        return(FALSE);
    }
    memset(psProvData->psPfns->psUIpfns, 0x00, sizeof(CRYPT_PROVUI_FUNCS));
    psProvData->psPfns->psUIpfns->cbStruct = sizeof(CRYPT_PROVUI_FUNCS);

    if (!(psProvData->psPfns->psUIpfns->psUIData = (CRYPT_PROVUI_DATA *)WVTNew(sizeof(CRYPT_PROVUI_DATA))))
    {
        return(FALSE);
    }
    memset(psProvData->psPfns->psUIpfns->psUIData, 0x00, sizeof(CRYPT_PROVUI_DATA));
    psProvData->psPfns->psUIpfns->psUIData->cbStruct = sizeof(CRYPT_PROVUI_DATA);

    GetSystemTimeAsFileTime(&psProvData->sftSystemTime);

    return(TRUE);
}

VOID FreeWintrustStateData (WINTRUST_DATA* pWintrustData)
{
    PCRYPT_PROVIDER_DATA pStateProvData;

    pStateProvData = WTHelperProvDataFromStateData(
                             pWintrustData->hWVTStateData
                             );

    if ( pStateProvData != NULL )
    {
        _CleanupProviderData( pStateProvData );
        DELETE_OBJECT( pWintrustData->hWVTStateData );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\wtasn.c ===
/* Copyright (C) Microsoft Corporation, 1996 - 1999 All rights reserved. */
/* ASN.1 definitions for Indirect data contents */

#include <windows.h>
#include "wtasn.h"

ASN1module_t WTASN_Module = NULL;

static int ASN1CALL ASN1Enc_ObjectID(ASN1encoding_t enc, ASN1uint32_t tag, ObjectID *val);
static int ASN1CALL ASN1Enc_SpcMinimalCriteria(ASN1encoding_t enc, ASN1uint32_t tag, SpcMinimalCriteria *val);
static int ASN1CALL ASN1Enc_UtcTime(ASN1encoding_t enc, ASN1uint32_t tag, UtcTime *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Enc_SpcAttributeTypeAndOptionalValue(ASN1encoding_t enc, ASN1uint32_t tag, SpcAttributeTypeAndOptionalValue *val);
static int ASN1CALL ASN1Enc_SpcString(ASN1encoding_t enc, ASN1uint32_t tag, SpcString *val);
static int ASN1CALL ASN1Enc_SpcSerializedObject(ASN1encoding_t enc, ASN1uint32_t tag, SpcSerializedObject *val);
static int ASN1CALL ASN1Enc_SpcLink(ASN1encoding_t enc, ASN1uint32_t tag, SpcLink *val);
static int ASN1CALL ASN1Enc_SpcPeImageData(ASN1encoding_t enc, ASN1uint32_t tag, SpcPeImageData *val);
static int ASN1CALL ASN1Enc_SpcSigInfo(ASN1encoding_t enc, ASN1uint32_t tag, SpcSigInfo *val);
static int ASN1CALL ASN1Enc_SpcImage(ASN1encoding_t enc, ASN1uint32_t tag, SpcImage *val);
static int ASN1CALL ASN1Enc_SpcFinancialCriteria(ASN1encoding_t enc, ASN1uint32_t tag, SpcFinancialCriteria *val);
static int ASN1CALL ASN1Enc_SpcStatementType(ASN1encoding_t enc, ASN1uint32_t tag, SpcStatementType *val);
static int ASN1CALL ASN1Enc_SpcSpOpusInfo(ASN1encoding_t enc, ASN1uint32_t tag, SpcSpOpusInfo *val);
static int ASN1CALL ASN1Enc_NameValue(ASN1encoding_t enc, ASN1uint32_t tag, NameValue *val);
static int ASN1CALL ASN1Enc_NameValues(ASN1encoding_t enc, ASN1uint32_t tag, NameValues *val);
static int ASN1CALL ASN1Enc_MemberInfo(ASN1encoding_t enc, ASN1uint32_t tag, MemberInfo *val);
static int ASN1CALL ASN1Enc_SpcIndirectDataContent(ASN1encoding_t enc, ASN1uint32_t tag, SpcIndirectDataContent *val);
static int ASN1CALL ASN1Enc_SpcSpAgencyInformation(ASN1encoding_t enc, ASN1uint32_t tag, SpcSpAgencyInformation *val);
static int ASN1CALL ASN1Dec_ObjectID(ASN1decoding_t dec, ASN1uint32_t tag, ObjectID *val);
static int ASN1CALL ASN1Dec_SpcMinimalCriteria(ASN1decoding_t dec, ASN1uint32_t tag, SpcMinimalCriteria *val);
static int ASN1CALL ASN1Dec_UtcTime(ASN1decoding_t dec, ASN1uint32_t tag, UtcTime *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Dec_SpcAttributeTypeAndOptionalValue(ASN1decoding_t dec, ASN1uint32_t tag, SpcAttributeTypeAndOptionalValue *val);
static int ASN1CALL ASN1Dec_SpcString(ASN1decoding_t dec, ASN1uint32_t tag, SpcString *val);
static int ASN1CALL ASN1Dec_SpcSerializedObject(ASN1decoding_t dec, ASN1uint32_t tag, SpcSerializedObject *val);
static int ASN1CALL ASN1Dec_SpcLink(ASN1decoding_t dec, ASN1uint32_t tag, SpcLink *val);
static int ASN1CALL ASN1Dec_SpcPeImageData(ASN1decoding_t dec, ASN1uint32_t tag, SpcPeImageData *val);
static int ASN1CALL ASN1Dec_SpcSigInfo(ASN1decoding_t dec, ASN1uint32_t tag, SpcSigInfo *val);
static int ASN1CALL ASN1Dec_SpcImage(ASN1decoding_t dec, ASN1uint32_t tag, SpcImage *val);
static int ASN1CALL ASN1Dec_SpcFinancialCriteria(ASN1decoding_t dec, ASN1uint32_t tag, SpcFinancialCriteria *val);
static int ASN1CALL ASN1Dec_SpcStatementType(ASN1decoding_t dec, ASN1uint32_t tag, SpcStatementType *val);
static int ASN1CALL ASN1Dec_SpcSpOpusInfo(ASN1decoding_t dec, ASN1uint32_t tag, SpcSpOpusInfo *val);
static int ASN1CALL ASN1Dec_NameValue(ASN1decoding_t dec, ASN1uint32_t tag, NameValue *val);
static int ASN1CALL ASN1Dec_NameValues(ASN1decoding_t dec, ASN1uint32_t tag, NameValues *val);
static int ASN1CALL ASN1Dec_MemberInfo(ASN1decoding_t dec, ASN1uint32_t tag, MemberInfo *val);
static int ASN1CALL ASN1Dec_SpcIndirectDataContent(ASN1decoding_t dec, ASN1uint32_t tag, SpcIndirectDataContent *val);
static int ASN1CALL ASN1Dec_SpcSpAgencyInformation(ASN1decoding_t dec, ASN1uint32_t tag, SpcSpAgencyInformation *val);
static void ASN1CALL ASN1Free_ObjectID(ObjectID *val);
static void ASN1CALL ASN1Free_UtcTime(UtcTime *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val);
static void ASN1CALL ASN1Free_SpcAttributeTypeAndOptionalValue(SpcAttributeTypeAndOptionalValue *val);
static void ASN1CALL ASN1Free_SpcString(SpcString *val);
static void ASN1CALL ASN1Free_SpcSerializedObject(SpcSerializedObject *val);
static void ASN1CALL ASN1Free_SpcLink(SpcLink *val);
static void ASN1CALL ASN1Free_SpcPeImageData(SpcPeImageData *val);
static void ASN1CALL ASN1Free_SpcSigInfo(SpcSigInfo *val);
static void ASN1CALL ASN1Free_SpcImage(SpcImage *val);
static void ASN1CALL ASN1Free_SpcStatementType(SpcStatementType *val);
static void ASN1CALL ASN1Free_SpcSpOpusInfo(SpcSpOpusInfo *val);
static void ASN1CALL ASN1Free_NameValue(NameValue *val);
static void ASN1CALL ASN1Free_NameValues(NameValues *val);
static void ASN1CALL ASN1Free_MemberInfo(MemberInfo *val);
static void ASN1CALL ASN1Free_SpcIndirectDataContent(SpcIndirectDataContent *val);
static void ASN1CALL ASN1Free_SpcSpAgencyInformation(SpcSpAgencyInformation *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[14] = {
    (ASN1EncFun_t) ASN1Enc_ObjectID,
    (ASN1EncFun_t) ASN1Enc_SpcMinimalCriteria,
    (ASN1EncFun_t) ASN1Enc_UtcTime,
    (ASN1EncFun_t) ASN1Enc_SpcLink,
    (ASN1EncFun_t) ASN1Enc_SpcPeImageData,
    (ASN1EncFun_t) ASN1Enc_SpcSigInfo,
    (ASN1EncFun_t) ASN1Enc_SpcFinancialCriteria,
    (ASN1EncFun_t) ASN1Enc_SpcStatementType,
    (ASN1EncFun_t) ASN1Enc_SpcSpOpusInfo,
    (ASN1EncFun_t) ASN1Enc_NameValue,
    (ASN1EncFun_t) ASN1Enc_NameValues,
    (ASN1EncFun_t) ASN1Enc_MemberInfo,
    (ASN1EncFun_t) ASN1Enc_SpcIndirectDataContent,
    (ASN1EncFun_t) ASN1Enc_SpcSpAgencyInformation,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[14] = {
    (ASN1DecFun_t) ASN1Dec_ObjectID,
    (ASN1DecFun_t) ASN1Dec_SpcMinimalCriteria,
    (ASN1DecFun_t) ASN1Dec_UtcTime,
    (ASN1DecFun_t) ASN1Dec_SpcLink,
    (ASN1DecFun_t) ASN1Dec_SpcPeImageData,
    (ASN1DecFun_t) ASN1Dec_SpcSigInfo,
    (ASN1DecFun_t) ASN1Dec_SpcFinancialCriteria,
    (ASN1DecFun_t) ASN1Dec_SpcStatementType,
    (ASN1DecFun_t) ASN1Dec_SpcSpOpusInfo,
    (ASN1DecFun_t) ASN1Dec_NameValue,
    (ASN1DecFun_t) ASN1Dec_NameValues,
    (ASN1DecFun_t) ASN1Dec_MemberInfo,
    (ASN1DecFun_t) ASN1Dec_SpcIndirectDataContent,
    (ASN1DecFun_t) ASN1Dec_SpcSpAgencyInformation,
};
static const ASN1FreeFun_t freefntab[14] = {
    (ASN1FreeFun_t) ASN1Free_ObjectID,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_UtcTime,
    (ASN1FreeFun_t) ASN1Free_SpcLink,
    (ASN1FreeFun_t) ASN1Free_SpcPeImageData,
    (ASN1FreeFun_t) ASN1Free_SpcSigInfo,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_SpcStatementType,
    (ASN1FreeFun_t) ASN1Free_SpcSpOpusInfo,
    (ASN1FreeFun_t) ASN1Free_NameValue,
    (ASN1FreeFun_t) ASN1Free_NameValues,
    (ASN1FreeFun_t) ASN1Free_MemberInfo,
    (ASN1FreeFun_t) ASN1Free_SpcIndirectDataContent,
    (ASN1FreeFun_t) ASN1Free_SpcSpAgencyInformation,
};
static const ULONG sizetab[14] = {
    SIZE_WTASN_Module_PDU_0,
    SIZE_WTASN_Module_PDU_1,
    SIZE_WTASN_Module_PDU_2,
    SIZE_WTASN_Module_PDU_3,
    SIZE_WTASN_Module_PDU_4,
    SIZE_WTASN_Module_PDU_5,
    SIZE_WTASN_Module_PDU_6,
    SIZE_WTASN_Module_PDU_7,
    SIZE_WTASN_Module_PDU_8,
    SIZE_WTASN_Module_PDU_9,
    SIZE_WTASN_Module_PDU_10,
    SIZE_WTASN_Module_PDU_11,
    SIZE_WTASN_Module_PDU_12,
    SIZE_WTASN_Module_PDU_13,
};

/* forward declarations of values: */
extern ASN1octet_t SpcPeImageData_flags_default_octets[1];
/* definitions of value components: */
static ASN1octet_t SpcPeImageData_flags_default_octets[1] = { 0x80 };
/* definitions of values: */
SpcPeImageFlags SpcPeImageData_flags_default = { 1, SpcPeImageData_flags_default_octets };

void ASN1CALL WTASN_Module_Startup(void)
{
    WTASN_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 14, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x7477);
}

void ASN1CALL WTASN_Module_Cleanup(void)
{
    ASN1_CloseModule(WTASN_Module);
    WTASN_Module = NULL;
}

static int ASN1CALL ASN1Enc_ObjectID(ASN1encoding_t enc, ASN1uint32_t tag, ObjectID *val)
{
    if (!ASN1BEREncObjectIdentifier2(enc, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ObjectID(ASN1decoding_t dec, ASN1uint32_t tag, ObjectID *val)
{
    if (!ASN1BERDecObjectIdentifier2(dec, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ObjectID(ObjectID *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SpcMinimalCriteria(ASN1encoding_t enc, ASN1uint32_t tag, SpcMinimalCriteria *val)
{
    if (!ASN1BEREncBool(enc, tag ? tag : 0x1, *val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcMinimalCriteria(ASN1decoding_t dec, ASN1uint32_t tag, SpcMinimalCriteria *val)
{
    if (!ASN1BERDecBool(dec, tag ? tag : 0x1, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UtcTime(ASN1encoding_t enc, ASN1uint32_t tag, UtcTime *val)
{
    if (!ASN1DEREncUTCTime(enc, tag ? tag : 0x17, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UtcTime(ASN1decoding_t dec, ASN1uint32_t tag, UtcTime *val)
{
    if (!ASN1BERDecUTCTime(dec, tag ? tag : 0x17, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UtcTime(UtcTime *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->digest).length, ((val)->digest).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->digest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->digestAlgorithm);
    }
}

static int ASN1CALL ASN1Enc_SpcAttributeTypeAndOptionalValue(ASN1encoding_t enc, ASN1uint32_t tag, SpcAttributeTypeAndOptionalValue *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->type))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcAttributeTypeAndOptionalValue(ASN1decoding_t dec, ASN1uint32_t tag, SpcAttributeTypeAndOptionalValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->type))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->value))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcAttributeTypeAndOptionalValue(SpcAttributeTypeAndOptionalValue *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_SpcString(ASN1encoding_t enc, ASN1uint32_t tag, SpcString *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncChar16String(enc, 0x80000000, ((val)->u.unicode).length, ((val)->u.unicode).value))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncCharString(enc, 0x80000001, ((val)->u.ascii).length, ((val)->u.ascii).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SpcString(ASN1decoding_t dec, ASN1uint32_t tag, SpcString *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecChar16String(dec, 0x80000000, &(val)->u.unicode))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecCharString(dec, 0x80000001, &(val)->u.ascii))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SpcString(SpcString *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1char16string_free(&(val)->u.unicode);
	    break;
	case 2:
	    ASN1charstring_free(&(val)->u.ascii);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_SpcSerializedObject(ASN1encoding_t enc, ASN1uint32_t tag, SpcSerializedObject *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->classId).length, ((val)->classId).value))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->serializedData).length, ((val)->serializedData).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcSerializedObject(ASN1decoding_t dec, ASN1uint32_t tag, SpcSerializedObject *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->classId))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->serializedData))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcSerializedObject(SpcSerializedObject *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SpcLink(ASN1encoding_t enc, ASN1uint32_t tag, SpcLink *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncCharString(enc, 0x80000000, ((val)->u.url).length, ((val)->u.url).value))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_SpcSerializedObject(enc, 0x80000001, &(val)->u.moniker))
	    return 0;
	break;
    case 3:
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcString(enc, 0, &(val)->u.file))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SpcLink(ASN1decoding_t dec, ASN1uint32_t tag, SpcLink *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecCharString(dec, 0x80000000, &(val)->u.url))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1Dec_SpcSerializedObject(dec, 0x80000001, &(val)->u.moniker))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecExplicitTag(dec, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcString(dd0, 0, &(val)->u.file))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SpcLink(SpcLink *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1charstring_free(&(val)->u.url);
	    break;
	case 2:
	    ASN1Free_SpcSerializedObject(&(val)->u.moniker);
	    break;
	case 3:
	    ASN1Free_SpcString(&(val)->u.file);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_SpcPeImageData(ASN1encoding_t enc, ASN1uint32_t tag, SpcPeImageData *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    ASN1uint32_t r;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if (!ASN1bitstring_cmp(&val->flags, &SpcPeImageData_flags_default, 1))
	o[0] &= ~0x80;
    if (o[0] & 0x80) {
	r = ((val)->flags).length;
	ASN1BEREncRemoveZeroBits(&r, ((val)->flags).value);
	if (!ASN1DEREncBitString(enc, 0x3, r, ((val)->flags).value))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcLink(enc, 0, &(val)->file))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcPeImageData(ASN1decoding_t dec, ASN1uint32_t tag, SpcPeImageData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x3) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecBitString(dd, 0x3, &(val)->flags))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcLink(dd0, 0, &(val)->file))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcPeImageData(SpcPeImageData *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1bitstring_free(&(val)->flags);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SpcLink(&(val)->file);
	}
    }
}

static int ASN1CALL ASN1Enc_SpcSigInfo(ASN1encoding_t enc, ASN1uint32_t tag, SpcSigInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->dwSIPversion))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->gSIPguid).length, ((val)->gSIPguid).value))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->dwReserved1))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->dwReserved2))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->dwReserved3))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->dwReserved4))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->dwReserved5))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcSigInfo(ASN1decoding_t dec, ASN1uint32_t tag, SpcSigInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->dwSIPversion))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->gSIPguid))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->dwReserved1))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->dwReserved2))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->dwReserved3))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->dwReserved4))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->dwReserved5))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcSigInfo(SpcSigInfo *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SpcImage(ASN1encoding_t enc, ASN1uint32_t tag, SpcImage *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcLink(enc, 0, &(val)->imageLink))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->bitmap).length, ((val)->bitmap).value))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1DEREncOctetString(enc, 0x80000002, ((val)->metafile).length, ((val)->metafile).value))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1DEREncOctetString(enc, 0x80000003, ((val)->enhancedMetafile).length, ((val)->enhancedMetafile).value))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->gifFile).length, ((val)->gifFile).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcImage(ASN1decoding_t dec, ASN1uint32_t tag, SpcImage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcLink(dd0, 0, &(val)->imageLink))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecOctetString2(dd, 0x80000001, &(val)->bitmap))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecOctetString2(dd, 0x80000002, &(val)->metafile))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecOctetString2(dd, 0x80000003, &(val)->enhancedMetafile))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecOctetString2(dd, 0x80000004, &(val)->gifFile))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcImage(SpcImage *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SpcLink(&(val)->imageLink);
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	}
	if ((val)->o[0] & 0x10) {
	}
	if ((val)->o[0] & 0x8) {
	}
    }
}

static int ASN1CALL ASN1Enc_SpcFinancialCriteria(ASN1encoding_t enc, ASN1uint32_t tag, SpcFinancialCriteria *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->financialInfoAvailable))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->meetsCriteria))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcFinancialCriteria(ASN1decoding_t dec, ASN1uint32_t tag, SpcFinancialCriteria *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecBool(dd, 0x1, &(val)->financialInfoAvailable))
	return 0;
    if (!ASN1BERDecBool(dd, 0x1, &(val)->meetsCriteria))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_SpcStatementType(ASN1encoding_t enc, ASN1uint32_t tag, SpcStatementType *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcStatementType(ASN1decoding_t dec, ASN1uint32_t tag, SpcStatementType *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (ObjectID *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcStatementType(SpcStatementType *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SpcSpOpusInfo(ASN1encoding_t enc, ASN1uint32_t tag, SpcSpOpusInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcString(enc, 0, &(val)->programName))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcLink(enc, 0, &(val)->moreInfo))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcLink(enc, 0, &(val)->publisherInfo))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcSpOpusInfo(ASN1decoding_t dec, ASN1uint32_t tag, SpcSpOpusInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcString(dd0, 0, &(val)->programName))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcLink(dd0, 0, &(val)->moreInfo))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcLink(dd0, 0, &(val)->publisherInfo))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcSpOpusInfo(SpcSpOpusInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SpcString(&(val)->programName);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SpcLink(&(val)->moreInfo);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SpcLink(&(val)->publisherInfo);
	}
    }
}

static int ASN1CALL ASN1Enc_NameValue(ASN1encoding_t enc, ASN1uint32_t tag, NameValue *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->refname).length, ((val)->refname).value))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->typeaction))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->value).length, ((val)->value).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NameValue(ASN1decoding_t dec, ASN1uint32_t tag, NameValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->refname))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->typeaction))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NameValue(NameValue *val)
{
    if (val) {
	ASN1char16string_free(&(val)->refname);
    }
}

static int ASN1CALL ASN1Enc_NameValues(ASN1encoding_t enc, ASN1uint32_t tag, NameValues *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_NameValue(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NameValues(ASN1decoding_t dec, ASN1uint32_t tag, NameValues *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (NameValue *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_NameValue(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NameValues(NameValues *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_NameValue(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_NameValue(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_MemberInfo(ASN1encoding_t enc, ASN1uint32_t tag, MemberInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->subguid).length, ((val)->subguid).value))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->certversion))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MemberInfo(ASN1decoding_t dec, ASN1uint32_t tag, MemberInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->subguid))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->certversion))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MemberInfo(MemberInfo *val)
{
    if (val) {
	ASN1char16string_free(&(val)->subguid);
    }
}

static int ASN1CALL ASN1Enc_SpcIndirectDataContent(ASN1encoding_t enc, ASN1uint32_t tag, SpcIndirectDataContent *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_SpcAttributeTypeAndOptionalValue(enc, 0, &(val)->data))
	return 0;
    if (!ASN1Enc_DigestInfo(enc, 0, &(val)->messageDigest))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcIndirectDataContent(ASN1decoding_t dec, ASN1uint32_t tag, SpcIndirectDataContent *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_SpcAttributeTypeAndOptionalValue(dd, 0, &(val)->data))
	return 0;
    if (!ASN1Dec_DigestInfo(dd, 0, &(val)->messageDigest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcIndirectDataContent(SpcIndirectDataContent *val)
{
    if (val) {
	ASN1Free_SpcAttributeTypeAndOptionalValue(&(val)->data);
	ASN1Free_DigestInfo(&(val)->messageDigest);
    }
}

static int ASN1CALL ASN1Enc_SpcSpAgencyInformation(ASN1encoding_t enc, ASN1uint32_t tag, SpcSpAgencyInformation *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcLink(enc, 0, &(val)->policyInformation))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcString(enc, 0, &(val)->policyDisplayText))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SpcImage(enc, 0x80000002, &(val)->logoImage))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcLink(enc, 0, &(val)->logoLink))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcSpAgencyInformation(ASN1decoding_t dec, ASN1uint32_t tag, SpcSpAgencyInformation *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcLink(dd0, 0, &(val)->policyInformation))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcString(dd0, 0, &(val)->policyDisplayText))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_SpcImage(dd, 0x80000002, &(val)->logoImage))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcLink(dd0, 0, &(val)->logoLink))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcSpAgencyInformation(SpcSpAgencyInformation *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SpcLink(&(val)->policyInformation);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SpcString(&(val)->policyDisplayText);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SpcImage(&(val)->logoImage);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_SpcLink(&(val)->logoLink);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\usagedef.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       usagedef.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider Model
//
//  Functions:  WintrustAddDefaultForUsage
//              WintrustGetDefaultForUsage
//
//  History:    07-Sep-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "cryptreg.h"


BOOL WINAPI WintrustAddDefaultForUsage(const char *pszUsageOID, 
                                       CRYPT_PROVIDER_REGDEFUSAGE *psDefUsage)
{
    HKEY            hKey;
    WCHAR           wsz[REG_MAX_KEY_NAME];
    WCHAR           wszUsage[REG_MAX_FUNC_NAME];
    WCHAR           wszGuid[REG_MAX_GUID_TEXT];
    DWORD           dwDisposition;
    HRESULT         hr;
    int             cchUsage;

    if (!(pszUsageOID) ||
        !(psDefUsage) ||
        !(_ISINSTRUCT(CRYPT_PROVIDER_REGDEFUSAGE, 
                      psDefUsage->cbStruct, 
                      pwszFreeCallbackDataFunctionName)) ||
        !(psDefUsage->pgActionID))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(guid2wstr(psDefUsage->pgActionID, &wszGuid[0])))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    wszUsage[0] = L'\0';
    cchUsage = MultiByteToWideChar(0, 0, pszUsageOID, -1, &wszUsage[0],
        REG_MAX_FUNC_NAME);
    if (0 >= cchUsage)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (REG_MAX_KEY_NAME < wcslen(REG_TRUST_USAGE_KEY) + 1 + cchUsage + 1)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    wcscpy(&wsz[0], REG_TRUST_USAGE_KEY);
    wcscat(&wsz[0], L"\\");
    wcscat(&wsz[0], &wszUsage[0]);

    if (RegCreateKeyExU(HKEY_LOCAL_MACHINE,
                        &wsz[0],
                        0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                        &hKey, &dwDisposition) != ERROR_SUCCESS)
    {
        return(FALSE);
    }

    hr = RegSetValueExU(hKey, REG_DEF_FOR_USAGE,
                        0, REG_SZ,
                        (BYTE *)&wszGuid[0],
                        (wcslen(&wszGuid[0]) + 1) * sizeof(WCHAR));

    if (psDefUsage->pwszDllName)
    {
        hr |= RegSetValueExU(hKey, REG_DLL_NAME,
                            0, REG_SZ,
                            (BYTE *)psDefUsage->pwszDllName,
                            (wcslen(psDefUsage->pwszDllName) + 1) * sizeof(WCHAR));

        if (psDefUsage->pwszLoadCallbackDataFunctionName)
        {
            hr |= RegSetValueExA(hKey, REG_DEF_CALLBACK_ALLOC,
                                0, REG_SZ,
                                (BYTE *)psDefUsage->pwszLoadCallbackDataFunctionName,
                                strlen(psDefUsage->pwszLoadCallbackDataFunctionName) + 1);

            if (psDefUsage->pwszFreeCallbackDataFunctionName)
            {
                hr |= RegSetValueExA(hKey, REG_DEF_CALLBACK_FREE,
                                    0, REG_SZ,
                                    (BYTE *)psDefUsage->pwszFreeCallbackDataFunctionName,
                                    strlen(psDefUsage->pwszFreeCallbackDataFunctionName) + 1);
            }
        }
    }

    RegCloseKey(hKey);

    return((hr == ERROR_SUCCESS) ? TRUE : FALSE);
}

BOOL WINAPI WintrustGetDefaultForUsage(DWORD dwAction, const char *pszUsageOID,
                                       CRYPT_PROVIDER_DEFUSAGE *psUsage)
{
    BOOL                        fRet;
    HKEY                        hKey;
    WCHAR                       wsz[REG_MAX_KEY_NAME];
    char                        szFunc[REG_MAX_FUNC_NAME];
    WCHAR                       wszUsage[REG_MAX_FUNC_NAME];
    WCHAR                       wszGuid[REG_MAX_GUID_TEXT];
    DWORD                       dwType;
    DWORD                       dwSize;
    HINSTANCE                   hDll;
    PFN_ALLOCANDFILLDEFUSAGE    pfnAlloc;
    PFN_FREEDEFUSAGE            pfnFree;
    int                         cchUsage;

    fRet        = TRUE;
    hKey        = NULL;
    hDll        = NULL;
    pfnAlloc    = NULL;
    pfnFree     = NULL;

    if (!(pszUsageOID) ||
        !(psUsage) ||
        !(_ISINSTRUCT(CRYPT_PROVIDER_DEFUSAGE, 
                      psUsage->cbStruct, 
                      pDefSIPClientData)))
    {
        goto InvalidParamError;
    }

    memset(&psUsage->gActionID, 0x00, sizeof(GUID));

    wszUsage[0] = L'\0';
    cchUsage = MultiByteToWideChar(0, 0, pszUsageOID, -1, &wszUsage[0], 
        REG_MAX_FUNC_NAME);
    if (0 >= cchUsage)
    {
        goto InvalidParamError;
    }

    if (REG_MAX_KEY_NAME < wcslen(REG_TRUST_USAGE_KEY) + 1 + cchUsage + 1)
    {
        goto InvalidParamError;
    }
    wcscpy(&wsz[0], REG_TRUST_USAGE_KEY);
    wcscat(&wsz[0], L"\\");
    wcscat(&wsz[0], &wszUsage[0]);

    if (RegOpenKeyExU(  HKEY_LOCAL_MACHINE,
                        &wsz[0],
                        0,
                        KEY_READ,
                        &hKey) != ERROR_SUCCESS)
    {
        goto RegOpenError;
    }

    // 
    //  get the dll name and function entry points
    //
    dwType = 0;
    dwSize = REG_MAX_KEY_NAME * sizeof(WCHAR);

    if (RegQueryValueExU(hKey, REG_DLL_NAME, NULL, &dwType, (BYTE *)&wsz[0], &dwSize) == ERROR_SUCCESS)
    {
        if (hDll = LoadLibraryU(&wsz[0]))
        {
            dwType = 0;
            dwSize = REG_MAX_FUNC_NAME;

            if (RegQueryValueExA(hKey, 
                                (dwAction == DWACTION_FREE) ? REG_DEF_CALLBACK_FREE : REG_DEF_CALLBACK_ALLOC,
                                NULL, &dwType, (BYTE *)&szFunc[0], &dwSize) == ERROR_SUCCESS)
            {
                if (dwAction == DWACTION_FREE)
                {
                    pfnFree = (PFN_FREEDEFUSAGE)GetProcAddress(hDll, &szFunc[0]);

                    if (pfnFree)
                    {
                        (*pfnFree)(pszUsageOID, psUsage);
                    }

                    fRet = TRUE;
                    goto CommonReturn;
                }
                
                pfnAlloc = (PFN_ALLOCANDFILLDEFUSAGE)GetProcAddress(hDll, &szFunc[0]);
            }
        }
    }

    if (dwAction != DWACTION_ALLOCANDFILL)
    {
        goto CommonReturn;
    }

    dwType = 0;
    dwSize = REG_MAX_GUID_TEXT * sizeof(WCHAR);

    wszGuid[0] = NULL;

    if (RegQueryValueExU(   hKey, 
                            REG_DEF_FOR_USAGE,
                            NULL, 
                            &dwType,
                            (BYTE *)&wszGuid[0],
                            &dwSize) != ERROR_SUCCESS)
    {
        goto RegQueryError;
    }

    if (!(wstr2guid(&wszGuid[0], &psUsage->gActionID)))
    {
        goto GuidError;
    }

    if (pfnAlloc)
    {
        if (!(*pfnAlloc)(pszUsageOID, psUsage))
        {
            goto UsageAllocError;
        }
    }

    CommonReturn:
        if (hKey)
        {
            RegCloseKey(hKey);
        }

        if (hDll)
        {
            FreeLibrary(hDll);
        }

        return(fRet);

    ErrorReturn:
        fRet = FALSE;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, RegOpenError);
    TRACE_ERROR_EX(DBG_SS, RegQueryError);
    TRACE_ERROR_EX(DBG_SS, GuidError);
    TRACE_ERROR_EX(DBG_SS, UsageAllocError);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParamError, ERROR_INVALID_PARAMETER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\wthelper.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wthelper.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  WTHelperGetProvPrivateDataFromChain
//              WTHelperGetProvSignerFromChain
//              WTHelperGetFileHandle
//              WTHelperGetFileName
//              WTHelperOpenKnownStores
//              WTHelperGetProvCertFromChain
//              WTHelperCheckCertUsage
//              WTHelperIsInRootStore
//              WTHelperProvDataFromStateData
//              WTHelperGetAgencyInfo
//
//              *** local functions ***
//              _FindKeyUsage
//
//  History:    01-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "pkialloc.h"

BOOL _FindKeyUsage(PCERT_ENHKEY_USAGE  pUsage, LPCSTR pszRequestedUsageOID);

CRYPT_PROVIDER_PRIVDATA * WINAPI WTHelperGetProvPrivateDataFromChain(CRYPT_PROVIDER_DATA *pProvData,
                                                                            GUID *pgProviderID)
{
    if (!(pProvData) ||
        !(pgProviderID))
    {
        return(NULL);
    }

    for (int i = 0; i < (int)pProvData->csProvPrivData; i++)
    {
        if (memcmp(&pProvData->pasProvPrivData[i].gProviderID, pgProviderID, sizeof(GUID)) == 0)
        {
            return(&pProvData->pasProvPrivData[i]);
        }
    }

    return(NULL);
}


CRYPT_PROVIDER_SGNR * WINAPI WTHelperGetProvSignerFromChain(CRYPT_PROVIDER_DATA *pProvData,
                                                            DWORD idxSigner,
                                                            BOOL fCounterSigner,
                                                            DWORD idxCounterSigner)
{
    if (!(pProvData) ||
        (idxSigner >= pProvData->csSigners))
    {
        return(NULL);
    }

    if (fCounterSigner)
    {
        if (idxCounterSigner >= pProvData->pasSigners[idxSigner].csCounterSigners)
        {
            return(NULL);
        }

        return(&pProvData->pasSigners[idxSigner].pasCounterSigners[idxCounterSigner]);
    }

    return(&pProvData->pasSigners[idxSigner]);
}

CRYPT_PROVIDER_CERT * WINAPI WTHelperGetProvCertFromChain(CRYPT_PROVIDER_SGNR *pSgnr,
                                                          DWORD idxCert)
{
    if (!(pSgnr) ||
        (idxCert >= pSgnr->csCertChain))
    {
        return(NULL);
    }

    return(&pSgnr->pasCertChain[idxCert]);
}

HANDLE WINAPI WTHelperGetFileHandle(WINTRUST_DATA *pWintrustData)
{
    switch (pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_FILE:
                return(pWintrustData->pFile->hFile);

        case WTD_CHOICE_CATALOG:
                return(pWintrustData->pCatalog->hMemberFile);
    }

    return(INVALID_HANDLE_VALUE);
}


WCHAR * WINAPI WTHelperGetFileName(WINTRUST_DATA *pWintrustData)
{
    switch (pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_FILE:
                return((WCHAR *)pWintrustData->pFile->pcwszFilePath);

        case WTD_CHOICE_CATALOG:
                if (!(pWintrustData->pCatalog->pcwszCatalogFilePath) ||
                    !(pWintrustData->pCatalog->pcwszMemberTag))
                {
                    return(NULL);
                }
                return((WCHAR *)pWintrustData->pCatalog->pcwszMemberFilePath);
        case WTD_CHOICE_CERT:
                if (pWintrustData->pCert->pcwszDisplayName)
                    return (WCHAR *) pWintrustData->pCert->pcwszDisplayName;
                else
                    return L"Certificate";
        case WTD_CHOICE_BLOB:
                if (pWintrustData->pBlob->pcwszDisplayName)
                    return (WCHAR *) pWintrustData->pBlob->pcwszDisplayName;
                else
                    return L"Blob";
    }

    return(NULL);
}

BOOL WINAPI WTHelperOpenKnownStores(CRYPT_PROVIDER_DATA *pProvData)
{
    DWORD       i;
    DWORD       cs;
    HCERTSTORE  *pas;

    if ((pProvData->pWintrustData) &&
        (pProvData->pWintrustData->dwUnionChoice == WTD_CHOICE_CERT) &&
        (_ISINSTRUCT(WINTRUST_CERT_INFO, pProvData->pWintrustData->pCert->cbStruct, dwFlags)))
    {
        HCERTSTORE  hStore;

        if (pProvData->pWintrustData->pCert->dwFlags & WTCI_DONT_OPEN_STORES)
        {
            if (hStore = CertOpenStore(CERT_STORE_PROV_MEMORY, 0, NULL, 0, NULL))
            {
                AddToStoreChain(hStore, &pProvData->chStores, &pProvData->pahStores);
                return(TRUE);
            }

            return(FALSE);
        }

        if (pProvData->pWintrustData->pCert->dwFlags & WTCI_OPEN_ONLY_ROOT)
        {
            if (hStore = StoreProviderGetStore(pProvData->hProv, WVT_STOREID_ROOT))
            {
                AddToStoreChain(hStore, &pProvData->chStores, &pProvData->pahStores);
                return(TRUE);
            }

            return(FALSE);
        }
    }

    cs = 0;
    TrustOpenStores(pProvData->hProv, &cs, NULL, 0);

    if (cs > 0)
    {
        if (!(pas = new HCERTSTORE[cs]))
        {
            pProvData->dwError = ERROR_NOT_ENOUGH_MEMORY;
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = TRUST_E_SYSTEM_ERROR;
            return(FALSE);
        }

        if (TrustOpenStores(pProvData->hProv, &cs, pas, 0))
        {
            
            for (i = 0; i < cs; i++)
            {
                AddToStoreChain(pas[i], &pProvData->chStores, &pProvData->pahStores);
            }
        }
        else
        {
            cs = 0;
        }

        delete pas;
    }

    if (cs > 0)
    {
        return(TRUE);
    }

    return(FALSE);
}

BOOL WINAPI WTHelperGetAgencyInfo(PCCERT_CONTEXT pCert, DWORD *pcbAgencyInfo, SPC_SP_AGENCY_INFO *pAgencyInfo)
{
    PCERT_EXTENSION     pExt;
    PSPC_SP_AGENCY_INFO pInfo;
    DWORD               cbInfo;


    if (!(pCert) || !(pcbAgencyInfo))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    *pcbAgencyInfo = 0;

    if (!(pExt = CertFindExtension(SPC_SP_AGENCY_INFO_OBJID, pCert->pCertInfo->cExtension,
                                   pCert->pCertInfo->rgExtension)))
    {
        return(FALSE);
    }

    CryptDecodeObject(X509_ASN_ENCODING, SPC_SP_AGENCY_INFO_STRUCT,
                     pExt->Value.pbData, pExt->Value.cbData, 0, NULL,
                     pcbAgencyInfo);

    if (*pcbAgencyInfo == 0) 
    {
        return(FALSE);
    }

    if (!(pAgencyInfo))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(FALSE);
    }

    if (!(CryptDecodeObject(X509_ASN_ENCODING, SPC_SP_AGENCY_INFO_STRUCT,
                            pExt->Value.pbData, pExt->Value.cbData, 0, pAgencyInfo,
                            pcbAgencyInfo)))
    {
        return(FALSE);
    } 

    return(TRUE);
}

BOOL WINAPI WTHelperCheckCertUsage(PCCERT_CONTEXT pCertContext, LPCSTR pszRequestedUsageOID)
{
    PCERT_ENHKEY_USAGE  pUsage;
    DWORD               cbUsage;
    int                 i;

    cbUsage = 0;

    CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, NULL, &cbUsage);

    if (cbUsage > 0)
    {
        if (!(pUsage = (PCERT_ENHKEY_USAGE)new BYTE[cbUsage]))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }

        if (!(CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                      pUsage, &cbUsage)))
        {
            delete pUsage;
            return(FALSE);
        }

        //
        // the cert has enhanced key usage extensions, check if we find ours
        //
        if (!(_FindKeyUsage(pUsage, pszRequestedUsageOID)))
        {
            SetLastError(CERT_E_WRONG_USAGE);
    
            delete pUsage;
            return(FALSE);
        }

        delete pUsage;
    }


    //
    //  OK... either we have NO EXTENSION or we found our OID in the list in the EXTENSION.
    //  now, make sure if we have properties that it has been enabled.
    //
    cbUsage = 0;
    CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG, NULL, &cbUsage);

    if (cbUsage > 0)
    {
        if (!(pUsage = (PCERT_ENHKEY_USAGE)new BYTE[cbUsage]))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }

        if (!(CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
                                      pUsage, &cbUsage)))
        {
            delete pUsage;

            return(FALSE);
        }

        //
        //  the cert has properties, first check if we're disabled
        //
        if (_FindKeyUsage(pUsage, szOID_YESNO_TRUST_ATTR))
        {
            SetLastError(CERT_E_WRONG_USAGE);
    
            delete pUsage;
            return(FALSE);
        }

        if (!(_FindKeyUsage(pUsage, pszRequestedUsageOID)))
        {
            SetLastError(CERT_E_WRONG_USAGE);
    
            delete pUsage;
            return(FALSE);
        }
        
        delete pUsage;
    }

    return(TRUE);
}

BOOL _FindKeyUsage(PCERT_ENHKEY_USAGE  pUsage, LPCSTR pszRequestedUsageOID)
{
    int     i;

    for (i = 0; i < (int)pUsage->cUsageIdentifier; i++)
    {
        if (strcmp(pUsage->rgpszUsageIdentifier[i], pszRequestedUsageOID) == 0)
        {
            return(TRUE);   // OK found it!
        }
    }

    return(FALSE);
}

BOOL WINAPI WTHelperIsInRootStore(CRYPT_PROVIDER_DATA *pProvData, PCCERT_CONTEXT pCertContext)
{
    if (pProvData->chStores < 1)
    {
        return(FALSE);
    }

    //
    //  check the fast way first!
    //
    if (pCertContext->hCertStore == pProvData->pahStores[0])
    {
        //
        //  it's in the root store!
        //
        return(TRUE);
    }

    //
    //  can't do it the fast way -- do it the slow way!
    //
    BYTE            *pbHash;
    DWORD           cbHash;
    CRYPT_HASH_BLOB sBlob;
    PCCERT_CONTEXT  pWorkContext;

    cbHash = 0;

	if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, NULL, &cbHash)))
    {
        return(FALSE);
    }

    if (cbHash < 1)
    {
        return(FALSE);
    }

    if (!(pbHash = (BYTE *)WVTNew(cbHash)))
    {
        return(FALSE);
    }

	if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, pbHash, &cbHash)))
    {
        delete pbHash;
        return(FALSE);
    }

    sBlob.cbData    = cbHash;
    sBlob.pbData    = pbHash;

    pWorkContext = CertFindCertificateInStore(pProvData->pahStores[0], pProvData->dwEncoding, 0,
                                              CERT_FIND_SHA1_HASH, &sBlob, NULL);

    delete pbHash;

    if (pWorkContext)
    {
        CertFreeCertificateContext(pWorkContext);
        return(TRUE);
    }

    return(FALSE);
}


typedef struct _ENUM_OID_INFO_ARG {
    DWORD               cOidInfo;
    PCCRYPT_OID_INFO    *ppOidInfo; 
} ENUM_OID_INFO_ARG, *PENUM_OID_INFO_ARG;

static BOOL WINAPI EnumOidInfoCallback(
    IN PCCRYPT_OID_INFO pOidInfo,
    IN void *pvArg
    )
{
    PENUM_OID_INFO_ARG pEnumOidInfoArg = (PENUM_OID_INFO_ARG) pvArg;

    PCCRYPT_OID_INFO *ppNewOidInfo;
    DWORD cOidInfo = pEnumOidInfoArg->cOidInfo;

    // DSIE: Bug 152473.
    for (DWORD i = 0; i < cOidInfo; i++)
    {
        if (0 == wcscmp(pOidInfo->pwszName, pEnumOidInfoArg->ppOidInfo[i]->pwszName))
        {
            return TRUE;
        }
    }
  
    if (ppNewOidInfo = (PCCRYPT_OID_INFO *) PkiRealloc(
            pEnumOidInfoArg->ppOidInfo,
            (cOidInfo + 2) * sizeof(PCCRYPT_OID_INFO))) {
        ppNewOidInfo[cOidInfo] = pOidInfo;
        ppNewOidInfo[cOidInfo + 1] = NULL;
        pEnumOidInfoArg->cOidInfo = cOidInfo + 1;
        pEnumOidInfoArg->ppOidInfo = ppNewOidInfo;
    }

    return TRUE;
}

BOOL WINAPI WTHelperGetKnownUsages(DWORD fdwAction, PCCRYPT_OID_INFO **pppOidInfo)
{


    if (!(pppOidInfo))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (fdwAction == WTH_FREE)
    {
        PkiFree(*pppOidInfo);
        *pppOidInfo = NULL;

        return(TRUE);
    }

    if (fdwAction == WTH_ALLOC)
    {
        ENUM_OID_INFO_ARG EnumOidInfoArg;
        memset(&EnumOidInfoArg, 0, sizeof(EnumOidInfoArg));

        CryptEnumOIDInfo(
            CRYPT_ENHKEY_USAGE_OID_GROUP_ID,
            0,              // dwFlags
            &EnumOidInfoArg,
            EnumOidInfoCallback
            );
  
        return (NULL != (*pppOidInfo = EnumOidInfoArg.ppOidInfo));
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    *pppOidInfo = NULL;
    return(FALSE);
}

CRYPT_PROVIDER_DATA * WINAPI WTHelperProvDataFromStateData(HANDLE hStateData)
{
    return((CRYPT_PROVIDER_DATA *)hStateData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\wvtver1.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wvtver1.cpp
//
//  Contents:   Microsoft Internet Security WinVerifyTrust v1 support
//
//  Functions:  WintrustIsVersion1ActionID
//              ConvertDataFromVersion1
//
//              *** local functions ***
//
//  History:    30-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "wvtver1.h"

BOOL WintrustIsVersion1ActionID(GUID *pgActionID)
{
    GUID    gV1UISup    = V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE;
    GUID    gV1UINoBad  = V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI;

    if ((memcmp(pgActionID, &gV1UISup, sizeof(GUID)) == 0) ||
        (memcmp(pgActionID, &gV1UINoBad, sizeof(GUID)) == 0))
    {
        return(TRUE);
    }

    return(FALSE);
}

WINTRUST_DATA *ConvertDataFromVersion1(HWND hWnd,
                                       GUID *pgActionID,
                                       WINTRUST_DATA *pWTDNew, 
                                       WINTRUST_FILE_INFO *pWTFINew, 
                                       LPVOID pWTDOld)
{
    GUID                                    gV1UINoBad  = V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI;

    WCHAR                                   *pwszFile;
    WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT  *pActData;

    pActData    = (WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT *)pWTDOld;

    memset(pWTDNew, 0x00, sizeof(WINTRUST_DATA));
    pWTDNew->cbStruct           = sizeof(WINTRUST_DATA);
    pWTDNew->dwUnionChoice      = WTD_CHOICE_FILE;
    pWTDNew->pFile              = pWTFINew;

    memset(pWTFINew, 0x00, sizeof(WINTRUST_FILE_INFO));
    pWTFINew->cbStruct          = sizeof(WINTRUST_FILE_INFO);

    if (!(pWTDOld))
    {
        return(pWTDNew);
    }

    pWTDNew->dwUIChoice             = WTD_UI_ALL;
    pWTDNew->pPolicyCallbackData    = pActData->hClientToken;
    pWTFINew->hFile                 = ((WIN_TRUST_SUBJECT_FILE *)pActData->Subject)->hFile;

    if (memcmp(&gV1UINoBad, pgActionID, sizeof(GUID)) == 0)
    {
        pWTDNew->dwUIChoice     = WTD_UI_NOBAD;
    }

    if (hWnd == (HWND)(-1))
    {
        pWTDNew->dwUIChoice     = WTD_UI_NONE;
    }

    pwszFile                        = (WCHAR *)((WIN_TRUST_SUBJECT_FILE  *)pActData->Subject)->lpPath;

    while ((*pwszFile) && (*pwszFile != '|'))
    {
        ++pwszFile;
    }

    if (*pwszFile)
    {
        *pwszFile = NULL;
    }
    
    pWTFINew->pcwszFilePath = (WCHAR *)((WIN_TRUST_SUBJECT_FILE  *)pActData->Subject)->lpPath;

    return(pWTDNew);
}



//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  the following code implements the version 1 style of calling trust providers.
//
//  this code is ONLY implemented when a trust provider registers itself in the
//  old location!
//
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////


#define WIN_TRUST_MAJOR_REVISION_MASK       0xFFFF0000
#define WIN_TRUST_MINOR_REVISION_MASK       0x0000FFFF
#define WIN_TRUST_REVISION_1_0              0x00010000

#define REGISTRY_TRUSTPROVIDERS TEXT("System\\CurrentControlSet\\Services\\WinTrust\\TrustProviders")
#define REGISTRY_ROOT           HKEY_LOCAL_MACHINE

#define ACTION_IDS              TEXT("$ActionIDs")
#define DLL_NAME                TEXT("$DLL")

#define IsEqualActionID( id1, id2)    (!memcmp(id1, id2, sizeof(GUID))) 

typedef struct _WINTRUST_CLIENT_TP_INFO {
    DWORD                                   dwRevision;
    //LPWINTRUST_CLIENT_TP_DISPATCH_TABLE     lpServices;
    LPVOID                                  lpServices;
} WINTRUST_CLIENT_TP_INFO,  *LPWINTRUST_CLIENT_TP_INFO;

typedef LONG
(*LPWINTRUST_PROVIDER_VERIFY_TRUST) (
    IN     HWND                             hwnd,
    IN     GUID *                           ActionID,
    IN     LPVOID                           ActionData
    );

typedef VOID
(*LPWINTRUST_PROVIDER_SUBMIT_CERTIFICATE) (
    IN     LPWIN_CERTIFICATE                lpCertificate
    );

typedef VOID
(*LPWINTRUST_PROVIDER_CLIENT_UNLOAD) (
    IN     LPVOID                           lpTrustProviderInfo
    );

typedef BOOL
(*LPWINTRUST_PROVIDER_CLIENT_INITIALIZE)(
    IN     DWORD                                dwWinTrustRevision,
    IN     LPWINTRUST_CLIENT_TP_INFO            lpWinTrustInfo,
    IN     LPWSTR                               lpProviderName,
    LPVOID                                      *lpTrustProviderInfo
//    OUT    LPWINTRUST_PROVIDER_CLIENT_INFO      *lpTrustProviderInfo
    );

typedef struct _WINTRUST_PROVIDER_CLIENT_SERVICES
{
    LPWINTRUST_PROVIDER_CLIENT_UNLOAD       Unload;
    LPWINTRUST_PROVIDER_VERIFY_TRUST        VerifyTrust;
    LPWINTRUST_PROVIDER_SUBMIT_CERTIFICATE  SubmitCertificate;
    
} WINTRUST_PROVIDER_CLIENT_SERVICES, *LPWINTRUST_PROVIDER_CLIENT_SERVICES;

typedef struct _WINTRUST_PROVIDER_CLIENT_INFO {
    DWORD                                   dwRevision;
    LPWINTRUST_PROVIDER_CLIENT_SERVICES     lpServices;
    DWORD                                   dwActionIdCount;
    GUID *                                  lpActionIdArray;
} WINTRUST_PROVIDER_CLIENT_INFO, *LPWINTRUST_PROVIDER_CLIENT_INFO;

typedef struct _LOADED_PROVIDER_V1 {

    struct _LOADED_PROVIDER_V1      *Next;
    struct _LOADED_PROVIDER_V1      *Prev;
    HANDLE                          ModuleHandle;
    LPTSTR                          ModuleName;
    LPTSTR                          SubKeyName;
    LPWINTRUST_PROVIDER_CLIENT_INFO ClientInfo;
    DWORD                           RefCount;
    DWORD                           ProviderInitialized;                            

} LOADED_PROVIDER_V1, *PLOADED_PROVIDER_V1;


#define PROVIDER_INITIALIZATION_SUCCESS        (1)
#define PROVIDER_INITIALIZATION_IN_PROGRESS    (2) 
#define PROVIDER_INITIALIZATION_FAILED         (3)

PLOADED_PROVIDER_V1 WinTrustFindActionID(IN GUID * dwActionID);
PLOADED_PROVIDER_V1 Version1_RegLoadProvider(HKEY hKey, LPTSTR KeyName, GUID *ActionID);
PLOADED_PROVIDER_V1 Version1_LoadProvider(GUID *pgActionID);
PLOADED_PROVIDER_V1 Version1_TestProviderForAction(HKEY hKey, LPTSTR KeyName, GUID * ActionID);
void Version1_UnloadProvider(PLOADED_PROVIDER_V1 Provider);

LONG Version1_WinVerifyTrust(HWND hwnd, GUID *ActionID, LPVOID ActionData)

{
    PLOADED_PROVIDER_V1 Provider;
    HRESULT rc;


    if (!(Provider = Version1_LoadProvider(ActionID)))
    {
        return( TRUST_E_PROVIDER_UNKNOWN );
    }

    rc = (*Provider->ClientInfo->lpServices->VerifyTrust)( hwnd,                             
                                                           ActionID,                         
                                                           ActionData                        
                                                           );

    Version1_UnloadProvider(Provider);

    return( rc );
}


PLOADED_PROVIDER_V1 Version1_LoadProvider(GUID *pgActionID)
{
    HKEY    hKey;             // Handle to the base of the provider information.
    HKEY    hSubKey;          // Handle to the provider currently being examined.
    LONG    Result;           // Returned by registry API.
    DWORD   cSubKeys;         // Number of providers under the root key.
    DWORD   cbMaxSubKeyLen;   // Maximum provider name length.
    ULONG   i;              // Indicies for iterating through providers and action IDs.
    LPTSTR  SubKeyName;       // Points to the name of the current provider.
    GUID *  ActionIds;
    PLOADED_PROVIDER_V1 FoundProvider = NULL;

    //
    // Open the registry and get a list of installed trust providers
    //

    Result = RegOpenKeyEx(
                 REGISTRY_ROOT,
                 REGISTRY_TRUSTPROVIDERS,
                 0L,
                 GENERIC_READ,
                 &hKey
                 );

    if (Result != ERROR_SUCCESS) {
        return( NULL );
    }

    //
    // Find out how many subkeys there are.
    //

    Result = RegQueryInfoKey (  hKey,               // handle of key to query
                                NULL,               // address of buffer for class string
                                NULL,               // address of size of class string buffer
                                NULL,               // reserved
                                &cSubKeys,          // address of buffer for number of subkeys
                                &cbMaxSubKeyLen,    // address of buffer for longest subkey name length
                                NULL,               // address of buffer for longest class string length
                                NULL,               // address of buffer for number of value entries
                                NULL,               // address of buffer for longest value name length
                                NULL,               // address of buffer for longest value data length
                                NULL,               // address of buffer for security descriptor length
                                NULL                // address of buffer for last write time
                                );

    if (ERROR_SUCCESS != Result) {
        RegCloseKey( hKey );
        return( NULL );
    }

    //
    // Iterate through the subkeys, looking for ones with hint information.
    //

    cbMaxSubKeyLen += sizeof( WCHAR );

    SubKeyName = new char[cbMaxSubKeyLen + 1];

    if (NULL == SubKeyName) {
        RegCloseKey( hKey );
        return(NULL);
    }

    for (i=0; i<cSubKeys; i++) {

        DWORD KeyNameLength;

        KeyNameLength = cbMaxSubKeyLen;

        Result = RegEnumKeyEx( hKey,               // handle of key to enumerate
                               i,                  // index of subkey to enumerate
                               SubKeyName,         // address of buffer for subkey name
                               &KeyNameLength,     // address for size of subkey buffer
                               NULL,               // reserved
                               NULL,               // address of buffer for class string
                               NULL,               // address for size of class buffer
                               NULL                // address for time key last written to
                               );

        //
        // Not much to do if this fails, try enumerating the rest of them and see
        // what happens.
        //

        if (Result != ERROR_SUCCESS) {
            continue;
        }

        Result = RegOpenKeyEx(
                     hKey,
                     SubKeyName,
                     0L,
                     GENERIC_READ | MAXIMUM_ALLOWED,
                     &hSubKey
                     );

        if (ERROR_SUCCESS != Result) 
        {
            continue;
        }

        FoundProvider = Version1_TestProviderForAction( hSubKey, SubKeyName, pgActionID );

        RegCloseKey( hSubKey );

        if (NULL != FoundProvider) 
        {
            
            //
            // Got one.  Clean up and return.
            //

            delete SubKeyName;
            RegCloseKey( hKey );
            return( FoundProvider );
        }

        continue;
    }

    delete SubKeyName;
    RegCloseKey( hKey );
    return( NULL );
}

WINTRUST_CLIENT_TP_INFO WinTrustClientTPInfo = {
                            WIN_TRUST_REVISION_1_0,
                            NULL
                            };

PLOADED_PROVIDER_V1 Version1_TestProviderForAction(HKEY hKey, LPTSTR KeyName, GUID * ActionID)
{
    PLOADED_PROVIDER_V1 Provider;
    LPWINTRUST_PROVIDER_CLIENT_INFO ClientInfo;
    GUID * ActionIds;
    DWORD i;

    Provider = Version1_RegLoadProvider( hKey, KeyName, ActionID);

    if (NULL == Provider) {
        return( NULL );
    }

    ClientInfo = Provider->ClientInfo;

    ActionIds = ClientInfo->lpActionIdArray;

    for (i=0; i<ClientInfo->dwActionIdCount; i++) {

        if (IsEqualActionID(ActionID, &ActionIds[i])) {
            return( Provider );
        }
    }

    return(NULL);
}

PLOADED_PROVIDER_V1 Version1_RegLoadProvider(HKEY hKey, LPTSTR KeyName, GUID *ActionID)
{
    LPTSTR ModuleName                           = NULL;
    HINSTANCE LibraryHandle                     = NULL;
    LPWINTRUST_PROVIDER_CLIENT_INFO ClientInfo  = NULL;
    PLOADED_PROVIDER_V1 Provider                   = NULL;
    PLOADED_PROVIDER_V1 FoundProvider              = NULL;
    LPWSTR ProviderName                         = NULL;
    LPTSTR SubKeyName                           = NULL;

    GUID    gBuffer[10];       // Assume no more than 10 action ids in a provider
    DWORD Type;
    DWORD cbData = 0;
    LONG Result;
    LPWINTRUST_PROVIDER_CLIENT_INITIALIZE ProcAddr;
    BOOL Referenced = FALSE;
    DWORD size;
    BOOL Inited;


    //
    //  get the guids
    //
    cbData = sizeof(GUID) * 10;
    Result = RegQueryValueEx(   hKey,    // handle of key to query
                                TEXT("$ActionIDs"),
                                NULL,       // reserved
                                &Type, // address of buffer for value type
                                (BYTE *)&gBuffer[0],
                                &cbData     // address of data buffer size
                                );

    if (Result != ERROR_SUCCESS)
    {
        return(NULL);
    }

    //
    //  check the guids
    //
    Inited = FALSE;
    for (int j = 0; j < (int)(cbData / sizeof(GUID)); j++) 
    {
        if (memcmp(&gBuffer[j], ActionID, sizeof(GUID)) == 0)
        {
            Inited = TRUE;
            break;
        }
    }

    if (!(Inited))
    {
        return(NULL);
    }


    //
    // Extract the dll name from the $DLL value
    //

    Result = RegQueryValueEx( hKey,           // handle of key to query
                              TEXT("$DLL"),   // address of name of value to query
                              NULL,           // reserved
                              &Type,          // address of buffer for value type
                              NULL,           // address of data buffer
                              &cbData         // address of data buffer size
                              );

//    if (ERROR_MORE_DATA != Result) {
//        goto error_cleanup;
//    }

    if (ERROR_SUCCESS != Result) {
        goto error_cleanup;
    }

    cbData += sizeof( TCHAR );

    ModuleName = new char[cbData];

    if (NULL == ModuleName) {
        goto error_cleanup;
    }

    ModuleName[cbData - 1] = TEXT('\0');

    Result = RegQueryValueEx( hKey,           // handle of key to query
                              TEXT("$DLL"),   // address of name of value to query
                              NULL,           // reserved
                              &Type,          // address of buffer for value type
                              (LPBYTE)ModuleName,   // address of data buffer
                              &cbData         // address of data buffer size
                              );

    if (ERROR_SUCCESS != Result) {
        goto error_cleanup;
    }

    //
    // Expand environment strings if necessary
    //

    if (Type == REG_EXPAND_SZ) {

        DWORD ExpandedLength = 0;
        LPTSTR ExpandedModuleName = NULL;

        ExpandedLength = ExpandEnvironmentStrings( ModuleName, NULL, 0 );

        if (0 == ExpandedLength) {
            goto error_cleanup;
        }

        ExpandedModuleName = new char[ExpandedLength];

        if (NULL == ExpandedModuleName) {
            goto error_cleanup;
        }

        ExpandedLength = ExpandEnvironmentStrings( ModuleName, ExpandedModuleName, ExpandedLength );

        if (0 == ExpandedLength) {
            delete ExpandedModuleName;
            goto error_cleanup;
        }

        //
        // Free the old module name, use the new one
        //

        delete ModuleName;

        ModuleName = ExpandedModuleName;
    }

    size = (lstrlen( KeyName ) + 1) * sizeof( WCHAR );

    ProviderName = new WCHAR[size / sizeof(WCHAR)];

    if (NULL == ProviderName) {
        goto error_cleanup;
    }


#ifdef UNICODE

    //
    // If we've been compiled as unicode, the KeyName we got from
    // the registry consists of WCHARs, so we can just copy it into
    // the Name buffer.
    //

    lstrcpy( ProviderName, KeyName );

#else

    //
    // If we've been compiled as ANSI, then KeyName is an ANSI string,
    // and we need to convert it to WCHARs.
    //

    MultiByteToWideChar ( CP_ACP, 0, KeyName, -1, ProviderName, size );

#endif // !UNICODE

    //
    // ModuleName now contains the module name, attempt to load it
    // and ask it to initialize itself.
    //

    LibraryHandle = LoadLibrary( (LPTSTR)ModuleName );

    if (NULL == LibraryHandle) {
        DWORD Error;

        Error = GetLastError();

        goto error_cleanup;
    }

    ProcAddr = (LPWINTRUST_PROVIDER_CLIENT_INITIALIZE) GetProcAddress( LibraryHandle, (LPCSTR)"WinTrustProviderClientInitialize");

    if (NULL == ProcAddr) {
        goto error_cleanup;
    }

    SubKeyName = new char[(lstrlen(KeyName) + 1) * sizeof(TCHAR)];

    if (NULL == SubKeyName) {
        goto error_cleanup;
    }

    lstrcpy( SubKeyName, KeyName );

    Provider = new LOADED_PROVIDER_V1;

    if (NULL == Provider) {
        delete SubKeyName;
        goto error_cleanup;
    }

    //
    // Ready to call init routine.
    //

    Provider->RefCount = 1;
    Provider->ProviderInitialized = PROVIDER_INITIALIZATION_IN_PROGRESS;

    //
    // Set the subkey name so anyone else looking for this provider will
    // find this one and wait.
    //
    // Note that we don't want to use the ProviderName as will be passed into
    // the init routine here, because we've forced that to WCHARs regardless
    // of whether we're ANSI or Unicode, and we want this string to reflect
    // the base system for efficiency.
    //

    Provider->SubKeyName = SubKeyName;

    Provider->Next = NULL;
    Provider->Prev = NULL;

    Inited = (*ProcAddr)( WIN_TRUST_REVISION_1_0, &WinTrustClientTPInfo, ProviderName, (void **)&ClientInfo );

    if (TRUE != Inited) {

        Provider->ProviderInitialized = PROVIDER_INITIALIZATION_FAILED;

        //
        // We could release the lock now, because we're either going to
        // do nothing to this provider, or we've removed it from
        // the list and no one else can get to it.
        //

        goto error_cleanup;
    }

    //
    // Since we have a write lock, it doesn't matter what order we
    // do this in, since there are no readers.  Just be sure to signal
    // the event under the write lock.
    //

    Provider->ProviderInitialized = PROVIDER_INITIALIZATION_SUCCESS;
    Provider->ModuleHandle = LibraryHandle;
    Provider->ModuleName = ModuleName;
    Provider->ClientInfo = ClientInfo;

    return( Provider );

error_cleanup:

    if (NULL != LibraryHandle) {
        FreeLibrary( LibraryHandle );
    }

    if (NULL != ModuleName) {
        delete ModuleName;
    }

    if (NULL != ProviderName) {
        delete ProviderName;
    }

    if (NULL != Provider)
    {
        delete Provider;
    }

    return( NULL );
}

void Version1_UnloadProvider(PLOADED_PROVIDER_V1 Provider)
{
    if (Provider)
    {
        if (Provider->ModuleHandle)
        {
            FreeLibrary((HINSTANCE)Provider->ModuleHandle);
        }
        if (Provider->ModuleName)
        {
            delete Provider->ModuleName;
        }
    }
    
    delete Provider;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\certs\mstest1.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       mstest1.h
//
//--------------------------------------------------------------------------

0x30,0x47,0x02,0x40,0x81,0x55,0x22,0xB9,0x8A,0xA4,0x6F,0xED,0xD6,0xE7,0xD9,0x66,
0x0F,0x55,0xBC,0xD7,0xCD,0xD5,0xBC,0x4E,0x40,0x02,0x21,0xA2,0xB1,0xF7,0x87,0x30,
0x85,0x5E,0xD2,0xF2,0x44,0xB9,0xDC,0x9B,0x75,0xB6,0xFB,0x46,0x5F,0x42,0xB6,0x9D,
0x23,0x36,0x0B,0xDE,0x54,0x0F,0xCD,0xBD,0x1F,0x99,0x2A,0x10,0x58,0x11,0xCB,0x40,
0xCB,0xB5,0xA7,0x41,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\common\crt.cpp ===
// Only build for retail

#if !DBG

////////////////////////////////////////////////////////////////////////
//
// Functions that reduce our dependence on the C runtime
//
////////////////////////////////////////////////////////////////////////
//

extern "C" int __cdecl _purecall(void) 
    {
    return 0;
    }

#endif  // !DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\certs\mstest2.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       mstest2.h
//
//--------------------------------------------------------------------------

0x30,0x48,0x02,0x41,0x00,0x81,0x55,0x22,0xB9,0x8A,0xA4,0x6F,0xED,0xD6,0xE7,0xD9,0x66,
0x0F,0x55,0xBC,0xD7,0xCD,0xD5,0xBC,0x4E,0x40,0x02,0x21,0xA2,0xB1,0xF7,0x87,0x30,
0x85,0x5E,0xD2,0xF2,0x44,0xB9,0xDC,0x9B,0x75,0xB6,0xFB,0x46,0x5F,0x42,0xB6,0x9D,
0x23,0x36,0x0B,0xDE,0x54,0x0F,0xCD,0xBD,0x1F,0x99,0x2A,0x10,0x58,0x11,0xCB,0x40,
0xCB,0xB5,0xA7,0x41,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\common\filemisc.c ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    filemisc.c

Abstract:

    This module contains routines to perform miscellaneous file related
    operations in the protected store.

Author:

    Scott Field (sfield)    27-Nov-96

--*/

#include <windows.h>

#include <sha.h>
#include "filemisc.h"
#include "unicode5.h"
#include "debug.h"

BOOL
GetFileNameFromPath(
    IN      LPCWSTR FullPath,
    IN  OUT LPCWSTR *FileName   // points to filename component in FullPath
    )
{
    DWORD cch = lstrlenW(FullPath);

    *FileName = FullPath;

    while( cch ) {

        if( FullPath[cch] == L'\\' ||
            FullPath[cch] == L'/' ||
            (cch == 1 && FullPath[1] == L':') ) {

            *FileName = &FullPath[cch+1];
            break;
        }

        cch--;
    }

    return TRUE;
}

BOOL
GetFileNameFromPathA(
    IN      LPCSTR FullPath,
    IN  OUT LPCSTR *FileName    // points to filename component in FullPath
    )
{
    DWORD cch = lstrlenA(FullPath);

    *FileName = FullPath;

    while( cch ) {

        if( FullPath[cch] == '\\' ||
            FullPath[cch] == '/' ||
            (cch == 1 && FullPath[1] == ':') ) {

            *FileName = &FullPath[cch+1];
            break;
        }

        cch--;
    }

    return TRUE;
}

BOOL
TranslateFromSlash(
    IN      LPWSTR szInput,
    IN  OUT LPWSTR *pszOutput   // optional
    )
{
    return TranslateString(szInput, pszOutput, L'\\', L'*');
}

BOOL
TranslateToSlash(
    IN      LPWSTR szInput,
    IN  OUT LPWSTR *pszOutput   // optional
    )
{
    return TranslateString(szInput, pszOutput, L'*', L'\\');
}

BOOL
TranslateString(
    IN      LPWSTR szInput,
    IN  OUT LPWSTR *pszOutput,  // optional
    IN      WCHAR From,
    IN      WCHAR To
    )
{
    LPWSTR szOut;
    DWORD cch = lstrlenW(szInput);
    DWORD i; // scan forward for cache - locality of reference

    if(pszOutput == NULL) {

        //
        // translate in place in existing string.
        //

        szOut = szInput;

    } else {
        DWORD cb = (cch+1) * sizeof(WCHAR);

        //
        // allocate new string and translate there.
        //

        szOut = (LPWSTR)SSAlloc( cb );
        *pszOutput = szOut;

        if(szOut == NULL)
            return FALSE;


        CopyMemory((LPBYTE)szOut, (LPBYTE)szInput, cb);
    }


    for(i = 0 ; i < cch ; i++) {
        if( szOut[ i ] == From )
            szOut[ i ] = To;
    }

    return TRUE;
}

BOOL
FindAndOpenFile(
    IN      LPCWSTR szFileName,     // file to search for + open
    IN      LPWSTR  pszFullPath,    // file to fill fullpath with
    IN      DWORD   cchFullPath,    // size of full path buffer, including NULL
    IN  OUT PHANDLE phFile          // resultant open file handle
    )
/*++

    This function searches the path for the specified file and if a file
    is found, the file is opened for read access and a handle to the open
    file is returned to the caller in the phFile parameter.

--*/
{
    LPWSTR szPart;

    *phFile = INVALID_HANDLE_VALUE;

    //
    // locate the specified file on the path.
    //

    if(FIsWinNT()) {

        //
        // WinNT: use SearchPathW
        //

        if(SearchPathW(
                NULL,
                szFileName,
                NULL,
                cchFullPath,
                pszFullPath,
                &szPart
                ) == 0) {

            return FALSE;
        }
    } else {

        //
        // Win95: convert to ANSI, use SearchPathA, convert back to Unicode
        // (yuck, but that's the price of not implementing Unicode!)
        //

        CHAR szFileNameA[MAX_PATH+1];
        DWORD cchFileName = lstrlenW(szFileName);
        CHAR szFilePathA[MAX_PATH+1];
        DWORD cchFilePathA;
        LPSTR szPartA;

        if(cchFileName > MAX_PATH)
            return FALSE;

        if(WideCharToMultiByte(
                CP_ACP,
                0,
                szFileName,
                cchFileName + 1, // include NULL
                szFileNameA,
                MAX_PATH + 1,
                NULL,
                NULL
                ) == 0) {

            return FALSE;
        }

        cchFilePathA = SearchPathA(
                NULL,
                szFileNameA,
                NULL,
                MAX_PATH,
                szFilePathA,
                &szPartA
                );

        if(cchFilePathA == 0)
            return FALSE;

        if(MultiByteToWideChar(
                CP_ACP,
                0,
                szFilePathA,
                cchFilePathA + 1, // include NULL
                pszFullPath,
                cchFullPath
                ) == 0) {
            return FALSE;
        }
    }


    *phFile = CreateFileU(
            pszFullPath,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );

    if(*phFile == INVALID_HANDLE_VALUE)
        return FALSE;

    return TRUE;
}

#if 0
BOOL
HashEntireDiskImage(
    IN  HANDLE hFile,       // handle of file to hash
    IN  LPBYTE FileHash     // on success, buffer contains file hash
    )
/*++

    This function hashes the file associated with the file specified by the
    hFile parameter.  If the function succeeds, the return value is TRUE,
    and the buffer specified by the FileHash parameter is filled with the
    hash of the file.

    The hashing performed by this function begins at start of the file
    associated with the hFile parameter, and continues until EOF or an error
    occurs.  The caller should make no assumptions about the file position
    upon return of this call.  For that reason, the caller should preserve
    and restore file position associated with hFile parameter if necessary.

    The current file position is set relative the beginning of file by this
    function.  This allows a caller to hash the entire contents of an file
    without worrying about the file position.

    This function should not be called from outside this module, unless
    absolutely necessary, because no caching or other performance improvements
    take place.

    The buffer specified by the FileHash parameter should be
    A_SHA_DIGEST_LEN length (20).

--*/
{
    if(SetFilePointer( hFile, 0, NULL, FILE_BEGIN ) == 0xFFFFFFFF)
        return FALSE;

    return HashDiskImage( hFile, FileHash );
}
#endif

#if 0
BOOL
HashDiskImage(
    IN  HANDLE hFile,   // handle of file to hash
    IN  LPBYTE FileHash // on success, buffer contains file hash
    )
/*++

    This function hashes the file associated with the file specified by the
    hFile parameter.  If the function succeeds, the return value is TRUE,
    and the buffer specified by the FileHash parameter is filled with the
    hash of the file.

    The hashing performed by this function begins at the current file position
    associated with the hFile parameter, and continues until EOF or and error
    occurs.  The caller should make no assumptions about the file position
    upon return of this call.  For that reason, the caller should preserve
    and restore file position associated with hFile parameter if necessary.

    This function should not be called from outside this module, unless
    absolutely necessary, because no caching or other performance improvements
    take place.

    The buffer specified by the FileHash parameter should be
    A_SHA_DIGEST_LEN length (20).

--*/
{
    #define DISK_BUF_SIZE 4096

    BYTE DiskBuffer[DISK_BUF_SIZE];
    A_SHA_CTX context;
    DWORD dwBytesToRead;
    DWORD dwBytesRead;
    BOOL bSuccess = FALSE;

    A_SHAInit(&context);

    dwBytesToRead = DISK_BUF_SIZE;

    do {
        bSuccess = ReadFile(hFile, DiskBuffer, dwBytesToRead, &dwBytesRead, NULL);
        if(!bSuccess) break;

        A_SHAUpdate(&context, DiskBuffer, dwBytesRead);
    } while (dwBytesRead);

    A_SHAFinal(&context, FileHash);

    return bSuccess;
}
#endif

#if 0
HINSTANCE
LoadAndOpenResourceDll(
    IN      LPCWSTR szFileName,     // file name to load + open
    IN  OUT LPWSTR  pszFullPath,    // buffer to fill file fullpath with
    IN      DWORD   cchFullPath,    // size of full path buffer (chars), including NULL
    IN  OUT PHANDLE phFile
    )
/*++

    This function attempts to load the resource component associated with
    protected storage.

    If the resource module is successfully loaded, the return value is
    the module handle associated with the resource module.  The return
    value is non-NULL is this case.

    If the function fails, the return value is NULL.

--*/
{

    if(!FindAndOpenFile(
            szFileName,
            pszFullPath,
            cchFullPath,
            phFile
            ))
        return NULL;

    //
    // note: LOAD_LIBRARY_AS_DATAFILE does not work with resources like
    // dialog boxes!!!
    // DONT_RESOLVE_DLL_REFERENCES does not work on Win95.
    // LoadLibraryEx has bugs in win95 with DLL_PROCESS_DETACH
    //

    if(FIsWinNT()) {
        return LoadLibraryExU(
                    pszFullPath,
                    NULL,
                    DONT_RESOLVE_DLL_REFERENCES
                    );

    } else {
        return LoadLibraryU( pszFullPath );
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\common\guidcnvt.c ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    guidcnvt.cpp

Abstract:

    Functionality in this module:

        Guid <-> String conversion

Author:

    Matt Thomlinson (mattt) 1-May-97

--*/

#include <windows.h>
#include <string.h>
#include "pstdef.h"

// crypto defs
#include <sha.h>
#include "unicode.h"
#include "unicode5.h"
#include "guidcnvt.h"

// guid -> string conversion
DWORD MyGuidToStringA(const GUID* pguid, CHAR rgsz[])
{
    DWORD dwRet = (DWORD)PST_E_FAIL;
    LPSTR szTmp = NULL;

    if (RPC_S_OK != (dwRet =
        UuidToStringA(
            (UUID*)pguid,
            (unsigned char**) &szTmp)) )
        goto Ret;

    if (lstrlenA((LPSTR)szTmp) >= MAX_GUID_SZ_CHARS)
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    lstrcpyA(rgsz, szTmp);
    dwRet = PST_E_OK;
Ret:
    if (szTmp)
        RpcStringFreeA((unsigned char**)&szTmp);

    return dwRet;
}

// string -> guid conversion
DWORD MyGuidFromStringA(LPSTR sz, GUID* pguid)
{
    DWORD dwRet = (DWORD)PST_E_FAIL;

    if (pguid == NULL)
        goto Ret;

    if (RPC_S_OK != (dwRet =
        UuidFromStringA(
            (unsigned char*)sz,
            (UUID*)pguid)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    return dwRet;
}


// guid -> string conversion
DWORD MyGuidToStringW(const GUID* pguid, WCHAR rgsz[])
{
    char rgch[MAX_GUID_SZ_CHARS];
    DWORD cch = sizeof(rgch);
    DWORD cchNeeded;
    LPWSTR szTmp;

    LONG    err;

    if(FIsWinNT()) {
        RPC_STATUS rpcStatus;
        LPWSTR wszStringUUID;
        DWORD cchStringUUID;

        rpcStatus = UuidToStringW((UUID*)pguid, &wszStringUUID);
        if(rpcStatus != RPC_S_OK)
            return rpcStatus;

        cchStringUUID = lstrlenW(wszStringUUID);
        CopyMemory(rgsz, wszStringUUID, (cchStringUUID + 1) * sizeof(WCHAR));
        RpcStringFreeW(&wszStringUUID);
        return rpcStatus;
    } else {

        err = MyGuidToStringA(
               pguid,
               rgch);

        if(err != PST_E_OK)
            return err;

        // how long is the unicode string?
        if (MAX_GUID_SZ_CHARS < MultiByteToWideChar(
                0,
                0,
                rgch,
                cch,
                NULL,
                0))
            goto ErrorReturn;

        if (MAX_GUID_SZ_CHARS < MultiByteToWideChar(
                    0,
                    0,
                    rgch,
                    cch,
                    rgsz,
                    (int) MAX_GUID_SZ_CHARS))
                goto ErrorReturn;

        return PST_E_OK;

    ErrorReturn:
        return PST_E_FAIL;

    }
}

// string -> guid conversion
DWORD MyGuidFromStringW(LPWSTR szW, GUID* pguid)
{
    BYTE rgb[MAX_GUID_SZ_CHARS];
    char *  szA;
    int i;

    DWORD dwErr;

    if(FIsWinNT()) {
        return UuidFromStringW(szW, pguid);
    } else {

        if(!MkMBStr(rgb, MAX_GUID_SZ_CHARS, szW, &szA))
            return PST_E_FAIL;

        for(i=0; i<MAX_GUID_SZ_CHARS; i++)
        {
            if (szA[i] == '.')
            {
                szA[i] = '\0';
                break;
            }
        }

        dwErr = MyGuidFromStringA(
            szA,
            pguid);

        FreeMBStr(rgb, szA);

        return dwErr;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkitrust\wintrust\certs\mstestb1.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       mstestb1.h
//
//--------------------------------------------------------------------------

0x30,0x47,0x02,0x40,0x9C,0x50,0x05,0x1D,0xE2,0x0E,0x4C,0x53,0xD8,0xD9,0xB5,0xE5,
0xFD,0xE9,0xE3,0xAD,0x83,0x4B,0x80,0x08,0xD9,0xDC,0xE8,0xE8,0x35,0xF8,0x11,0xF1,
0xE9,0x9B,0x03,0x7A,0x65,0x64,0x76,0x35,0xCE,0x38,0x2C,0xF2,0xB6,0x71,0x9E,0x06,
0xD9,0xBF,0xBB,0x31,0x69,0xA3,0xF6,0x30,0xA0,0x78,0x7B,0x18,0xDD,0x50,0x4D,0x79,
0x1E,0xEB,0x61,0xC1,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\common\listbase.cpp ===
#include <windows.h>

#include "listbase.h"
#include "debug.h"


CLinkedList::CLinkedList()
{
//    OutputDebugString(">> CLinkedList CONstructor called <<\n");

    m_fInitialized = FALSE;
    m_pHead = NULL;
    m_pfnIsMatch = NULL;
    m_pfnFreeElt = NULL;
}

CLinkedList::~CLinkedList()
{
//    OutputDebugString(">> CLinkedList DEstructor called <<\n");

    if(m_fInitialized)
    {
#if DBG
        EnterCriticalSection(&m_critsecListBusy);

        ELT* ple = m_pHead;
        while(ple)
        {
            OutputDebugStringW(L"Caught list leak!\n");
            ple = ple->pNext;
        }

        LeaveCriticalSection(&m_critsecListBusy);
#endif

        Reset();

        DeleteCriticalSection(&m_critsecListBusy);
    }
}

BOOL CLinkedList::Initialize()
{

    __try
    {
        if(!m_fInitialized)
        {
            InitializeCriticalSection(&m_critsecListBusy);
        }
        m_fInitialized = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    return m_fInitialized;
}

BOOL CLinkedList::Reset()
{
    //////////////////////
    // walk list, free
    ELT* ple;

    if(m_fInitialized)
    {
        EnterCriticalSection(&m_critsecListBusy);

        while (m_pHead)
        {
            ple = m_pHead;
            m_pHead = ple->pNext;

            m_pfnFreeElt(ple);
        }

        LeaveCriticalSection(&m_critsecListBusy);
    }
    return m_fInitialized;

}


BOOL CLinkedList::AddToList(ELT* pListItem)
{
    if(m_fInitialized)
    {
        EnterCriticalSection(&m_critsecListBusy);

        pListItem->pNext = m_pHead;                    // insert into linked list
        m_pHead = pListItem;

        LeaveCriticalSection(&m_critsecListBusy);
    }

    return m_fInitialized;
}

BOOL CLinkedList::DelFromList(ELT* pv)
{
    SS_ASSERT(pv != NULL);

    if(!m_fInitialized)
    {
        return FALSE;
    }

    EnterCriticalSection(&m_critsecListBusy);

    ELT* ple = m_pHead;
    ELT* plePrior = NULL;

    while (ple)
    {
        if (m_pfnIsMatch(ple, pv))
            break;

        plePrior = ple;
        ple = ple->pNext;
    }

    // if we didn't find a match, return
    if (NULL == ple)
    {
        LeaveCriticalSection(&m_critsecListBusy);
        return FALSE;
    }

    // else remove from list
    if (NULL == plePrior)
        m_pHead = ple->pNext;
    else
        plePrior->pNext = ple->pNext;

    LeaveCriticalSection(&m_critsecListBusy);

    // delete extracted item
    m_pfnFreeElt(ple);

    return TRUE;
}

ELT* CLinkedList::SearchList(ELT* pv)
{
    SS_ASSERT(pv != NULL);
    if(!m_fInitialized)
    {
        return NULL;
    }

    ELT* ple;

    EnterCriticalSection(&m_critsecListBusy);

    ple = m_pHead;

    while (ple)
    {
        if (m_pfnIsMatch(ple, pv))
        {
            LeaveCriticalSection(&m_critsecListBusy);
            return ple;
        }

        ple = ple->pNext;
    }

    LeaveCriticalSection(&m_critsecListBusy);

    return NULL;
}

BOOL CLinkedList::LockList()
{
    if(m_fInitialized)
    {
        EnterCriticalSection(&m_critsecListBusy);
    }
    return m_fInitialized;
}

BOOL CLinkedList::UnlockList()
{
    if(m_fInitialized)
    {
        LeaveCriticalSection(&m_critsecListBusy);
    }
    return m_fInitialized;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\common\debug.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* Snipped from SChannel sources
*
* 1/23/96
*----------------------------------------------------------------------------*/



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <debug.h>

DWORD   g_dwEventLogging=0;
typedef LONG          HRESULT;  

#include "pstdef.h"




/*----------------------------------------------------------------------------*/
/* NOTE:  This file not compiled for retail builds                            */
/*----------------------------------------------------------------------------*/
#if DBG



#ifdef HEAPDUMP
#include <winbasep.h>
#endif

#define WINDEBUG

#ifndef min
#define min(x,y) ((x)<(y)?(x):(y))

#endif



DWORD   g_dwInfoLevel  = SS_LOG_WARNING | SS_LOG_ERROR;
DWORD   SSTraceIndent = 0;



#define MAX_DEBUG_BUFFER 2048


// This function simply outputs information to the debugging log file handle.

void
SSDebugOutput(char *szOutString)
{
    OutputDebugStringA(szOutString);
}



void
DbgDumpHexString(const unsigned char *String, DWORD cbString)
{
    unsigned int i;

    for (i = 0; i < cbString; i++)
    {
    int j;
    char *pch;
    char ach[9];

    pch = &ach[wsprintf(ach,  "%2.2x", String[i])];
    SS_ASSERT(pch - ach <= sizeof(ach) - 4);


    if ((i & 1) == 1)
    {
        *pch++ = ' ';
    }
    if ((i & 7) == 7)
    {
        *pch++ = ' ';
    }
    if ((i & 15) == 15)
    {
        *pch++ = '\n';
    }
    *pch = '\0';
    SSDebugOutput(ach);
    }
}


char *aszSSDebugLevel[] = 
{
    "Error  ",
    "Warning",
    "Trace  ",
    "Mem    ",
    "Result "
};


void
SSDebugLog(long Mask, const char *Format, ...)
{
    va_list ArgList;
    int     Level = 0;
    int     PrefixSize = 0;
    int     iOut;
    char    szOutString[MAX_DEBUG_BUFFER];
    long    OriginalMask = Mask;

    if (Mask & g_dwInfoLevel)
    {
        while (!(Mask & 1))
        {
            Level++;
            Mask >>= 1;
        }

        if (Level >= sizeof(aszSSDebugLevel) / sizeof(char *))
        {
            Level = sizeof(aszSSDebugLevel) / sizeof(char *) - 1;
        }
        // Make the prefix first:  "Process.Thread> GINA-XXX"

        iOut = wsprintf(
                szOutString,
                "%3d.%3d> %s: ",
                GetCurrentProcessId(),
                GetCurrentThreadId(),
                aszSSDebugLevel[Level]);

        PrefixSize = min(60, SSTraceIndent * 3);
        FillMemory(szOutString+iOut, PrefixSize, ' ');
        PrefixSize += iOut;
        szOutString[PrefixSize] = '\0';

        va_start(ArgList, Format);

        if (wvsprintf(&szOutString[PrefixSize], Format, ArgList) < 0)
        {
            static char szOverFlow[] = "\n<256 byte OVERFLOW!>\n";

            // Less than zero indicates that the string would not fit into the
            // buffer.  Output a special message indicating overflow.

            lstrcpy(
            &szOutString[sizeof(szOutString) - sizeof(szOverFlow)],
            szOverFlow);
        }
        va_end(ArgList);

        SSDebugOutput(szOutString);
    }
}

LPSTR SzErrorCase(long err)
{
    char *szName = "Unknown";

    switch(err)
    {
        case PST_E_OK: szName = "PST_OK"; break;
        case PST_E_FAIL: szName = "PST_FAIL"; break;
        case PST_E_PROV_DLL_NOT_FOUND: szName = "PST_PROV_DLL_NOT_FOUND"; break;
        case PST_E_INVALID_HANDLE: szName = "PST_INVALID_HANDLE"; break;
        case PST_E_TYPE_EXISTS: szName = "PST_TYPE_EXISTS"; break;
        case PST_E_TYPE_NO_EXISTS: szName = "PST_TYPE_NO_EXISTS"; break;
        case PST_E_INVALID_RULESET: szName = "PST_INVALID_RULESET"; break;
        case PST_E_NO_PERMISSIONS: szName = "PST_NO_PERMISSIONS"; break;
        case PST_E_STORAGE_ERROR: szName = "PST_STORAGE_ERROR"; break;
        case PST_E_CALLER_NOT_VERIFIED: szName = "PST_CALLER_NOT_VERIFIED"; break;
        case PST_E_WRONG_PASSWORD: szName = "PST_WRONG_PASSWORD"; break;
        case PST_E_DISK_IMAGE_MISMATCH: szName = "PST_DISK_IMAGE_MISMATCH"; break;
        case PST_E_MEMORY_IMAGE_MISMATCH: szName = "PST_MEMORY_IMAGE_MISMATCH"; break;
        case PST_E_UNKNOWN_EXCEPTION: szName = "PST_UNKNOWN_EXCEPTION"; break;
        case PST_E_NYI: szName = "PST_NYI"; break;
    }
    
    return szName;
}


long    
SSLogErrorCode(
    long err, 
    const char *szFile, 
    long lLine)
{
    LPSTR szName;
    szName = SzErrorCase(err);
     
    SSDebugLog(SS_LOG_RES, "Result: %s (0x%lx) - %s, Line %d\n", szName, err, szFile, lLine);

    return err;
}

#pragma warning(disable:4206)   /* Disable the empty translation unit */
                /* warning/error */

void
SSAssert(
    void * FailedAssertion,
    void * FileName,
    unsigned long LineNumber,
    char * Message)
{
    SSDebugLog(SS_LOG_ERROR, 
               "Assertion FAILED, %s, %s : %d\n", 
               FailedAssertion,
               FileName,
               LineNumber);

    DebugBreak();      
}


// NOTE: heap dumping reqs winbasep.h, generated by
// windows build. Therefore, heap dumping unsupported
// in this build.

// Get winbasep.h and define HEAPDUMP to dump heap.

int HeapFlags = 0x0;    // no trace
//int HeapFlags = 0x2;    // output window trace

VOID
DumpHeapState(char *pszMsg)
{

#ifdef HEAPDUMP

    DWORD dwWritten;
    char szOutString[256];

    if (HeapFlags & 2)
    {
        HANDLE BaseHeap = RtlProcessHeap();
        HEAP_SUMMARY HeapSum;

        wsprintf(szOutString, "%s: HeapSummary(%p): ", pszMsg, BaseHeap);
        HeapSum.cb = sizeof(HeapSum);

        if (!HeapSummary(BaseHeap, 0, &HeapSum))
        {
            wsprintf(
            &szOutString[lstrlen(szOutString)],
            "FAILED: %u\n",
            GetLastError());
        }
        else
        {
            wsprintf(
            &szOutString[lstrlen(szOutString)],
            "Allocated=%x  Committed=%x\n",
            HeapSum.cbAllocated,
            HeapSum.cbCommitted);
        }
        SSDebugOutput(szOutString);
    }

#endif // HEAPDUMP

}

VOID
CaptureStackBackTrace(
    EXCEPTION_POINTERS *pep,
    ULONG cSkip,
    ULONG cFrames,
    ULONG *aeip)
{
    FillMemory(aeip, cFrames * sizeof(aeip[0]), 0);

#if i386 == 1
    {
        ULONG ieip, *pebp;
        ULONG *pebpMax;
        ULONG *pebpMin;

        if (pep == NULL)
        {
            ieip = 0;
            cSkip++;                    // always skip current frame
            pebp = ((ULONG *) &pep) - 2;
        }
        else
        {
            ieip = 1;
            SS_ASSERT(cSkip == 0);
            aeip[0] = pep->ContextRecord->Eip;
            pebp = (ULONG *) pep->ContextRecord->Ebp;
        }

        pebpMin = (ULONG *) &pep - 3;   // start below current frame
        pebpMax = pebpMin + 16*1024/sizeof(ULONG);
        if (pebp >= pebpMin && pebp < pebpMax)
        {
    //          __try
            {
            for ( ; ieip < cSkip + cFrames; ieip++)
            {
                ULONG *pebpNext;

                if (ieip >= cSkip)
                {
                aeip[ieip - cSkip] = *(pebp + 1);  // save an eip
                }

                pebpNext = (ULONG *) *pebp;
                if (pebpNext < pebp + 2 || pebpNext >= pebpMax - 1)
                {
                break;
                }
                pebp = pebpNext;
            }
            }
    //          __except(EXCEPTION_EXECUTE_HANDLER)
            {
            }
        }
    }
#endif // i386 == 1
}


////////////////////////////////////////////////////////
// debug mem routines


#define CMEMMAX 500
#define CEIP    6

int cMemAlloc;
int cMemAlloc2;
ULONG cbMemTotal;
ULONG cbMemTotal2;

typedef struct _MEM {
    VOID *pv;
    ULONG cb;
    ULONG aeip[CEIP];
} MEM;

MEM amem[CMEMMAX];


VOID *
SSAlloc(DWORD cb)
{
    VOID *pv;

    int i;
    char szOutString[256];
    int iRecorded = -1;
    MEM mem;

    DumpHeapState("Before Alloc");

    if (HeapFlags & 2)
    {
        CaptureStackBackTrace(NULL, 1, CEIP, mem.aeip);
        wsprintf(szOutString, "AllocMem(%x bytes): ", cb);
        cMemAlloc2++;
        cbMemTotal2 += cb;
        mem.cb = cb;
    }

    pv = LocalAlloc(LMEM_FIXED, cb);

    if (HeapFlags & 2)
    {
        mem.pv = pv;
        if (pv != NULL)
        {
            for (i = 0; i < CMEMMAX; i++)
            {
                if (amem[i].pv == pv)
                {
                    char szOutString2[256];

                    wsprintf(
                    szOutString2,
                    "FreeDup(%p) (%x bytes) from %x %x %x %x %x %x (%d)\n",
                    pv,
                    amem[i].cb,
                    amem[i].aeip[0],
                    amem[i].aeip[1],
                    amem[i].aeip[2],
                    amem[i].aeip[3],
                    amem[i].aeip[4],
                    amem[i].aeip[5],
                    i);
                    SSDebugOutput(szOutString2);
                    cMemAlloc--;
                    cbMemTotal -= amem[i].cb;
                    amem[i].pv = NULL;
                }

                if (amem[i].pv == NULL && iRecorded == -1)
                {
                    amem[i] = mem;
                    cMemAlloc++;
                    cbMemTotal += cb;
                    iRecorded = i;
                }
            }
        }
        else
        {
            lstrcat(szOutString, "FAILED: ");
        }

        wsprintf(
            &szOutString[lstrlen(szOutString)],
            "0x%p from %x %x %x %x %x %x (%d)\n",
            mem.pv,
            mem.aeip[0],
            mem.aeip[1],
            mem.aeip[2],
            mem.aeip[3],
            mem.aeip[4],
            mem.aeip[5],
            iRecorded);

        SSDebugOutput(szOutString);
    }
    DumpHeapState("After Alloc");

    return(pv);
}


VOID *
SSReAlloc(VOID *pv, DWORD cb)
{
    void* pBefore = pv;
    
    pv = LocalReAlloc(pv, cb, LMEM_MOVEABLE);    // allow realloc to move this memory

    if (pv == NULL)
    {
        CHAR sz[50];
        wsprintf(sz, "ReAlloc Failed! error %d\n", GetLastError());
        SSDebugOutput(sz);
    }
    else
    {
        if (pv != pBefore)
            SSDebugOutput("Performance: ReAlloc forced to move memory!\n");
    }

    return pv;
}


VOID
SSFree(VOID *pv)
{
    int i;
    char szOutString[256];

    DumpHeapState("Before Free");
    if (HeapFlags & 2)
    {
        cMemAlloc2--;
        wsprintf(szOutString, "FreeMem(%p)", pv);
        for (i = 0; i < CMEMMAX; i++)
        {
            if (pv == amem[i].pv)
            {
            cMemAlloc--;
            cbMemTotal -= amem[i].cb;
            amem[i].pv = NULL;
            wsprintf(
                &szOutString[lstrlen(szOutString)],
                " (%x bytes) from %x %x %x %x %x %x (%d)",
                amem[i].cb,
                amem[i].aeip[0],
                amem[i].aeip[1],
                amem[i].aeip[2],
                amem[i].aeip[3],
                amem[i].aeip[4],
                amem[i].aeip[5],
                i);
            break;
            }
        }
    }

    LocalFree(pv);

    if (HeapFlags & 2)
    {
        lstrcat(szOutString, "\n");
        SSDebugOutput(szOutString);
    }
    DumpHeapState("After Free");

}

SIZE_T
SSSize(HLOCAL hMem)
{
    return LocalSize( hMem );
}



#endif /* DBG */ 
/*----------------------------------------------------------------------------*/
/* NOTE:  This file not compiled for retail builds                            */
/*----------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\csecstor\crt.cpp ===
// Only build for retail

#if !DBG

////////////////////////////////////////////////////////////////////////
//
// Functions that reduce our dependence on the C runtime
//
////////////////////////////////////////////////////////////////////////
//

extern "C" int __cdecl _purecall(void) 
    {
    return 0;
    }

#endif  // !DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\common\primitiv.cpp ===
/*
    File:       primitiv.cpp

    Title:      Cryptographic Primitives for Protected Storage
    Author:     Matt Thomlinson
    Date:       11/22/96

    With the help of the rsa32 library, this module manufactures
    actually _usable_ primitives.

    Since CryptoAPI base provider may call us, we can't use
    CryptXXX primitives (circular dependencies may result).



    Functions in this module:

    FMyMakeDESKey
        Given key material, does necessary DES key setup. Has the
        side effect of stashing the keying material in the DESKey
        structure.

    FMyPrimitiveSHA
        Given pbData/cbData, runs SHA1 Init-Update-Final and returns
        the hash buffer.

    FMyPrimitiveDESEncrypt
        Given a ppbBlock/pcbBlock/DESKey structure, DES CBC (with an
        IV of 0)encrypts the block with the DESKey passed in. DESKey
        must be passed in with key setup already done. Note that this
        call might realloc ppbBlock since the encrypted length must be
        a multiple of the blocksize.

    FMyPrimitiveDESDecrypt
        Given a pbBlock/pcbBlock/DESKey structure, decrypts the
        block with the given (prepared) DESKey. Note that pbBlock
        will not be realloced, since the output buffer is always
        smaller than or the same size as the encrypted buffer.

    FMyPrimitiveDeriveKey
        Derives a DES key from multiple input buffers in
        the following manner:

        FMyMakeDESKey( SHA1(Salt | OtherData) )

    FMyOldPrimitiveHMAC (non-interoperable, buggy version of HMAC)
    FMyPrimitiveHMAC
        Derives a quality HMAC (Keyed message-authentication code) for
        passed-in data and prepared DESKey. The HMAC is computed in
        the following (standard HMAC) manner:

        KoPad = KiPad = DESKey key setup buffer
        XOR(KoPad, 0x5c5c5c5c)
        XOR(KiPad, 0x36363636)
        HMAC = SHA1(KoPad | SHA1(KiPad | Data))


*/

#include <windows.h>

// crypto defs
#include <wincrypt.h>

#include "sha.h"
#include "des.h"
#include "modes.h"
#include "randlib.h"

// others
#include "primitiv.h"
#include "debug.h"


#define OLD_MAC_K_PADSIZE           16
#define HMAC_K_PADSIZE              64


BOOL FMyMakeDESKey(
        PDESKEY pDESKey,
        BYTE*   pbKeyMaterial)
{
    CopyMemory(pDESKey->rgbKey, pbKeyMaterial, DES_BLOCKLEN);

    // assumes pbKeyMaterial is at least DES_BLOCKLEN bytes
    deskey(&pDESKey->sKeyTable, pbKeyMaterial);    // takes material, runs DES table setup
    return TRUE;
}


BOOL    FMyPrimitiveSHA(
            PBYTE       pbData,
            DWORD       cbData,
            BYTE        rgbHash[A_SHA_DIGEST_LEN])
{
    A_SHA_CTX   sSHAHash;


    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (BYTE *) pbData, cbData);
    A_SHAFinal(&sSHAHash, rgbHash);

    return TRUE;
}

BOOL FMyPrimitiveDESDecrypt(
            PBYTE       pbBlock,        // in out
            DWORD       *pcbBlock,      // in out
            DESKEY      sDESKey)        // in
{
    BOOL fRet = FALSE;

    DWORD dwDataLen = *pcbBlock;
    DWORD i;

    if (dwDataLen % DES_BLOCKLEN)
    {
        SetLastError((DWORD) NTE_BAD_DATA);
        return FALSE;
    }

    BYTE rgbBuf[DES_BLOCKLEN];

    BYTE rgbFeedBack[DES_BLOCKLEN];
    ZeroMemory(rgbFeedBack, DES_BLOCKLEN);

    // pump the data through the decryption, including padding
    // NOTE: the total length is a multiple of BlockLen

    for (DWORD BytePos = 0; (BytePos + DES_BLOCKLEN) <= dwDataLen; BytePos += DES_BLOCKLEN)
    {
        // put the encrypted text into a temp buffer
        CopyMemory(rgbBuf, pbBlock + BytePos, DES_BLOCKLEN);

        CBC(des, DES_BLOCKLEN, pbBlock + BytePos, rgbBuf, &sDESKey.sKeyTable,
            DECRYPT, rgbFeedBack);
    }

    // ## NOTE: if the pad is wrong, the user's buffer is hosed, because
    // ## we've decrypted into the user's buffer -- can we re-encrypt it?

    //
    // if dwPadVal is wrong, we've failed to decrypt correctly. Bad key?
    //

    DWORD dwPadVal = (DWORD) *(pbBlock + dwDataLen - 1);
    if (dwPadVal == 0 || dwPadVal > DES_BLOCKLEN)
    {
        SetLastError((DWORD) NTE_BAD_DATA);
        goto Ret;
    }

    // Make sure all the (rest of the) pad bytes are correct.
    for (i=1; i<dwPadVal; i++)
    {
        if ((pbBlock)[dwDataLen - (i + 1)] != dwPadVal)
        {
            SetLastError((DWORD) NTE_BAD_DATA);
            goto Ret;
        }
    }

    // update the length
    *pcbBlock -= dwPadVal;

    fRet = TRUE;
Ret:
    return fRet;
}

BOOL FMyPrimitiveDESEncrypt(
            PBYTE*      ppbBlock,       // in out
            DWORD       *pcbBlock,      // in out
            DESKEY      sDESKey)        // in
{
    BOOL fRet = FALSE;
    DWORD dwDataLen = *pcbBlock;

    DWORD cbPartial = (*pcbBlock % DES_BLOCKLEN);

    DWORD dwPadVal = DES_BLOCKLEN - cbPartial;
    if (dwPadVal != 0)
    {
        *pcbBlock += dwPadVal;

        *ppbBlock = (PBYTE)SSReAlloc(*ppbBlock, *pcbBlock);
    }

    // now we're a multiple of DES_BLOCKLEN
    SS_ASSERT((*pcbBlock % DES_BLOCKLEN) == 0);

    if (dwPadVal)
    {
        // Fill the pad with a value equal to the
        // length of the padding, so decrypt will
        // know the length of the original data
        // and as a simple integrity check.

        FillMemory(*ppbBlock + dwDataLen, (int)dwPadVal, (size_t)dwPadVal);
    }

    // allocate memory for a temporary buffer
    BYTE rgbBuf[DES_BLOCKLEN];

    BYTE rgbFeedBack[DES_BLOCKLEN];
    ZeroMemory(rgbFeedBack, DES_BLOCKLEN);

    PBYTE pbData = *ppbBlock;

    // pump the full blocks of data through
    for (dwDataLen = *pcbBlock; dwDataLen>0; dwDataLen-=DES_BLOCKLEN, pbData+=DES_BLOCKLEN)
    {
        SS_ASSERT(dwDataLen >= DES_BLOCKLEN);

        // put the plaintext into a temporary
        // buffer, then encrypt the data
        // back into the caller's buffer

        CopyMemory(rgbBuf, pbData, DES_BLOCKLEN);

        CBC(des, DES_BLOCKLEN, pbData, rgbBuf, &sDESKey.sKeyTable,
            ENCRYPT, rgbFeedBack);
    }

    fRet = TRUE;
//Ret:
    return fRet;
}


BOOL    FMyPrimitiveDeriveKey(
            PBYTE       pbSalt,
            DWORD       cbSalt,
            PBYTE       pbOtherData,
            DWORD       cbOtherData,
            DESKEY*     pDesKey)
{
    BOOL fRet = FALSE;

    A_SHA_CTX   sSHAHash;

/*
    PBYTE pbToBeHashed = (PBYTE)SSAlloc(cbSalt+cbOtherData);
    if(pbToBeHashed == NULL) return FALSE;

    CopyMemory(pbToBeHashed, pbSalt, cbSalt);
    CopyMemory((PBYTE)((DWORD)pbToBeHashed+cbSalt), pbOtherData, cbOtherData);

    // hash data
    BYTE rgbHash[A_SHA_DIGEST_LEN];
    if (!FMyPrimitiveSHA(pbToBeHashed, cbSalt+cbOtherData, rgbHash))
        goto Ret;
*/
    // NEW: put hashing code inline: saves alloc, copy, free
    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (BYTE *) pbSalt, cbSalt);
    A_SHAUpdate(&sSHAHash, (BYTE *) pbOtherData, cbOtherData);
    A_SHAFinal(&sSHAHash, sSHAHash.HashVal);

    // now all data hashed, derive a session key
    SS_ASSERT(sizeof(sSHAHash.HashVal) >= DES_BLOCKLEN);
    if (!FMyMakeDESKey(pDesKey, sSHAHash.HashVal))
        goto Ret;

    fRet = TRUE;
Ret:
    return fRet;
}


BOOL FMyOldPrimitiveHMAC(
        DESKEY      sMacKey,
        PBYTE       pbData,
        DWORD       cbData,
        BYTE        rgbHMAC[A_SHA_DIGEST_LEN])
{
    BOOL fRet = FALSE;

    BYTE rgbKipad[OLD_MAC_K_PADSIZE];
    BYTE rgbKopad[OLD_MAC_K_PADSIZE];

    ZeroMemory(rgbKipad, OLD_MAC_K_PADSIZE);
    CopyMemory(rgbKipad, &sMacKey.rgbKey, DES_BLOCKLEN);

    CopyMemory(rgbKopad, rgbKipad, sizeof(rgbKipad));


    BYTE  rgbHMACTmp[OLD_MAC_K_PADSIZE+A_SHA_DIGEST_LEN];


    // assert we're a multiple
    SS_ASSERT( (OLD_MAC_K_PADSIZE % sizeof(DWORD)) == 0);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for(DWORD dwBlock=0; dwBlock<OLD_MAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)rgbKopad)[dwBlock] ^= 0x5C5C5C5C;
    }


    // prepend Kipad to data, Hash to get H1
    {
        // do this inline, don't call MyPrimitiveSHA since it would require data copy
        A_SHA_CTX   sSHAHash;

        A_SHAInit(&sSHAHash);
        A_SHAUpdate(&sSHAHash, pbData, cbData);
        A_SHAUpdate(&sSHAHash, rgbKipad, OLD_MAC_K_PADSIZE);
        // Finish off the hash
        A_SHAFinal(&sSHAHash, sSHAHash.HashVal);

        // prepend Kopad to H1, hash to get HMAC
        CopyMemory(rgbHMACTmp, rgbKopad, OLD_MAC_K_PADSIZE);
        CopyMemory(rgbHMACTmp+OLD_MAC_K_PADSIZE, sSHAHash.HashVal, A_SHA_DIGEST_LEN);
    }

    if (!FMyPrimitiveSHA(
            rgbHMACTmp,
            sizeof(rgbHMACTmp),
            rgbHMAC))
        goto Ret;

    fRet = TRUE;
Ret:

    return fRet;
}


BOOL FMyPrimitiveHMAC(
        DESKEY      sMacKey,
        PBYTE       pbData,
        DWORD       cbData,
        BYTE        rgbHMAC[A_SHA_DIGEST_LEN])
{
    return FMyPrimitiveHMACParam(
            sMacKey.rgbKey,
            DES_BLOCKLEN,
            pbData,
            cbData,
            rgbHMAC);
}

BOOL FMyPrimitiveHMACParam(
        PBYTE       pbKeyMaterial,
        DWORD       cbKeyMaterial,
        PBYTE       pbData,
        DWORD       cbData,
        BYTE        rgbHMAC[A_SHA_DIGEST_LEN]  // output buffer
        )
{
    BOOL fRet = FALSE;

    BYTE rgbKipad[HMAC_K_PADSIZE];
    BYTE rgbKopad[HMAC_K_PADSIZE];

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;


    ZeroMemory(rgbKipad, HMAC_K_PADSIZE);
    CopyMemory(rgbKipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(rgbKopad, HMAC_K_PADSIZE);
    CopyMemory(rgbKopad, pbKeyMaterial, cbKeyMaterial);



    BYTE  rgbHMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];

    // assert we're a multiple
    SS_ASSERT( (HMAC_K_PADSIZE % sizeof(DWORD)) == 0);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for(DWORD dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)rgbKopad)[dwBlock] ^= 0x5C5C5C5C;
    }


    // prepend Kipad to data, Hash to get H1
    {
        // do this inline, don't call MyPrimitiveSHA since it would require data copy
        A_SHA_CTX   sSHAHash;

        A_SHAInit(&sSHAHash);
        A_SHAUpdate(&sSHAHash, rgbKipad, HMAC_K_PADSIZE);
        A_SHAUpdate(&sSHAHash, pbData, cbData);

        // Finish off the hash
        A_SHAFinal(&sSHAHash, sSHAHash.HashVal);

        // prepend Kopad to H1, hash to get HMAC
        CopyMemory(rgbHMACTmp, rgbKopad, HMAC_K_PADSIZE);
        CopyMemory(rgbHMACTmp+HMAC_K_PADSIZE, sSHAHash.HashVal, A_SHA_DIGEST_LEN);
    }

    // final hash: output value into passed-in buffer
    if (!FMyPrimitiveSHA(
            rgbHMACTmp,
            sizeof(rgbHMACTmp),
            rgbHMAC))
        goto Ret;

    fRet = TRUE;
Ret:

    return fRet;
}

/////////////////////////////////////////////////////////////////////////
// PKCS5DervivePBKDF2_SHA
// 
// Performs a PKCS #5 Iterative key derivation (type 2) 
// using HMAC_SHA as the primitive hashing function
/////////////////////////////////////////////////////////////////////////

BOOL PKCS5DervivePBKDF2(
        PBYTE       pbKeyMaterial,
        DWORD       cbKeyMaterial,
        PBYTE       pbSalt,
        DWORD       cbSalt,
        DWORD       KeyGenAlg,
        DWORD       cIterationCount,
        DWORD       iBlockIndex,
        BYTE        rgbPKCS5Key[A_SHA_DIGEST_LEN]  // output buffer
        )

{

    DWORD      i,j;
    A_SHA_CTX   sSHAHash;
    BYTE    rgbPKCS5Temp[A_SHA_DIGEST_LEN];
    BYTE    rgbTempData[PBKDF2_MAX_SALT_SIZE + 4];

    if((cIterationCount <1) ||  
       (NULL == pbKeyMaterial) ||
       (NULL == pbSalt) ||
       (0 == cbKeyMaterial) ||
       (0 == cbSalt) ||
       (cbSalt > PBKDF2_MAX_SALT_SIZE) ||
       (KeyGenAlg != CALG_HMAC))
    {
        return FALSE;
    }

    //
    // Add in the block index 
    //
    CopyMemory(rgbTempData, pbSalt, cbSalt);
    rgbTempData[cbSalt] = 0;
    rgbTempData[cbSalt+1] = 0;
    rgbTempData[cbSalt+2] = 0;
    rgbTempData[cbSalt+3] = (BYTE)(iBlockIndex & 0xff);

    //
    // Perfom the initial iteration, which is
    // HMAC_SHA1(KeyMaterial, Salt || cBlockIndex)
    //
    if(!FMyPrimitiveHMACParam(pbKeyMaterial, 
                              cbKeyMaterial,
                              rgbTempData,
                              cbSalt+4,
                              rgbPKCS5Key))
                              return FALSE;



    //
    // Perform additional iterations
    // HMAC_SHA1(KeyMaterial, last)
    //


    for (i=1; i<cIterationCount; i++)
    {
        if(!FMyPrimitiveHMACParam(pbKeyMaterial, 
                                  cbKeyMaterial,
                                  rgbPKCS5Key,
                                  A_SHA_DIGEST_LEN,
                                  rgbPKCS5Temp))
                                  return FALSE;
        // xor back into the primary key.
        for(j=0; j < (A_SHA_DIGEST_LEN / 4); j++)
        {
            ((DWORD *)rgbPKCS5Key)[j] ^= ((DWORD *)rgbPKCS5Temp)[j];
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\common\secmisc.c ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    secmisc.c

Abstract:

    This module contains miscellaneous security routines for the Protected
    Storage.


Author:

    Scott Field (sfield)    25-Mar-97

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include "secmisc.h"

#include "unicode5.h"
#include "debug.h"

BOOL
GetUserHKEYEx(
    IN      LPCWSTR szUser,
    IN      DWORD   dwDesiredAccess,
    IN  OUT HKEY    *hKeyUser,
    IN      BOOL    fCheckDefault       // check .Default registry hive when user's not available?
    )
{
    HKEY hKey;
    LONG lRet;

    //
    // first, try HKEY_USERS\szUser
    // note on WinNT, szUser is an textual sid of the form S-1-5-21-xxx ...
    //      on Win95, szUser is the username associated with the logged on user
    //

    //
    // unfortunately, if szUser is null or empty, the RegOpenKeyEx below will
    // succeed, which is not correct behavior for us.  Check for this case
    // and retry with default on if fCheckDefault is TRUE.
    //

    if(szUser == NULL || szUser[0] == L'\0') {
        // invalid szUser specified.
        lRet = ERROR_FILE_NOT_FOUND;
    } else {
        lRet = RegOpenKeyExU(
                    HKEY_USERS,
                    szUser,
                    0,      // dwOptions
                    dwDesiredAccess,
                    &hKey
                    );
    }

    if( lRet != ERROR_SUCCESS && fCheckDefault ) {

        //
        // if that failed, try HKEY_USERS\.Default (for services on NT).
        // TODO (lookat), for now, don't fall back to HKEY_USERS\.Default on Win95
        // because that is shared across users when profiles are disabled.
        //

        lRet = RegOpenKeyExU(
                    HKEY_USERS,
                    L".Default",
                    0,      // dwOptions
                    dwDesiredAccess,
                    &hKey
                    );
    }

    if(lRet != ERROR_SUCCESS) {
        SetLastError( (DWORD)lRet );
        return FALSE;
    }

    *hKeyUser = hKey;

    return TRUE;
}

BOOL
GetUserHKEY(
    IN      LPCWSTR szUser,
    IN      DWORD   dwDesiredAccess,
    IN  OUT HKEY    *hKeyUser
    )
{
    //
    // winnt: try HKEY_USERS\.Default
    // win95: don't go to HKEY_USERS\.Default when profiles disabled.
    //

    if(FIsWinNT()) {
        BOOL fRet = GetUserHKEYEx(szUser, dwDesiredAccess, hKeyUser, FALSE);

        if(!fRet) {
            //
            // see if local system.  If so, retry against .Default
            //

            static const WCHAR szTextualSidSystem[] = TEXTUAL_SID_LOCAL_SYSTEM;

            if( memcmp(szUser, szTextualSidSystem, sizeof(szTextualSidSystem)) == 0 )
                fRet = GetUserHKEYEx(szUser, dwDesiredAccess, hKeyUser, TRUE);

        }

        return fRet;

    } else {
        return GetUserHKEYEx(szUser, dwDesiredAccess, hKeyUser, FALSE);
    }

}

BOOL
GetUserTextualSid(
    IN HANDLE hUserToken,        // optional
    IN  OUT LPWSTR  lpBuffer,
    IN  OUT LPDWORD nSize
    )
{
    HANDLE hToken;
    PSID pSidUser = NULL;
    BOOL fSuccess = FALSE;

    if(hUserToken == NULL)
    {
        if(!OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                    &hToken
                    ))
        {
            return FALSE;
        }
    }
    else
    {
        hToken = hUserToken;
    }

    fSuccess = GetTokenUserSid(hToken, &pSidUser);

    if(fSuccess) 
    {
        //
        // obtain the textual representaion of the Sid
        //

        fSuccess = GetTextualSid(
                        pSidUser,   // user binary Sid
                        lpBuffer,   // buffer for TextualSid
                        nSize       // required/result buffer size in chars (including NULL)
                        );
    }

    if(pSidUser)
        SSFree(pSidUser);

    if(hToken != hUserToken)
    {
        CloseHandle(hToken);
    }

    return fSuccess;
}

BOOL
GetTextualSid(
    IN      PSID    pSid,          // binary Sid
    IN  OUT LPWSTR  TextualSid,  // buffer for Textual representaion of Sid
    IN  OUT LPDWORD dwBufferLen // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD dwSidSize;


    if(!IsValidSid(pSid)) return FALSE;

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length (conservative guess)
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(WCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*dwBufferLen < dwSidSize) {
        *dwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    dwSidSize = wsprintfW(TextualSid, L"S-%lu-", SID_REVISION );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) ) {
        dwSidSize += wsprintfW(TextualSid + dwSidSize,
                    L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    } else {
        dwSidSize += wsprintfW(TextualSid + dwSidSize,
                    L"%lu",
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for (dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++) {
        dwSidSize += wsprintfW(TextualSid + dwSidSize,
            L"-%lu", *GetSidSubAuthority(pSid, dwCounter) );
    }

    *dwBufferLen = dwSidSize + 1; // tell caller how many chars (include NULL)

    return TRUE;
}

BOOL
GetThreadAuthenticationId(
    IN      HANDLE  hThread,
    IN  OUT PLUID   AuthenticationId
    )
/*++

    This function retrieves the authentication Id (LUID) from the access token
    specified by the calling thread.

    The thread specified by hThread must be impersonating a client.

--*/
{
    HANDLE hToken;
    TOKEN_STATISTICS TokenInfo;
    DWORD dwReturnLen;
    BOOL bSuccess;

    if(!FIsWinNT()) {

        //
        // on Win95, just zero fill the authentication ID, since none exists
        //

        ZeroMemory(AuthenticationId, sizeof(LUID));
        return TRUE;
    }

    if(!OpenThreadToken(
        hThread,
        TOKEN_QUERY,
        TRUE,
        &hToken
        )) return FALSE;

    bSuccess = GetTokenInformation(
        hToken,
        TokenStatistics,
        &TokenInfo,
        sizeof(TokenInfo),
        &dwReturnLen
        );

    CloseHandle(hToken);

    if(!bSuccess) return FALSE;

    memcpy(AuthenticationId, &(TokenInfo.AuthenticationId), sizeof(LUID));
    return TRUE;
}

BOOL
GetTokenAuthenticationId(
    IN      HANDLE  hUserToken,
    IN  OUT PLUID   AuthenticationId
    )
/*++

    This function retrieves the authentication Id (LUID) from the specified
    access token.

--*/
{
    TOKEN_STATISTICS TokenInfo;
    DWORD dwReturnLen;
    BOOL bSuccess;
    HANDLE hToken = NULL;

    if(!FIsWinNT()) {

        //
        // on Win95, just zero fill the authentication ID, since none exists
        //

        ZeroMemory(AuthenticationId, sizeof(LUID));
        return TRUE;
    }

    if(hUserToken == NULL)
    {
        if(!OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                    &hToken
                    ))
        {
            return FALSE;
        }
    }
    else
    {
        hToken = hUserToken;
    }

    bSuccess = GetTokenInformation(
        hToken,
        TokenStatistics,
        &TokenInfo,
        sizeof(TokenInfo),
        &dwReturnLen
        );

    if(hToken != hUserToken)
    {
        CloseHandle(hToken);
    }

    if(!bSuccess) return FALSE;

    memcpy(AuthenticationId, &(TokenInfo.AuthenticationId), sizeof(LUID));
    return TRUE;
}

BOOL
GetTokenUserSid(
    IN      HANDLE  hUserToken,     // token to query
    IN  OUT PSID    *ppUserSid  // resultant user sid
    )
/*++

    This function queries the access token specified by the
    hToken parameter, and returns an allocated copy of the
    TokenUser information on success.

    The access token specified by hToken must be opened for
    TOKEN_QUERY access.

    On success, the return value is TRUE.  The caller is
    responsible for freeing the resultant UserSid via a call
    to SSFree().

    On failure, the return value is FALSE.  The caller does
    not need to free any buffer.

--*/
{
    BYTE FastBuffer[256];
    LPBYTE SlowBuffer = NULL;
    PTOKEN_USER ptgUser;
    DWORD cbBuffer;
    BOOL fSuccess = FALSE;
    HANDLE hToken = NULL;

    *ppUserSid = NULL;

    if(hUserToken == NULL)
    {
        if(!OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                    &hToken
                    ))
        {
            return FALSE;
        }
    }
    else
    {
        hToken = hUserToken;
    }

    //
    // try querying based on a fast stack based buffer first.
    //

    ptgUser = (PTOKEN_USER)FastBuffer;
    cbBuffer = sizeof(FastBuffer);

    fSuccess = GetTokenInformation(
                    hToken,    // identifies access token
                    TokenUser, // TokenUser info type
                    ptgUser,   // retrieved info buffer
                    cbBuffer,  // size of buffer passed-in
                    &cbBuffer  // required buffer size
                    );

    if(!fSuccess) {

        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            //
            // try again with the specified buffer size
            //

            SlowBuffer = (LPBYTE)SSAlloc(cbBuffer);

            if(SlowBuffer != NULL) {
                ptgUser = (PTOKEN_USER)SlowBuffer;

                fSuccess = GetTokenInformation(
                                hToken,    // identifies access token
                                TokenUser, // TokenUser info type
                                ptgUser,   // retrieved info buffer
                                cbBuffer,  // size of buffer passed-in
                                &cbBuffer  // required buffer size
                                );
            }
        }
    }

    //
    // if we got the token info successfully, copy the
    // relevant element for the caller.
    //

    if(fSuccess) {

        DWORD cbSid;

        // reset to assume failure
        fSuccess = FALSE;

        cbSid = GetLengthSid(ptgUser->User.Sid);

        *ppUserSid = SSAlloc( cbSid );

        if(*ppUserSid != NULL) {
            fSuccess = CopySid(cbSid, *ppUserSid, ptgUser->User.Sid);
        }
        else
        {
            fSuccess = FALSE;
        }
    }

    if(!fSuccess) {
        if(*ppUserSid) {
            SSFree(*ppUserSid);
            *ppUserSid = NULL;
        }
    }

    if(SlowBuffer)
        SSFree(SlowBuffer);

    if(hToken != hUserToken)
    {
        CloseHandle(hToken);
    }

    return fSuccess;
}

BOOL
SetRegistrySecurity(
    IN      HKEY    hKey
    )
/*++

    The function applies security to the specifed registry key such that only
    Local System has Full Control to the registry key.  Note that the owner
    is not set, which results in a default owner of Administrators.

    The specified hKey must to opened for WRITE_DAC access.

--*/
{
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PSID pLocalSystemSid = NULL;
    SECURITY_DESCRIPTOR sd;
    PACL pDacl = NULL;
    PACCESS_ALLOWED_ACE pAce;
    DWORD dwAclSize;
    LONG lRetCode;
    BOOL bSuccess = FALSE; // assume this function fails

    //
    // prepare a Sid representing the Local System account
    //

    if(!AllocateAndInitializeSid(
        &sia,
        1,
        SECURITY_LOCAL_SYSTEM_RID,
        0, 0, 0, 0, 0, 0, 0,
        &pLocalSystemSid
        )) goto cleanup;

    //
    // compute size of new acl
    //

    dwAclSize = sizeof(ACL) +
        1 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(pLocalSystemSid) ;

    //
    // allocate storage for Acl
    //

    pDacl = (PACL)SSAlloc(dwAclSize);
    if(pDacl == NULL) goto cleanup;

    if(!InitializeAcl(pDacl, dwAclSize, ACL_REVISION))
        goto cleanup;

    if(!AddAccessAllowedAce(
        pDacl,
        ACL_REVISION,
        KEY_ALL_ACCESS,
        pLocalSystemSid
        )) goto cleanup;

    //
    // make it container inherit.
    //

    if(!GetAce(pDacl, 0, &pAce))
        goto cleanup;

    pAce->Header.AceFlags = CONTAINER_INHERIT_ACE;

    if(!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
        goto cleanup;

    if(!SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE)) {
        goto cleanup;
    }

    //
    // apply the security descriptor to the registry key
    //

    lRetCode = RegSetKeySecurity(
        hKey,
        (SECURITY_INFORMATION)DACL_SECURITY_INFORMATION,
        &sd
        );

    if(lRetCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    bSuccess = TRUE; // indicate success

cleanup:

    //
    // free allocated resources
    //

    if(pDacl != NULL)
        SSFree(pDacl);

    if(pLocalSystemSid != NULL)
        FreeSid(pLocalSystemSid);

    return bSuccess;
}

BOOL
SetPrivilege(
    HANDLE hToken,          // token handle
    LPCWSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);

    if(!LookupPrivilegeValueW( NULL, Privilege, &luid )) return FALSE;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    //
    // second pass.  set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;

    if(bEnablePrivilege) {
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    }
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    return TRUE;
}

BOOL
SetCurrentPrivilege(
    LPCWSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    BOOL bSuccess=FALSE; // assume failure
    HANDLE hToken;

    if(OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            ))
    {

        if(SetPrivilege(hToken, Privilege, bEnablePrivilege)) bSuccess=TRUE;

        CloseHandle(hToken);
    }

    return bSuccess;
}


BOOL
IsDelegating(
    IN      HANDLE hToken   // token to query, open for at least TOKEN_QUERY access
    )
/*++

    This function determines if the specified access token represents an
    impersonation at the delegation impersonate level.

    The access token specified by the hToken parameter must be opened for
    at least TOKEN_QUERY access.

    If the return value is TRUE, the specified hToken is impersonating at
    delegation level.

    If the return value is FALSE, hToken does not represent delegation level
    impersonation.

--*/
{
    DWORD dwImpersonationLevel;
    DWORD cbTokenInfo;

    if( GetTokenInformation(
                hToken,
                TokenImpersonationLevel,
                &dwImpersonationLevel,
                sizeof(dwImpersonationLevel),
                &cbTokenInfo
                ) && dwImpersonationLevel == SecurityDelegation ) {

        return TRUE;
    }

    return FALSE;
}

BOOL
IsUserSidInDomain(
    IN      PSID pSidDomain,    // domain Sid
    IN      PSID pSidUser       // user Sid
    )
/*++

    This function determines if the user associated with the
    pSidUser parameter exists in the domain specified by pSidDomain.

    If the user is in the specified domain, the return value is TRUE.
    Otherwise, the return value is FALSE.

--*/
{
    DWORD dwSubauthorityCount;
    DWORD dwSubauthIndex;

    //
    // pickup count of subauthorities in domain sid.  The domain Sid
    // is the prefix associated with user sids, so use that count
    // as the basis for our comparison.
    //

    dwSubauthorityCount = (DWORD)*GetSidSubAuthorityCount( pSidDomain );

    if( dwSubauthorityCount >= (DWORD)*GetSidSubAuthorityCount( pSidUser ) )
        return FALSE;

    //
    // compare identifier authority values.
    //

    if(memcmp(  GetSidIdentifierAuthority(pSidDomain),
                GetSidIdentifierAuthority(pSidUser),
                sizeof(SID_IDENTIFIER_AUTHORITY)  ) != 0)
        return FALSE;

    //
    // loop through subauthorities comparing equality.
    //

    for(dwSubauthIndex = 0 ;
        dwSubauthIndex < dwSubauthorityCount ;
        dwSubauthIndex++) {

        if( *GetSidSubAuthority(pSidDomain, dwSubauthIndex) !=
            *GetSidSubAuthority(pSidUser, dwSubauthIndex) )
            return FALSE;
    }


    return TRUE;
}

BOOL
IsAdministrator(
    VOID
    )
/*++

    This function determines if the calling user is an Administrator.

    On Windows 95, this function always returns TRUE, as there is
    no difference between users on that platform.

    On Windows NT, the caller of this function must be impersonating
    the user which is to be queried.  If the caller is not impersonating,
    this function will always return FALSE.

--*/
{
    HANDLE hAccessToken;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    PSID psidAdministrators = NULL;
    BOOL bSuccess;

    //
    // If we aren't on WinNT (on Win95) just return TRUE
    //

    if(!FIsWinNT())
        return TRUE;

    if(!OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY,
            TRUE,
            &hAccessToken
            )) return FALSE;

    bSuccess = AllocateAndInitializeSid(
            &siaNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators
            );

    if( bSuccess ) {
        BOOL fIsMember = FALSE;

        bSuccess = CheckTokenMembership( hAccessToken, psidAdministrators, &fIsMember );

        if( bSuccess && !fIsMember )
            bSuccess = FALSE;

    }

    CloseHandle( hAccessToken );

    if(psidAdministrators)
        FreeSid(psidAdministrators);

    return bSuccess;
}

BOOL
IsLocal(
    VOID
    )
/*++

    This function determines if the calling user is logged on locally

    On Windows 95, this function always returns TRUE, as there is
    no difference between users on that platform.

    On Windows NT, the caller of this function must be impersonating
    the user which is to be queried.  If the caller is not impersonating,
    this function will always return FALSE.

--*/
{
    HANDLE hAccessToken;
    SID_IDENTIFIER_AUTHORITY siaLocalAuthority = SECURITY_LOCAL_SID_AUTHORITY;
    PSID psidLocal = NULL;
    BOOL bSuccess;

    //
    // If we aren't on WinNT (on Win95) just return TRUE
    //

    if(!FIsWinNT())
        return TRUE;

    if(!OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY,
            TRUE,
            &hAccessToken
            )) return FALSE;

    bSuccess = AllocateAndInitializeSid(
            &siaLocalAuthority,
            1,
            SECURITY_LOCAL_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidLocal
            );

    if( bSuccess ) {
        BOOL fIsMember = FALSE;

        bSuccess = CheckTokenMembership( hAccessToken, psidLocal, &fIsMember );

        if( bSuccess && !fIsMember )
            bSuccess = FALSE;

    }

    CloseHandle( hAccessToken );

    if(psidLocal)
        FreeSid(psidLocal);

    return bSuccess;
}


BOOL
IsDomainController(
    VOID
    )
/*++

    This function returns TRUE if the current machine is a Windows NT
    domain controller.

    The function returns FALSE if the current machine is not a Windows NT
    domain controller.

--*/
{
    HMODULE hNtDll;

    typedef BOOLEAN (NTAPI *RTLGETNTPRODUCTTYPE)(
        OUT PNT_PRODUCT_TYPE NtProductType
        );


    RTLGETNTPRODUCTTYPE _RtlGetNtProductType;
    NT_PRODUCT_TYPE NtProductType;

    if(!FIsWinNT())
        return FALSE;


    hNtDll = GetModuleHandleW(L"ntdll.dll");
    if( hNtDll == NULL )
        return FALSE;


    _RtlGetNtProductType = (RTLGETNTPRODUCTTYPE)GetProcAddress( hNtDll, "RtlGetNtProductType" );
    if( _RtlGetNtProductType == NULL )
        return FALSE;


    if(_RtlGetNtProductType( &NtProductType )) {
        if( NtProductType == NtProductLanManNt )
            return TRUE;
    }

    return FALSE;
}

LONG
SecureRegDeleteValueU(
    IN      HKEY hKey,          // handle of key
    IN      LPCWSTR lpValueName // address of value name
    )
/*++

    This function securely deletes a value from the registry.  This approach
    avoids leaving a copy of the old data in the registry backing file after
    the delete has occurred.

    The specified registry handle hKey must be opened for
    REG_QUERY_VALUE | REG_SET_VALUE | DELETE access.

    On success, the return value is ERROR_SUCCESS.
    On error, the return value is a Win32 error code.

--*/
{
    DWORD dwType;
    DWORD cbData;

    BYTE FastBuffer[ 256 ];
    LPBYTE lpData;
    LPBYTE SlowBuffer = NULL;

    LONG lRet;

    cbData = 0; // query size of value data.

    //
    // query the current size of the registry data.
    // zero the current registry data of current size.
    // delete the registry data.
    // flush the change to disk.
    //  If errors occur, just do a regular delete.
    //

    lRet = RegQueryValueExU(
                hKey,
                lpValueName,
                NULL,
                &dwType,
                NULL,
                &cbData
                );

    if( lRet == ERROR_MORE_DATA ) {

        BOOL fSet = TRUE; // assume ok to set

        //
        // select fast buffer if large enough.  otherwise, allocate a buffer
        //

        if(cbData <= sizeof(FastBuffer)) {
            lpData = FastBuffer;
        } else {
            SlowBuffer = (LPBYTE)SSAlloc( cbData );

            if(SlowBuffer == NULL) {
                fSet = FALSE; // failure.
            } else {
                lpData = SlowBuffer;
            }

        }

        if( fSet ) {

            ZeroMemory( lpData, cbData );

            RegSetValueExU(
                        hKey,
                        lpValueName,
                        0,
                        dwType,
                        lpData,
                        cbData
                        );
        }
    }

    lRet = RegDeleteValueU( hKey, lpValueName );

    RegFlushKey( hKey );

    if( SlowBuffer )
        SSFree( SlowBuffer );

    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\csecstor\defer.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    defer.h

Abstract:

    This module contains routines to perform deferred "on-demand" loading
    of the Protected Storage server.

    Furthermore, this module implements a routine, IsServiceAvailable(),
    which is a high-performance test that can be used to determine if the
    protected storage server is running.  This test is performed prior
    to attempting any more expensive operations against the server (eg,
    RPC binding).

    This defer loading code is only relevant for Protected Storage when
    running on Windows 95.

Author:

    Scott Field (sfield)    23-Jan-97

--*/

BOOL IsServiceAvailable(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\csecstor\csecstr1.cpp ===
// CSecStr1.cpp : Implementation of CISecStorApp and DLL registration.

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "dpapiprv.h" // RPC protseq stuff

#include "stdafx.h"
#include "pstorec.h"
#include "cSecStr1.h"
#include "pstrpc.h"
#include <wincrypt.h>
#include "pstdef.h"
#include "crtem.h"
#include "defer.h"

#include "pmacros.h"
#include "debug.h"
#include "unicode.h"
#include "waitsvc.h"


/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_API midl_user_allocate(size_t len)
{
    return CoTaskMemAlloc(len);
}

void __RPC_API midl_user_free(void __RPC_FAR * ptr)
{
    CoTaskMemFree(ptr);
}

RPC_STATUS BindW(WCHAR **pszBinding, RPC_BINDING_HANDLE *phBind)
{
    RPC_STATUS status;



    //
    // on WinNT5, go to the shared services.exe RPC server
    //

    status = RpcStringBindingComposeW(
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_PROT_SEQ,
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_ENDPOINT,
                            NULL,
                            (unsigned short * *)pszBinding
                            );


    if (status)
    {
        return(status);
    }

    status = RpcBindingFromStringBindingW(*pszBinding, phBind);

    return status;
}





RPC_STATUS UnbindW(WCHAR **pszBinding, RPC_BINDING_HANDLE *phBind)
{
    RPC_STATUS status;

    status = RpcStringFreeW(pszBinding);

    if (status)
    {
        return(status);
    }

    RpcBindingFree(phBind);

    return RPC_S_OK;
}


//
// define an ugly macro that allows us to provide enough context to work-around
// a bug in imagehlp on win95.
//

#define InitCallContext( pCallContext ) \
    RealInitCallContext( pCallContext );

BOOL RealInitCallContext(PST_CALL_CONTEXT *pCallContext)
{
    HANDLE hCurrentThread;

    pCallContext->Handle = (DWORD_PTR)INVALID_HANDLE_VALUE;
    pCallContext->Address = GetCurrentProcessId();

    //
    // duplicate pseudo-current thread handle to real handle to pass to server
    //

    if(!DuplicateHandle(
        GetCurrentProcess(),
        GetCurrentThread(),
        GetCurrentProcess(),
        &hCurrentThread,
        0,
        FALSE,
        DUPLICATE_SAME_ACCESS
        ))
        return FALSE;

    pCallContext->Handle = (DWORD_PTR)hCurrentThread;

    return TRUE;
}

BOOL DeleteCallContext(PST_CALL_CONTEXT* pCallContext)
{
    if (pCallContext != NULL)
    {
        if(pCallContext->Handle != (DWORD_PTR)INVALID_HANDLE_VALUE)
        {
            CloseHandle((HANDLE)(pCallContext->Handle));
            pCallContext->Handle = (DWORD_PTR)INVALID_HANDLE_VALUE;
        }

        pCallContext->Address = 0;
    }

    return TRUE;
}


// RPC Binding class
CRPCBinding::CRPCBinding()
{
}

CRPCBinding::~CRPCBinding()
{
    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        if (m_fGoodHProv) {
            SSReleaseContext(m_hBind, m_hProv, CallContext, 0);
        }
        if(m_wszStringBinding != NULL && m_hBind != NULL)
            UnbindW(&m_wszStringBinding, &m_hBind);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // if RPCBinding being destroyed, catch anything RPC might throw
        // swallow!
    }

    DeleteCallContext(&CallContext);

}

static BOOL g_fDone = FALSE;
HRESULT CRPCBinding::Init()
{
    HRESULT hr;

    m_dwRef = 1;
    m_fGoodHProv = FALSE;

    m_wszStringBinding = NULL;
    m_hBind = NULL;

    WaitForCryptService(L"ProtectedStorage", &g_fDone);

    if(!IsServiceAvailable())
        return PST_E_SERVICE_UNAVAILABLE;

    return BindW(&m_wszStringBinding, &m_hBind);
}

HRESULT CRPCBinding::Acquire(
             IN PPST_PROVIDERID pProviderID,
             IN LPVOID  pReserved,
             IN DWORD dwFlags
             )
{
    PST_CALL_CONTEXT CallContext;
    HRESULT hr;

    __try
    {
        InitCallContext(&CallContext);

        // now we acquire context
        hr = SSAcquireContext(m_hBind,
                pProviderID,
                CallContext,
                (DWORD) GetCurrentProcessId(),
                &m_hProv,
                (DWORD_PTR)pReserved,
                dwFlags
                );

        if(hr != RPC_S_OK)
            goto Ret;

        m_fGoodHProv = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // catch anything RPC might throw
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

Ret:

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

CRPCBinding *CRPCBinding::AddRef()
{
    m_dwRef++;
    return this;
}

void CRPCBinding::Release()
{
    m_dwRef--;
    if (0 == m_dwRef)
        delete this;
}

/////////////////////////////////////////////////////////////////////////////
//

CPStore::CPStore()
{
}

CPStore::~CPStore()
{
    m_pBinding->Release();
}

void CPStore::Init(
                    CRPCBinding *pBinding
                    )
{
    m_pBinding = pBinding;
    m_Index = 0;
}

HRESULT CPStore::CreateObject(
                    CRPCBinding *pBinding,
                    IPStore **ppv
                    )
{
    HRESULT hr;
    __try
    {
        typedef CComObject<CPStore> CObject;

        CObject* pnew = new CObject;
        if(NULL == pnew)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pnew->Init(pBinding) ;
            hr = pnew->QueryInterface(IID_IPStore, (void**)ppv);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT CPStore::CreateObject(
                    CRPCBinding *pBinding,
                    IEnumPStoreProviders **ppv
                    )
{
    HRESULT hr;
    __try
    {
        typedef CComObject<CPStore> CObject;

        CObject* pnew = new CObject;
        if(NULL == pnew)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pnew->Init(pBinding);
            hr = pnew->QueryInterface(IID_IEnumPStoreProviders, (void**)ppv);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::GetInfo(
    /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties)
{
    HRESULT         hr;
    PST_CALL_CONTEXT CallContext;

    __try
    {

        InitCallContext(&CallContext);

        *ppProperties = NULL;

        if (RPC_S_OK != (hr =
            SSGetProvInfo(m_pBinding->m_hBind,
                m_pBinding->m_hProv,
                CallContext,
                ppProperties,
                0)))
            goto Ret;

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::GetProvParam(
    /* [in] */ DWORD dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [out] */ BYTE __RPC_FAR **ppbData,
    /* [in] */ DWORD dwFlags)
{
    HRESULT hr;
    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        *pcbData = 0;
        *ppbData = NULL;

        if (RPC_S_OK != (hr =
            SSGetProvParam(m_pBinding->m_hBind,
                m_pBinding->m_hProv,
                CallContext,
                dwParam,
                pcbData,
                ppbData,
                dwFlags)))
            goto Ret;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::SetProvParam(
    /* [in] */ DWORD dwParam,
    /* [in] */ DWORD cbData,
    /* [in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ DWORD dwFlags)
{
    HRESULT hr;
    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        hr = SSSetProvParam(m_pBinding->m_hBind,
                              m_pBinding->m_hProv,
                              CallContext,
                              dwParam,
                              cbData,
                              pbData,
                              dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::CreateType(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ DWORD dwFlags)
{
    // validate inputs
    if ((pInfo == NULL) || pInfo->cbSize != sizeof(PST_TYPEINFO))
        return E_INVALIDARG;

    if ( pInfo->szDisplayName == NULL )
        return E_INVALIDARG;

    if (pType == NULL)
        return E_INVALIDARG;


    HRESULT hr;
    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        hr = SSCreateType(m_pBinding->m_hBind,
                          m_pBinding->m_hProv,
                          CallContext,
                          Key,
                          pType,
                          pInfo,
                          dwFlags);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::GetTypeInfo(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [out] */ PPST_TYPEINFO __RPC_FAR* ppInfo,
    /* [in] */ DWORD dwFlags)
{
    HRESULT         hr;
    PST_CALL_CONTEXT CallContext;

    if (pType == NULL)
        return E_INVALIDARG;

    if (ppInfo == NULL)
        return E_INVALIDARG;

    __try
    {
        InitCallContext(&CallContext);

        *ppInfo = NULL;

        if (RPC_S_OK != (hr =
            SSGetTypeInfo(m_pBinding->m_hBind,
                m_pBinding->m_hProv,
                CallContext,
                Key,
                pType,
                ppInfo,
                dwFlags)))
            goto Ret;

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::DeleteType(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags)
{
    if (pType == NULL)
        return E_INVALIDARG;

    PST_CALL_CONTEXT CallContext;
    HRESULT hr;

    __try
    {
        InitCallContext(&CallContext);

        hr = SSDeleteType(m_pBinding->m_hBind,
                            m_pBinding->m_hProv,
                            CallContext,
                            Key,
                            pType,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::CreateSubtype(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags)
{
    if ((pType == NULL) || (pSubtype == NULL))
        return E_INVALIDARG;

    if ( (pInfo == NULL) || (pInfo->cbSize != sizeof(PST_TYPEINFO)) )
        return E_INVALIDARG;

    // validate inputs
    if (pInfo->szDisplayName == NULL)
        return E_INVALIDARG;

    HRESULT hr;
    PST_CALL_CONTEXT CallContext;

    PST_ACCESSRULESET sNullRuleset = {sizeof(PST_ACCESSRULESET), 0, NULL};

    __try
    {
        InitCallContext(&CallContext);


        hr = SSCreateSubtype(m_pBinding->m_hBind,
                             m_pBinding->m_hProv,
                             CallContext,
                             Key,
                             pType,
                             pSubtype,
                             pInfo,
                             &sNullRuleset, // always pass NullRuleset.
                             dwFlags);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }


    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::GetSubtypeInfo(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_TYPEINFO __RPC_FAR* ppInfo,
    /* [in] */ DWORD dwFlags)
{
    if ((pType == NULL) || (pSubtype == NULL))
        return E_INVALIDARG;

    if (ppInfo == NULL)
        return E_INVALIDARG;

    HRESULT         hr;
    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        *ppInfo = NULL;

        if (RPC_S_OK != (hr =
            SSGetSubtypeInfo(m_pBinding->m_hBind,
                m_pBinding->m_hProv,
                CallContext,
                Key,
                pType,
                pSubtype,
                ppInfo,
                dwFlags)))
            goto Ret;

        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::DeleteSubtype(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ DWORD dwFlags)
{
    if ((pType == NULL) || (pSubtype == NULL))
        return E_INVALIDARG;

    PST_CALL_CONTEXT CallContext;
    HRESULT hr;

    __try
    {
        InitCallContext(&CallContext);
        hr = SSDeleteSubtype(m_pBinding->m_hBind,
                            m_pBinding->m_hProv,
                            CallContext,
                            Key,
                            pType,
                            pSubtype,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}


HRESULT STDMETHODCALLTYPE CPStore::ReadAccessRuleset(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
    /* [in] */ DWORD dwFlags)
{
    return PSTERR_TO_HRESULT(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE CPStore::WriteAccessRuleset(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags)
{
    return PSTERR_TO_HRESULT(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE CPStore::EnumTypes(
    /* [in] */ PST_KEY Key,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum
)
{
    HRESULT hr;

    __try
    {
        hr = CEnumTypes::CreateObject(m_pBinding->AddRef(), Key, NULL, dwFlags, ppenum);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::EnumSubtypes(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum
)
{
    if (pType == NULL)
        return E_INVALIDARG;

    HRESULT hr;

    __try
    {
        hr = CEnumTypes::CreateObject(m_pBinding->AddRef(), Key, pType, dwFlags, ppenum);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::DeleteItem(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags)
{
    if ((pItemType == NULL) || (pItemSubtype == NULL) || (szItemName == NULL))
        return E_INVALIDARG;

    // if it exists, is it valid?
    if ((pPromptInfo) && (pPromptInfo->cbSize != sizeof(PST_PROMPTINFO)))
        return E_INVALIDARG;

    PST_CALL_CONTEXT CallContext;
    HRESULT hr;

    __try
    {
        PST_PROMPTINFO sNullPrompt = {sizeof(PST_PROMPTINFO), 0, NULL, L""};

        // deal with NULL pPromptInfo
        if (pPromptInfo == NULL)
            pPromptInfo = &sNullPrompt;

        InitCallContext(&CallContext);

        hr = SSDeleteItem(m_pBinding->m_hBind,
                          m_pBinding->m_hProv,
                          CallContext,
                          Key,
                          pItemType,
                          pItemSubtype,
                          szItemName,
                          pPromptInfo,
                          dwFlags);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::ReadItem(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [out][in] */ DWORD __RPC_FAR *pcbData,
    /* [out][size_is] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags)
{
    if ((pItemType == NULL) || (pItemSubtype == NULL) || (szItemName == NULL))
        return E_INVALIDARG;

    // if exists, is it valid?
    if ((pPromptInfo) && (pPromptInfo->cbSize != sizeof(PST_PROMPTINFO)))
        return E_INVALIDARG;


    HRESULT hr;
    PST_CALL_CONTEXT CallContext;

    __try
    {
        PST_PROMPTINFO sNullPrompt = {sizeof(PST_PROMPTINFO), 0, NULL, L""};

        // deal with NULL pPromptInfo
        if (pPromptInfo == NULL)
            pPromptInfo = &sNullPrompt;

        InitCallContext(&CallContext);

        *pcbData = 0;
        *ppbData = NULL;

        // get the information
        if (RPC_S_OK != (hr =
            SSReadItem(m_pBinding->m_hBind,
                m_pBinding->m_hProv,
                CallContext,
                Key,
                pItemType,
                pItemSubtype,
                szItemName,
                pcbData,
                ppbData,
                pPromptInfo,
                dwFlags)))
            goto Ret;


        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:

    DeleteCallContext(&CallContext);
    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::WriteItem(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD cbData,
    /* [in][size_is] */ BYTE __RPC_FAR *pbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwDefaultConfirmationStyle,
    /* [in] */ DWORD dwFlags)
{
    if ((pItemType == NULL) || (pItemSubtype == NULL))
        return E_INVALIDARG;

    if (szItemName == NULL)
        return E_INVALIDARG;

    if ((pPromptInfo) && (pPromptInfo->cbSize != sizeof(PST_PROMPTINFO)))
        return E_INVALIDARG;


    PST_CALL_CONTEXT CallContext;
    HRESULT hr;

    __try
    {
        PST_PROMPTINFO sNullPrompt = {sizeof(PST_PROMPTINFO), 0, NULL, L""};

        // deal with NULL pPromptInfo
        if (pPromptInfo == NULL)
            pPromptInfo = &sNullPrompt;

        InitCallContext(&CallContext);

        hr = SSWriteItem(m_pBinding->m_hBind,
                         m_pBinding->m_hProv,
                         CallContext,
                         Key,
                         pItemType,
                         pItemSubtype,
                         szItemName,
                         cbData,
                         pbData,
                         pPromptInfo,
                         dwDefaultConfirmationStyle,
                         dwFlags);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::OpenItem(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PST_ACCESSMODE ModeFlags,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags)
{
    if ((pItemType == NULL) || (pItemSubtype == NULL) || (szItemName == NULL))
        return E_INVALIDARG;

    // if exists, is it valid?
    if ((pPromptInfo) && (pPromptInfo->cbSize != sizeof(PST_PROMPTINFO)))
        return E_INVALIDARG;


    PST_CALL_CONTEXT CallContext;
    HRESULT hr;

    __try
    {
        PST_PROMPTINFO sNullPrompt = {sizeof(PST_PROMPTINFO), 0, NULL, L""};

        // deal with NULL pPromptInfo
        if (pPromptInfo == NULL)
            pPromptInfo = &sNullPrompt;

        InitCallContext(&CallContext);

        // get the information
        if (RPC_S_OK != (hr =
            SSOpenItem(m_pBinding->m_hBind,
                m_pBinding->m_hProv,
                CallContext,
                Key,
                pItemType,
                pItemSubtype,
                szItemName,
                ModeFlags,
                pPromptInfo,
                dwFlags)))
            goto Ret;

        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:

    DeleteCallContext(&CallContext);
    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::CloseItem(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwFlags)
{
    if ((pItemType == NULL) || (pItemSubtype == NULL) || (szItemName == NULL))
        return E_INVALIDARG;

    HRESULT hr;
    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        // get the information
        if (RPC_S_OK != (hr =
            SSCloseItem(m_pBinding->m_hBind,
                m_pBinding->m_hProv,
                CallContext,
                Key,
                pItemType,
                pItemSubtype,
                szItemName,
                dwFlags)))
            goto Ret;

        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::EnumItems(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum
)
{
    if ((pItemType == NULL) || (pItemSubtype == NULL))
        return E_INVALIDARG;

    HRESULT hr;

    __try
    {
        hr = CEnumItems::CreateObject(m_pBinding->AddRef(),
                                        Key,
                                        pItemType,
                                        pItemSubtype,
                                        dwFlags,
                                        ppenum);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::Next(
    /* [in] */ DWORD celt,
    /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched)
{
    if ((pceltFetched == NULL) && (celt != 1))
        return E_INVALIDARG;

    DWORD       i = 0;
    HRESULT     hr = S_OK;

    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        for (i=0;i<celt;i++)
        {
            // clean the destination
            rgelt[i] = NULL;

            if (RPC_S_OK != (hr =
                SSPStoreEnumProviders(
                    m_pBinding->m_hBind,
                    CallContext,
                    &(rgelt[i]),
                    m_Index,
                    0)))
                goto Ret;

            m_Index++;

        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:
    __try
    {
        // if non-null, fill in
        if (pceltFetched)
            *pceltFetched = i;

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // don't stomp err code
        if (hr == PST_E_OK)
            hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::Skip(
    /* [in] */ DWORD celt)
{
    HRESULT hr = S_OK;

    __try
    {
        PST_PROVIDERINFO* pProvInfo;

        // loop (breaks if end reached)
        for (DWORD dw=0; dw<celt; dw++)
        {
            if(S_OK != (hr = this->Next(1, &pProvInfo, NULL)))
                break;

            // free the Info struct
            midl_user_free(pProvInfo);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::Reset( void)
{
    HRESULT hr;
    __try
    {
        m_Index = 0;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::Clone(
    /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum)
{
    if (ppenum == NULL)
        return E_INVALIDARG;

    HRESULT hr;

    __try
    {
        // get an ISecStor interface
        hr = CreateObject(m_pBinding->AddRef(), ppenum);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

// IEnumPStoreItems
CEnumItems::CEnumItems()
{
}

CEnumItems::~CEnumItems()
{
    m_pBinding->Release();
}

void CEnumItems::Init(
                      CRPCBinding *pBinding,
                      PST_KEY Key,
                      const GUID *pType,
                      const GUID *pSubtype,
                      DWORD dwFlags
                      )
{
    m_pBinding = pBinding;
    m_Key = Key;
    CopyMemory(&m_Type, pType, sizeof(GUID));
    CopyMemory(&m_Subtype, pSubtype, sizeof(GUID));
    m_dwFlags = dwFlags;
    m_Index = 0;
}

HRESULT CEnumItems::CreateObject(
                    CRPCBinding *pBinding,
                    PST_KEY Key,
                    const GUID *pType,
                    const GUID *pSubtype,
                    DWORD dwFlags,
                    IEnumPStoreItems **ppv
)
{
    if ((pType == NULL) || (pSubtype == NULL))
        return E_INVALIDARG;

    HRESULT hr;
    __try
    {
        typedef CComObject<CEnumItems> CObject;

        CObject* pnew = new CObject;
        if(NULL == pnew)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pnew->Init(pBinding, Key, pType, pSubtype, dwFlags);

            hr = pnew->QueryInterface(IID_IEnumPStoreItems, (void**)ppv);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // don't stomp err code
        if (hr == PST_E_OK)
            hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CEnumItems::Next(
    /* [in] */ DWORD celt,
    /* [out][size_is] */ LPWSTR __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched)
{
    if ((pceltFetched == NULL) && (celt != 1))
        return E_INVALIDARG;

    DWORD       i = 0;
    HRESULT     hr = S_OK;

    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        for (i=0;i<celt;i++)
        {
            rgelt[i] = NULL;

            //
            // TODO: during an enumeration of multiple items, we may fault/fail.
            // in this scenario, it may be useful to free any allocated entries
            // in the enumeration array.  This would entail invalidating all the
            // array entries prior to enumeration, and then looping+freeing on
            // error.
            //

            if (RPC_S_OK != (hr =
                SSEnumItems(
                    m_pBinding->m_hBind,
                    m_pBinding->m_hProv,
                    CallContext,
                    m_Key,
                    &m_Type,
                    &m_Subtype,
                    &(rgelt[i]),
                    m_Index,
                    m_dwFlags)))
                goto Ret;

            m_Index++;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:
    __try
    {
        // fill in if non-null
        if (pceltFetched)
            *pceltFetched = i;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // don't stomp err code
        if (hr == PST_E_OK)
            hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CEnumItems::Skip(
    /* [in] */ DWORD celt)
{
    LPWSTR      szName = NULL;
    DWORD       i;
    HRESULT     hr = S_OK;

    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        for (i=0;i<celt;i++)
        {

            if (RPC_S_OK != (hr =
                SSEnumItems(
                    m_pBinding->m_hBind,
                    m_pBinding->m_hProv,
                    CallContext,
                    m_Key,
                    &m_Type,
                    &m_Subtype,
                    &szName,
                    m_Index,
                    m_dwFlags)))
                goto Ret;

            midl_user_free(szName);
            szName = NULL;

            m_Index++;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

Ret:
    __try
    {
        if (szName)
            midl_user_free(szName);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // don't stomp err code
        if (hr == PST_E_OK)
            hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}


HRESULT STDMETHODCALLTYPE CEnumItems::Reset( void)
{
    HRESULT hr;

    __try
    {
        m_Index = 0;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CEnumItems::Clone(
    /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum)
{
    if (ppenum == NULL)
        return E_INVALIDARG;

    HRESULT hr;

    __try
    {
        hr = CEnumItems::CreateObject(m_pBinding->AddRef(),
                                        m_Key,
                                        &m_Type,
                                        &m_Subtype,
                                        m_dwFlags,
                                        ppenum);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

// IEnumPStoreTypes
CEnumTypes::CEnumTypes()
{
}

CEnumTypes::~CEnumTypes()
{
    m_pBinding->Release();
}

void CEnumTypes::Init(
                    CRPCBinding *pBinding,
                    PST_KEY Key,
                    const GUID *pType,
                    DWORD dwFlags
)
{
    m_pBinding = pBinding;
    m_Key = Key;
    if (NULL != pType)
    {
        CopyMemory(&m_Type, pType, sizeof(GUID));
        m_fEnumSubtypes = TRUE;
    }
    else
        m_fEnumSubtypes = FALSE;

    m_Index = 0;
    m_dwFlags = dwFlags;
}

HRESULT CEnumTypes::CreateObject(
                    CRPCBinding *pBinding,
                    PST_KEY Key,
                    const GUID *pType,
                    DWORD dwFlags,
                    IEnumPStoreTypes **ppv
)
{
    HRESULT hr;

    __try
    {
        typedef CComObject<CEnumTypes> CObject;

        CObject* pnew = new CObject;
        if(NULL == pnew)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pnew->Init(pBinding, Key, pType, dwFlags);
            hr = pnew->QueryInterface(IID_IEnumPStoreTypes, (void**)ppv);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}


HRESULT STDMETHODCALLTYPE EnumTypesNext(
    /* [in] */ CEnumTypes *pEnumType,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ GUID __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched)
{
    if ((pceltFetched == NULL) && (celt != 1))
        return E_INVALIDARG;

    DWORD           i;
    PST_CALL_CONTEXT CallContext;
    HRESULT         hr = S_OK;

    __try
    {
        InitCallContext(&CallContext);

        for (i=0;i<celt;i++)
        {

            if (RPC_S_OK != (hr =
                SSEnumTypes(
                    pEnumType->m_pBinding->m_hBind,
                    pEnumType->m_pBinding->m_hProv,
                    CallContext,
                    pEnumType->m_Key,
                    &(rgelt[i]),
                    pEnumType->m_Index,
                    pEnumType->m_dwFlags)))
                goto Ret;

            pEnumType->m_Index++;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:
    __try
    {
        if (pceltFetched != NULL)
            *pceltFetched = i;

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // don't stomp err code
        if (hr == PST_E_OK)
            hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE EnumSubtypesNext(
    /* [in] */ CEnumTypes *pEnumType,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ GUID __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched)
{
    if ((pceltFetched == NULL) && (celt != 1))
        return E_INVALIDARG;

    DWORD   i = 0;
    PST_CALL_CONTEXT CallContext;
    HRESULT hr = S_OK;

    __try
    {
        InitCallContext(&CallContext);

        for (i=0;i<celt;i++)
        {

            if (RPC_S_OK != (hr =
                SSEnumSubtypes(
                    pEnumType->m_pBinding->m_hBind,
                    pEnumType->m_pBinding->m_hProv,
                    CallContext,
                    pEnumType->m_Key,
                    &pEnumType->m_Type,
                    &(rgelt[i]),
                    pEnumType->m_Index,
                    pEnumType->m_dwFlags)))
                goto Ret;

            pEnumType->m_Index++;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:
    __try
    {
        if (pceltFetched != NULL)
            *pceltFetched = i;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // don't stomp hr
        if (hr == PST_E_OK)
            hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CEnumTypes::Next(
    /* [in] */ DWORD celt,
    /* [out][in][size_is] */ GUID __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    __try
    {
        if (m_fEnumSubtypes)
            hr = EnumSubtypesNext(this, celt, rgelt, pceltFetched);
        else
            hr = EnumTypesNext(this, celt, rgelt, pceltFetched);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CEnumTypes::Skip(
/* [in] */ DWORD celt
)
{
    GUID    Guid;
    DWORD   i;
    PST_CALL_CONTEXT CallContext;
    HRESULT hr = S_OK;

    __try
    {
        InitCallContext(&CallContext);

        for (i=0;i<celt;i++)
        {
            if (m_fEnumSubtypes)
            {
                if (RPC_S_OK != (hr = SSEnumTypes(
                        m_pBinding->m_hBind,
                        m_pBinding->m_hProv,
                        CallContext,
                        m_Key,
                        &Guid,
                        m_Index,
                        m_dwFlags)))
                {
                    goto Ret;
                }
            }
            else
            {
                if (RPC_S_OK != (hr = SSEnumSubtypes(
                        m_pBinding->m_hBind,
                        m_pBinding->m_hProv,
                        CallContext,
                        m_Key,
                        &m_Type,
                        &Guid,
                        m_Index++,
                        m_dwFlags)))
                {
                    goto Ret;
                }
            }

            m_Index++;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}


HRESULT STDMETHODCALLTYPE CEnumTypes::Reset( void)
{
    HRESULT hr;
    __try
    {
        m_Index = 0;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CEnumTypes::Clone(
    /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum)
{
    if (ppenum == NULL)
        return E_INVALIDARG;

    GUID    *pType = NULL;
    HRESULT hr;

    __try
    {
        if (m_fEnumSubtypes)
            pType = &m_Type;

        hr = CEnumTypes::CreateObject(m_pBinding->AddRef(), m_Key, pType, m_dwFlags, ppenum);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

// functions exported from the DLL

// PStoreCreateInstance - allows caller to get provider interface
HRESULT
WINAPI
PStoreCreateInstance(
    OUT IPStore **ppProvider,
    IN  PST_PROVIDERID* pProviderID,
    IN  void*  pReserved,
    DWORD dwFlags)
{
    if (ppProvider == NULL)
        return E_INVALIDARG;

    // pProviderID can be NULL, defaults to base provider

    HRESULT     hr = PST_E_FAIL;
    CRPCBinding *pBinding = NULL;

    __try
    {
        GUID IDBaseProvider = MS_BASE_PSTPROVIDER_ID;

        if (0 != dwFlags)
        {
            hr = PST_E_BAD_FLAGS;
            goto Ret;
        }

        // if passed in null, asking for (hardcoded) base provider
        if (pProviderID == NULL)
            pProviderID = &IDBaseProvider;

        pBinding = new CRPCBinding;
        if(NULL == pBinding)
        {
            hr = E_OUTOFMEMORY;
            goto Ret;
        }
        if (RPC_S_OK != (hr = pBinding->Init()))
            goto Ret;

        if (RPC_S_OK != (hr = pBinding->Acquire(pProviderID, pReserved, dwFlags)))
            goto Ret;

        // get an ISecStor interface
        if (S_OK != (hr =
            CPStore::CreateObject(pBinding, ppProvider)) )
            goto Ret;

        hr = PST_E_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:
    __try
    {
        // on err, release binding
        if (hr != PST_E_OK)
        {
            if (pBinding)
                pBinding->Release();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // don't stomp code
        if (hr == PST_E_OK)
            hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

// PStoreEnumProviders - returns an interface for enumerating providers
HRESULT
WINAPI
PStoreEnumProviders(
    DWORD dwFlags,
    IEnumPStoreProviders **ppenum)
{
    HRESULT             hr = PST_E_FAIL;
    CRPCBinding         *pBinding = NULL;

    __try
    {
        pBinding = new CRPCBinding;
        if(NULL == pBinding)
        {
            hr = E_OUTOFMEMORY;
            goto Ret;
        }
        if (S_OK != (hr = pBinding->Init()) )
            goto Ret;

        // get an ISecStor interface
        if (S_OK != (hr = CPStore::CreateObject(pBinding, ppenum)) )
            goto Ret;

        hr = PST_E_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:
    __try
    {
        // on error, release binding
        if (hr != PST_E_OK)
        {
            if (pBinding)
                pBinding->Release();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // don't stomp code
        if (hr == PST_E_OK)
            hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\csecstor\defer.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    defer.cpp

Abstract:

    This module contains routines to perform deferred "on-demand" loading
    of the Protected Storage server.

    Furthermore, this module implements a routine, IsServiceAvailable(),
    which is a high-performance test that can be used to determine if the
    protected storage server is running.  This test is performed prior
    to attempting any more expensive operations against the server (eg,
    RPC binding).

    This defer loading code is only relevant for Protected Storage when
    running on Windows 95.

Author:

    Scott Field (sfield)    23-Jan-97

--*/

#include <windows.h>
#include <wincrypt.h>
#include "pstrpc.h"
#include "pstprv.h"
#include "service.h"
#include "crtem.h"
#include "unicode.h"

#define SERVICE_WAIT_TIMEOUT    (10*1000)   // 10 seconds

BOOL StartService95(VOID);
BOOL GetServiceImagePath95(LPSTR ImagePath, LPDWORD cchImagePath);

BOOL
IsServiceAvailable(VOID)
/*++

    This routine checks to see if the secure storage service is available, to
    avoid causing logon delays if the service is not yet available or has been
    stopped.

    OpenEventA is used to allow this to be callable from WinNT or Win95,
    since the Win95 cred manager also needs this service.

--*/
{
    HANDLE hEvent;
    DWORD dwWaitState;

    if( FIsWinNT5() ) {
        hEvent = OpenEventA(SYNCHRONIZE, FALSE, PST_EVENT_INIT_NT5);
    } else {
        hEvent = OpenEventA(SYNCHRONIZE, FALSE, PST_EVENT_INIT);
    }

    if(hEvent == NULL) {
        //
        // if running on Win95, try to start the server/service
        //

        if(!FIsWinNT())
            return StartService95();

        return FALSE;
    }

    dwWaitState = WaitForSingleObject(hEvent, SERVICE_WAIT_TIMEOUT);

    CloseHandle(hEvent);

    if(dwWaitState != WAIT_OBJECT_0)
        return FALSE;

    return TRUE;
}

BOOL
StartService95(VOID)
{
    HANDLE hEvent;
    DWORD dwWaitState;

    CHAR ServicePath[MAX_PATH+1];
    DWORD cchServicePath = MAX_PATH;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD dwWaitTimeout = 2500;
    BOOL bSuccess = FALSE;

    //
    // create + check status of service init flag.
    //

    hEvent = CreateEventA(
            NULL,
            TRUE,
            FALSE,
            PST_EVENT_INIT
            );

    if(hEvent == NULL)
        return FALSE;

    //
    // check for race condition with multiple callers creating event.
    //

    if(GetLastError() == ERROR_ALREADY_EXISTS) {
        WaitForSingleObject( hEvent, SERVICE_WAIT_TIMEOUT );
        CloseHandle(hEvent);
        return TRUE;
    }


    if(!GetServiceImagePath95(ServicePath, &cchServicePath)) {
        CloseHandle(hEvent);
        return FALSE;
    }


    ZeroMemory(&si, sizeof(si));

    bSuccess = CreateProcessA(
        ServicePath,
        NULL,
        NULL,
        NULL,
        FALSE,
        DETACHED_PROCESS,
        NULL,
        NULL,
        &si,
        &pi
        );

    if(bSuccess) {
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);

        dwWaitTimeout = SERVICE_WAIT_TIMEOUT;
    }

    dwWaitState = WaitForSingleObject(hEvent, dwWaitTimeout);
    if(dwWaitState != WAIT_OBJECT_0)
        bSuccess = FALSE;

    CloseHandle(hEvent);

    return bSuccess;
}

BOOL
GetServiceImagePath95(
    LPSTR ImagePath,
    LPDWORD cchImagePath // IN, OUT
    )
{
    HKEY hBaseKey = NULL;
    LPCWSTR ServicePath = L"SYSTEM\\CurrentControlSet\\Services\\" SZSERVICENAME L"\\Parameters";
    DWORD dwCreate;
    DWORD dwType;
    LONG lRet;

    lRet = RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            ServicePath,
            0,
            NULL,                       // address of class string 
            0,
            KEY_QUERY_VALUE,
            NULL,
            &hBaseKey,
            &dwCreate);

    if(lRet == ERROR_SUCCESS) {

        lRet = RegQueryValueExA(
                hBaseKey,
                "ImagePath",
                NULL,
                &dwType,
                (PBYTE)ImagePath,
                cchImagePath);
    }

    if(hBaseKey)
        RegCloseKey(hBaseKey);

    if(lRet != ERROR_SUCCESS) {
        SetLastError((DWORD)lRet);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\common\rules.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    rules.cpp

Abstract:

    This module contains routines to perform client side marshalling of
    access clause data structures for Protected Storage.

    Additional fixup is performed for some cases, for example, if a client
    provides a security descriptor, the security descriptor is fixed-up
    to have all necessary fields, such as owner and primary group sids.

Author:

    Scott Field (sfield)    13-Feb-97

--*/

#include <windows.h>

#include "pstrpc.h"
#include "pstdef.h"

#include "crtem.h"

#include "rules.h"
#include "debug.h"


BOOL
SetClauseDataAbsolute(
    IN  PST_ACCESSCLAUSETYPE ClauseType,
    IN  LPBYTE ClauseData
    );

BOOL
SetClauseDataSelfRelative(
    IN  PST_ACCESSCLAUSETYPE ClauseType,
    IN  LPBYTE OldClauseData,
    IN  LPBYTE *NewClauseData,
    OUT DWORD *cbNewClauseData
    );

BOOL
SecurityDescriptorToSelfRelative(
    PSECURITY_DESCRIPTOR pSD,       // existing security descriptor
    PSECURITY_DESCRIPTOR *pNewSD,   // newly allocated self-relative copy
    DWORD *pcbNewSD
    );



// get the length of the entire ruleset structure
BOOL GetLengthOfRuleset(
    IN PPST_ACCESSRULESET pRules,
    OUT DWORD *pcbRules
    )
{
    DWORD cRules;
    DWORD cClauses;
    PST_ACCESSCLAUSE* pClause;

    __try {

    *pcbRules = 0;
    for (cRules=0; cRules<pRules->cRules; cRules++)
    {
        // for each Rule in Rules, walk all clauses and add assoc cb
        for (cClauses=0; cClauses<pRules->rgRules[cRules].cClauses; cClauses++)
        {
            pClause = &pRules->rgRules[cRules].rgClauses[cClauses];

            *pcbRules += pClause->cbClauseData + sizeof(PST_ACCESSCLAUSE);
        }

        *pcbRules += sizeof(PST_ACCESSRULE);
    }

    // now add in Rules struct
    *pcbRules += sizeof(PST_ACCESSRULESET);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }

    return TRUE;
}

// set up the rules to be output
BOOL MyCopyOfRuleset(
    IN PPST_ACCESSRULESET pRulesIn,
    OUT PPST_ACCESSRULESET pRulesOut
    )
{
    DWORD               cRules;
    DWORD               cClauses;
    PST_ACCESSCLAUSE*   pClauseIn;
    PST_ACCESSCLAUSE*   pClauseOut;
    BYTE                *pb = (BYTE*)(pRulesOut) + sizeof(PST_ACCESSRULESET);

    
    // ASSERT size member
    SS_ASSERT(pRulesIn->cbSize == sizeof(PST_ACCESSRULESET));

    pRulesOut->cbSize = pRulesIn->cbSize;
    pRulesOut->cRules = pRulesIn->cRules;
    pRulesOut->rgRules = (PST_ACCESSRULE*)pb;
    pb += pRulesOut->cRules * sizeof(PST_ACCESSRULE);

    for (cRules=0; cRules<pRulesOut->cRules; cRules++)
    {
        // ASSERT size member
        SS_ASSERT(pRulesIn->rgRules[cRules].cbSize == sizeof(PST_ACCESSRULE));

        pRulesOut->rgRules[cRules].cbSize = pRulesIn->rgRules[cRules].cbSize;
        pRulesOut->rgRules[cRules].AccessModeFlags = pRulesIn->rgRules[cRules].AccessModeFlags;
        pRulesOut->rgRules[cRules].cClauses = pRulesIn->rgRules[cRules].cClauses;
        pRulesOut->rgRules[cRules].rgClauses = (PST_ACCESSCLAUSE*)pb;
        pb += pRulesOut->rgRules[cRules].cClauses * sizeof(PST_ACCESSCLAUSE);

        // for each Rule in Rules, walk all clauses and free assoc pb
        for (cClauses=0; cClauses<pRulesOut->rgRules[cRules].cClauses; cClauses++)
        {
            pClauseIn = &pRulesIn->rgRules[cRules].rgClauses[cClauses];
            pClauseOut = &pRulesOut->rgRules[cRules].rgClauses[cClauses];

            // ASSERT size member
            SS_ASSERT(pClauseIn->cbSize == sizeof(PST_ACCESSCLAUSE));

            pClauseOut->cbSize = pClauseIn->cbSize;
            pClauseOut->ClauseType = pClauseIn->ClauseType;
            pClauseOut->cbClauseData = pClauseIn->cbClauseData;
            if (0 != pClauseOut->cbClauseData)
            {
                pClauseOut->pbClauseData = (BYTE*)pb;
                CopyMemory(pClauseOut->pbClauseData, pClauseIn->pbClauseData, pClauseOut->cbClauseData);
                pb += pClauseOut->cbClauseData;

                // translate self-relative rule data to absolute format
                if (pClauseOut->ClauseType & PST_SELF_RELATIVE_CLAUSE) {
                    SetClauseDataAbsolute(pClauseOut->ClauseType, pClauseOut->pbClauseData);
                    pClauseOut->ClauseType &= ~PST_SELF_RELATIVE_CLAUSE;
                }
            }
        }
    }

    return TRUE;
}



BOOL
SetClauseDataAbsolute(
    IN  PST_ACCESSCLAUSETYPE ClauseType,
    IN  LPBYTE ClauseData
    )
/*++
    Translate self-relative format clause data to absolute format clause data.
--*/
{
    switch (ClauseType & ~PST_SELF_RELATIVE_CLAUSE)
    {
        case PST_AUTHENTICODE:
        {
            PST_AUTHENTICODEDATA *pNewCheckData = (PST_AUTHENTICODEDATA *)ClauseData;
            LPBYTE Target;

            if(pNewCheckData->cbSize != sizeof(PST_AUTHENTICODEDATA))
                break;

            pNewCheckData->szRootCA = (LPWSTR)((LPBYTE)(pNewCheckData->szRootCA) + (DWORD_PTR)pNewCheckData);
            pNewCheckData->szIssuer = (LPWSTR)((LPBYTE)(pNewCheckData->szIssuer) + (DWORD_PTR)pNewCheckData);
            pNewCheckData->szPublisher = (LPWSTR)((LPBYTE)(pNewCheckData->szPublisher) + (DWORD_PTR)pNewCheckData);
            pNewCheckData->szProgramName = (LPWSTR)((LPBYTE)(pNewCheckData->szProgramName) + (DWORD_PTR)pNewCheckData);

            return TRUE;
        }

        case PST_BINARY_CHECK:
        {
            PST_BINARYCHECKDATA *pNewCheckData = (PST_BINARYCHECKDATA *)ClauseData;

            if(pNewCheckData->cbSize != sizeof(PST_BINARYCHECKDATA))
                break;

            pNewCheckData->szFilePath = (LPWSTR)((LPBYTE)(pNewCheckData->szFilePath) + (DWORD_PTR)pNewCheckData);

            return TRUE;
        }

        case PST_SECURITY_DESCRIPTOR:
        {
            PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR)ClauseData;

            // note: security descriptor translation not relevant, as
            // Win32 API calls accept self-relative or absolute format
            // security descriptors
            //

            if(!IsValidSecurityDescriptor(pSD))
                break;

            return TRUE;
        }

        //
        // note: default just falls through
    }

    SetLastError((DWORD)PST_E_INVALID_RULESET);
    return FALSE;
}


BOOL
SetClauseDataSelfRelative(
    IN  PST_ACCESSCLAUSETYPE ClauseType,
    IN  LPBYTE OldClauseData,
    IN  LPBYTE *NewClauseData,
    OUT DWORD *cbNewClauseData
    )
/*++
    Translate absolute format clause data to self-relative format clause data.
--*/
{
    switch (ClauseType)
    {
        case PST_AUTHENTICODE:
        {
            PST_AUTHENTICODEDATA *pOldCheckData = (PST_AUTHENTICODEDATA *)OldClauseData;
            PST_AUTHENTICODEDATA *pNewCheckData;
            DWORD cbCheckData;
            DWORD cbRoot;
            DWORD cbIssuer;
            DWORD cbPublisher;
            DWORD cbProgramName;
            LPBYTE Target;

            if(pOldCheckData->cbSize != sizeof(PST_AUTHENTICODEDATA))
                break;

            cbRoot = (lstrlenW(pOldCheckData->szRootCA) + 1) * sizeof(WCHAR);
            cbIssuer = (lstrlenW(pOldCheckData->szIssuer) + 1) * sizeof(WCHAR);
            cbPublisher = (lstrlenW(pOldCheckData->szPublisher) + 1) * sizeof(WCHAR);
            cbProgramName = (lstrlenW(pOldCheckData->szProgramName) + 1) * sizeof(WCHAR);

            cbCheckData = sizeof(PST_AUTHENTICODEDATA) +
                            cbRoot + cbIssuer + cbPublisher + cbProgramName;

            pNewCheckData = (PST_AUTHENTICODEDATA *)RulesAlloc(cbCheckData);
            if(pNewCheckData == NULL) {
                // TODO memory failure error code
                break;
            }

            ZeroMemory(pNewCheckData, cbCheckData);

            pNewCheckData->cbSize = pOldCheckData->cbSize;
            pNewCheckData->dwModifiers = pOldCheckData->dwModifiers;

            pNewCheckData->szRootCA = (LPWSTR)((UINT_PTR)sizeof(PST_AUTHENTICODEDATA)) ;
            pNewCheckData->szIssuer = (LPWSTR)((LPBYTE)pNewCheckData->szRootCA + cbRoot);
            pNewCheckData->szPublisher = (LPWSTR)((LPBYTE)pNewCheckData->szIssuer + cbIssuer);
            pNewCheckData->szProgramName = (LPWSTR)((LPBYTE)pNewCheckData->szPublisher + cbPublisher);

            if(pOldCheckData->szRootCA) {
                Target = (LPBYTE)pNewCheckData->szRootCA + (DWORD_PTR)pNewCheckData;
                CopyMemory(Target, pOldCheckData->szRootCA, cbRoot);
            }

            if(pOldCheckData->szIssuer) {
                Target = (LPBYTE)pNewCheckData->szIssuer + (DWORD_PTR)pNewCheckData;
                CopyMemory(Target, pOldCheckData->szIssuer, cbIssuer);
            }

            if(pOldCheckData->szPublisher) {
                Target = (LPBYTE)pNewCheckData->szPublisher + (DWORD_PTR)pNewCheckData;
                CopyMemory(Target, pOldCheckData->szPublisher, cbPublisher);
            }

            if(pOldCheckData->szProgramName) {
                Target = (LPBYTE)pNewCheckData->szProgramName + (DWORD_PTR)pNewCheckData;
                CopyMemory(Target, pOldCheckData->szProgramName, cbProgramName);
            }

            *NewClauseData = (LPBYTE)pNewCheckData;
            *cbNewClauseData = cbCheckData;

            return TRUE;
        }

        case PST_BINARY_CHECK:
        {
            PST_BINARYCHECKDATA *pOldCheckData = (PST_BINARYCHECKDATA *)OldClauseData;
            PST_BINARYCHECKDATA *pNewCheckData;
            DWORD cbCheckData;
            DWORD cbFileName = 0;

            if(pOldCheckData->cbSize != sizeof(PST_BINARYCHECKDATA))
                break;

            //
            // get length of szFilePath member, in bytes
            //

            if(pOldCheckData->szFilePath)
                cbFileName = lstrlenW(pOldCheckData->szFilePath);

            cbFileName = (cbFileName + 1) * sizeof(WCHAR); // always room for NULL

            cbCheckData = sizeof(PST_BINARYCHECKDATA) + cbFileName;

            pNewCheckData = (PST_BINARYCHECKDATA *)RulesAlloc(cbCheckData);
            if(pNewCheckData == NULL) {
                // TODO memory failure error code
                break;
            }

            ZeroMemory(pNewCheckData, cbCheckData);

            pNewCheckData->cbSize = pOldCheckData->cbSize;
            pNewCheckData->dwModifiers = pOldCheckData->dwModifiers;
            pNewCheckData->szFilePath = (LPWSTR)(pNewCheckData + 1);

            if(pOldCheckData->szFilePath)
                CopyMemory((LPWSTR)(pNewCheckData->szFilePath), pOldCheckData->szFilePath, cbFileName);

            // make file name pointer offset from structure
            pNewCheckData->szFilePath = (LPWSTR)((LPBYTE)pNewCheckData->szFilePath - (DWORD_PTR)pNewCheckData);

            *NewClauseData = (LPBYTE)pNewCheckData;
            *cbNewClauseData = cbCheckData;

            return TRUE;
        }

        case PST_SECURITY_DESCRIPTOR:
        {
            PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR)OldClauseData;
            PSECURITY_DESCRIPTOR pNewSD;

            // TODO:
            // 1. translate absolute to self-relative, if necessary
            // 2. fill in owner and group Sid's, if NULL
            //

            if(!SecurityDescriptorToSelfRelative(pSD, &pNewSD, cbNewClauseData))
                break;

            *NewClauseData = (LPBYTE)pNewSD;

            return TRUE;
        }

        //
        // note: default just falls through
    }

    SetLastError((DWORD)PST_E_INVALID_RULESET);
    return FALSE;
}


BOOL
SecurityDescriptorToSelfRelative(
    PSECURITY_DESCRIPTOR pSD,       // existing security descriptor
    PSECURITY_DESCRIPTOR *pNewSD,   // newly allocated self-relative copy
    DWORD *pcbNewSD
    )
/*++
    This routine takes as input in the pSD parameter a pointer to a Windows NT
    security descriptor.  This descriptor can be in either self-relative or
    absolute format, and does not need to contain any particular fields - in
    particular, the owner and group Sids do not need to be present.

    The input security descriptor is parsed and copied as appropriate in order
    to allocate and build a new security descriptor which is output in the
    pNewSD parameter.  If the input security descriptor did not contain valid
    owner or group Sids, the default Sids are obtained from the calling thread
    or process access token.

    The output security descriptor will be in self-relative format and will
    contain as many valid fields as the input security descriptor, plus the
    missing (now defaulted) owner and group Sids if necessary.

    The owner and group Sids must be present so that the server side component
    can succesfully call the AccessCheck() API against the persisted security
    descriptor.  The security descriptor must be in self-relative format
    to allow easy transport in both directions across RPC.

    On success, the DWORD pointed to by the pcbNewSD parameter is filled with
    the size of the output security descriptor supplied in the alloc'd
    pNewSD buffer.

--*/
{
    SECURITY_DESCRIPTOR_CONTROL SDControl;
    DWORD dwRevision;
    DWORD cbSD;
    DWORD cbNewSD;

    PSID pGroupSid;
    PSID pOwnerSid;
    BOOL bDefaulted;

    HANDLE hToken = NULL;
    PTOKEN_OWNER pTokenOwner;
    PTOKEN_PRIMARY_GROUP pTokenGroup;
    BYTE FastOwner[128];
    BYTE FastGroup[128];
    PTOKEN_OWNER SlowOwner = NULL;
    PTOKEN_PRIMARY_GROUP SlowGroup = NULL;
    DWORD cbTokenInfo;

    PSECURITY_DESCRIPTOR pTempSD = NULL;
    BOOL bSaclPresent;
    BOOL bDaclPresent;
    PACL pSacl;
    PACL pDacl;

    BOOL bSuccess = FALSE;

    if(!IsValidSecurityDescriptor(pSD))
        return FALSE;

    if(!GetSecurityDescriptorControl(pSD, &SDControl, &dwRevision))
        return FALSE;

    if(!GetSecurityDescriptorOwner(pSD, &pGroupSid, &bDefaulted))
        return FALSE;

    if(!GetSecurityDescriptorGroup(pSD, &pOwnerSid, &bDefaulted))
        return FALSE;

    //
    // three possible scenarios:
    // 1. input security descriptor does not contain owner or group Sids,
    //    necessary for AccessCheck()
    //    prepare default owner and group sids and insert into new
    //    security descriptor.  continue to 2...
    // 2. input security descriptor in absolute format, rather than self-relative.
    //    convert to self-relative format.
    // 3. neither 1 nor 2 apply - a rare case for somebody to supply a
    //    security descriptor in self relative format containing all the necessary
    //    elements.
    //    In this case, just make a copy of the input security descriptor.
    //

    if(pGroupSid == NULL || pOwnerSid == NULL) {

        //
        // grab defaults from token
        //

        if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken)) {
            if(GetLastError() != ERROR_NO_TOKEN)
                return FALSE;

            // no thread token present, try process token
            if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
                return FALSE;
        }

        if(pOwnerSid == NULL) {

            // try fast buffer first
            pTokenOwner = (PTOKEN_OWNER)FastOwner;
            cbTokenInfo = sizeof(FastOwner);

            if(!GetTokenInformation(
                    hToken,
                    TokenOwner,
                    pTokenOwner,
                    cbTokenInfo,
                    &cbTokenInfo
                    )) {

                //
                // retry with larger buffer if appropriate
                //

                if(GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                    goto cleanup;

                SlowOwner = (PTOKEN_OWNER)HeapAlloc(GetProcessHeap(), 0, cbTokenInfo);
                if(SlowOwner == NULL)
                    goto cleanup;

                pTokenOwner = (PTOKEN_OWNER)SlowOwner;

                if(!GetTokenInformation(
                        hToken,
                        TokenOwner,
                        pTokenOwner,
                        cbTokenInfo,
                        &cbTokenInfo
                        )) goto cleanup;
            }

            pOwnerSid = pTokenOwner->Owner;
        }

        if(pGroupSid == NULL) {

            // try fast buffer first
            pTokenGroup = (PTOKEN_PRIMARY_GROUP)FastGroup;
            cbTokenInfo = sizeof(FastGroup);

            if(!GetTokenInformation(
                    hToken,
                    TokenPrimaryGroup,
                    pTokenGroup,
                    cbTokenInfo,
                    &cbTokenInfo
                    )) {

                //
                // retry with larger buffer if appropriate
                //

                if(GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                    goto cleanup;

                SlowGroup = (PTOKEN_PRIMARY_GROUP)HeapAlloc(GetProcessHeap(), 0, cbTokenInfo);
                if(SlowGroup == NULL)
                    goto cleanup;

                pTokenGroup = (PTOKEN_PRIMARY_GROUP)SlowGroup;

                if(!GetTokenInformation(
                        hToken,
                        TokenPrimaryGroup,
                        pTokenGroup,
                        cbTokenInfo,
                        &cbTokenInfo
                        )) goto cleanup;
            }

            pGroupSid = pTokenGroup->PrimaryGroup;
        }
    } // if owner || group == null
    else if( SDControl & SE_SELF_RELATIVE ) {

        //
        // owner and group Sids valid, AND
        // descriptor is in self-relative format!
        // reward the caller by doing a simple alloc + memory copy
        //

        cbNewSD = GetSecurityDescriptorLength(pSD);

        *pNewSD = (PSECURITY_DESCRIPTOR)RulesAlloc(cbNewSD);
        if(*pNewSD == NULL)
            goto cleanup;

        CopyMemory(*pNewSD, pSD, cbNewSD);

        *pcbNewSD = cbNewSD;
        bSuccess = TRUE;
        goto cleanup;
    }

    if(!GetSecurityDescriptorDacl(pSD, &bDaclPresent, &pDacl, &bDefaulted))
        goto cleanup;

    if(!GetSecurityDescriptorSacl(pSD, &bSaclPresent, &pSacl, &bDefaulted))
        goto cleanup;

    //
    // copy old SD to a new temporary SD, filling in everything as we go.
    //

    cbNewSD = sizeof(SECURITY_DESCRIPTOR);
    cbNewSD += GetLengthSid(pGroupSid);
    cbNewSD += GetLengthSid(pOwnerSid);

    ACL_SIZE_INFORMATION AclInfo;

    if(bDaclPresent && pDacl != NULL) {
        if(!GetAclInformation(pDacl, &AclInfo, sizeof(AclInfo), AclSizeInformation))
            goto cleanup;

        cbNewSD += (AclInfo.AclBytesInUse + AclInfo.AclBytesFree);
    }

    if(bSaclPresent && pSacl != NULL) {
        if(!GetAclInformation(pSacl, &AclInfo, sizeof(AclInfo), AclSizeInformation))
            goto cleanup;

        cbNewSD += (AclInfo.AclBytesInUse + AclInfo.AclBytesFree);
    }

    pTempSD = (PSECURITY_DESCRIPTOR)HeapAlloc(GetProcessHeap(), 0, cbNewSD);
    if(pTempSD == NULL)
        goto cleanup;

    if(!InitializeSecurityDescriptor(pTempSD, SECURITY_DESCRIPTOR_REVISION))
        goto cleanup;

    if(!SetSecurityDescriptorDacl(pTempSD, bDaclPresent, pDacl, FALSE))
        goto cleanup;

    if(!SetSecurityDescriptorSacl(pTempSD, bSaclPresent, pSacl, FALSE))
        goto cleanup;

    if(!SetSecurityDescriptorOwner(pTempSD, pOwnerSid, FALSE))
        goto cleanup;

    if(!SetSecurityDescriptorGroup(pTempSD, pGroupSid, FALSE))
        goto cleanup;

    //
    // make the security descriptor self-relative and give it back to the
    // caller.
    //

    *pNewSD = (PSECURITY_DESCRIPTOR)RulesAlloc(cbNewSD);
    if(*pNewSD == NULL)
        goto cleanup;

    bSuccess = MakeSelfRelativeSD(pTempSD, *pNewSD, &cbNewSD);

    *pcbNewSD = cbNewSD;

cleanup:

    if(hToken != NULL)
        CloseHandle(hToken);

    if(SlowOwner != NULL)
        HeapFree(GetProcessHeap(), 0, SlowOwner);

    if(SlowGroup != NULL)
        HeapFree(GetProcessHeap(), 0, SlowGroup);

    if(pTempSD != NULL)
        HeapFree(GetProcessHeap(), 0, pTempSD);

    if(!bSuccess && *pNewSD != NULL) {
        RulesFree(*pNewSD);
        *pNewSD = NULL;
    }

    return bSuccess;
}

BOOL RulesRelativeToAbsolute(
    IN PPST_ACCESSRULESET pRules)
{
    PST_ACCESSRULE*     pRule;
    PST_ACCESSCLAUSE*   pClause;

    DWORD               cRules;
    DWORD               cClauses;

    // short circuit
    if (pRules == NULL)
        return TRUE;

    for (cRules=0; cRules<pRules->cRules; cRules++)
    {
        // point to this rule list
        pRule = &pRules->rgRules[cRules];

        // for each Rule in Rules, walk all clauses
        for (cClauses=0; cClauses<pRule->cClauses; cClauses++)
        {
            // point to this clause
            pClause = &pRule->rgClauses[cClauses];

            // if there is data, do translation
            if (0 != pClause->cbClauseData)
            {
                // translate self-relative rule data to absolute format
                if(pClause->ClauseType & PST_SELF_RELATIVE_CLAUSE)
                {
                    SetClauseDataAbsolute(pClause->ClauseType, pClause->pbClauseData);
                    pClause->ClauseType &= ~PST_SELF_RELATIVE_CLAUSE;
                }
            }
        }
    }

    return TRUE;
}

// fixup clause data within rule structure
BOOL RulesAbsoluteToRelative(
    IN PPST_ACCESSRULESET NewRules
    )
{
    PPST_ACCESSRULESET pRules = NewRules;
    DWORD cRules;
    DWORD cClauses;
    PST_ACCESSCLAUSE* pClause;
    BOOL bSuccess = TRUE; // assume success

    // short circuit
    if (pRules == NULL)
        return TRUE;

    for (cRules=0; cRules<pRules->cRules; cRules++)
    {
        for (cClauses=0; cClauses<pRules->rgRules[cRules].cClauses; cClauses++)
        {
            pClause = &pRules->rgRules[cRules].rgClauses[cClauses];

            if( pClause->cbClauseData &&
                !(pClause->ClauseType & PST_SELF_RELATIVE_CLAUSE) ) {

                LPBYTE OldData = pClause->pbClauseData;
                LPBYTE NewData = NULL;
                DWORD cbNewClauseData;

                if(!SetClauseDataSelfRelative(pClause->ClauseType, OldData, &NewData, &cbNewClauseData)) {
                    pClause->pbClauseData = NULL; // invalidate existing data
                    bSuccess = FALSE;
                }

                pClause->ClauseType |= PST_SELF_RELATIVE_CLAUSE;
                pClause->pbClauseData = NewData;
                pClause->cbClauseData = cbNewClauseData; // fixup size
            }
        }
    }

    if(!bSuccess)
        FreeClauseDataRelative(NewRules);

    return bSuccess;
}

// free allocated clause data in relative format
void FreeClauseDataRelative(
    IN PPST_ACCESSRULESET NewRules
    )
{
    PPST_ACCESSRULESET pRules = NewRules;
    DWORD cRules;
    DWORD cClauses;
    PST_ACCESSCLAUSE* pClause;

    // short circuit
    if (pRules == NULL)
        return;

    for (cRules=0; cRules<pRules->cRules; cRules++)
    {
        // for each Rule in Ruleset, walk all clauses and free assoc pb
        for (cClauses=0; cClauses<pRules->rgRules[cRules].cClauses; cClauses++)
        {
            pClause = &pRules->rgRules[cRules].rgClauses[cClauses];

            if (pClause->pbClauseData)
            {
                RulesFree(pClause->pbClauseData);
                pClause->pbClauseData = NULL;
            }
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\csecstor\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by csecstor.rc
//
#define IDS_CPSTORE_DESC                1
#define IDS_CENUMTYPES_DESC             2
#define IDS_CENUMITEMS_DESC             3

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\csecstor\csecstor.cpp ===
// CSecStor.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f ISecStorps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "pstypes.h"
#include "pstorec.h"
#include "CSecStr1.h"

#define IID_DEFINED
#include "PStorec_i.c"

#include "unicode.h"
#include <wincrypt.h>

#include "pstprv.h" // MODULE_RAISE_COUNT

BOOL
RaiseRefCount(
    VOID
    );

BOOL
LowerRefCount(
    VOID
    );

LONG g_lRefCount = 1;
HMODULE g_hModule = NULL;


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CPStore, CPStore)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);


        // begin    HACK HACK HACK

        // fix for rpcrt4 load/free memory leak...
        // bug is actually in rpcrt4 dependencies: user32, advapi

        // load module. DON'T FREE IT, causes reload leaks
        LoadLibrary("rpcrt4.dll");

        // note: NT, Win95 srcs checked -- neither will overflow 4G refcount

        // end      HACK HACK HACK

        RaiseRefCount();
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();

        LowerRefCount();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}

//
// overload new and delete so we don't need to bring in full CRT
//

#if 0
void * __cdecl operator new(size_t cb)
{
    return HeapAlloc(GetProcessHeap(), 0, cb);
}

void __cdecl operator delete(void * pv)
{
    HeapFree(GetProcessHeap(), 0, pv);
}

#ifndef DBG

void * __cdecl malloc(size_t cb)
{
    return HeapAlloc(GetProcessHeap(), 0, cb);
}

void __cdecl free(void * pv)
{
    HeapFree(GetProcessHeap(), 0, pv);
}

void * __cdecl realloc(void * pv, size_t cb)
{
    if(pv == NULL)
        return malloc(cb);

    return HeapReAlloc(GetProcessHeap(), 0, pv, cb);
}

#endif
#endif

//
// provide allocator for rule allocation routines.
//

LPVOID
RulesAlloc(
    IN      DWORD cb
    )
{
    return CoTaskMemAlloc( cb );
}

VOID
RulesFree(
    IN      LPVOID pv
    )
{
    CoTaskMemFree( pv );
}


BOOL
RaiseRefCount(
    VOID
    )
{
    WCHAR szFileName[ MAX_PATH + 1 ];
    HMODULE hModule;
    LONG i;
    BOOL fSuccess = TRUE;

    if(GetModuleFileNameU( NULL, szFileName, MAX_PATH ) == 0)
        return FALSE;

    for ( i = 0 ; i < MODULE_RAISE_COUNT ; i++ ) {
        hModule = LoadLibraryU(szFileName);
        if(hModule == NULL) {
            fSuccess = FALSE;
            break;
        }

        InterlockedIncrement( &g_lRefCount );
    }

    if(hModule != NULL)
        g_hModule = hModule;

    return fSuccess;
}

BOOL
LowerRefCount(
    VOID
    )
{
    BOOL fSuccess = TRUE;

    if( g_hModule == NULL )
        return FALSE;

    while ( InterlockedDecrement( &g_lRefCount ) > 0 ) {
        if(!FreeLibrary( g_hModule )) {
            fSuccess = FALSE;
            break;
        }
    }

    InterlockedIncrement( &g_lRefCount );

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\csecstor\csecstr1.h ===
// CSecStr1.h : Declaration of the CSecStor


#include "resource.h"       // main symbols
#include "pstypes.h"
#include "pstrpc.h"


class CRPCBinding
{
private:
    DWORD m_dwRef;
    BOOL m_fGoodHProv;
    
public:
    LPWSTR m_wszStringBinding;
    RPC_BINDING_HANDLE m_hBind;
    PST_PROVIDER_HANDLE m_hProv;

    CRPCBinding();
    ~CRPCBinding();
    HRESULT Init();
    HRESULT Acquire(
                 IN PPST_PROVIDERID pProviderID,
                 IN PVOID pReserved,
                 IN DWORD dwFlags
                 );
    CRPCBinding *AddRef();
    void Release();
};

/////////////////////////////////////////////////////////////////////////////
// CPStore

class CPStore : 
	public IEnumPStoreProviders,
	public IPStore,
	public CComObjectRoot,
	public CComCoClass<CPStore,&CLSID_CPStore>
{
private:
    CRPCBinding *m_pBinding;
    DWORD m_Index;

public:
	CPStore();
	~CPStore();
    void Init(
              CRPCBinding *pBinding
              );
    static HRESULT CreateObject(
            CRPCBinding *pBinding,
            IPStore **ppv
            );
    static HRESULT CreateObject(
            CRPCBinding *pBinding,
            IEnumPStoreProviders **ppv
            );

BEGIN_COM_MAP(CPStore)
	COM_INTERFACE_ENTRY(IEnumPStoreProviders)
	COM_INTERFACE_ENTRY(IPStore)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CPStore) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CPStore, _T("CPStore1.CPStore.1"), _T("CPStore1.CPStore"), IDS_CPSTORE_DESC, THREADFLAGS_BOTH)

// IEnumSecureProviders
virtual HRESULT STDMETHODCALLTYPE Next( 
    /* [in] */ DWORD celt,
    /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

virtual HRESULT STDMETHODCALLTYPE Skip( 
    /* [in] */ DWORD celt);

virtual HRESULT STDMETHODCALLTYPE Reset( void);

virtual HRESULT STDMETHODCALLTYPE Clone( 
    /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);
        
// ISecureProvider
virtual HRESULT STDMETHODCALLTYPE GetInfo( 
    /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties);

virtual HRESULT STDMETHODCALLTYPE GetProvParam( 
    /* [in] */ DWORD dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [out] */ BYTE __RPC_FAR **ppbData,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE SetProvParam( 
    /* [in] */ DWORD dwParam,
    /* [in] */ DWORD cbData,
    /* [in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ DWORD dwFlags);
        
virtual HRESULT STDMETHODCALLTYPE CreateType( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ DWORD dwFlags);
        
virtual HRESULT STDMETHODCALLTYPE GetTypeInfo( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE DeleteType( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE CreateSubtype( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE GetSubtypeInfo( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE DeleteSubtype( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE ReadAccessRuleset( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
    /* [in] */ DWORD dwFlags);
        
virtual HRESULT STDMETHODCALLTYPE WriteAccessRuleset( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);
        
virtual HRESULT STDMETHODCALLTYPE EnumTypes( 
    /* [in] */ PST_KEY Key,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum
    );

virtual HRESULT STDMETHODCALLTYPE EnumSubtypes( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum
    );
        
virtual HRESULT STDMETHODCALLTYPE DeleteItem( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE ReadItem( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [out][in] */ DWORD __RPC_FAR *pcbData,
    /* [out][size_is] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE WriteItem( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD cbData,
    /* [in][size_is] */ BYTE __RPC_FAR *pbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwDefaultConfirmationStyle,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE OpenItem( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PST_ACCESSMODE ModeFlags,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE CloseItem( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE EnumItems( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum
    );
        
public:
};


// CEnumTypes
class CEnumTypes : 
	public IEnumPStoreTypes,
	public CComObjectRoot,
	public CComCoClass<CEnumTypes,&CLSID_CEnumTypes>
{
public:
    CRPCBinding *m_pBinding;
    PST_KEY m_Key;
    DWORD m_Index;
    DWORD m_dwFlags;
    GUID m_Type;
    BOOL m_fEnumSubtypes;

public:
	CEnumTypes();
	~CEnumTypes();
    void Init(
              CRPCBinding *pBinding,
              PST_KEY Key,
              const GUID *pType,
              DWORD dwFlags
              );
    static HRESULT CreateObject(
              CRPCBinding *pBinding,
              PST_KEY Key,
              const GUID *pType,
              DWORD dwFlags, 
              IEnumPStoreTypes **ppv
              );

BEGIN_COM_MAP(CEnumTypes)
	COM_INTERFACE_ENTRY(IEnumPStoreTypes)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CEnumTypes) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CEnumTypes, _T("CEnumTypes1.CEnumTypes.1"), _T("CEnumTypes1.CEnumTypes"), IDS_CENUMTYPES_DESC, THREADFLAGS_BOTH)


virtual HRESULT STDMETHODCALLTYPE Next( 
    /* [in] */ DWORD celt,
    /* [out][in][size_is] */ GUID __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

virtual HRESULT STDMETHODCALLTYPE Clone( 
    /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);
        
virtual HRESULT STDMETHODCALLTYPE Skip( 
    /* [in] */ DWORD celt);

virtual HRESULT STDMETHODCALLTYPE Reset( void);

};

// CEnumItems
class CEnumItems : 
	public IEnumPStoreItems,
	public CComObjectRoot,
	public CComCoClass<CEnumItems,&CLSID_CEnumItems>
{
private:
    CRPCBinding *m_pBinding;
    PST_KEY m_Key;
    DWORD m_Index;
    DWORD m_dwFlags;
    GUID m_Type;
    GUID m_Subtype;

public:
	CEnumItems();
	~CEnumItems();
    void Init(
              CRPCBinding *pBinding,
              PST_KEY Key,
              const GUID *pType,
              const GUID *pSubtype,
              DWORD dwFlags
              );
    static HRESULT CreateObject(
                  CRPCBinding *pBinding,
                  PST_KEY Key,
                  const GUID *pType,
                  const GUID *pSubtype,
                  DWORD dwFlags,
                  IEnumPStoreItems **ppv
                  );

BEGIN_COM_MAP(CEnumItems)
	COM_INTERFACE_ENTRY(IEnumPStoreItems)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CPStore) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CEnumItems, _T("CEnumItems1.CEnumItems.1"), _T("CEnumItems1.CEnumItems"), IDS_CENUMITEMS_DESC, THREADFLAGS_BOTH)


virtual HRESULT STDMETHODCALLTYPE Next( 
    /* [in] */ DWORD celt,
    /* [out][size_is] */ LPWSTR __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

virtual HRESULT STDMETHODCALLTYPE Clone( 
    /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);
        
virtual HRESULT STDMETHODCALLTYPE Skip( 
    /* [in] */ DWORD celt);

virtual HRESULT STDMETHODCALLTYPE Reset( void);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\csecstor\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\csecstor\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\capiprim.cpp ===
/*
    File:       capiprim.cpp

    Title:      Cryptographic Primitives using CryptoAPI
    Author:     Matt Thomlinson
    Date:       11/22/96

    Functions in this module:

    FMyPrimitiveCryptHMAC
        Derives a quality HMAC (Keyed message-authentication code).
        The HMAC is computed in the following (standard HMAC) manner:

        KoPad = KiPad = DESKey key setup buffer
        XOR(KoPad, 0x5c5c5c5c)
        XOR(KiPad, 0x36363636)
        HMAC = SHA1(KoPad | SHA1(KiPad | Data))


*/
#include <pch.cpp>
#pragma hdrstop
#include "crypt.h"


BOOL
WINAPI
_CryptEnumProvidersW(
    DWORD   dwIndex,
    DWORD * pdwReserved,
    DWORD   dwFlags,
    DWORD * pdwProvType,
    LPWSTR pszProvName,
    DWORD * pcbProvName
    );


extern DWORD g_dwCryptProviderID;
#define HMAC_K_PADSIZE              64

extern CCryptProvList*  g_pCProvList;

BOOL FMyPrimitiveCryptHMAC(
        PBYTE       pbKeyMaterial,
        DWORD       cbKeyMaterial,
        PBYTE       pbData,
        DWORD       cbData,
        HCRYPTPROV  hVerifyProv,
        DWORD       dwHashAlg,
        HCRYPTHASH* phHash)                      // out
{
    DWORD       cb;
    BOOL        fRet = FALSE;

    BYTE        rgbKipad[HMAC_K_PADSIZE];   ZeroMemory(rgbKipad, HMAC_K_PADSIZE);
    BYTE        rgbKopad[HMAC_K_PADSIZE];   ZeroMemory(rgbKopad, HMAC_K_PADSIZE);

    BYTE        rgbHMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];

    HCRYPTHASH  hTmpHash = NULL;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    // fill pad bufs with keying material
    CopyMemory(rgbKipad, pbKeyMaterial, cbKeyMaterial);
    CopyMemory(rgbKopad, pbKeyMaterial, cbKeyMaterial);

    // assert we're a multiple for the next loop
    SS_ASSERT( (HMAC_K_PADSIZE % sizeof(DWORD)) == 0);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for(DWORD dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)rgbKopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    // check passed-in prov
    if (hVerifyProv == NULL)
        goto Ret;

    // create an intermediate hash
    if (!CryptCreateHash(
            hVerifyProv,
            dwHashAlg,
            NULL,
            0,
            &hTmpHash))
        goto Ret;

    // prepend Kipad to data, Hash to get H1
    if (!CryptHashData(
            hTmpHash,
            rgbKipad,
            sizeof(rgbKipad),
            0))
        goto Ret;
    if (!CryptHashData(
            hTmpHash,
            pbData,
            cbData,
            0))
        goto Ret;

    // prepend Kopad to H1
    CopyMemory(rgbHMACTmp, rgbKopad, HMAC_K_PADSIZE);
    cb = A_SHA_DIGEST_LEN;
    if (!CryptGetHashParam(
            hTmpHash,
            HP_HASHVAL,
            rgbHMACTmp+HMAC_K_PADSIZE,
            &cb,
            0))
        goto Ret;

    // do final hash w/ CryptoAPI into output hash
    // create the final hash
    if (!CryptCreateHash(
            hVerifyProv,
            dwHashAlg,
            NULL,
            0,
            phHash))
        goto Ret;

    // hash ( Kopad | H1 ) to get HMAC
    if (!CryptHashData(
            *phHash,
            rgbHMACTmp,
            HMAC_K_PADSIZE + cb,    // pad + hashsize
            0))
        goto Ret;

    fRet = TRUE;
Ret:
    if (hTmpHash)
        CryptDestroyHash(hTmpHash);

    return fRet;
}


#if DBG
void CheckMACInterop(
        PBYTE   pbMonsterKey,
        DWORD   cbMonsterKey,
        PBYTE   pbRandKey,
        DWORD   cbRandKey,
        HCRYPTPROV hVerifyProv,
        ALG_ID  algidHash)
{
    HCRYPTHASH  hHash = 0;
    BOOL fRet = FALSE;

    BYTE    rgbOldHash[A_SHA_DIGEST_LEN];

    BYTE    rgbCryptHash[A_SHA_DIGEST_LEN];
    DWORD   cbHashSize = sizeof(rgbCryptHash);

    if (algidHash == CALG_SHA1)
    {
        if (!FMyPrimitiveCryptHMAC(
                pbMonsterKey,   // key
                cbMonsterKey,
                pbRandKey,      // data
                cbRandKey,
                hVerifyProv,
                algidHash,
                &hHash))        // output
            goto Ret;

        // nab crypt result
        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                rgbCryptHash,
                &cbHashSize,
                0))
            goto Ret;

        // nab raw result
        if (!FMyPrimitiveHMACParam(
                pbMonsterKey,
                cbMonsterKey,
                pbRandKey,
                cbRandKey,
                rgbOldHash))
            goto Ret;

        if (0 != memcmp(rgbOldHash, rgbCryptHash, A_SHA_DIGEST_LEN))
            goto Ret;
    }
    // else don't have interop test

    fRet = TRUE;
Ret:
    if (!fRet)
    {
        OutputDebugString(TEXT("HMACs did not interop!!!!\n"));
        SS_ASSERT(0);
    }

    if (hHash)
        CryptDestroyHash(hHash);

    return;
}
#endif  // DBG



// USEC -- (US Export Controls)
DWORD GetSaltForExportControl(
        HCRYPTPROV  hProv,
        HCRYPTKEY   hKey,
        PBYTE*      ppbSalt,
        DWORD*      pcbSalt)

{
    DWORD dwRet;

    // fix bug: derived keys will be > 40 bits in length

    // fix is to stomp derived key with exposed salt (Provider knows what is legal!!)
    if (!CryptGetKeyParam(
            hKey,
            KP_SALT,
            NULL,
            pcbSalt,
            0))
    {
#if DBG
        if (GetLastError() != NTE_BAD_KEY)
            OutputDebugString(TEXT("GetSaltForExportControl failed in possible violation of ITAR!\n"));
#endif

/*
        dwRet = GetLastError();
        goto Ret;
*/
        // Assume key type doesn't support salt
        // report cbSalt = 0
        *pcbSalt = 0;
        *ppbSalt = (PBYTE)SSAlloc(0);

        dwRet = ERROR_SUCCESS;
        goto Ret;
    }

    *ppbSalt = (PBYTE)SSAlloc(*pcbSalt);
    if (!RtlGenRandom(
            *ppbSalt,
            *pcbSalt))
    {
        dwRet = GetLastError();
        goto Ret;
    }

    // don't get if salt zero len (bug workaround for NT5B1 RSAEnh)
    if (*pcbSalt != 0)
    {
        if (!CryptSetKeyParam(
                hKey,
                KP_SALT,
                *ppbSalt,
                0))
        {
            dwRet = GetLastError();
            goto Ret;
        }
    }

    dwRet = ERROR_SUCCESS;

Ret:
    return dwRet;
}


// USEC -- (US Export Controls)
DWORD SetSaltForExportControl(
        HCRYPTKEY   hKey,
        PBYTE       pbSalt,
        DWORD       cbSalt)
{
    DWORD dwRet;
    DWORD cbAllowableSaltLen;

    // first check and make sure we can set this salt
    if (!CryptGetKeyParam(
            hKey,
            KP_SALT,
            NULL,
            &cbAllowableSaltLen,
            0))
    {
/*
        dwRet = GetLastError();
        goto Ret;
*/
        // If cbSalt == 0, no error
        if (cbSalt == 0)
            dwRet = ERROR_SUCCESS;
        else
            dwRet = GetLastError();

        goto Ret;
    }

    if (cbAllowableSaltLen != cbSalt)
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // don't set if salt zero len (bug workaround for NT5B1 RSAEnh)
    if (cbSalt != 0)
    {
        // set the salt to stomp real key bits (export law)
        if (!CryptSetKeyParam(
                hKey,
                KP_SALT,
                pbSalt,
                0))
        {
            dwRet = GetLastError();
            goto Ret;
        }
    }

    dwRet = ERROR_SUCCESS;
Ret:
    return dwRet;
}



DWORD GetCryptProviderFromRequirements(
        DWORD       dwAlgId1,
        DWORD*      pdwKeySize1,
        DWORD       dwAlgId2,
        DWORD*      pdwKeySize2,
        DWORD*      pdwProvType,
        LPWSTR*     ppszProvName)
{
    DWORD       dwRet;

    DWORD       cbProvName=0, cbNecessary;
    HCRYPTPROV  hQueryProv = NULL;

    SS_ASSERT(pdwKeySize1);
    SS_ASSERT(pdwKeySize2);

    *ppszProvName=NULL;

    for (int iProvIndex=0; ;iProvIndex++)
    {
        if (!_CryptEnumProvidersW(
                iProvIndex,
                NULL,
                0,
                pdwProvType,
                NULL,
                &cbNecessary))
        {
            dwRet = GetLastError();

            if (dwRet == ERROR_NO_MORE_ITEMS)
                dwRet = NTE_PROV_DLL_NOT_FOUND;

            // end of providers OR
            // trouble enumerating providers: both fatal
            goto Ret;
        }

        if (cbNecessary > cbProvName)
        {
            if (*ppszProvName == NULL)
                *ppszProvName = (LPWSTR)SSAlloc(cbNecessary);
            else
                *ppszProvName = (LPWSTR)SSReAlloc(*ppszProvName, cbNecessary);

            if (*ppszProvName == NULL)
            {
                dwRet = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }

            cbProvName = cbNecessary;
        }

        if (!_CryptEnumProvidersW(
                iProvIndex,
                NULL,
                0,
                pdwProvType,
                *ppszProvName,
                &cbNecessary))
        {
            // trouble enumerating providers: fatal
            dwRet = GetLastError();
            goto Ret;
        }

        if (!CryptAcquireContextU(
                &hQueryProv,
                NULL,
                *ppszProvName,
                *pdwProvType,
                CRYPT_VERIFYCONTEXT))
        {
            // trouble acquiring context, to go next csp
            continue;
        }

        if ((FProviderSupportsAlg(hQueryProv, dwAlgId1, pdwKeySize1)) &&
            (FProviderSupportsAlg(hQueryProv, dwAlgId2, pdwKeySize2)) )
            goto CSPFound;

        // release
        CryptReleaseContext(hQueryProv, 0);
        hQueryProv = NULL;
    }

CSPFound:
    dwRet = ERROR_SUCCESS;

Ret:
    if (hQueryProv != NULL)
        CryptReleaseContext(hQueryProv, 0);

    if (dwRet != ERROR_SUCCESS)
    {
        SSFree(*ppszProvName);
        *ppszProvName = NULL;
    }

    return dwRet;
}


// *pdwKeySize == -1  gets any size, reports size
HCRYPTPROV
GetCryptProviderHandle(
        DWORD   dwDefaultCSPType,
        DWORD   dwAlgId1,
        DWORD*  pdwKeySize1,
        DWORD   dwAlgId2,
        DWORD*  pdwKeySize2)
{
    DWORD dwRet;
    DWORD dwProvType;
    LPWSTR szProvName = NULL;

    CRYPTPROV_LIST_ITEM Elt, *pFoundElt;
    HCRYPTPROV hNewCryptProv=0;

    SS_ASSERT(pdwKeySize1);
    SS_ASSERT(pdwKeySize2);
    if(NULL == g_pCProvList)
    {
        SetLastError(PST_E_FAIL);
        return NULL;
    }


    // Adjust DES key sizes, to prevent the situation where the CSP
    // originally used for encryption accidently reported a 3DES key 
    // size of 192 bits, and the current CSPs only enumerate support 
    // for 3DES keys of 168 bits.
    if(dwAlgId1 == CALG_DES || dwAlgId1 == CALG_3DES)
    {
        *pdwKeySize1 = -1;
    }


    // check cache for satisfactory CSP
    CreateCryptProvListItem(&Elt,
                        dwAlgId1,
                        *pdwKeySize1,
                        dwAlgId2,
                        *pdwKeySize2,
                        0);

    if (NULL != (pFoundElt = g_pCProvList->SearchList(&Elt)) )
    {
        // report what we're returning
        *pdwKeySize1 = pFoundElt->dwKeySize1;
        *pdwKeySize2 = pFoundElt->dwKeySize2;

        return pFoundElt->hProv;
    }

    // not in cache: have to rummage

    // try default provider of given type, see if it satisfies
    if (CryptAcquireContextU(
            &hNewCryptProv,
            NULL,
            MS_STRONG_PROV,
            dwDefaultCSPType,
            CRYPT_VERIFYCONTEXT))
    {
        if ((FProviderSupportsAlg(hNewCryptProv, dwAlgId1, pdwKeySize1)) &&
            (FProviderSupportsAlg(hNewCryptProv, dwAlgId2, pdwKeySize2)) )
            goto CSPAcquired;


        // clean up non-usable CSP
        CryptReleaseContext(hNewCryptProv, 0);
        hNewCryptProv = NULL;

        // all other cases: fall through to enum CSPs
    }

    // rummage along providers on system to find someone who fits the bill
    if(ERROR_SUCCESS != (dwRet =
        GetCryptProviderFromRequirements(
            dwAlgId1,
            pdwKeySize1,
            dwAlgId2,
            pdwKeySize2,
            &dwProvType,
            &szProvName)))
    {
        SetLastError(dwRet);
        goto Ret;
    }

    // found one!

    // init csp
    if (!CryptAcquireContextU(
                &hNewCryptProv,
                NULL,
                szProvName,
                dwProvType,
                CRYPT_VERIFYCONTEXT))
    {
        // this a failure case

        // SetLastError already done for us
        hNewCryptProv = NULL;
        goto Ret;
    }

CSPAcquired:

    SS_ASSERT(hNewCryptProv != NULL);

    // and add to internal list
    pFoundElt = (CRYPTPROV_LIST_ITEM*) SSAlloc(sizeof(CRYPTPROV_LIST_ITEM));
    if(NULL == pFoundElt)
    {
        // clean up non-usable CSP
        CryptReleaseContext(hNewCryptProv, 0);
        hNewCryptProv = NULL;
        goto Ret;
    }
    CreateCryptProvListItem(pFoundElt,
                        dwAlgId1,
                        *pdwKeySize1,
                        dwAlgId2,
                        *pdwKeySize2,
                        hNewCryptProv);

    g_pCProvList->AddToList(pFoundElt);

Ret:
    if (szProvName)
        SSFree(szProvName);

    return hNewCryptProv;
}


BOOL FProviderSupportsAlg(
        HCRYPTPROV  hQueryProv,
        DWORD       dwAlgId,
        DWORD*      pdwKeySize)
{
    PROV_ENUMALGS       sSupportedAlgs;
    PROV_ENUMALGS_EX    sSupportedAlgsEx;
    DWORD       cbSupportedAlgs = sizeof(sSupportedAlgs);
    DWORD       cbSupportedAlgsEx = sizeof(sSupportedAlgsEx);

    // must be non-null
    SS_ASSERT(pdwKeySize != NULL);

    // now we have provider; enum the algorithms involved
    for(int iAlgs=0; ; iAlgs++)
    {

        //
        // Attempt the EX alg enumeration
        if (CryptGetProvParam(
                hQueryProv,
                PP_ENUMALGS_EX,
                (PBYTE)&sSupportedAlgsEx,
                &cbSupportedAlgsEx,
                (iAlgs == 0) ? CRYPT_FIRST : 0  ))
        {
            if (sSupportedAlgsEx.aiAlgid == dwAlgId)
            {
                if(*pdwKeySize == -1)
                {
                    *pdwKeySize = sSupportedAlgsEx.dwMaxLen;
                }
                else
                {
                    if ((sSupportedAlgsEx.dwMinLen > *pdwKeySize) ||
                        (sSupportedAlgsEx.dwMaxLen < *pdwKeySize))
                        return FALSE;
                }

                return TRUE;
                    
            }
        }
        else if (!CryptGetProvParam(
                hQueryProv,
                PP_ENUMALGS,
                (PBYTE)&sSupportedAlgs,
                &cbSupportedAlgs,
                (iAlgs == 0) ? CRYPT_FIRST : 0  ))
        {
            // trouble enumerating algs
            break;
        

            if (sSupportedAlgs.aiAlgid == dwAlgId)
            {
                // were we told to ignore size?
                if (*pdwKeySize != -1)
                {
                    // else, if defaults don't match
                    if (sSupportedAlgs.dwBitLen != *pdwKeySize)
                    {
                        return FALSE;
                    }
                }

                // report back size
                *pdwKeySize = sSupportedAlgs.dwBitLen;
                return TRUE;
            }
        }
        else
        {
            // trouble enumerating algs
            break;
        }
    }

    return FALSE;
}

BOOL
WINAPI
_CryptEnumProvidersW(
    DWORD   dwIndex,
    DWORD * pdwReserved,
    DWORD   dwFlags,
    DWORD * pdwProvType,
    LPWSTR pszProvName,
    DWORD * pcbProvName
    )
{
    HMODULE hAdvapi32;
    typedef BOOL (WINAPI *CRYPTENUMPROVIDERSW)(
        DWORD   dwIndex,
        DWORD * pdwReserved,
        DWORD   dwFlags,
        DWORD * pdwProvType,
        LPWSTR pszProvName,
        DWORD * pcbProvName
        );

    static CRYPTENUMPROVIDERSW _RealCryptEnumProvidersW;


    if (_RealCryptEnumProvidersW == NULL) {
        hAdvapi32 = GetModuleHandleA("advapi32.dll");
        if(hAdvapi32 == NULL)
            return FALSE;

        _RealCryptEnumProvidersW = (CRYPTENUMPROVIDERSW)GetProcAddress(hAdvapi32, "CryptEnumProvidersW");
        if(_RealCryptEnumProvidersW == NULL)
            return FALSE;
    }

    return _RealCryptEnumProvidersW(
                        dwIndex,
                        pdwReserved,
                        dwFlags,
                        pdwProvType,
                        pszProvName,
                        pcbProvName
                        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\crypt32.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    crypt32.cpp

Abstract:

    This module contains routines associated with server side Crypt32
    operations.

Author:

    Scott Field (sfield)    14-Aug-97

--*/

#include <pch.cpp>
#pragma hdrstop
#include <msaudite.h>



#define SECURITY_WIN32
#include <security.h>

#define     CRYPTPROTECT_SVR_VERSION_1     0x01

DWORD
CPSCreateServerContext(
    PCRYPT_SERVER_CONTEXT pServerContext,
    handle_t hBinding
    );

DWORD
CPSDeleteServerContext(
    PCRYPT_SERVER_CONTEXT pServerContext
    );




GUID g_guidDefaultProvider = CRYPTPROTECT_DEFAULT_PROVIDER;



//
// routines to initialize and destroy server state associated with
// server callbacks and performance improvements.
//

DWORD
CPSCreateServerContext(
    PCRYPT_SERVER_CONTEXT pServerContext,
    handle_t hBinding
    )
{
    DWORD dwLastError = ERROR_SUCCESS;

    __try {


        ZeroMemory( pServerContext, sizeof(CRYPT_SERVER_CONTEXT) );

        pServerContext->cbSize = sizeof(CRYPT_SERVER_CONTEXT);
        pServerContext->hBinding = hBinding;

        pServerContext->fImpersonating = FALSE;

        if(NULL != hBinding)
        {
            dwLastError = RpcImpersonateClient( hBinding );
            if(ERROR_SUCCESS != dwLastError)
            {
                return dwLastError;
            }
        }

        //
        // Grab the thread token.
        //
        if(OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                    TRUE,
                    &pServerContext->hToken
                    ))
        {
            pServerContext->fImpersonating = (NULL == hBinding);
        }
        else
        {
            HANDLE hProcessToken = NULL;
            if(OpenProcessToken(GetCurrentProcess(), 
                                TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                                &hProcessToken))
            {
                if(!DuplicateTokenEx(hProcessToken,
                                     0,
                                     NULL,
                                     SecurityImpersonation,
                                     TokenImpersonation,
                                     &pServerContext->hToken))
                {
                    dwLastError = GetLastError();
                }

                CloseHandle(hProcessToken);
            }
            else
            {
                dwLastError = GetLastError();
            }
        }
        if(hBinding)
        {
            RpcRevertToSelfEx( hBinding );
        }


    } __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwLastError = GetExceptionCode();
        // TODO: for NT, convert exception code to winerror.
        //       for 95, just override to access violation.
    }

    return dwLastError;
}

DWORD
CPSDeleteServerContext(
    PCRYPT_SERVER_CONTEXT pServerContext
    )
{
    if(pServerContext->szUserStorageArea)
    {
        SSFree(pServerContext->szUserStorageArea);
        pServerContext->szUserStorageArea = NULL;
    }
    if(pServerContext->hToken)
    {
        CloseHandle(pServerContext->hToken);
    }


    if(pServerContext->cbSize == sizeof(CRYPT_SERVER_CONTEXT))
        ZeroMemory( pServerContext, sizeof(CRYPT_SERVER_CONTEXT) );


    return ERROR_SUCCESS;
}

DWORD
WINAPI
CPSDuplicateContext(
    IN      PVOID pvContext,
    IN OUT  PVOID *ppvDuplicateContext
    )
/*++

    Duplicate an outstanding server context so that a provider may defer
    processing associated with the outstanding context until a later time.

    This is used to support asynchronous operations on behalf of the caller
    to the Data Protection API.

    The caller MUST be impersonating the security context of the client user
    prior to making this call.

--*/
{
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;
    PCRYPT_SERVER_CONTEXT pNewContext = NULL;

    HANDLE hToken = NULL;
    HANDLE hDuplicateToken;
    BOOL fSuccess = FALSE;
    DWORD dwLastError = ERROR_SUCCESS;

    if( pServerContext == NULL ||
        pServerContext->cbSize != sizeof(CRYPT_SERVER_CONTEXT) ||
        ppvDuplicateContext == NULL
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    pNewContext = (PCRYPT_SERVER_CONTEXT)SSAlloc( sizeof( CRYPT_SERVER_CONTEXT ) );
    if( pNewContext == NULL )
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;

    CopyMemory( pNewContext, pServerContext, sizeof(CRYPT_SERVER_CONTEXT) );
    pNewContext->hBinding = NULL;

    if(pServerContext->szUserStorageArea)
    {
        pNewContext->szUserStorageArea = (LPWSTR)SSAlloc((wcslen(pServerContext->szUserStorageArea)+1)*
                                                 sizeof(WCHAR));
        if(NULL != pNewContext->szUserStorageArea)
        {
            wcscpy(pNewContext->szUserStorageArea, pServerContext->szUserStorageArea);
        }
    }

    fSuccess = DuplicateTokenEx(pServerContext->hToken, 
                                0,
                                NULL,
                                SecurityImpersonation,
                                TokenImpersonation,
                                &pNewContext->hToken);

    if( !fSuccess )
    {
        dwLastError = GetLastError();
        pNewContext->hToken = NULL;

        CPSFreeContext( pNewContext );
    } else {
        *ppvDuplicateContext = pNewContext;
    }

    return dwLastError;
}

DWORD
WINAPI
CPSFreeContext(
    IN      PVOID pvDuplicateContext
    )
{
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvDuplicateContext;

    if( pServerContext == NULL ||
        pServerContext->cbSize != sizeof(CRYPT_SERVER_CONTEXT)
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( pServerContext->hToken )
        CloseHandle( pServerContext->hToken );

    if(pServerContext->szUserStorageArea)
    {
        SSFree(pServerContext->szUserStorageArea);
        pServerContext->szUserStorageArea = NULL;
    }

    ZeroMemory( pServerContext, sizeof(CRYPT_SERVER_CONTEXT) );
    SSFree( pServerContext );

    return ERROR_SUCCESS;
}

DWORD
WINAPI
CPSImpersonateClient(
    IN      PVOID pvContext
    )
{
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;
    DWORD dwLastError = ERROR_INVALID_PARAMETER;

    if( pvContext == NULL )
        return ERROR_SUCCESS;

    if( pServerContext->cbSize == sizeof(CRYPT_SERVER_CONTEXT) ) {

        if(!FIsWinNT())
            return ERROR_SUCCESS;

        if( pServerContext->fOverrideToLocalSystem ) {
            if(ImpersonateSelf(SecurityImpersonation)) {
                dwLastError = ERROR_SUCCESS;
            } else {
                dwLastError = GetLastError();
                D_DebugLog((DEB_WARN, "Failed ImpersonateSelf call: 0x%x\n", dwLastError));
            }

        } else {

            //
            // duplicated server context has access token included; use it directly
            //

            if( pServerContext->hToken ) {
                if(!SetThreadToken( NULL, pServerContext->hToken ))
                {
                    dwLastError = GetLastError();
                    D_DebugLog((DEB_WARN, "Failed SetThreadToken call: 0x%x\n", dwLastError));
                }

                dwLastError = ERROR_SUCCESS;
                goto cleanup;
            }
            if(pServerContext->hBinding)
            {
                dwLastError = RpcImpersonateClient( pServerContext->hBinding );
            }
            else
            {
                dwLastError = ERROR_INVALID_PARAMETER;
            }
        }
    }

cleanup:

#if DBG
    if(NT_SUCCESS(dwLastError) && (DPAPIInfoLevel & DEB_TRACE))
    {
        BYTE            rgbTemp[256];
        PTOKEN_USER     pUser = (PTOKEN_USER)rgbTemp;
        DWORD           cbRetInfo;
        UNICODE_STRING  ucsSid;
        HANDLE          hToken;
        NTSTATUS        Status;

        Status = NtOpenThreadToken(NtCurrentThread(), TOKEN_QUERY, TRUE, &hToken);
        if(NT_SUCCESS(Status))
        {
            Status = NtQueryInformationToken(hToken,
                                             TokenUser,
                                             pUser,
                                             256,
                                             &cbRetInfo);
            if(NT_SUCCESS(Status))
            {
                if(NT_SUCCESS(RtlConvertSidToUnicodeString(&ucsSid, pUser->User.Sid, TRUE)))
                {
                    D_DebugLog((DEB_TRACE, "Impersonating user:%ls\n", ucsSid.Buffer));
                    RtlFreeUnicodeString(&ucsSid);
                }
            }
            else
            {
                D_DebugLog((DEB_ERROR, "Unable read user info: 0x%x\n", Status));
            }
        }
        else
        {
            D_DebugLog((DEB_ERROR, "Unable to open thread token: 0x%x\n", Status));
        }
    }
#endif

    if(!NT_SUCCESS(dwLastError))
    {
        D_DebugLog((DEB_WARN, "CPSImpersonateClient returned 0x%x\n", dwLastError));
    }

    return dwLastError;
}

DWORD
WINAPI
CPSRevertToSelf(
    IN      PVOID pvContext
    )
{
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;
    DWORD dwLastError = ERROR_INVALID_PARAMETER;

    if( pvContext == NULL )
        return ERROR_SUCCESS;

    if( pServerContext->cbSize == sizeof(CRYPT_SERVER_CONTEXT) ) {

        if(!FIsWinNT())
            return ERROR_SUCCESS;

        if( pServerContext->fOverrideToLocalSystem || pServerContext->hToken ) {

            if(RevertToSelf()) {
                dwLastError = ERROR_SUCCESS;
            } else {
                dwLastError = GetLastError();
            }

        } else {
            if(pServerContext->hBinding)
            {
                dwLastError = RpcRevertToSelfEx( pServerContext->hBinding );
            }
            else
            {
                dwLastError = ERROR_INVALID_PARAMETER;
            }
        }
    }

    return dwLastError;
}


DWORD
WINAPI
CPSOverrideToLocalSystem(
    IN      PVOID pvContext,
    IN      BOOL *pfLocalSystem,            // if non-null, new over ride BOOL
    IN OUT  BOOL *pfCurrentlyLocalSystem    // if non-null, prior over ride BOOL
    )
{
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;

    if( pServerContext == NULL ||
        pServerContext->cbSize != sizeof(CRYPT_SERVER_CONTEXT)
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( pfCurrentlyLocalSystem )
        *pfCurrentlyLocalSystem = pServerContext->fOverrideToLocalSystem;

    if( pfLocalSystem )
        pServerContext->fOverrideToLocalSystem = *pfLocalSystem;

    return ERROR_SUCCESS;
}


DWORD
CPSDuplicateClientAccessToken(
    IN      PVOID pvContext,            // server context
    IN OUT  HANDLE *phToken
    )
{
    HANDLE hToken = NULL;
    HANDLE hDuplicateToken;
    DWORD dwLastError = ERROR_SUCCESS;
    BOOL fSuccess;

    *phToken = NULL;

    //
    // make a duplicate of the client access token.
    //
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;

    if(!DuplicateTokenEx(pServerContext->hToken,
                         0,
                         NULL,
                         SecurityImpersonation,
                         TokenImpersonation,
                         &hDuplicateToken ))
    {
        dwLastError = GetLastError();
    }
    else
        *phToken = hDuplicateToken;

    return dwLastError;

}

DWORD
WINAPI
CPSGetUserName(
    IN      PVOID pvContext,
        OUT LPWSTR *ppszUserName,
        OUT DWORD *pcchUserName
    )
{
    WCHAR szBuf[MAX_PATH+1];
    DWORD cchBuf = MAX_PATH;
    DWORD dwLastError = ERROR_INVALID_PARAMETER;
    BOOL fLocalMachine = FALSE;
    BOOL fSuccess = FALSE;


    //
    // if we are currently over-riding to Local System, we know the values
    // that need to be returned.
    //

    CPSOverrideToLocalSystem(
                pvContext,
                NULL,       // don't change current over-ride BOOL
                &fLocalMachine
                );


    if( fLocalMachine ) {
        LPCWSTR szLocalMachine;
        DWORD cbLocalMachine;

        if(FIsWinNT()) {
            static const WCHAR szName1[] = TEXTUAL_SID_LOCAL_SYSTEM;

            szLocalMachine = szName1;
            cbLocalMachine = sizeof(szName1);

        } else {
            static const WCHAR szName2[] = L"LOCAL_MACHINE_USER";

            szLocalMachine = szName2;
            cbLocalMachine = sizeof(szName2);
        }

        CopyMemory( szBuf, szLocalMachine, cbLocalMachine );
        cchBuf = cbLocalMachine / sizeof(WCHAR);

        fSuccess = TRUE;

    } else {

        if(FIsWinNT()) {

            dwLastError = CPSImpersonateClient( pvContext );
            if(dwLastError != ERROR_SUCCESS)
                return dwLastError;

            fSuccess = GetUserTextualSid(
                            NULL,
                            szBuf,
                            &cchBuf
                            );

            CPSRevertToSelf( pvContext );

        } else {
            fSuccess = GetUserNameU(
                            szBuf,
                            &cchBuf
                            );

            if(!fSuccess) {

                //
                // for Win95, if nobody is logged on, empty user name
                // TODO: should probably be *DEFAULT*
                //

                if(GetLastError() == ERROR_NOT_LOGGED_ON) {
                    szBuf[ 0 ] = L'\0';
                    cchBuf = 1;
                    fSuccess = TRUE;
                }
            }
        }


    }

    if( fSuccess ) {

        *ppszUserName = (LPWSTR)SSAlloc( cchBuf * sizeof(WCHAR));

        if(*ppszUserName) {
            CopyMemory( *ppszUserName, szBuf, cchBuf * sizeof(WCHAR));

            if(pcchUserName)
                *pcchUserName = cchBuf;

            dwLastError = ERROR_SUCCESS;
        }
    }

    return dwLastError;
}



DWORD
WINAPI
CPSGetDerivedCredential(
    IN      PVOID pvContext,
    IN      GUID  *pCredentialID,
    IN      DWORD dwFlags,   
    IN      PBYTE pbMixingBytes,
    IN      DWORD cbMixingBytes,
    IN OUT  BYTE rgbDerivedCredential[A_SHA_DIGEST_LEN]
    )
{
    LUID LogonId;
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;
    DWORD dwLastError = ERROR_SUCCESS;


    if( pServerContext != NULL && pServerContext->cbSize != sizeof(CRYPT_SERVER_CONTEXT) )
        return ERROR_INVALID_PARAMETER;

    if( cbMixingBytes == 0 || pbMixingBytes == NULL )
        return ERROR_INVALID_PARAMETER;


    if( !FIsWinNT5() ) {

        DWORD FixedCred[] = {
                0x414188aa, 0xfa8a0011, 0x66666666, 0x77777777, 0x88888888 };
        A_SHA_CTX shaContext;

        A_SHAInit( &shaContext );
        A_SHAUpdate( &shaContext, (PBYTE)FixedCred, sizeof(FixedCred) );
        A_SHAUpdate( &shaContext, pbMixingBytes, cbMixingBytes );

        A_SHAFinal( &shaContext, rgbDerivedCredential );
        ZeroMemory( &shaContext, sizeof(shaContext) );

        return ERROR_SUCCESS;
    }

    //
    // impersonate the client and get the LogonId associated with the client.
    //

    dwLastError = CPSImpersonateClient( pvContext );

    if( dwLastError != ERROR_SUCCESS )
        return dwLastError;

    if(!GetThreadAuthenticationId( GetCurrentThread(), &LogonId ))
    {
        CPSRevertToSelf( pvContext );
        return GetLastError();
    }




    dwLastError = QueryDerivedCredential( pCredentialID,
                                          &LogonId, 
                                          dwFlags, 
                                          pbMixingBytes, 
                                          cbMixingBytes, 
                                          rgbDerivedCredential );


    CPSRevertToSelf( pvContext );


    return dwLastError;
}

DWORD
WINAPI
CPSGetSystemCredential(
    IN      PVOID pvContext,
    IN      BOOL fLocalMachine,
    IN OUT  BYTE rgbSystemCredential[A_SHA_DIGEST_LEN]
    )
{
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;

    if( pServerContext != NULL && pServerContext->cbSize != sizeof(CRYPT_SERVER_CONTEXT) )
        return ERROR_INVALID_PARAMETER;

    if( !FIsWinNT() ) {
        DWORD FixedCred[] = {
                0x414188aa, 0xfa8a0011, 0x66666666, 0x77777777, 0x88888888 };
        DWORD dw = 0xa123ff00;
        A_SHA_CTX shaContext;

        A_SHAInit( &shaContext );
        A_SHAUpdate( &shaContext, (PBYTE)FixedCred, sizeof(FixedCred) );
        if( fLocalMachine )
            A_SHAUpdate( &shaContext, (PBYTE)&dw, sizeof(dw) );

        A_SHAFinal( &shaContext, rgbSystemCredential );
        ZeroMemory( &shaContext, sizeof(shaContext) );

        return ERROR_SUCCESS;
    }

    return GetSystemCredential( fLocalMachine, rgbSystemCredential);
}


DWORD
WINAPI
CPSCreateWorkerThread(
    IN      PVOID pThreadFunc,
    IN      PVOID pThreadArg
    )
{

    if( !QueueUserWorkItem(
            (PTHREAD_START_ROUTINE)pThreadFunc,
            pThreadArg,
            WT_EXECUTELONGFUNCTION
            )) {

        return GetLastError();
    }

    return ERROR_SUCCESS;
}

DWORD CPSAudit(
    IN      HANDLE      hToken,
    IN      DWORD       dwAuditID,
    IN      LPCWSTR     wszMasterKeyID,
    IN      LPCWSTR     wszRecoveryServer,
    IN      DWORD       dwReason,
    IN      LPCWSTR     wszRecoveryKeyID,
    IN      DWORD       dwFailure)
{

    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING MasterKeyID;
    UNICODE_STRING RecoveryServer;
    UNICODE_STRING RecoveryKeyID;

    BOOL           fReasonField = FALSE;
    PSID           UserSid = NULL;


    fReasonField = ((SE_AUDITID_DPAPI_PROTECT == dwAuditID) ||
                   (SE_AUDITID_DPAPI_UNPROTECT == dwAuditID) ||
                   (SE_AUDITID_DPAPI_RECOVERY == dwAuditID));

    GetTokenUserSid(hToken, &UserSid);


    if(wszMasterKeyID)
    {
        RtlInitUnicodeString(&MasterKeyID, wszMasterKeyID);
    }
    else
    {
        RtlInitUnicodeString(&MasterKeyID, L"");
    }

    if(wszRecoveryServer)
    {
        RtlInitUnicodeString(&RecoveryServer, wszRecoveryServer);
    }
    else
    {
        RtlInitUnicodeString(&RecoveryServer, L"");
    }

    if(wszRecoveryKeyID)
    {
        RtlInitUnicodeString(&RecoveryKeyID, wszRecoveryKeyID);
    }
    else
    {
        RtlInitUnicodeString(&RecoveryKeyID, L"");
    }


    Status = LsaIAuditDPAPIEvent(
                        dwAuditID,
                        UserSid,
                        &MasterKeyID,
                        &RecoveryServer,
                        fReasonField ? &dwReason : NULL,
                        &RecoveryKeyID,
                        &dwFailure
                        );
    if(UserSid)
    {
        SSFree(UserSid);
    }
    return (DWORD)Status;
}


DWORD
CPSGetUserStorageArea(
    IN      PVOID   pvContext,
    IN      PSID    pSid,     // optional
    IN      BOOL    fCreate,  // Create the storage area if it doesn't exist
    IN  OUT LPWSTR *ppszUserStorageArea
    )
{

    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;

    LPCWSTR szLocalSystem;
    DWORD cbLocalSystem;

    WCHAR szUserStorageRoot[MAX_PATH+1];
    DWORD cbUserStorageRoot;

    const WCHAR szProductString[] = L"\\Microsoft\\Protect\\";
    DWORD cbProductString = sizeof(szProductString) - sizeof(WCHAR);

    LPWSTR szUser = NULL;
    DWORD cbUser;
    DWORD cchUser;

    LPCWSTR szOptionalTrailing;
    DWORD cbOptionalTrailing = 0;

    BOOL fLocalMachine = FALSE;

    HANDLE hFile = INVALID_HANDLE_VALUE;
    PBYTE pbCurrent;

    BOOL fImpersonated = FALSE;

    DWORD dwLastError = ERROR_CANTOPEN;

    *ppszUserStorageArea = NULL;


    if(NULL == pServerContext)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(NULL == pSid)
    {

        //
        // If this is the current users sid, check to see if we've already
        // calculated this string.

        if(NULL != pServerContext->szUserStorageArea)
        {
            *ppszUserStorageArea = (LPWSTR)SSAlloc((wcslen(pServerContext->szUserStorageArea)+1)*sizeof(WCHAR));
            if(NULL == *ppszUserStorageArea)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            wcscpy(*ppszUserStorageArea, pServerContext->szUserStorageArea);
            return ERROR_SUCCESS;
        }


        //
        // get the user name associated with the call.
        // Note: this is the textual Sid on NT, and the user name on Win95.
        //



        dwLastError = CPSGetUserName( pvContext, &szUser, &cchUser );
        if(dwLastError != ERROR_SUCCESS)
            goto cleanup;

        cbUser = (cchUser-1) * sizeof(WCHAR);
    }
    else
    {
        WCHAR wszTextualSid[MAX_PATH+1];
        cchUser = MAX_PATH;

        if(!GetTextualSid(pSid, wszTextualSid, &cchUser))
        {
            dwLastError = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        cbUser = (cchUser-1) * sizeof(WCHAR);
        szUser = (LPWSTR)SSAlloc(cchUser*sizeof(WCHAR));
        if(NULL == szUser)
        {
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        wcscpy(szUser, wszTextualSid);
    }


    //
    // impersonate the client user to test and create storage area if necessary
    //

    dwLastError = CPSImpersonateClient( pvContext );

    if( dwLastError != ERROR_SUCCESS )
        goto cleanup;

    fImpersonated = TRUE;


    //
    // see if the call is for shared, CRYPT_PROTECT_LOCAL_MACHINE
    // disposition.
    //

    CPSOverrideToLocalSystem(
                pvContext,
                NULL,       // don't change current over-ride BOOL
                &fLocalMachine
                );

    //
    // determine path to per-user storage area, based on whether this
    // is a local machine disposition call or a per-user disposition call.
    //

    if(FIsWinNT()) {
        const WCHAR szSidSystem[] = TEXTUAL_SID_LOCAL_SYSTEM;
        szLocalSystem = szSidSystem;
        cbLocalSystem = sizeof(szSidSystem);
    } else {
        // TODO: Win95 case.
        cbLocalSystem = 0xffffffff;
    }

    if( fLocalMachine ||
        ((cchUser*sizeof(WCHAR)) == cbLocalSystem) && (memcmp(szUser, szLocalSystem, cbLocalSystem) == 0)
        ) {

        cbUserStorageRoot = GetSystemDirectoryW(
                                szUserStorageRoot,
                                sizeof(szUserStorageRoot) / sizeof(WCHAR)
                                );

        cbUserStorageRoot *= sizeof(WCHAR);

        //
        // when the Sid is the SYSTEM sid, and this isn't a Local Machine
        // disposition call, add a trailing component to the storage path.
        //

        if( !fLocalMachine ) {
            const static WCHAR szUserStorageForSystem[] = L"\\User";

            cbOptionalTrailing = sizeof(szUserStorageForSystem) - sizeof(WCHAR);
            szOptionalTrailing = szUserStorageForSystem;
        }

    } else {

        dwLastError = PRGetProfilePath(NULL,
                                       NULL,
                                       szUserStorageRoot );

        if( dwLastError != ERROR_SUCCESS )
        {
            goto cleanup;
        }

        cbUserStorageRoot = lstrlenW( szUserStorageRoot ) * sizeof(WCHAR);
    }

    //
    // an empty string is not legal as the root component of the per-user
    // storage area.
    //

    if( cbUserStorageRoot == 0 ) {
        dwLastError = ERROR_CANTOPEN;
        goto cleanup;
    }

    //
    // insure returned string does not have trailing \
    //

    if( szUserStorageRoot[ (cbUserStorageRoot / sizeof(WCHAR)) - 1 ] == L'\\' ) {

        szUserStorageRoot[ (cbUserStorageRoot / sizeof(WCHAR)) - 1 ] = L'\0';
        cbUserStorageRoot -= sizeof(WCHAR);
    }


    *ppszUserStorageArea = (LPWSTR)SSAlloc(
                                    cbUserStorageRoot +
                                    cbProductString +
                                    cbUser +
                                    cbOptionalTrailing +
                                    (2 * sizeof(WCHAR)) // trailing slash and NULL
                                    );

    if( *ppszUserStorageArea == NULL ) {
        dwLastError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto cleanup;
    }


    pbCurrent = (PBYTE)*ppszUserStorageArea;

    CopyMemory(pbCurrent, szUserStorageRoot, cbUserStorageRoot);
    pbCurrent += cbUserStorageRoot;

    CopyMemory(pbCurrent, szProductString, cbProductString);
    pbCurrent += cbProductString;

    CopyMemory(pbCurrent, szUser, cbUser);
    pbCurrent += cbUser; // note: cbUser does not include terminal NULL

    if(cbOptionalTrailing) {
        CopyMemory(pbCurrent, szOptionalTrailing, cbOptionalTrailing);
        pbCurrent += cbOptionalTrailing;
    }

    if( *((LPWSTR)pbCurrent - 1) != L'\\' ) {
        *(LPWSTR)pbCurrent = L'\\';
        pbCurrent += sizeof(WCHAR);
    }

    *(LPWSTR)pbCurrent = L'\0';


    //
    // test for well-known file in the storage area.  if it exists,
    // don't bother trying to create directory structure.
    //

    dwLastError = OpenFileInStorageArea(
                    NULL, // NULL == already impersonating the client
                    GENERIC_READ,
                    *ppszUserStorageArea,
                    REGVAL_PREFERRED_MK,
                    &hFile
                    );

    if( dwLastError == ERROR_SUCCESS) {
        CloseHandle( hFile );
    } else {
        if(fCreate)
        {
            dwLastError = DPAPICreateNestedDirectories(
                            *ppszUserStorageArea,
                            (LPWSTR)((LPBYTE)*ppszUserStorageArea + cbUserStorageRoot + sizeof(WCHAR))
                            );
        }
    }
    if((ERROR_SUCCESS == dwLastError) &&
       (NULL == pSid))
    {
        pServerContext->szUserStorageArea = (LPWSTR)SSAlloc((wcslen(*ppszUserStorageArea)+1)*sizeof(WCHAR));
        if(NULL == pServerContext->szUserStorageArea)
        {
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            wcscpy(pServerContext->szUserStorageArea, *ppszUserStorageArea);
        }

    }



cleanup:

    if( fImpersonated )
        CPSRevertToSelf( pvContext );

    if(szUser)
        SSFree(szUser);

    if( dwLastError != ERROR_SUCCESS && *ppszUserStorageArea ) {
        SSFree( *ppszUserStorageArea );
        *ppszUserStorageArea = NULL;
    }

    return dwLastError;
}



HKEY GetLMRegistryProviderKey()
{
    HKEY hBaseKey = NULL;
    DWORD dwCreate;
    DWORD dwDesiredAccess = KEY_READ | KEY_WRITE;

    static const WCHAR szKeyName[] = REG_CRYPTPROTECT_LOC L"\\" REG_CRYPTPROTECT_PROVIDERS_SUBKEYLOC;


    // Open Key //
    if (ERROR_SUCCESS !=
        RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            szKeyName,
            0,
            NULL,                       // address of class string
            0,
            dwDesiredAccess,
            NULL,
            &hBaseKey,
            &dwCreate))
        goto Ret;

Ret:
    return hBaseKey;
}




DWORD GetPolicyBits()
{
    return 0;
}





///////////////////////////////////////////////////////////////////////
// RPC-exposed functions
//
// these functions return a DWORD equivalent to GetLastError().
// the client side stub code will check if the return code is not
// ERROR_SUCCESS, and if this is the case, the client stub will return
// FALSE and SetLastError() to this DWORD.
//

DWORD
s_SSCryptProtectData(
    handle_t h,
    BYTE __RPC_FAR *__RPC_FAR *ppbOut,
    DWORD __RPC_FAR *pcbOut,
    BYTE __RPC_FAR *pbIn,
    DWORD cbIn,
    LPCWSTR szDataDescr,
    BYTE* pbOptionalEntropy,
    DWORD cbOptionalEntropy,
    GUID* pProvider,
    PSSCRYPTPROTECTDATA_PROMPTSTRUCT pPromptStruct,
    DWORD dwFlags,
    BYTE* pbOptionalPassword,
    DWORD cbOptionalPassword
    )
{
    DWORD   dwRet;


    DWORD   dwHeaderSize = sizeof(GUID)+sizeof(DWORD);
    PBYTE   pbWritePtr;

    CRYPT_SERVER_CONTEXT ServerContext;
    DWORD dwTempLastError = CPSCreateServerContext(&ServerContext, h);
    if(dwTempLastError != ERROR_SUCCESS)
        return dwTempLastError;


    //
    // User mode cannot request encryption of system blobs
    if(dwFlags & CRYPTPROTECT_SYSTEM)
    {
        return ERROR_INVALID_PARAMETER;
    }

    __try {

    // don't validate flags parameter


        // get policy for this level

        // UNDONE: what do policy bits allow an admin to set?
        // maybe a recovery agent, other defaults?
        GetPolicyBits();


        dwRet = SPCryptProtect(
                    &ServerContext,
                    ppbOut,
                    pcbOut,
                    pbIn,
                    cbIn,
                    szDataDescr,
                    pbOptionalEntropy,
                    cbOptionalEntropy,
                    pPromptStruct,
                    dwFlags,
                    pbOptionalPassword, // following 2 fields considered temporary
                    cbOptionalPassword  // until SAS UI supported
                    );

        ZeroMemory( pbIn, cbIn );
        if ( dwRet != ERROR_SUCCESS || *ppbOut == NULL )
            goto Ret;

        // move entire block down, sneak header in
        *ppbOut = (PBYTE)SSReAlloc(*ppbOut, *pcbOut + dwHeaderSize);
        if(NULL == *ppbOut)
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        MoveMemory(*ppbOut + dwHeaderSize, *ppbOut, *pcbOut);
        *pcbOut += dwHeaderSize;

        pbWritePtr = *ppbOut;
        *(DWORD*)pbWritePtr = CRYPTPROTECT_SVR_VERSION_1;
        pbWritePtr += sizeof(DWORD);

        CopyMemory(pbWritePtr, &g_guidDefaultProvider, sizeof(GUID));
        pbWritePtr += sizeof(GUID);

        dwRet = ERROR_SUCCESS;

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        dwRet = GetExceptionCode();
        // TODO: for NT, convert exception code to winerror.
        //       for 95, just override to access violation.
    }

Ret:
    CPSDeleteServerContext( &ServerContext );
    return dwRet;
}

DWORD
s_SSCryptUnprotectData(
    handle_t h,
    BYTE __RPC_FAR *__RPC_FAR *ppbOut,
    DWORD __RPC_FAR *pcbOut,
    BYTE __RPC_FAR *pbIn,
    DWORD cbIn,
    LPWSTR* ppszDataDescr,
    BYTE* pbOptionalEntropy,
    DWORD cbOptionalEntropy,
    GUID* pProvider,
    PSSCRYPTPROTECTDATA_PROMPTSTRUCT pPromptStruct,
    DWORD dwFlags,
    BYTE* pbOptionalPassword,
    DWORD cbOptionalPassword
    )
{
    DWORD   dwRet;
    PBYTE   pbReadPtr = pbIn;
    GUID    guidProvider;
    CRYPT_SERVER_CONTEXT ServerContext;

    // User mode cannot request decryption of system blobs
    if(dwFlags & CRYPTPROTECT_SYSTEM)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Error out if input buffer is smaller than the minumum size.
    if(cbIn < sizeof(DWORD) + sizeof(GUID))
    {
        return ERROR_INVALID_DATA;
    }

    // Create a server context.
    dwRet = CPSCreateServerContext(&ServerContext, h);
    if(dwRet != ERROR_SUCCESS)
    {
        return dwRet;
    }

    __try {

        // get policy for this level

        // UNDONE: what do policy bits allow an admin to set?
        // maybe a recovery agent, other defaults?
        GetPolicyBits();

        if (*(DWORD*)pbReadPtr != CRYPTPROTECT_SVR_VERSION_1)
        {
            dwRet = ERROR_INVALID_DATA;
            goto Ret;
        }
        pbReadPtr += sizeof(DWORD);

        // next field in Data is provider GUID
        CopyMemory(&guidProvider, pbReadPtr, sizeof(GUID));
        pbReadPtr += sizeof(GUID);

        // echo out if requested
        if (pProvider)
            CopyMemory(pProvider, &guidProvider, sizeof(GUID));


        dwRet = SPCryptUnprotect(
                    &ServerContext,
                    ppbOut,
                    pcbOut,
                    pbReadPtr,
                    (cbIn - (LONG)(pbReadPtr - pbIn)) , // eg (200 - (0x00340020 - 0x00340000))
                    ppszDataDescr,
                    pbOptionalEntropy,
                    cbOptionalEntropy,
                    pPromptStruct,
                    dwFlags,
                    pbOptionalPassword, // following 2 fields considered temporary
                    cbOptionalPassword  // until SAS UI supported
                    );

        ZeroMemory( pbIn, cbIn );

        if (dwRet != ERROR_SUCCESS)
            goto Ret;

        dwRet = ERROR_SUCCESS; // it's already this at this point in time for now.

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        dwRet = GetExceptionCode();
        // TODO: for NT, convert exception code to winerror.
        //       for 95, just override to access violation.
    }

Ret:

    CPSDeleteServerContext( &ServerContext );
    return dwRet;
}






BOOLEAN
LsaICryptProtectData(
        IN PVOID          DataIn,
        IN ULONG         DataInLength,
        IN PUNICODE_STRING DataDescr,
        IN PVOID          OptionalEntropy,
        IN ULONG          OptionalEntropyLength,
        IN PVOID          Reserved,
        IN PVOID          Reserved2,
        IN ULONG          Flags,
        OUT PVOID  *      DataOut,
        OUT PULONG        DataOutLength)
{
    DWORD dwRetVal = ERROR_SUCCESS;
    CRYPT_SERVER_CONTEXT ServerContext;;

    DWORD   dwHeaderSize = sizeof(GUID)+sizeof(DWORD);
    PBYTE   pbWritePtr;



    dwRetVal = CPSCreateServerContext(&ServerContext, NULL);
    if(dwRetVal != ERROR_SUCCESS)
    {
        SetLastError(dwRetVal);
        return FALSE;
    }


    // check params
    if ((DataOut == NULL) ||
        (DataIn == NULL) ||
        (NULL == DataDescr))
    {
        dwRetVal = ERROR_INVALID_PARAMETER;
        goto error;
    }

    __try {

        if(ServerContext.fImpersonating)
        {
            CPSRevertToSelf(&ServerContext);
        }


        // don't validate flags parameter


        // get policy for this level

        // UNDONE: what do policy bits allow an admin to set?
        // maybe a recovery agent, other defaults?
        GetPolicyBits();

        *DataOut = NULL;
        *DataOutLength = 0;

        dwRetVal = SPCryptProtect(
                    &ServerContext,
                    (PBYTE *)DataOut,
                    DataOutLength,
                    (PBYTE)DataIn,
                    DataInLength,
                    DataDescr?DataDescr->Buffer:NULL,
                    (PBYTE)OptionalEntropy,
                    OptionalEntropyLength,
                    NULL,
                    Flags,
                    NULL, // following 2 fields considered temporary
                    0  // until SAS UI supported
                    );

        if ( dwRetVal != ERROR_SUCCESS || *DataOut == NULL )
            goto error;

        // move entire block down, sneak header in
        *DataOut =SSReAlloc(*DataOut, *DataOutLength + dwHeaderSize);
        if(NULL == *DataOut)
        {
            dwRetVal = ERROR_NOT_ENOUGH_MEMORY;
            goto error;
        }
        MoveMemory((PBYTE)*DataOut + dwHeaderSize, *DataOut, *DataOutLength);
        *DataOutLength += dwHeaderSize;

        pbWritePtr = (PBYTE)*DataOut;
        *(DWORD*)pbWritePtr = CRYPTPROTECT_SVR_VERSION_1;
        pbWritePtr += sizeof(DWORD);

        CopyMemory(pbWritePtr, &g_guidDefaultProvider, sizeof(GUID));
        pbWritePtr += sizeof(GUID);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwRetVal = GetExceptionCode();
    }


error:
    if(ServerContext.fImpersonating)
    {
        CPSImpersonateClient(&ServerContext);
    }

    CPSDeleteServerContext( &ServerContext );


    if(dwRetVal != ERROR_SUCCESS) {
        SetLastError(dwRetVal);
        return FALSE;
    }

    return TRUE;
}




BOOLEAN
LsaICryptUnprotectData(
        IN PVOID          DataIn,
        IN ULONG          DataInLength,
        IN PVOID          OptionalEntropy,
        IN ULONG          OptionalEntropyLength,
        IN PVOID          Reserved,
        IN PVOID          Reserved2,
        IN ULONG          Flags,
        OUT PUNICODE_STRING        DataDescr,
        OUT PVOID  *      DataOut,
        OUT PULONG        DataOutLength)
{
    DWORD dwRetVal = ERROR_SUCCESS;
    CRYPT_SERVER_CONTEXT ServerContext;;

    DWORD   dwHeaderSize = sizeof(GUID)+sizeof(DWORD);
    PBYTE   pbWritePtr;
    LPWSTR  wszDataDescr = NULL;



    dwRetVal = CPSCreateServerContext(&ServerContext, NULL);
    if(dwRetVal != ERROR_SUCCESS)
    {
        SetLastError(dwRetVal);
        return FALSE;
    }

    // check params
    if ((DataOut == NULL) ||
        (DataIn == NULL))
    {
        dwRetVal = ERROR_INVALID_PARAMETER;
        goto error;
    }

    __try {

        if(ServerContext.fImpersonating)
        {
            CPSRevertToSelf(&ServerContext);
        }


        // don't validate flags parameter


        // get policy for this level

        // UNDONE: what do policy bits allow an admin to set?
        // maybe a recovery agent, other defaults?
        GetPolicyBits();


        //
        // define outer+inner wrapper for security blob.
        // this won't be necessary once SAS support is provided by the OS.
        //

        typedef struct {
            DWORD dwOuterVersion;
            GUID guidProvider;

            DWORD dwVersion;
            GUID guidMK;
            DWORD dwPromptFlags;
            DWORD cbDataDescr;
            WCHAR szDataDescr[1];
        } sec_blob, *psec_blob;

        sec_blob *SecurityBlob = (sec_blob*)(DataIn);


        //
        // zero so client stub allocates
        //

        *DataOut = NULL;
        *DataOutLength = 0;


        //
        // only call UI function if prompt flags dictate, because we don't
        // want to bring in cryptui.dll unless necessary.
        //

        if( ((SecurityBlob->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_UNPROTECT) ||
             (SecurityBlob->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_PROTECT))
            )
        {

            dwRetVal = ERROR_INVALID_PARAMETER;
            goto error;

        } else {
            if(SecurityBlob->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG )
            {
                dwRetVal = ERROR_INVALID_PARAMETER;
                goto error;
            }
        }


        if (SecurityBlob->dwOuterVersion != CRYPTPROTECT_SVR_VERSION_1)
        {
            dwRetVal = ERROR_INVALID_DATA;
            goto error;
        }

        if(0 != memcmp(&SecurityBlob->guidProvider, &g_guidDefaultProvider, sizeof(GUID)))
        {
            dwRetVal = ERROR_INVALID_DATA;
            goto error;
        }

        Flags |= CRYPTPROTECT_IN_PROCESS;

        dwRetVal = SPCryptUnprotect(
                    &ServerContext,
                    (PBYTE *)DataOut,
                    DataOutLength,
                    (PBYTE)DataIn + sizeof(DWORD) + sizeof(GUID),
                    (DataInLength - (LONG)(sizeof(DWORD) + sizeof(GUID))) ,
                    DataDescr?&wszDataDescr:NULL,
                    (PBYTE)OptionalEntropy,
                    OptionalEntropyLength,
                    NULL,
                    Flags,
                    NULL, // following 2 fields considered temporary
                    0  // until SAS UI supported
                    );

        if (dwRetVal != ERROR_SUCCESS)
        {
            goto error;
        }

        if(NULL != DataDescr)
        {
            RtlInitUnicodeString(DataDescr, wszDataDescr);
        }




    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwRetVal = GetExceptionCode();
    }

error:
    if(ServerContext.fImpersonating)
    {
        // Impersonate back to the impersonation context
        CPSImpersonateClient(&ServerContext);
    }
    CPSDeleteServerContext( &ServerContext );


    SetLastError(dwRetVal);
    if(dwRetVal != ERROR_SUCCESS && dwRetVal != CRYPT_I_NEW_PROTECTION_REQUIRED ) {
        return FALSE;
    }
    return TRUE;
}


DWORD
WINAPI
CPSGetSidHistory(
    IN      PVOID pvContext,
    OUT     PSID  **papsidHistory,
    OUT     DWORD *cpsidHistory
    )
{
    DWORD dwLastError = ERROR_SUCCESS;
    BYTE FastBuffer[256];
    BYTE GroupsFastBuffer[256];
    LPBYTE SlowBuffer = NULL;
    PTOKEN_USER ptgUser;
    PTOKEN_GROUPS ptgGroups = NULL;
    DWORD cbBuffer;
    DWORD cbSid;
    DWORD cSids = 0;
    PBYTE pbCurrentSid = NULL;
    DWORD i;


    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;


    //
    // try querying based on a fast stack based buffer first.
    //

    ptgUser = (PTOKEN_USER)FastBuffer;
    cbBuffer = sizeof(FastBuffer);

    if(!GetTokenInformation(
                    pServerContext->hToken,    // identifies access token
                    TokenUser, // TokenUser info type
                    ptgUser,   // retrieved info buffer
                    cbBuffer,  // size of buffer passed-in
                    &cbBuffer  // required buffer size
                    ))
    {
        dwLastError = GetLastError();

        if(dwLastError != ERROR_INSUFFICIENT_BUFFER)
        {
            goto error;
        }

        //
        // try again with the specified buffer size
        //

        ptgUser = (PTOKEN_USER)SSAlloc(cbBuffer);
        if(NULL == ptgUser)
        {
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            goto error;
        }



        if(!GetTokenInformation(
                            pServerContext->hToken,    // identifies access token
                            TokenUser, // TokenUser info type
                            ptgUser,   // retrieved info buffer
                            cbBuffer,  // size of buffer passed-in
                            &cbBuffer  // required buffer size
                            ))
        {
            dwLastError = GetLastError();
            goto error;
        }

    }


    //
    // try querying based on a fast stack based buffer first.
    //

    ptgGroups = (PTOKEN_GROUPS)GroupsFastBuffer;
    cbBuffer = sizeof(GroupsFastBuffer);

    if(!GetTokenInformation(
                    pServerContext->hToken,    // identifies access token
                    TokenGroups, // TokenUser info type
                    ptgGroups,   // retrieved info buffer
                    cbBuffer,  // size of buffer passed-in
                    &cbBuffer  // required buffer size
                    ))
    {
        dwLastError = GetLastError();

        if(dwLastError != ERROR_INSUFFICIENT_BUFFER)
        {
            goto error;
        }
        dwLastError = ERROR_SUCCESS;

        //
        // try again with the specified buffer size
        //

        ptgGroups = (PTOKEN_GROUPS)SSAlloc(cbBuffer);
        if(NULL == ptgGroups)
        {
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            goto error;
        }



        if(!GetTokenInformation(
                            pServerContext->hToken,    // identifies access token
                            TokenGroups, // TokenUser info type
                            ptgGroups,   // retrieved info buffer
                            cbBuffer,  // size of buffer passed-in
                            &cbBuffer  // required buffer size
                            ))
        {
            dwLastError = GetLastError();
            goto error;
        }

    }


    //
    // if we got the token info successfully, copy the
    // relevant element for the caller.
    //

    cbSid = GetLengthSid(ptgUser->User.Sid);
    cSids = 1;

    for(i=0; i < ptgGroups->GroupCount; i++)
    {
        if(0 == (SE_GROUP_ENABLED & ptgGroups->Groups[i].Attributes))
        {
            continue;
        }
        if(0 == ((SE_GROUP_OWNER | SE_GROUP_USE_FOR_DENY_ONLY) & ptgGroups->Groups[i].Attributes))
        {
            continue;
        }
        cbSid += GetLengthSid(ptgGroups->Groups[i].Sid);
        cSids ++;

    }


    *cpsidHistory = cSids;
    *papsidHistory = (PSID *)SSAlloc(cSids*sizeof(PSID) +  cbSid );

    if(*papsidHistory == NULL)
    {
        dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    else
    {
        pbCurrentSid = (PBYTE)((*papsidHistory)+cSids);

        // Fill in the primary user SID
        (*papsidHistory)[0] = (PSID)pbCurrentSid;
        cbSid = GetLengthSid(ptgUser->User.Sid);
        CopySid(cbSid, pbCurrentSid, ptgUser->User.Sid);
        pbCurrentSid += cbSid;

        cSids = 1;

        // Fill in the rest of the SIDs
        for(i=0; i < ptgGroups->GroupCount; i++)
        {
            if(0 == (SE_GROUP_ENABLED & ptgGroups->Groups[i].Attributes))
            {
                continue;
            }
            if(0 == ((SE_GROUP_OWNER | SE_GROUP_USE_FOR_DENY_ONLY) & ptgGroups->Groups[i].Attributes))
            {
                continue;
            }
            (*papsidHistory)[cSids++] = pbCurrentSid;
            cbSid = GetLengthSid(ptgGroups->Groups[i].Sid);
            CopySid(cbSid, pbCurrentSid,ptgGroups->Groups[i].Sid);
            pbCurrentSid += cbSid;
        }
    }


error:

    if(FastBuffer != (PBYTE)ptgUser)
    {
        SSFree(ptgUser);
    }

    if(GroupsFastBuffer != (PBYTE)ptgGroups)
    {
        SSFree(ptgGroups);
    }


    return dwLastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\capiprim.h ===
BOOL FMyPrimitiveCryptHMAC(
        PBYTE       pbKeyMaterial,
        DWORD       cbKeyMaterial,
        PBYTE       pbData,
        DWORD       cbData,
        HCRYPTPROV  hVerifyProv,
        DWORD       dwHashAlg,
        HCRYPTHASH* phHash);                     // out

#if DBG
void CheckMACInterop(
        PBYTE       pbMonsterPwdBuf,
        DWORD       cbMonsterPwdBuf,
        PBYTE       pbKeySalt,
        DWORD       cbKeySalt,
        HCRYPTPROV  hVerifyProv,
        ALG_ID      algDerivationHash);
#endif

// USEC -- (US Export Controls)
DWORD GetSaltForExportControl(
        HCRYPTPROV  hProv,
        HCRYPTKEY   hKey,
        PBYTE*      ppbSalt,
        DWORD*      pcbSalt);

DWORD SetSaltForExportControl(
        HCRYPTKEY   hKey,
        PBYTE       pbSalt,
        DWORD       cbSalt);

HCRYPTPROV
GetCryptProviderHandle(
        DWORD       dwDefaultCSPType,
        DWORD       dwAlgId1,
        DWORD*      pdwKeySize1,
        DWORD       dwAlgId2,
        DWORD*      pdwKeySize2);

DWORD GetCryptProviderFromRequirements(
        DWORD       dwAlgId1,
        DWORD*      pdwKeySize1,
        DWORD       dwAlgId2,
        DWORD*      pdwKeySize2,
        DWORD*      pdwProvType,
        LPWSTR*     ppszProvName);

BOOL  FProviderSupportsAlg(
        HCRYPTPROV  hQueryProv,
        DWORD       dwAlgId,
        DWORD*      pdwKeySize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\crypt32.h ===
#ifndef _CRYPT32_H_

#define _CRYPT32_H_

#ifdef _cplusplus
extern "C" {
#endif

typedef struct {
    DWORD       cbSize;                 // size for validity check.
    handle_t    hBinding;               // RPC binding handle.
    BOOL        fOverrideToLocalSystem; // over-ride impersonation to Local System?
    BOOL        fImpersonating;         // Impersonating
    HANDLE      hToken;                 // access token for impersonation when duplicate
    LPWSTR      szUserStorageArea;      // cached user storage area
} CRYPT_SERVER_CONTEXT, *PCRYPT_SERVER_CONTEXT;




//
// note: unclear at the moment whether these will be public.
//

DWORD
CPSCreateServerContext(
    OUT     PCRYPT_SERVER_CONTEXT pServerContext,
    IN      handle_t hBinding
    );

DWORD
CPSDeleteServerContext(
    IN      PCRYPT_SERVER_CONTEXT pServerContext
    );

DWORD CPSDuplicateContext(
    IN      PVOID pvContext,
    IN OUT  PVOID *ppvDuplicateContext
    );

DWORD CPSFreeContext(
    IN      PVOID pvDuplicateContext
    );

DWORD CPSImpersonateClient(
    IN      PVOID pvContext
    );

DWORD CPSRevertToSelf(
    IN      PVOID pvContext
    );

DWORD CPSOverrideToLocalSystem(
    IN      PVOID pvContext,
    IN      BOOL *pfLocalSystem,
    IN OUT  BOOL *pfCurrentlyLocalSystem
    );

DWORD
CPSDuplicateClientAccessToken(
    IN      PVOID pvContext,            // server context
    IN OUT  HANDLE *phToken
    );

DWORD CPSGetUserName(
    IN      PVOID pvContext,
        OUT LPWSTR *ppszUserName,
        OUT DWORD *pcchUserName
    );


#define USE_DPAPI_OWF           0x1
#define USE_ROOT_CREDENTIAL     0x2

DWORD CPSGetDerivedCredential(
    IN      PVOID pvContext,
    IN      GUID *pCredentialID,
    IN      DWORD dwFlags, 
    IN      PBYTE pbMixingBytes,
    IN      DWORD cbMixingBytes,
    IN OUT  BYTE rgbDerivedCredential[A_SHA_DIGEST_LEN]
    );

DWORD CPSGetSystemCredential(
    IN      PVOID pvContext,
    IN      BOOL fLocalMachine,
    IN OUT  BYTE rgbSystemCredential[A_SHA_DIGEST_LEN]
    );


DWORD CPSCreateWorkerThread(
    IN      PVOID pThreadFunc,
    IN      PVOID pThreadArg
    );

DWORD CPSAudit(
    IN      HANDLE      hToken,
    IN      DWORD       dwAuditID,
    IN      LPCWSTR     wszMasterKeyID,
    IN      LPCWSTR     wszRecoveryServer,
    IN      DWORD       dwReason,
    IN      LPCWSTR     wszRecoveryKeyID,
    IN      DWORD       dwFailure);


DWORD
WINAPI
CPSGetSidHistory(
    IN      PVOID pvContext,
    OUT     PSID  **papsidHistory,
    OUT     DWORD *cpsidHistory
    );    

DWORD
CPSGetUserStorageArea(
    IN      PVOID   pvContext,
    IN      PSID    pSid,     // optional
    IN      BOOL    fCreate,  // Create the storage area if it doesn't exist
    IN  OUT LPWSTR *ppszUserStorageArea
    );


#ifdef _cplusplus
} // extern "C"
#endif

#endif // _CRYPT32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\crypt32p.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    session.h

Abstract:

    This module contains prototypes to support communication with the LSA
    (Local Security Authority) to permit querying of active sessions.

Author:

    Scott Field (sfield)    02-Mar-97

--*/

#ifndef __CRYPT32P_H__
#define __CRYPT32P_H__

DWORD
WINAPI
SPCryptProtect(
        PVOID       pvContext,      // server context
        PBYTE*      ppbOut,         // out encr data
        DWORD*      pcbOut,         // out encr cb
        PBYTE       pbIn,           // in ptxt data
        DWORD       cbIn,           // in ptxt cb
        LPCWSTR     szDataDescr,    // in
        PBYTE       pbOptionalEntropy,  // OPTIONAL
        DWORD       cbOptionalEntropy,
        PSSCRYPTPROTECTDATA_PROMPTSTRUCT      psPrompt,       // OPTIONAL prompting struct
        DWORD       dwFlags,
        BYTE*       pbOptionalPassword,
        DWORD       cbOptionalPassword
        );

DWORD
WINAPI
SPCryptUnprotect(
        PVOID       pvContext,                          // server context
        PBYTE*      ppbOut,                             // out ptxt data
        DWORD*      pcbOut,                             // out ptxt cb
        PBYTE       pbIn,                               // in encr data
        DWORD       cbIn,                               // in encr cb
        LPWSTR*     ppszDataDescr,                      // OPTIONAL
        PBYTE       pbOptionalEntropy,                  // OPTIONAL
        DWORD       cbOptionalEntropy,
        PSSCRYPTPROTECTDATA_PROMPTSTRUCT  psPrompt,   // OPTIONAL, prompting struct
        DWORD       dwFlags,
        BYTE*       pbOptionalPassword,
        DWORD       cbOptionalPassword
        );


#endif // __CRYPT32P_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\crypt32p.cpp ===
/*
    File:       crypt32.cpp

    Title:      CryptProtect APIs
    Author:     Matt Thomlinson
    Date:       8/2/97


    The CryptProtect API set allows an application to secure
    user data for online and offline storage. While the well-known problem
    of data storage is left to the calling application, this solves the
    relatively unsolved problem of how to cryptographically derive strong
    keys for storing the data. These APIs are initially available on NT5 only.

    Very little checking is done at this level to validate the caller. We
    believe that problem should be solved at a different level -- since all
    other system security is granular to the user, it is difficult to create a
    feature that provides something more granular. Instead, any process running
    under the logged-in user has the ability to decrypt any and all items it
    can retrieve. Callers should note that while items are being processed,
    UI may be spawned to notify the user.

    For user confirmation, the NT secure attention sequence is used to
    garner the wishes of the user. This behavior is set by the caller during protection.

*/

#include <pch.cpp>
#pragma hdrstop
#include "msaudite.h"
#include "crypt.h"

int
WINAPI
ServiceMessageBox(
    IN      PVOID pvContext,
    IN      HWND hWnd,
    IN      LPCWSTR lpText,
    IN      LPCWSTR lpCaption,
    IN      UINT uType
    );




#define             ALGID_DERIVEKEY_HASH        CALG_SHA1       // doesn't change


// USEC: can be as long as we want, since we castrate generated key later
#define             KEY_DERIVATION_BUFSIZE      (128/8)
#define             DEFAULT_BLOCKSIZE_OVERRUN   (128/8)     // allow block ciphers to process up to a 128 bits at a time

#define             MS_BASE_CRYPTPROTECT_VERSION    0x01




DWORD
WINAPI
SPCryptProtect(
        PVOID       pvContext,      // server context
        PBYTE*      ppbOut,         // out encr data
        DWORD*      pcbOut,         // out encr cb
        PBYTE       pbIn,           // in ptxt data
        DWORD       cbIn,           // in ptxt cb
        LPCWSTR     szDataDescr,    // in
        PBYTE       pbOptionalEntropy,  // OPTIONAL
        DWORD       cbOptionalEntropy,
        PSSCRYPTPROTECTDATA_PROMPTSTRUCT      psPrompt,       // OPTIONAL prompting struct
        DWORD       dwFlags,
        BYTE*       pbOptionalPassword,
        DWORD       cbOptionalPassword
        )
{
    DWORD       dwRet;
    LPWSTR      szUser = NULL;
    PBYTE       pbWritePtr = NULL;
    GUID        guidMK;

    WCHAR       wszMKGuidString[MAX_GUID_SZ_CHARS];

    HCRYPTPROV  hVerifyProv;
    HCRYPTHASH  hHash = NULL;
    HCRYPTKEY   hKey = NULL;

    PBYTE       pbCrypt = NULL;
    DWORD       cbCrypt = 0;

    DWORD       cbEncrypted; // count of bytes to encrypt

    PBYTE       pbEncrSalt = NULL;
    DWORD       cbEncrSalt = 0;

    BYTE        rgbPwdBuf[A_SHA_DIGEST_LEN];

    DWORD       cbMACSize = A_SHA_DIGEST_LEN;

    BYTE        rgbEncrKey[KEY_DERIVATION_BUFSIZE];
    BYTE        rgbMACKey[KEY_DERIVATION_BUFSIZE];

    LPBYTE      pbMasterKey = NULL;
    DWORD       cbMasterKey;

    PBYTE       pStreamFlagPtr;

    DWORD       dwProtectionFlags = 0;

    DWORD   dwDefaultCryptProvType = 0;
    DWORD   dwAlgID_Encr_Alg = 0;
    DWORD   dwAlgID_Encr_Alg_KeySize = 0; 
    DWORD   dwAlgID_MAC_Alg = 0;
    DWORD   dwAlgID_MAC_Alg_KeySize = 0;

    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;


#if DBG
    D_DebugLog((DEB_TRACE_API,"SPCryptProtect 0x%x called\n", pServerContext));

    if(pServerContext)
    {
        if(pServerContext->cbSize == sizeof(CRYPT_SERVER_CONTEXT))
        {
            D_DebugLog((DEB_TRACE_API, "  pServerContext->hBinding:%d\n", pServerContext->hBinding));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->fOverrideToLocalSystem:%d\n", pServerContext->fOverrideToLocalSystem));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->fImpersonating:%d\n", pServerContext->fImpersonating));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->hToken:%d\n", pServerContext->hToken));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->szUserStorageArea:%ls\n", pServerContext->szUserStorageArea));
        }
    }
    
    D_DebugLog((DEB_TRACE_API, "  pbInput:0x%x\n", pbIn));
    D_DebugLog((DEB_TRACE_API, "  pszDataDescr:%ls\n", szDataDescr));
    D_DebugLog((DEB_TRACE_API, "  pbOptionalEntropy:0x%x\n", pbOptionalEntropy));
    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "    ", pbOptionalEntropy, cbOptionalEntropy);
    D_DebugLog((DEB_TRACE_API, "  dwFlags:0x%x\n", dwFlags));
    D_DebugLog((DEB_TRACE_API, "  pbOptionalPassword:0x%x\n", pbOptionalPassword));
    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "    ", pbOptionalPassword, cbOptionalPassword);
#endif

    ZeroMemory(&guidMK, sizeof(guidMK));
    wszMKGuidString[0] = 0;

    GetDefaultAlgInfo(&dwDefaultCryptProvType,
                      &dwAlgID_Encr_Alg,
                      &dwAlgID_Encr_Alg_KeySize,
                      &dwAlgID_MAC_Alg,
                      &dwAlgID_MAC_Alg_KeySize);

    if( dwFlags & CRYPTPROTECT_LOCAL_MACHINE ) {
        BOOL fOverrideToLocalSystem = TRUE;

        CPSOverrideToLocalSystem(
                pvContext,
                &fOverrideToLocalSystem,
                NULL    // don't care what previous value was
                );

        dwProtectionFlags |= CRYPTPROTECT_LOCAL_MACHINE;
    }


    if( dwFlags & CRYPTPROTECT_CRED_SYNC )
    {
        dwRet = CPSImpersonateClient( pvContext );
        if( dwRet == ERROR_SUCCESS )
        {
            dwRet = InitiateSynchronizeMasterKeys( pvContext );

            CPSRevertToSelf( pvContext );
        }

        return dwRet;
    }

    if( dwFlags & CRYPTPROTECT_CRED_REGENERATE )
    {
        dwRet = DpapiUpdateLsaSecret( pvContext );
        return dwRet;
    }


    //
    // include additional flags
    //
    dwProtectionFlags |= (dwFlags & (CRYPTPROTECT_SYSTEM | CRYPTPROTECT_AUDIT));

    // else no override; get provider by algs alone
    if (NULL == (hVerifyProv =
        GetCryptProviderHandle(
            dwDefaultCryptProvType,
            dwAlgID_Encr_Alg, &dwAlgID_Encr_Alg_KeySize,
            dwAlgID_MAC_Alg, &dwAlgID_MAC_Alg_KeySize)) )
    {
        dwRet = GetLastError();
        goto Ret;
    }

    dwRet = GetSpecifiedMasterKey(
            pvContext,
            &guidMK,
            &pbMasterKey,
            &cbMasterKey,
            FALSE   // we don't know what master key we want to use - use preferred
            );

    if(dwRet != ERROR_SUCCESS)
        goto Ret;

    MyGuidToStringW(&guidMK, wszMKGuidString);

    //
    // hash pbMasterKey to get rgbPwdBuf
    //

    FMyPrimitiveSHA( pbMasterKey, cbMasterKey, rgbPwdBuf );


    // derive encr key
    {
        if (!RtlGenRandom(
                rgbEncrKey,
                sizeof(rgbEncrKey)))
        {
            dwRet = GetLastError();
            goto Ret;
        }

#if DBG
    // Leave here as regression check
    CheckMACInterop(rgbPwdBuf, sizeof(rgbPwdBuf), rgbEncrKey, sizeof(rgbEncrKey), hVerifyProv, ALGID_DERIVEKEY_HASH);
#endif

        if (!FMyPrimitiveCryptHMAC(
                    rgbPwdBuf,
                    sizeof(rgbPwdBuf),
                    rgbEncrKey,
                    sizeof(rgbEncrKey),
                    hVerifyProv,
                    ALGID_DERIVEKEY_HASH,
                    &hHash))
        {
            dwRet = GetLastError();
            goto Ret;
        }

        // add password if exists
        if (NULL != pbOptionalEntropy)
        {
            if (!CryptHashData(
                    hHash,
                    pbOptionalEntropy,
                    cbOptionalEntropy,
                    0))
            {
                dwRet = GetLastError();
                goto Ret;
            }
        }

        // add prompted UI based password if exists.
        // will eventually come from SAS
        //

        if ( NULL != pbOptionalPassword && cbOptionalPassword )
        {
            if (!CryptHashData(
                    hHash,
                    pbOptionalPassword,
                    cbOptionalPassword,
                    0))
            {
                dwRet = GetLastError();
                goto Ret;
            }

        }

        if (!CryptDeriveKey(
                hVerifyProv,
                dwAlgID_Encr_Alg,
                hHash,
                CRYPT_CREATE_SALT,
                &hKey))
        {
            dwRet = GetLastError();
            goto Ret;
        }

        CryptDestroyHash(hHash);
        hHash = 0;

        // USEC -- (US Export Controls)
        if (ERROR_SUCCESS != (dwRet =
            GetSaltForExportControl(
                hVerifyProv,
                hKey,
                &pbEncrSalt,
                &cbEncrSalt)) )
            goto Ret;
    }

    // derive MAC key
    {
        if (!RtlGenRandom(
                rgbMACKey,
                sizeof(rgbMACKey)))
        {
            dwRet = GetLastError();
            goto Ret;
        }
        if (!FMyPrimitiveCryptHMAC(
                    rgbPwdBuf,
                    sizeof(rgbPwdBuf),
                    rgbMACKey,
                    sizeof(rgbMACKey),
                    hVerifyProv,
                    dwAlgID_MAC_Alg,
                    &hHash))
        {
            dwRet = GetLastError();
            goto Ret;
        }

        // add password if exists
        if (NULL != pbOptionalEntropy)
        {
            if (!CryptHashData(
                    hHash,
                    pbOptionalEntropy,
                    cbOptionalEntropy,
                    0))
            {
                dwRet = GetLastError();
                goto Ret;
            }
        }

        // add prompted UI based password if exists.
        // will eventually come from SAS
        //

        if ( NULL != pbOptionalPassword && cbOptionalPassword )
        {
            if (!CryptHashData(
                    hHash,
                    pbOptionalPassword,
                    cbOptionalPassword,
                    0))
            {
                dwRet = GetLastError();
                goto Ret;
            }

        }

        // USEC -- (US Export Controls)
        // Does not apply to MAC -- use strong key
    }

    // hash & encrypt the data
    cbCrypt = cbIn + DEFAULT_BLOCKSIZE_OVERRUN;
    if (NULL == (pbCrypt = (PBYTE)SSAlloc(cbCrypt)) )
    {
        dwRet = ERROR_OUTOFMEMORY;
        goto Ret;
    }
    CopyMemory(pbCrypt, pbIn, cbIn);

    // now write data out: size?
    *pcbOut = sizeof(GUID) + 2*sizeof(DWORD);                                   // dwVer + guidMK + dwFlags
    *pcbOut += sizeof(DWORD) + WSZ_BYTECOUNT(szDataDescr);                      // data description
    *pcbOut += 3*sizeof(DWORD) + sizeof(rgbEncrKey);                            // EncrAlgID + AlgIDKeySize + cbEncrKey + EncrKey
    *pcbOut += sizeof(DWORD) + cbEncrSalt;                                      // Encr salt
    *pcbOut += 3*sizeof(DWORD) + sizeof(rgbMACKey);                             // MACAlgID + AlgIDKeySize + cbMACKey + MACKey
    *pcbOut += sizeof(DWORD) + cbCrypt;                                         // size + encrypted data (guess)
    *pcbOut += sizeof(DWORD) + A_SHA_DIGEST_LEN;                                // MAC + MACsize

    *ppbOut = (PBYTE)SSAlloc(*pcbOut);
    if( *ppbOut == NULL ) {
        dwRet = ERROR_OUTOFMEMORY;
        goto Ret;
    }

    ZeroMemory( *ppbOut, *pcbOut );

    pbWritePtr = *ppbOut;

    ////////////////////////////////////////////////////////////////////
    // FYI: Data format
    // (    Version | guidMKid | dwFlags |
    //      cbDataDescr | szDataDescr |
    //
    //      dwEncrAlgID | dwEncrAlgKeySize |
    //      cbEncrKey | EncrKey |
    //      cbEncrSalt | EncrSalt |
    //
    //      dwMACAlgID | dwMACAlgKeySize |
    //      cbMACKey | MACKey |
    //
    //      cbEncrData | EncrData |
    //      cbMAC | MAC )
    //
    // NOTE: entire buffer from Version through EncrData is included in MAC
    ////////////////////////////////////////////////////////////////////

    // dwVersion
    *(DWORD UNALIGNED *)pbWritePtr = MS_BASE_CRYPTPROTECT_VERSION;
    pbWritePtr += sizeof(DWORD);

    // guid MKid
    CopyMemory(pbWritePtr, &guidMK, sizeof(GUID));
    pbWritePtr += sizeof(GUID);

    // dwFlags -- written out later via pStreamFlagPtr
    pStreamFlagPtr = pbWritePtr;
    pbWritePtr += sizeof(DWORD);

    // cbDataDescr
    *(DWORD UNALIGNED *)pbWritePtr = WSZ_BYTECOUNT(szDataDescr);
    pbWritePtr += sizeof(DWORD);

    // szDataDescr
    CopyMemory(pbWritePtr, szDataDescr, WSZ_BYTECOUNT(szDataDescr));
    pbWritePtr += WSZ_BYTECOUNT(szDataDescr);

    // dwEncrAlgID
    *(DWORD UNALIGNED *)pbWritePtr = dwAlgID_Encr_Alg;
    pbWritePtr += sizeof(DWORD);

    // dwEncrAlgKeySize
    *(DWORD UNALIGNED *)pbWritePtr = dwAlgID_Encr_Alg_KeySize;
    pbWritePtr += sizeof(DWORD);

     // cb EncrKey
    *(DWORD UNALIGNED *)pbWritePtr = sizeof(rgbEncrKey);
    pbWritePtr += sizeof(DWORD);

    // Encr Key
    CopyMemory(pbWritePtr, rgbEncrKey, sizeof(rgbEncrKey));
    pbWritePtr += sizeof(rgbEncrKey);

    // cb Encr salt
    *(DWORD UNALIGNED *)pbWritePtr = cbEncrSalt;
    pbWritePtr += sizeof(DWORD);

    // Encr salt
    CopyMemory(pbWritePtr, pbEncrSalt, cbEncrSalt);
    pbWritePtr += cbEncrSalt;

    // dwMACAlgID
    *(DWORD UNALIGNED *)pbWritePtr = dwAlgID_MAC_Alg;
    pbWritePtr += sizeof(DWORD);

    // dwMACAlgKeySize
    *(DWORD UNALIGNED *)pbWritePtr = dwAlgID_MAC_Alg_KeySize;
    pbWritePtr += sizeof(DWORD);

    // cb MAC key
    *(DWORD UNALIGNED *)pbWritePtr = sizeof(rgbMACKey);
    pbWritePtr += sizeof(DWORD);

    // MAC key
    CopyMemory(pbWritePtr, rgbMACKey, sizeof(rgbMACKey));
    pbWritePtr += sizeof(rgbMACKey);

    // USER GATING: only consider if prompt structure specified
    if ( psPrompt )
    {
        if (psPrompt->cbSize != sizeof(SSCRYPTPROTECTDATA_PROMPTSTRUCT))
        {
            dwRet = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        if ((psPrompt->dwPromptFlags & ~(CRYPTPROTECT_PROMPT_ON_PROTECT |
                                         CRYPTPROTECT_PROMPT_ON_UNPROTECT | 
                                         CRYPTPROTECT_PROMPT_STRONG |
                                         CRYPTPROTECT_PROMPT_REQUIRE_STRONG)) != 0)
        {
            dwRet = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        if ((psPrompt->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG) &&
            (pbOptionalPassword == NULL || cbOptionalPassword == 0)
            )
        {
            dwRet = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        // UI: only if requested by PROMPT_ON_PROTECT
        if ( psPrompt->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_PROTECT )
        {
            if ( dwFlags & CRYPTPROTECT_UI_FORBIDDEN )
            {
                dwRet = ERROR_PASSWORD_RESTRICTION;
                goto Ret;
            }

// UI handled outside service until SAS support added.



            dwProtectionFlags |= CRYPTPROTECT_PROMPT_ON_PROTECT;
        }

        if ( psPrompt->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_UNPROTECT )
            dwProtectionFlags |= CRYPTPROTECT_PROMPT_ON_UNPROTECT;

        if ( psPrompt->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG )
            dwProtectionFlags |= CRYPTPROTECT_PROMPT_STRONG;

        if ( psPrompt->dwPromptFlags & CRYPTPROTECT_PROMPT_REQUIRE_STRONG )
            dwProtectionFlags |= CRYPTPROTECT_PROMPT_REQUIRE_STRONG;
    }

    // update stored protection flags in the stream
    *(DWORD UNALIGNED *)pStreamFlagPtr = dwProtectionFlags;

    // dansimon recommends that MAC be on encrypted data, such that the
    // MAC has no possibility of revealing info about the plaintext.

    cbEncrypted = cbIn;

    // then Encrypt pbIn
    if (!CryptEncrypt(
            hKey,
            NULL,
            TRUE,
            0,
            pbCrypt,
            &cbEncrypted,
            cbCrypt))
    {
        dwRet = GetLastError();
        goto Ret;
    }
    // now cbCrypt is size of encrypted data
    cbCrypt = cbEncrypted;

    // Encrdata: len
    *(DWORD UNALIGNED *)pbWritePtr = cbCrypt;
    pbWritePtr += sizeof(DWORD);

    // Encrdata: val
    CopyMemory(pbWritePtr, pbCrypt, cbCrypt);
    pbWritePtr += cbCrypt;

    {

        // dansimon recommends that MAC be on encrypted data, such that the
        // MAC has no possibility of revealing info about the plaintext.

        // MAC from start to here
        if (!CryptHashData(
                hHash,
                *ppbOut,
                (DWORD)(pbWritePtr - *ppbOut),
                0))
        {
            dwRet = GetLastError();
            goto Ret;
        }

        // cbMAC
        pbWritePtr += sizeof(DWORD);    // skip cb write; retreive hash val first

        // MAC
        if (!CryptGetHashParam(
            hHash,
            HP_HASHVAL,
            pbWritePtr,
            &cbMACSize,
            0))
        {
            dwRet = GetLastError();
            goto Ret;
        }
        // rewrite cbMAC before MAC
        *(DWORD UNALIGNED *)(pbWritePtr - sizeof(DWORD)) = cbMACSize;
        // make sure we didn't overstep
        SS_ASSERT(cbMACSize <= A_SHA_DIGEST_LEN);
        pbWritePtr += cbMACSize;
    }


    // assert allocation size was sufficient
    SS_ASSERT(*ppbOut + *pcbOut >= pbWritePtr);

    // reset output size
    *pcbOut = (DWORD)(pbWritePtr - *ppbOut);

    dwRet = ERROR_SUCCESS;
Ret:


    if((dwProtectionFlags & CRYPTPROTECT_AUDIT) ||
        (ERROR_SUCCESS != dwRet))
    {

        WCHAR wszCryptoAlgs[2*MAX_STRING_ALGID_LENGTH + 2];
        DWORD i;

        i = AlgIDToString(wszCryptoAlgs, dwAlgID_Encr_Alg, dwAlgID_Encr_Alg_KeySize);
        wszCryptoAlgs[i++]= L',';
        wszCryptoAlgs[i++]= L' ';
        AlgIDToString(&wszCryptoAlgs[i], dwAlgID_MAC_Alg, dwAlgID_MAC_Alg_KeySize);

        CPSAudit(pServerContext->hToken,
                SE_AUDITID_DPAPI_PROTECT,
                wszMKGuidString,            // Key Identifier
                szDataDescr,                // Data Description
                dwProtectionFlags,          // Protected Data Flags
                wszCryptoAlgs,              // Protection Algorithms
                dwRet);                     // Failure Reason


    }


    ZeroMemory(rgbPwdBuf, sizeof(rgbPwdBuf));
    ZeroMemory(rgbEncrKey, sizeof(rgbEncrKey));

    if(pbMasterKey) {
        ZeroMemory(pbMasterKey, cbMasterKey);
        SSFree(pbMasterKey);
    }

    if (hKey)
        CryptDestroyKey(hKey);

    if (hHash)
        CryptDestroyHash(hHash);

    if (pbCrypt)
        SSFree(pbCrypt);

    if (pbEncrSalt)
        SSFree(pbEncrSalt);

    D_DebugLog((DEB_TRACE_API, "SPCryptProtect returned 0x%x\n", dwRet));

    return dwRet;
}



DWORD
WINAPI
SPCryptUnprotect(
        PVOID       pvContext,                          // server context
        PBYTE*      ppbOut,                             // out ptxt data
        DWORD*      pcbOut,                             // out ptxt cb
        PBYTE       pbIn,                               // in encr data
        DWORD       cbIn,                               // in encr cb
        LPWSTR*     ppszDataDescr,                      // OPTIONAL
        PBYTE       pbOptionalEntropy,                  // OPTIONAL
        DWORD       cbOptionalEntropy,
        PSSCRYPTPROTECTDATA_PROMPTSTRUCT  psPrompt,   // OPTIONAL, prompting struct
        DWORD       dwFlags,
        BYTE*       pbOptionalPassword,
        DWORD       cbOptionalPassword
        )
{
    DWORD       dwRet;
    PBYTE       pbReadPtr = pbIn;
    LPWSTR      szUser = NULL;
    GUID        guidMK;
    WCHAR       wszMKGuidString[MAX_GUID_SZ_CHARS];

    HCRYPTPROV  hVerifyProv;
    HCRYPTKEY   hKey = NULL;
    HCRYPTHASH  hHash = NULL;

    BYTE        rgbEncrKey[KEY_DERIVATION_BUFSIZE];
    BYTE        rgbMACKey[KEY_DERIVATION_BUFSIZE];

    DWORD       cbEncr;

    PBYTE       pbEncrSalt = NULL;
    DWORD       cbEncrSalt = 0;

    DWORD       dwEncrAlgID, dwEncrAlgKeySize, dwMACAlgID, dwMACAlgKeySize;
    DWORD       cbEncrKeysize, cbMACKeysize;
    DWORD       dwProtectionFlags = 0;

    BYTE        rgbPwdBuf[A_SHA_DIGEST_LEN];

    DWORD       cbDataDescr;
    LPWSTR      szDataDescr = NULL;

    LPBYTE pbMasterKey = NULL;
    DWORD cbMasterKey = 0;

#if DBG
    D_DebugLog((DEB_TRACE_API,"SPCryptUnprotect 0x%x called\n", pvContext));

    if(pvContext)
    {
        PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;
        if(pServerContext->cbSize == sizeof(CRYPT_SERVER_CONTEXT))
        {
            D_DebugLog((DEB_TRACE_API, "  pServerContext->hBinding:%d\n", pServerContext->hBinding));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->fOverrideToLocalSystem:%d\n", pServerContext->fOverrideToLocalSystem));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->fImpersonating:%d\n", pServerContext->fImpersonating));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->hToken:%d\n", pServerContext->hToken));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->szUserStorageArea:%ls\n", pServerContext->szUserStorageArea));
        }
    }
    D_DebugLog((DEB_TRACE_API, "  pbOptionalEntropy:0x%x\n", pbOptionalEntropy));
    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "    ", pbOptionalEntropy, cbOptionalEntropy);
    D_DebugLog((DEB_TRACE_API, "  dwFlags:0x%x\n", dwFlags));
    D_DebugLog((DEB_TRACE_API, "  pbOptionalPassword:0x%x\n", pbOptionalPassword));
    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "    ", pbOptionalPassword, cbOptionalPassword);
#endif


    ZeroMemory(&guidMK, sizeof(guidMK));

    ZeroMemory(rgbPwdBuf, sizeof(rgbPwdBuf));


    DWORD   dwDefaultCryptProvType = 0;
    DWORD   dwAlgID_Encr_Alg = 0;
    DWORD   dwAlgID_Encr_Alg_KeySize = 0; 
    DWORD   dwAlgID_MAC_Alg = 0;
    DWORD   dwAlgID_MAC_Alg_KeySize = 0;


    wszMKGuidString[0] = 0;


    GetDefaultAlgInfo(&dwDefaultCryptProvType,
                      &dwAlgID_Encr_Alg,
                      &dwAlgID_Encr_Alg_KeySize,
                      &dwAlgID_MAC_Alg,
                      &dwAlgID_MAC_Alg_KeySize);

    ////////////////////////////////////////////////////////////////////
    // FYI: Data format
    // (    Version | guidMKid | dwFlags |
    //      cbDataDescr | szDataDescr |
    //
    //      dwEncrAlgID | dwEncrAlgKeySize |
    //      cbEncrKey | EncrKey |
    //      cbEncrSalt | EncrSalt |
    //
    //      dwMACAlgID | dwMACAlgKeySize |
    //      cbMACKey | MACKey |
    //
    //      cbEncrData | EncrData |
    //      cbMAC | MAC )
    //
    // NOTE: entire buffer from ProvHeader through EncrData is included in MAC
    ////////////////////////////////////////////////////////////////////

    // Check for minimum input buffer size.
    if(cbIn < sizeof(DWORD) +           // Version
              sizeof(GUID) +            // guidMKid
              sizeof(DWORD) +           // dwFlags
              sizeof(DWORD))            // cbDataDescr
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // version check
    if (*(DWORD UNALIGNED *)pbReadPtr != MS_BASE_CRYPTPROTECT_VERSION)
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);

    // guidMKid
    CopyMemory(&guidMK, pbReadPtr, sizeof(GUID));
    pbReadPtr += sizeof(GUID);
    cbIn -= sizeof(GUID);

    MyGuidToStringW(&guidMK, wszMKGuidString);
    D_DebugLog((DEB_TRACE, "Master key GUID:%ls\n", wszMKGuidString));


    // dwFlags during protection
    dwProtectionFlags = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);
    D_DebugLog((DEB_TRACE, "Protection flags:0x%x\n", dwProtectionFlags));

    //
    // evaluate original CryptProtectData dwFlags to determine if
    // CRYPT_LOCAL_MACHINE set.
    //

    if( dwProtectionFlags & CRYPTPROTECT_LOCAL_MACHINE ) {
        BOOL fOverrideToLocalSystem = TRUE;

        CPSOverrideToLocalSystem(
                pvContext,
                &fOverrideToLocalSystem,
                NULL    // don't care what previous value was
                );
    }

    if((dwProtectionFlags ^ dwFlags) & CRYPTPROTECT_SYSTEM)
    {
        //
        // Attempted to use decrypt system data as a user, or user data
        // with the system flag
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }


    // cbDataDescr
    cbDataDescr = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);

    // Check for minimum input buffer size.
    if(cbIn < cbDataDescr +             // szDataDescr
              sizeof(DWORD) +           // dwEncrAlgID
              sizeof(DWORD) +           // dwEncrAlgKeySize
              sizeof(DWORD))            // cbEncrKey
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // szDataDescr
    szDataDescr = (LPWSTR)pbReadPtr;
    pbReadPtr += cbDataDescr;
    cbIn -= cbDataDescr;
    D_DebugLog((DEB_TRACE, "Description:%ls\n", szDataDescr));

    // dwEncrAlgID
    dwEncrAlgID = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);

    // dwEncrAlgKeySize
    dwEncrAlgKeySize = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);
    D_DebugLog((DEB_TRACE, "Encrypt alg:0x%x, Size:%d bits\n", dwEncrAlgID, dwEncrAlgKeySize));

    // cb Encr key
    cbEncrKeysize = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);
    if (cbEncrKeysize > sizeof(rgbEncrKey))
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // Check for minimum input buffer size.
    if(cbIn < cbEncrKeysize +           // EncrKey
              sizeof(DWORD))            // cbEncrSalt
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // Encr key
    CopyMemory(rgbEncrKey, pbReadPtr, cbEncrKeysize);
    pbReadPtr += cbEncrKeysize;
    cbIn -= cbEncrKeysize;

    // cb Encr salt
    cbEncrSalt = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);

    // Check for minimum input buffer size.
    if(cbIn < cbEncrSalt +              // EncrSalt
              sizeof(DWORD) +           // dwMACAlgID
              sizeof(DWORD) +           // dwMACAlgKeySize
              sizeof(DWORD))            // cbMACKey
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // Encr salt
    pbEncrSalt = (PBYTE)SSAlloc(cbEncrSalt);
    if( pbEncrSalt == NULL ) {
        dwRet = ERROR_OUTOFMEMORY;
        goto Ret;
    }
    CopyMemory(pbEncrSalt, pbReadPtr, cbEncrSalt);
    pbReadPtr += cbEncrSalt;
    cbIn -= cbEncrSalt;

    // dwMACAlgID
    dwMACAlgID = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);

    // dwMACAlgKeySize
    dwMACAlgKeySize = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);

    D_DebugLog((DEB_TRACE, "MAC alg:0x%x, Size:%d bits\n", dwMACAlgID, dwMACAlgKeySize));

    // MAC key size
    cbMACKeysize = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);
    if (cbMACKeysize > sizeof(rgbMACKey))
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // Check for minimum input buffer size.
    if(cbIn < cbMACKeysize)            // cbMACKey
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // MAC key
    CopyMemory(rgbMACKey, pbReadPtr, cbMACKeysize);
    pbReadPtr += cbMACKeysize;
    cbIn -= cbMACKeysize;

    if (NULL == (hVerifyProv =
        GetCryptProviderHandle(
            dwDefaultCryptProvType,
            dwEncrAlgID, &dwEncrAlgKeySize,
            dwMACAlgID, &dwMACAlgKeySize)) )
    {
        dwRet = (DWORD)GetLastError();
        goto Ret;
    }

    // USER GATING: when PROMPT_ON_UNPROTECT specified during CryptProtectData
    if ( CRYPTPROTECT_PROMPT_ON_UNPROTECT & dwProtectionFlags )
    {
        if (dwFlags & CRYPTPROTECT_UI_FORBIDDEN)
        {
            dwRet = ERROR_PASSWORD_RESTRICTION;
            goto Ret;
        }

        if (psPrompt == NULL)
        {
            dwRet = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        if (psPrompt->cbSize != sizeof(SSCRYPTPROTECTDATA_PROMPTSTRUCT))
        {
            dwRet = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        if ((psPrompt->dwPromptFlags & ~(CRYPTPROTECT_PROMPT_ON_PROTECT |
                                         CRYPTPROTECT_PROMPT_ON_UNPROTECT | 
                                         CRYPTPROTECT_PROMPT_STRONG |
                                         CRYPTPROTECT_PROMPT_REQUIRE_STRONG)) != 0)
        {
            dwRet = ERROR_INVALID_PARAMETER;
            goto Ret;
        }


// UI handled outside service until SAS support added.


    }


    dwRet = GetSpecifiedMasterKey(
                    pvContext,
                    &guidMK,
                    &pbMasterKey,
                    &cbMasterKey,
                    TRUE    // we do know what master key we want to use
                    );

    if(dwRet != ERROR_SUCCESS)
    {
        DebugLog((DEB_ERROR, "Unable to get specified master key:%ls, error 0x%x\n",
            wszMKGuidString, dwRet));
        goto Ret;
    }

    //
    // hash pbMasterKey to get rgbPwdBuf
    //

    FMyPrimitiveSHA( pbMasterKey, cbMasterKey, rgbPwdBuf);


    // derive encr key
    {
        if (!FMyPrimitiveCryptHMAC(
                    rgbPwdBuf,
                    sizeof(rgbPwdBuf),
                    rgbEncrKey,
                    cbEncrKeysize,
                    hVerifyProv,
                    ALGID_DERIVEKEY_HASH,
                    &hHash))
        {
            dwRet = GetLastError();
            goto Ret;
        }

        // add password if exists
        if (NULL != pbOptionalEntropy)
        {
            if (!CryptHashData(
                    hHash,
                    pbOptionalEntropy,
                    cbOptionalEntropy,
                    0))
            {
                dwRet = GetLastError();
                goto Ret;
            }
        }

        // add prompted UI based password if exists.
        // will eventually come from SAS
        //

        if ( NULL != pbOptionalPassword && cbOptionalPassword )
        {
            if (!CryptHashData(
                    hHash,
                    pbOptionalPassword,
                    cbOptionalPassword,
                    0))
            {
                dwRet = GetLastError();
                goto Ret;
            }
        }

        if (!CryptDeriveKey(
                hVerifyProv,
                dwEncrAlgID,
                hHash,
                ((dwEncrAlgKeySize << 16) | CRYPT_CREATE_SALT),
                &hKey))
        {
            dwRet = GetLastError();
            goto Ret;
        }

        CryptDestroyHash(hHash);
        hHash = 0;

        // USEC -- (US Export Controls)
        if (ERROR_SUCCESS != (dwRet =
            SetSaltForExportControl(
                hKey,
                pbEncrSalt,
                cbEncrSalt)) )
            goto Ret;
    }

    // derive MAC key
    {
        if (!FMyPrimitiveCryptHMAC(
                    rgbPwdBuf,
                    sizeof(rgbPwdBuf),
                    rgbMACKey,
                    cbMACKeysize,
                    hVerifyProv,
                    dwMACAlgID,
                    &hHash))
        {
            dwRet = GetLastError();
            goto Ret;
        }

        // add password if exists
        if (NULL != pbOptionalEntropy)
        {
            if (!CryptHashData(
                    hHash,
                    pbOptionalEntropy,
                    cbOptionalEntropy,
                    0))
            {
                dwRet = GetLastError();
                goto Ret;
            }
        }

        // add prompted UI based password if exists.
        // will eventually come from SAS
        //

        if ( NULL != pbOptionalPassword && cbOptionalPassword )
        {
            if (!CryptHashData(
                    hHash,
                    pbOptionalPassword,
                    cbOptionalPassword,
                    0))
            {
                dwRet = GetLastError();
                goto Ret;
            }

        }

        // USEC -- (US Export Controls)
        // does not apply -- use strong key
    }

    // Check for minimum input buffer size.
    if(cbIn < sizeof(DWORD))            // cbEncrData
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // get encr size
    cbEncr = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);

    // Check for minimum input buffer size.
    if(cbIn < cbEncr +                  // EncrData
              sizeof(DWORD) +           // cbMAC
              A_SHA_DIGEST_LEN)         // MAC
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // dansimon recommends that MAC be on encrypted data, such that the
    // MAC has no possibility of revealing info about the plaintext.

    // MAC is from start thru encrypted data
    if (!CryptHashData(
            hHash,
            pbIn,
            (DWORD) ((pbReadPtr - pbIn) + cbEncr),
            0))
    {
        dwRet = GetLastError();
        goto Ret;
    }


    *pcbOut = cbEncr;

    if ((dwProtectionFlags & CRYPTPROTECT_NO_ENCRYPTION) == 0)
    {
        if (!CryptDecrypt(
                hKey,
                NULL,   // hHash mattt 9/12/97
                TRUE,
                0,
                pbReadPtr,
                pcbOut))
        {
            dwRet = GetLastError();
            if(NTE_BAD_DATA == dwRet)
			{
                dwRet = ERROR_INVALID_DATA;
			}
            goto Ret;
        }
    }

    {
        BYTE        rgbComputedMAC[A_SHA_DIGEST_LEN];
        // use MACPtr to skip past decr data,
        PBYTE       pbMACPtr = pbReadPtr + cbEncr;
        DWORD       cbMACsize = A_SHA_DIGEST_LEN;

        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                rgbComputedMAC,
                &cbMACsize,
                0))
        {
            dwRet = GetLastError();
            goto Ret;
        }

        // chk MAC size
        if (*(DWORD UNALIGNED *)pbMACPtr != cbMACsize)
        {
            dwRet = ERROR_INVALID_DATA;
            goto Ret;
        }
        pbMACPtr += sizeof(DWORD);

        // chk MAC
        if (0 != memcmp(pbMACPtr, rgbComputedMAC, cbMACsize) )
        {
            dwRet = ERROR_INVALID_DATA;
            goto Ret;
        }
    }


    //
    // Write data out, encrypted so that rpc doesn't leave copies
    // laying around in plaintext.
    //

    if((dwFlags & CRYPTPROTECT_IN_PROCESS) == 0)
    {
        DWORD cbPadding;
        NTSTATUS Status;

        cbPadding = RTL_ENCRYPT_MEMORY_SIZE - (*pcbOut) % RTL_ENCRYPT_MEMORY_SIZE;
        if(cbPadding == 0)
        {
            cbPadding += RTL_ENCRYPT_MEMORY_SIZE;
        }

        *ppbOut = (PBYTE)SSAlloc(*pcbOut + cbPadding);
        if(*ppbOut == NULL)
        {
            dwRet = ERROR_OUTOFMEMORY;
            goto Ret;
        }
        CopyMemory(*ppbOut, pbReadPtr, *pcbOut);
        FillMemory((*ppbOut) + (*pcbOut), cbPadding, (BYTE)cbPadding);
        *pcbOut += cbPadding;

        dwRet = RpcImpersonateClient(((PCRYPT_SERVER_CONTEXT)pvContext)->hBinding);
        if( dwRet != ERROR_SUCCESS )
        {
            SSFree(*ppbOut);
            goto Ret;
        }

        Status = RtlEncryptMemory(*ppbOut,
                                  *pcbOut,
                                  RTL_ENCRYPT_OPTION_SAME_LOGON);

        RevertToSelf();

        if(!NT_SUCCESS(Status))
        {
            SSFree(*ppbOut);
            dwRet = RtlNtStatusToDosError(Status);
            goto Ret;
        }
    }
    else
    {
        // We're in-process, so don't bother encrypting output buffer.
        *ppbOut = (PBYTE)SSAlloc(*pcbOut);
        if(*ppbOut == NULL)
        {
            dwRet = ERROR_OUTOFMEMORY;
            goto Ret;
        }
        CopyMemory(*ppbOut, pbReadPtr, *pcbOut);
    }

    // optional: caller may want data descr
    if (ppszDataDescr)
    {
        *ppszDataDescr = (LPWSTR)SSAlloc(cbDataDescr);
        if(*ppszDataDescr == NULL)
        {
            dwRet = ERROR_OUTOFMEMORY;
            goto Ret;
        }
        CopyMemory(*ppszDataDescr, szDataDescr, cbDataDescr);
    }

    dwRet = ERROR_SUCCESS;

    if(dwFlags &  CRYPTPROTECT_VERIFY_PROTECTION )
    {
        HCRYPTPROV hTestProv =  GetCryptProviderHandle( dwDefaultCryptProvType,
                                dwAlgID_Encr_Alg, &dwAlgID_Encr_Alg_KeySize,
                                dwAlgID_MAC_Alg, &dwAlgID_MAC_Alg_KeySize);

        if(hTestProv)
        {

            // Verify encryption strengths
            // Never downgrade encryption strength, just check if we need
            // to upgrade
            if((dwAlgID_Encr_Alg_KeySize > dwEncrAlgKeySize) ||
               (dwAlgID_MAC_Alg_KeySize > dwMACAlgKeySize))
            {
                dwRet = CRYPT_I_NEW_PROTECTION_REQUIRED;
            }
        }
    }
    

Ret:
    if((dwProtectionFlags & CRYPTPROTECT_AUDIT) ||
        (ERROR_SUCCESS != dwRet))
    {

        DWORD dwAuditRet = dwRet;
        WCHAR wszCryptoAlgs[2*MAX_STRING_ALGID_LENGTH + 2];
        DWORD i;
        PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;


        i = AlgIDToString(wszCryptoAlgs, dwEncrAlgID, dwEncrAlgKeySize);
        wszCryptoAlgs[i++]= L',';
        wszCryptoAlgs[i++]= L' ';
        AlgIDToString(&wszCryptoAlgs[i], dwMACAlgID, dwMACAlgKeySize);

        if(CRYPT_I_NEW_PROTECTION_REQUIRED == dwAuditRet)
        {
            dwAuditRet = ERROR_SUCCESS;
        }

        CPSAudit(pServerContext->hToken,
                SE_AUDITID_DPAPI_UNPROTECT,
                wszMKGuidString,            // Key Identifier
                szDataDescr,                // Data Description
                0,                          // Protected Data Flags
                wszCryptoAlgs,              // Protection Algorithms
                dwAuditRet);                // Failure Reason


    }

    ZeroMemory(rgbPwdBuf, sizeof(rgbPwdBuf));
    ZeroMemory(rgbEncrKey, sizeof(rgbEncrKey));

    if(pbMasterKey) {
        ZeroMemory(pbMasterKey, cbMasterKey);
        SSFree(pbMasterKey);
    }

    if (hKey)
        CryptDestroyKey(hKey);

    if (hHash)
        CryptDestroyHash(hHash);

#if 0
    if (szDataDescr)
        SSFree(szDataDescr);
#endif

    if (pbEncrSalt)
        SSFree(pbEncrSalt);

    D_DebugLog((DEB_TRACE_API, "SPCryptUnprotect returned 0x%x\n", dwRet));

    return dwRet;
}





int
WINAPI
ServiceMessageBox(
    IN      PVOID pvContext,
    IN      HWND hWnd,
    IN      LPCWSTR lpText,
    IN      LPCWSTR lpCaption,
    IN      UINT uType
    )
/*++

    This routine supports displaying a MessageBox() on the correct
    Terminal Server console (Hydra).

--*/
{
    int iRet;

    //
    // impersonate the user associated with the context.
    //

    if( ERROR_SUCCESS != CPSImpersonateClient( pvContext ) )
        return -1;

    iRet = MessageBoxW(
                        hWnd,
                        lpText,
                        lpCaption,
                        uType
                        );

    CPSRevertToSelf( pvContext );

    return iRet;
}


/////////////////////////////////////////////
// initializing global defaults
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\keycache.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    keycache.h

Abstract:

    This module contains routines for accessing cached masterkeys.

Author:

    Scott Field (sfield)    07-Nov-98

Revision History:

--*/

#ifndef __KEYCACHE_H__
#define __KEYCACHE_H__


BOOL
InitializeKeyCache(
    VOID
    );

VOID
DeleteKeyCache(
    VOID
    );

BOOL
SearchMasterKeyCache(
    IN      PLUID pLogonId,
    IN      GUID *pguidMasterKey,
    IN  OUT PBYTE *ppbMasterKey,
        OUT PDWORD pcbMasterKey
    );

BOOL
InsertMasterKeyCache(
    IN      PLUID pLogonId,
    IN      GUID *pguidMasterKey,
    IN      PBYTE pbMasterKey,
    IN      DWORD cbMasterKey
    );

BOOL
PurgeMasterKeyCache(
    VOID
    );

#endif  // __KEYCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\keybckup.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    keybckup.h

Abstract:

    This module contains routines associated with client side Key Backup
    operations.

Author:

    Scott Field (sfield)    16-Sep-97

--*/

#ifndef __KEYBCKUP_H__
#define __KEYBCKUP_H__

DWORD
LocalBackupRestoreData(
    IN      HANDLE              hToken,
    IN      PMASTERKEY_STORED   phMasterKey,
    IN      DWORD               dwReason,
    IN      PBYTE               pbDataIn,
    IN      DWORD               cbDataIn,
        OUT PBYTE               *ppbDataOut,
        OUT DWORD               *pcbDataOut,
    IN      const GUID          *pguidAction
    );

DWORD
BackupRestoreData(
    IN      HANDLE              hToken,
    IN      PMASTERKEY_STORED   phMasterKey,
    IN      DWORD               dwReason,
    IN      PBYTE               pbDataIn,
    IN      DWORD               cbDataIn,
        OUT PBYTE               *ppbDataOut,
        OUT DWORD               *pcbDataOut,
    IN      BOOL                fBackup
    );

DWORD
AttemptLocalBackup(
    IN      BOOL                fRetrieve,
    IN      HANDLE              hToken,
    IN      PMASTERKEY_STORED   phMasterKey,
    IN      DWORD               dwReason,
    PBYTE                       pbMasterKey,
    DWORD                       cbMasterKey,
    PBYTE                       pbLocalKey,
    DWORD                       cbLocalKey,
    PBYTE                       *ppbBBK,
    DWORD                       *pcbBBK
    );

#endif  // __KEYBCKUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\keybckup.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    keybckup.cpp

Abstract:

    This module contains routines associated with client side Key Backup
    operations.

Author:

    Scott Field (sfield)    16-Sep-97

--*/
#include <pch.cpp>
#pragma hdrstop

extern "C" {
#include <dsgetdc.h>
#include <msaudite.h>
}



typedef struct _WZR_RPC_BINDING_LIST
{
    LPCWSTR pszProtSeq;
    LPCWSTR pszEndpoint;
} WZR_RPC_BINDING_LIST;

WZR_RPC_BINDING_LIST g_awzrBackupBindingList[] =
{
    { DPAPI_LOCAL_PROT_SEQ, DPAPI_LOCAL_ENDPOINT },
    { DPAPI_BACKUP_PROT_SEQ, DPAPI_BACKUP_ENDPOINT},
    { DPAPI_LEGACY_BACKUP_PROT_SEQ,   DPAPI_LEGACY_BACKUP_ENDPOINT}
};

DWORD g_cwzrBackupBindingList = sizeof(g_awzrBackupBindingList)/sizeof(g_awzrBackupBindingList[0]);





DWORD
WINAPI
CPSGetDomainControllerName(
    IN  OUT LPWSTR wszDomainControllerName,
    IN  OUT DWORD *pcchDomainControllerName,
    IN      BOOL   fRediscover
    );

BOOL
GetDomainControllerNameByToken(
    IN      HANDLE hToken,
    IN  OUT LPWSTR wszDomainControllerName,
    IN  OUT PDWORD pcchDomainControllerName,
    IN      BOOL   fRediscover
    );



static const GUID guidRetrieve = BACKUPKEY_RETRIEVE_BACKUP_KEY_GUID;
static const GUID guidRestore = BACKUPKEY_RESTORE_GUID;
static const GUID guidRestoreW2K = BACKUPKEY_RESTORE_GUID_W2K;
static const GUID guidBackup = BACKUPKEY_BACKUP_GUID;

DWORD
BackupRestoreData(
    IN      HANDLE              hToken,
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD               dwReason,
    IN      PBYTE pbDataIn,
    IN      DWORD cbDataIn,
        OUT PBYTE *ppbDataOut,
        OUT DWORD *pcbDataOut,
    IN      BOOL  fBackup
    )
{


    return LocalBackupRestoreData(hToken,
                                  phMasterKey,
                                  dwReason,
                                  pbDataIn,
                                  cbDataIn,
                                  ppbDataOut, 
                                  pcbDataOut,
                                  fBackup?&guidBackup:&guidRestore);




}

DWORD
LocalBackupRestoreData(
    IN      HANDLE              hToken,
    IN      PMASTERKEY_STORED   phMasterKey,
    IN      DWORD               dwReason,
    IN      PBYTE               pbDataIn,
    IN      DWORD               cbDataIn,
        OUT PBYTE               *ppbDataOut,
        OUT DWORD               *pcbDataOut,
    IN      const GUID          *pguidAction
    )
/*++

    The caller of this function MUST be impersonating a client user.

--*/
{
    WCHAR FastBuffer[ 256 ];
    LPWSTR SlowBuffer = NULL;
    LPWSTR pszAuditComputerName = NULL;
    LPWSTR wszComputerName;
    DWORD cchComputerName;


    static DWORD dwLastFailTickCount; // time for failure on last access
    static LUID luidLastFailAuthId; // LUID associated with failed network

    DWORD dwCandidateTickCount;
    LUID luidCandidateAuthId; // LUID associated with client security context.

    BOOL fRediscoverDC = FALSE;
    DWORD dwLastError = ERROR_NETWORK_BUSY;
    
    BOOL  fRetrieve = FALSE;

    D_DebugLog((DEB_TRACE_API, "LocalBackupRestoreData\n"));

    if(!FIsWinNT())
        return ERROR_CALL_NOT_IMPLEMENTED;

    fRetrieve = (memcmp(pguidAction, &guidRetrieve, sizeof(GUID)) == 0);



    //
    // impersonate the user, so we may
    // 1. check the authentication ID to see if we've failed to hit the
    //    net as this user.
    // 2. determine a domain controller computer name associated with
    //    the user.
    // 3. backup or restore the requested material on behalf of the user.
    //

    if(!GetThreadAuthenticationId( GetCurrentThread(), &luidCandidateAuthId ))
        return GetLastError();

    //
    // now, see if the network was previously unavailable (recently)
    // for this user.
    //

    dwCandidateTickCount = GetTickCount();

    if(memcmp(&luidCandidateAuthId, &luidLastFailAuthId, sizeof(LUID)) == 0) {
        if( (dwLastFailTickCount + (5*1000*60)) > dwCandidateTickCount ) {
            //BUGBUG: return ERROR_NETWORK_BUSY;
        }
    }

    //
    // we got far enough along that we update the failed network cache
    // if something goes wrong from here.
    //

network_call:

    //
    // get domain controller computer name associated with current
    // security context.
    // Try with fast static buffer first, fallback on dynamically allocated
    // buffer if not large enough.
    //

    wszComputerName = FastBuffer;
    cchComputerName = sizeof(FastBuffer) / sizeof( WCHAR );

    dwLastError = CPSGetDomainControllerName(
                        wszComputerName,
                        &cchComputerName,
                        fRediscoverDC
                        );

    if( dwLastError != ERROR_SUCCESS  && (cchComputerName > (sizeof(FastBuffer) / sizeof(WCHAR) ))) {

        SlowBuffer = (LPWSTR) SSAlloc( cchComputerName * sizeof(WCHAR) );
        if( SlowBuffer ) {
            wszComputerName = SlowBuffer;

            dwLastError = CPSGetDomainControllerName(
                                wszComputerName,
                                &cchComputerName,
                                fRediscoverDC
                                );
        }

    }


    if( dwLastError == ERROR_SUCCESS ) {

        LPWSTR wszTargetMachine = wszComputerName;

        pszAuditComputerName = wszComputerName;

        //
        // select action ID.
        //



        //
        // HACKHACK workaround picky RPC/Kerberos name format behavior that
        // would otherwise prevent Kerberos from being used.
        //

        if( wszTargetMachine[ 0 ] == L'\\' && wszTargetMachine[ 1 ] == L'\\' )
            wszTargetMachine += 2;





        dwLastError = BackupKey(
                            wszTargetMachine,   // target computer.
                            pguidAction,
                            pbDataIn,
                            cbDataIn,
                            ppbDataOut,
                            pcbDataOut,
                            0
                            );

    }


    //
    // Audit success or failure
    //
    
    if((memcmp(pguidAction, &guidRestore, sizeof(GUID)) == 0) ||
        (memcmp(pguidAction, &guidRestoreW2K, sizeof(GUID)) == 0))
    {

        // Grab the recovery key id
        WCHAR wszBackupkeyGuid[MAX_GUID_SZ_CHARS];

        PBACKUPKEY_RECOVERY_BLOB pBackupBlob = (PBACKUPKEY_RECOVERY_BLOB)phMasterKey->pbBBK;
        wszBackupkeyGuid[0] = 0;

        if((pBackupBlob) && (phMasterKey->cbBBK > sizeof(BACKUPKEY_RECOVERY_BLOB)))
        {
            MyGuidToStringW(&pBackupBlob->guidKey, wszBackupkeyGuid);
        }


        CPSAudit(hToken,
                SE_AUDITID_DPAPI_RECOVERY,
                phMasterKey->wszguidMasterKey,      // Key Identifier
                pszAuditComputerName,               // Recovery Server
                0,                                  // Recovery Reason
                wszBackupkeyGuid,                   // Recovery Key ID
                dwLastError);                       // Failure Reason
    }
    else if(memcmp(pguidAction, &guidBackup, sizeof(GUID)) == 0)
    {
        // Attempting a remote backup

        // Grab the recovery key id 

        WCHAR wszBackupkeyGuid[MAX_GUID_SZ_CHARS];
        PBACKUPKEY_RECOVERY_BLOB pBackupBlob = (PBACKUPKEY_RECOVERY_BLOB)*ppbDataOut;
        wszBackupkeyGuid[0] = 0;

        if(( dwLastError == ERROR_SUCCESS ) &&
            (pBackupBlob) && 
            (*pcbDataOut > sizeof(BACKUPKEY_RECOVERY_BLOB)))
        {
            MyGuidToStringW(&pBackupBlob->guidKey, wszBackupkeyGuid);
        }

        CPSAudit(hToken,                                           
                SE_AUDITID_DPAPI_BACKUP,
                phMasterKey->wszguidMasterKey,      // Key Identifier
                pszAuditComputerName,               // Recovery Server
                0,
                wszBackupkeyGuid,                   // Recovery Key ID
                dwLastError);                       // Failure Reason
    }


    if( SlowBuffer ) {
        SSFree( SlowBuffer );
        SlowBuffer = NULL;
    }
    //
    // common failure path is ERROR_ACCESS_DENIED for delegation scenarios
    // where target machine isn't trusted for delegation.
    // don't bother retry for this case.
    //

    if( dwLastError != ERROR_SUCCESS && dwLastError != ERROR_ACCESS_DENIED ) {


        //
        // if it failed, try once again and force DC re-discovery.
        //

        if( !fRediscoverDC ) {
            fRediscoverDC = TRUE;
            goto network_call;
        }

        //
        // one of the network operations failed, so update the
        // last failure variables so that we don't bang the network
        // over-and-over.
        //

        dwLastFailTickCount = dwCandidateTickCount;
        CopyMemory( &luidLastFailAuthId, &luidCandidateAuthId, sizeof(LUID));
    }

    D_DebugLog((DEB_TRACE_API, "LocalBackupRestoreData returned 0x%x\n", dwLastError));

    return dwLastError;
}




BOOL
GetDomainControllerNameByToken(
    IN      HANDLE hToken,
    IN  OUT LPWSTR wszDomainControllerName,
    IN  OUT PDWORD pcchDomainControllerName,
    IN      BOOL   fRediscover
    )
/*++

    This routine obtains a domain controller computer name associated with
    the account related to the hToken access token.

    hToken should be opened for TOKEN_QUERY access.
    wszDomainControllerName should be of size (UNCLEN+1)

--*/
{
    PSID pSidUser = NULL;   // sid of client user.
    WCHAR szUserName[ UNLEN + 1 ];
    DWORD cchUserName = sizeof(szUserName) / sizeof(WCHAR);

    WCHAR szDomainName[ DNLEN + 1]; // domain we want a controller for.
    DWORD cchDomainName = sizeof(szDomainName) / sizeof(WCHAR);
    SID_NAME_USE snu;

    PDOMAIN_CONTROLLER_INFOW pDomainInfo = NULL;
    LPWSTR wszQueryResult = NULL;

    NET_API_STATUS nas;
    DWORD dwGetDcFlags = 0;

    BOOL fSuccess = FALSE;

    if(wszDomainControllerName == NULL || pcchDomainControllerName == NULL)
        return FALSE;

    //
    // first, get the sid of the user associated with the specified access
    // token.
    //

    if(!GetTokenUserSid(hToken, &pSidUser))
        return FALSE;

    //
    // next, lookup the domain name associated with the specified account.
    //

    if(!LookupAccountSidW(
            NULL,
            pSidUser,
            szUserName,
            &cchUserName,
            szDomainName,
            &cchDomainName,
            &snu
            )) {

        SSFree(pSidUser);
        return FALSE;
    }


    if( fRediscover )
        dwGetDcFlags |= DS_FORCE_REDISCOVERY;

    nas = DsGetDcNameW(
                NULL,
                szDomainName,
                NULL,
                NULL,
                DS_DIRECTORY_SERVICE_REQUIRED | // make sure backend is NT5
                DS_IS_FLAT_NAME |
                dwGetDcFlags,
                &pDomainInfo
                );

    if( nas == ERROR_SUCCESS )
        wszQueryResult = pDomainInfo->DomainControllerName;

    //
    // if we made a successful query, copy it for the caller and indicate
    // success if appropriate.
    //

    if(wszQueryResult) {
        DWORD cchQueryResult = lstrlenW( wszQueryResult ) + 1;

        if( *pcchDomainControllerName >= cchQueryResult ) {
            CopyMemory(wszDomainControllerName, wszQueryResult, cchQueryResult * sizeof(WCHAR));
            fSuccess = TRUE;
        }

        *pcchDomainControllerName = cchQueryResult;
    }


    if(pDomainInfo)
        NetApiBufferFree(pDomainInfo);

    if(pSidUser)
        SSFree(pSidUser);

    return fSuccess;
}


DWORD
WINAPI
CPSGetDomainControllerName(
    IN  OUT LPWSTR wszDomainControllerName,
    IN  OUT DWORD *pcchDomainControllerName,
    IN      BOOL   fRediscover
    )
/*++

    This routine collects a domain controller computer name associated
    with the current impersonated user (if one is being impersonated), or
    the user associated with the pvContext outstanding client call if the
    thread is not already impersonating a client.

--*/
{
    HANDLE hToken = NULL;
    DWORD dwLastError;

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken)) {
        return GetLastError();
    }

    if(!GetDomainControllerNameByToken(
                        hToken,
                        wszDomainControllerName,
                        pcchDomainControllerName,
                        fRediscover
                        )) {

        dwLastError = ERROR_BAD_NET_RESP;
        goto cleanup;
    }

    dwLastError = ERROR_SUCCESS;

cleanup:

    if(hToken)
        CloseHandle(hToken);

    return dwLastError;
}


#define BACKUP_KEY_PREFIX L"BK-"
#define BACKUP_KEY_PREFIX_LEN 3

#define BACKUP_PUBLIC_VERSION 1

typedef struct _BACKUP_PUBLIC_KEY
{
    DWORD dwVersion;
    DWORD cbPublic;
    DWORD cbSignature;
} BACKUP_PUBLIC_KEY, *PBACKUP_PUBLIC_KEY;

DWORD
RetrieveBackupPublicKeyFromStorage(
        HANDLE hToken, 
        PSID pSidUser,
        LPWSTR wszFilePath,
        OUT PBYTE *ppbDataOut,
        OUT DWORD *pcbDataOut
    )
{
    DWORD dwLastError = ERROR_SUCCESS;
    WCHAR szUserName[ UNLEN + 1 ];
    DWORD cchUserName = sizeof(szUserName) / sizeof(WCHAR);

    WCHAR szDomainName[ BACKUP_KEY_PREFIX_LEN + DNLEN +1]; // domain we want a controller for.
    DWORD cchDomainName = sizeof(szDomainName) / sizeof(WCHAR);

    HANDLE hFile = NULL;
    HANDLE hMap = NULL;
    PBACKUP_PUBLIC_KEY pBackupPublic = NULL;

    DWORD dwFileSizeLow;
    SID_NAME_USE snu;





    wcscpy(szDomainName, BACKUP_KEY_PREFIX);


    //
    // next, lookup the domain name associated with the specified account.
    //

    cchDomainName -= BACKUP_KEY_PREFIX_LEN;

    if(!LookupAccountSidW(
            NULL,
            pSidUser,
            szUserName,
            &cchUserName,
            szDomainName + BACKUP_KEY_PREFIX_LEN,
            &cchDomainName,
            &snu
            )) {

        return GetLastError();
    }


    if(hToken)
    {
        if(!SetThreadToken(NULL, hToken))
        {
            return GetLastError();
        }
    }

    //
    // Attempt to find a public key for the
    // specified domain
    //

    cchDomainName += BACKUP_KEY_PREFIX_LEN;


    //
    // setup the UNICODE_STRINGs for the call.
    //
    dwLastError = OpenFileInStorageArea(
                    NULL,
                    GENERIC_READ,
                    wszFilePath,
                    szDomainName,
                    &hFile
                    );

    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }

    dwFileSizeLow = GetFileSize( hFile, NULL );
    if(dwFileSizeLow == 0xFFFFFFFF)
    {
     
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }


    hMap = CreateFileMappingU(
                    hFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    0,
                    NULL
                    );

    if(NULL == hMap)
    {
        dwLastError = GetLastError();
        goto error;
    }



    pBackupPublic = (PBACKUP_PUBLIC_KEY)MapViewOfFile( hMap, FILE_MAP_READ, 0, 0, 0 );

    if(NULL == pBackupPublic)
    {
        dwLastError = GetLastError();
        goto error;
    }

    if((pBackupPublic->dwVersion != BACKUP_PUBLIC_VERSION) ||
       (dwFileSizeLow < sizeof(BACKUP_PUBLIC_KEY) + pBackupPublic->cbPublic + pBackupPublic->cbSignature))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }

    //
    // Verify the signature
    //
    dwLastError = LogonCredVerifySignature( NULL,
                                            (PBYTE)(pBackupPublic + 1) + pBackupPublic->cbSignature,
                                            pBackupPublic->cbPublic,
                                            NULL,
                                            (PBYTE)(pBackupPublic + 1),
                                            pBackupPublic->cbSignature);
    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }


    *ppbDataOut = (PBYTE)SSAlloc(pBackupPublic->cbPublic);
    if(NULL == ppbDataOut)
    {
        dwLastError = STATUS_OBJECT_NAME_NOT_FOUND;
        goto error;
    }

    CopyMemory(*ppbDataOut, (PBYTE)(pBackupPublic+1), pBackupPublic->cbPublic);
    *pcbDataOut = pBackupPublic->cbPublic;

error:


    if(pBackupPublic)
    {
        UnmapViewOfFile(pBackupPublic);
    }

    if(hMap)
    {
        CloseHandle(hMap);
    }

    if(hFile)
    {
        CloseHandle(hFile);
    }

    if(hToken)
    {
        RevertToSelf();
    }
    return dwLastError;

}

DWORD
WriteBackupPublicKeyToStorage(
        HANDLE hToken, 
        PSID pSidUser,
        LPWSTR wszFilePath,
        PBYTE pbData,
        DWORD cbData
    )
{
    DWORD dwLastError = ERROR_SUCCESS;
    WCHAR szUserName[ UNLEN + 1 ];
    DWORD cchUserName = sizeof(szUserName) / sizeof(WCHAR);

    WCHAR szDomainName[ BACKUP_KEY_PREFIX_LEN + DNLEN +1]; // domain we want a controller for.
    DWORD cchDomainName = sizeof(szDomainName) / sizeof(WCHAR);

    HANDLE hFile = NULL;
    HANDLE hMap = NULL;
    PBACKUP_PUBLIC_KEY pBackupPublic = NULL;

    DWORD dwFileSizeLow;
    SID_NAME_USE snu;
    PBYTE pbSignature = NULL;
    DWORD cbSignature;






    wcscpy(szDomainName, BACKUP_KEY_PREFIX);


    //
    // next, lookup the domain name associated with the specified account.
    //

    cchDomainName -= BACKUP_KEY_PREFIX_LEN;

    if(!LookupAccountSidW(
            NULL,
            pSidUser,
            szUserName,
            &cchUserName,
            szDomainName + BACKUP_KEY_PREFIX_LEN,
            &cchDomainName,
            &snu
            )) {

        return GetLastError();
    }


    if(hToken)
    {
        if(!SetThreadToken(NULL, hToken))
        {
            return GetLastError();
        }
    }
    //
    // Attempt to find a public key for the
    // specified domain
    //

    cchDomainName += BACKUP_KEY_PREFIX_LEN;


    dwLastError = LogonCredGenerateSignature(
                                            hToken,
                                            pbData,
                                            cbData,
                                            NULL,
                                            &pbSignature,
                                            &cbSignature);
    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }


    dwFileSizeLow = sizeof(BACKUP_PUBLIC_KEY) + cbData + cbSignature;


    //
    // setup the UNICODE_STRINGs for the call.
    //
    dwLastError = OpenFileInStorageArea(
                    NULL,
                    GENERIC_READ | GENERIC_WRITE,
                    wszFilePath,
                    szDomainName,
                    &hFile
                    );

    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }


    hMap = CreateFileMappingU(
                    hFile,
                    NULL,
                    PAGE_READWRITE,
                    0,
                    dwFileSizeLow,
                    NULL
                    );

    if(NULL == hMap)
    {
        dwLastError = GetLastError();
        goto error;
    }



    pBackupPublic = (PBACKUP_PUBLIC_KEY)MapViewOfFile( hMap, FILE_MAP_WRITE , 0, 0, dwFileSizeLow );

    if(NULL == pBackupPublic)
    {
        dwLastError = GetLastError();
        goto error;
    }

    pBackupPublic->dwVersion = BACKUP_PUBLIC_VERSION;

    pBackupPublic->cbSignature = cbSignature;

    pBackupPublic->cbPublic = cbData;

    CopyMemory((PBYTE)(pBackupPublic+1), pbSignature, cbSignature);


    CopyMemory((PBYTE)(pBackupPublic+1) + cbSignature, pbData, cbData);






error:


    if(pBackupPublic)
    {
        UnmapViewOfFile(pBackupPublic);
    }

    if(hMap)
    {
        CloseHandle(hMap);
    }

    if(hFile)
    {
        CloseHandle(hFile);
    }
    if(pbSignature)
    {
        SSFree(pbSignature);
    }
    if(hToken)
    {
        RevertToSelf();
    }
    return dwLastError;

}



DWORD
AttemptLocalBackup(
    IN      BOOL                fRetrieve,
    IN      HANDLE              hToken,
    IN      PMASTERKEY_STORED   phMasterKey,
    IN      DWORD               dwReason,
    PBYTE                       pbMasterKey,
    DWORD                       cbMasterKey,
    PBYTE                       pbLocalKey,
    DWORD                       cbLocalKey,
    PBYTE                       *ppbBBK,
    DWORD                       *pcbBBK
    )
{

    DWORD dwLastError = ERROR_SUCCESS;
    PCCERT_CONTEXT  pPublic = NULL;
    PBYTE          pbPublic = NULL;
    DWORD          cbPublic = 0;

    HCRYPTPROV     hProv = NULL;
    HCRYPTKEY      hPublicKey = NULL;

    PBYTE                    pbPayloadKey = NULL;;

    PBACKUPKEY_KEY_BLOB     pKeyBlob = NULL;
    DWORD                   cbKeyBlobData = 0;
    DWORD                   cbKeyBlob = 0;


    PBACKUPKEY_INNER_BLOB   pInnerBlob = NULL;
    DWORD                   cbInnerBlob = 0;
    DWORD                   cbInnerBlobData = 0;
    PBYTE                   pbData = NULL;

    DWORD                   cbTemp = 0;


    PBACKUPKEY_RECOVERY_BLOB pOuterBlob = NULL;
    DWORD                   cbOuterBlob = 0;

    PSID pSidUser = NULL;   // sid of client user.

    DWORD  cbSid = 0;

    WCHAR                   wszBackupKeyID[MAX_GUID_SZ_CHARS];
    BYTE                    rgbThumbprint[A_SHA_DIGEST_LEN];
    DWORD                   cbThumbprint;

    wszBackupKeyID[0] = 0;


    if(!GetTokenUserSid(hToken, &pSidUser)){
        dwLastError = GetLastError();
        goto error;
    }

    if(fRetrieve)
    {

        // Attempt to retrieve the public from 
        // the DC.

        //
        // We impersonate when we do this
        //

        SetThreadToken(NULL, hToken);

        dwLastError = LocalBackupRestoreData(hToken, 
                                             phMasterKey, 
                                             dwReason,
                                             pbMasterKey,
                                             0,
                                             &pbPublic,
                                             &cbPublic,
                                             &guidRetrieve);

        // 
        // Revert back to ourself
        //
        SetThreadToken(NULL, NULL);


    }
    else
    {
        //
        // We're attempting a backup, so first see if we have a local copy of
        // the public.
        //
    
        dwLastError = RetrieveBackupPublicKeyFromStorage(hToken,
                                                         pSidUser,
                                                         phMasterKey->szFilePath,
                                                        &pbPublic,
                                                        &cbPublic);
    }

    if(ERROR_SUCCESS == dwLastError)
    {
        pPublic = CertCreateCertificateContext(X509_ASN_ENCODING,
                                     pbPublic,
                                     cbPublic);
        if(NULL == pPublic)
        {
            dwLastError = GetLastError();
        }
    }


    if(dwLastError != ERROR_SUCCESS)
    {
        goto error;
    }



    if(sizeof(GUID) == pPublic->pCertInfo->SerialNumber.cbData)
    {
        MyGuidToStringW((GUID *)pPublic->pCertInfo->SerialNumber.pbData, wszBackupKeyID);
    }

    



    if(fRetrieve)
    {
        WriteBackupPublicKeyToStorage(hToken,
                                      pSidUser,
                                      phMasterKey->szFilePath,
                                      pbPublic,
                                      cbPublic);
    }

    if(!CryptAcquireContext(&hProv, 
                            NULL, 
                            NULL, 
                            PROV_RSA_FULL, 
                            CRYPT_VERIFYCONTEXT))
    {
        dwLastError = GetLastError();
        goto error;
    }

    if(!CryptImportPublicKeyInfoEx(hProv,
                               pPublic->dwCertEncodingType,
                               &pPublic->pCertInfo->SubjectPublicKeyInfo,
                               CALG_RSA_KEYX,
                               NULL,
                               NULL,
                               &hPublicKey))
    {
        dwLastError = GetLastError();
        goto error;
    }

    cbSid = GetLengthSid(pSidUser);


    cbInnerBlobData = sizeof(BACKUPKEY_INNER_BLOB) + 
                  cbLocalKey +
                  cbSid +
                  A_SHA_DIGEST_LEN;


    //
    // Round up to blocklen
    //
    cbInnerBlob = (cbInnerBlobData + (DES_BLOCKLEN - 1)) & ~(DES_BLOCKLEN-1);

    cbTemp = sizeof(cbKeyBlob);
    if(!CryptGetKeyParam(hPublicKey, 
                         KP_BLOCKLEN, 
                         (PBYTE)&cbKeyBlob, 
                         &cbTemp, 
                         0))
    {
        dwLastError = GetLastError();
        goto error;
    }

    cbKeyBlob >>= 3;  // convert from bits to bytes


    cbOuterBlob = sizeof(BACKUPKEY_RECOVERY_BLOB) +
                  cbKeyBlob +
                  cbInnerBlob;

    pOuterBlob = (PBACKUPKEY_RECOVERY_BLOB)SSAlloc(cbOuterBlob);
    if(NULL == pOuterBlob)
    {
        dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    pKeyBlob = (PBACKUPKEY_KEY_BLOB)(pOuterBlob+1);

    pInnerBlob = (PBACKUPKEY_INNER_BLOB)((PBYTE)pKeyBlob + cbKeyBlob);

    // Initialize the payload key

    cbKeyBlobData = sizeof(BACKUPKEY_KEY_BLOB) + cbMasterKey + DES3_KEYSIZE + DES_BLOCKLEN;
    pKeyBlob->cbMasterKey = cbMasterKey;
    pKeyBlob->cbPayloadKey = DES3_KEYSIZE + DES_BLOCKLEN;
    pbPayloadKey = (PBYTE)(pKeyBlob+1) + cbMasterKey;

    CopyMemory((PBYTE)(pKeyBlob+1), pbMasterKey, cbMasterKey);


    //
    // Generate a payload key
    //
    RtlGenRandom(pbPayloadKey, pKeyBlob->cbPayloadKey);



    // Populate the payload

    pInnerBlob->dwPayloadVersion = BACKUPKEY_PAYLOAD_VERSION;

    pInnerBlob->cbLocalKey = cbLocalKey;


    pbData = (PBYTE)(pInnerBlob+1);

    CopyMemory(pbData, pbLocalKey, cbLocalKey);

    pbData += cbLocalKey;

    CopyMemory(pbData, pSidUser, cbSid);

    pbData += cbSid;

    // Pad
    if(cbInnerBlob > cbInnerBlobData)
    {
        RtlGenRandom(pbData, cbInnerBlob - cbInnerBlobData);
        pbData += cbInnerBlob - cbInnerBlobData;
    }

    // Generate the payload MAC

    FMyPrimitiveSHA( (PBYTE)pInnerBlob, 
                    cbInnerBlob - A_SHA_DIGEST_LEN,
                    pbData);



    //
    // Encrypt with 3DES CBC
    //
    {

        DES3TABLE s3DESKey;
        BYTE InputBlock[DES_BLOCKLEN];
        DWORD iBlock;
        DWORD cBlocks = cbInnerBlob/DES_BLOCKLEN;
        BYTE feedback[ DES_BLOCKLEN ];
        // initialize 3des key
        //

        if(cBlocks*DES_BLOCKLEN != cbInnerBlob)
        {
            // Master key must be a multiple of DES_BLOCKLEN
            dwLastError = NTE_BAD_KEY;
            goto error;

        }
        tripledes3key(&s3DESKey, pbPayloadKey);

        //
        // IV is derived from the DES_BLOCKLEN bytes of the calculated 
        // rgbSymKey, after the 3des key
        CopyMemory(feedback, pbPayloadKey + DES3_KEYSIZE, DES_BLOCKLEN);


        for(iBlock=0; iBlock < cBlocks; iBlock++)
        {
            CopyMemory(InputBlock, 
                       ((PBYTE)pInnerBlob)+iBlock*DES_BLOCKLEN,
                       DES_BLOCKLEN);
            CBC(tripledes,
                DES_BLOCKLEN,
                ((PBYTE)pInnerBlob)+iBlock*DES_BLOCKLEN,
                InputBlock,
                &s3DESKey,
                ENCRYPT,
                feedback);
        }
    }
    
    //
    // Encrypt master key and payload key to 
    // the public key 


    if(!CryptEncrypt(hPublicKey, 
                 NULL, 
                 TRUE, 
                 0, // CRYPT_OAEP 
                 (PBYTE)pKeyBlob, 
                 &cbKeyBlobData, 
                 cbKeyBlob))
    {
        dwLastError = GetLastError();
        goto error;
    }

    if(cbKeyBlobData != cbKeyBlob)
    {
        CopyMemory((PBYTE)pKeyBlob + cbKeyBlobData, 
                   pInnerBlob,
                   cbInnerBlob);
        cbOuterBlob -= cbKeyBlob - cbKeyBlobData;
    }

    pOuterBlob->dwVersion = BACKUPKEY_RECOVERY_BLOB_VERSION;
    pOuterBlob->cbEncryptedMasterKey  = cbKeyBlobData;
    pOuterBlob->cbEncryptedPayload = cbInnerBlob;
    CopyMemory(&pOuterBlob->guidKey,
               pPublic->pCertInfo->SubjectUniqueId.pbData,
               sizeof(GUID));


    *ppbBBK = (PBYTE)pOuterBlob;
    *pcbBBK = cbOuterBlob;

    pOuterBlob = NULL;
error:


    if((fRetrieve) || (ERROR_SUCCESS == dwLastError))
    {
        // Only audit if we're attempting to do the long backup.
        SetThreadToken(NULL, hToken);

        CPSAudit(hToken,
                SE_AUDITID_DPAPI_BACKUP,
                phMasterKey->wszguidMasterKey,      // Key Identifier
                L"",                                // Recovery Server
                dwReason,
                wszBackupKeyID,                     // Recovery Key ID
                dwLastError);                       // Failure Reason
        SetThreadToken(NULL, NULL);
    }

    if(pPublic)
    {
        CertFreeCertificateContext(pPublic);
    }
    if(pbPublic)
    {
        SSFree(pbPublic);
    }
    if(pOuterBlob)
    {
        SSFree(pOuterBlob);
    }

    if(hPublicKey)
    {
        CryptDestroyKey(hPublicKey);
    }
    if(hProv)
    {
        CryptReleaseContext(hProv, 0);
    }

    return dwLastError;
}

DWORD
WINAPI
BackupKey(
    IN      LPCWSTR szComputerName,
    IN      const GUID *pguidActionAgent,
    IN      BYTE *pDataIn,
    IN      DWORD cbDataIn,
    IN  OUT BYTE **ppDataOut,
    IN  OUT DWORD *pcbDataOut,
    IN      DWORD dwParam
    )
{

    RPC_BINDING_HANDLE h = NULL;
    WCHAR *pStringBinding = NULL;
    BOOL  fLocal = FALSE;
    HANDLE hToken = NULL;

    RPC_STATUS RpcStatus = RPC_S_OK;
    DWORD dwRetVal = ERROR_INVALID_PARAMETER;
    DWORD i;

    WCHAR szLocalComputerName[MAX_COMPUTERNAME_LENGTH + 2];
    DWORD BufSize = MAX_COMPUTERNAME_LENGTH + 2;

    if (!(GetComputerNameW(szLocalComputerName, &BufSize)))
    {
        return GetLastError();
    }




    *ppDataOut = NULL;
    *pcbDataOut = 0;

    if (!FIsWinNT5())
        return ERROR_CALL_NOT_IMPLEMENTED;


    //
    // If we're going off machine, check to make sure that delegation is 
    // allowed.
    //
    if(!IsLocal() && (szComputerName) && (0 != wcscmp(szComputerName, szLocalComputerName)))
    {

        LPUSER_INFO_1 pUserInfo = NULL;


        wcscat(szLocalComputerName, L"$");


        if((OpenThreadToken(GetCurrentThread(), 
                            TOKEN_IMPERSONATE, 
                            TRUE, 
                            &hToken)) &&
            SetThreadToken(NULL, NULL))
        {
            if (NERR_Success == NetUserGetInfo(
                                        szComputerName,
                                        szLocalComputerName,
                                        1,
                                        (PBYTE *)&pUserInfo
                                        )) {

                if (!(UF_TRUSTED_FOR_DELEGATION & pUserInfo->usri1_flags))
                {
                    RpcStatus = SEC_E_DELEGATION_REQUIRED;
                }

                NetApiBufferFree(pUserInfo);
            }

            // Impersonate again
            if(!SetThreadToken(NULL, hToken))
            {
                RpcStatus = GetLastError();
            }
        }
        if(RPC_S_OK != RpcStatus)
        {
            goto error;
        }


    }
    else
    {
        fLocal = TRUE;
    }

    //
    // Try all of the bindings
    //
    for (i = fLocal?0:1; i < g_cwzrBackupBindingList; i++)
    {
        RPC_SECURITY_QOS RpcQos;

        if (RPC_S_OK != RpcNetworkIsProtseqValidW(
                                    (unsigned short *)g_awzrBackupBindingList[i].pszProtSeq))
        {
            continue;
        }

        RpcStatus = RpcStringBindingComposeW(
                              NULL,
                              (unsigned short *)g_awzrBackupBindingList[i].pszProtSeq,
                              (unsigned short *)szComputerName,
                              (unsigned short *)g_awzrBackupBindingList[i].pszEndpoint,
                              NULL,
                              &pStringBinding);
        if (RPC_S_OK != RpcStatus)
        {
            continue;
        }

        RpcStatus = RpcBindingFromStringBindingW(
                                    pStringBinding,
                                    &h);
        if (NULL != pStringBinding)
        {
            RpcStringFreeW(&pStringBinding);
        }
        if (RPC_S_OK != RpcStatus)
        {
            continue;
        }

        RpcStatus = RpcEpResolveBinding(
                            h,
                            BackupKey_v1_0_c_ifspec);
        if (RPC_S_OK != RpcStatus)
        {
            continue;
        }

        //
        // enable privacy and negotiated re-authentication.
        // a fresh authentication is required in the event an existing connection
        // to the target machine already existed which was made with non-default
        // credentials.
        //


        ZeroMemory( &RpcQos, sizeof(RpcQos) );
        RpcQos.Version = RPC_C_SECURITY_QOS_VERSION;
        RpcQos.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
        RpcQos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
        RpcQos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

        RpcStatus = RpcBindingSetAuthInfoExW(
                    h,
                    (LPWSTR)szComputerName,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_AUTHN_GSS_NEGOTIATE,
                    0,
                    0,
                    &RpcQos
                    );
        if (RPC_S_OK != RpcStatus)
        {
            continue;
        }




        __try
        {

            dwRetVal = BackuprKey(
                            h,
                            (GUID*)pguidActionAgent,
                            pDataIn,
                            cbDataIn,
                            ppDataOut,
                            pcbDataOut,
                            dwParam
                            );

        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            RpcStatus = _exception_code();
        }
        if (RPC_S_OK == RpcStatus)
        {
            break;
        }

    }

error:

    if(hToken)
    {
        CloseHandle(hToken);
    }
    if(RPC_S_OK != RpcStatus)
    {
        dwRetVal = RpcStatus;
    }

    if(h)
    {
        RpcBindingFree(&h);
    }


    return dwRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\keyman.cpp ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    keyman.cpp

Abstract:

    This module contains routines to manage master keys on behalf of the
    client.  This includes retrieval, backup and restore.


Author:

    Scott Field (sfield)    09-Sep-97

Revision History:

    Scott Field (sfield)    01-Mar-98
    Use files as the backing store.
    Storage of all masterkey pieces a single atomic operation.

--*/

#include <pch.cpp>
#pragma hdrstop

#include <msaudite.h>

#define REENCRYPT_MASTER_KEY    1
#define ADD_MASTER_KEY_TO_CACHE 2


//
// preferred masterkey selection query/set
//

NTSTATUS
GetPreferredMasterKeyGuid(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
    IN  OUT GUID *pguidMasterKey
    );

BOOL
SetPreferredMasterKeyGuid(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
    IN      GUID *pguidMasterKey
    );

//
// masterkey creation and query
//

DWORD
CreateMasterKey(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
        OUT GUID *pguidMasterKey,
    IN      BOOL fRequireBackup
    );

BOOL
GetMasterKeyByGuid(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
    IN      PSID    pSid,
    IN      BOOL    fMigrate, 
    IN      GUID *pguidMasterKey,
        OUT LPBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey,
        OUT DWORD *pdwMasterKeyDisposition  // refer to MK_DISP_ constants
    );

BOOL
GetMasterKey(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
    IN      PSID    pSid,
    IN      BOOL    fMigrate,
    IN      WCHAR wszMasterKey[MAX_GUID_SZ_CHARS],
        OUT LPBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey,
        OUT DWORD *pdwMasterKeyDisposition
    );

//
// helper functions used during key retrieval and storage.
//

BOOL
ReadMasterKey(
    IN      PVOID pvContext,            // if NULL, caller is assumed to be impersonating
    IN      PMASTERKEY_STORED phMasterKey
    );

BOOL
WriteMasterKey(
    IN      PVOID pvContext,            // if NULL, caller is assumed to be impersonating
    IN      PMASTERKEY_STORED phMasterKey
    );

BOOL
CheckToStompMasterKey(
    IN      PMASTERKEY_STORED_ON_DISK   phMasterKeyCandidate,   // masterkey to check if worthy to stomp over existing
    IN      HANDLE                      hFile,                  // file handle to existing masterkey
    IN OUT  BOOL                        *pfStomp                // stomp the existing masterkey?
    );

BOOL
DuplicateMasterKey(
    IN      PMASTERKEY_STORED phMasterKeyIn,
    IN      PMASTERKEY_STORED phMasterKeyOut
    );

BOOL
CloseMasterKey(
    IN      PVOID pvContext,            // if NULL, caller is assumed to be impersonating
    IN      PMASTERKEY_STORED phMasterKey,
    IN      BOOL fPersist               // persist any changes to storage?
    );

VOID
FreeMasterKey(
    IN      PMASTERKEY_STORED phMasterKey
    );

//
// low-level crypto enabled key persistence query/set
//

DWORD
DecryptMasterKeyFromStorage(
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD dwMKLoc,
    IN      BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN],
        OUT BOOL  *pfUpgradeEncryption,
        OUT PBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey
    );

DWORD
DecryptMasterKeyToMemory(
    IN      BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN],
    IN      PBYTE pbMasterKeyIn,
    IN      DWORD cbMasterKeyIn,
        OUT BOOL *pfUpgradeEncryption, 
        OUT PBYTE *ppbMasterKeyOut,
        OUT DWORD *pcbMasterKeyOut
    );

DWORD
EncryptMasterKeyToStorage(
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD dwMKLoc,
    IN      BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN],
    IN      PBYTE pbMasterKey,
    IN      DWORD cbMasterKey
    );

DWORD
EncryptMasterKeyToMemory(
    IN      BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN],
    IN      DWORD cIterationCount,
    IN      PBYTE pbMasterKey,
    IN      DWORD cbMasterKey,
        OUT PBYTE *ppbMasterKeyOut,
        OUT DWORD *pcbMasterKeyOut
    );

DWORD
PersistMasterKeyToStorage(
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD dwMKLoc,
    IN      PBYTE pbMasterKeyOut,
    IN      DWORD cbMasterKeyOut
    );

DWORD
QueryMasterKeyFromStorage(
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD dwMKLoc,
    IN  OUT PBYTE *ppbMasterKeyOut,
    IN  OUT DWORD *pcbMasterKeyOut
    );

//
// per-user credential derivation
//

BOOL
GetMasterKeyUserEncryptionKey(
    IN      PVOID   pvContext,
    IN      GUID    *pCredentialID,
    IN      PSID    pSid,
    IN      DWORD   dwFlags, 
    IN  OUT BYTE    rgbMKEncryptionKey[A_SHA_DIGEST_LEN]
    );

BOOL
GetLocalKeyUserEncryptionKey(
    IN      PVOID pvContext,
    IN      PMASTERKEY_STORED phMasterKey,
    IN  OUT BYTE rgbLKEncrytionKey[A_SHA_DIGEST_LEN]
    );

//
// backup/restore operations.
//

BOOL
IsBackupMasterKeyRequired(
    IN      PMASTERKEY_STORED phMasterKey,
    IN  OUT BOOL *pfPhaseTwo        // is phase two required?
    );

DWORD
BackupMasterKey(
    IN      PVOID pvContext,
    IN      PMASTERKEY_STORED phMasterKey,
    IN      LPBYTE pbMasterKey,
    IN      DWORD cbMasterKey,
    IN      BOOL fPhaseTwo,         // is phase two required?
    IN      BOOL fAsynchronous      // asynchronous call?
    );

DWORD
QueueBackupMasterKey(
    IN      PVOID pvContext,
    IN      PMASTERKEY_STORED phMasterKey,
    IN      PBYTE pbLocalKey,
    IN      DWORD cbLocalKey,
    IN      PBYTE pbMasterKey,
    IN      DWORD cbMasterKey,
    IN      DWORD dwWaitTimeout             // amount of time to wait for operation to complete
    );

DWORD
RestoreMasterKey(
    IN      PVOID   pvContext,
    IN      PSID    pSid,
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD   dwReason,
        OUT LPBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey
    );


//
// asyncrhonous work functions for:
// 1.  Backup operations
// 2.  Masterkey synchronization operations
//

DWORD
WINAPI
QueueBackupMasterKeyThreadFunc(
    IN      LPVOID lpThreadArgument
    );

DWORD
WINAPI
QueueSyncMasterKeysThreadFunc(
    IN      LPVOID lpThreadArgument
    );


//
// backup/restore policy operations
//

BOOL
InitializeMasterKeyPolicy(
    IN      PVOID pvContext,
    IN      MASTERKEY_STORED *phMasterKey,
    OUT     BOOL *fLocalAccount
    );





BOOL
IsDomainBackupRequired(
    IN      PVOID pvContext
    );

//
// primitives for reading and writing to per-user storage.
//








typedef NET_API_STATUS (WINAPI *NETUSERMODALSGET)(
    LPWSTR servername,
    DWORD level,
    LPBYTE *bufptr
    );

typedef NET_API_STATUS (WINAPI *NETSERVERGETINFO)(
    LPWSTR servername,
    DWORD level,
    LPBYTE *bufptr
    );


typedef NET_API_STATUS (WINAPI *NETAPIBUFFERFREE)(
    LPVOID Buffer
    );








DWORD
InitiateSynchronizeMasterKeys(
    IN      PVOID pvContext         // server context
    )
/*++

    Force Synchronization of all masterkeys associated with the caller.

    This can include per-machine keys if the call was made with the per-machine
    flag turned on.  Otherwise, the masterkeys associated with the client
    user security context are synchronized.

    Synchronization is required to support a variety of login credential
    change scenarios:

    1. Domain Administrator assigns new password to user.
    2. User changes password locally.
    3. User changes password from another machine on the network.
    4. User which is primarily disconnected from the network requests new
       password from Domain Administrator, connect to network long enough
       to refresh Netlogon cache with new credential.

--*/
{
    PQUEUED_SYNC pQueuedSync = NULL;
    DWORD cbQueuedSync = sizeof(QUEUED_SYNC);
    DWORD dwLastError = ERROR_SUCCESS;

    D_DebugLog((DEB_TRACE_API, "SynchronizeMasterKeys\n"));

    pQueuedSync = (PQUEUED_SYNC)SSAlloc( cbQueuedSync );
    if( pQueuedSync == NULL ) {
        dwLastError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto cleanup;
    }

    ZeroMemory( pQueuedSync, cbQueuedSync );
    pQueuedSync->cbSize = cbQueuedSync;

    //
    // duplicate the outstanding server context.
    //

    dwLastError = CPSDuplicateContext(pvContext, &(pQueuedSync->pvContext));

    if( dwLastError != ERROR_SUCCESS )
         goto cleanup;

    //
    // create the worker thread to handle the synchronize request.
    //

//    dwLastError = CPSCreateWorkerThread(
//                                (PVOID)QueueSyncMasterKeysThreadFunc,
//                                pQueuedSync
//                                );

    if( !QueueUserWorkItem(
            QueueSyncMasterKeysThreadFunc,
            pQueuedSync,
            WT_EXECUTELONGFUNCTION
            )) {

        dwLastError = GetLastError();
    }


cleanup:

    if( dwLastError != ERROR_SUCCESS ) {

        //
        // free resources locally since a thread was not successfully created;
        // normally, the worker thread will free these resources.
        //

        if( pQueuedSync ) {

            if( pQueuedSync->pvContext )
                CPSFreeContext( pQueuedSync->pvContext );

            SSFree( pQueuedSync );
        }
    }

    return dwLastError;
}



DWORD
WINAPI
QueueSyncMasterKeysThreadFunc(
    IN      LPVOID lpThreadArgument
    )
/*++

    This routines performs asyncronous masterkey synchronization associated
    with the client security context that invoked the operation.

    All masterkeys associated with the security context are queried which
    in turn causes a re-encrypt/sync if necessary.

--*/
{
    PQUEUED_SYNC pQueuedSync = (PQUEUED_SYNC)lpThreadArgument;
    PVOID pvContext = NULL;
    DWORD dwLastError = ERROR_SUCCESS;

    if( pQueuedSync == NULL || pQueuedSync->cbSize != sizeof(QUEUED_SYNC) ||
        pQueuedSync->pvContext == NULL ) {
        dwLastError = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    pvContext = pQueuedSync->pvContext;

    dwLastError = SynchronizeMasterKeys(pvContext, 0);

cleanup:

    if( pvContext ) {
        CPSFreeContext( pvContext );
    }

    if( pQueuedSync )
        SSFree( pQueuedSync );

    return dwLastError;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReencryptMasterKey
//
//  Synopsis:   Read in the specified (machine) master key file, encrypt it 
//              using the current DPAPI LSA secret, and write it back out.
//              This routine is only called when updating the DPAPI LSA 
//              secret (e.g., by sysprep).
//
//  Arguments:  [pvContext]          -- Server context.
//
//              [pLogonId]           -- User logon session.
//
//              [pszUserStorageArea] -- Path to user profile.
//
//              [pszFilename]        -- Filename of the master key file.
//
//  Returns:    ERROR_SUCCESS if the operation was successful, a Windows
//              error code otherwise.
//
//  History:    
//
//  Notes:      This function should only be called for machine master keys,
//              since these are typically the only ones that are encrypted 
//              using the LSA secret.
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ReencryptMasterKey(
    PVOID pvContext,
    PLUID pLogonId,
    LPWSTR pszUserStorageArea,
    LPWSTR pszFilename)
{
    MASTERKEY_STORED hMasterKey;
    DWORD   cbFilePath;
    LPBYTE  pbMasterKey;
    DWORD   cbMasterKey;
    GUID    guidMasterKey;
    BYTE    rgbMKEncryptionKey[A_SHA_DIGEST_LEN];
    BOOL    fUserCredentialValid;
    GUID CredentialID;
    DWORD dwLastError;

    //
    // Validate input parameters.
    //

    if((pszUserStorageArea == NULL) || (pszFilename == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(WSZ_BYTECOUNT(pszFilename) > sizeof(hMasterKey.wszguidMasterKey))
    {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Initialize master key memory block.
    //

    ZeroMemory( &hMasterKey, sizeof(hMasterKey) );

    hMasterKey.fModified = TRUE;

    cbFilePath = WSZ_BYTECOUNT(pszUserStorageArea);
    hMasterKey.szFilePath = (LPWSTR)SSAlloc( cbFilePath );
    if(hMasterKey.szFilePath == NULL) 
    {
        dwLastError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        return dwLastError;
    }

    CopyMemory(hMasterKey.szFilePath, pszUserStorageArea, cbFilePath);
    CopyMemory(hMasterKey.wszguidMasterKey, pszFilename, WSZ_BYTECOUNT(pszFilename));


    //
    // read the master key components into memory.
    //

    if(!ReadMasterKey( pvContext, &hMasterKey )) 
    {
        D_DebugLog((DEB_WARN, "ReadMasterKey failed: 0x%x\n", GetLastError()));
        CloseMasterKey(pvContext, &hMasterKey, FALSE);
        return ERROR_NOT_FOUND;
    }

    //
    // read the master key from the cache
    //

    dwLastError = MyGuidFromStringW(hMasterKey.wszguidMasterKey, &guidMasterKey);

    if(dwLastError != ERROR_SUCCESS)
    {
        CloseMasterKey(pvContext, &hMasterKey, FALSE);
        return dwLastError;
    }

    pbMasterKey = NULL;

    if(!SearchMasterKeyCache( pLogonId, &guidMasterKey, &pbMasterKey, &cbMasterKey ))
    {
        D_DebugLog((DEB_ERROR, "Master key %ls not found in cache!\n", hMasterKey.wszguidMasterKey));
        CloseMasterKey(pvContext, &hMasterKey, FALSE);
        return ERROR_NOT_FOUND;
    }


    //
    // Get encryption key
    //

    ZeroMemory(&CredentialID, sizeof(CredentialID));

    fUserCredentialValid = GetMasterKeyUserEncryptionKey(pvContext, 
                                                     &CredentialID,
                                                     NULL, 
                                                     USE_DPAPI_OWF | USE_ROOT_CREDENTIAL, 
                                                     rgbMKEncryptionKey);
    if(fUserCredentialValid)
    {
        hMasterKey.dwPolicy |= POLICY_DPAPI_OWF;
    }
    else
    {
        D_DebugLog((DEB_ERROR, "Unable to get user encryption key\n"));
        CloseMasterKey(pvContext, &hMasterKey, FALSE);
        return ERROR_NOT_FOUND;
    }


    //
    // re-encrypt the masterkey.
    //

    dwLastError = EncryptMasterKeyToStorage(
                            &hMasterKey,
                            REGVAL_MASTER_KEY,
                            rgbMKEncryptionKey,
                            pbMasterKey,
                            cbMasterKey
                            );

    SSFree(pbMasterKey);

    if(dwLastError != ERROR_SUCCESS)
    {
        D_DebugLog((DEB_WARN, "Error encrypting master key!\n"));
        CloseMasterKey(pvContext, &hMasterKey, FALSE);
        return dwLastError;
    }


    // 
    // Save the master key to disk.
    //

    if(!CloseMasterKey(pvContext, &hMasterKey, TRUE))
    {
        D_DebugLog((DEB_WARN, "Error saving master key!\n"));
        return ERROR_NOT_FOUND;
    }

    return ERROR_SUCCESS;
}


//+---------------------------------------------------------------------------
//
//  Function:   SynchronizeMasterKeys
//
//  Synopsis:   Enumerate all of the master keys, and update their encryption
//              state as necessary.
//
//  Arguments:  [pvContext]     -- Server context.
//
//              [dwMode]        -- Operation to perform on the master keys.
//
//  Returns:    ERROR_SUCCESS if the operation was successful, a Windows
//              error code otherwise.
//
//  History:    
//
//  Notes:      By default, this function will read in each of the master
//              keys belonging to the specified user. If necessary, a key 
//              recovery operation will be done, and the reencrypted key
//              will be written back out to disk.
//
//              If the dwMode parameter is non-zero, then one of the
//              following operations will be done:
//
//              ADD_MASTER_KEY_TO_CACHE 
//                  Read each master key into the master key cache. Fail
//                  if any of the keys cannot be successfully read. This
//                  operation is done before the DPAPI LSA secret is updated.
//
//              REENCRYPT_MASTER_KEY
//                  Re-encrypt each master key (from the cache), and write
//                  them back out to disk. This operation is performed after
//                  the DPAPI LSA secret is updated.
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SynchronizeMasterKeys(
    IN PVOID pvContext,
    IN DWORD dwMode)
{
    LPWSTR szUserStorageArea = NULL;
    BOOL fImpersonated = FALSE;
    DWORD cbUserStorageArea;
    HANDLE hFindData = INVALID_HANDLE_VALUE;
// note: tis a shame that ? doesn't map to wildcard a single character...
//    const WCHAR szFileName[] = L"????????-????-????-????-????????????";
    const WCHAR szFileName[] = L"*";
    LPWSTR szFileMatch = NULL;
    DWORD cbFileMatch;
    WIN32_FIND_DATAW FindFileData;
    DWORD dwLastError;
    PSID *apsidHistory = NULL;
    DWORD cSids = 0;
    DWORD iSid = 0;
    LUID LogonId;
    BOOL fLogonIdValid = FALSE;
    GUID guidMasterKey;

    //
    // get LogonId associated with client security context.
    //

    dwLastError = CPSImpersonateClient( pvContext );
    if( dwLastError == ERROR_SUCCESS )
    {
        if(GetThreadAuthenticationId(GetCurrentThread(), &LogonId))
        {
            fLogonIdValid = TRUE;
        }

        CPSRevertToSelf( pvContext );
    }


    // 
    // Get the sid history for this user, so 
    // we can sync all keys
    //
    dwLastError = CPSGetSidHistory(pvContext,
                                   &apsidHistory,
                                   &cSids);
    if(ERROR_SUCCESS != dwLastError)
    {
        goto cleanup;
    }


    for(iSid=0; iSid < cSids; iSid++)
    {
        //
        // get the path to the per-user master key storage area on disk
        //

        dwLastError = CPSGetUserStorageArea( pvContext, 
                                             (iSid > 0)?apsidHistory[iSid]:NULL, 
                                             FALSE, 
                                             &szUserStorageArea );

        if( dwLastError != ERROR_SUCCESS )
        {
            if(dwLastError == ERROR_PATH_NOT_FOUND || dwLastError == ERROR_FILE_NOT_FOUND)
            { 
                dwLastError = ERROR_SUCCESS;
            }
            goto cleanup;
        }


        //
        // build the wild card search path.
        //

        cbUserStorageArea = lstrlenW( szUserStorageArea ) * sizeof(WCHAR);
        cbFileMatch = cbUserStorageArea + sizeof(szFileName);

        szFileMatch = (LPWSTR)SSAlloc( cbFileMatch );
        if(NULL == szFileMatch)
        {
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        CopyMemory( szFileMatch, szUserStorageArea, cbUserStorageArea );
        CopyMemory( ((LPBYTE)szFileMatch)+cbUserStorageArea, szFileName, sizeof(szFileName) );


        //
        // impersonate the client security context via the duplicated context.
        //

        dwLastError = CPSImpersonateClient( pvContext );
        if( dwLastError != ERROR_SUCCESS )
            goto cleanup;

        fImpersonated = TRUE;

        //
        // now enumerate the files looking for ones that look interesting.
        //

        hFindData = FindFirstFileW( szFileMatch, &FindFileData );

        if( hFindData == INVALID_HANDLE_VALUE )
            goto cleanup;

        do {
            LPBYTE pbMasterKey = NULL;
            DWORD cbMasterKey = 0;
            DWORD dwMasterKeyDisposition;

            if( FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
                continue;

            //
            // ignore files which don't look like a textual GUID.
            //

            if( lstrlenW( FindFileData.cFileName ) != 36 )
                continue;

            if( FindFileData.cFileName[ 8  ] != L'-' ||
                FindFileData.cFileName[ 13 ] != L'-' ||
                FindFileData.cFileName[ 18 ] != L'-' ||
                FindFileData.cFileName[ 23 ] != L'-' ) {

                continue;
            }

            switch(dwMode)
            {
            case ADD_MASTER_KEY_TO_CACHE:

                //
                // Add this master key to the master key cache. Abort the
                // entire function if the operation is not successful for
                // any reason.
                //

                if(!fLogonIdValid)
                {
                    dwLastError = ERROR_ACCESS_DENIED;
                    goto cleanup;
                }

                dwLastError = MyGuidFromStringW(FindFileData.cFileName, &guidMasterKey);
                if(dwLastError != ERROR_SUCCESS)
                { 
                    goto cleanup;
                }

                // Fetch the specified key.
                if(!GetMasterKey(pvContext,
                                 szUserStorageArea,
                                 apsidHistory[iSid],         
                                 iSid > 0,
                                 FindFileData.cFileName,
                                 &pbMasterKey,
                                 &cbMasterKey,
                                 &dwMasterKeyDisposition))
                {
                    dwLastError = ERROR_ACCESS_DENIED;
                    goto cleanup;
                }

                // Add the key to the cache.
                if(!InsertMasterKeyCache(&LogonId,
                                         &guidMasterKey,
                                         pbMasterKey,
                                         cbMasterKey))
                {
                    if(pbMasterKey) 
                    {
                        ZeroMemory( pbMasterKey, cbMasterKey );
                        SSFree( pbMasterKey );
                    }
                    dwLastError = ERROR_ACCESS_DENIED;
                    goto cleanup;
                }

                // Scrub and free the master key.
                if(pbMasterKey) 
                {
                    ZeroMemory( pbMasterKey, cbMasterKey );
                    SSFree( pbMasterKey );
                }
                
                break;


            case REENCRYPT_MASTER_KEY:
                //
                // The DPAPI LSA secret has changed, so read the master key 
                // from the cache and reencrypt it to storage. This mode will
                // only be used for the local machine master keys.
                //

                if(!fLogonIdValid)
                {
                    dwLastError = ERROR_ACCESS_DENIED;
                    goto cleanup;
                }

                // Ignore the returned error code, since there's little
                // we can do about it now...
                ReencryptMasterKey(pvContext,
                                   &LogonId,
                                   szUserStorageArea,
                                   FindFileData.cFileName);

                break;


            default:

                //
                // fetch the specified key; this will cause a credential re-sync
                // if necessary.
                //

                if(GetMasterKey(
                            pvContext,
                            szUserStorageArea,
                            apsidHistory[iSid],         
                            iSid > 0,
                            FindFileData.cFileName,
                            &pbMasterKey,
                            &cbMasterKey,
                            &dwMasterKeyDisposition
                            ) )
        
                {
                    //
                    // success, scrub and free the key.
                    //
                    if( pbMasterKey ) 
                    {
                        ZeroMemory( pbMasterKey, cbMasterKey );
                        SSFree( pbMasterKey );
                    }
                }

                break;
            }

        } while( FindNextFileW( hFindData, &FindFileData ) );

        dwLastError = ERROR_SUCCESS;

        SSFree(szUserStorageArea);
        szUserStorageArea = NULL;
    }


cleanup:

    if( pvContext ) 
    {
        if( fImpersonated )
            CPSRevertToSelf( pvContext );
    }

    if( hFindData != INVALID_HANDLE_VALUE )
        FindClose( hFindData );

    if( szUserStorageArea )
        SSFree( szUserStorageArea );

    if( szFileMatch )
        SSFree( szFileMatch );

    if(apsidHistory)
        SSFree( apsidHistory );

    return dwLastError;
}


VOID
DPAPISynchronizeMasterKeys(
    IN HANDLE hUserToken)
{
    CRYPT_SERVER_CONTEXT ServerContext;
    BOOL fContextCreated = FALSE;
    HANDLE hOldUser = NULL;
    DWORD dwError;

    D_DebugLog((DEB_TRACE_API, "DPAPISynchronizeMasterKeys\n"));

    //
    // Create a server context.
    //

    if(hUserToken)
    {
        if(!OpenThreadToken(GetCurrentThread(), 
                        TOKEN_IMPERSONATE | TOKEN_READ,
                        TRUE, 
                        &hOldUser)) 
        {
            hOldUser = NULL;
        }

        if(!ImpersonateLoggedOnUser(hUserToken))
        {
            dwError = GetLastError();
            CloseHandle(hOldUser);
            goto cleanup;
        }
    }

    dwError = CPSCreateServerContext(&ServerContext, NULL);

    if(hOldUser)
    {
        SetThreadToken(NULL, hOldUser);
        CloseHandle(hOldUser);
        hOldUser = NULL;
    }

    if(dwError != ERROR_SUCCESS)
    {
        goto cleanup;
    }
    fContextCreated = TRUE;

   
    //
    // Synchronize the master keys. 
    //

    dwError = InitiateSynchronizeMasterKeys(&ServerContext);

    if(dwError != ERROR_SUCCESS)
    {
        goto cleanup;
    }


cleanup:

    if(fContextCreated)
    {
        CPSDeleteServerContext( &ServerContext );
    }

    D_DebugLog((DEB_TRACE_API, "DPAPISynchronizeMasterKeys returned 0x%x\n", dwError));
}


DWORD
GetSpecifiedMasterKey(
    IN      PVOID pvContext,        // server context
    IN  OUT GUID *pguidMasterKey,
        OUT LPBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey,
    IN      BOOL fSpecified         // get specified pguidMasterKey key ?
    )
/*++

    This function returns the caller a decrypted master key.
    If fSpecified is TRUE, the returned master key is the one specified by
    the GUID pointed to by pguidMasterKey.  Otherwise, the returned master key
    is the preferred master key, and pguidMasterKey is filled with the GUID
    value associated with the preferred master key.

    The proper way to utilize the fSpecified parameter is to specify FALSE
    when obtaining a masterkey associated with an encrypt operation;
    specify TRUE and supply valid GUID in pguidMasterKey when doing a decrypt
    operation.  For an encrypt operation, the caller will store the GUID
    returned in pguidMasterKey alongside any data encrypted with that master
    key.

    On success, the return value is ERROR_SUCCESS.  The caller must free the buffer
    pointed to by ppbMasterKey using SSFree() when finished with it.  The
    caller should keep this buffer around for the shortest possible time, to
    avoid pagefile exposure.

    On failure, the return value is not ERROR_SUCCESS.  The caller need not free the
    buffer pointed to ppbMasterKey.

--*/
{

    LUID LogonId;
    BOOL fCached = FALSE;   // masterkey found in cache?

    LPWSTR szUserStorageArea = NULL;

    DWORD dwMasterKeyDisposition = 0;

    DWORD dwLocalError;
    DWORD dwLastError;
    BOOL fSetPreferred = FALSE; // update preferred guid?
    BOOL fSuccess = FALSE;
    PSID *apsidHistory = NULL;
    DWORD cSids = 0;
    NTSTATUS Status;

    D_DebugLog((DEB_TRACE_API, "GetSpecifiedMasterKey called\n"));

    //
    // get LogonId associated with client security context.
    //

    dwLastError = CPSImpersonateClient( pvContext );
    if( dwLastError != ERROR_SUCCESS )
    {
        D_DebugLog((DEB_TRACE_API, "GetSpecifiedMasterKey returned 0x%x\n", dwLastError));
        return dwLastError;
    }

    fSuccess = GetThreadAuthenticationId(GetCurrentThread(), &LogonId);
    if( !fSuccess )
    {
        dwLastError = GetLastError();
    }
    CPSRevertToSelf( pvContext );

    if( !fSuccess )
    {
        D_DebugLog((DEB_TRACE_API, "GetSpecifiedMasterKey returned 0x%x\n", dwLastError));
        return dwLastError;
    }

    fSuccess = FALSE;


    //
    // get the path to the per-user master key storage area on disk
    //

    dwLastError = CPSGetUserStorageArea( pvContext, NULL, TRUE, &szUserStorageArea );

    if(dwLastError != ERROR_SUCCESS)
    {
        D_DebugLog((DEB_WARN, "CPSGetUserStorageArea failed: 0x%x\n", dwLastError));
        goto cleanup;
    }

    D_DebugLog((DEB_TRACE, "Master key user path: %ls\n", szUserStorageArea));


    //
    // Get the preferred key GUID if possible
    //
    if( !fSpecified ) 
    {

        //
        // determine what is the preferred master key.
        // if none exists, create one, and set it as being preferred.
        //

        Status = GetPreferredMasterKeyGuid( pvContext, szUserStorageArea, pguidMasterKey );
        if(!NT_SUCCESS(Status))
        {
            if(Status == STATUS_PASSWORD_EXPIRED)
            {
                GUID guidNewMasterKey;

                // A preferred master key exists, but it has expired. Attempt to generate
                // a new master key, but fall back to the old one if we're unable to 
                // create a proper backup for the new master key.
                dwLastError = CreateMasterKey( pvContext, szUserStorageArea, &guidNewMasterKey, TRUE );
                if(dwLastError == ERROR_SUCCESS)
                {
                    // Use new key.
                    memcpy(pguidMasterKey, &guidNewMasterKey, sizeof(GUID));

                    // update preferred guid.
                    fSetPreferred = TRUE;
                }
            }
            else
            {
                // No preferred master key currently exists, so generate a new one.
                dwLastError = CreateMasterKey( pvContext, szUserStorageArea, pguidMasterKey, FALSE );
                if(dwLastError != ERROR_SUCCESS)
                {
                    goto cleanup;
                }

                // update preferred guid.
                fSetPreferred = TRUE;
            }
        }
    }


    //
    // search cache for specified masterkey.
    //

    if(SearchMasterKeyCache( &LogonId, pguidMasterKey, ppbMasterKey, pcbMasterKey ))
    {
        D_DebugLog((DEB_TRACE, "Master key found in cache.\n"));

        fCached = TRUE;
        fSuccess = TRUE;
        goto cleanup;
    }
    else
    {
        DWORD i;

        // If it's not in the cache, we need to load it.  
        // By default, we have the users primary sid
        //
        cSids = 1;

        if(fSpecified)
        {
            //
            // If the GUID was specified, we need to find it, so get
            // the SID History so we can search all SIDS the user has
            // been for this one.
            //
            dwLastError = CPSGetSidHistory(pvContext,
                                           &apsidHistory,
                                           &cSids);
            if(ERROR_SUCCESS != dwLastError)
            {
                D_DebugLog((DEB_WARN, "CPSGetSidHistory failed: 0x%x\n", dwLastError));
                goto cleanup;
            }
        }

        for(i=0; i < cSids; i++)
        {

            if((fSpecified) && (i > 0))
            {
                // for sid's beyond the 0th one (the current user's sid), 
                // we need to grab the new storage area.
                if(szUserStorageArea)
                {
                    SSFree(szUserStorageArea);
                    szUserStorageArea = NULL;
                }
                dwLocalError = CPSGetUserStorageArea( pvContext, 
                                                  apsidHistory[i], 
                                                  FALSE, 
                                                  &szUserStorageArea );

                if(dwLocalError != ERROR_SUCCESS)
                {
                    // There is no storage area for this SID, so try the next
                    continue;
                }
            }


            //
            // get the master key.
            //

            fSuccess = GetMasterKeyByGuid(
                            pvContext,
                            szUserStorageArea,
                            (i > 0)?apsidHistory[i]:NULL,
                            i > 0,
                            pguidMasterKey,
                            ppbMasterKey,
                            pcbMasterKey,
                            &dwMasterKeyDisposition);

            D_DebugLog((DEB_TRACE, "GetMasterKeyByGuid disposition: %s\n",
                (dwMasterKeyDisposition == MK_DISP_OK) ? "Normal" :
                (dwMasterKeyDisposition == MK_DISP_BCK_LCL) ? "Local backup" :
                (dwMasterKeyDisposition == MK_DISP_BCK_DC) ? "DC backup" :
                (dwMasterKeyDisposition == MK_DISP_STORAGE_ERR) ? "Storage error" :
                (dwMasterKeyDisposition == MK_DISP_DELEGATION_ERR) ? "Delegation error" :
                "Unknown error"));

            if(!fSuccess)
            {
                if(MK_DISP_STORAGE_ERR != dwMasterKeyDisposition)
                {
                    // The disposition was not a storage error, so the key does
                    // exist in this area, but there was some other error.
                    break;
                }
            }
            else
            {
                break;
            }
        }
    }
    

    //
    // if this was an encrypt operation, and we failed to get at the preferred key,
    // create a new key and set it preferred.
    //

    if(!fSuccess && 
       !fSpecified && 
       ((dwMasterKeyDisposition == MK_DISP_STORAGE_ERR) ||
       (dwMasterKeyDisposition == MK_DISP_DELEGATION_ERR) ))
    {
        dwLastError = CreateMasterKey( pvContext, szUserStorageArea, pguidMasterKey, FALSE );
        if(dwLastError != ERROR_SUCCESS)
            goto cleanup;

        fSuccess = GetMasterKeyByGuid(
                        pvContext,
                        szUserStorageArea,
                        NULL,
                        FALSE,
                        pguidMasterKey,
                        ppbMasterKey,
                        pcbMasterKey,
                        &dwMasterKeyDisposition
                        );

        fSetPreferred = fSuccess;
    }

    if( fSuccess && fSetPreferred ) 
    {

        //
        // masterkey creation succeeded, and usage of the key succeeded.
        // set key as being preferred.
        //

        SetPreferredMasterKeyGuid( pvContext, szUserStorageArea, pguidMasterKey );
    }


cleanup:

    if(szUserStorageArea)
    {
        SSFree(szUserStorageArea);
    }

    if(apsidHistory)
    {
        SSFree(apsidHistory);
    }

    if(fSuccess) 
    {
        //
        // add entry to cache if it wasn't found there.
        //

        if( !fCached )
        {
            InsertMasterKeyCache( &LogonId, pguidMasterKey, *ppbMasterKey, *pcbMasterKey );
        }

        D_DebugLog((DEB_TRACE_API, "GetSpecifiedMasterKey returned 0x%x\n", ERROR_SUCCESS));

        return ERROR_SUCCESS;
    }


    if(dwLastError == ERROR_SUCCESS)
    {
        dwLastError = (DWORD)NTE_BAD_KEY_STATE;
    }

    if(MK_DISP_DELEGATION_ERR == dwMasterKeyDisposition)
    {
        dwLastError = (DWORD)SEC_E_DELEGATION_REQUIRED;
    }

    D_DebugLog((DEB_TRACE_API, "GetSpecifiedMasterKey returned 0x%x\n", dwLastError));

    return dwLastError;
}




DWORD
CreateMasterKey(
    IN  PVOID pvContext,
    IN  LPCWSTR szUserStorageArea,
    OUT GUID *pguidMasterKey,
    IN  BOOL fRequireBackup)
{
    MASTERKEY_STORED hMasterKey;
    DWORD cbFilePath;

    BYTE pbMasterKey[ MASTERKEY_MATERIAL_SIZE ];
    DWORD cbMasterKey;

    BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN];  // masterkey encryption key

    BYTE pbLocalKey[ LOCALKEY_MATERIAL_SIZE ];
    DWORD cbLocalKey;
    BYTE rgbLKEncryptionKey[A_SHA_DIGEST_LEN];  // localkey encryption key

    BOOL fUserCredentialValid = FALSE;

    DWORD dwLastError;
    BOOL fSuccess = FALSE;
    BOOL fLocalAccount = FALSE;

    GUID CredentialID;

    D_DebugLog((DEB_TRACE, "CreateMasterKey\n"));

    ZeroMemory(&CredentialID, sizeof(CredentialID));

    //
    // generate new GUID
    //

    dwLastError = UuidCreate( pguidMasterKey );

    if( dwLastError ) {
        if( dwLastError == RPC_S_UUID_LOCAL_ONLY ) {
            dwLastError = ERROR_SUCCESS;
        } else {
            return dwLastError;
        }
    }


    //
    // initialize masterkey
    //


    ZeroMemory( &hMasterKey, sizeof(hMasterKey));
    hMasterKey.dwVersion = MASTERKEY_STORED_VERSION;
    hMasterKey.fModified = TRUE;

    //
    // set initial (default) masterkey policy.
    // Do this whenever we determine a new masterkey is created/selected.
    // This allows us future flexibility if we want to pull policy bits
    // from some admin defined place.
    //

    InitializeMasterKeyPolicy( pvContext, &hMasterKey , &fLocalAccount);

    //
    // copy path to key file into masterkey memory block.
    //

    cbFilePath = (lstrlenW( szUserStorageArea ) + 1) * sizeof(WCHAR);
    hMasterKey.szFilePath = (LPWSTR)SSAlloc( cbFilePath );
    if(hMasterKey.szFilePath == NULL)
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;

    CopyMemory(hMasterKey.szFilePath, szUserStorageArea, cbFilePath);


    if( MyGuidToStringW( pguidMasterKey, hMasterKey.wszguidMasterKey ) != 0 )
    {
        dwLastError = ERROR_INVALID_DATA;
        goto cleanup;
    }


    #ifdef COMPILED_BY_DEVELOPER
    D_DebugLog((DEB_TRACE, "Master key GUID:%ls\n", hMasterKey.wszguidMasterKey));
    #endif

    //
    // generate random masterkey in memory.
    //

    cbMasterKey = sizeof(pbMasterKey);
    if(!RtlGenRandom(pbMasterKey, cbMasterKey))
    {
        dwLastError = GetLastError();
        goto cleanup;
    }

    #ifdef COMPILED_BY_DEVELOPER
    D_DebugLog((DEB_TRACE, "Master key:\n"));
    D_DPAPIDumpHexData(DEB_TRACE, "  ", pbMasterKey, cbMasterKey);
    #endif


    //
    // generate random localkey in memory.
    //

    cbLocalKey = sizeof(pbLocalKey);
    if(!RtlGenRandom(pbLocalKey, cbLocalKey))
    {
        dwLastError = GetLastError();
        goto cleanup;
    }

    #ifdef COMPILED_BY_DEVELOPER
    D_DebugLog((DEB_TRACE, "Local key:\n"));
    D_DPAPIDumpHexData(DEB_TRACE, "  ", pbLocalKey, cbLocalKey);
    #endif


    //
    // get current masterkey encryption key.
    //

    if(fLocalAccount)
    {
        fUserCredentialValid = GetMasterKeyUserEncryptionKey(pvContext, 
                                                         &CredentialID,
                                                         NULL, 
                                                         USE_DPAPI_OWF | USE_ROOT_CREDENTIAL, 
                                                         rgbMKEncryptionKey);
        if(fUserCredentialValid)
        {
            hMasterKey.dwPolicy |= POLICY_DPAPI_OWF;

            #ifdef COMPILED_BY_DEVELOPER
            D_DebugLog((DEB_TRACE, "MK Encryption key:\n"));
            D_DPAPIDumpHexData(DEB_TRACE, "  ", rgbMKEncryptionKey, sizeof(rgbMKEncryptionKey));

            D_DebugLog((DEB_TRACE, "MK Encryption key GUID:\n"));
            D_DPAPIDumpHexData(DEB_TRACE, "  ", (PBYTE)&CredentialID, sizeof(CredentialID));
            #endif
        }
        else
        {
            D_DebugLog((DEB_WARN, "Unable to get SHA OWF user encryption key!\n"));
        }

    }

    if(!fUserCredentialValid)
    {
        //
        // If we couldn't use the DPAPI owf, then do something else
        //
        fUserCredentialValid = GetMasterKeyUserEncryptionKey(pvContext,
                                                             fLocalAccount?(&CredentialID):NULL,
                                                             NULL, 
                                                             USE_ROOT_CREDENTIAL, 
                                                             rgbMKEncryptionKey);

        #ifdef COMPILED_BY_DEVELOPER
            if(fUserCredentialValid)
            { 
                D_DebugLog((DEB_TRACE, "MK Encryption key:\n"));
                D_DPAPIDumpHexData(DEB_TRACE, "  ", rgbMKEncryptionKey, sizeof(rgbMKEncryptionKey));

                if(fLocalAccount)
                {
                    D_DebugLog((DEB_TRACE, "MK Encryption key GUID:\n"));
                    D_DPAPIDumpHexData(DEB_TRACE, "  ", (PBYTE)&CredentialID, sizeof(CredentialID));
                }
            }
            else
            {
                D_DebugLog((DEB_WARN, "Unable to get NT OWF user encryption key!\n"));
            }
        #endif
    }


    //
    // if the user credential is not intact or available, generate a random
    // one for the time being.  When fUserCredentialIntact is FALSE, we also
    // do not attempt to backup/restore the key to phase 1 status.
    // When fUserCredentialIntact eventually becomes TRUE, we will upgrade to
    // phase 2 transparently.
    //

    if( !fUserCredentialValid ) 
    {

        //
        // if no backup was specified in policy, we can't run with an
        // random credential, as it won't be backed up to support temporary
        // credential-less operation (eg: delegation).
        //

        if( hMasterKey.dwPolicy & POLICY_NO_BACKUP )
            goto cleanup;

        RtlGenRandom(rgbMKEncryptionKey, sizeof(rgbMKEncryptionKey));

        #ifdef COMPILED_BY_DEVELOPER
        D_DebugLog((DEB_TRACE, "MK Encryption key:\n"));
        D_DPAPIDumpHexData(DEB_TRACE, "  ", rgbMKEncryptionKey, sizeof(rgbMKEncryptionKey));
        #endif
    }
    else if(fLocalAccount)
    {
        //
        // Save the local backup information
        // 

        LOCAL_BACKUP_DATA LocalBackupData;

        LocalBackupData.dwVersion = MASTERKEY_BLOB_LOCALKEY_BACKUP;
        CopyMemory(&LocalBackupData.CredentialID, &CredentialID, sizeof(CredentialID));


        dwLastError = PersistMasterKeyToStorage(
                        &hMasterKey,
                        REGVAL_BACKUP_LCL_KEY,
                        (PBYTE)&LocalBackupData,
                        sizeof(LocalBackupData)
                        );
        if(ERROR_SUCCESS != dwLastError)
        {
            goto cleanup;
        }
    }


    //
    // get localkey user encryption key.
    //

    if(!GetLocalKeyUserEncryptionKey(pvContext, &hMasterKey, rgbLKEncryptionKey))
        goto cleanup;

    #ifdef COMPILED_BY_DEVELOPER
    D_DebugLog((DEB_TRACE, "LK Encryption key:\n"));
    D_DPAPIDumpHexData(DEB_TRACE, "  ", rgbLKEncryptionKey, sizeof(rgbLKEncryptionKey));
    #endif

    //
    // now, encrypt and store the master key.
    //

    dwLastError = EncryptMasterKeyToStorage(
                    &hMasterKey,
                    REGVAL_MASTER_KEY,
                    rgbMKEncryptionKey,
                    pbMasterKey,
                    cbMasterKey
                    );

    if(dwLastError == ERROR_SUCCESS) 
    {

        //
        // now, encrypt and store the local key.
        //

        dwLastError = EncryptMasterKeyToStorage(
                        &hMasterKey,
                        REGVAL_LOCAL_KEY,
                        rgbLKEncryptionKey,
                        pbLocalKey,
                        cbLocalKey
                        );
    }


    if(dwLastError == ERROR_SUCCESS) 
    {
        BOOL    fPhaseTwo = FALSE;
        fSuccess = TRUE;


        //
        // after creation, do initial backup if necessary.
        //

        if(IsBackupMasterKeyRequired( &hMasterKey, &fPhaseTwo )) 
        {
            DWORD dwBackupError;


            dwBackupError = BackupMasterKey(
                            pvContext,
                            &hMasterKey,
                            pbMasterKey,
                            cbMasterKey,
                            fPhaseTwo,              // phase two backup required?
                            fUserCredentialValid    // async only if cred valid
                            );

            if(dwBackupError != ERROR_SUCCESS)
            {
                if(!fUserCredentialValid || fRequireBackup)
                {
                    //
                    // no valid credential, and backup failed, fail creation of
                    // this key.
                    //

                    dwLastError = SEC_E_DELEGATION_REQUIRED;
                    fSuccess = FALSE;
                }


            }

        }
    }




cleanup:

    ZeroMemory(pbMasterKey, cbMasterKey);
    ZeroMemory(rgbMKEncryptionKey, sizeof(rgbMKEncryptionKey));
    ZeroMemory(rgbLKEncryptionKey, sizeof(rgbLKEncryptionKey));

    //
    // note: it's possible for a race to occur closing the master key
    // at this point, because the key may be backed up asynchronously.
    // this isn't a problem because when a key is persisted to disk,
    // we will not downgrade the backed up blob to non-backed up, as the
    // CloseMasterKey() code includes logic to prevent that situation from
    // occuring.
    //


    if(!CloseMasterKey(pvContext, &hMasterKey, fSuccess))
        fSuccess = FALSE;

    if(fSuccess)
        return ERROR_SUCCESS;

    if(dwLastError == ERROR_SUCCESS)
        dwLastError = ERROR_INVALID_PARAMETER;

    return dwLastError;
}


BOOL
GetMasterKeyByGuid(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
    IN      PSID    pSid,
    IN      BOOL    fMigrate,
    IN      GUID *pguidMasterKey,
        OUT LPBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey,
        OUT DWORD *pdwMasterKeyDisposition  // refer to MK_DISP_ constants
    )
{
    WCHAR wszguidMasterKey[MAX_GUID_SZ_CHARS];

    *pdwMasterKeyDisposition = MK_DISP_UNKNOWN_ERR;

    if( MyGuidToStringW( pguidMasterKey, wszguidMasterKey ) != 0 )
        return FALSE;

    return GetMasterKey(
                pvContext,
                szUserStorageArea,
                pSid,
                fMigrate,
                wszguidMasterKey,
                ppbMasterKey,
                pcbMasterKey,
                pdwMasterKeyDisposition
                );
}

BOOL
GetMasterKey(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
    IN      PSID    pSid,
    IN      BOOL    fMigrate,
    IN      WCHAR wszMasterKey[MAX_GUID_SZ_CHARS],
        OUT LPBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey,
        OUT DWORD *pdwMasterKeyDisposition
    )
{
    MASTERKEY_STORED hMasterKey;
    DWORD cbFilePath;
    BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN];  // masterkey encryption key
    DWORD dwLastError = (DWORD)NTE_BAD_KEY;
    BOOL fUserCredentialValid;
    BOOL fSuccess = FALSE;
    BOOL fUpgradeEncryption = FALSE;
    LPWSTR wszOldFilePath = NULL;
    GUID CredentialID;

    D_DebugLog((DEB_TRACE_API, "GetMasterKey: %ls\n", wszMasterKey));

    *pdwMasterKeyDisposition = MK_DISP_UNKNOWN_ERR;

    ZeroMemory( &hMasterKey, sizeof(hMasterKey) );

    hMasterKey.fModified = FALSE;

    //
    // copy path to key file into masterkey memory block.
    //

    cbFilePath = (lstrlenW( szUserStorageArea ) + 1) * sizeof(WCHAR);
    hMasterKey.szFilePath = (LPWSTR)SSAlloc( cbFilePath );
    if(hMasterKey.szFilePath == NULL) 
    {
        SetLastError( ERROR_NOT_ENOUGH_SERVER_MEMORY );
        return FALSE;
    }

    CopyMemory(hMasterKey.szFilePath, szUserStorageArea, cbFilePath);
    CopyMemory(hMasterKey.wszguidMasterKey, wszMasterKey, sizeof(hMasterKey.wszguidMasterKey));

    //
    // read the masterkey components into memory.
    //

    if(!ReadMasterKey( pvContext, &hMasterKey )) 
    {
        D_DebugLog((DEB_WARN, "ReadMasterKey failed: 0x%x\n", GetLastError()));
        SetLastError( (DWORD)NTE_BAD_KEY );
        *pdwMasterKeyDisposition = MK_DISP_STORAGE_ERR;
        return FALSE;
    }

    //
    // get current masterkey encryption key.
    //

    ZeroMemory(&CredentialID, sizeof(CredentialID));

    fUserCredentialValid = GetMasterKeyUserEncryptionKey(pvContext,
                                                         &CredentialID,
                                                         pSid,
                                                         USE_ROOT_CREDENTIAL | 
                                                            ((hMasterKey.dwPolicy & POLICY_DPAPI_OWF)?USE_DPAPI_OWF:0),
                                                         rgbMKEncryptionKey);

    if( fUserCredentialValid ) 
    {

        //
        // retrieve and decrypt MK with current credential.
        // if success, see if pending phase one/two backup required [make it so]
        //

        #ifdef COMPILED_BY_DEVELOPER
        D_DebugLog((DEB_TRACE, "MK decryption key:\n"));
        D_DPAPIDumpHexData(DEB_TRACE, "  ", rgbMKEncryptionKey, sizeof(rgbMKEncryptionKey));
        #endif

        dwLastError = DecryptMasterKeyFromStorage(
                            &hMasterKey,
                            REGVAL_MASTER_KEY,
                            rgbMKEncryptionKey,
                            &fUpgradeEncryption,
                            ppbMasterKey,
                            pcbMasterKey
                            );

        #if DBG
            if(dwLastError == ERROR_SUCCESS)
            {
                #ifdef COMPILED_BY_DEVELOPER
                D_DebugLog((DEB_TRACE, "Master key:\n"));
                D_DPAPIDumpHexData(DEB_TRACE, "  ", *ppbMasterKey, *pcbMasterKey);
                #endif
            }
            else
            {
                D_DebugLog((DEB_WARN, "Decryption with current user MK failed\n"));
            }
        #endif
    }
    else
    {
        D_DebugLog((DEB_WARN, "GetMasterKeyUserEncryptionKey failed: 0x%x\n", GetLastError()));
    }

    if( fUpgradeEncryption || fMigrate || (dwLastError != ERROR_SUCCESS )) 
    {

        //
        // if the MK fails to decrypt, attempt recovery.
        //  if recovery succeeds, re-encrypt MK with current credential.
        //

        if(dwLastError != ERROR_SUCCESS)
        {


            dwLastError = RestoreMasterKey(
                                pvContext,
                                pSid,
                                &hMasterKey,
                                dwLastError,
                                ppbMasterKey,
                                pcbMasterKey
                                );

            fUpgradeEncryption = TRUE;
        }



        //
        // If this is a migration, we must get the current real user storage
        // area, not the one that the key was retrieved from.
        //

        if((ERROR_SUCCESS == dwLastError) &&
           (fMigrate))
        {
            wszOldFilePath = hMasterKey.szFilePath;
            hMasterKey.szFilePath = NULL;

            dwLastError = CPSGetUserStorageArea( pvContext, 
                                              NULL, 
                                              FALSE, 
                                              &hMasterKey.szFilePath );
        }

        //
        // recovery succeeded, re-encrypt the masterkey if the user credential
        // is valid.
        // Also re-encrypt if fUpgradeEncryption indicates that we're 
        // not meeting current policy with this master key.
        //

        if( fUpgradeEncryption && (dwLastError == ERROR_SUCCESS )) 
        {

            if( fUserCredentialValid ) 
            {
                D_DebugLog((DEB_TRACE, "Update master key encryption.\n"));

                dwLastError = EncryptMasterKeyToStorage(
                                        &hMasterKey,
                                        REGVAL_MASTER_KEY,
                                        rgbMKEncryptionKey,
                                        *ppbMasterKey,
                                        *pcbMasterKey
                                        );
                
                if(dwLastError != ERROR_SUCCESS)
                {
                    D_DebugLog((DEB_WARN, "Error encrypting master key!\n"));
                }


                // Update the local backup information
                if(dwLastError == ERROR_SUCCESS)
                {
                    LOCAL_BACKUP_DATA LocalBackupData;

                    if(hMasterKey.pbBK != NULL && hMasterKey.cbBK >= sizeof(LocalBackupData))
                    {
                        CopyMemory(&LocalBackupData, hMasterKey.pbBK, sizeof(LocalBackupData));

                        if(LocalBackupData.dwVersion == MASTERKEY_BLOB_LOCALKEY_BACKUP)
                        {
                            #ifdef COMPILED_BY_DEVELOPER
                            D_DebugLog((DEB_TRACE, "New MK encryption key GUID:\n"));
                            D_DPAPIDumpHexData(DEB_TRACE, "  ", (PBYTE)&LocalBackupData.CredentialID, sizeof(LocalBackupData.CredentialID));
                            #endif

                            CopyMemory(&LocalBackupData.CredentialID, &CredentialID, sizeof(CredentialID));

                            PersistMasterKeyToStorage(
                                        &hMasterKey,
                                        REGVAL_BACKUP_LCL_KEY,
                                        (PBYTE)&LocalBackupData,
                                        sizeof(LocalBackupData)
                                        );
                        }
                    }
                }
            }
        }
        
        if(ERROR_SUCCESS != dwLastError)
        {

            //
            // treat recovery failure as storage error so that a new key can
            // be created for Protect operations.
            //
            if(dwLastError == SEC_E_DELEGATION_REQUIRED)
            {
                *pdwMasterKeyDisposition = MK_DISP_DELEGATION_ERR;
            }
            else
            {
                *pdwMasterKeyDisposition = MK_DISP_STORAGE_ERR;
            }
        }
    }



    if( dwLastError == ERROR_SUCCESS ) 
    {

        //
        // after access, do backup if necessary.
        // we check this each access to see if deferred backup required.
        // (note: employ a back-off interval so we don't bang the network
        // constantly when it isn't around).
        //

        BOOL fPhaseTwo;

        if(fUserCredentialValid && IsBackupMasterKeyRequired( &hMasterKey, &fPhaseTwo )) 
        {
            if(BackupMasterKey(
                            pvContext,
                            &hMasterKey,
                            *ppbMasterKey,
                            *pcbMasterKey,
                            fPhaseTwo,  // phase two backup required?
                            TRUE        // always asynchronous during key retrieve
                            ) == ERROR_SUCCESS) 
            {

                if(fPhaseTwo)
                    *pdwMasterKeyDisposition = MK_DISP_BCK_DC;
                else
                    *pdwMasterKeyDisposition = MK_DISP_BCK_LCL;
            }
        }

        if( *pdwMasterKeyDisposition == MK_DISP_UNKNOWN_ERR )
        {
            *pdwMasterKeyDisposition = MK_DISP_OK;
        }

        fSuccess = TRUE;
    }

    if(!CloseMasterKey(pvContext, &hMasterKey, fSuccess))
    {
        fSuccess = FALSE;
    }

    if(fSuccess && (NULL != wszOldFilePath))
    {
        LPWSTR wszDeleteFilePath = NULL;
        // Delete the old key, now that the new one has been migrated.

        wszDeleteFilePath = (LPWSTR)SSAlloc((wcslen(wszOldFilePath) +
                                    wcslen(wszMasterKey) +
                                    2) * sizeof(WCHAR));
        if(NULL != wszDeleteFilePath)
        {
            wcscpy(wszDeleteFilePath, wszOldFilePath);
            wcscat(wszDeleteFilePath, L"\\");
            wcscat(wszDeleteFilePath, wszMasterKey);

            DeleteFile(wszDeleteFilePath);
            SSFree(wszDeleteFilePath);
        }
    }
    return fSuccess;
}

BOOL
GetMasterKeyUserEncryptionKey(
    IN      PVOID   pvContext,
    IN      GUID    *pCredentialID,
    IN      PSID    pSid,
    IN      DWORD   dwFlags,
    IN  OUT BYTE    rgbMKEncryptionKey[A_SHA_DIGEST_LEN]
    )
/*++

    This routine gets the key used to encrypt and decrypt the persisted
    master key MK.  This routine returns a copy of a function of the per-user
    logon credential used during Windows NT logon.

    If the function succeeds, the return value is TRUE, and the buffer
    specified with by the rgbMKEncryptionKey parameter is filled with the
    masterkey encryption key.

    The return value is FALSE if the encryption key could not be obtained.

--*/
{
    BOOL fLocalMachine = FALSE;
    LPWSTR szUserName = NULL;
    DWORD cchUserName;
    DWORD dwLastError;
    BOOL fSystemCred = FALSE;
    BOOL fSuccess = TRUE;


    //
    // see if the call is for shared, CRYPT_PROTECT_LOCAL_MACHINE
    // disposition.
    //

    CPSOverrideToLocalSystem(
                pvContext,
                NULL,       // don't change current over-ride BOOL
                &fLocalMachine
                );


    //
    // if the context specified per-machine, we know that it's a system credential.
    // also, we don't need to get the user name in this scenario.
    //

    fSystemCred = fLocalMachine;

    if( !fLocalMachine ) 
    {

        if(pSid)
        {
            WCHAR wszTextualSid[MAX_PATH+1];
            cchUserName = MAX_PATH+1;
            if(!GetTextualSid(pSid, wszTextualSid, &cchUserName))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            szUserName = (LPWSTR)SSAlloc(cchUserName*sizeof(WCHAR));
            if(NULL == szUserName)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
            wcscpy(szUserName, wszTextualSid);
            cchUserName = wcslen(szUserName) + 1;
        }
        else
        {
            //
            // use the user name (actually Sid), as the mixing bytes.
            //

            dwLastError = CPSGetUserName(
                                                    pvContext,
                                                    &szUserName,
                                                    &cchUserName
                                                    );

            if( dwLastError != ERROR_SUCCESS ) {
                SetLastError( dwLastError );
                return FALSE;
            }
        }

        //
        // see if the user name is the system account; if so, it's a system
        // credential.
        //

        if(lstrcmpW(szUserName, TEXTUAL_SID_LOCAL_SYSTEM) == 0)
            fSystemCred = TRUE;
    }


    //
    // pickup credential for the local system account.
    //

    if( fSystemCred ) {

        dwLastError = CPSGetSystemCredential(
                                        pvContext,
                                        fLocalMachine,
                                        rgbMKEncryptionKey
                                        );
        if(pCredentialID)
        {
            ZeroMemory(pCredentialID, sizeof(GUID));
        }

    } else {

        dwLastError = CPSGetDerivedCredential(
                                        pvContext,
                                        pCredentialID,
                                        dwFlags,
                                        (PBYTE)szUserName,
                                        cchUserName * sizeof(WCHAR),
                                        rgbMKEncryptionKey
                                        );
    }

    if( szUserName )
        SSFree( szUserName );

    if( dwLastError != ERROR_SUCCESS ) {
        SetLastError( dwLastError );
        fSuccess = FALSE;
    }

    return fSuccess;
}

BOOL
GetLocalKeyUserEncryptionKey(
    IN      PVOID pvContext,
    IN      PMASTERKEY_STORED phMasterKey,
    IN  OUT BYTE rgbLKEncryptionKey[A_SHA_DIGEST_LEN]
    )
/*++

    This routine gets the key used to encrypt and decrypt the persisted
    local key MK.  This routine returns a copy of a function of the per-user
    logon name or Sid.  This is a fixed, derivable key which is required in
    order to satisfy minimal stand-alone entropy.

    If the function succeeds, the return value is TRUE, and the buffer
    specified with by the rgbLKEncryptionKey parameter is filled with the
    masterkey encryption key.

    The return value is FALSE if the encryption key could not be obtained.

--*/
{
    A_SHA_CTX shaContext;
    LPWSTR wszUserName;
    DWORD cchUserName;  // includes terminal NULL
    BOOL fSuccess = TRUE;

    if( CPSGetUserName(
                            pvContext,
                            &wszUserName,
                            &cchUserName
                            ) != ERROR_SUCCESS) {
        return FALSE;
    }

    A_SHAInit( &shaContext );
    A_SHAUpdate( &shaContext, (PBYTE)wszUserName, cchUserName * sizeof(WCHAR) );


    //
    // if it's above version 1, and it's local only policy, mix in LSA keys.
    //

    if( phMasterKey->dwVersion > 1 && phMasterKey->dwPolicy & POLICY_LOCAL_BACKUP ) {
        BYTE rgbEncryptionKey[ A_SHA_DIGEST_LEN ];
        DWORD dwLastError;

        dwLastError = CPSGetSystemCredential(
                                        pvContext,
                                        TRUE,
                                        rgbEncryptionKey
                                        );

        if( dwLastError == ERROR_SUCCESS ) {

            A_SHAUpdate( &shaContext, rgbEncryptionKey, sizeof(rgbEncryptionKey) );

            dwLastError = CPSGetSystemCredential(
                                            pvContext,
                                            FALSE,
                                            rgbEncryptionKey
                                            );

            A_SHAUpdate( &shaContext, rgbEncryptionKey, sizeof(rgbEncryptionKey) );

        }

        ZeroMemory( rgbEncryptionKey, sizeof(rgbEncryptionKey) );

        if( dwLastError != ERROR_SUCCESS )
            fSuccess = FALSE;
    }


    A_SHAFinal( &shaContext, rgbLKEncryptionKey );

    SSFree(wszUserName);

    return fSuccess;
}

DWORD
DecryptMasterKeyToMemory(
    IN      BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN],
    IN      PBYTE pbMasterKeyIn,
    IN      DWORD cbMasterKeyIn,
        OUT BOOL *pfUpgradeEncryption, 
        OUT PBYTE *ppbMasterKeyOut,
        OUT DWORD *pcbMasterKeyOut
    )
{
    PMASTERKEY_BLOB pMasterKeyBlob;
    DWORD cbMasterKeyBlob = cbMasterKeyIn;
    PMASTERKEY_INNER_BLOB pMasterKeyInnerBlob;
    DWORD cIterationCount = 0;
    DWORD cbMasterKeyBlobHeader;

    PBYTE pbMasterKey;
    DWORD cbMasterKey;
    ALG_ID EncryptionAlg = CALG_RC4;
    ALG_ID PKCS5Alg      = CALG_HMAC;


    BYTE rgbSymKey[A_SHA_DIGEST_LEN*2]; // big enough to handle 3des keys
    BYTE rgbMacKey[A_SHA_DIGEST_LEN];
    BYTE rgbMacCandidate[A_SHA_DIGEST_LEN];

    DWORD dwLastError = (DWORD)NTE_BAD_KEY;
    DWORD KeyBlocks = 1;

    if(pfUpgradeEncryption)
    {
        *pfUpgradeEncryption = FALSE;
    }
    //
    // Alloc, so we do not modify passed in data
    //
    pMasterKeyBlob = (PMASTERKEY_BLOB)SSAlloc( cbMasterKeyBlob );
    if(pMasterKeyBlob == NULL)
        return (DWORD)NTE_BAD_KEY;

    CopyMemory( pMasterKeyBlob, pbMasterKeyIn, cbMasterKeyBlob );


    if(pMasterKeyBlob->dwVersion > MASTERKEY_BLOB_VERSION)
        goto cleanup;

    if(MASTERKEY_BLOB_VERSION_W2K == pMasterKeyBlob->dwVersion)
    {
        pMasterKeyInnerBlob = 
            (PMASTERKEY_INNER_BLOB)(((PMASTERKEY_BLOB_W2K)pMasterKeyBlob) + 1);
        cIterationCount = 0;
        cbMasterKeyBlobHeader = sizeof(MASTERKEY_BLOB_W2K);
    }
    else
    {
        pMasterKeyInnerBlob = (PMASTERKEY_INNER_BLOB)(pMasterKeyBlob + 1);
        cIterationCount = pMasterKeyBlob->IterationCount;
        cbMasterKeyBlobHeader = sizeof(MASTERKEY_BLOB);
        PKCS5Alg = (ALG_ID)pMasterKeyBlob->KEYGENAlg;
        EncryptionAlg = (ALG_ID)pMasterKeyBlob->EncryptionAlg;
        if(CALG_3DES == EncryptionAlg)
        {
            KeyBlocks = 2;  // enough blocks for 3des
        }
        else
        {
            KeyBlocks = 1;
        }
    }
    if(pfUpgradeEncryption)
    {
        if(!FIsLegacyCompliant())
        {
            // 
            // If we're not in legacy mode, upgrade the master key encryption
            // if we're not using CALG_3DES or enough iterations
            if((cIterationCount < GetIterationCount()) ||
                (CALG_3DES != EncryptionAlg))
            {
                *pfUpgradeEncryption = TRUE;
            }
        }
    }



    if(cIterationCount)
    {
        DWORD j;
        
        //
        // derive symetric key via rgbMKEncryptionKey and random R2
        // using PKCS#5 keying function PBKDF2
        //

        for(j=0; j < KeyBlocks; j++)
        {
            if(!PKCS5DervivePBKDF2( rgbMKEncryptionKey,
                                A_SHA_DIGEST_LEN,
                                pMasterKeyBlob->R2,
                                MASTERKEY_R2_LEN,
                                PKCS5Alg,
                                cIterationCount,
                                j+1,
                                rgbSymKey + j*A_SHA_DIGEST_LEN))
                goto cleanup;
        }

    }
    else
    {
        //
        // derive symetric key via rgbMKEncryptionKey and random R2
        // using the weak W2K mechanism
        //

        if(!FMyPrimitiveHMACParam(
                        rgbMKEncryptionKey,
                        A_SHA_DIGEST_LEN,
                        pMasterKeyBlob->R2,
                        MASTERKEY_R2_LEN,
                        rgbSymKey
                        ))
                goto cleanup;
    }




    //
    // decrypt data R3, MAC, pbMasterKey beyond masterkey blob
    //

    if(CALG_RC4 == EncryptionAlg)
    {

        RC4_KEYSTRUCT sRC4Key;        //
        // initialize rc4 key
        //

        rc4_key(&sRC4Key, A_SHA_DIGEST_LEN, rgbSymKey);

        rc4(&sRC4Key, 
            cbMasterKeyBlob - cbMasterKeyBlobHeader, 
            (PBYTE)pMasterKeyInnerBlob);
    }
    else if (CALG_3DES == EncryptionAlg)
    {

        DES3TABLE s3DESKey;
        BYTE InputBlock[DES_BLOCKLEN];
        DWORD iBlock;
        DWORD cBlocks = (cbMasterKeyBlob - cbMasterKeyBlobHeader)/DES_BLOCKLEN;
        BYTE feedback[ DES_BLOCKLEN ];
        // initialize 3des key
        //

        if(cBlocks*DES_BLOCKLEN != (cbMasterKeyBlob - cbMasterKeyBlobHeader))
        {
            // Master key must be a multiple of DES_BLOCKLEN
            return (DWORD)NTE_BAD_KEY;
        }
        tripledes3key(&s3DESKey, rgbSymKey);

        //
        // IV is derived from the DES_BLOCKLEN bytes of the calculated 
        // rgbSymKey, after the 3des key
        CopyMemory(feedback, rgbSymKey + DES3_KEYSIZE, DES_BLOCKLEN);

        for(iBlock=0; iBlock < cBlocks; iBlock++)
        {
            CopyMemory(InputBlock, 
                       ((PBYTE)pMasterKeyInnerBlob)+iBlock*DES_BLOCKLEN,
                       DES_BLOCKLEN);
            CBC(tripledes,
                DES_BLOCKLEN,
                ((PBYTE)pMasterKeyInnerBlob)+iBlock*DES_BLOCKLEN,
                InputBlock,
                &s3DESKey,
                DECRYPT,
                feedback);
        }
    }
    else
    {
        // Unknown cipher....
        return (DWORD)NTE_BAD_KEY;
    }
    //
    // adjust cipher start point to include R3 and MAC.
    //
    if(MASTERKEY_BLOB_VERSION_W2K == pMasterKeyBlob->dwVersion)
    {
        pbMasterKey = 
            (PBYTE)(((PMASTERKEY_INNER_BLOB_W2K)pMasterKeyInnerBlob) + 1);
        cbMasterKey = cbMasterKeyBlob - cbMasterKeyBlobHeader - sizeof(MASTERKEY_INNER_BLOB_W2K);

    }
    else
    {
        pbMasterKey = (PBYTE)(pMasterKeyInnerBlob + 1);
        cbMasterKey = cbMasterKeyBlob - cbMasterKeyBlobHeader - sizeof(MASTERKEY_INNER_BLOB);
    }

    //
    // derive MAC key via HMAC from rgbMKEncryptionKey and random R3.
    //


    
    if(!FMyPrimitiveHMACParam(
                    rgbMKEncryptionKey,
                    A_SHA_DIGEST_LEN,
                    pMasterKeyInnerBlob->R3,
                    MASTERKEY_R3_LEN,
                    rgbMacKey
                    ))
    {
        goto cleanup;
    }







    //
    // use MAC key to derive result from pbMasterKey
    //

    if(!FMyPrimitiveHMACParam(
            rgbMacKey,
            sizeof(rgbMacKey),
            pbMasterKey,
            cbMasterKey,
            rgbMacCandidate // resultant MAC for verification.
            ))
        goto cleanup;

    //
    // verify MAC equality
    //

    if(memcmp(pMasterKeyInnerBlob->MAC, rgbMacCandidate, A_SHA_DIGEST_LEN) != 0)
        goto cleanup;

    //
    // give caller results.
    //

    *ppbMasterKeyOut = (LPBYTE)SSAlloc( cbMasterKey );
    if(*ppbMasterKeyOut == NULL) {
        dwLastError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto cleanup;
    }

    CopyMemory(*ppbMasterKeyOut, pbMasterKey, cbMasterKey);
    *pcbMasterKeyOut = cbMasterKey;

    dwLastError = ERROR_SUCCESS;

cleanup:

    if(pMasterKeyBlob) {
        ZeroMemory(pMasterKeyBlob, cbMasterKeyBlob);
        SSFree( pMasterKeyBlob );
    }

    return dwLastError;
}

DWORD
DecryptMasterKeyFromStorage(
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD dwMKLoc,
    IN      BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN],
        OUT BOOL  *pfUpgradeEncryption,
        OUT PBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey
    )
{
    PBYTE pbRegData;
    DWORD cbRegData;

    //
    // fetch blob from storage.
    //

    switch( dwMKLoc ) {
        case REGVAL_MASTER_KEY:
            pbRegData = phMasterKey->pbMK;
            cbRegData = phMasterKey->cbMK;
            break;
        case REGVAL_LOCAL_KEY:
            pbRegData = phMasterKey->pbLK;
            cbRegData = phMasterKey->cbLK;
            break;
        case REGVAL_BACKUP_LCL_KEY:
            pbRegData = phMasterKey->pbBK;
            cbRegData = phMasterKey->cbBK;
            break;
        case REGVAL_BACKUP_DC_KEY:
            pbRegData = phMasterKey->pbBBK;
            cbRegData = phMasterKey->cbBBK;
            break;

        default:
            return NTE_BAD_KEY;
    }

    if( cbRegData == 0 || pbRegData == NULL )
        return (DWORD)NTE_BAD_KEY;


    return DecryptMasterKeyToMemory(
                        rgbMKEncryptionKey,
                        pbRegData,
                        cbRegData,
                        pfUpgradeEncryption, 
                        ppbMasterKey,
                        pcbMasterKey
                        );
}


DWORD
EncryptMasterKeyToStorage(
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD dwMKLoc,
    IN      BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN],
    IN      PBYTE pbMasterKey,
    IN      DWORD cbMasterKey
    )
/*++

    Encrypt the pbMasterKey using rgbMKEncryptionKey, storing (persisting) the
    result to the registry key and location specified by hMasterKey, wszMKLoc.

--*/
{
    PBYTE pbMasterKeyOut = NULL;
    DWORD cbMasterKeyOut;
    DWORD dwLastError;
    DWORD dwIterationCount = 1;

    D_DebugLog((DEB_TRACE_API, "EncryptMasterKeyToStorage\n"));

    if(dwMKLoc == REGVAL_MASTER_KEY)
    {
        dwIterationCount = GetIterationCount();
    }

    dwLastError = EncryptMasterKeyToMemory(
                    rgbMKEncryptionKey,
                    dwIterationCount,
                    pbMasterKey,
                    cbMasterKey,
                    &pbMasterKeyOut,
                    &cbMasterKeyOut
                    );

    if(dwLastError != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    dwLastError = PersistMasterKeyToStorage(
                    phMasterKey,
                    dwMKLoc,
                    pbMasterKeyOut,
                    cbMasterKeyOut
                    );

    if( pbMasterKeyOut ) {
        ZeroMemory(pbMasterKeyOut, cbMasterKeyOut);
        SSFree(pbMasterKeyOut);
    }

cleanup:

    D_DebugLog((DEB_TRACE_API, "EncryptMasterKeyToStorage returned 0x%x\n", dwLastError));

    return dwLastError;
}

DWORD
PersistMasterKeyToStorage(
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD dwMKLoc,
    IN      PBYTE pbMasterKeyOut,
    IN      DWORD cbMasterKeyOut
    )
/*++

    Persist the specified key output material to storage.

--*/
{
    PBYTE *ppbData;
    DWORD *pcbData;

    //
    // fetch blob from storage.
    //

    switch( dwMKLoc ) {
        case REGVAL_MASTER_KEY:
            ppbData = &(phMasterKey->pbMK);
            pcbData = &(phMasterKey->cbMK);
            break;
        case REGVAL_LOCAL_KEY:
            ppbData = &(phMasterKey->pbLK);
            pcbData = &(phMasterKey->cbLK);
            break;
        case REGVAL_BACKUP_LCL_KEY:
            ppbData = &(phMasterKey->pbBK);
            pcbData = &(phMasterKey->cbBK);
            break;
        case REGVAL_BACKUP_DC_KEY:
            ppbData = &(phMasterKey->pbBBK);
            pcbData = &(phMasterKey->cbBBK);
            break;

        default:
            return NTE_BAD_KEY;
    }


    if( pbMasterKeyOut == NULL && cbMasterKeyOut == 0 ) {

        //
        // discard existing block if present.
        //

        if( *ppbData ) {
            ZeroMemory( *ppbData, *pcbData );
            SSFree( *ppbData );
        }

        *ppbData = NULL;
        *pcbData = 0;

        return ERROR_SUCCESS;
    }


    //
    // free the in-memory buffer associated with this data block if one
    // was allocated previously.
    //

    if( *ppbData ) {
        ZeroMemory( *ppbData, *pcbData );

        if( *pcbData < cbMasterKeyOut ) {
            SSFree( *ppbData );
            *ppbData = (LPBYTE)SSAlloc( cbMasterKeyOut );
        }

    } else {
        *ppbData = (LPBYTE)SSAlloc( cbMasterKeyOut );
    }

    *pcbData = 0;

    if( *ppbData == NULL )
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;


    *pcbData = cbMasterKeyOut ;
    CopyMemory( *ppbData, pbMasterKeyOut, cbMasterKeyOut );

    //
    // a change occured in the master key.
    //

    phMasterKey->fModified = TRUE;

    return ERROR_SUCCESS;
}

DWORD
QueryMasterKeyFromStorage(
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD dwMKLoc,
    IN  OUT PBYTE *ppbMasterKeyOut,
    IN  OUT DWORD *pcbMasterKeyOut
    )
/*++

    Query raw masterkey material from storage, returning a pointer to the
    requested element for the caller.

    On Success, the return value is ERROR_SUCCESS.

--*/
{
    PBYTE pbData;
    DWORD cbData;

    //
    // fetch blob from storage.
    //

    switch( dwMKLoc ) {
        case REGVAL_MASTER_KEY:
            pbData = phMasterKey->pbMK;
            cbData = phMasterKey->cbMK;
            break;
        case REGVAL_LOCAL_KEY:
            pbData = phMasterKey->pbLK;
            cbData = phMasterKey->cbLK;
            break;
        case REGVAL_BACKUP_LCL_KEY:
            pbData = phMasterKey->pbBK;
            cbData = phMasterKey->cbBK;
            break;
        case REGVAL_BACKUP_DC_KEY:
            pbData = phMasterKey->pbBBK;
            cbData = phMasterKey->cbBBK;
            break;

        default:
            return (DWORD)NTE_BAD_KEY;
    }


    if(cbData == 0 || pbData == NULL)
        return (DWORD)NTE_BAD_KEY;

    *ppbMasterKeyOut = pbData;
    *pcbMasterKeyOut = cbData;

    return ERROR_SUCCESS;
}

DWORD
EncryptMasterKeyToMemory(
    IN      BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN],
    IN      DWORD cIterationCount,
    IN      PBYTE pbMasterKey,
    IN      DWORD cbMasterKey,
        OUT PBYTE *ppbMasterKeyOut,
        OUT DWORD *pcbMasterKeyOut
    )
{
    PMASTERKEY_BLOB pMasterKeyBlob;
    DWORD cbMasterKeyBlob;
    DWORD cbMasterInnerKeyBlob;
    PMASTERKEY_INNER_BLOB pMasterKeyInnerBlob;
    PBYTE pbCipherBegin;

    BYTE rgbMacKey[A_SHA_DIGEST_LEN];

    DWORD dwLastError = (DWORD)NTE_BAD_KEY;

    BOOL  fLegacyBlob = (FIsLegacyCompliant() || (0 == cIterationCount));

    ALG_ID EncryptionAlg = CALG_3DES;
    ALG_ID PKCS5Alg      = CALG_HMAC;


    BYTE rgbSymKey[A_SHA_DIGEST_LEN*2]; // big enough to handle 3des keys

    DWORD KeyBlocks = 1;




    if(!fLegacyBlob)
    {

        cbMasterInnerKeyBlob = sizeof(MASTERKEY_INNER_BLOB) +
                        cbMasterKey ;

        cbMasterKeyBlob = sizeof(MASTERKEY_BLOB) +
                        cbMasterInnerKeyBlob;
    }
    else
    {

        EncryptionAlg = CALG_RC4;

        cbMasterInnerKeyBlob = sizeof(MASTERKEY_INNER_BLOB_W2K) +
                        cbMasterKey ;

        cbMasterKeyBlob = sizeof(MASTERKEY_BLOB_W2K) +
                        cbMasterInnerKeyBlob;

    }

    if(CALG_3DES == EncryptionAlg)
    {
        KeyBlocks = 2;

        if(cbMasterInnerKeyBlob%DES_BLOCKLEN)
        {
            return NTE_BAD_KEY;
        }
    }

    pMasterKeyBlob = (PMASTERKEY_BLOB)SSAlloc( cbMasterKeyBlob );
    if(pMasterKeyBlob == NULL)
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;

    if(!fLegacyBlob)
    {
        pMasterKeyBlob->dwVersion = MASTERKEY_BLOB_VERSION;
        pMasterKeyInnerBlob = (PMASTERKEY_INNER_BLOB)(pMasterKeyBlob + 1);
    }
    else
    {
        pMasterKeyBlob->dwVersion = MASTERKEY_BLOB_VERSION_W2K;
        pMasterKeyInnerBlob = 
            (PMASTERKEY_INNER_BLOB)(((PMASTERKEY_BLOB_W2K)pMasterKeyBlob) + 1);
    }


    //
    // generate random R2 for SymKey
    //

    if(!RtlGenRandom(pMasterKeyBlob->R2, MASTERKEY_R2_LEN))
        goto cleanup;

    //
    // generate random R3 for MAC
    //

    if(!RtlGenRandom(pMasterKeyInnerBlob->R3, MASTERKEY_R3_LEN))
        goto cleanup;


    if(!fLegacyBlob)
    {
        DWORD j;
        //
        // derive symetric key via rgbMKEncryptionKey and random R2
        //

        for(j=0; j < KeyBlocks; j++)
        {
            if(!PKCS5DervivePBKDF2(
                            rgbMKEncryptionKey,
                            A_SHA_DIGEST_LEN,
                            pMasterKeyBlob->R2,
                            MASTERKEY_R2_LEN,
                            PKCS5Alg,
                            cIterationCount,
                            j+1,
                            rgbSymKey+j*A_SHA_DIGEST_LEN
                            ))
                goto cleanup;
        }
        pMasterKeyBlob->IterationCount = cIterationCount;
        pMasterKeyBlob->EncryptionAlg = EncryptionAlg;
        pMasterKeyBlob->KEYGENAlg = PKCS5Alg;

        pbCipherBegin = (PBYTE)(pMasterKeyInnerBlob+1);

    }
    else
    {
        //
        // derive symetric key via rgbMKEncryptionKey and random R2
        //

        if(!FMyPrimitiveHMACParam(
                        rgbMKEncryptionKey,
                        A_SHA_DIGEST_LEN,
                        pMasterKeyBlob->R2,
                        MASTERKEY_R2_LEN,
                        rgbSymKey
                        ))
            goto cleanup;

        pbCipherBegin = (PBYTE)(((PMASTERKEY_INNER_BLOB_W2K)pMasterKeyInnerBlob)+1);

    }

    //
    // derive MAC key via HMAC from rgbMKEncryptionKey and random R3.
    //

    if(!FMyPrimitiveHMACParam(
                    rgbMKEncryptionKey,
                    A_SHA_DIGEST_LEN,
                    pMasterKeyInnerBlob->R3,
                    MASTERKEY_R3_LEN,
                    rgbMacKey   // resultant MAC key
                    ))
    {
        goto cleanup;
    }
    

    //
    // copy pbMasterKey following inner MAC'ish blob.
    //


    CopyMemory( pbCipherBegin, pbMasterKey, cbMasterKey );

    //
    // use MAC key to derive result from pbMasterKey
    //

    if(!FMyPrimitiveHMACParam(
                    rgbMacKey,
                    sizeof(rgbMacKey),
                    pbMasterKey,
                    cbMasterKey,
                    pMasterKeyInnerBlob->MAC // resultant MAC for verification.
                    ))
        goto cleanup;



    if(CALG_RC4 == EncryptionAlg)
    {

        RC4_KEYSTRUCT sRC4Key;        //
        // initialize rc4 key
        //

        rc4_key(&sRC4Key, A_SHA_DIGEST_LEN, rgbSymKey);

        rc4(&sRC4Key, 
            cbMasterInnerKeyBlob, 
            (PBYTE)pMasterKeyInnerBlob);
    }
    else if (CALG_3DES == EncryptionAlg)
    {

        DES3TABLE s3DESKey;
        BYTE InputBlock[DES_BLOCKLEN];
        DWORD iBlock;
        DWORD cBlocks = cbMasterInnerKeyBlob/DES_BLOCKLEN;
        BYTE feedback[ DES_BLOCKLEN ];
        // initialize 3des key
        //

        if(cBlocks*DES_BLOCKLEN != cbMasterInnerKeyBlob)
        {
            // Master key must be a multiple of DES_BLOCKLEN
            return (DWORD)NTE_BAD_KEY;
        }
        tripledes3key(&s3DESKey, rgbSymKey);

        //
        // IV is derived from the DES_BLOCKLEN bytes of the calculated 
        // rgbSymKey, after the 3des key
        CopyMemory(feedback, rgbSymKey + DES3_KEYSIZE, DES_BLOCKLEN);


        for(iBlock=0; iBlock < cBlocks; iBlock++)
        {
            CopyMemory(InputBlock, 
                       ((PBYTE)pMasterKeyInnerBlob)+iBlock*DES_BLOCKLEN,
                       DES_BLOCKLEN);
            CBC(tripledes,
                DES_BLOCKLEN,
                ((PBYTE)pMasterKeyInnerBlob)+iBlock*DES_BLOCKLEN,
                InputBlock,
                &s3DESKey,
                ENCRYPT,
                feedback);
        }
    }
    else
    {
        // Unknown cipher....
        return (DWORD)NTE_BAD_KEY;
    }


    *ppbMasterKeyOut = (PBYTE)pMasterKeyBlob;
    *pcbMasterKeyOut = cbMasterKeyBlob;

    pMasterKeyBlob = NULL; // prevent free of blob on success (caller does it).

    dwLastError = ERROR_SUCCESS;

cleanup:

    if(pMasterKeyBlob) {
        ZeroMemory(pMasterKeyBlob, cbMasterKeyBlob);
        SSFree(pMasterKeyBlob);
    }

    return dwLastError;
}

BOOL
IsBackupMasterKeyRequired(
    IN      PMASTERKEY_STORED phMasterKey,
    IN  OUT BOOL *pfPhaseTwo        // is phase two required?
    )
/*++

    Determine if we need to do a phase one or phase two backup.

    Return value is TRUE if phase one or phase two backup required.
     pfPhaseTwo set TRUE if phase two backup required.

    Return value is FALSE when backup not required.

--*/
{
    DWORD dwMasterKeyPolicy;
    PBYTE pbMasterKeyOut;
    DWORD cbMasterKeyOut;
    DWORD dwLastError;


    dwMasterKeyPolicy = phMasterKey->dwPolicy;

    if(dwMasterKeyPolicy & POLICY_NO_BACKUP)
        return FALSE;

    //
    // For WinNT4 systems, pretend the policy was set to local only backup.
    //

    if( !FIsWinNT5() )
        dwMasterKeyPolicy |= POLICY_LOCAL_BACKUP;

    //
    // evaluate what phase backup required based on policy.
    //

    *pfPhaseTwo = FALSE;

    if(!(dwMasterKeyPolicy & POLICY_LOCAL_BACKUP)) {

        dwLastError = QueryMasterKeyFromStorage(
                            phMasterKey,
                            REGVAL_BACKUP_DC_KEY,
                            &pbMasterKeyOut,
                            &cbMasterKeyOut
                            );


        if(dwLastError != ERROR_SUCCESS) {
            *pfPhaseTwo = TRUE;
            return TRUE;
        }

    } else {

        dwLastError = QueryMasterKeyFromStorage(
                            phMasterKey,
                            REGVAL_BACKUP_LCL_KEY,
                            &pbMasterKeyOut,
                            &cbMasterKeyOut
                            );

        if(dwLastError != ERROR_SUCCESS)
            return TRUE;
    }

    return FALSE;
}


BOOL
IsNT4Domain(void)
{
    NTSTATUS Status;
    LSA_HANDLE PolicyHandle = NULL;
    OBJECT_ATTRIBUTES PolicyObjectAttributes;
    PPOLICY_DNS_DOMAIN_INFO pDnsDomainInfo = NULL;
    BOOL fRet = FALSE;

    InitializeObjectAttributes( &PolicyObjectAttributes,
                                NULL,             // Name
                                0,                // Attributes
                                NULL,             // Root
                                NULL);            // Security Descriptor

    Status = LsaOpenPolicy(NULL,
                           &PolicyObjectAttributes,
                           POLICY_VIEW_LOCAL_INFORMATION,
                           &PolicyHandle);
    if(!NT_SUCCESS(Status))
    {
        goto cleanup;
    }

    Status = LsaQueryInformationPolicy(PolicyHandle,
                                       PolicyDnsDomainInformation,
                                       (PVOID *)&pDnsDomainInfo);
    if(!NT_SUCCESS(Status))
    {
        goto cleanup;
    }

    if((pDnsDomainInfo != NULL) &&
       (pDnsDomainInfo->DnsDomainName.Buffer == NULL))
    {
        fRet = TRUE;
    }


cleanup:

    if(pDnsDomainInfo)
        LsaFreeMemory(pDnsDomainInfo);

    if(PolicyHandle)
        LsaClose(PolicyHandle);

    return fRet;
}


DWORD
BackupMasterKey(
    IN      PVOID pvContext,
    IN      PMASTERKEY_STORED phMasterKey,
    IN      LPBYTE pbMasterKey,
    IN      DWORD cbMasterKey,
    IN      BOOL fPhaseTwo,         // is phase two required?
    IN      BOOL fAsynchronous      // asynchronous call?
    )
{

    BYTE rgbLKEncryptionKey[ A_SHA_DIGEST_LEN ];
    BYTE rgbBKEncryptionKey[ A_SHA_DIGEST_LEN ];

    PBYTE pbLocalKey = NULL;
    DWORD cbLocalKey = 0;

    PBYTE pbBackupKeyPhaseOne = NULL;
    DWORD cbBackupKeyPhaseOne = 0;

    PBYTE pbBackupKeyPhaseTwo = NULL;
    DWORD cbBackupKeyPhaseTwo = 0;


    DWORD dwLastError = (DWORD)NTE_BAD_KEY;


    BOOL  fLegacy = FIsLegacyCompliant();

    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;

    //
    // get current localkey encryption key.
    //

    if(!GetLocalKeyUserEncryptionKey(pvContext, phMasterKey, rgbLKEncryptionKey))
        goto cleanup;

    //
    // retrieve and decrypt LK with current credential.
    //

    dwLastError = DecryptMasterKeyFromStorage(
                        phMasterKey,
                        REGVAL_LOCAL_KEY,
                        rgbLKEncryptionKey,
                        NULL,
                        &pbLocalKey,
                        &cbLocalKey
                        );

    if(dwLastError != ERROR_SUCCESS)
        goto cleanup;


    //
    // Are we running in an NT4 domain? If so, then force legacy mode so that 
    // the master key is backed up using the lsa secret scheme. Otherwise, the
    // master key won't be recoverable following a password change.
    // 

    if(FIsLegacyNt4Domain())
    {
        if(IsNT4Domain())
        {
            D_DebugLog((DEB_WARN,"NT4 domain detected, so force legacy backup mode!\n"));
            fLegacy = TRUE;
        }
    }

    if(fLegacy)
    {
        //
        // derive BK encryption key from decrypted Local Key.
        //

        FMyPrimitiveSHA( pbLocalKey, cbLocalKey, rgbBKEncryptionKey );

        //
        // encrypt masterkey to phase one backup key, using encryption key derived
        // from local key.  do it in memory, such that we only commit it to disk if
        // phase two backup key cannot be generated/persisted.
        //

        dwLastError = EncryptMasterKeyToMemory(
                            rgbBKEncryptionKey,
                            0,
                            pbMasterKey,
                            cbMasterKey,
                            &pbBackupKeyPhaseOne,
                            &cbBackupKeyPhaseOne
                            );

        if(dwLastError != ERROR_SUCCESS)
            goto cleanup;

        // Copy this in directly, so we do not set the modified flag

    }


    


    //
    // attempt phase two backup (if policy permits).
    //

    if( fPhaseTwo ) {
        DWORD dwWaitTimeout;

        dwLastError = ERROR_SUCCESS;

        // 
        // We only attempt a local backup if we
        // have user keying material.  Otherwise,
        // we directly contact the DC
        //
        if(fAsynchronous && (!fLegacy))
        {
            if(ERROR_SUCCESS == dwLastError)
            {

                //
                // Try to do this locally, without going 
                // off machine
                dwLastError = AttemptLocalBackup(
                                                FALSE,
                                                pServerContext->hToken,
                                                phMasterKey,
                                                0,
                                                pbMasterKey,
                                                cbMasterKey,
                                                pbLocalKey,
                                                cbLocalKey,
                                                &pbBackupKeyPhaseTwo,
                                                &cbBackupKeyPhaseTwo
                                                );
            }

            if(ERROR_SUCCESS == dwLastError)
            {
                dwLastError = PersistMasterKeyToStorage(
                                    phMasterKey,
                                    REGVAL_BACKUP_DC_KEY,
                                    pbBackupKeyPhaseTwo,
                                    cbBackupKeyPhaseTwo
                                    );
                if(ERROR_SUCCESS == dwLastError)
                {
                    // Zero out any local backup key that might
                    // be present
                    PersistMasterKeyToStorage(
                                        phMasterKey,
                                        REGVAL_BACKUP_LCL_KEY,
                                        NULL,
                                        0
                                        );

                }

            }
        }



        if(fLegacy || (!fAsynchronous) || (ERROR_SUCCESS != dwLastError))
        {
            // 
            // We couldn't back up locally
            // so we need to go off machine
            //
            if( fAsynchronous )
                dwWaitTimeout = 2000;
            else
                dwWaitTimeout = 20000;

            dwLastError = QueueBackupMasterKey(
                                pvContext,
                                phMasterKey,
                                pbLocalKey,
                                cbLocalKey,
                                pbMasterKey,
                                cbMasterKey,
                                dwWaitTimeout
                                );
        }

    }

    if( !fPhaseTwo || dwLastError != ERROR_SUCCESS ) {

        DWORD dwTempError;

        //
        // couldn't (or policy didn't allow) backup to phase two.
        // persist phase one key, if one was generated
        //

        if(pbBackupKeyPhaseOne)
        {
            // This will overwrite our local backup data indicating which credential
            // will be able to decrypt the master key.  However, since we have a 
            // phase one backup key anyway, it doesn't matter.
            //
            // This should only happen if fLegacy is true
            dwTempError = PersistMasterKeyToStorage(
                            phMasterKey,
                            REGVAL_BACKUP_LCL_KEY,
                            pbBackupKeyPhaseOne,
                            cbBackupKeyPhaseOne
                            );
        }


        //
        // if it was async, prop correct error code back.
        //

        if( fAsynchronous || !fPhaseTwo ) {
            dwLastError = dwTempError;
        } else {
            if( dwLastError == ERROR_SUCCESS && dwTempError != ERROR_SUCCESS )
                dwLastError = dwTempError;
        }
    }


cleanup:

    ZeroMemory( rgbLKEncryptionKey, sizeof(rgbLKEncryptionKey) );
    ZeroMemory( rgbBKEncryptionKey, sizeof(rgbBKEncryptionKey) );

    if(pbLocalKey) {
        ZeroMemory(pbLocalKey, cbLocalKey);
        SSFree(pbLocalKey);
    }

    if(pbBackupKeyPhaseOne) {
        ZeroMemory(pbBackupKeyPhaseOne, cbBackupKeyPhaseOne);
        SSFree(pbBackupKeyPhaseOne);
    }

    if(pbBackupKeyPhaseTwo) {
        ZeroMemory(pbBackupKeyPhaseTwo, cbBackupKeyPhaseTwo);
        SSFree(pbBackupKeyPhaseTwo);
    }

    return dwLastError;
}

DWORD
QueueBackupMasterKey(
    IN      PVOID pvContext,
    IN      PMASTERKEY_STORED phMasterKey,
    IN      PBYTE pbLocalKey,
    IN      DWORD cbLocalKey,
    IN      PBYTE pbMasterKey,
    IN      DWORD cbMasterKey,
    IN      DWORD dwWaitTimeout             // amount of time to wait for operation to complete
    )
{

    HANDLE hDuplicateToken = NULL;
    PMASTERKEY_STORED phDuplicatedMasterKey = NULL;
    PQUEUED_BACKUP pQueuedBackup = NULL;
    HANDLE hEventThread = NULL;
    HANDLE hEventSuccess = NULL;
    HANDLE hDuplicateEvent = NULL;
    HANDLE hDuplicateEvent2 = NULL;
    DWORD dwLastError;

    //
    // allocate memory for the structure and any trailing contents.
    //

    pQueuedBackup = (PQUEUED_BACKUP)SSAlloc(
                            sizeof(QUEUED_BACKUP) +
                            cbMasterKey +
                            cbLocalKey
                            );

    if( pQueuedBackup == NULL )
        return ERROR_OUTOFMEMORY;

    pQueuedBackup->cbSize = sizeof(QUEUED_BACKUP);

    //
    // duplicate the phase one backup blob.
    //

    pQueuedBackup->pbLocalKey = (LPBYTE)(pQueuedBackup+1);
    pQueuedBackup->cbLocalKey = cbLocalKey;

    CopyMemory(pQueuedBackup->pbLocalKey, pbLocalKey, cbLocalKey);


    // BUGBUG: pQueueBackup should not be pagable or should be protected.
    pQueuedBackup->pbMasterKey = pQueuedBackup->pbLocalKey + cbLocalKey;
    pQueuedBackup->cbMasterKey = cbMasterKey;

    CopyMemory(pQueuedBackup->pbMasterKey, pbMasterKey, cbMasterKey);

    //
    // make a duplicate of the client access token.
    //

    dwLastError = CPSDuplicateClientAccessToken( pvContext, &hDuplicateToken );

    if( dwLastError != ERROR_SUCCESS )
        goto cleanup;

    //
    // duplicate the open masterkey
    //

    if(!DuplicateMasterKey( phMasterKey, &(pQueuedBackup->hMasterKey) )) {
        dwLastError = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    pQueuedBackup->hToken = hDuplicateToken;
    phDuplicatedMasterKey = &(pQueuedBackup->hMasterKey);


    hEventThread = CreateEventW( NULL, TRUE, FALSE, NULL );

    if( hEventThread ) {

        if( DuplicateHandle(
                    GetCurrentProcess(),
                    hEventThread,
                    GetCurrentProcess(),
                    &hDuplicateEvent,
                    0,
                    FALSE,
                    DUPLICATE_SAME_ACCESS
                    )) {

            pQueuedBackup->hEventThread = hDuplicateEvent;
        } else {
            hDuplicateEvent = NULL;
        }

    }

    //
    // create event which indicates success.
    //

    hEventSuccess = CreateEventW( NULL, TRUE, FALSE, NULL );

    if( hEventSuccess ) {

        if( DuplicateHandle(
                    GetCurrentProcess(),
                    hEventSuccess,
                    GetCurrentProcess(),
                    &hDuplicateEvent2,
                    0,
                    FALSE,
                    DUPLICATE_SAME_ACCESS
                    )) {

            pQueuedBackup->hEventSuccess = hDuplicateEvent2;
        } else {
            hDuplicateEvent2 = NULL;
        }

    }

    //
    // finally, create the worker thread.
    //

    if( !QueueUserWorkItem(
            QueueBackupMasterKeyThreadFunc,
            pQueuedBackup,
            WT_EXECUTELONGFUNCTION
            )) {

        dwLastError = GetLastError();
        goto cleanup;
    }

    //
    // if the thread is still active, we write the master key out.
    //

    if( hEventThread ) {
        if(WAIT_OBJECT_0 != WaitForSingleObject( hEventThread, dwWaitTimeout ))
            dwLastError = STILL_ACTIVE;
    }

    if( hEventSuccess && dwLastError == ERROR_SUCCESS ) {

        //
        // check if operation succeeded.
        // if not, indicate an error condition.
        //

        if(WAIT_OBJECT_0 != WaitForSingleObject( hEventSuccess, 0 ))
            dwLastError = STILL_ACTIVE;

    }

cleanup:

    //
    // if thread creation failed, we cleanup resources that were handed
    // to the thread, since it cannot possibly clean them up.
    //

    if( dwLastError != ERROR_SUCCESS && dwLastError != STILL_ACTIVE ) {

        if( hDuplicateToken )
            CloseHandle( hDuplicateToken );

        if( hDuplicateEvent )
            CloseHandle( hDuplicateEvent );

        if( hDuplicateEvent2 )
            CloseHandle( hDuplicateEvent2 );

        if( phDuplicatedMasterKey )
            CloseMasterKey( pvContext, phDuplicatedMasterKey, FALSE );

        if( pQueuedBackup )
            SSFree( pQueuedBackup );
    }

    if( hEventThread )
        CloseHandle( hEventThread );

    if( hEventSuccess )
        CloseHandle( hEventSuccess );

    return dwLastError;
}

DWORD
WINAPI
QueueBackupMasterKeyThreadFunc(
    IN      LPVOID lpThreadArgument
    )
{
    PQUEUED_BACKUP pQueuedBackup = (PQUEUED_BACKUP)lpThreadArgument;
    HANDLE hToken = NULL;
    HANDLE hEventThread;
    HANDLE hEventSuccess;
    PMASTERKEY_STORED phMasterKey = NULL;
    PBYTE pbBackupKeyPhaseOne = NULL;
    DWORD cbBackupKeyPhaseOne;

    PBYTE pbBackupKeyPhaseTwo = NULL;
    DWORD cbBackupKeyPhaseTwo;
    BOOL fImpersonated = FALSE;
    DWORD dwLastError = ERROR_SUCCESS;

    BOOL fSuccess = FALSE;
    BOOL fSuccessClose = FALSE;

    BOOL fLegacy = FIsLegacyCompliant();
    //
    // check structure version.
    //

    if(pQueuedBackup == NULL || pQueuedBackup->cbSize != sizeof(QUEUED_BACKUP))
        return ERROR_INVALID_PARAMETER;

    hToken = pQueuedBackup->hToken;
    hEventThread = pQueuedBackup->hEventThread;
    hEventSuccess = pQueuedBackup->hEventSuccess;

    phMasterKey = &(pQueuedBackup->hMasterKey);





    if(!fLegacy)
    {

        //
        // Public was not available, so 
        // we need to try to retrieve it
        // 

        dwLastError = AttemptLocalBackup(TRUE,
                        hToken,
                        phMasterKey,
                        0,
                        pQueuedBackup->pbMasterKey,
                        pQueuedBackup->cbMasterKey,
                        pQueuedBackup->pbLocalKey,
                        pQueuedBackup->cbLocalKey,
                        &pbBackupKeyPhaseTwo,
                        &cbBackupKeyPhaseTwo
                        );
    }

    //
    // impersonate the client user.
    //

    if(FIsWinNT()) {
        fImpersonated = SetThreadToken( NULL, hToken );
        if(!fImpersonated) {
            dwLastError = GetLastError();
            goto cleanup;
        }
    } else {
        fImpersonated = TRUE;
    }

    if((ERROR_SUCCESS != dwLastError) || fLegacy)
    {
        BYTE rgbBKEncryptionKey[ A_SHA_DIGEST_LEN ];

        //
        // derive BK encryption key from decrypted Local Key.
        //

        FMyPrimitiveSHA( pQueuedBackup->pbLocalKey, pQueuedBackup->cbLocalKey, rgbBKEncryptionKey );

        //
        // encrypt masterkey to phase one backup key, using encryption key derived
        // from local key.  do it in memory, such that we only commit it to disk if
        // phase two backup key cannot be generated/persisted.
        //

        dwLastError = EncryptMasterKeyToMemory(
                            rgbBKEncryptionKey,
                            0,
                            pQueuedBackup->pbMasterKey,
                            pQueuedBackup->cbMasterKey,
                            &pbBackupKeyPhaseOne,
                            &cbBackupKeyPhaseOne
                            );
        ZeroMemory(rgbBKEncryptionKey, sizeof(rgbBKEncryptionKey));


        if(dwLastError != ERROR_SUCCESS)
            goto cleanup;

        // Copy this in directly, so we do not set the modified flag



        // Perform a legacy style backup
        dwLastError = BackupRestoreData(
                        NULL,
                        phMasterKey,
                        0,
                        pbBackupKeyPhaseOne,
                        cbBackupKeyPhaseOne,
                        &pbBackupKeyPhaseTwo,
                        &cbBackupKeyPhaseTwo,
                        TRUE    // backup data
                        );
    }

    if( dwLastError == ERROR_SUCCESS ) {

        //
        // perist phase two backup key to storage.
        //

        dwLastError = PersistMasterKeyToStorage(
                            phMasterKey,
                            REGVAL_BACKUP_DC_KEY,
                            pbBackupKeyPhaseTwo,
                            cbBackupKeyPhaseTwo
                            );

        if( dwLastError == ERROR_SUCCESS ) {

            //
            // successful phase two backup+persist, nuke phase one backup
            // master key.
            //

            PersistMasterKeyToStorage(
                        phMasterKey,
                        REGVAL_BACKUP_LCL_KEY,
                        NULL,
                        0
                        );

            fSuccess = TRUE;
        }
    }


cleanup:

    //
    // always close/free master key.  Only if impersonation succeeeded
    // do we attempt to flush it out.
    //

    fSuccessClose = CloseMasterKey( NULL, phMasterKey, fSuccess ) ;

    if( hEventSuccess ) {
        if( fSuccess && fSuccessClose )
            SetEvent( hEventSuccess );

        CloseHandle( hEventSuccess );
    }

    if( fImpersonated )
        RevertToSelf();

    if( hToken )
        CloseHandle(hToken);

    if( hEventThread ) {
        SetEvent( hEventThread );
        CloseHandle( hEventThread );
    }
    if(pbBackupKeyPhaseOne) {
        ZeroMemory(pbBackupKeyPhaseOne, cbBackupKeyPhaseOne);
        SSFree(pbBackupKeyPhaseOne);
    }
    if(pbBackupKeyPhaseTwo) {
        ZeroMemory(pbBackupKeyPhaseTwo, cbBackupKeyPhaseTwo);
        SSFree(pbBackupKeyPhaseTwo);
    }

    if( lpThreadArgument )
        SSFree( lpThreadArgument );

    return dwLastError;
}

DWORD
RestoreMasterKey(
    IN      PVOID   pvContext,
    IN      PSID    pSid,
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD   dwReason,
        OUT LPBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey
    )
/*++

    Recover the master key associated with the specified master key.

    The current state of the masterkey dictates what level of recovery is
    attempted.

--*/
{
    static const GUID guidRestoreW2K = BACKUPKEY_RESTORE_GUID_W2K;

    BYTE rgbLKEncryptionKey[ A_SHA_DIGEST_LEN ];
    BYTE rgbBKEncryptionKey[ A_SHA_DIGEST_LEN ];

    PBYTE pbLocalKey = NULL;
    DWORD cbLocalKey;

    PBYTE pbBackupKeyPhaseOne = NULL;
    DWORD cbBackupKeyPhaseOne;


    BOOL fAllocatedPhaseOne = FALSE;

    DWORD dwLastError = (DWORD)NTE_BAD_KEY;

    D_DebugLog((DEB_TRACE, "RestoreMasterKey:%ls\n", phMasterKey->wszguidMasterKey));

    if(phMasterKey->pbBK)
    {

        LOCAL_BACKUP_DATA LocalBackupData;

        // First, see if we have any local password-change recovery 
        // information.

        if(phMasterKey->cbBK >= sizeof(LocalBackupData))
        {
            CopyMemory(&LocalBackupData, phMasterKey->pbBK, sizeof(LocalBackupData));
        }
        else
        {
            ZeroMemory(&LocalBackupData, sizeof(LocalBackupData));
        }
        
        if(MASTERKEY_BLOB_LOCALKEY_BACKUP == LocalBackupData.dwVersion)
        {
            D_DebugLog((DEB_TRACE, "Attempt local recovery.\n"));

            #ifdef COMPILED_BY_DEVELOPER
            D_DebugLog((DEB_TRACE, "MK decryption key GUID:\n"));
            D_DPAPIDumpHexData(DEB_TRACE, "  ", (PBYTE)&LocalBackupData.CredentialID, sizeof(LocalBackupData.CredentialID));
            #endif

            if(GetMasterKeyUserEncryptionKey(pvContext,
                                             &LocalBackupData.CredentialID,
                                             pSid,
                                             ((phMasterKey->dwPolicy & POLICY_DPAPI_OWF)?USE_DPAPI_OWF:0),
                                             rgbBKEncryptionKey))
            {

                //
                // retrieve and decrypt MK with current credential.
                //

                #ifdef COMPILED_BY_DEVELOPER
                D_DebugLog((DEB_TRACE, "MK decryption key:\n"));
                D_DPAPIDumpHexData(DEB_TRACE, "  ", rgbBKEncryptionKey, sizeof(rgbBKEncryptionKey));
                #endif

                dwLastError = DecryptMasterKeyFromStorage(
                                    phMasterKey,
                                    REGVAL_MASTER_KEY,
                                    rgbBKEncryptionKey,
                                    NULL,
                                    ppbMasterKey,
                                    pcbMasterKey
                                    );
                if(ERROR_SUCCESS == dwLastError)
                {
                    #ifdef COMPILED_BY_DEVELOPER
                    D_DebugLog((DEB_TRACE, "Master key:\n"));
                    D_DPAPIDumpHexData(DEB_TRACE, "  ", *ppbMasterKey, *pcbMasterKey);
                    #endif

                    goto cleanup;
                }
                else
                {
                    D_DebugLog((DEB_WARN, "Unable to decrypt MK with local decryption key.\n"));
                }
            }
            else
            {
                D_DebugLog((DEB_WARN, "Unable to locate local MK decryption key.\n"));
            }
        }
    }



    if(phMasterKey->pbBBK) {

        //
        // do phase two recovery.
        // undoing phase two backup blob gives us phase one backup blob.
        //

        dwLastError = CPSImpersonateClient( pvContext );

        if( dwLastError == ERROR_SUCCESS ) {

            dwLastError = BackupRestoreData(
                            ((PCRYPT_SERVER_CONTEXT)pvContext)->hToken,
                            phMasterKey,
                            dwReason,
                            phMasterKey->pbBBK,
                            phMasterKey->cbBBK,
                            &pbBackupKeyPhaseOne,
                            &cbBackupKeyPhaseOne,
                            FALSE    // do not backup data
                            );

            if(ERROR_SUCCESS != dwLastError)
            {
                //
                // Attempt a restore through the w2k restore port
                //
                dwLastError = LocalBackupRestoreData(
                                                    ((PCRYPT_SERVER_CONTEXT)pvContext)->hToken,
                                                    phMasterKey,
                                                    dwReason,
                                                    phMasterKey->pbBBK,
                                                    phMasterKey->cbBBK,
                                                    &pbBackupKeyPhaseOne,
                                                    &cbBackupKeyPhaseOne,
                                                    &guidRestoreW2K);
            }
            if(dwLastError == ERROR_SUCCESS)
                fAllocatedPhaseOne = TRUE;



            CPSRevertToSelf( pvContext );
        }

    } else {

        //
        // try phase one blob.
        //

        dwLastError = QueryMasterKeyFromStorage(
                        phMasterKey,
                        REGVAL_BACKUP_LCL_KEY,
                        &pbBackupKeyPhaseOne,
                        &cbBackupKeyPhaseOne
                        );

    }

    if(dwLastError != ERROR_SUCCESS)
        goto cleanup;


    //
    // Check to see if this really is a phase one blob
    //

    if(cbBackupKeyPhaseOne < sizeof(DWORD))
    {
        goto cleanup;
    }
    if(*((DWORD *)pbBackupKeyPhaseOne) != MASTERKEY_BLOB_RAW_VERSION)
    {
        //
        // we successfully got an phase one blob.
        // decrypt it to get the original masterkey.
        //


        //
        // get current localkey encryption key.
        //

        if(!GetLocalKeyUserEncryptionKey(pvContext, phMasterKey, rgbLKEncryptionKey))
            goto cleanup;

        //
        // retrieve and decrypt LK with current credential.
        //

        dwLastError = DecryptMasterKeyFromStorage(
                            phMasterKey,
                            REGVAL_LOCAL_KEY,
                            rgbLKEncryptionKey,
                            NULL, 
                            &pbLocalKey,
                            &cbLocalKey
                            );

        if(dwLastError != ERROR_SUCCESS)
            goto cleanup;

        //
        // derive BK encryption key from decrypted Local Key.
        //

        FMyPrimitiveSHA( pbLocalKey, cbLocalKey, rgbBKEncryptionKey );


        //
        // finally, decrypt BK using derived BKEncryptionKey
        //

        dwLastError = DecryptMasterKeyToMemory(
                            rgbBKEncryptionKey,
                            pbBackupKeyPhaseOne,
                            cbBackupKeyPhaseOne,
                            NULL, 
                            ppbMasterKey,
                            pcbMasterKey
                            );
    }
    else
    {
        *ppbMasterKey = (PBYTE)SSAlloc(cbBackupKeyPhaseOne - sizeof(DWORD));
        if(NULL == *ppbMasterKey)
        {
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        CopyMemory(*ppbMasterKey, 
                   pbBackupKeyPhaseOne + sizeof(DWORD),
                   cbBackupKeyPhaseOne - sizeof(DWORD));
        *pcbMasterKey =  cbBackupKeyPhaseOne - sizeof(DWORD);

    }


cleanup:

    ZeroMemory( rgbLKEncryptionKey, sizeof(rgbLKEncryptionKey) );
    ZeroMemory( rgbBKEncryptionKey, sizeof(rgbBKEncryptionKey) );

    if(pbLocalKey) {
        ZeroMemory(pbLocalKey, cbLocalKey);
        SSFree(pbLocalKey);
    }

    if(fAllocatedPhaseOne && pbBackupKeyPhaseOne) {
        ZeroMemory(pbBackupKeyPhaseOne, cbBackupKeyPhaseOne);
        SSFree(pbBackupKeyPhaseOne);
    }

    D_DebugLog((DEB_TRACE, "RestoreMasterKey returned 0x%x\n", dwLastError));

    return dwLastError;
}


//
// per-user root level policy query, set
//

BOOL
InitializeMasterKeyPolicy(
    IN      PVOID pvContext,
    IN      PMASTERKEY_STORED phMasterKey,
    OUT     BOOL *fLocalAccount
    )
{
    DWORD dwMasterKeyPolicy = 0;

    BOOL fSystemCred = FALSE;

    //
    // get current top-level policy.
    //

    dwMasterKeyPolicy = phMasterKey->dwPolicy | GetMasterKeyDefaultPolicy();

    *fLocalAccount = !IsDomainBackupRequired( pvContext );



    if( !(dwMasterKeyPolicy & POLICY_NO_BACKUP) &&
        !(dwMasterKeyPolicy & POLICY_LOCAL_BACKUP) ) {

        //
        // See if domain controller (phase two) backup is required/appropriate.
        //

        if( !(*fLocalAccount) ) {
            phMasterKey->dwPolicy = dwMasterKeyPolicy;
            return TRUE;
        }

    }



    //
    // see if the call is for shared, CRYPT_PROTECT_LOCAL_MACHINE
    // disposition.
    //

    CPSOverrideToLocalSystem(
                pvContext,
                NULL,       // don't change current over-ride BOOL
                &fSystemCred
                );


    //
    // if the context specified per-machine, we know that it's a system credential.
    // also, we don't need to get the user name in this scenario.
    //

    if( !fSystemCred ) {

        LPWSTR szUserName;
        DWORD cchUserName;
        DWORD dwLastError;

        dwLastError = CPSGetUserName(
                                                pvContext,
                                                &szUserName,
                                                &cchUserName
                                                );

        if( dwLastError != ERROR_SUCCESS ) {
            SetLastError( dwLastError );
            return FALSE;
        }

        //
        // see if the user name is the system account; if so, it's a system
        // credential.
        //

        if(lstrcmpW(szUserName, TEXTUAL_SID_LOCAL_SYSTEM) == 0)
            fSystemCred = TRUE;


        SSFree( szUserName );
    }


    if( fSystemCred ) {

        //
        // a SYSTEM (user or per-machine disposition) key is the focus
        // of our attention; never back these up.
        //

        dwMasterKeyPolicy |= POLICY_NO_BACKUP;
        dwMasterKeyPolicy &= ~POLICY_LOCAL_BACKUP;

    } else {

        //
        // otherwise assume it's a key associated with a local account...
        // (local only backup).
        //

        dwMasterKeyPolicy |= POLICY_LOCAL_BACKUP;
    }


    //
    // don't persist a default value as this implies that somebody really
    // specified a policy. (maximum forward compatibility).
    //

    phMasterKey->dwPolicy = dwMasterKeyPolicy;

    return TRUE;
}






BOOL
IsDomainBackupRequired(
    IN      PVOID pvContext
    )
/*++

    Determine if the current security context dictates whether domain controller
    (phase two) based backup is required/appropriate.

--*/
{

    PSID pSidUser = NULL;
    DWORD dwSubauthorityCount;

    PUSER_MODALS_INFO_2 pumi2 = NULL;
    NET_API_STATUS nas;

    BOOL fBackupRequired = FALSE; // assume backup not required.
    BOOL fSuccess;
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;

    //
    // Win95: lie about the policy, domain backup not allowed.
    // TODO: WinNT4: also lie about the policy; local only backup.
    //

    if(!FIsWinNT())
        return FALSE;

    //
    // get the Sid associated with the client security context.
    //  see if the Sid only has one subauthority.  If so, no associated DC.
    //  see if current machine a DC.  If so, backup is required.
    //

    fSuccess = GetTokenUserSid(pServerContext->hToken, &pSidUser);

    if(!fSuccess)
        goto cleanup;

    //
    // see if the Sid has only one subauthority.  If so, no associated DC,
    // no DC backup possible.
    //

    dwSubauthorityCount = *GetSidSubAuthorityCount( pSidUser );

    if( dwSubauthorityCount == 1 ) {
        fBackupRequired = FALSE;
        goto cleanup;
    }

    //
    // if current machine is a domain controller, backup is required.
    //

    if(IsDomainController()) {
        fBackupRequired = TRUE;
        goto cleanup;
    }


    //
    // if the Sid contains local machine domain prefix Sid, backup is not
    // required, as no DC is associated with the account.
    //

    nas = NetUserModalsGet( NULL, 2, (LPBYTE*)&pumi2 );

    if(nas != NERR_Success)
        goto cleanup;

    if(!IsUserSidInDomain( pumi2->usrmod2_domain_id, pSidUser )) {
        fBackupRequired = TRUE;
        goto cleanup;
    }

    //
    // defaulted to backup not required.
    //

    fBackupRequired = FALSE;

cleanup:

    if(pumi2)
        NetApiBufferFree(pumi2);

    if(pSidUser)
        SSFree(pSidUser);

    return fBackupRequired;
}

NTSTATUS
GetPreferredMasterKeyGuid(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
    IN  OUT GUID *pguidMasterKey
    )
/*++

    Given a registry handle to the MasterKeys portion of the registry,
    tells the caller what the preferred master key GUID is.

    On Success, the return value is TRUE, and the pguidMasterKey
    buffer is filled with the GUID associated with the preferred
    master key.

    On Failure, the return value is FALSE.  The caller can assume
    there is no preferred master key configured in this case, and a new one
    is to be created and subsequently selected via SetPreferredMasterKeyGuid().

--*/
{

    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwBytesRead;

    MASTERKEY_PREFERRED_INFO sMKPreferred;
    SYSTEMTIME stCurrentTime;
    FILETIME ftCurrentTime;
    unsigned __int64 CurrentTime;
    unsigned __int64 ExpiryInterval;

    DWORD dwLastError;
    BOOL fSuccess;

    dwLastError = OpenFileInStorageArea(
                        pvContext,
                        GENERIC_READ,
                        szUserStorageArea,
                        REGVAL_PREFERRED_MK,
                        &hFile
                        );

    if(dwLastError != ERROR_SUCCESS) 
    {
        return STATUS_NOT_FOUND;
    }

    //
    // read the expiration and GUID from file into buffer.
    //

    fSuccess = ReadFile( hFile, &sMKPreferred, sizeof(sMKPreferred), &dwBytesRead, NULL );

    CloseHandle( hFile );

    if( !fSuccess )
    {
        return STATUS_NOT_FOUND;
    }

    //
    // validate data
    //

    if( dwBytesRead != sizeof(sMKPreferred) )
    {
        return STATUS_NOT_FOUND;
    }


    //
    // Copy the GUID of the preferred master key to the output buffer.
    //

    CopyMemory(pguidMasterKey, &(sMKPreferred.guidPreferredKey), sizeof(GUID));


    //
    // see if the key has expired
    //

    GetSystemTime(&stCurrentTime);
    SystemTimeToFileTime(&stCurrentTime, &ftCurrentTime);

    if(CompareFileTime(&ftCurrentTime, &(sMKPreferred.ftPreferredKeyExpires)) >= 0)
    {
        // key has expired
        return STATUS_PASSWORD_EXPIRED;
    }

    ExpiryInterval = MASTERKEY_EXPIRES_DAYS * 24 * 60 * 60;
    ExpiryInterval *= 10000000;

    CurrentTime = ((__int64)ftCurrentTime.dwHighDateTime << 32) + (__int64)ftCurrentTime.dwLowDateTime;
    CurrentTime += ExpiryInterval;

    ftCurrentTime.dwLowDateTime = (DWORD)(CurrentTime & 0xffffffff);
    ftCurrentTime.dwHighDateTime = (DWORD)(CurrentTime >> 32);

    if(CompareFileTime(&ftCurrentTime, &(sMKPreferred.ftPreferredKeyExpires)) < 0)
    {
        // expiry time is too far in the future
        return STATUS_PASSWORD_EXPIRED;
    }


    //
    // The key is current.
    //

    return STATUS_SUCCESS;
}

BOOL
SetPreferredMasterKeyGuid(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
    IN      GUID *pguidMasterKey
    )
{
    MASTERKEY_PREFERRED_INFO sMKPreferred;
    SYSTEMTIME stCurrentTime;
    FILETIME ftCurrentTime;
    unsigned __int64 uTime;
    unsigned __int64 oTime;

    HANDLE hFile;
    DWORD dwBytesWritten;

    DWORD dwLastError;
    BOOL fSuccess;

    CopyMemory(&sMKPreferred.guidPreferredKey, pguidMasterKey, sizeof(GUID));

    //
    // set key expiration time.
    //

    GetSystemTime(&stCurrentTime);
    SystemTimeToFileTime(&stCurrentTime, &(sMKPreferred.ftPreferredKeyExpires));

    uTime = sMKPreferred.ftPreferredKeyExpires.dwLowDateTime;
    uTime += ((unsigned __int64)sMKPreferred.ftPreferredKeyExpires.dwHighDateTime << 32) ;

    //
    //  the compiler complains about integer constant overflow
    // if we don't break it up..
    //

    oTime = MASTERKEY_EXPIRES_DAYS * 24 * 60 * 60;
    oTime *= 10000000;

    uTime += oTime;

    sMKPreferred.ftPreferredKeyExpires.dwLowDateTime = (DWORD)(uTime & 0xffffffff);
    sMKPreferred.ftPreferredKeyExpires.dwHighDateTime = (DWORD)(uTime >> 32);


    dwLastError = OpenFileInStorageArea(
                        pvContext,
                        GENERIC_WRITE,
                        szUserStorageArea,
                        REGVAL_PREFERRED_MK,
                        &hFile
                        );

    if(dwLastError != ERROR_SUCCESS) {
        SetLastError(dwLastError);
        return FALSE;
    }

    //
    // write the expiration and GUID from buffer into file.
    //

    fSuccess = WriteFile( hFile, &sMKPreferred, sizeof(sMKPreferred), &dwBytesWritten, NULL );

    CloseHandle( hFile );

    return fSuccess;
}



DWORD
OpenFileInStorageArea(
    IN      PVOID pvContext,            // if NULL, caller is assumed to be impersonating
    IN      DWORD   dwDesiredAccess,
    IN      LPCWSTR szUserStorageArea,
    IN      LPCWSTR szFileName,
    IN OUT  HANDLE  *phFile
    )
{
    LPWSTR szFilePath = NULL;
    DWORD cbUserStorageArea;
    DWORD cbFileName;
    DWORD dwShareMode = 0;
    DWORD dwCreationDistribution = OPEN_EXISTING;
    DWORD dwLastError = ERROR_SUCCESS;

    *phFile = INVALID_HANDLE_VALUE;

    if( dwDesiredAccess & GENERIC_READ ) {
        dwShareMode |= FILE_SHARE_READ;
        dwCreationDistribution = OPEN_EXISTING;
    }

    if( dwDesiredAccess & GENERIC_WRITE ) {
        dwShareMode = 0;
        dwCreationDistribution = OPEN_ALWAYS;
    }

    cbUserStorageArea = lstrlenW( szUserStorageArea ) * sizeof(WCHAR);
    cbFileName = lstrlenW( szFileName ) * sizeof(WCHAR);

    szFilePath = (LPWSTR)SSAlloc( cbUserStorageArea + cbFileName + sizeof(WCHAR) );

    if( szFilePath == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    CopyMemory(szFilePath, szUserStorageArea, cbUserStorageArea);
    CopyMemory((LPBYTE)szFilePath+cbUserStorageArea, szFileName, cbFileName + sizeof(WCHAR));

    if( pvContext )
        dwLastError = CPSImpersonateClient( pvContext );

    if( dwLastError == ERROR_SUCCESS ) {

        //
        // TODO:
        // apply security descriptor to file.
        //

        *phFile = CreateFileWithRetries(
                    szFilePath,
                    dwDesiredAccess,
                    dwShareMode,
                    NULL,
                    dwCreationDistribution,
                    FILE_ATTRIBUTE_HIDDEN |
                    FILE_ATTRIBUTE_SYSTEM |
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

        if( *phFile == INVALID_HANDLE_VALUE ) {
            dwLastError = GetLastError();
        }

        if( pvContext )
            CPSRevertToSelf( pvContext );

    }

    if(szFilePath)
        SSFree(szFilePath);

    return dwLastError;
}

HANDLE
CreateFileWithRetries(
    IN      LPCWSTR lpFileName,
    IN      DWORD dwDesiredAccess,
    IN      DWORD dwShareMode,
    IN      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN      DWORD dwCreationDisposition,
    IN      DWORD dwFlagsAndAttributes,
    IN      HANDLE hTemplateFile
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;

    static const DWORD rgReadRetrys[] = { 1, 10, 50, 100, 1000, 0 };
    static const DWORD rgWriteRetrys[] = { 1, 10, 20, 20, 50, 75, 100, 500, 1, 1000, 0 };

    const DWORD *prgRetries;
    DWORD dwRetryIndex;

    DWORD dwLastError = ERROR_SHARING_VIOLATION;

    if( dwDesiredAccess & GENERIC_WRITE ) {
        prgRetries = rgWriteRetrys;
    } else {
        prgRetries = rgReadRetrys;
    }

    for( dwRetryIndex = 0 ; prgRetries[ dwRetryIndex ] ; dwRetryIndex++ ) {

        hFile = CreateFileU(
                    lpFileName,
                    dwDesiredAccess,
                    dwShareMode,
                    lpSecurityAttributes,
                    dwCreationDisposition,
                    dwFlagsAndAttributes,
                    hTemplateFile
                    );

        if( hFile != INVALID_HANDLE_VALUE )
            break;

        dwLastError = GetLastError();

        if( dwLastError == ERROR_SHARING_VIOLATION )
        {
            //
            // sleep around for the designated period of time...
            //

            Sleep( prgRetries[dwRetryIndex] );
            continue;
        }

        break;
    }

    if( hFile == INVALID_HANDLE_VALUE )
        SetLastError( dwLastError );

    return hFile;
}




BOOL
ReadMasterKey(
    IN      PVOID pvContext,            // if NULL, caller is assumed to be impersonating
    IN      PMASTERKEY_STORED phMasterKey
    )
/*++

    Read the masterkey specified by phMasterKey->wszguidMasterKey into memory.

--*/
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = NULL;
    DWORD dwFileSizeLow;

    PMASTERKEY_STORED_ON_DISK pMasterKeyRead = NULL;
    DWORD cbguidMasterKey, cbguidMasterKey2;
    PBYTE pbCurrentBlock;

    BOOL fSuccess = FALSE;


    if( OpenFileInStorageArea(
                    pvContext,
                    GENERIC_READ,
                    phMasterKey->szFilePath,
                    phMasterKey->wszguidMasterKey,
                    &hFile
                    ) != ERROR_SUCCESS)
            return FALSE;

    dwFileSizeLow = GetFileSize( hFile, NULL );
    if(dwFileSizeLow == 0xFFFFFFFF)
        goto cleanup;


    hMap = CreateFileMappingU(
                    hFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    0,
                    NULL
                    );

    if( hMap == NULL )
        goto cleanup;


    pMasterKeyRead = (PMASTERKEY_STORED_ON_DISK)MapViewOfFile( hMap, FILE_MAP_READ, 0, 0, 0 );

    if(pMasterKeyRead == NULL)
        goto cleanup;


    if(pMasterKeyRead->dwVersion > MASTERKEY_STORED_VERSION)
        goto cleanup;

    //
    // do some size validation
    //

    if( dwFileSizeLow < sizeof(MASTERKEY_STORED_ON_DISK) )
        goto cleanup;

    if((pMasterKeyRead->cbMK + pMasterKeyRead->cbLK +
        pMasterKeyRead->cbBK + pMasterKeyRead->cbBBK) >
        ( dwFileSizeLow - sizeof(MASTERKEY_STORED_ON_DISK) )
        )
        goto cleanup;

    //
    // validate retrieved GUID matches requested GUID.
    //

    cbguidMasterKey = (lstrlenW( phMasterKey->wszguidMasterKey ) + 1) * sizeof(WCHAR);
    cbguidMasterKey2 = (lstrlenW( pMasterKeyRead->wszguidMasterKey ) + 1) * sizeof(WCHAR);

    if(cbguidMasterKey != cbguidMasterKey2)
        goto cleanup;

    if(memcmp( phMasterKey->wszguidMasterKey, pMasterKeyRead->wszguidMasterKey, cbguidMasterKey) != 0)
        goto cleanup;

    phMasterKey->dwVersion = pMasterKeyRead->dwVersion;

    //
    // pickup master key policy
    //

    phMasterKey->dwPolicy = pMasterKeyRead->dwPolicy;


    //
    // copy useful components into new block so a single contiguous write
    // can occur.
    //

    pbCurrentBlock = (LPBYTE)(pMasterKeyRead + 1);

    if( pMasterKeyRead->cbMK ) {
        phMasterKey->pbMK = (LPBYTE)SSAlloc( pMasterKeyRead->cbMK );
        if(phMasterKey->pbMK == NULL)
            goto cleanup;

        phMasterKey->cbMK = pMasterKeyRead->cbMK;

        CopyMemory(phMasterKey->pbMK, pbCurrentBlock, pMasterKeyRead->cbMK);
        pbCurrentBlock += pMasterKeyRead->cbMK;
    }

    if( pMasterKeyRead->cbLK ) {
        phMasterKey->pbLK = (LPBYTE)SSAlloc( pMasterKeyRead->cbLK );
        if(phMasterKey->pbLK == NULL)
            goto cleanup;

        phMasterKey->cbLK = pMasterKeyRead->cbLK;

        CopyMemory(phMasterKey->pbLK, pbCurrentBlock, pMasterKeyRead->cbLK);
        pbCurrentBlock += pMasterKeyRead->cbLK;
    }

    if( pMasterKeyRead->cbBK ) {
        phMasterKey->pbBK = (LPBYTE)SSAlloc( pMasterKeyRead->cbBK );
        if(phMasterKey->pbBK == NULL)
            goto cleanup;

        phMasterKey->cbBK = pMasterKeyRead->cbBK;

        CopyMemory(phMasterKey->pbBK, pbCurrentBlock, pMasterKeyRead->cbBK);
        pbCurrentBlock += pMasterKeyRead->cbBK;
    }


    if( pMasterKeyRead->cbBBK ) {
        phMasterKey->pbBBK = (LPBYTE)SSAlloc( pMasterKeyRead->cbBBK );
        if(phMasterKey->pbBBK == NULL)
            goto cleanup;

        phMasterKey->cbBBK = pMasterKeyRead->cbBBK;

        CopyMemory(phMasterKey->pbBBK, pbCurrentBlock, pMasterKeyRead->cbBBK);
    }


    fSuccess = TRUE;

cleanup:

    if( pMasterKeyRead )
        UnmapViewOfFile( pMasterKeyRead );

    if( hMap )
        CloseHandle( hMap );

    if( hFile != INVALID_HANDLE_VALUE )
        CloseHandle( hFile );

    if( !fSuccess )
        FreeMasterKey( phMasterKey );

    return fSuccess;
}


BOOL
WriteMasterKey(
    IN      PVOID pvContext,            // if NULL, caller is assumed to be impersonating
    IN      PMASTERKEY_STORED phMasterKey
    )
/*++

    Persist the specified masterkey to storage.

    if pvContext is NULL, the caller must be impersonating the user associated
    with the masterkey.

--*/
{
    PMASTERKEY_STORED_ON_DISK pMasterKeyToWrite;
    DWORD cbMasterKeyToWrite;

    PBYTE pbCurrentBlock;
    HANDLE hFile;

    BOOL fSuccess = FALSE;

    if(phMasterKey->dwVersion > MASTERKEY_STORED_VERSION)
        return FALSE;


    cbMasterKeyToWrite = sizeof(MASTERKEY_STORED_ON_DISK) +
                            phMasterKey->cbMK +
                            phMasterKey->cbLK +
                            phMasterKey->cbBK +
                            phMasterKey->cbBBK ;

    pMasterKeyToWrite = (PMASTERKEY_STORED_ON_DISK) SSAlloc( cbMasterKeyToWrite );

    if(pMasterKeyToWrite == NULL)
        return FALSE;

    //
    // copy useful components
    //

    pMasterKeyToWrite->dwVersion = phMasterKey->dwVersion;
    CopyMemory(
                pMasterKeyToWrite->wszguidMasterKey,
                phMasterKey->wszguidMasterKey,
                (MAX_GUID_SZ_CHARS * sizeof(WCHAR))
                );

    pMasterKeyToWrite->dwPolicy = phMasterKey->dwPolicy;
    pMasterKeyToWrite->cbMK = phMasterKey->cbMK;
    pMasterKeyToWrite->cbLK = phMasterKey->cbLK;
    pMasterKeyToWrite->cbBK = phMasterKey->cbBK;
    pMasterKeyToWrite->cbBBK = phMasterKey->cbBBK;


    //
    // overwrite non-useful components
    //

    pMasterKeyToWrite->fModified = FALSE;
    pMasterKeyToWrite->szFilePath = 0;
    pMasterKeyToWrite->pbMK = 0;
    pMasterKeyToWrite->pbLK = 0;
    pMasterKeyToWrite->pbBK = 0;
    pMasterKeyToWrite->pbBBK = 0;


    //
    // copy useful components into new block so a single contiguous write
    // can occur.
    //

    pbCurrentBlock = (LPBYTE)(pMasterKeyToWrite + 1);

    if( phMasterKey->pbMK ) {
        CopyMemory(pbCurrentBlock, phMasterKey->pbMK, phMasterKey->cbMK);
        pbCurrentBlock += phMasterKey->cbMK;
    }

    if( phMasterKey->pbLK ) {
        CopyMemory(pbCurrentBlock, phMasterKey->pbLK, phMasterKey->cbLK);
        pbCurrentBlock += phMasterKey->cbLK;
    }


    if( phMasterKey->pbBK ) {
        CopyMemory(pbCurrentBlock, phMasterKey->pbBK, phMasterKey->cbBK);
        pbCurrentBlock += phMasterKey->cbBK;
    }

    if( phMasterKey->pbBBK ) {
        CopyMemory(pbCurrentBlock, phMasterKey->pbBBK, phMasterKey->cbBBK);

    }

    if( OpenFileInStorageArea(
                    pvContext,
                    GENERIC_READ | GENERIC_WRITE,
                    phMasterKey->szFilePath,
                    phMasterKey->wszguidMasterKey,
                    &hFile
                    ) == ERROR_SUCCESS) {


        BOOL fWriteData;
        DWORD dwBytesWritten;

        CheckToStompMasterKey( pMasterKeyToWrite, hFile, &fWriteData );

        if( fWriteData ) {
            fSuccess = WriteFile(
                            hFile,
                            pMasterKeyToWrite,
                            cbMasterKeyToWrite,
                            &dwBytesWritten,
                            NULL
                            );
        } else {
            fSuccess = TRUE; // nothing to do, success
        }

        CloseHandle( hFile );
    }


    ZeroMemory( pMasterKeyToWrite, cbMasterKeyToWrite);
    SSFree( pMasterKeyToWrite );

    return fSuccess;
}

BOOL
CheckToStompMasterKey(
    IN      PMASTERKEY_STORED_ON_DISK   phMasterKeyCandidate,   // masterkey to check if worthy to stomp over existing
    IN      HANDLE                      hFile,                  // file handle to existing masterkey
    IN OUT  BOOL                        *pfStomp                // stomp the existing masterkey?
    )
{
    HANDLE hMap = NULL;
    PMASTERKEY_STORED_ON_DISK pMasterKeyRead = NULL;
    BOOL fSuccess = FALSE;

    *pfStomp = TRUE;

    if( phMasterKeyCandidate->dwPolicy & POLICY_NO_BACKUP )
        return TRUE;

    if( phMasterKeyCandidate->dwPolicy & POLICY_LOCAL_BACKUP &&
        phMasterKeyCandidate->cbBK )
        return TRUE;

    if( phMasterKeyCandidate->cbBBK )
        return TRUE;

    hMap = CreateFileMapping(
                    hFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    0,
                    NULL
                    );

    if( hMap == NULL )
        goto cleanup;

    pMasterKeyRead = (PMASTERKEY_STORED_ON_DISK)MapViewOfFile( hMap, FILE_MAP_READ, 0, 0, 0 );

    if(pMasterKeyRead == NULL)
        goto cleanup;

    if(pMasterKeyRead->dwVersion > MASTERKEY_STORED_VERSION)
        goto cleanup;

    //
    // there's really only two cases where we don't allow stomping:
    // candidate masterkey doesn't contain phase 1 and existing does,
    // candidate masterkey doesn't contain phase 1 and existing one contains phase2.
    // note: we allow stomping over a masterkey that contains a phase 2 with one
    // that only contains a phase 1, because of a race condition that can occur
    // during the backup operation;  In this situation, it is better to have
    // a phase 1 and let it get upgraded to phase 2 at a later time.
    //

    if( phMasterKeyCandidate->cbBK == 0 &&
        (pMasterKeyRead->cbBK || pMasterKeyRead->cbBBK)
        )
        *pfStomp = FALSE;

    fSuccess = TRUE;

cleanup:

    if( pMasterKeyRead )
        UnmapViewOfFile( pMasterKeyRead );

    if( hMap )
        CloseHandle( hMap );

    return fSuccess;
}

BOOL
CloseMasterKey(
    IN      PVOID pvContext,            // if NULL, caller is assumed to be impersonating
    IN      PMASTERKEY_STORED phMasterKey,
    IN      BOOL fPersist               // persist any changes to storage?
    )
/*++

    Free the memory an optionally persist any changes associated with a
    master key.

--*/
{
    BOOL fSuccess = TRUE;

    //
    // if we were told to persist any changes, and changes were actually made,
    // persist them out.
    //

    if( fPersist && phMasterKey->fModified )
        fSuccess = WriteMasterKey( pvContext, phMasterKey );

    //
    // free memory.
    //

    FreeMasterKey( phMasterKey );

    return fSuccess;
}

VOID
FreeMasterKey(
    IN      PMASTERKEY_STORED phMasterKey
    )
/*++

    Free allocated memory associated with the specified master key.

--*/
{
    if( phMasterKey->dwVersion > MASTERKEY_STORED_VERSION )
        return;

    if( phMasterKey->szFilePath )
        SSFree( phMasterKey->szFilePath );

    if( phMasterKey->pbMK ) {
        ZeroMemory( phMasterKey->pbMK, phMasterKey->cbMK );
        SSFree( phMasterKey->pbMK );
    }

    if( phMasterKey->pbLK ) {
        ZeroMemory( phMasterKey->pbLK, phMasterKey->cbLK );
        SSFree( phMasterKey->pbLK );
    }

    if( phMasterKey->pbBK ) {
        ZeroMemory( phMasterKey->pbBK, phMasterKey->cbBK );
        SSFree( phMasterKey->pbBK );
    }

    if( phMasterKey->pbBBK ) {
        ZeroMemory( phMasterKey->pbBBK, phMasterKey->cbBBK );
        SSFree( phMasterKey->pbBBK );
    }

    ZeroMemory( phMasterKey, sizeof(MASTERKEY_STORED) );

    return;
}

BOOL
DuplicateMasterKey(
    IN      PMASTERKEY_STORED phMasterKeyIn,
    IN      PMASTERKEY_STORED phMasterKeyOut
    )
/*++

    Duplicate the input masterkey to a new copy, setting the fModified flag
    on the copy to FALSE.

    This provides a mechanism to allow for deferring operations against a
    master key.

--*/
{
    BOOL fSuccess = FALSE;

    if( phMasterKeyIn->dwVersion > MASTERKEY_STORED_VERSION )
        return FALSE;

    ZeroMemory( phMasterKeyOut, sizeof(MASTERKEY_STORED) );

    phMasterKeyOut->dwVersion = phMasterKeyIn->dwVersion;
    phMasterKeyOut->dwPolicy = phMasterKeyIn->dwPolicy;
    phMasterKeyOut->fModified = FALSE;

    if( lstrlenW( phMasterKeyIn->wszguidMasterKey ) > MAX_GUID_SZ_CHARS )
        return FALSE;

    CopyMemory(phMasterKeyOut->wszguidMasterKey, phMasterKeyIn->wszguidMasterKey, MAX_GUID_SZ_CHARS * sizeof(WCHAR));

    if( phMasterKeyIn->szFilePath ) {
        DWORD cbFilePath = (lstrlenW(phMasterKeyIn->szFilePath) + 1) * sizeof(WCHAR);

        phMasterKeyOut->szFilePath = (LPWSTR)SSAlloc( cbFilePath );
        if(phMasterKeyOut->szFilePath == NULL)
            goto cleanup;

        CopyMemory( phMasterKeyOut->szFilePath, phMasterKeyIn->szFilePath, cbFilePath );
    }

    if( phMasterKeyIn->pbMK ) {
        phMasterKeyOut->cbMK = phMasterKeyIn->cbMK;
        phMasterKeyOut->pbMK = (PBYTE)SSAlloc(phMasterKeyIn->cbMK);
        if(phMasterKeyOut->pbMK == NULL)
            goto cleanup;

        CopyMemory( phMasterKeyOut->pbMK, phMasterKeyIn->pbMK, phMasterKeyIn->cbMK );
    }


    if( phMasterKeyIn->pbLK ) {
        phMasterKeyOut->cbLK = phMasterKeyIn->cbLK;
        phMasterKeyOut->pbLK = (PBYTE)SSAlloc(phMasterKeyIn->cbLK);
        if(phMasterKeyOut->pbLK == NULL)
            goto cleanup;

        CopyMemory( phMasterKeyOut->pbLK, phMasterKeyIn->pbLK, phMasterKeyIn->cbLK );
    }

    if( phMasterKeyIn->pbBK ) {
        phMasterKeyOut->cbBK = phMasterKeyIn->cbBK;
        phMasterKeyOut->pbBK = (PBYTE)SSAlloc(phMasterKeyIn->cbBK);
        if(phMasterKeyOut->pbBK == NULL)
            goto cleanup;

        CopyMemory( phMasterKeyOut->pbBK, phMasterKeyIn->pbBK, phMasterKeyIn->cbBK );
    }

    if( phMasterKeyIn->pbBBK ) {
        phMasterKeyOut->cbBBK = phMasterKeyIn->cbBBK;
        phMasterKeyOut->pbBBK = (PBYTE)SSAlloc(phMasterKeyIn->cbBBK);
        if(phMasterKeyOut->pbBBK == NULL)
            goto cleanup;

        CopyMemory( phMasterKeyOut->pbBBK, phMasterKeyIn->pbBBK, phMasterKeyIn->cbBBK );
    }

    fSuccess = TRUE;

cleanup:

    if( !fSuccess )
        FreeMasterKey( phMasterKeyOut );

    return fSuccess;
}


BOOL
InitializeKeyManagement(
    VOID
    )
{
    if(!InitializeKeyCache())
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
TeardownKeyManagement(
    VOID
    )
{

    DeleteKeyCache();

    return TRUE;
}


DWORD
DpapiUpdateLsaSecret(
    IN PVOID pvContext)
{
    CRYPT_SERVER_CONTEXT SystemContext;
    CRYPT_SERVER_CONTEXT SystemUserContext;
    LPWSTR pszUserStorageArea = NULL;
    BOOL fSystemContextCreated = FALSE;
    BOOL fSystemUserContextCreated = FALSE;
    BOOL fNewSecretCreated = TRUE;
    GUID guidMasterKey;
    BOOL fOverrideToLocalSystem;
    DWORD dwRet;

    D_DebugLog((DEB_TRACE_API, "DpapiUpdateLsaSecret\n"));


    //
    // TCB privilege must be held by the client in order to
    // make this call.  Verify that before doing anything else
    //

    dwRet = CPSImpersonateClient( pvContext );

    if(dwRet == ERROR_SUCCESS) 
    {
        HANDLE ClientToken;

        dwRet = NtOpenThreadToken(
                     NtCurrentThread(),
                     TOKEN_QUERY,
                     TRUE,
                     &ClientToken
                     );

        if ( NT_SUCCESS( dwRet )) 
        {
            BOOLEAN Result = FALSE;
            PRIVILEGE_SET RequiredPrivileges;
            LUID_AND_ATTRIBUTES PrivilegeArray[1];

            RequiredPrivileges.PrivilegeCount = 1;
            RequiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
            RequiredPrivileges.Privilege[0].Luid = RtlConvertLongToLuid( SE_TCB_PRIVILEGE );
            RequiredPrivileges.Privilege[0].Attributes = 0;

            dwRet = NtPrivilegeCheck(
                         ClientToken,
                         &RequiredPrivileges,
                         &Result
                         );

            if ( NT_SUCCESS( dwRet ) &&
                 Result == FALSE ) 
            {
                dwRet = STATUS_PRIVILEGE_NOT_HELD;
            }

            NtClose( ClientToken );
            ClientToken = NULL;
        }

        CPSRevertToSelf( pvContext );
    }

    if(!NT_SUCCESS(dwRet))
    {
        D_DebugLog((DEB_ERROR, "DpapiUpdateLsaSecret: TCB privilege required!\n"));
        goto cleanup;
    }


    //
    // Enumerate through all of the master keys in the Protect\S-1-5-18  
    // directory, and load them all up in the master key cache.
    //

    D_DebugLog((DEB_TRACE, "Load system master keys into cache\n"));

    dwRet = CPSCreateServerContext(&SystemContext, NULL);
    if(dwRet != ERROR_SUCCESS)
    {
        goto cleanup;
    }
    fSystemContextCreated = TRUE;

    fOverrideToLocalSystem = TRUE; 
    CPSOverrideToLocalSystem(&SystemContext, &fOverrideToLocalSystem, NULL);

    dwRet = SynchronizeMasterKeys(&SystemContext, ADD_MASTER_KEY_TO_CACHE);
    if(dwRet != ERROR_SUCCESS)
    {
        goto cleanup;
    }


    //
    // Enumerate through all of the master keys in the Protect\S-1-5-18\User 
    // directory, and load them all up in the master key cache.
    //

    dwRet = CPSCreateServerContext(&SystemUserContext, NULL);
    if(dwRet != ERROR_SUCCESS)
    {
        goto cleanup;
    }
    fSystemUserContextCreated = TRUE;

    dwRet = SynchronizeMasterKeys(&SystemUserContext, ADD_MASTER_KEY_TO_CACHE);
    if(dwRet != ERROR_SUCCESS)
    {
        goto cleanup;
    }


    //
    // Regenerate the DPAPI_SYSTEM value.
    //

    D_DebugLog((DEB_TRACE, "Reset lsa secret\n"));

    if(!UpdateSystemCredentials())
    {
        fNewSecretCreated = FALSE;
        DebugLog((DEB_ERROR, "Unable to reset DPAPI_SYSTEM secret.\n"));
    }


    //
    // Reencrypt and write back all of the master keys that are in the cache.
    // Note that since this routine should only be called on brand-new machines
    // that have just been setup using SYSPREP, the total number of master keys
    // should always be exactly two. Thus, we shouldn't have to worry about
    // overflowing the master key cache or anything like that.
    //

    D_DebugLog((DEB_TRACE, "Reencrypt system master keys\n"));

    if(fNewSecretCreated)
    {
        SynchronizeMasterKeys(&SystemContext, REENCRYPT_MASTER_KEY);
        SynchronizeMasterKeys(&SystemUserContext, REENCRYPT_MASTER_KEY);
    }


    //
    // Generate two new master keys, and mark them as preferred.
    //

    D_DebugLog((DEB_TRACE, "Generate new system master keys\n"));

    dwRet = CPSGetUserStorageArea( &SystemContext, 
                                   NULL, 
                                   FALSE, 
                                   &pszUserStorageArea );
    if(dwRet == ERROR_SUCCESS)
    {
        dwRet = CreateMasterKey( &SystemContext, pszUserStorageArea, &guidMasterKey, FALSE );
        if(dwRet == ERROR_SUCCESS)
        {
            SetPreferredMasterKeyGuid( &SystemContext, pszUserStorageArea, &guidMasterKey );
        }

        SSFree(pszUserStorageArea);
        pszUserStorageArea = NULL;
    }
    else if(dwRet == ERROR_PATH_NOT_FOUND)
    {
        dwRet = ERROR_SUCCESS;
    }

    dwRet = CPSGetUserStorageArea( &SystemUserContext, 
                                   NULL, 
                                   FALSE, 
                                   &pszUserStorageArea );
    if(dwRet == ERROR_SUCCESS)
    {
        dwRet = CreateMasterKey( &SystemUserContext, pszUserStorageArea, &guidMasterKey, FALSE );
        if(dwRet == ERROR_SUCCESS)
        {
            SetPreferredMasterKeyGuid( &SystemUserContext, pszUserStorageArea, &guidMasterKey );
        }
    
        SSFree(pszUserStorageArea);
        pszUserStorageArea = NULL;
    }
    else if(dwRet == ERROR_PATH_NOT_FOUND)
    {
        dwRet = ERROR_SUCCESS;
    }


    //
    // Cleanup.
    //

cleanup:

    if(fSystemContextCreated)
    {
        CPSDeleteServerContext( &SystemContext );
    }

    if(fSystemUserContextCreated)
    {
        CPSDeleteServerContext( &SystemUserContext );
    }

    D_DebugLog((DEB_TRACE_API, "DpapiUpdateLsaSecret returned 0x%x\n", dwRet));

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\keycache.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    keycache.h

Abstract:

    This module contains routines for accessing cached masterkeys.

Author:

    Scott Field (sfield)    07-Nov-98

Revision History:

--*/

#include <pch.cpp>
#pragma hdrstop

//
// masterkey cache.
//

typedef struct {
    LIST_ENTRY Next;
    LUID LogonId;
    GUID guidMasterKey;
    FILETIME ftLastAccess;
    DWORD cbMasterKey;
    BYTE pbMasterKey[ 64 ];
} MASTERKEY_CACHE_ENTRY, *PMASTERKEY_CACHE_ENTRY, *LPMASTERKEY_CACHE_ENTRY;

RTL_CRITICAL_SECTION g_MasterKeyCacheCritSect;
LIST_ENTRY g_MasterKeyCacheList;



BOOL
RemoveMasterKeyCache(
    IN      PLUID pLogonId
    );



BOOL
SearchMasterKeyCache(
    IN      PLUID pLogonId,
    IN      GUID *pguidMasterKey,
    IN  OUT PBYTE *ppbMasterKey,
        OUT PDWORD pcbMasterKey
    )
/*++

    Search the masterkey sorted masterkey cache by pLogonId then by
    pguidMasterKey.

    On success, return value is true, and ppbMasterKey will point to a buffer
    allocated on behalf of the caller containing the specified masterkey.
    The caller must free the buffer using SSFree().

--*/
{
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    BOOL fSuccess = FALSE;

    RtlEnterCriticalSection( &g_MasterKeyCacheCritSect );

    ListHead = &g_MasterKeyCacheList;

    for( ListEntry = ListHead->Flink;
         ListEntry != ListHead;
         ListEntry = ListEntry->Flink ) {

        PMASTERKEY_CACHE_ENTRY pCacheEntry;
        signed int comparator;

        pCacheEntry = CONTAINING_RECORD( ListEntry, MASTERKEY_CACHE_ENTRY, Next );

        //
        // search by LogonId, then by GUID.
        //

        comparator = memcmp(pLogonId, &pCacheEntry->LogonId, sizeof(LUID));

        if( comparator < 0 )
            continue;

        if( comparator > 0 )
            break;

        comparator = memcmp(pguidMasterKey, &pCacheEntry->guidMasterKey, sizeof(GUID));

        if( comparator < 0 )
            continue;

        if( comparator > 0 )
            break;

        //
        // match found.
        //

        *pcbMasterKey = pCacheEntry->cbMasterKey;
        *ppbMasterKey = (PBYTE)SSAlloc( *pcbMasterKey );
        if( *ppbMasterKey != NULL ) {
            CopyMemory( *ppbMasterKey, pCacheEntry->pbMasterKey, *pcbMasterKey );
            fSuccess = TRUE;
        }


        //
        // update last access time.
        //

        GetSystemTimeAsFileTime( &pCacheEntry->ftLastAccess );

        break;
    }


    RtlLeaveCriticalSection( &g_MasterKeyCacheCritSect );

    if( fSuccess ) {

        //
        // decrypt (in-place) the returned encrypted cache entry.
        //

        LsaUnprotectMemory( *ppbMasterKey, *pcbMasterKey );
    }

    return fSuccess;

}

BOOL
InsertMasterKeyCache(
    IN      PLUID pLogonId,
    IN      GUID *pguidMasterKey,
    IN      PBYTE pbMasterKey,
    IN      DWORD cbMasterKey
    )
/*++

    Insert the specified masterkey into the cahce sorted by pLogonId then by
    pguidMasterKey.

    The return value is TRUE on success.

--*/
{
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    PMASTERKEY_CACHE_ENTRY pCacheEntry;
    PMASTERKEY_CACHE_ENTRY pThisCacheEntry = NULL;
    BOOL fInserted = FALSE;

    if( cbMasterKey > sizeof(pCacheEntry->pbMasterKey) )
        return FALSE;

    pCacheEntry = (PMASTERKEY_CACHE_ENTRY)SSAlloc( sizeof( MASTERKEY_CACHE_ENTRY ) );
    if( pCacheEntry == NULL )
        return FALSE;

    CopyMemory( &pCacheEntry->LogonId, pLogonId, sizeof(LUID) );
    CopyMemory( &pCacheEntry->guidMasterKey, pguidMasterKey, sizeof(GUID) );
    pCacheEntry->cbMasterKey = cbMasterKey;
    CopyMemory( pCacheEntry->pbMasterKey, pbMasterKey, cbMasterKey );

    LsaProtectMemory( pCacheEntry->pbMasterKey, cbMasterKey );

    GetSystemTimeAsFileTime( &pCacheEntry->ftLastAccess );

    RtlEnterCriticalSection( &g_MasterKeyCacheCritSect );

    ListHead = &g_MasterKeyCacheList;

    for( ListEntry = ListHead->Flink;
         ListEntry != ListHead;
         ListEntry = ListEntry->Flink ) {

        signed int comparator;

        pThisCacheEntry = CONTAINING_RECORD( ListEntry, MASTERKEY_CACHE_ENTRY, Next );

        //
        // insert into list sorted by LogonId, then sorted by GUID.
        //

        comparator = memcmp(pLogonId, &pThisCacheEntry->LogonId, sizeof(LUID));

        if( comparator < 0 )
            continue;

        if( comparator == 0 ) {
            comparator = memcmp( pguidMasterKey, &pThisCacheEntry->guidMasterKey, sizeof(GUID));

            if( comparator < 0 )
                continue;

            if( comparator == 0 ) {

                //
                // don't insert duplicate records.
                // this would only happen in a race condition with multiple threads.
                //

                ZeroMemory( pCacheEntry, sizeof(MASTERKEY_CACHE_ENTRY) );
                SSFree( pCacheEntry );
                fInserted = TRUE;
                break;
            }
        }


        //
        // insert prior to current record.
        //

        InsertHeadList( pThisCacheEntry->Next.Blink, &pCacheEntry->Next );
        fInserted = TRUE;
        break;
    }

    if( !fInserted ) {
        if( pThisCacheEntry == NULL ) {
            InsertHeadList( ListHead, &pCacheEntry->Next );
        } else {
            InsertHeadList( &pThisCacheEntry->Next, &pCacheEntry->Next );
        }
    }

    RtlLeaveCriticalSection( &g_MasterKeyCacheCritSect );

    return TRUE;
}

BOOL
PurgeMasterKeyCache(
    VOID
    )
/*++

    Purge masterkey cache of timed-out entries, or entries associated with
    terminated logon sessions.

--*/
{
    //
    // build active session table.
    //

    // don't touch entries that have an entry in active session table.
    // assume LUID_SYSTEM in table.
    //

    // entries not in table: discard after 15 minute timeout.
    //


    // if entry in table, find next LUID
    // else, if entry expired, check timeout.  if expired, remove.
    //

    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;


    RtlEnterCriticalSection( &g_MasterKeyCacheCritSect );

    ListHead = &g_MasterKeyCacheList;

    for( ListEntry = ListHead->Flink;
         ListEntry != ListHead;
         ListEntry = ListEntry->Flink ) {

        PMASTERKEY_CACHE_ENTRY pCacheEntry;
//        signed int comparator;

        pCacheEntry = CONTAINING_RECORD( ListEntry, MASTERKEY_CACHE_ENTRY, Next );
    }


    RtlLeaveCriticalSection( &g_MasterKeyCacheCritSect );

    return FALSE;
}

BOOL
RemoveMasterKeyCache(
    IN      PLUID pLogonId
    )
/*++

    Remove all entries from the masterkey cache corresponding to the specified
    pLogonId.

    The purpose of this routine is to purge the masterkey cache of entries
    associated with (now) non-existent logon sessions.

--*/
{

    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;

    RtlEnterCriticalSection( &g_MasterKeyCacheCritSect );

    ListHead = &g_MasterKeyCacheList;

    for( ListEntry = ListHead->Flink;
         ListEntry != ListHead;
         ListEntry = ListEntry->Flink ) {

        PMASTERKEY_CACHE_ENTRY pCacheEntry;
        signed int comparator;

        pCacheEntry = CONTAINING_RECORD( ListEntry, MASTERKEY_CACHE_ENTRY, Next );

        //
        // remove all entries with matching LogonId.
        //

        comparator = memcmp(pLogonId, &pCacheEntry->LogonId, sizeof(LUID));

        if( comparator > 0 )
            break;

        if( comparator < 0 )
            continue;

        //
        // match found.
        //

        RemoveEntryList( &pCacheEntry->Next );

        ZeroMemory( pCacheEntry, sizeof(MASTERKEY_CACHE_ENTRY) );
        SSFree( pCacheEntry );
    }


    RtlLeaveCriticalSection( &g_MasterKeyCacheCritSect );

    return TRUE;
}



BOOL
InitializeKeyCache(
    VOID
    )
{
    NTSTATUS Status;
    
    Status = RtlInitializeCriticalSection( &g_MasterKeyCacheCritSect );
    if(!NT_SUCCESS(Status))
    {
        return FALSE;
    }

    InitializeListHead( &g_MasterKeyCacheList );

    return TRUE;
}


VOID
DeleteKeyCache(
    VOID
    )
{

    //
    // remove all list entries.
    //

    RtlEnterCriticalSection( &g_MasterKeyCacheCritSect );

    while ( !IsListEmpty( &g_MasterKeyCacheList ) ) {

        PMASTERKEY_CACHE_ENTRY pCacheEntry;

        pCacheEntry = CONTAINING_RECORD(
                                g_MasterKeyCacheList.Flink,
                                MASTERKEY_CACHE_ENTRY,
                                Next
                                );

        RemoveEntryList( &pCacheEntry->Next );

        ZeroMemory( pCacheEntry, sizeof(MASTERKEY_CACHE_ENTRY) );
        SSFree( pCacheEntry );
    }

    RtlLeaveCriticalSection( &g_MasterKeyCacheCritSect );

    RtlDeleteCriticalSection( &g_MasterKeyCacheCritSect );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\dpapi.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dpapi.cpp

Abstract:

    This module contains the DPAPI initialization routines, called by the LSA

Author:

    Pete Skelly (petesk)    22-Mar-00
--*/


#include <pch.cpp>
#pragma hdrstop
#include "pasrec.h"

CCryptProvList*     g_pCProvList = NULL;

TOKEN_SOURCE DPAPITokenSource;

PLSA_SECPKG_FUNCTION_TABLE g_pSecpkgTable;


#ifdef RETAIL_LOG_SUPPORT
HANDLE g_hParamEvent = NULL;
HKEY   g_hKeyParams  = NULL;
HANDLE g_hWait       = NULL;

DEFINE_DEBUG2(DPAPI);

DEBUG_KEY DPAPIDebugKeys[] = { 
    {DEB_ERROR,         "Error"},
    {DEB_WARN,          "Warn"},
    {DEB_TRACE,         "Trace"},
    {DEB_TRACE_API,     "API"},
    {DEB_TRACE_CRED,    "Cred"},
    {DEB_TRACE_CTXT,    "Ctxt"},
    {DEB_TRACE_LSESS,   "LSess"},
    {DEB_TRACE_LOGON,   "Logon"},
    {DEB_TRACE_TIME,    "Time"},
    {DEB_TRACE_LOCKS,   "Locks"},
    {DEB_TRACE_LEAKS,   "Leaks"},
    {0,                  NULL},
};

VOID
DPAPIWatchParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus);

VOID
DPAPIInitializeDebugging(
    BOOL fMonitorRegistry)
{
    DPAPIInitDebug(DPAPIDebugKeys);

    if(fMonitorRegistry)
    {
        g_hParamEvent = CreateEvent(NULL,
                               FALSE,
                               FALSE,
                               NULL);

        if (NULL == g_hParamEvent) 
        {
            D_DebugLog((DEB_WARN, "CreateEvent for ParamEvent failed - 0x%x\n", GetLastError()));
        } 
        else 
        {
            DPAPIWatchParamKey(g_hParamEvent, FALSE);
        }
    }
}

////////////////////////////////////////////////////////////////////
//
//  Name:       DPAPIGetRegParams
//
//  Synopsis:   Gets the debug paramaters from the registry 
//
//  Arguments:  HKEY to HKLM/System/CCS/LSA/DPAPI
//
//  Notes:      Sets DPAPIInfolevel for debug spew
//
void
DPAPIGetRegParams(HKEY ParamKey)
{

    DWORD       cbType, tmpInfoLevel = DPAPIInfoLevel, cbSize = sizeof(DWORD);
    DWORD       dwErr;
 
    dwErr = RegQueryValueExW(
        ParamKey,
        WSZ_DPAPIDEBUGLEVEL,
        NULL,
        &cbType,
        (LPBYTE)&tmpInfoLevel,
        &cbSize      
        );
    if (dwErr != ERROR_SUCCESS)
    {
        if (dwErr ==  ERROR_FILE_NOT_FOUND)
        {
            // no registry value is present, don't want info
            // so reset to defaults
#if DBG
            DPAPIInfoLevel = DEB_ERROR;
            
#else // fre
            DPAPIInfoLevel = 0;
#endif
        }
        else
        {
            D_DebugLog((DEB_WARN, "Failed to query DebugLevel: 0x%x\n", dwErr));
        }      
    }

    // TBD:  Validate flags?
    DPAPIInfoLevel = tmpInfoLevel;
    dwErr = RegQueryValueExW(
               ParamKey,
               WSZ_FILELOG,
               NULL,
               &cbType,
               (LPBYTE)&tmpInfoLevel,
               &cbSize      
               );

    if (dwErr == ERROR_SUCCESS)
    {                                                
       DPAPISetLoggingOption((BOOL)tmpInfoLevel);
    }
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
       DPAPISetLoggingOption(FALSE);
    }
    
    return;
}

////////////////////////////////////////////////////////////////////
//
//  Name:       DPAPIWaitCleanup
//
//  Synopsis:   Cleans up wait from DPAPIWatchParamKey()
//
//  Arguments:  <none>
//
//  Notes:      .
//
void
DPAPIWaitCleanup()
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (NULL != g_hWait) 
    {
        Status = RtlDeregisterWait(g_hWait);               
        if (NT_SUCCESS(Status) && NULL != g_hParamEvent ) 
        {
            CloseHandle(g_hParamEvent);
        }      
    }                                  
}



////////////////////////////////////////////////////////////////////
//
//  Name:       DPAPIWatchParamKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on param key, initializes
//              debug level, then utilizes thread pool to wait on
//              changes to this registry key.  Enables dynamic debug
//              level changes, as this function will also be callback
//              if registry key modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//
VOID
DPAPIWatchParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus)
{
    NTSTATUS    Status;
    LONG        lRes = ERROR_SUCCESS;
   
    if (NULL == g_hKeyParams)  // first time we've been called.
    {
        lRes = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    DPAPI_PARAMETER_PATH,
                    0,
                    KEY_READ,
                    &g_hKeyParams);

        if (ERROR_SUCCESS != lRes)
        {
            D_DebugLog((DEB_WARN,"Failed to open DPAPI key: 0x%x\n", lRes));
            goto Reregister;
        }
    }

    if (NULL != g_hWait) 
    {
        Status = RtlDeregisterWait(g_hWait);
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
            goto Reregister;
        }

    }
    
    lRes = RegNotifyChangeKeyValue(
                g_hKeyParams,
                FALSE,
                REG_NOTIFY_CHANGE_LAST_SET,
                (HANDLE) pCtxt,
                TRUE);

    if (ERROR_SUCCESS != lRes) 
    {
        D_DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
        // we're tanked now. No further notifications, so get this one
    }
                   
    DPAPIGetRegParams(g_hKeyParams);
    
Reregister:
    
    Status = RtlRegisterWait(&g_hWait,
                             (HANDLE) pCtxt,
                             DPAPIWatchParamKey,
                             (HANDLE) pCtxt,
                             INFINITE,
                             WT_EXECUTEINPERSISTENTIOTHREAD|
                             WT_EXECUTEONLYONCE);

}                       
                        
#endif // RETAIL_LOG_SUPPORT


//
//  FUNCTION: DPAPIInitialize
//
//  COMMENTS:
//  

DWORD
NTAPI
DPAPIInitialize(
    LSA_SECPKG_FUNCTION_TABLE *pSecpkgTable)
{
    DWORD dwLastError = ERROR_SUCCESS;
    BOOL fStartedKeyService = FALSE;
    BOOL bListConstruct = FALSE;
    LONG        lRes = ERROR_SUCCESS;

    RPC_STATUS status;

    dwLastError = RtlInitializeCriticalSection(&g_csCredHistoryCache);
    if(!NT_SUCCESS(dwLastError))
    {
        goto cleanup;
    }

    DPAPIInitializeDebugging(TRUE);


    // Initialize stuff necessary to create tokens etc, just as if 
    // we're a security package. 
    g_pSecpkgTable = pSecpkgTable;

    CopyMemory( DPAPITokenSource.SourceName, DPAPI_PACKAGE_NAME_A, strlen(DPAPI_PACKAGE_NAME_A) );
    AllocateLocallyUniqueId( &DPAPITokenSource.SourceIdentifier );



    g_pCProvList = new CCryptProvList;
    if(g_pCProvList)
    {
        if(!g_pCProvList->Initialize())
        {
            delete g_pCProvList;
            g_pCProvList = NULL;
        }
    }

    IntializeGlobals();

    if(!InitializeKeyManagement())
    {
        dwLastError = STATUS_NO_MEMORY;
        goto cleanup;
    }

    status = RpcServerUseProtseqEpW(DPAPI_LOCAL_PROT_SEQ,   //ncalrpc 
                                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT, 
                                    DPAPI_LOCAL_ENDPOINT,   //protected_storage
                                    NULL);              //Security Descriptor

    if(RPC_S_DUPLICATE_ENDPOINT == status)
    {
        status = RPC_S_OK;
    }

    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }
    status = RpcServerUseProtseqEpW(DPAPI_BACKUP_PROT_SEQ,   //ncalrpc 
                                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT, 
                                    DPAPI_BACKUP_ENDPOINT,   //protected_storage
                                    NULL);              //Security Descriptor

    if(RPC_S_DUPLICATE_ENDPOINT == status)
    {
        status = RPC_S_OK;
    }

    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }

    status = RpcServerRegisterIfEx(s_ICryptProtect_v1_0_s_ifspec, 
                                   NULL, 
                                   NULL,
                                   RPC_IF_AUTOLISTEN,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   NULL);

    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }


    status = RpcServerRegisterIfEx(s_PasswordRecovery_v1_0_s_ifspec, 
                                   NULL, 
                                   NULL,
                                   RPC_IF_AUTOLISTEN,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   NULL);

    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }

    //
    // Start the Backup Key server
    // note: it only starts when the current machine is an domain controller.
    //

    dwLastError = StartBackupKeyServer();
    if(dwLastError != ERROR_SUCCESS) {
        goto cleanup;
    }

    return dwLastError;

cleanup:
    DPAPIShutdown();
    return dwLastError;
}



DWORD
NTAPI
DPAPIShutdown(  )
{
    //
    // ignore errors because we are shutting down
    //

    RpcServerUnregisterIf(s_ICryptProtect_v1_0_s_ifspec, 0, 0);

    //
    // stop backup key server
    // Note:  this function knows internally whether the backup key server
    // really started or not.
    //

    StopBackupKeyServer();


    if(g_pCProvList)
    {
        delete g_pCProvList;
        g_pCProvList = NULL;
    }

    TeardownKeyManagement();
    
    ShutdownGlobals();
    return ERROR_SUCCESS;
}

#ifdef RETAIL_LOG_SUPPORT
VOID
DPAPIDumpHexData(
    DWORD LogLevel,
    PSTR  pszPrefix,
    PBYTE pbData,
    DWORD cbData)
{
    DWORD i,count;
    CHAR digits[]="0123456789abcdef";
    CHAR pbLine[MAX_PATH];
    DWORD cbLine;
    DWORD cbHeader;
    DWORD_PTR address;

    if((DPAPIInfoLevel & LogLevel) == 0)
    {
        return;
    }

    if(pbData == NULL || cbData == 0)
    {
        return;
    }

    if(pszPrefix)
    {
        strcpy(pbLine, pszPrefix);
        cbHeader = strlen(pszPrefix);
    }
    else
    {
        pbLine[0] = '\0';
        cbHeader = 0;
    }

    for(; cbData ; cbData -= count, pbData += count)
    {
        count = (cbData > 16) ? 16:cbData;

        cbLine = cbHeader;

        address = (DWORD_PTR)pbData;

#if defined(_WIN64)
        pbLine[cbLine++] = digits[(address >> 0x3c) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x38) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x34) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x30) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x2c) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x28) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x24) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x20) & 0x0f];
#endif

        pbLine[cbLine++] = digits[(address >> 0x1c) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x18) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x14) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x10) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x0c) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x08) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x04) & 0x0f];
        pbLine[cbLine++] = digits[(address        ) & 0x0f];
        pbLine[cbLine++] = ' ';
        pbLine[cbLine++] = ' ';

        for(i = 0; i < count; i++)
        {
            pbLine[cbLine++] = digits[pbData[i]>>4];
            pbLine[cbLine++] = digits[pbData[i]&0x0f];
            if(i == 7)
            {
                pbLine[cbLine++] = ':';
            }
            else
            {
                pbLine[cbLine++] = ' ';
            }
        }

        for(; i < 16; i++)
        {
            pbLine[cbLine++] = ' ';
            pbLine[cbLine++] = ' ';
            pbLine[cbLine++] = ' ';
        }

        pbLine[cbLine++] = ' ';

        for(i = 0; i < count; i++)
        {
            if(pbData[i] < 32 || pbData[i] > 126)
            {
                pbLine[cbLine++] = '.';
            }
            else
            {
                pbLine[cbLine++] = pbData[i];
            }
        }

        pbLine[cbLine++] = '\n';
        pbLine[cbLine++] = 0;

        D_DebugLog((LogLevel, pbLine));
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\keysrv.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    keybckup.cpp

Abstract:

    This module contains routines associated with server side Key Backup
    operations.

    User sends data D2 to remote agent (remote agent is this code)
    Agent uses secret monster key K, random R2, HMACs to derive SymKeyK.
    Use SymKeyK to encrypt {userid, D2}
    Agent returns recovery field E{userid, D2}, R2 to User
    User stores recovery field E{userid, D2}, R2

Author:

    Scott Field (sfield)    16-Aug-97

--*/

#include <pch.cpp>
#pragma hdrstop
#include <ntlsa.h>

//
// functions to backup and restore to/from recoverable blob
//

BOOL
BackupToRecoverableBlobW2K(
    IN      HANDLE hToken,  // client access token opened for TOKEN_QUERY
    IN      BYTE *pDataIn,
    IN      DWORD cbDataIn,
    IN  OUT BYTE **ppDataOut,
    IN  OUT DWORD *pcbDataOut
    );

BOOL
RestoreFromRecoverableBlob(
    IN      HANDLE  hToken,
    IN      BOOL    fWin2kDataOut,
    IN      BYTE  * pDataIn,
    IN      DWORD   cbDataIn,
    IN  OUT BYTE ** ppDataOut,
    IN  OUT DWORD * pcbDataOut
    );


BOOL
RestoreFromRecoverableBlobW2K(
    IN      HANDLE hToken,  // client access token opened for TOKEN_QUERY
    IN      BYTE *pDataIn,
    IN      DWORD cbDataIn,
    IN  OUT BYTE **ppDataOut,
    IN  OUT DWORD *pcbDataOut
    );



BOOL ConvertRecoveredBlobToW2KBlob(
    IN      BYTE *pbMasterKey,
    IN      DWORD cbMaserKey,
    IN      PBYTE pbLocalKey,
    IN      DWORD cbLocalKey,
    IN      PSID pSidCandidate,
    IN  OUT BYTE **ppbDataOut,
    IN  OUT DWORD *pcbDataOut);



//
// functions to get/create/set keys to persistent storage.
//

BOOL
GetBackupKey(
    IN      GUID *pguidKey,
        OUT PBYTE *ppbKey,
        OUT DWORD *pcbKey,
        OUT HCRYPTPROV *phCryptProv,
        OUT HCRYPTKEY  *phCryptKey
    );

BOOL
CreateBackupKeyW2K(
    IN      DWORD dwKeyVersion,
    IN  OUT GUID *pguidKey,
        OUT PBYTE *ppbKey,
        OUT DWORD *pcbKey);

BOOL
CreateBackupKey(
    IN      DWORD dwKeyVersion,
    IN  OUT GUID *pguidKey,
        OUT PBYTE *ppbKey,
        OUT DWORD *pcbKey,
        OUT HCRYPTPROV *phCryptProv,
        OUT HCRYPTKEY  *phCryptKey
    );

BOOL
SaveBackupKey(
    IN      GUID *pguidKey,
    IN      BYTE *pbKey,
    IN      DWORD cbKey
    );

BOOL
DestroyBackupKey(
    IN      GUID guidKey
    );

//
// functions to get/create/set the preferred backup key.
//

BOOL
SetupPreferredBackupKeys(
    VOID
    );



BOOL
FreePreferredBackupKey(
    VOID
    );

//
// helper functions to set/get the GUID associated with the preferred
// backup key.
//

BOOL
GetPreferredBackupKeyGuid(
    IN      DWORD dwVersion,
    IN  OUT GUID *pguidKey
    );

BOOL
SetPreferredBackupKeyGuid(
    IN      DWORD dwVersion,
    IN      GUID *pguidKey
    );

//
// helper functions for managing SYSTEM credentials.
//

BOOL
CreateSystemCredentials(
    VOID
    );

DWORD
QuerySystemCredentials(
    IN  OUT BYTE rgbSystemCredMachine[ A_SHA_DIGEST_LEN ],
    IN  OUT BYTE rgbSystemCredUser [ A_SHA_DIGEST_LEN ]
    );

BOOL
FreeSystemCredentials(
    VOID
    );

BOOL GeneratePublicKeyCert(HCRYPTPROV hCryptProv,
                           HCRYPTKEY hCryptKey,
                           GUID *pguidKey,
                           DWORD *pcbPublicExportLength,
                           PBYTE *ppbPublicExportData);

//
// utility functions for interacting with LSA, etc.
//


NTSTATUS
OpenPolicy(
    LPWSTR ServerName,          // machine to open policy on (Unicode)
    DWORD DesiredAccess,        // desired access to policy
    PLSA_HANDLE PolicyHandle    // resultant policy handle
    );

BOOL
WaitOnSAMDatabase(
    VOID
    );


//
// typedef's so that we can dynamically link to API calls which
// aren't exported in Win95 .dll files.  static linking would
// prevent the image from running on Win95.
//

typedef NTSTATUS (NTAPI *NTOPENEVENT)(
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );




#define FILETIME_TICKS_PER_SECOND  10000000
#define BACKUPKEY_LIFETIME 60*60*24*365 // 1 Year


//
// private defines and prototypes for the backup and restore
// blob operations.
//

#define BACKUPKEY_VERSION_W2K   1       // legacy version of monster key material
#define BACKUPKEY_MATERIAL_SIZE (256)   // monster key material size, excluding version, etc.


#define BACKUPKEY_VERSION       2       // legacy version of monster key material
//
// LSA secret key name prefix, textual GUID key ID follows
//
#define BACKUPKEY_NAME_PREFIX   L"G$BCKUPKEY_"

//
// LSA secret key name - identifies GUID of legacy preferred key
//
#define BACKUPKEY_PREFERRED_W2K     L"G$BCKUPKEY_P"

//
// LSA secret key name - identifies GUID of preferred key
//
#define BACKUPKEY_PREFERRED         L"G$BCKUPKEY_PREFERRED"

//
// exposed Random R2 used to derive symetric key from monster key
// BACKUPKEY_R2_LEN makes BACKUPKEY_RECOVERY_BLOB size mod 32.
//
#define BACKUPKEY_R2_LEN        (68)        // length of random HMAC data

//
// size of inner Random R3 used to derive MAC key.
//

#define BACKUPKEY_R3_LEN        (32)

typedef struct {
    DWORD dwVersion;            // version of structure (BACKUPKEY_RECOVERY_BLOB_VERSION)
    DWORD cbClearData;          // quantity of clear data, not including Sid
    DWORD cbCipherData;         // quantity of cipher data following structure
    GUID guidKey;               // guid identifying backup key used
    BYTE R2[BACKUPKEY_R2_LEN];  // random data used during HMAC to derive symetric key
} BACKUPKEY_RECOVERY_BLOB_W2K, 
     *PBACKUPKEY_RECOVERY_BLOB_W2K, 
     *LPBACKUPKEY_RECOVERY_BLOB_W2K;

//
// when dwOuterVersion is 1,
// BYTE bCipherData[cbCipherData] follows
//
// in the clear, bCipherData is
// struct BACKUPKEY_INNER_BLOB
// BYTE bUserClearData[cbClearData]
// SID data follows bUserClearData[cbClearData]
// GetLengthSid() yields sid data length, IsValidSid() used to validate
// structural integrity of data.  Further authentication of requesting user
// done when restore requested.
//

typedef struct {
    BYTE R3[BACKUPKEY_R3_LEN];  // random data used to derive MAC key
    BYTE MAC[A_SHA_DIGEST_LEN]; // HMAC(R3, pUserSid | pbClearUserData)
} BACKUPKEY_INNER_BLOB_W2K, 
 *PBACKUPKEY_INNER_BLOB_W2K, 
 *LPBACKUPKEY_INNER_BLOB_W2K;



//
// definitions to support credentials for the SYSTEM account.
// this includes two scenarios:
// 1. Calls originating from the local system account security context.
// 2. Calls with the LOCAL_MACHINE disposition.
//

#define SYSTEM_CREDENTIALS_VERSION  1
#define SYSTEM_CREDENTIALS_SECRET   L"DPAPI_SYSTEM"

typedef struct {
    DWORD dwVersion;
    BYTE rgbSystemCredMachine[ A_SHA_DIGEST_LEN ];
    BYTE rgbSystemCredUser[ A_SHA_DIGEST_LEN ];
} SYSTEM_CREDENTIALS, *PSYSTEM_CREDENTIALS, *LPSYSTEM_CREDENTIALS;



//
//  Counter value and name for memory mapped file.
//  See timer.exe...
//
#ifdef DCSTRESS

LPVOID g_pCounter = NULL;
#define WSZ_MAP_OBJECT      L"rpcnt"

#endif // DCSTRESS



BOOL g_fBackupKeyServerStarted = FALSE;


//
// Legacy system preferred backup key
//

GUID g_guidW2KPreferredKey;
PBYTE g_pbW2KPreferredKey = NULL;
DWORD g_cbW2KPreferredKey = 0;


// Public/Private style preferred key
GUID g_guidPreferredKey;
PBYTE g_pbPreferredKey = NULL;
DWORD g_cbPreferredKey = 0;
HCRYPTPROV g_hProvPreferredKey = NULL;
HCRYPTKEY  g_hKeyPreferredKey = NULL;

RTL_CRITICAL_SECTION g_csInitialization;

BOOL g_fSetupPreferredAttempted = FALSE;



//
// global SYSTEM credentials:
//  One is for calls originating from the Local System account security context
//  at per-user disposition;
//  The other key is for calls originating from any account at the per-machine
//  disposition.
//

BOOL g_fSystemCredsInitialized = FALSE;
BYTE g_rgbSystemCredMachine[ A_SHA_DIGEST_LEN ];
BYTE g_rgbSystemCredUser[ A_SHA_DIGEST_LEN ];


DWORD
s_BackuprKey(
    /* [in] */ handle_t h,
    /* [in] */ GUID __RPC_FAR *pguidActionAgent,
    /* [in] */ BYTE __RPC_FAR *pDataIn,
    /* [in] */ DWORD cbDataIn,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppDataOut,
    /* [out] */ DWORD __RPC_FAR *pcbDataOut,
    /* [in] */ DWORD dwParam
    )
/*++

    Server side implemention of the BackupKey() interface.

--*/
{

    static const GUID guidBackup = BACKUPKEY_BACKUP_GUID;
    static const GUID guidRestoreW2K = BACKUPKEY_RESTORE_GUID_W2K;

    static const GUID guidRestore = BACKUPKEY_RESTORE_GUID;
    static const GUID guidRetrieve = BACKUPKEY_RETRIEVE_BACKUP_KEY_GUID;

    HANDLE hToken = NULL;
    PBYTE pTempDataOut;
    BOOL fEncrypt;
    BOOL fSuccess;
    DWORD dwLastError = ERROR_SUCCESS;

    if( !g_fBackupKeyServerStarted )
        return ERROR_INVALID_PARAMETER;

    __try {

        //
        // insure the preferred key is setup.
        //

        if(!SetupPreferredBackupKeys())
            return ERROR_INVALID_PARAMETER;


        //
        // pickup a copy of an access token representing the client.
        //

        dwLastError = RpcImpersonateClient( h );

        if(dwLastError != RPC_S_OK)
            goto cleanup;

        fSuccess = OpenThreadToken(
                        GetCurrentThread(),
                        TOKEN_QUERY,
                        FALSE,
                        &hToken
                        );

        if(!fSuccess)
            dwLastError = GetLastError();

        RpcRevertToSelf();

        if(!fSuccess)
            goto cleanup;


        if(memcmp(pguidActionAgent, &guidRestore, sizeof(GUID)) == 0) 
        {
            if(cbDataIn < sizeof(DWORD))
            {
                // Not enough room for a version 
                return ERROR_INVALID_PARAMETER;
            }

            if(BACKUPKEY_RECOVERY_BLOB_VERSION_W2K == ((DWORD *)pDataIn)[0])
            {
                // The recovery blob is of the legacy style, so simply
                // restore it the old way.
                fSuccess = RestoreFromRecoverableBlobW2K(
                            hToken,
                            pDataIn,
                            cbDataIn,
                            &pTempDataOut,
                            pcbDataOut
                            );
            }
            else if(BACKUPKEY_RECOVERY_BLOB_VERSION == ((DWORD *)pDataIn)[0])
            {
           
                fSuccess = RestoreFromRecoverableBlob(
                            hToken,
                            FALSE,
                            pDataIn,
                            cbDataIn,
                            &pTempDataOut,
                            pcbDataOut
                            );
            }
            else
            {
                return ERROR_INVALID_PARAMETER;
            }
        } 
        else if(memcmp(pguidActionAgent, &guidBackup, sizeof(GUID)) == 0) 
        {
            // We only use the legacy mechanism for backup when the backup
            // method is called.  The real mechanism of backup 
            // requires backup on the client machine alone.

            fSuccess = BackupToRecoverableBlobW2K(
                        hToken,
                        pDataIn,
                        cbDataIn,
                        &pTempDataOut,
                        pcbDataOut
                        );
        } 
        else if(memcmp(pguidActionAgent, &guidRestoreW2K, sizeof(GUID)) == 0) 
        {
            //
            // A legacy client is calling, and always expects a legacy 
            // pbBK style return blob.

            if(cbDataIn < sizeof(DWORD))
            {
                // Not enough room for a version 
                return ERROR_INVALID_PARAMETER;
            }
            if(BACKUPKEY_RECOVERY_BLOB_VERSION_W2K == ((DWORD *)pDataIn)[0])
            {
                // The recovery blob is of the legacy style, so simply
                // restore it the old way.
                fSuccess = RestoreFromRecoverableBlobW2K(
                            hToken,
                            pDataIn,
                            cbDataIn,
                            &pTempDataOut,
                            pcbDataOut
                            );
            }
            else if(BACKUPKEY_RECOVERY_BLOB_VERSION == ((DWORD *)pDataIn)[0])
            {
                // This is a current recovery blob, so restore it the
                // current way
                fSuccess = RestoreFromRecoverableBlob(
                            hToken,
                            TRUE,
                            pDataIn,
                            cbDataIn,
                            &pTempDataOut,
                            pcbDataOut
                            );
            }
            else
            {
                return ERROR_INVALID_PARAMETER;
            }

        } 
        else if(memcmp(pguidActionAgent, &guidRetrieve, sizeof(GUID)) == 0) 
        {
            if((g_cbPreferredKey < 3*sizeof(DWORD)) ||
               (((DWORD *)g_pbPreferredKey)[0] != BACKUPKEY_VERSION) ||
               (((DWORD *)g_pbPreferredKey)[1] + 
                ((DWORD *)g_pbPreferredKey)[2] + 3*sizeof(DWORD) != g_cbPreferredKey))

            {
                return ERROR_INVALID_PARAMETER;
            }
            pTempDataOut = (PBYTE)SSAlloc(((DWORD *)g_pbPreferredKey)[2]);
            if(NULL == pTempDataOut)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            CopyMemory(pTempDataOut, 
                       g_pbPreferredKey + 
                        3*sizeof(DWORD) +
                        ((DWORD *)g_pbPreferredKey)[1],
                       ((DWORD *)g_pbPreferredKey)[2]);

            *pcbDataOut = ((DWORD *)g_pbPreferredKey)[2];
            fSuccess = TRUE;
        } 
        else 
        {
            return ERROR_INVALID_PARAMETER;
        }




        if( fSuccess ) {

            //
            // everything went as planned: tell caller about buffer
            //

            *ppDataOut = pTempDataOut;



#ifdef DCSTRESS

            //
            //  Increment RPC counter for timer.exe, if timer
            //  is running.
            //
            if (g_pCounter)
                (*(DWORD*)g_pCounter)++;

#endif // DCSTRESS



        } else {
            dwLastError = GetLastError();
            if(dwLastError == ERROR_SUCCESS) {
                dwLastError = ERROR_FILE_NOT_FOUND;
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        // TODO: convert to Win Error
        dwLastError = GetExceptionCode();
    }

cleanup:

    if(hToken)
        CloseHandle(hToken);

    return dwLastError;
}


///////////////////////////////////////////////////////////////////
// BackupToRecoverableBlobW2K
//
// This functionality is requested by W2K legacy clients, which
// are passing up the pbBK Backup key to be encrypted into a 
// pbBBK.
//
// We encrypt this verbatim, using a version of 
// BACKUPKEY_RECOVERY_BLOB_BK, indicating that 
// BACKUPKEY_RESTORE_GUID_W2K must be used 
// to recover this blob, not BACKUPKEY_RESTORE_GUID.
//
// Post W2K Recovery blobs are created on the clients, so we need to 
// server code to create them.
// 
///////////////////////////////////////////////////////////////////
BOOL
BackupToRecoverableBlobW2K(
    IN      HANDLE hToken,
    IN      BYTE *pDataIn,
    IN      DWORD cbDataIn,
    IN  OUT BYTE **ppDataOut,
    IN  OUT DWORD *pcbDataOut
    )
{
    PSID pSidUser = NULL;
    DWORD cbSidUser;

    PBACKUPKEY_RECOVERY_BLOB_W2K    pRecoveryBlob;
    DWORD                           cbRecoveryBlob;
    PBACKUPKEY_INNER_BLOB_W2K       pInnerBlob;
    DWORD                           cbInnerBlob;
    PBYTE pbCipherBegin;
    BYTE rgbSymKey[A_SHA_DIGEST_LEN];
    BYTE rgbMacKey[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT sRC4Key;

    DWORD dwLastError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;


    if( pDataIn == NULL || cbDataIn == 0 ||
        ppDataOut == NULL || pcbDataOut == NULL ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *ppDataOut = NULL;

    //
    // get Sid associated with client user.
    //

    if(!GetTokenUserSid( hToken, &pSidUser ))
        return FALSE;

    cbSidUser = GetLengthSid( pSidUser );


    //
    // Calculate the size of the inner blob
    //
    cbInnerBlob = sizeof(BACKUPKEY_INNER_BLOB_W2K) +
                  cbSidUser +
                  cbDataIn;


    //
    // Estimate the size of the encrypted data buffer
    //

    //
    // allocate buffer to contain results
    // RECOVERABLE_BLOB struct + Sid + cbDataIn
    // note that cbDataIn works because we use a stream cipher.
    //

    *pcbDataOut = sizeof(BACKUPKEY_RECOVERY_BLOB_W2K) +
                    sizeof(BACKUPKEY_INNER_BLOB_W2K) +
                    cbSidUser +
                    cbDataIn ;

    *ppDataOut = (LPBYTE)SSAlloc( *pcbDataOut );
    if(*ppDataOut == NULL) {
        dwLastError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto cleanup;
    }

    pRecoveryBlob = (PBACKUPKEY_RECOVERY_BLOB_W2K)*ppDataOut;
    pRecoveryBlob->dwVersion = BACKUPKEY_RECOVERY_BLOB_VERSION_W2K;
    pRecoveryBlob->cbClearData = cbDataIn; // does not include Sid since not handed back on restore
    pRecoveryBlob->cbCipherData = sizeof(BACKUPKEY_INNER_BLOB_W2K) + cbSidUser + cbDataIn;
    CopyMemory( &(pRecoveryBlob->guidKey), &g_guidW2KPreferredKey, sizeof(GUID));

    pInnerBlob = (PBACKUPKEY_INNER_BLOB_W2K)(pRecoveryBlob+1);

    //
    // generate random R2 for SymKey
    //

    if(!RtlGenRandom(pRecoveryBlob->R2, BACKUPKEY_R2_LEN))
        goto cleanup;

    //
    // generate random R3 for MAC
    //

    if(!RtlGenRandom(pInnerBlob->R3, BACKUPKEY_R3_LEN))
        goto cleanup;


    //
    // check that we are dealing with a persisted key version we
    // understand.
    //

    if( ((DWORD*)g_pbW2KPreferredKey)[0] != BACKUPKEY_VERSION_W2K)
        goto cleanup;

    //
    // derive symetric key via HMAC from preferred backup key and
    // random R2.
    //

    if(!FMyPrimitiveHMACParam(
            (LPBYTE)g_pbW2KPreferredKey + sizeof(DWORD),
            g_cbW2KPreferredKey - sizeof(DWORD),
            pRecoveryBlob->R2,
            BACKUPKEY_R2_LEN,
            rgbSymKey
            ))
        goto cleanup;

    //
    // derive MAC key via HMAC from preferred backup key and
    // random R3.
    //

    if(!FMyPrimitiveHMACParam(
            (LPBYTE)g_pbW2KPreferredKey + sizeof(DWORD),
            g_cbW2KPreferredKey - sizeof(DWORD),
            pInnerBlob->R3,
            BACKUPKEY_R3_LEN,
            rgbMacKey   // resultant MAC key
            ))
        goto cleanup;

    //
    // copy pSidUser and pDataIn following inner MAC'ish blob.
    //

    pbCipherBegin = (PBYTE)(pInnerBlob+1);

    CopyMemory( pbCipherBegin, pSidUser, cbSidUser );
    CopyMemory( pbCipherBegin+cbSidUser, pDataIn, cbDataIn );

    //
    // use MAC key to derive result from pSidUser and pDataIn
    //

    if(!FMyPrimitiveHMACParam(
            rgbMacKey,
            sizeof(rgbMacKey),
            pbCipherBegin,
            cbSidUser + cbDataIn,
            pInnerBlob->MAC // resultant MAC for verification.
            ))
        goto cleanup;

    //
    // adjust cipher start point to include R3 and MAC.
    //

    pbCipherBegin = (PBYTE)(pRecoveryBlob+1);


    //
    // initialize rc4 key
    //

    rc4_key(&sRC4Key, sizeof(rgbSymKey), rgbSymKey);

    //
    // encrypt data R3, MAC, pSidUser, pDataIn beyond recovery blob
    //

    rc4(&sRC4Key, pRecoveryBlob->cbCipherData, pbCipherBegin);

    fSuccess = TRUE;

cleanup:

    ZeroMemory( &sRC4Key, sizeof(sRC4Key) );
    ZeroMemory( rgbSymKey, sizeof(rgbSymKey) );

    if(pSidUser)
        SSFree(pSidUser);

    if(!fSuccess) {
        if(*ppDataOut) {
            SSFree(*ppDataOut);
            *ppDataOut = NULL;
        }

        if( dwLastError == ERROR_SUCCESS )
            dwLastError = ERROR_INVALID_DATA;

        SetLastError( dwLastError );
    }

    return fSuccess;
}





BOOL
RestoreFromRecoverableBlobW2K(
    IN      HANDLE hToken,
    IN      BYTE *pDataIn,
    IN      DWORD cbDataIn,
    IN  OUT BYTE **ppDataOut,
    IN  OUT DWORD *pcbDataOut
    )
{
    PSID pSidCandidate;
    DWORD cbSidCandidate;
    BOOL fIsMember;

    PBACKUPKEY_RECOVERY_BLOB_W2K pRecoveryBlob;
    PBACKUPKEY_INNER_BLOB_W2K    pInnerBlob;
    PBYTE                        pbCipherBegin;
    BYTE                         rgbSymKey[A_SHA_DIGEST_LEN];
    BYTE                         rgbMacKey[A_SHA_DIGEST_LEN];
    BYTE                         rgbMacCandidate[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT                sRC4Key;

    PBYTE pbPersistedKey = NULL;
    DWORD cbPersistedKey = 0;
    BOOL fUsedPreferredKey = TRUE; // did we use preferred backup key?

    DWORD dwLastError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;


    if( pDataIn == NULL || cbDataIn == 0 ||
        ppDataOut == NULL || pcbDataOut == NULL ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *ppDataOut = NULL;

    pRecoveryBlob = (PBACKUPKEY_RECOVERY_BLOB_W2K)pDataIn;

    //
    // check for invalid recovery blob version.
    // also check that input and output size fields aren't out of bounds
    // for a stream cipher (v1 blob).
    // TODO: further size validation against cbClearData and cbCipherData.
    //

    if(
        cbDataIn < (sizeof(BACKUPKEY_RECOVERY_BLOB_W2K) + sizeof(BACKUPKEY_INNER_BLOB_W2K)) ||
        pRecoveryBlob->dwVersion != BACKUPKEY_RECOVERY_BLOB_VERSION_W2K ||
        pRecoveryBlob->cbCipherData != (cbDataIn - sizeof(BACKUPKEY_RECOVERY_BLOB_W2K)) ||
        pRecoveryBlob->cbClearData > pRecoveryBlob->cbCipherData
        ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // determine if we use the preferred key, or some other key.
    // if the specified key is not the preferred one, fetch the
    // proper key.
    //

    if(memcmp(&g_guidW2KPreferredKey, &(pRecoveryBlob->guidKey), sizeof(GUID)) == 0) {

        pbPersistedKey = g_pbW2KPreferredKey;
        cbPersistedKey = g_cbW2KPreferredKey;
        fUsedPreferredKey = TRUE;
    } else {
        if(!GetBackupKey(
                    &(pRecoveryBlob->guidKey),
                    &pbPersistedKey,
                    &cbPersistedKey,
                    NULL,
                    NULL
                    ))
                goto cleanup;

        fUsedPreferredKey = FALSE;
    }

    //
    // check that we are dealing with a persisted key version we
    // understand.
    //

    if(((DWORD*)pbPersistedKey)[0] != BACKUPKEY_VERSION_W2K)
        goto cleanup;

    //
    // derive symetric key via HMAC from backup key and random R2.
    //

    if(!FMyPrimitiveHMACParam(
                    (LPBYTE)pbPersistedKey + sizeof(DWORD),
                    cbPersistedKey - sizeof(DWORD),
                    pRecoveryBlob->R2,
                    BACKUPKEY_R2_LEN,
                    rgbSymKey
                    ))
            goto cleanup;


    //
    // initialize rc4 key
    //

    rc4_key(&sRC4Key, sizeof(rgbSymKey), rgbSymKey);

    //
    // decrypt data R3, MAC, pSidUser, pDataIn beyond recovery blob
    //

    pbCipherBegin = (PBYTE)(pRecoveryBlob+1);

    rc4(&sRC4Key, pRecoveryBlob->cbCipherData, pbCipherBegin);


    pInnerBlob = (PBACKUPKEY_INNER_BLOB_W2K)(pRecoveryBlob+1);

    //
    // derive MAC key via HMAC from backup key and random R3.
    //

    if(!FMyPrimitiveHMACParam(
            (LPBYTE)pbPersistedKey + sizeof(DWORD),
            cbPersistedKey - sizeof(DWORD),
            pInnerBlob->R3,
            BACKUPKEY_R3_LEN,
            rgbMacKey   // resultant MAC key
            ))
        goto cleanup;

    //
    // adjust pbCipherBegin to only include decrypted pUserSid, and pDataIn
    //
    pbCipherBegin = (PBYTE)(pInnerBlob+1);

    //
    // validate user Sid: compare client user to that embedded in
    // decrypted recovery blob.
    //

    pSidCandidate = (PSID)pbCipherBegin;

    if(!IsValidSid(pSidCandidate)) {
        dwLastError = ERROR_INVALID_SID;
        goto cleanup;
    }

    cbSidCandidate = GetLengthSid(pSidCandidate);

    //
    // use MAC key to derive result from pSidUser and pDataIn
    //

    if(!FMyPrimitiveHMACParam(
            rgbMacKey,
            sizeof(rgbMacKey),
            pbCipherBegin,
            pRecoveryBlob->cbCipherData - sizeof(BACKUPKEY_INNER_BLOB_W2K),
            rgbMacCandidate // resultant MAC for verification.
            ))
        goto cleanup;

    //
    // verify MAC equality
    //

    if(memcmp(pInnerBlob->MAC, rgbMacCandidate, A_SHA_DIGEST_LEN) != 0) {
        dwLastError = ERROR_INVALID_ACCESS;
        goto cleanup;
    }


    //
    // check if client passes accesscheck against embedded Sid.
    // TODO: see if we expand to check for ADMINS ?
    //

    if(!CheckTokenMembership( hToken, pSidCandidate, &fIsMember )) {
        dwLastError = GetLastError();
        goto cleanup;
    }

    if( !fIsMember ) {
        dwLastError = ERROR_INVALID_ACCESS;
        goto cleanup;
    }

    //
    // validation against cbClearData for good measure.
    //

    if( pRecoveryBlob->cbClearData != (cbDataIn -
                                        sizeof(BACKUPKEY_RECOVERY_BLOB_W2K) -
                                        sizeof(BACKUPKEY_INNER_BLOB_W2K) -
                                        cbSidCandidate)
        ) {
        dwLastError = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // allocate buffer to contain results
    //

    *pcbDataOut = pRecoveryBlob->cbClearData;

    *ppDataOut = (LPBYTE)SSAlloc( *pcbDataOut );
    if(*ppDataOut == NULL) {
        *pcbDataOut = 0;
        dwLastError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto cleanup;
    }

    //
    // advance past decrypted Sid and copy results to caller.
    //

    CopyMemory(*ppDataOut, pbCipherBegin+cbSidCandidate, *pcbDataOut);

    fSuccess = TRUE;

cleanup:

    ZeroMemory( &sRC4Key, sizeof(sRC4Key) );
    ZeroMemory( rgbSymKey, sizeof(rgbSymKey) );
    ZeroMemory( pDataIn, cbDataIn );

    //
    // free the fetched key if it wasn't the preferred one.
    //

    if(!fUsedPreferredKey && pbPersistedKey) {
        ZeroMemory(pbPersistedKey, cbPersistedKey);
        SSFree(pbPersistedKey);
    }

    if(!fSuccess) {
        if(*ppDataOut) {
            SSFree(*ppDataOut);
            *ppDataOut = NULL;
        }

        if( dwLastError == ERROR_SUCCESS )
            dwLastError = ERROR_INVALID_DATA;

        SetLastError( dwLastError );
    }


    return fSuccess;
}

BOOL
RestoreFromRecoverableBlob(
    IN      HANDLE  hToken,
    IN      BOOL    fWin2kDataOut,
    IN      BYTE  * pDataIn,
    IN      DWORD   cbDataIn,
    IN  OUT BYTE ** ppDataOut,
    IN  OUT DWORD * pcbDataOut
    )
{
    PSID pSidCandidate;
    DWORD cbSidCandidate;
    BOOL fIsMember;

    PBACKUPKEY_RECOVERY_BLOB     pRecoveryBlob;
    PBACKUPKEY_KEY_BLOB          pKeyBlob;
    PBACKUPKEY_INNER_BLOB        pInnerBlob;

    DWORD cbKeyBlob = 0;

    PBYTE pbMasterKey = NULL;
    PBYTE pbPayloadKey = NULL;


    PBYTE pbPersistedKey = NULL;
    DWORD cbPersistedKey = 0;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY  hKey = NULL;

    BYTE    rgbPayloadMAC[A_SHA_DIGEST_LEN];


    BOOL fUsedPreferredKey = TRUE; // did we use preferred backup key?

    DWORD dwLastError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;


    if( pDataIn == NULL || cbDataIn == 0 ||
        ppDataOut == NULL || pcbDataOut == NULL ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *ppDataOut = NULL;
    //
    // Make a copy of pDataIn, so we can decrypt the copy
    // and then destroy it
    //


    pRecoveryBlob = (PBACKUPKEY_RECOVERY_BLOB)SSAlloc(cbDataIn);
    if(NULL == pRecoveryBlob)
    {
        SetLastError(ERROR_NOT_ENOUGH_SERVER_MEMORY);
        return FALSE;
    }
    CopyMemory((PBYTE)pRecoveryBlob, 
               pDataIn,
               cbDataIn);

    //
    // check for invalid recovery blob version.
    // also check that input and output size fields aren't out of bounds
    // for a stream cipher (v1 blob).
    // TODO: further size validation against cbClearData and cbCipherData.
    //

    if(
        (cbDataIn < sizeof(BACKUPKEY_RECOVERY_BLOB)) ||
        (cbDataIn < (sizeof(BACKUPKEY_RECOVERY_BLOB) + pRecoveryBlob->cbEncryptedMasterKey + pRecoveryBlob->cbEncryptedPayload)) ||
        (pRecoveryBlob->dwVersion != BACKUPKEY_RECOVERY_BLOB_VERSION)
        ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // determine if we use the preferred key, or some other key.
    // if the specified key is not the preferred one, fetch the
    // proper key.
    //

    if(memcmp(&g_guidPreferredKey, &(pRecoveryBlob->guidKey), sizeof(GUID)) == 0) {

        pbPersistedKey = g_pbPreferredKey;
        cbPersistedKey = g_cbPreferredKey;
        hProv = g_hProvPreferredKey;
        hKey = g_hKeyPreferredKey;
        fUsedPreferredKey = TRUE;
    } else {
        if(!GetBackupKey(
                    &(pRecoveryBlob->guidKey),
                    &pbPersistedKey,
                    &cbPersistedKey,
                    &hProv,
                    &hKey
                    ))
        {
           dwLastError = GetLastError();
           goto cleanup;
        }

        fUsedPreferredKey = FALSE;
    }

    //
    // check that we are dealing with a persisted key version we
    // understand.
    //

    if(((DWORD*)pbPersistedKey)[0] != BACKUPKEY_VERSION)
    {
        dwLastError = NTE_BAD_KEY;
        goto cleanup;
    }

    pKeyBlob = (PBACKUPKEY_KEY_BLOB)(pRecoveryBlob+1);
    pInnerBlob = (PBACKUPKEY_INNER_BLOB)((PBYTE)pKeyBlob + pRecoveryBlob->cbEncryptedMasterKey);

    cbKeyBlob = pRecoveryBlob->cbEncryptedMasterKey;
    //
    // Decrypt the master key and payload key
    //

    if(!CryptDecrypt(hKey,
                     NULL,
                     TRUE,
                     0, //CRYPT_OAEP,
                     (PBYTE)pKeyBlob,
                     &cbKeyBlob))
    {
       dwLastError = GetLastError();
       goto cleanup;
    }



    //
    // Use the payload key to decrypt the payload
    //
    if(pKeyBlob->cbPayloadKey != DES3_KEYSIZE + DES_BLOCKLEN)
    {
        dwLastError = ERROR_INVALID_DATA;
        goto cleanup;
    }
    pbMasterKey= (PBYTE)(pKeyBlob+1);
    pbPayloadKey = pbMasterKey + pKeyBlob->cbMasterKey;

    if(pRecoveryBlob->cbEncryptedPayload < A_SHA_DIGEST_LEN + sizeof(BACKUPKEY_INNER_BLOB))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto cleanup;
    }



    {

        DES3TABLE s3DESKey;
        BYTE InputBlock[DES_BLOCKLEN];
        DWORD iBlock;
        DWORD cBlocks = pRecoveryBlob->cbEncryptedPayload/DES_BLOCKLEN;
        BYTE feedback[ DES_BLOCKLEN ];
        // initialize 3des key
        //

        if(cBlocks*DES_BLOCKLEN != pRecoveryBlob->cbEncryptedPayload)
        {
            // Master key must be a multiple of DES_BLOCKLEN
            goto cleanup;

        }
        tripledes3key(&s3DESKey, pbPayloadKey);

        //
        // IV is derived from the DES_BLOCKLEN bytes of the calculated 
        // rgbSymKey, after the 3des key
        CopyMemory(feedback, pbPayloadKey + DES3_KEYSIZE, DES_BLOCKLEN);

        for(iBlock=0; iBlock < cBlocks; iBlock++)
        {
            CopyMemory(InputBlock, 
                       ((PBYTE)pInnerBlob)+iBlock*DES_BLOCKLEN,
                       DES_BLOCKLEN);
            CBC(tripledes,
                DES_BLOCKLEN,
                ((PBYTE)pInnerBlob)+iBlock*DES_BLOCKLEN,
                InputBlock,
                &s3DESKey,
                DECRYPT,
                feedback);
        }
    }
    //
    // Check the MAC
    //

    // Generate the payload MAC

    FMyPrimitiveSHA( (PBYTE)pInnerBlob, 
                    pRecoveryBlob->cbEncryptedPayload  - A_SHA_DIGEST_LEN,
                    rgbPayloadMAC);

    if(0 != memcmp(rgbPayloadMAC, 
              (PBYTE)pInnerBlob + pRecoveryBlob->cbEncryptedPayload  - A_SHA_DIGEST_LEN,
              A_SHA_DIGEST_LEN))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto cleanup;
    }

    if(pInnerBlob->dwPayloadVersion != BACKUPKEY_PAYLOAD_VERSION)
    {
        dwLastError = ERROR_INVALID_DATA;
        goto cleanup;
    }


    pSidCandidate = (PBYTE)(pInnerBlob+1) + pInnerBlob->cbLocalKey;



    //
    // validate user Sid: compare client user to that embedded in
    // decrypted recovery blob.
    //


    if(!IsValidSid(pSidCandidate)) {
        dwLastError = ERROR_INVALID_SID;
        goto cleanup;
    }

    cbSidCandidate = GetLengthSid(pSidCandidate);

    if(cbSidCandidate + 
        pInnerBlob->cbLocalKey + 
        sizeof(BACKUPKEY_INNER_BLOB) +
        A_SHA_DIGEST_LEN > pRecoveryBlob->cbEncryptedPayload)
    {
        dwLastError = ERROR_INVALID_DATA;
        goto cleanup;
    }

    //
    // check if client passes accesscheck against embedded Sid.
    // TODO: see if we expand to check for ADMINS ?
    //

    if(!CheckTokenMembership( hToken, pSidCandidate, &fIsMember )) {
        dwLastError = GetLastError();
        goto cleanup;
    }

    if( !fIsMember ) {
        dwLastError = ERROR_INVALID_ACCESS;
        goto cleanup;
    }


    if(fWin2kDataOut)
    {
       if(!ConvertRecoveredBlobToW2KBlob(
                                        pbMasterKey,
                                        pKeyBlob->cbMasterKey,
                                        (PBYTE)(pInnerBlob+1),
                                        pInnerBlob->cbLocalKey,
                                        pSidCandidate,
                                        ppDataOut,
                                        pcbDataOut))
       {
           dwLastError = GetLastError();
           goto cleanup;
       }

    }
    else
    {
        *pcbDataOut = sizeof(DWORD) + pKeyBlob->cbMasterKey;
        *ppDataOut = (LPBYTE)SSAlloc( *pcbDataOut );
        if(*ppDataOut == NULL) {
            *pcbDataOut = 0;
            dwLastError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
            goto cleanup;
        }
        *((DWORD *)*ppDataOut) = MASTERKEY_BLOB_RAW_VERSION;
        CopyMemory((*ppDataOut) + sizeof(DWORD), pbMasterKey, (*pcbDataOut) - sizeof(DWORD));
    }


    fSuccess = TRUE;

cleanup:

    ZeroMemory( pDataIn, cbDataIn );

    //
    // free the fetched key if it wasn't the preferred one.
    //

    if(!fUsedPreferredKey && pbPersistedKey) {
        ZeroMemory(pbPersistedKey, cbPersistedKey);
        SSFree(pbPersistedKey);
        if(hKey)
        {
            CryptDestroyKey(hKey);
        }
        if(hProv)
        {
            CryptReleaseContext(hProv, 0);
        }
    }



    if(!fSuccess) {
        if(*ppDataOut) {
            SSFree(*ppDataOut);
            *ppDataOut = NULL;
        }

        if( dwLastError == ERROR_SUCCESS )
            dwLastError = ERROR_INVALID_DATA;

        SetLastError( dwLastError );
    }

    if(pRecoveryBlob)
    {
        ZeroMemory(pRecoveryBlob, cbDataIn);
        SSFree(pRecoveryBlob);
    }


    return fSuccess;
}

DWORD
StartBackupKeyServer(
    VOID
    )
{
    RPC_STATUS status;
    LPWSTR pszPrincipalName = NULL;

    //
    // initialize critical section that prevents race condition for
    // deferred intitialization activities.
    //

    status = RtlInitializeCriticalSection( &g_csInitialization );
    if(!NT_SUCCESS(status))
    {
        return status;
    }


    //
    // if we aren't WinNT5 or a domain controller, don't do anything.
    //

    if(!FIsWinNT5() || !IsDomainController())
        return ERROR_SUCCESS;

    //
    // enable SNEGO authentication
    //
    
    status = RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_NEGOTIATE, 
                                          &pszPrincipalName);

    if (RPC_S_OK != status) 
        return status;

    SS_ASSERT(0 != wcslen(pszPrincipalName));

    status = RpcServerRegisterAuthInfoW(
                    pszPrincipalName,
                    RPC_C_AUTHN_GSS_NEGOTIATE,
                    0,
                    0
                    );

    RpcStringFree(&pszPrincipalName);
    pszPrincipalName = NULL;

    if( status )
        return status;

    status = RpcServerRegisterIfEx(s_BackupKey_v1_0_s_ifspec, 
                                   NULL, 
                                   NULL,
                                   RPC_IF_AUTOLISTEN,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   NULL);

    if( status )
        return status;


    //
    // NOTE: RpcServerListen is called outside this routine
    //

    g_fBackupKeyServerStarted = TRUE;


#ifdef DCSTRESS_petesk

    //  Open the memory mapped file, and map a view into this process
    {
        HANDLE  hMMFile = NULL;

        //
        //  Create the memory mapped file backed by the paging file
        //
        hMMFile = OpenFileMappingW(
                        FILE_MAP_WRITE,
                        FALSE,
                        WSZ_MAP_OBJECT
                        );


        if (hMMFile)  {

            //
            //  Map the dword counter into pstore process
            //
            g_pCounter = MapViewOfFile(
                                hMMFile,
                                FILE_MAP_WRITE,
                                0,
                                0,
                                4
                                );
        }


    }

#endif // DCSTRESS


    return ERROR_SUCCESS;
}

DWORD
StopBackupKeyServer(
    VOID
    )
{
    RPC_STATUS status;

    RtlDeleteCriticalSection( &g_csInitialization );

    //
    // only do something if the server started.
    //

    if(!g_fBackupKeyServerStarted)
        return ERROR_SUCCESS;

    status = RpcServerUnregisterIf(s_BackupKey_v1_0_s_ifspec, 0, 0);


    FreePreferredBackupKey();
    FreeSystemCredentials();

    g_fBackupKeyServerStarted = FALSE;

    return status;
}

BOOL
GetBackupKey(
    IN      GUID *pguidKey,
        OUT PBYTE *ppbKey,
        OUT DWORD *pcbKey,
        OUT HCRYPTPROV *phCryptProv,
        OUT HCRYPTKEY  *phCryptKey
    )
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING *pSecretData;
    WCHAR wszKeyGuid[ (sizeof(BACKUPKEY_NAME_PREFIX) / sizeof(WCHAR)) + MAX_GUID_SZ_CHARS ];
    NTSTATUS Status;
    BOOL fSuccess;

    if(pguidKey == NULL || ppbKey == NULL || pcbKey == NULL)
        return FALSE;

    //
    // setup the UNICODE_STRINGs for the call.
    //

    CopyMemory(wszKeyGuid, BACKUPKEY_NAME_PREFIX, sizeof(BACKUPKEY_NAME_PREFIX));

    if(MyGuidToStringW(pguidKey,
        (LPWSTR)( (LPBYTE)wszKeyGuid + sizeof(BACKUPKEY_NAME_PREFIX) - sizeof(WCHAR) )
        ) != 0) return FALSE;

    InitLsaString(&SecretKeyName, wszKeyGuid);

    Status = OpenPolicy(NULL, POLICY_GET_PRIVATE_INFORMATION, &PolicyHandle);

    if(!NT_SUCCESS(Status))
        return FALSE;

    Status = LsaRetrievePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &pSecretData
                );

    LsaClose(PolicyHandle);

    if(!NT_SUCCESS(Status) || pSecretData == NULL)
        return FALSE;

    *ppbKey = (LPBYTE)SSAlloc( pSecretData->Length );

    if(*ppbKey) {
        *pcbKey = pSecretData->Length;
        CopyMemory( *ppbKey, pSecretData->Buffer, pSecretData->Length );
        fSuccess = TRUE;
    } else {
        fSuccess = FALSE;
    }

    if(fSuccess && (NULL != phCryptProv))
    {
        if((*pcbKey >= sizeof(DWORD)) &&  // prefix bug 170438
           (*((DWORD *)*ppbKey) == BACKUPKEY_VERSION))
        {

            if(!CryptAcquireContext(phCryptProv,
                                    NULL,
                                    NULL,
                                    PROV_RSA_FULL,
                                    CRYPT_VERIFYCONTEXT))
            {
                fSuccess = FALSE;
            }
            else
            {
                if(phCryptKey)
                {
                    if(!CryptImportKey(*phCryptProv,
                                    (*ppbKey) + 3*sizeof(DWORD),
                                    ((DWORD *)*ppbKey)[1],
                                    NULL,
                                    0,
                                    phCryptKey))
                    {
                        fSuccess = FALSE;
                        CryptReleaseContext(*phCryptProv, 0);
                        *phCryptProv = NULL;
                    }
                }

            }
        }
        else
        {
            *phCryptProv = NULL;
        }
    }

    ZeroMemory( pSecretData->Buffer, pSecretData->Length );
    LsaFreeMemory( pSecretData );

    

    return fSuccess;
}

BOOL
CreateBackupKeyW2K(
    IN  OUT GUID *pguidKey,
        OUT PBYTE *ppbKey,
        OUT DWORD *pcbKey
    )
/*++

    This routine creates a new backup key and an identifier for that key.

    The key is then stored as an global LSA secret.

--*/
{
    DWORD RpcStatus;
    BOOL fSuccess = FALSE;;
    HCRYPTPROV hCryptProv = NULL;
    HCRYPTKEY  hCryptKey = NULL;
    DWORD      dwDefaultKeySize = 1024;
    PBYTE      pbPublicExportData = NULL;

    if(pguidKey == NULL || ppbKey == NULL || pcbKey == NULL)
        return FALSE;

    *ppbKey = NULL;

    //
    // generate new Guid representing key
    //

    RpcStatus = UuidCreate( pguidKey );
    if( RpcStatus != RPC_S_OK && RpcStatus != RPC_S_UUID_LOCAL_ONLY )
        return FALSE;



    *pcbKey = BACKUPKEY_MATERIAL_SIZE + sizeof(DWORD);
    *ppbKey = (LPBYTE)SSAlloc( *pcbKey );

    if(*ppbKey == NULL)
        return FALSE;

    //
    // generate random key material.
    //

    fSuccess = RtlGenRandom(*ppbKey, *pcbKey);

    if(fSuccess) {

        //
        // version the key material.
        //

        ((DWORD *)*ppbKey)[0] = BACKUPKEY_VERSION_W2K;

        fSuccess = SaveBackupKey(pguidKey, *ppbKey, *pcbKey);

    } else {
        SSFree( *ppbKey );
        *ppbKey = NULL;
    }


    return fSuccess;
}

BOOL
CreateBackupKey(
    IN  OUT GUID *pguidKey,
        OUT PBYTE *ppbKey,
        OUT DWORD *pcbKey,
        OUT HCRYPTPROV *phCryptProv,
        OUT HCRYPTKEY  *phCryptKey
    )
/*++

    This routine creates a new backup key and an identifier for that key.

    The key is then stored as an global LSA secret.

--*/
{
    DWORD RpcStatus;
    BOOL fSuccess = FALSE;;
    HCRYPTPROV hCryptProv = NULL;
    HCRYPTKEY  hCryptKey = NULL;
    DWORD      dwDefaultKeySize = 1024;
    PBYTE      pbPublicExportData = NULL;

    if(pguidKey == NULL || ppbKey == NULL || pcbKey == NULL)
        return FALSE;

    *ppbKey = NULL;

    //
    // generate new Guid representing key
    //

    RpcStatus = UuidCreate( pguidKey );
    if( RpcStatus != RPC_S_OK && RpcStatus != RPC_S_UUID_LOCAL_ONLY )
        return FALSE;


    DWORD      cbPrivateExportLength = 0;
    DWORD      cbPublicExportLength = 0;



    if(!CryptAcquireContext(&hCryptProv,
                            NULL,
                            NULL,
                            PROV_RSA_FULL,
                            CRYPT_VERIFYCONTEXT))
    {
        goto error;
    }
    if(!CryptGenKey(hCryptProv, 
                    AT_KEYEXCHANGE,
                    CRYPT_EXPORTABLE | dwDefaultKeySize << 16, // 1024 bit
                    &hCryptKey))
    {
        goto error;
    }

    // 
    // Get the private key size
    //
    if(!CryptExportKey(hCryptKey,
                       NULL,
                       PRIVATEKEYBLOB,
                       0,
                       NULL,
                       &cbPrivateExportLength))
    {
        goto error;
    }

    if(!GeneratePublicKeyCert(hCryptProv,
                              hCryptKey,
                              pguidKey,
                              &cbPublicExportLength,
                              &pbPublicExportData))
    {
        goto error;
    }

    *pcbKey = sizeof(DWORD) + // version
              sizeof(DWORD) + // cbPrivateExportLength
              sizeof(DWORD) + // cbPublicExportLength
              cbPrivateExportLength + 
              cbPublicExportLength;

    *ppbKey = (LPBYTE)SSAlloc( *pcbKey );

    if(*ppbKey == NULL)
        goto error;

    ((DWORD *)*ppbKey)[0] = BACKUPKEY_VERSION;
    ((DWORD *)*ppbKey)[1] = cbPrivateExportLength;
    ((DWORD *)*ppbKey)[2] = cbPublicExportLength;

    if(!CryptExportKey(hCryptKey,
                       NULL,
                       PRIVATEKEYBLOB,
                       0,
                       (*ppbKey) + 3*sizeof(DWORD),
                       &cbPrivateExportLength))
    {
        goto error;
    }
    CopyMemory((*ppbKey) + 3*sizeof(DWORD) +  cbPrivateExportLength,
               pbPublicExportData,
               cbPublicExportLength);

    *phCryptProv = hCryptProv;
    hCryptProv = NULL;

    *phCryptKey = hCryptKey;
    hCryptKey = NULL;

    fSuccess = SaveBackupKey(pguidKey, *ppbKey, *pcbKey);


error:

    if(hCryptKey)
    {

    }
    if(hCryptProv)
    {
            CryptReleaseContext(hCryptProv,
                                0);
    }
    if(pbPublicExportData)
    {
        SSFree(pbPublicExportData);
    }
    return fSuccess;
}

BOOL
SaveBackupKey(
    IN      GUID *pguidKey,
    IN      BYTE *pbKey,
    IN      DWORD cbKey     // size of pbKey material, not greater than 0xffff
    )
/*++

    Persist the specified key to a global LSA secret.

--*/
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING SecretData;
    WCHAR wszKeyGuid[ (sizeof(BACKUPKEY_NAME_PREFIX) / sizeof(WCHAR)) + MAX_GUID_SZ_CHARS ];
    NTSTATUS Status;

    if(pguidKey == NULL || pbKey == NULL || cbKey > 0xffff)
        return FALSE;

    //
    // setup the UNICODE_STRINGs for the call.
    //

    CopyMemory(wszKeyGuid, BACKUPKEY_NAME_PREFIX, sizeof(BACKUPKEY_NAME_PREFIX));

    if(MyGuidToStringW(pguidKey,
        (LPWSTR)( (LPBYTE)wszKeyGuid + sizeof(BACKUPKEY_NAME_PREFIX) - sizeof(WCHAR) )
        ) != 0) return FALSE;

    InitLsaString(&SecretKeyName, wszKeyGuid);

    SecretData.Buffer = (LPWSTR)pbKey;
    SecretData.Length = (USHORT)cbKey;
    SecretData.MaximumLength = (USHORT)cbKey;

    Status = OpenPolicy(NULL, POLICY_CREATE_SECRET, &PolicyHandle);

    if(!NT_SUCCESS(Status))
        return FALSE;

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &SecretData
                );

    LsaClose(PolicyHandle);

    if(!NT_SUCCESS(Status))
        return FALSE;

    return TRUE;
}

BOOL
DestroyBackupKey(
    IN      GUID guidKey
    )
{
    //
    // Delete the LSA secret containing the specified key.
    //

    return FALSE;
}


BOOL
SetupPreferredBackupKeys(
    VOID
    )
{
    static BOOL fSetupStatus = FALSE;
    BOOL fLocalStatus = FALSE;


    if( g_fSetupPreferredAttempted )
        return fSetupStatus;

    RtlEnterCriticalSection( &g_csInitialization );

    if( !g_fSetupPreferredAttempted ) {

        //
        // Wait on LSA/SAM to be available.
        //

        fSetupStatus = WaitOnSAMDatabase();

        if( fSetupStatus ) {

            fLocalStatus = FALSE;

            //
            // get the preferred backup key.
            // TODO: if this fails (unlikely), we should probably log an event!
            // check outcome of StartBackupKeyServer() in the main service code
            //

            //
            // Get the legacy backup key
            //

            if(GetPreferredBackupKeyGuid(BACKUPKEY_VERSION_W2K, &g_guidW2KPreferredKey)) {

                //
                // now, pickup the specified key
                //



                fLocalStatus = GetBackupKey(&g_guidW2KPreferredKey, 
                                            &g_pbW2KPreferredKey, 
                                            &g_cbW2KPreferredKey,
                                            NULL,
                                            NULL);
            }


            if(!fLocalStatus)
            {

                //
                // no preferred backup key specified, or we couldn't read one
                // create a new one.
                //

                if(CreateBackupKeyW2K(&g_guidW2KPreferredKey, 
                                    &g_pbW2KPreferredKey, 
                                    &g_cbW2KPreferredKey))
                    fLocalStatus = SetPreferredBackupKeyGuid(BACKUPKEY_VERSION_W2K,
                                                             &g_guidPreferredKey);
                else
                    fLocalStatus  = FALSE;
            }

            fSetupStatus = fLocalStatus;

            fLocalStatus = FALSE;

            //
            // Get the current backup key
            // 

            if(GetPreferredBackupKeyGuid(BACKUPKEY_VERSION, &g_guidPreferredKey)) {

                //
                // now, pickup the specified key
                //



                fLocalStatus = GetBackupKey(&g_guidPreferredKey, 
                                            &g_pbPreferredKey, 
                                            &g_cbPreferredKey,
                                            &g_hProvPreferredKey,
                                            &g_hKeyPreferredKey);

            }

            if(!fLocalStatus)
            {

                //
                // no preferred backup key specified.  create one and specify it
                // as being the preferred one.
                //

                if(CreateBackupKey(&g_guidPreferredKey, 
                                    &g_pbPreferredKey, 
                                    &g_cbPreferredKey,
                                    &g_hProvPreferredKey,
                                    &g_hKeyPreferredKey))
                    fLocalStatus = SetPreferredBackupKeyGuid(BACKUPKEY_VERSION,
                                                             &g_guidPreferredKey);
                else
                    fLocalStatus  = FALSE;
            }
        }

        if(!fLocalStatus)
        {
            fSetupStatus = FALSE;
        }
        g_fSetupPreferredAttempted = TRUE;
    }

    RtlLeaveCriticalSection( &g_csInitialization );

    return fSetupStatus;
}


BOOL
GetPreferredBackupKeyGuid(
    IN      DWORD dwVersion,
    IN  OUT GUID *pguidKey
    )
/*++

    Get the GUID value associated with the key which has been set to be preferred.

    The return value is TRUE, if successful.  The GUID value is copied into the
    buffer specified by the pguidKey parameter.

    The return value is FALSE on failure; if the GUID does not exist, or the
    data could not be retrieved, for instance.

--*/
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING *pSecretData;
    USHORT cbData;
    NTSTATUS Status;
    BOOL fSuccess;

    if(pguidKey == NULL)
        return FALSE;

    //
    // setup the UNICODE_STRINGs for the call.
    //

    InitLsaString(&SecretKeyName, 
        (dwVersion == BACKUPKEY_VERSION_W2K)?BACKUPKEY_PREFERRED_W2K:BACKUPKEY_PREFERRED);

    Status = OpenPolicy(NULL, POLICY_GET_PRIVATE_INFORMATION, &PolicyHandle);

    if(!NT_SUCCESS(Status))
        return FALSE;

    Status = LsaRetrievePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &pSecretData
                );

    LsaClose(PolicyHandle);

    if(!NT_SUCCESS(Status) || pSecretData == NULL)
        return FALSE;

    if(pSecretData->Length == sizeof(GUID)) {
        CopyMemory(pguidKey, pSecretData->Buffer, sizeof(GUID));
        fSuccess = TRUE;
    } else {
        fSuccess = FALSE;
    }

    ZeroMemory(pSecretData->Buffer, pSecretData->Length);
    LsaFreeMemory(pSecretData);

    return fSuccess;
}

BOOL
SetPreferredBackupKeyGuid(
    IN      DWORD dwVersion,
    IN      GUID *pguidKey
    )
/*++

    Sets the specified GUID as being the preferred backup key, by reference
    from the GUID to key mapping.

--*/
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING SecretData;
    NTSTATUS Status;

    if(pguidKey == NULL)
        return FALSE;

    //
    // setup the UNICODE_STRINGs for the call.
    //

    InitLsaString(&SecretKeyName,        
        (dwVersion == BACKUPKEY_VERSION_W2K)?BACKUPKEY_PREFERRED_W2K:BACKUPKEY_PREFERRED);


    SecretData.Buffer = (LPWSTR)pguidKey;
    SecretData.Length = sizeof(GUID);
    SecretData.MaximumLength = sizeof(GUID);

    Status = OpenPolicy(NULL, POLICY_CREATE_SECRET, &PolicyHandle);

    if(!NT_SUCCESS(Status))
        return FALSE;

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &SecretData
                );

    LsaClose(PolicyHandle);

    if(!NT_SUCCESS(Status))
        return FALSE;

    return TRUE;
}

BOOL
FreePreferredBackupKey(
    VOID
    )
{

    g_fSetupPreferredAttempted = FALSE;

    //
    // free allocated key pair.
    //

    if(g_pbPreferredKey) {
        ZeroMemory(g_pbPreferredKey, g_cbPreferredKey);
        SSFree(g_pbPreferredKey);
        g_pbPreferredKey = NULL;
    }

    return TRUE;
}


NTSTATUS
OpenPolicy(
    LPWSTR ServerName,
    DWORD DesiredAccess,
    PLSA_HANDLE PolicyHandle
    )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes.
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    if (ServerName != NULL) {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString, ServerName);
        Server = &ServerString;
    } else {
        Server = NULL;
    }

    //
    // Attempt to open the policy.
    //
    return LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle
                );
}

BOOL
WaitOnSAMDatabase(
    VOID
    )
{
    NTSTATUS Status;
    LSA_UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES EventAttributes;
    HANDLE hEvent;
    BOOL fSuccess = FALSE;

    InitLsaString( &EventName, L"\\SAM_SERVICE_STARTED" );
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    Status = NtOpenEvent( &hEvent, SYNCHRONIZE, &EventAttributes );

    if(!NT_SUCCESS(Status))
        return FALSE;

    if( WAIT_OBJECT_0 == WaitForSingleObject( hEvent, INFINITE ) )
        fSuccess = TRUE;

    CloseHandle( hEvent );

    return fSuccess;
}









DWORD
GetSystemCredential(
    IN      BOOL fLocalMachine,
    IN OUT  BYTE rgbCredential[ A_SHA_DIGEST_LEN ]
    )
/*++

    This routines returns the credential associated with the SYSTEM account
    based on the fLocalMachine parameter.

    If fLocalMachine is TRUE, the credential returned is suitable for use
    at the LOCAL_MACHINE storage disposition.

    Otherwise, the credential returned is suitable for use when the calling
    user security context is the Local System account.

--*/
{
    PBYTE Credential;

    if(!g_fSystemCredsInitialized) {
        DWORD dwLastError;

        RtlEnterCriticalSection( &g_csInitialization );

        if(!g_fSystemCredsInitialized) {
            dwLastError = QuerySystemCredentials( g_rgbSystemCredMachine, g_rgbSystemCredUser );
            if( dwLastError == ERROR_FILE_NOT_FOUND ) {
                if( CreateSystemCredentials() )
                    dwLastError = QuerySystemCredentials( g_rgbSystemCredMachine, g_rgbSystemCredUser );
            }

            if( dwLastError == ERROR_SUCCESS )
                g_fSystemCredsInitialized = TRUE;
        } else {
            dwLastError = ERROR_SUCCESS;
        }

        RtlLeaveCriticalSection( &g_csInitialization );

        if( dwLastError != ERROR_SUCCESS )
            return dwLastError;
    }


    if( fLocalMachine )
        Credential = g_rgbSystemCredMachine;
    else
        Credential = g_rgbSystemCredUser;

    CopyMemory( rgbCredential, Credential, A_SHA_DIGEST_LEN );

    return ERROR_SUCCESS;
}

BOOL
UpdateSystemCredentials(
    VOID
    )
{
    BOOL fSuccess;

    RtlEnterCriticalSection( &g_csInitialization );

    g_fSystemCredsInitialized = FALSE;

    fSuccess = CreateSystemCredentials();

    RtlLeaveCriticalSection( &g_csInitialization );

    return fSuccess;
}

BOOL
CreateSystemCredentials(
    VOID
    )
{
    SYSTEM_CREDENTIALS SystemCredentials;

    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING SecretData;
    NTSTATUS Status;

    //
    // create random key material.
    //

    RtlGenRandom( (PBYTE)&SystemCredentials, sizeof(SystemCredentials) );
    SystemCredentials.dwVersion = SYSTEM_CREDENTIALS_VERSION;

    //
    // setup the UNICODE_STRINGs for the call.
    //

    InitLsaString(&SecretKeyName, SYSTEM_CREDENTIALS_SECRET);

    SecretData.Buffer = (LPWSTR)&SystemCredentials;
    SecretData.Length = sizeof( SystemCredentials );
    SecretData.MaximumLength = sizeof( SystemCredentials );

    Status = OpenPolicy(NULL, POLICY_CREATE_SECRET, &PolicyHandle);

    if(!NT_SUCCESS(Status))
        return FALSE;

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &SecretData
                );

    LsaClose(PolicyHandle);

    if(!NT_SUCCESS(Status))
        return FALSE;

    return TRUE;
}

DWORD
QuerySystemCredentials(
    IN  OUT BYTE rgbSystemCredMachine[ A_SHA_DIGEST_LEN ],
    IN  OUT BYTE rgbSystemCredUser [ A_SHA_DIGEST_LEN ]
    )
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING *pSecretData;
    USHORT cbData;
    NTSTATUS Status;
    DWORD dwLastError = ERROR_INVALID_PARAMETER;
    BOOL fSuccess;

    if( !WaitOnSAMDatabase() )
        return WAIT_TIMEOUT;

    //
    // setup the UNICODE_STRINGs for the call.
    //

    InitLsaString(&SecretKeyName, SYSTEM_CREDENTIALS_SECRET);

    Status = OpenPolicy(NULL, POLICY_GET_PRIVATE_INFORMATION, &PolicyHandle);

    if(!NT_SUCCESS(Status))
        return dwLastError;

    Status = LsaRetrievePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &pSecretData
                );

    LsaClose(PolicyHandle);

    if(Status == STATUS_OBJECT_NAME_NOT_FOUND)
        return ERROR_FILE_NOT_FOUND;

    if(!NT_SUCCESS(Status) || pSecretData == NULL)
        return dwLastError;

    if( pSecretData->Length == sizeof(SYSTEM_CREDENTIALS) ) {
        PSYSTEM_CREDENTIALS pSystemCredentials = (PSYSTEM_CREDENTIALS)pSecretData->Buffer;

        if( pSystemCredentials->dwVersion == SYSTEM_CREDENTIALS_VERSION ) {
            CopyMemory( rgbSystemCredMachine, pSystemCredentials->rgbSystemCredMachine, A_SHA_DIGEST_LEN );
            CopyMemory( rgbSystemCredUser, pSystemCredentials->rgbSystemCredUser, A_SHA_DIGEST_LEN );

            dwLastError = ERROR_SUCCESS;
        }
    }

    ZeroMemory(pSecretData->Buffer, pSecretData->Length);
    LsaFreeMemory(pSecretData);

    return dwLastError;
}


BOOL
FreeSystemCredentials(
    VOID
    )
{
    ZeroMemory( g_rgbSystemCredMachine, sizeof(g_rgbSystemCredMachine) );
    ZeroMemory( g_rgbSystemCredUser, sizeof(g_rgbSystemCredUser) );

    g_fSystemCredsInitialized = FALSE;

    return TRUE;
}


BOOL GeneratePublicKeyCert(HCRYPTPROV hCryptProv,
                           HCRYPTKEY hCryptKey,
                           GUID *pguidKey,
                           DWORD *pcbPublicExportLength,
                           PBYTE *ppbPublicExportData)
{

    BOOL            fRet = FALSE;
    CERT_INFO       CertInfo;
    CERT_PUBLIC_KEY_INFO *pKeyInfo = NULL;
    DWORD                 cbKeyInfo = 0;
    CERT_NAME_BLOB  CertName;
    CERT_RDN_ATTR   RDNAttributes[1];
    CERT_RDN        CertRDN[] = {1, RDNAttributes} ;
    CERT_NAME_INFO  NameInfo = {1, CertRDN};

    CertName.pbData = NULL;
    CertName.cbData = 0;

    RDNAttributes[0].Value.pbData = NULL;
    RDNAttributes[0].Value.cbData = 0;

    DWORD cbCertSize = 0;
    PBYTE pbCert = NULL;
    DWORD cSize = 0;

    // Generate a self-signed cert structure

    RDNAttributes[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    RDNAttributes[0].pszObjId =    szOID_COMMON_NAME;

    if(!GetComputerNameEx(ComputerNameDnsDomain,
                       NULL,
                       &cSize))
    {
        DWORD dwError = GetLastError();

        if((dwError != ERROR_MORE_DATA) &&
           (dwError != ERROR_BUFFER_OVERFLOW))
        {
            goto error;
        }
    }
    RDNAttributes[0].Value.cbData = cSize * sizeof(WCHAR);

    RDNAttributes[0].Value.pbData = (PBYTE)SSAlloc(RDNAttributes[0].Value.cbData);
    if(NULL == RDNAttributes[0].Value.pbData)
    {
        goto error;
    }

    if(!GetComputerNameEx(ComputerNameDnsDomain,
                       (LPWSTR)RDNAttributes[0].Value.pbData,
                       &cSize))
    {
        goto error;
    }


    //
    // Get the actual public key info from the key
    //
    if(!CryptExportPublicKeyInfo(hCryptProv, 
                             AT_KEYEXCHANGE,
                             X509_ASN_ENCODING,
                             NULL,
                             &cbKeyInfo))
    {
        goto error;
    }
    pKeyInfo = (CERT_PUBLIC_KEY_INFO *)SSAlloc(cbKeyInfo);
    if(NULL == pKeyInfo)
    {
        goto error;
    }
    if(!CryptExportPublicKeyInfo(hCryptProv, 
                             AT_KEYEXCHANGE,
                             X509_ASN_ENCODING,
                             pKeyInfo,
                             &cbKeyInfo))
    {
        goto error;
    }

    // 
    // Generate the certificate name
    //

    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_NAME,
                          &NameInfo,
                          NULL,
                          &CertName.cbData))
    {
        goto error;
    }

    CertName.pbData = (PBYTE)SSAlloc(CertName.cbData);
    if(NULL == CertName.pbData)
    {
        goto error;
    }
    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_NAME,
                          &NameInfo,
                          CertName.pbData,
                          &CertName.cbData))
    {
        goto error;
    }



    CertInfo.dwVersion = CERT_V3;
    CertInfo.SerialNumber.pbData = (PBYTE)pguidKey;
    CertInfo.SerialNumber.cbData =  sizeof(GUID);
    CertInfo.SignatureAlgorithm.pszObjId = szOID_OIWSEC_sha1RSASign;
    CertInfo.SignatureAlgorithm.Parameters.cbData = 0;
    CertInfo.SignatureAlgorithm.Parameters.pbData = NULL;
    CertInfo.Issuer.pbData = CertName.pbData;
    CertInfo.Issuer.cbData = CertName.cbData;

    GetSystemTimeAsFileTime(&CertInfo.NotBefore);
    CertInfo.NotAfter = CertInfo.NotBefore;
    ((LARGE_INTEGER * )&CertInfo.NotAfter)->QuadPart += 
           Int32x32To64(FILETIME_TICKS_PER_SECOND, BACKUPKEY_LIFETIME);



    CertInfo.Subject.pbData = CertName.pbData;
    CertInfo.Subject.cbData = CertName.cbData;
    CertInfo.SubjectPublicKeyInfo = *pKeyInfo;
    CertInfo.SubjectUniqueId.pbData = (PBYTE)pguidKey;
    CertInfo.SubjectUniqueId.cbData = sizeof(GUID);
    CertInfo.SubjectUniqueId.cUnusedBits = 0;
    CertInfo.IssuerUniqueId.pbData = (PBYTE)pguidKey;
    CertInfo.IssuerUniqueId.cbData = sizeof(GUID);
    CertInfo.IssuerUniqueId.cUnusedBits = 0;
    CertInfo.cExtension = 0;
    CertInfo.rgExtension = NULL;

    if(!CryptSignAndEncodeCertificate(hCryptProv, 
                                      AT_KEYEXCHANGE,
                                      X509_ASN_ENCODING,
                                      X509_CERT_TO_BE_SIGNED,
                                      &CertInfo,
                                      &CertInfo.SignatureAlgorithm,
                                      NULL,
                                      NULL,
                                      &cbCertSize))
    {
        goto error;
    }

    pbCert = (PBYTE)SSAlloc(cbCertSize);
    if(NULL == pbCert)
    {
        goto error;
    }

    if(!CryptSignAndEncodeCertificate(hCryptProv, 
                                      AT_KEYEXCHANGE,
                                      X509_ASN_ENCODING,
                                      X509_CERT_TO_BE_SIGNED,
                                      &CertInfo,
                                      &CertInfo.SignatureAlgorithm,
                                      NULL,
                                      pbCert,
                                      &cbCertSize))
    {
        goto error;
    }

    *pcbPublicExportLength = cbCertSize;
  
    *ppbPublicExportData = pbCert;

    if(!CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCertSize))
    {
        GetLastError();
    }

    pbCert = NULL;

    fRet = TRUE;

error:
    if(pbCert)
    {
        SSFree(pbCert);
    }
    if(pKeyInfo)
    {
        SSFree(pKeyInfo);
    }
    if(CertName.pbData)
    {
        SSFree(CertName.pbData);
    }

    if(RDNAttributes[0].Value.pbData)
    {
        SSFree(RDNAttributes[0].Value.pbData);
    }

    return fRet;
}

BOOL ConvertRecoveredBlobToW2KBlob(
    IN      BYTE *pbMasterKey,
    IN      DWORD cbMasterKey,
    IN      PBYTE pbLocalKey,
    IN      DWORD cbLocalKey,
    IN      PSID pSidCandidate,
    IN  OUT BYTE **ppbDataOut,
    IN  OUT DWORD *pcbDataOut)
{

    BYTE rgbBKEncryptionKey[ A_SHA_DIGEST_LEN ];

    DWORD cbSidCandidate=0;

    PMASTERKEY_BLOB_W2K pMasterKeyBlob = NULL;
    DWORD cbMasterKeyBlob;
    DWORD cbMasterInnerKeyBlob;
    PMASTERKEY_INNER_BLOB_W2K pMasterKeyInnerBlob = NULL;

    PBYTE pbCipherBegin;

    RC4_KEYSTRUCT sRC4Key;
    BYTE rgbMacKey[A_SHA_DIGEST_LEN];

    DWORD dwLastError = (DWORD)NTE_BAD_KEY;


    BYTE rgbSymKey[A_SHA_DIGEST_LEN*2]; // big enough to handle 3des keys



    if(!IsValidSid(pSidCandidate)) {
        goto cleanup;
    }

    cbSidCandidate = GetLengthSid(pSidCandidate);
       

    //
    // derive BK encryption key from decrypted Local Key.
    //

    FMyPrimitiveSHA( pbLocalKey, cbLocalKey, rgbBKEncryptionKey );


    cbMasterInnerKeyBlob = sizeof(MASTERKEY_INNER_BLOB_W2K) +
                    cbMasterKey ;

    cbMasterKeyBlob = sizeof(MASTERKEY_BLOB_W2K) +
                    cbMasterInnerKeyBlob;


    pMasterKeyBlob = (PMASTERKEY_BLOB_W2K)SSAlloc( cbMasterKeyBlob );
    if(pMasterKeyBlob == NULL)
    {
        dwLastError =  ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto cleanup;
    }


    pMasterKeyBlob->dwVersion = MASTERKEY_BLOB_VERSION_W2K;
    pMasterKeyInnerBlob = 
        (PMASTERKEY_INNER_BLOB_W2K)(pMasterKeyBlob + 1);
    

    //
    // generate random R2 for SymKey
    //

    if(!RtlGenRandom(pMasterKeyBlob->R2, MASTERKEY_R2_LEN_W2K))
        goto cleanup;

    //
    // generate random R3 for MAC
    //

    if(!RtlGenRandom(pMasterKeyInnerBlob->R3, MASTERKEY_R3_LEN_W2K))
        goto cleanup;


    //
    // derive symetric key via rgbMKEncryptionKey and random R2
    //

    if(!FMyPrimitiveHMACParam(
                    rgbBKEncryptionKey,
                    A_SHA_DIGEST_LEN,
                    pMasterKeyBlob->R2,
                    MASTERKEY_R2_LEN_W2K,
                    rgbSymKey
                    ))
        goto cleanup;

        //
        // derive MAC key via HMAC from rgbMKEncryptionKey and random R3.
        //

    if(!FMyPrimitiveHMACParam(
                    rgbBKEncryptionKey,
                    A_SHA_DIGEST_LEN,
                    pMasterKeyInnerBlob->R3,
                    MASTERKEY_R3_LEN_W2K,
                    rgbMacKey   // resultant MAC key
                    ))
        goto cleanup;
    pbCipherBegin = (PBYTE)(pMasterKeyInnerBlob+1);


    //
    // copy pbMasterKey following inner MAC'ish blob.
    //


    CopyMemory( pbCipherBegin, pbMasterKey, cbMasterKey );

    //
    // use MAC key to derive result from pbMasterKey
    //

    if(!FMyPrimitiveHMACParam(
                    rgbMacKey,
                    sizeof(rgbMacKey),
                    pbMasterKey,
                    cbMasterKey,
                    pMasterKeyInnerBlob->MAC // resultant MAC for verification.
                    ))
        goto cleanup;







    rc4_key(&sRC4Key, A_SHA_DIGEST_LEN, rgbSymKey);

    rc4(&sRC4Key, 
        cbMasterInnerKeyBlob, 
        (PBYTE)pMasterKeyInnerBlob);


    *ppbDataOut = (PBYTE)pMasterKeyBlob;
    *pcbDataOut = cbMasterKeyBlob;

    pMasterKeyBlob = NULL; // prevent free of blob on success (caller does it).

    dwLastError = ERROR_SUCCESS;

cleanup:

    if(pMasterKeyBlob) {
        ZeroMemory(pMasterKeyBlob, cbMasterKeyBlob);
        SSFree(pMasterKeyBlob);
    }

    SetLastError(dwLastError);
    return (dwLastError == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\keysrv.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    keybckup.h

Abstract:

    This module contains routines associated with server side Key Backup
    operations.

Author:

    Scott Field (sfield)    16-Aug-97

--*/

#ifndef __KEYSRV_H__
#define __KEYSRV_H__


DWORD
StartBackupKeyServer(
    VOID
    );

DWORD
StopBackupKeyServer(
    VOID
    );

DWORD
GetSystemCredential(
    IN      BOOL fLocalMachine,
    IN OUT  BYTE rgbCredential[ A_SHA_DIGEST_LEN ]
    );

BOOL
UpdateSystemCredentials(
    VOID
    );

BOOL
GetDomainControllerName(
    IN      HANDLE hToken,
    IN  OUT LPWSTR wszDomainControllerName,
    IN  OUT PDWORD pcchDomainControllerName,
    IN      BOOL   fRediscover
    );

#endif  // __KEYSRV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\keyman.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    keyman.h

Abstract:

    This module contains routines to manage master keys in the cliet.  This
    includes retrieval, backup and restore.

Author:

    Scott Field (sfield)    09-Sep-97

--*/

#ifndef __KEYMAN_H__
#define __KEYMAN_H__


#if 0

    The layout of the registry is as follows:

    HKEY_CURRENT_LUSER\...\Cryptography\Protect\<UserId>\

    note:  Protect key and all subkeys Acl'd for Local System access

    MasterKeys\

    Policy = (REG_DWORD value), policy bits of master keys; eg, don't backup, local only backup, local + DC recovery)
    Preferred = (REG_BINARY value containing MASTERKEY_PREFERRED_INFO),
                Indicates the GUID of the preferred master key, and
                when the key expires.
    <GUID> = (Subkey) Textual form of a master key, identified by GUID.
        LK = (REG_BINARY data), randomly generated local backup key, created if policy permits. [obfuscated]
        MK = (REG_BINARY data), master key data, encrypted with logon credential (WinNT) or obfuscated (Win95)
        BK = (REG_BINARY data), master key data, encrypted with LK, if policy permits.
        BBK = (REG_BINARY data), master key data, encrypted with LK and DC recovery key, if policy permits.
    <GUID...> = any number of additional subkeys representing master keys and associated data.

#endif // 0


#define REGVAL_PREFERRED_MK                 L"Preferred"
#define REGVAL_POLICY_MK                    L"ProtectionPolicy"

#define REGVAL_MK_DEFAULT_ITERATION_COUNT   L"MasterKeyIterationCount"
#define REGVAL_MK_LEGACY_COMPLIANCE         L"MasterKeyLegacyCompliance"
#define REGVAL_MK_LEGACY_NT4_DOMAIN         L"MasterKeyLegacyNt4Domain"

// MasterKeys\<GUID>\<value>
#define REGVAL_MASTER_KEY       0 // L"MK"   // masterkey, encrypted with user credential
#define REGVAL_LOCAL_KEY        1 // L"LK"   // phase one backup blob encryption key
#define REGVAL_BACKUP_LCL_KEY   2 // L"BK"   // phase one backup blob
#define REGVAL_BACKUP_DC_KEY    3 // L"BBK"  // phase two backup blob

#define MK_DISP_OK              0 // normal disposition, no backup/restore occured
#define MK_DISP_BCK_LCL         1 // local backup/restore took place
#define MK_DISP_BCK_DC          2 // DC based backup/restore took place
#define MK_DISP_STORAGE_ERR     3 // error retrieving key from storage
#define MK_DISP_DELEGATION_ERR  4 // Recovery failure because delegation disabled
#define MK_DISP_UNKNOWN_ERR     5 // unknown error


// Policy bit for local only (no DC) backup
#define POLICY_LOCAL_BACKUP     0x1

// Policy bit for NO backup (Win95)
#define POLICY_NO_BACKUP        0x2

// Use the DPAPI One way function of the password (SHA_1(pw))
#define POLICY_DPAPI_OWF        0x4

#define MASTERKEY_MATERIAL_SIZE (64)    // size of the masterkey key material
#define LOCALKEY_MATERIAL_SIZE  (32)    // size of the localkey key material


#define MASTERKEY_R2_LEN            (16)
#define MASTERKEY_R3_LEN            (16)

#define DEFAULT_MASTERKEY_ITERATION_COUNT (4000)    // 4000 == ~100ms on 400 MHz machine

//
// the MASTERKEY_STORED structure depicts all the data that may be associated
// with a single master key entity.
//

typedef struct {
    DWORD dwVersion;
    BOOL fModified;             // have contents been modified, deeming a persist operation?
    LPWSTR szFilePath;          // path (not including filename) to the file for persist operation
    WCHAR wszguidMasterKey[MAX_GUID_SZ_CHARS]; // filename (GUID based)

    DWORD dwPolicy;             // policy bits on this key

    DWORD cbMK;                 // count of bytes associated with pbMK (Zero if not present)
    PBYTE pbMK;                 // MasterKey data.  NULL if not present

    DWORD cbLK;                 // count of bytes associated with pbLK (Zero if not present)
    PBYTE pbLK;                 // LocalKey data.  NULL if not present

    DWORD cbBK;                 // count of bytes associated with pbBK (Zero if not present)
    PBYTE pbBK;                 // BackupLocalKey data.  NULL if not present

    DWORD cbBBK;                // count of bytes associated with pbBBK (Zero if not present)
    PBYTE pbBBK;                // BackupDCKey data.  NULL if not present

} MASTERKEY_STORED, *PMASTERKEY_STORED, *LPMASTERKEY_STORED;

//
// the on-disk version of the structure is neccessary to allow 64bit and 32bit
// platform interop with upgraded systems or roaming files.
// pointers are changed to 32bit offsets
//

typedef struct {
    DWORD dwVersion;
    BOOL fModified;             // have contents been modified, deeming a persist operation?
    DWORD szFilePath;           // invalid on disk
    WCHAR wszguidMasterKey[MAX_GUID_SZ_CHARS]; // filename (GUID based)

    DWORD dwPolicy;             // policy bits on this key

    DWORD cbMK;                 // count of bytes associated with pbMK (Zero if not present)
    DWORD pbMK;                 // invalid on disk

    DWORD cbLK;                 // count of bytes associated with pbLK (Zero if not present)
    DWORD pbLK;                 // invalid on disk

    DWORD cbBK;                 // count of bytes associated with pbBK (Zero if not present)
    DWORD pbBK;                 // invalid on disk

    DWORD cbBBK;                // count of bytes associated with pbBBK (Zero if not present)
    DWORD pbBBK;                // invalid on disk

} MASTERKEY_STORED_ON_DISK, *PMASTERKEY_STORED_ON_DISK, *LPMASTERKEY_STORED_ON_DISK;

//
// VERSION1: LK is not encrypted with LSA Secret when POLICY_LOCAL_BACKUP is set
// VERSION2: LK is encrypted with LSA Secret when POLICY_LOCAL_BACKUP is set
//#define MASTERKEY_STORED_VERSION 1
#define MASTERKEY_STORED_VERSION 2

typedef struct {
    DWORD dwVersion;            // version of structure (MASTERKEY_BLOB_VERSION)
    BYTE R2[MASTERKEY_R2_LEN];  // random data used during HMAC to derive symetric key
    DWORD IterationCount;       // PKCS5 iteration count
    DWORD KEYGENAlg;            // PKCS5 Key Generation Alg, in CAPI ALG_ID form
    DWORD EncryptionAlg;        // Encryption Alg, in CAPI ALG_ID form
} MASTERKEY_BLOB, *PMASTERKEY_BLOB, *LPMASTERKEY_BLOB;


typedef struct {
    BYTE R3[MASTERKEY_R3_LEN];  // random data used to derive MAC key
    BYTE MAC[A_SHA_DIGEST_LEN]; // MAC(R3, pbMasterKey)
    DWORD Padding;              // Padding to make masterkey inner blob divisable by
                                // 3DES_BLOCKLEN
} MASTERKEY_INNER_BLOB, *PMASTERKEY_INNER_BLOB, *LPMASTERKEY_INNER_BLOB;




typedef struct {
    DWORD   dwVersion;            // version of structure MASTERKEY_BLOB_LOCALKEY_BACKUP 
    GUID    CredentialID;         // indicates the credential id used to protect the
                                  // master key.
} LOCAL_BACKUP_DATA, *PLOCAL_BACKUP_DATA, *LPLOCAL_BACKUP_DATA;


//
// 90 day masterkey expiration
//

#define MASTERKEY_EXPIRES_DAYS  (90)

typedef struct {
    GUID guidPreferredKey;
    FILETIME ftPreferredKeyExpires;
} MASTERKEY_PREFERRED_INFO, *PMASTERKEY_PREFERRED_INFO, *LPMASTERKEY_PREFERRED_INFO;

//
// deferred backup structure.
//

typedef struct {
    DWORD cbSize;           // sizeof(QUEUED_BACKUP)
    MASTERKEY_STORED hMasterKey;
    HANDLE hToken;          // client access token
    PBYTE pbLocalKey;
    DWORD cbLocalKey;
    PBYTE pbMasterKey;
    DWORD cbMasterKey;
    HANDLE hEventThread;    // Event that signals thread finished processing
    HANDLE hEventSuccess;   // Event signalled indicates thread did successful backup
} QUEUED_BACKUP, *PQUEUED_BACKUP, *LPQUEUED_BACKUP;

//
// deferred key sync structure.
//

typedef struct {
    DWORD cbSize;           // sizeof(QUEUED_SYNC)
    PVOID pvContext;        // duplicated server context
} QUEUED_SYNC, *PQUEUED_SYNC, *LPQUEUED_SYNC;


DWORD
GetSpecifiedMasterKey(
    IN      PVOID pvContext,        // server context
    IN  OUT GUID *pguidMasterKey,
        OUT LPBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey,
    IN      BOOL fSpecified         // get specified pguidMasterKey key ?
    );

DWORD
InitiateSynchronizeMasterKeys(
    IN      PVOID pvContext         // server context
    );

DWORD
WINAPI
SynchronizeMasterKeys(
    IN PVOID pvContext,
    IN DWORD dwFlags);

VOID
DPAPISynchronizeMasterKeys(
    IN HANDLE hUserToken);

BOOL
InitializeKeyManagement(
    VOID
    );

BOOL
TeardownKeyManagement(
    VOID
    );

DWORD
DpapiUpdateLsaSecret(
    IN PVOID pvContext);

DWORD
OpenFileInStorageArea(
    IN      PVOID pvContext,            // if NULL, caller is assumed to be impersonating
    IN      DWORD   dwDesiredAccess,
    IN      LPCWSTR szUserStorageArea,
    IN      LPCWSTR szFileName,
    IN OUT  HANDLE  *phFile
    );

HANDLE
CreateFileWithRetries(
    IN      LPCWSTR lpFileName,
    IN      DWORD dwDesiredAccess,
    IN      DWORD dwShareMode,
    IN      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN      DWORD dwCreationDisposition,
    IN      DWORD dwFlagsAndAttributes,
    IN      HANDLE hTemplateFile
    );

#endif  // __KEYMAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\memprot.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    memprot.h

Abstract:

    This module contains routines for accessing sensitive data stored in
    memory in encrypted form.

Author:

    Scott Field (sfield)    07-Nov-98

Revision History:

--*/

#ifndef __MEMPROT_H__
#define __MEMPROT_H__

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


VOID
LsaProtectMemory(
    VOID        *pData,
    ULONG       cbData
    );

extern "C"
VOID
LsaUnprotectMemory(
    VOID        *pData,
    ULONG       cbData
    );

#ifdef __cplusplus
}
#endif // __cplusplus


#endif  // __MEMPROT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\lnklist.cpp ===
#include <pch.cpp>
#pragma hdrstop

#include "crtem.h"











////////////////////////
// Cryptographic Provider handle list

CCryptProvList::CCryptProvList()
{
    m_pfnIsMatch = CryptProvIsMatch;
    m_pfnFreeElt = CryptProvFreeElt;
}

void CreateCryptProvListItem(CRYPTPROV_LIST_ITEM* pli,
                        DWORD       dwAlgId1,
                        DWORD       dwKeySize1,
                        DWORD       dwAlgId2,
                        DWORD       dwKeySize2,
                        HCRYPTPROV  hProvider)
{
    pli->pNext = NULL;

    pli->dwAlgId1 = dwAlgId1;
    pli->dwKeySize1 = dwKeySize1;

    pli->dwAlgId2 = dwAlgId2;
    pli->dwKeySize2 = dwKeySize2;

    pli->hProv = hProvider;
}

BOOL CryptProvIsMatch(
        ELT* pCandidate,
        ELT* pTemplate)
{
    PCRYPTPROV_LIST_ITEM pliCandidate = (PCRYPTPROV_LIST_ITEM) pCandidate;
    PCRYPTPROV_LIST_ITEM pliTemplate = (PCRYPTPROV_LIST_ITEM) pTemplate;

    // if both algids match
    if ((pliCandidate->dwAlgId1 == pliTemplate->dwAlgId1) &&
        (pliCandidate->dwAlgId2 == pliTemplate->dwAlgId2))
    {
        // if both sizes match
        if ((pliCandidate->dwKeySize1 == -1) ||
            (pliTemplate->dwKeySize1 == -1) ||
            (pliCandidate->dwKeySize1 == pliTemplate->dwKeySize1))
        {
            if ((pliCandidate->dwKeySize2 == -1) ||
                (pliTemplate->dwKeySize2 == -1) ||
                (pliCandidate->dwKeySize2 == pliTemplate->dwKeySize2))
               return TRUE;
        }
    }

    return FALSE;
}

void CryptProvFreeElt(
        ELT* p)
{
    if (NULL == p)
        return;

    PCRYPTPROV_LIST_ITEM pli = (PCRYPTPROV_LIST_ITEM) p;

    // do all necessary freeing
    if (pli->hProv != 0)
        CryptReleaseContext((HCRYPTPROV)pli->hProv, 0);

    ZeroMemory(pli, sizeof(CRYPTPROV_LIST_ITEM)); // make sure contents invalid

    SSFree(pli);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\lnklist.h ===
#ifndef __LNKLIST_H__
#define __LNKLIST_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "pstypes.h"
#include "listbase.h"
#include <sha.h>



//////////////////////////////
// CryptProv list

// item list element
typedef struct _CRYPTPROV_LIST_ITEM
{
    // internal to list
    struct _CRYPTPROV_LIST_ITEM *      pNext;

    // Lookup device
//    DWORD                   dwProvID;
    DWORD                   dwAlgId1;
    DWORD                   dwKeySize1;

    DWORD                   dwAlgId2;
    DWORD                   dwKeySize2;

    // item data
    HCRYPTPROV              hProv;

} CRYPTPROV_LIST_ITEM, *PCRYPTPROV_LIST_ITEM;

class CCryptProvList : public CLinkedList
{

public:
    CCryptProvList();

    BOOL                AddToList(PCRYPTPROV_LIST_ITEM pli)
    {   return CLinkedList::AddToList((ELT*)pli);   }

    BOOL    DelFromList(PCRYPTPROV_LIST_ITEM pli)
    {   return CLinkedList::DelFromList((ELT*)pli);  }

    PCRYPTPROV_LIST_ITEM   SearchList(PCRYPTPROV_LIST_ITEM pli)
    {   return (PCRYPTPROV_LIST_ITEM)  CLinkedList::SearchList((ELT*)pli);  }

};


///////////////////////////
// Associated functions
void CreateCryptProvListItem(CRYPTPROV_LIST_ITEM* pli,
                        DWORD       dwAlgId1,
                        DWORD       dwKeySize1,
                        DWORD       dwAlgId2,
                        DWORD       dwKeySize2,
                        HCRYPTPROV  hCryptProv);

BOOL CryptProvIsMatch(
        ELT* pCandidate,
        ELT* pTemplate);

void CryptProvFreeElt(
        ELT* p);





#ifdef __cplusplus
}
#endif

#endif // __LNKLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\misc.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    misc.cpp

Abstract:

    Functionality in this module:

       Globals management   

Author:

    Pete Skelly (petesk) 23-Mar-00

--*/


#include <pch.cpp>
#pragma hdrstop



//
// Registry Setable Globals, and handlign goo
//

// Must access key via api's
static HKEY g_hProtectedStorageKey = NULL;

static HANDLE g_hProtectedStorageChangeEvent = NULL;

static CRITICAL_SECTION g_csGlobals;

static BOOL g_fcsGlobalsInitialized = FALSE;

// key management globals
static DWORD   g_IterationCount = DEFAULT_MASTERKEY_ITERATION_COUNT;
static BOOL    g_LegacyMode = FALSE;
static BOOL    g_LegacyModeNt4Domain = FALSE;
static DWORD   g_dwMasterKeyDefaultPolicy = 0;


// define softcoded constants we use
static DWORD        g_dwDefaultCryptProvType    = PROV_RSA_FULL;

static DWORD        g_dwAlgID_Encr_Alg          = CALG_3DES;
static DWORD        g_dwAlgID_Encr_Alg_KeySize  = -1;           // any size

static DWORD        g_dwAlgID_MAC_Alg           = CALG_SHA1;
static DWORD        g_dwAlgID_MAC_Alg_KeySize   = -1;           // any size

typedef struct _ALG_TO_STRING
{
    DWORD   AlgId;
    LPCWSTR  wszString;
} ALG_TO_STRING;


ALG_TO_STRING g_AlgToString[] =
{
    { CALG_MD2, L"MD2-%d " },
    { CALG_MD4, L"MD4-%d " },
    { CALG_MD5, L"MD5-%d " },
    { CALG_SHA1, L"SHA1-%d " },
    { CALG_DES, L"DES-%d " },
    { CALG_3DES_112, L"3DES-%d " },
    { CALG_3DES, L"3DES-%d " },
    { CALG_DESX, L"DESX-%d " },
    { CALG_RC2, L"RC2-%d " },
    { CALG_RC4, L"RC4-%d " },
    { CALG_SEAL, L"SEAL-%d " },
    { CALG_RSA_SIGN, L"RSA Signature-%d " },
    { CALG_RSA_KEYX, L"RSA Exchange-%d " },
    { CALG_DSS_SIGN, L"DSS-%d " },
    { CALG_DH_SF, L"DH-%d " },
    { CALG_DH_EPHEM, L"DH Ephemeral-%d " },
    { CALG_KEA_KEYX, L"KEA Exchange-%d " },
    { CALG_SKIPJACK, L"SKIPJACK-%d " },
    { CALG_TEK, L"TEK-%d " },
    { CALG_RC5, L"RC5-%d " },
    { CALG_HMAC, L"HMAC-%d " }
};

DWORD   g_cAlgToString = sizeof(g_AlgToString)/sizeof(g_AlgToString[0]);


// supply a new, delete operator
void * __cdecl operator new(size_t cb)
{
    return SSAlloc( cb );
}

void __cdecl operator delete(void * pv)
{
    SSFree( pv );
}




DWORD AlgIDToString(LPWSTR wszString, DWORD dwAlgID, DWORD dwStrength)
{
    DWORD i;
    for(i=0; i < g_cAlgToString; i++)
    {
        if(dwAlgID == g_AlgToString[i].AlgId)
        {
            return wsprintf(wszString, g_AlgToString[i].wszString, dwStrength);
        }
    }
    return wsprintf(wszString, L"Unknown 0x%lx - %d", dwAlgID, dwStrength);
}


DWORD UpdateGlobals(BOOL fForce)
{
    DWORD lRet = ERROR_SUCCESS;
    DWORD dwDisposition;

    if(NULL == g_fcsGlobalsInitialized ||
       NULL == g_hProtectedStorageKey ||
       NULL == g_hProtectedStorageChangeEvent)
    {
        return ERROR_SUCCESS;
    }

    if(WAIT_OBJECT_0 == WaitForSingleObject(g_hProtectedStorageChangeEvent, 0))
    {
        // Update the globals, as they have changed

        DWORD dwParameterValue;
        DWORD cbParameter = sizeof(dwParameterValue);
        DWORD dwValueType;

        EnterCriticalSection(&g_csGlobals);

        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        REGVAL_MK_DEFAULT_ITERATION_COUNT,
                        NULL,
                        &dwValueType,
                        (LPBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) {

            //
            // Only allow policy to increase the iteration
            // count, never decrease it.
            // 
            if( dwParameterValue > g_IterationCount) {
                g_IterationCount = dwParameterValue;
            }
        }

        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        REGVAL_MK_LEGACY_COMPLIANCE,
                        NULL,
                        &dwValueType,
                        (LPBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            if( dwParameterValue != 0) {
                g_LegacyMode = TRUE;
            }
        }

        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        REGVAL_MK_LEGACY_NT4_DOMAIN,
                        NULL,
                        &dwValueType,
                        (LPBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if((lRet == ERROR_SUCCESS) && 
           (dwValueType == REG_DWORD) &&
           (dwParameterValue != 0))
        {
            g_LegacyModeNt4Domain = TRUE;
        }
        else
        {
            g_LegacyModeNt4Domain = FALSE;
        }

        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        REGVAL_POLICY_MK,
                        NULL,
                        &dwValueType,
                        (LPBYTE)&dwParameterValue,
                        &cbParameter
                        );

        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) {

            //
            // Only allow policy to increase the iteration
            // count, never decrease it.
            // 


            if( dwParameterValue == 1 ) {
                g_dwMasterKeyDefaultPolicy = POLICY_LOCAL_BACKUP;
            }
        }


        cbParameter = sizeof(DWORD);
        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_ENCR_ALG,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            g_dwAlgID_Encr_Alg = dwParameterValue;
        }

        cbParameter = sizeof(DWORD);
        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_ENCR_ALG_KEYSIZE,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            g_dwAlgID_Encr_Alg_KeySize = dwParameterValue;
        }

        cbParameter = sizeof(DWORD);
        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_MAC_ALG,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            g_dwAlgID_MAC_Alg = dwParameterValue;
        }

        cbParameter = sizeof(DWORD);
        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_MAC_ALG_KEYSIZE,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            g_dwAlgID_MAC_Alg_KeySize = dwParameterValue;
        }

        cbParameter = sizeof(DWORD);
        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_CRYPT_PROV_TYPE,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            g_dwDefaultCryptProvType = dwParameterValue;
        }


        // Register to be notified of future registry changes.
        lRet = RegNotifyChangeKeyValue(g_hProtectedStorageKey,
                            TRUE,  // bWatchSubtree
                            REG_NOTIFY_CHANGE_LAST_SET |
                            REG_NOTIFY_CHANGE_NAME,
                            g_hProtectedStorageChangeEvent,
                            TRUE);

        if(ERROR_SUCCESS != lRet)
        {
            //
            // If notify failed, we no longer notify, so we don't need to handle anymore
            CloseHandle(g_hProtectedStorageChangeEvent);
            g_hProtectedStorageChangeEvent = NULL;
        }

        LeaveCriticalSection(&g_csGlobals);
    }

    return lRet;
}

DWORD IntializeGlobals()
{

    DWORD lRet = ERROR_SUCCESS;
    DWORD dwDisposition;
    static const WCHAR szProviderKeyName[] = REG_CRYPTPROTECT_LOC L"\\" REG_CRYPTPROTECT_PROVIDERS_SUBKEYLOC L"\\" CRYPTPROTECT_DEFAULT_PROVIDER_GUIDSZ ;

    __try
    {
        InitializeCriticalSection(&g_csGlobals);
        g_fcsGlobalsInitialized = TRUE;

        lRet = RegCreateKeyExU(
                    HKEY_LOCAL_MACHINE,
                    szProviderKeyName,
                    0,
                    NULL,
                    0,
                    KEY_QUERY_VALUE | KEY_NOTIFY,
                    NULL,
                    &g_hProtectedStorageKey,
                    &dwDisposition
                    );

        if(lRet != ERROR_SUCCESS)
        {
            goto error;
        }
        g_hProtectedStorageChangeEvent = CreateEvent(NULL, 
                                                     FALSE,
                                                     TRUE,
                                                     NULL);


        lRet = UpdateGlobals(TRUE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        lRet = GetExceptionCode();
    }


error:

    return lRet;
}




DWORD ShutdownGlobals()
{

    DWORD lRet = ERROR_SUCCESS;
    DWORD dwDisposition;


    if(g_hProtectedStorageKey)
    {
        RegCloseKey(g_hProtectedStorageKey);
        g_hProtectedStorageKey = NULL;
    }

    if(g_hProtectedStorageChangeEvent)
    {
        CloseHandle(g_hProtectedStorageChangeEvent);
        g_hProtectedStorageChangeEvent = NULL;
    }

    if(g_fcsGlobalsInitialized)
    {
        DeleteCriticalSection(&g_csGlobals);
    }

    return lRet;
}


DWORD GetIterationCount()
{
    UpdateGlobals(FALSE);
    return g_IterationCount;
}

BOOL FIsLegacyCompliant()
{
    UpdateGlobals(FALSE);
    return g_LegacyMode;
}

BOOL FIsLegacyNt4Domain()
{
    UpdateGlobals(FALSE);
    return g_LegacyModeNt4Domain;
}


DWORD GetMasterKeyDefaultPolicy()
{
    UpdateGlobals(FALSE);
    return g_dwMasterKeyDefaultPolicy;
}


DWORD GetDefaultAlgInfo(DWORD *pdwProvType,
                        DWORD *pdwEncryptionAlg,
                        DWORD *pdwEncryptionAlgSize,
                        DWORD *pdwMACAlg,
                        DWORD *pdwMACAlgSize)
{

    UpdateGlobals(FALSE);

    if(g_fcsGlobalsInitialized)
    {
        EnterCriticalSection(&g_csGlobals);
    }

    if(pdwProvType)
    {
        *pdwProvType = g_dwDefaultCryptProvType;
    }
    if(pdwEncryptionAlg)
    {
        *pdwEncryptionAlg = g_dwAlgID_Encr_Alg;
    }
    if(pdwEncryptionAlgSize)
    {
        *pdwEncryptionAlgSize = g_dwAlgID_Encr_Alg_KeySize;
    }
    if(pdwMACAlg)
    {
        *pdwMACAlg = g_dwAlgID_MAC_Alg;
    }
    if(pdwMACAlgSize)
    {
        *pdwMACAlgSize = g_dwAlgID_MAC_Alg_KeySize;
    }
    if(g_fcsGlobalsInitialized)
    {
        LeaveCriticalSection(&g_csGlobals);
    }
    return ERROR_SUCCESS;
}


void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String
    )
{
    DWORD StringLength;

    if(String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\pch.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pch.cpp

Abstract:

    pch header files


Author:

    petesk 2/2/2000

Revision History:

    

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lm.h>
#include <rpc.h>

// crypto headers
#include <shlobj.h>
#include <wincrypt.h>
#include <sha.h>
#include <rc4.h>
#include <des.h>
#include <tripldes.h>
#include <modes.h>
#include <crypt.h>


extern "C"
{
// Private LSA functionality
#include <ntsam.h>
#include <ntlsa.h>
#include <samrpc.h>
#include <samisrv.h>
#include <lsarpc.h>
#include <lsaisrv.h> 
}


#include "lnklist.h"
#include "crypt32.h"

#include "guidcnvt.h"
#include "dpapiprv.h"
#include "passrecp.h"
#include "dprpc.h" 
#include "keyrpc.h"
#include "keyback.h"
#include "keysrv.h"
#include "memprot.h"
#include "keyman.h"
#include "keycache.h"
#include "keybckup.h"
#include "crtem.h"
#include "crypt32p.h"
#include "capiprim.h"
#include "unicode.h"
#include "unicode5.h"
#include "secmisc.h"
#include "filemisc.h"
#include "primitiv.h"

#include "pmacros.h"

#include "debug.h"
#include "misc.h"

#include "dsysdbg.h"
#include "dpapidbg.h"

#include "resource.h"
#include "session.h"
#include "recovery.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\misc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    misc.h

Abstract:

    This module contains various DPAPI declarations.

Author:

    jbanes      10-11-2000

--*/

#define DPAPI_PACKAGE_NAME_A  "DPAPI"

extern TOKEN_SOURCE DPAPITokenSource;

extern PLSA_SECPKG_FUNCTION_TABLE g_pSecpkgTable;

extern RTL_CRITICAL_SECTION g_csCredHistoryCache;


DWORD IntializeGlobals();

DWORD ShutdownGlobals();

DWORD GetIterationCount();
BOOL  FIsLegacyCompliant();
BOOL  FIsLegacyNt4Domain();
DWORD GetMasterKeyDefaultPolicy();

#define MAX_STRING_ALGID_LENGTH 30
DWORD AlgIDToString(LPWSTR wszString, DWORD dwAlgID, DWORD dwStrength );


DWORD GetDefaultAlgInfo(DWORD *pdwProvType,
                        DWORD *pdwEncryptionAlg,
                        DWORD *pdwEncryptionAlgSize,
                        DWORD *pdwMACAlg,
                        DWORD *pdwMACAlgSize);

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString, // destination
    LPWSTR String                  // source (Unicode)
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\recovery.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    recovery.h

Abstract:

    This module contains prototypes to support local account password recovery.

Author:

    Pete Skelly (petesk)    09-May-00

--*/

#ifndef __RECOVERY_H__
#define __RECOVERY_H__

#ifdef __cplusplus
extern "C" {
#endif

DWORD 
SPRecoverQueryStatus(
    PVOID pvContext,
    LPWSTR pszUserName,
    DWORD *pdwStatus);

DWORD
PRCreateDummyToken(
    PUNICODE_STRING Username,
    PUNICODE_STRING Domain,
    HANDLE *Token);

DWORD               
PRGetProfilePath(
    HANDLE hUserToken,
    PUNICODE_STRING UserName,
    PWSTR pszPath);

DWORD 
RecoverChangePasswordNotify(
    HANDLE UserToken,
    BYTE OldPasswordOWF[A_SHA_DIGEST_LEN], 
    PUNICODE_STRING NewPassword);


#ifdef __cplusplus
}
#endif


#endif // __RECOVERY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\recovery.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    recovery.c

Abstract:

    This module contains code to handle the local key recovery case.

Author:

    Pete Skelly (petesk)    May 9, 2000

--*/

#include <pch.cpp>
#pragma hdrstop
#include <ntmsv1_0.h>
#include <crypt.h>
#include <userenv.h>
#include <userenvp.h>
#include "debug.h"
#include "passrec.h"
#include "passrecp.h"
#include "pasrec.h"
#include <kerberos.h>

#define RECOVERY_KEY_BASE       L"Security\\Recovery\\"
#define RECOVERY_FILENAME       L""
#define RECOVERY_STORE_NAME     L"Recovery"


DWORD
CPSCreateServerContext(
    PCRYPT_SERVER_CONTEXT pServerContext,
    handle_t hBinding
    );

DWORD
CPSDeleteServerContext(
    PCRYPT_SERVER_CONTEXT pServerContext
    );


DWORD
DecryptRecoveryPassword(
    IN PSID pUserSid,
    IN PBYTE pbRecoveryPrivate,
    IN DWORD cbRecoveryPrivate,
    OUT LPWSTR *ppszPassword);

DWORD
ResetLocalUserPassword(
    LPWSTR pszDomain,
    LPWSTR pszUsername,
    LPWSTR pszOldPassword,
    LPWSTR pszNewPassword);

NTSTATUS
PRCreateLocalToken(
    PUNICODE_STRING Username,
    PUNICODE_STRING Domain,
    HANDLE *Token);


DWORD 
EncryptRecoveryPassword(
    IN HANDLE hUserToken,
    IN PCCERT_CONTEXT pCertContext,
    IN PUNICODE_STRING pNewPassword)
{
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hkRecoveryPublic = 0;

    PRECOVERY_SUPPLEMENTAL_CREDENTIAL pNewCred = NULL;
    DWORD                             cbNewCred = 0;

    BYTE  NewPasswordOWF[A_SHA_DIGEST_LEN];

    PBYTE pbPasswordBuffer = NULL;
    DWORD cbPasswordBuffer = 0;
    PBYTE pbSignature = NULL;
    DWORD cbSignature = 0;

    DWORD      cbTemp = 0;
    DWORD      cbKeySize = 0;
    PSID pUserSid = NULL;

    D_DebugLog((DEB_TRACE_API, "EncryptRecoveryPassword\n"));

    //
    // We have a cert with a good signature, so
    // go ahead and encrypt to it
    //
    if(!CryptAcquireContext(&hProv, 
                            NULL, 
                            MS_STRONG_PROV, 
                            PROV_RSA_FULL, 
                            CRYPT_VERIFYCONTEXT))
    {
        dwError = GetLastError();
        goto error;
    }

    if(!CryptImportPublicKeyInfoEx(hProv,
                               pCertContext->dwCertEncodingType,
                               &pCertContext->pCertInfo->SubjectPublicKeyInfo,
                               CALG_RSA_KEYX,
                               NULL,
                               NULL,
                               &hkRecoveryPublic))
    {
        dwError = GetLastError();
        goto error;
    }

    cbTemp = sizeof(cbKeySize);
    if(!CryptGetKeyParam(hkRecoveryPublic, 
                         KP_BLOCKLEN, 
                         (PBYTE)&cbKeySize, 
                         &cbTemp, 
                         0))
    {
        dwError = GetLastError();
        goto error;
    }

    cbKeySize >>= 3;  // convert from bits to bytes

    if((DWORD)pNewPassword->Length + 20 > cbKeySize)
    {
        dwError = ERROR_INVALID_DATA;
        goto error;
    }
    
    FMyPrimitiveSHA(
            (PBYTE)pNewPassword->Buffer,
            pNewPassword->Length,
            NewPasswordOWF);

#ifdef COMPILED_BY_DEVELOPER
    D_DebugLog((DEB_TRACE, "Password:%ls\n", pNewPassword->Buffer));

    D_DebugLog((DEB_TRACE, "Signature OWF:\n"));
    D_DPAPIDumpHexData(DEB_TRACE, "  ", NewPasswordOWF, sizeof(NewPasswordOWF));
#endif

    dwError = LogonCredGenerateSignature(
                  hUserToken,
                  pCertContext->pbCertEncoded,
                  pCertContext->cbCertEncoded,
                  NewPasswordOWF,
                  &pbSignature,
                  &cbSignature);

    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }

#ifdef COMPILED_BY_DEVELOPER
    D_DebugLog((DEB_TRACE, "Signature:\n"));
    D_DPAPIDumpHexData(DEB_TRACE, "  ", pbSignature, cbSignature);
#endif

    cbNewCred = sizeof(RECOVERY_SUPPLEMENTAL_CREDENTIAL) +
                A_SHA_DIGEST_LEN +
                cbSignature +
                cbKeySize;




    pNewCred = (PRECOVERY_SUPPLEMENTAL_CREDENTIAL)LocalAlloc(LMEM_FIXED, cbNewCred);
    if(NULL == pNewCred)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    
    pNewCred->dwVersion = RECOVERY_SUPPLEMENTAL_CREDENTIAL_VERSION;
    pNewCred->cbRecoveryCertHashSize = A_SHA_DIGEST_LEN;
    pNewCred->cbRecoveryCertSignatureSize = cbSignature;
    pNewCred->cbEncryptedPassword = 0;

    CopyMemory((PBYTE)(pNewCred+1)+A_SHA_DIGEST_LEN,
               pbSignature,
               cbSignature);



    if(!CertGetCertificateContextProperty(pCertContext, 
                                      CERT_HASH_PROP_ID,
                                      (PBYTE)(pNewCred+1),
                                      &pNewCred->cbRecoveryCertHashSize))
    {
        dwError = GetLastError();
        goto error;
    }


    CopyMemory((PBYTE)(pNewCred+1) + 
                        pNewCred->cbRecoveryCertHashSize +
                        pNewCred->cbRecoveryCertSignatureSize,
                        pNewPassword->Buffer,
                        pNewPassword->Length);

    pNewCred->cbEncryptedPassword = pNewPassword->Length;

        
    if(!CryptEncrypt(hkRecoveryPublic,
                     0,
                     TRUE,
                     0, //CRYPT_OAEP,
                     (PBYTE)(pNewCred+1) + 
                        pNewCred->cbRecoveryCertHashSize +
                        pNewCred->cbRecoveryCertSignatureSize,
                     &pNewCred->cbEncryptedPassword,
                     cbKeySize))
    {
        dwError = GetLastError();
        goto error;
    }


    //
    // Save the recovery data to the registry.
    //

    if(!GetTokenUserSid(hUserToken, &pUserSid))
    {
        dwError = GetLastError();
        goto error;
    }


    dwError = RecoverySetSupplementalCredential(
                                    pUserSid,
                                    pNewCred, 
                                    cbNewCred);


error:

    if(pUserSid)
    {
        SSFree(pUserSid);
    }

    ZeroMemory(NewPasswordOWF, sizeof(NewPasswordOWF));

    if(pbSignature)
    {
        LocalFree(pbSignature);
    }

    if(pNewCred)
    {
        ZeroMemory(pNewCred, cbNewCred);
    }


    if(hkRecoveryPublic)
    {
        CryptDestroyKey(hkRecoveryPublic);
    }

    if(hProv)
    {
        CryptReleaseContext(hProv,0);
    }

    D_DebugLog((DEB_TRACE_API, "EncryptRecoveryPassword returned 0x%x\n", dwError));

    return dwError;
}


DWORD 
RecoverFindRecoveryPublic(            
    HANDLE hUserToken,
    PSID pUserSid,
    PCCERT_CONTEXT *ppRecoveryPublic,
    PBYTE pbVerifyOWF,
    BOOL fVerifySignature)
{
    DWORD dwError = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertContext = NULL;
    PRECOVERY_SUPPLEMENTAL_CREDENTIAL pCred = NULL;
    DWORD                             cbCred = 0;

    HCERTSTORE hStore = NULL;
    PSID pLocalSid = NULL;

    CRYPT_HASH_BLOB HashBlob;

    D_DebugLog((DEB_TRACE_API, "RecoverFindRecoveryPublic\n"));

    if(NULL == ppRecoveryPublic)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

#ifdef COMPILED_BY_DEVELOPER
    D_DebugLog((DEB_TRACE, "Verify OWF:\n"));
    D_DPAPIDumpHexData(DEB_TRACE, "  ", pbVerifyOWF, A_SHA_DIGEST_LEN);
#endif

    if(pUserSid == NULL)
    {
        if(!GetTokenUserSid(hUserToken, &pLocalSid))
        {
            dwError = GetLastError();
            goto error;
        }
        pUserSid = pLocalSid;
    }

    dwError = RecoveryRetrieveSupplementalCredential(pUserSid, &pCred, &cbCred);
    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }


    // 
    // Validate cbCred
    //
    if((NULL == pCred) ||
       (sizeof(RECOVERY_SUPPLEMENTAL_CREDENTIAL) > cbCred) ||
       ( sizeof(RECOVERY_SUPPLEMENTAL_CREDENTIAL) + 
         pCred->cbRecoveryCertHashSize + 
         pCred->cbRecoveryCertSignatureSize + 
         pCred->cbEncryptedPassword > cbCred) ||
         (pCred->dwVersion != RECOVERY_SUPPLEMENTAL_CREDENTIAL_VERSION))
    {
        dwError = ERROR_INVALID_DATA;
        goto error;
    }

    // 
    // Attempt to find the recovery public
    //

    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                  X509_ASN_ENCODING,
                  NULL,
                  CERT_STORE_READONLY_FLAG | CERT_SYSTEM_STORE_LOCAL_MACHINE,
                  RECOVERY_STORE_NAME);

    if(NULL == hStore)
    {
        dwError = GetLastError();
        goto error;
    }

    HashBlob.cbData = pCred->cbRecoveryCertHashSize;
    HashBlob.pbData = (PBYTE)(pCred + 1);


    while(pCertContext = CertFindCertificateInStore(hStore, 
                                              X509_ASN_ENCODING,
                                              0,
                                              CERT_FIND_HASH,
                                              &HashBlob,
                                              pCertContext))
    {
        // we found one, verify it's signature
        // The signature verification will use the 'old password'
        // which will either be the current logon credential, or
        // will be in the password history

        if(fVerifySignature)
        {
            dwError = LogonCredVerifySignature( hUserToken,
                                                pCertContext->pbCertEncoded,
                                                pCertContext->cbCertEncoded,
                                                pbVerifyOWF,
                                                (PBYTE)(pCred + 1) + pCred->cbRecoveryCertHashSize,
                                                pCred->cbRecoveryCertSignatureSize);

            if(ERROR_SUCCESS == dwError)
            {
                break;
            }
        }
        else
        {
            dwError = ERROR_SUCCESS;
            break;
        }
    }


    if(NULL == pCertContext)
    {
        dwError = GetLastError();
        goto error;
    }

    *ppRecoveryPublic = pCertContext;
    pCertContext = NULL;

error:

    if(pLocalSid)
    {
        SSFree(pLocalSid);
    }

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    D_DebugLog((DEB_TRACE_API, "RecoverFindRecoveryPublic returned 0x%x\n", dwError));

    return dwError;
}


DWORD 
RecoverChangePasswordNotify(
    HANDLE UserToken,
    BYTE OldPasswordOWF[A_SHA_DIGEST_LEN], 
    PUNICODE_STRING NewPassword)
{
    DWORD dwError = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertContext = NULL;

    D_DebugLog((DEB_TRACE_API, "RecoverChangePasswordNotify\n"));

    // 
    // Validate cbCred
    //
    if(NULL == NewPassword)
    {
        dwError = ERROR_INVALID_DATA;
        goto error;
    }
    

    dwError = RecoverFindRecoveryPublic(UserToken,
                                        NULL,
                                        &pCertContext, 
                                        OldPasswordOWF,
                                        TRUE);          // verify signature 

    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }



    dwError = EncryptRecoveryPassword(UserToken,
                                      pCertContext,
                                      NewPassword);

    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }


error:


    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    D_DebugLog((DEB_TRACE_API, "RecoverChangePasswordNotify returned 0x%x\n", dwError));

    return dwError;
}


DWORD 
s_SSRecoverQueryStatus(
    handle_t h,
    PBYTE pbUserName,
    DWORD cbUserName,
    DWORD *pdwStatus)
{
    DWORD dwError;
    LPWSTR pszUserName = (LPWSTR)pbUserName;
    CRYPT_SERVER_CONTEXT ServerContext;

    // Make sure username is zero terminated.
    if(pbUserName == NULL || cbUserName < sizeof(WCHAR))
    {
        return ERROR_INVALID_PARAMETER;
    }
    if(pszUserName[(cbUserName - 1) / sizeof(WCHAR)] != L'\0')
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwError = CPSCreateServerContext(&ServerContext, h);
    if(dwError != ERROR_SUCCESS)
    {
        return dwError;
    }

    dwError = SPRecoverQueryStatus(&ServerContext,
                                   pszUserName,
                                   pdwStatus);

    CPSDeleteServerContext( &ServerContext );

    return dwError;
}


DWORD 
SPRecoverQueryStatus(
    PVOID pvContext,                // server context
    LPWSTR pszUserName,             // user name
    DWORD *pdwStatus)               // recovery status
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwDisp = RECOVERY_STATUS_OK;
    PCCERT_CONTEXT pCertContext = NULL;
    WCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cchMachineName;
    PSID pUserSid = NULL;
    DWORD cbSid = 0;
    SID_NAME_USE SidType; 
    PWSTR pszDomainName = NULL;
    DWORD cchDomainName = 0;
    HANDLE hToken = 0;
    UNICODE_STRING UserName;
    UNICODE_STRING Domain;
    BOOL fImpersonated = FALSE;

    D_DebugLog((DEB_TRACE_API, "SPRecoverQueryStatus\n"));
    D_DebugLog((DEB_TRACE_API, "User name:%ls\n", pszUserName));

    //
    // Attempt to obtain the SID for the specified user.
    //

    // Determine the (local user) domain.
    cchMachineName = sizeof(szMachineName) / sizeof(WCHAR);
    if(!GetComputerName(szMachineName, &cchMachineName))
    {
        dwError = GetLastError();
        goto cleanup;
    }

    if(!LookupAccountName(szMachineName,
                          pszUserName,
                          NULL,
                          &cbSid,
                          NULL,
                          &cchDomainName,
                          &SidType))
    {
        dwError = GetLastError();

        if(dwError != ERROR_INSUFFICIENT_BUFFER)
        {
            dwDisp = RECOVERY_STATUS_USER_NOT_FOUND;
            dwError = ERROR_SUCCESS;
            goto cleanup;
        }
    }

    pUserSid = (PBYTE)LocalAlloc(LPTR, cbSid);
    if(pUserSid == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    pszDomainName = (PWSTR)LocalAlloc(LPTR, cchDomainName * sizeof(WCHAR));
    if(pszDomainName == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    if(!LookupAccountName(szMachineName,
                          pszUserName,
                          pUserSid,
                          &cbSid,
                          pszDomainName,
                          &cchDomainName,
                          &SidType))
    {
        dwDisp = RECOVERY_STATUS_USER_NOT_FOUND;
        dwError = ERROR_SUCCESS;
        goto cleanup;
    }

    if(SidType != SidTypeUser)
    {
        dwDisp = RECOVERY_STATUS_USER_NOT_FOUND;
        dwError = ERROR_SUCCESS;
        goto cleanup;
    }


    // 
    // Attempt to find the recovery public
    //

    dwError = RecoverFindRecoveryPublic(NULL,
                                        pUserSid,
                                        &pCertContext, 
                                        NULL,       // current OWF
                                        FALSE);     // verify signature 
    if(ERROR_FILE_NOT_FOUND == dwError)
    {
        dwDisp = RECOVERY_STATUS_FILE_NOT_FOUND;
        dwError = ERROR_SUCCESS;
    } 
    else if(CRYPT_E_NOT_FOUND == dwError)
    {
        dwDisp = RECOVERY_STATUS_NO_PUBLIC_EXISTS;
        dwError = ERROR_SUCCESS;
    }
    else if(ERROR_INVALID_ACCESS == dwError)
    {
        dwDisp = RECOVERY_STATUS_PUBLIC_SIGNATURE_INVALID;
        dwError = ERROR_SUCCESS;
    }

cleanup:

    if(ERROR_SUCCESS == dwError)
    {
        D_DebugLog((DEB_TRACE_API, "Disposition: %d\n", dwDisp));
        *pdwStatus = dwDisp;
    }

    if(hToken)
    {
        CloseHandle(hToken);
    }

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(pUserSid) LocalFree(pUserSid);
    if(pszDomainName) LocalFree(pszDomainName);

    if(fImpersonated)
    {
        CPSRevertToSelf(pvContext);
    }

    D_DebugLog((DEB_TRACE_API, "SPRecoverQueryStatus returned 0x%x\n", dwError));

    return dwError;
}


NTSTATUS
VerifyCredentials(
    IN PWSTR UserName,
    IN PWSTR DomainName,
    IN PWSTR Password
    )
{
    PKERB_VERIFY_CREDENTIALS_REQUEST pVerifyRequest;
    KERB_VERIFY_CREDENTIALS_REQUEST VerifyRequest;

    ULONG cbVerifyRequest;

    PVOID pResponse = NULL;
    ULONG cbResponse;

    USHORT cbUserName;
    USHORT cbDomainName;
    USHORT cbPassword;

    NTSTATUS ProtocolStatus = STATUS_LOGON_FAILURE;
    NTSTATUS Status;

    UNICODE_STRING AuthenticationPackage;

    RtlInitUnicodeString(&AuthenticationPackage, MICROSOFT_KERBEROS_NAME_W);

    cbUserName = (USHORT)(lstrlenW(UserName) * sizeof(WCHAR)) ;
    cbDomainName = (USHORT)(lstrlenW(DomainName) * sizeof(WCHAR)) ;
    cbPassword = (USHORT)(lstrlenW(Password) * sizeof(WCHAR)) ;


    cbVerifyRequest = sizeof(VerifyRequest) +
                        cbUserName +
                        cbDomainName +
                        cbPassword ;

    pVerifyRequest = &VerifyRequest;
    ZeroMemory( &VerifyRequest, sizeof(VerifyRequest) );


    pVerifyRequest->MessageType = KerbVerifyCredentialsMessage ;

    //
    // do the length, buffers, copy,  marshall dance.
    //

    pVerifyRequest->UserName.Length = cbUserName;
    pVerifyRequest->UserName.MaximumLength = cbUserName;
    pVerifyRequest->UserName.Buffer = UserName;

    pVerifyRequest->DomainName.Length = cbDomainName;
    pVerifyRequest->DomainName.MaximumLength = cbDomainName;
    pVerifyRequest->DomainName.Buffer = DomainName;

    pVerifyRequest->Password.Length = cbPassword;
    pVerifyRequest->Password.MaximumLength = cbPassword;
    pVerifyRequest->Password.Buffer = Password;

    pVerifyRequest->VerifyFlags = 0;

    Status = LsaICallPackage(
                &AuthenticationPackage,
                pVerifyRequest,
                cbVerifyRequest,
                &pResponse,
                &cbResponse,
                &ProtocolStatus
                );

    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = ProtocolStatus;

Cleanup:

    return Status;
}


DWORD
s_SSRecoverImportRecoveryKey(
    handle_t h,
    BYTE* pbUsername,
    DWORD cbUsername,
    BYTE* pbCurrentPassword,
    DWORD cbCurrentPassword,
    BYTE* pbRecoveryPublic,
    DWORD cbRecoveryPublic)
                           
{
    DWORD dwError = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertContext = NULL;
    HANDLE hUserToken = NULL;
    HCERTSTORE hStore = NULL;
    WCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cchMachineName;
    LPWSTR pszUsername = (LPWSTR)pbUsername;
    LPWSTR pszCurrentPassword = (LPWSTR)pbCurrentPassword;
    UNICODE_STRING Domain;
    UNICODE_STRING Username;
    UNICODE_STRING Password;

    D_DebugLog((DEB_TRACE_API, "s_SSRecoverImportRecoveryKey\n"));

    //
    // Validate input parameters.
    //

    if(pbUsername == NULL || cbUsername < sizeof(WCHAR) ||
       pbCurrentPassword == NULL || cbCurrentPassword < sizeof(WCHAR) ||
       pbRecoveryPublic == NULL || cbRecoveryPublic == 0)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

    // Make sure strings are zero terminated.
    if((pszUsername[(cbUsername - 1) / sizeof(WCHAR)] != L'\0') ||
       (pszCurrentPassword[(cbCurrentPassword - 1) / sizeof(WCHAR)] != L'\0'))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }


    // 
    // Verify the supplied password. 
    // This ensures that we're being called by the actual user, and
    // that we're not being spoofed into creating a non-authorized
    // recovery certificate. 
    //

    cchMachineName = MAX_COMPUTERNAME_LENGTH + 1;

    if(!GetComputerName(szMachineName, &cchMachineName))
    {
        dwError = GetLastError();
        goto error;
    }

    dwError = VerifyCredentials(pszUsername,
                                szMachineName,
                                pszCurrentPassword);

    if(!NT_SUCCESS(dwError))
    {
        D_DebugLog((DEB_ERROR, "s_SSRecoverImportRecoveryKey: password did not verify (0x%x)\n", dwError));
        goto error;
    }

    
    //
    // Create a token for the user. This will be used when signing the
    // recovery file. It almost makes sense to call LogonUser in order to do
    // this (since we have the password and everything), but that function 
    // fails on Whistler when the user has a blank password.
    //

    RtlInitUnicodeString(&Domain, szMachineName);
    RtlInitUnicodeString(&Username, pszUsername);
    RtlInitUnicodeString(&Password, pszCurrentPassword);

    dwError = PRCreateLocalToken(&Username, &Domain, &hUserToken);

    if(!NT_SUCCESS(dwError))
    {
        D_DebugLog((DEB_ERROR, "s_SSRecoverImportRecoveryKey: could not create local token (0x%x)\n", dwError));
        goto error;
    }


    //
    // Add the recovery certificate to the recovery store.
    //
  
    pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                 pbRecoveryPublic,
                                                 cbRecoveryPublic);
    if(NULL == pCertContext)
    {
        dwError = GetLastError();
        goto error;
    }



    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                  X509_ASN_ENCODING,
                  NULL,
                  CERT_SYSTEM_STORE_LOCAL_MACHINE,
                  RECOVERY_STORE_NAME);

    if(NULL == hStore)
    {
        dwError = GetLastError();
        goto error;
    }

    if(!CertAddCertificateContextToStore(hStore, 
                                     pCertContext,
                                     CERT_STORE_ADD_REPLACE_EXISTING,
                                     NULL))
    {
        dwError = GetLastError();
        goto error;
    }


    dwError = EncryptRecoveryPassword(hUserToken,
                                      pCertContext,
                                      &Password);

    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }

error:

    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(hUserToken)
    {
        CloseHandle(hUserToken);
    }

    D_DebugLog((DEB_TRACE_API, "s_SSRecoverImportRecoveryKey returned 0x%x\n", dwError));

    return dwError;
}


NTSTATUS
PRCreateLocalToken(
    PUNICODE_STRING Username,
    PUNICODE_STRING Domain,
    HANDLE *Token)
{
    NTSTATUS Status;
    NTSTATUS SubStatus;
    LUID LogonId;
    PUCHAR AuthData;
    DWORD AuthDataLen;
    SECURITY_STRING PacUserName;


    //
    // Obtain a PAC for the user.
    //

    Status = g_pSecpkgTable->GetAuthDataForUser( 
                                    Username,
                                    SecNameSamCompatible,
                                    NULL,
                                    &AuthData,
                                    &AuthDataLen,
                                    NULL );
    if (!NT_SUCCESS(Status))
    {
        goto cleanup;
    }


    //
    // Convert the PAC into a user token.
    //

    PacUserName.Buffer = NULL;

    Status = g_pSecpkgTable->ConvertAuthDataToToken(
                                    AuthData,
                                    AuthDataLen,
                                    SecurityImpersonation,
                                    &DPAPITokenSource,
                                    Network,
                                    Domain,
                                    Token,
                                    &LogonId,
                                    &PacUserName,
                                    &SubStatus );

cleanup:

    return Status;
}

//+---------------------------------------------------------------------------
//
//  Function:   PRGetProfilePath
//
//  Synopsis:   Returns the path for user's application data.
//
//
//  Arguments:  [hUserToken] -- An access token representing a particular 
//                              user. The token must have TOKEN_IMPERSONATE 
//                              and TOKEN_QUERY priviledge. 
//
//              [pUsername]  -- Name of the user. If an explicit access token
//                              is specified, this parameter is used to
//                              load the user's profile.
//
//              [pszPath]    -- Pointer to a buffer of length MAX_PATH to 
//                              receive the path. If error occurs then the 
//                              string will be empty.
//
//----------------------------------------------------------------------------
DWORD               
PRGetProfilePath(
    IN HANDLE hUserToken OPTIONAL,
    IN PUNICODE_STRING pUsername OPTIONAL,
    OUT PWSTR pszPath)
{
    DWORD Status;
    HANDLE hToken = NULL;
    HANDLE hOldUser = NULL;
    HANDLE hLocalToken = NULL;
    PROFILEINFOW ProfileInfo;
    BOOL fProfileLoaded = FALSE;
    LPWSTR pszUsername = NULL;

    //
    // Default to empty string.
    //

    *pszPath = L'\0';


    //
    // If a user token is explicitly specified, then load the user profile.
    // Otherwise, use the current thread token.
    //

    if(hUserToken && pUsername)
    {
        pszUsername = (LPWSTR)LocalAlloc(LPTR, pUsername->Length + sizeof(WCHAR));
        if(pszUsername == NULL)
        {
            return STATUS_NO_MEMORY;
        }
        memcpy(pszUsername, pUsername->Buffer, pUsername->Length);


        hToken = hUserToken;

        if(!OpenThreadToken(GetCurrentThread(), 
                        TOKEN_IMPERSONATE | TOKEN_READ,
                        TRUE, 
                        &hOldUser)) 
        {
            hOldUser = NULL;
        }
        RevertToSelf();

        memset(&ProfileInfo, 0, sizeof(ProfileInfo));
        ProfileInfo.dwSize = sizeof(ProfileInfo);
        ProfileInfo.dwFlags = PI_NOUI;
        ProfileInfo.lpUserName = pszUsername;

        if(!LoadUserProfileW(hToken, &ProfileInfo))
        {
            Status = GetLastError();
            goto cleanup;
        }
        fProfileLoaded = TRUE;
    }
    else
    {
        if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hLocalToken))
        {
            Status = GetLastError();
            goto cleanup;
        }

        hToken = hLocalToken;
    }


    //
    // Get path to user's profile data. This will typically look something
    // like "c:\Documents and Settings\<user>\Application Data".
    //

    Status = GetUserAppDataPath(hToken, pszPath);

    if(Status != ERROR_SUCCESS)
    {
        D_DebugLog((DEB_ERROR, "GetUserAppDataPath returned: %d\n", Status));
        goto cleanup;
    }

    D_DebugLog((DEB_TRACE, "Profile path:%ls\n", pszPath));


cleanup:

    if(hToken && fProfileLoaded)
    {
        UnloadUserProfile(hToken, ProfileInfo.hProfile);
    }

    if(hOldUser)
    {
        SetThreadToken(NULL, hOldUser);
        CloseHandle(hOldUser);
    }

    if(hLocalToken)
    {
        CloseHandle(hLocalToken);
    }

    if(pszUsername)
    {
        LocalFree(pszUsername);
    }

    return Status;
}


DWORD 
RecoverySetSupplementalCredential(
    IN PSID pUserSid,
    IN PRECOVERY_SUPPLEMENTAL_CREDENTIAL pSupplementalCred, 
    IN DWORD cbSupplementalCred)
{
    WCHAR szPath[MAX_PATH + 1];
    LPWSTR pszTextualSid;
    DWORD cchTextualSid;
    HKEY hRecovery = NULL;
    DWORD Disp;
    DWORD dwError;
    HANDLE hOldUser = NULL;

    D_DebugLog((DEB_TRACE_API, "RecoverySetSupplementalCredential\n"));

    //
    // Build path to recovery data.
    //

    wcscpy(szPath, RECOVERY_KEY_BASE);

    pszTextualSid = szPath + wcslen(szPath);
    cchTextualSid = (sizeof(szPath) / sizeof(WCHAR)) - wcslen(szPath);

    if(!GetTextualSid(pUserSid, pszTextualSid, &cchTextualSid))
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }


    //
    // Write data to registry as local system.
    //

    if(!OpenThreadToken(GetCurrentThread(), 
                    TOKEN_IMPERSONATE | TOKEN_READ,
                    TRUE, 
                    &hOldUser)) 
    {
        hOldUser = NULL;
    }
    RevertToSelf();


    //
    // Write recovery data to the registry.
    //

    dwError = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             szPath,
                             0,
                             TEXT(""),
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE,
                             NULL,
                             &hRecovery,
                             &Disp);

    if(dwError != ERROR_SUCCESS)
    {
        goto error;
    }

    dwError = RegSetValueEx(hRecovery,
                            RECOVERY_FILENAME,
                            NULL,
                            REG_BINARY,
                            (PBYTE)pSupplementalCred,
                            cbSupplementalCred);

    if(dwError != ERROR_SUCCESS)
    {
        goto error;
    }

   
    dwError = ERROR_SUCCESS;


error:

    if(hRecovery)
    {
        RegCloseKey(hRecovery);
    }

    if(hOldUser)
    {
        SetThreadToken(NULL, hOldUser);
        CloseHandle(hOldUser);
    }

    D_DebugLog((DEB_TRACE_API, "RecoverySetSupplementalCredential returned 0x%x\n", dwError));

    return dwError;
}


DWORD 
RecoveryRetrieveSupplementalCredential(
    IN  PSID pUserSid,
    OUT PRECOVERY_SUPPLEMENTAL_CREDENTIAL *ppSupplementalCred, 
    OUT DWORD *pcbSupplementalCred)
{
    WCHAR szPath[MAX_PATH + 1];
    LPWSTR pszTextualSid;
    DWORD cchTextualSid;
    HKEY hRecovery = NULL;
    DWORD Type;
    PBYTE pbData = NULL;
    DWORD cbData;
    DWORD dwError;
    HANDLE hOldUser = NULL;

    D_DebugLog((DEB_TRACE_API, "RecoveryRetrieveSupplementalCredential\n"));


    //
    // Build path to recovery data.
    //

    wcscpy(szPath, RECOVERY_KEY_BASE);

    pszTextualSid = szPath + wcslen(szPath);
    cchTextualSid = (sizeof(szPath) / sizeof(WCHAR)) - wcslen(szPath);

    if(!GetTextualSid(pUserSid, pszTextualSid, &cchTextualSid))
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }


    //
    // Read data from registry as local system.
    //

    if(!OpenThreadToken(GetCurrentThread(), 
                    TOKEN_IMPERSONATE | TOKEN_READ,
                    TRUE, 
                    &hOldUser)) 
    {
        hOldUser = NULL;
    }
    RevertToSelf();


    //
    // Read recovery data blob out of the registry.
    //

    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           szPath,
                           0,
                           KEY_READ,
                           &hRecovery);

    if(dwError != ERROR_SUCCESS)
    {
        goto error;
    }


    dwError = RegQueryValueEx(hRecovery,
                              RECOVERY_FILENAME,
                              NULL,
                              &Type,
                              NULL,
                              &cbData);

    if(dwError != ERROR_SUCCESS)
    {
        if(dwError != ERROR_MORE_DATA)
        {
            goto error;
        }
    }

    pbData = (PBYTE)LocalAlloc(LPTR, cbData);
    if(pbData == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    dwError = RegQueryValueEx(hRecovery,
                              RECOVERY_FILENAME,
                              NULL,
                              &Type,
                              pbData,
                              &cbData);

    if(dwError != ERROR_SUCCESS)
    {
        if(dwError != ERROR_MORE_DATA)
        {
            goto error;
        }
    }

    if(Type != REG_BINARY)
    {
        dwError = ERROR_INVALID_DATA;
        goto error;
    }


    //
    // Set output parameters.
    //

    *ppSupplementalCred = (PRECOVERY_SUPPLEMENTAL_CREDENTIAL)pbData;
    *pcbSupplementalCred = cbData;

    pbData = NULL;
    
    dwError = ERROR_SUCCESS;


error:

    if(hRecovery)
    {
        RegCloseKey(hRecovery);
    }

    if(hOldUser)
    {
        SetThreadToken(NULL, hOldUser);
        CloseHandle(hOldUser);
    }

    if(pbData)
    {
        LocalFree(pbData);
    }

    D_DebugLog((DEB_TRACE_API, "RecoveryRetrieveSupplementalCredential returned 0x%x\n", dwError));

    return dwError;
}



DWORD 
s_SSRecoverPassword(
    handle_t h,
    PBYTE pbUsername,
    DWORD cbUsername,
    PBYTE pbRecoveryPrivate,
    DWORD cbRecoveryPrivate,
    PBYTE pbNewPassword,
    DWORD cbNewPassword)
{
    DWORD dwError = ERROR_SUCCESS;
    PWSTR pszUsername = (PWSTR)pbUsername;
    PWSTR pszNewPassword = (PWSTR)pbNewPassword;
    PWSTR pszOldPassword = NULL;
    CRYPT_SERVER_CONTEXT ServerContext;
    PSID pSid = NULL;
    DWORD cbSid;
    WCHAR szDomain[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cchDomain;
    SID_NAME_USE AcctType;


    D_DebugLog((DEB_TRACE_API, "s_SSRecoverPassword\n"));

    dwError = CPSCreateServerContext(&ServerContext, h);
    if(dwError != ERROR_SUCCESS)
    {
        return dwError;
    }

    //
    // Validate input parameters.
    //

    if(pbUsername == NULL || cbUsername < sizeof(WCHAR) ||
       pbRecoveryPrivate == NULL || cbRecoveryPrivate == 0 ||
       pbNewPassword == NULL || cbNewPassword < sizeof(WCHAR))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

    // Make sure strings are zero terminated.
    if((pszUsername[(cbUsername - 1) / sizeof(WCHAR)] != L'\0') ||
       (pszNewPassword[(cbNewPassword - 1) / sizeof(WCHAR)] != L'\0'))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

    // Check for zero length username.
    if(wcslen(pszUsername) == 0)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

    //
    // Lookup the user SID.
    //

    cchDomain = MAX_COMPUTERNAME_LENGTH + 1;
    if(!GetComputerNameW(szDomain, &cchDomain))
    {
        dwError = GetLastError();
        goto error;
    }

    if(!LookupAccountNameW(szDomain,
                           pszUsername,
                           NULL,
                           &cbSid,
                           NULL,
                           &cchDomain,
                           &AcctType)) 
    {
        dwError = GetLastError();

        if(dwError != ERROR_INSUFFICIENT_BUFFER)
        {
            goto error;
        }
    }

    pSid = (PBYTE)LocalAlloc(LPTR, cbSid);
    if(pSid == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    if(cchDomain > MAX_COMPUTERNAME_LENGTH + 1)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    if(!LookupAccountNameW(szDomain,
                           pszUsername,
                           pSid,
                           &cbSid,
                           szDomain,
                           &cchDomain,
                           &AcctType)) 
    {
        dwError = GetLastError();
        goto error;
    }



    //
    // Import the recovery private
    //
    // The private comes in the form of a version DWORD, followed by a certificate, 
    // followed directly by a pvk import blob, so skip past the certificate
    //
   
    if((cbRecoveryPrivate < 2*sizeof(DWORD)) ||
        ( *((DWORD *)pbRecoveryPrivate) != RECOVERY_BLOB_MAGIC) ||
        ( *((DWORD *)(pbRecoveryPrivate + sizeof(DWORD))) != RECOVERY_BLOB_VERSION))
    {
        dwError = ERROR_INVALID_DATA;
        goto error;
    }

    //
    // Decrypt the recovery file in order to obtain the user's
    // old password. Shazam!
    //

    dwError = DecryptRecoveryPassword(pSid,
                                      pbRecoveryPrivate,
                                      cbRecoveryPrivate,
                                      &pszOldPassword);

    if(dwError != ERROR_SUCCESS)
    {
        CPSImpersonateClient(&ServerContext);
        goto error;
    }


    //
    // Set the user's password to the new value.
    //

    dwError = ResetLocalUserPassword(szDomain,
                                     pszUsername,
                                     pszOldPassword,
                                     pszNewPassword);
    if(dwError != STATUS_SUCCESS)
    {
        D_DebugLog((DEB_ERROR, "Error changing user's password (0x%x)\n", dwError));
        goto error;
    }


error:

    if(pSid)
    {
        LocalFree(pSid);
    }

    if(pszOldPassword)
    {
        memset(pszOldPassword, 0, wcslen(pszOldPassword) * sizeof(WCHAR));
        LocalFree(pszOldPassword);
        pszOldPassword = NULL;
    }

    if(pbNewPassword && cbNewPassword)
    {
        memset(pbNewPassword, 0, cbNewPassword);
    }

    CPSDeleteServerContext(&ServerContext);

    D_DebugLog((DEB_TRACE_API, "s_SSRecoverPassword returned 0x%x\n", dwError));

    return dwError;
}


DWORD
DecryptRecoveryPassword(
    IN PSID pUserSid,
    IN PBYTE pbRecoveryPrivate,
    IN DWORD cbRecoveryPrivate,
    OUT LPWSTR *ppszPassword)
{
    PRECOVERY_SUPPLEMENTAL_CREDENTIAL pCred = NULL;
    DWORD cbCred = 0;
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hkRecoveryPrivate = 0;
    PBYTE pbPasswordBuffer = NULL;
    DWORD cbPasswordBuffer = 0;
    DWORD dwError;

    D_DebugLog((DEB_TRACE, "DecryptRecoveryPassword\n"));


    //
    // Read the recovery data.
    //

    dwError = RecoveryRetrieveSupplementalCredential(pUserSid,
                                                     &pCred, 
                                                     &cbCred);
    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }

    if((NULL == pCred) ||
       (sizeof(RECOVERY_SUPPLEMENTAL_CREDENTIAL) > cbCred) ||
       ( sizeof(RECOVERY_SUPPLEMENTAL_CREDENTIAL) + 
         pCred->cbRecoveryCertHashSize + 
         pCred->cbRecoveryCertSignatureSize + 
         pCred->cbEncryptedPassword > cbCred) ||
         (pCred->dwVersion != RECOVERY_SUPPLEMENTAL_CREDENTIAL_VERSION))
    {
        dwError =  ERROR_INVALID_DATA;
        goto error;
    }



    //
    // Import the recovery private key into CryptoAPI.
    //

    if(!CryptAcquireContext(&hProv, NULL, MS_STRONG_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        dwError = GetLastError();
        goto error;
    }


    if(!CryptImportKey(hProv, 
                       pbRecoveryPrivate + 2*sizeof(DWORD), 
                       cbRecoveryPrivate - 2*sizeof(DWORD),
                       0, 
                       0, 
                       &hkRecoveryPrivate))
    {
        dwError = GetLastError();
        goto error;
    }

    cbPasswordBuffer = cbCred - (sizeof(RECOVERY_SUPPLEMENTAL_CREDENTIAL) + 
                                 pCred->cbRecoveryCertHashSize + 
                                 pCred->cbRecoveryCertSignatureSize);

    pbPasswordBuffer = (PBYTE)LocalAlloc(LPTR, cbPasswordBuffer);

    if(NULL == pbPasswordBuffer)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    CopyMemory(pbPasswordBuffer,  
               (PBYTE)(pCred + 1) + 
               pCred->cbRecoveryCertHashSize + 
               pCred->cbRecoveryCertSignatureSize,
               cbPasswordBuffer);


    //
    // OAEP padding includes random data, as well as a
    // verification mechanism, so we don't need to worry about
    // salting the password.
    //

    if(!CryptDecrypt(hkRecoveryPrivate,
                 0,
                 TRUE,
                 0, //CRYPT_OAEP,
                 pbPasswordBuffer,
                 &cbPasswordBuffer))
    {
        dwError = GetLastError();
        D_DebugLog((DEB_ERROR, "Error 0x%x decrypting user's password\n", dwError));
        goto error;
    }

    //
    // Zero terminate the password.
    //

    *((LPWSTR)pbPasswordBuffer + cbPasswordBuffer/sizeof(WCHAR)) = L'\0';

    *ppszPassword = (LPWSTR)pbPasswordBuffer;
    pbPasswordBuffer = NULL;

    dwError = ERROR_SUCCESS;

error:

    if(pbPasswordBuffer)
    {
        LocalFree(pbPasswordBuffer);
    }

    if(pCred)
    {
        ZeroMemory((PBYTE)pCred, cbCred);
        LocalFree(pCred);
    }

    if(hkRecoveryPrivate)
    {
        CryptDestroyKey(hkRecoveryPrivate);
    }

    if(hProv)
    {
        CryptReleaseContext(hProv, 0);
    }

    D_DebugLog((DEB_TRACE, "DecryptRecoveryPassword returned 0x%x\n", dwError));

    return dwError;
}


DWORD
ResetLocalUserPassword(
    LPWSTR pszDomain,
    LPWSTR pszUsername,
    LPWSTR pszOldPassword,
    LPWSTR pszNewPassword)
{
    UNICODE_STRING Domain;
    UNICODE_STRING Username;
    UNICODE_STRING OldPassword;
    UNICODE_STRING NewPassword;
    NTSTATUS Status;
    HANDLE hToken = NULL;

    D_DebugLog((DEB_TRACE, "ResetLocalUserPassword\n"));


    //
    // Cruft up a local token for the user.
    //

    RtlInitUnicodeString(&Domain, pszDomain);
    RtlInitUnicodeString(&Username, pszUsername);
    RtlInitUnicodeString(&OldPassword, pszOldPassword);
    RtlInitUnicodeString(&NewPassword, pszNewPassword);

    Status = PRCreateLocalToken(&Username, &Domain, &hToken);

    if(!NT_SUCCESS(Status))
    {
        goto cleanup;
    }


    // 
    // Set the password on the user account to the new value.
    //

    Status = SamIChangePasswordForeignUser2(NULL,
                                            &Username,
                                            &NewPassword,
                                            hToken,
                                            USER_CHANGE_PASSWORD);

    if(!NT_SUCCESS(Status))
    {
        goto cleanup;
    }


    //
    // Notify DPAPI of the password change. This will cause the CREDHIST
    // and RECOVERY files to be updated, and the master key files to be
    // re-encrypted with the new password.
    //

    LsaINotifyPasswordChanged(&Domain,
                              &Username,
                              NULL,
                              NULL,
                              &OldPassword,
                              &NewPassword,
                              TRUE);

cleanup:

    if(hToken)
    {
        CloseHandle(hToken);
    }

    D_DebugLog((DEB_TRACE, "ResetLocalUserPassword returned 0x%x\n", Status));

    return Status;
}

NTSTATUS 
CreateSystemDirectory(
    LPCWSTR lpPathName)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;

    if(!RtlDosPathNameToNtPathName_U( lpPathName,
                                      &FileName,
                                      NULL,
                                      &RelativeName))
    {
        return STATUS_OBJECT_PATH_NOT_FOUND;
    }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) 
    {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
    }
    else 
    {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes( &Obja,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                RelativeName.ContainingDirectory,
                                NULL );

    // Creating the directory with attribute FILE_ATTRIBUTE_SYSTEM to avoid inheriting encryption 
    // property from parent directory

    Status = NtCreateFile( &Handle,
                           FILE_LIST_DIRECTORY | SYNCHRONIZE,
                           &Obja,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_SYSTEM,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_CREATE,
                           FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                           NULL,
                           0L );

    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    if(NT_SUCCESS(Status))
    {
        NtClose(Handle);
        return STATUS_SUCCESS;
    }
    else 
    {
        return Status;
    }
}


/*++

    Create all subdirectories if they do not exists starting at
    szCreationStartPoint.

    szCreationStartPoint must point to a character within the null terminated
    buffer specified by the szFullPath parameter.

    Note that szCreationStartPoint should not point at the first character
    of a drive root, eg:

    d:\foo\bar\bilge\water
    \\server\share\foo\bar
    \\?\d:\big\path\bilge\water

    Instead, szCreationStartPoint should point beyond these components, eg:

    bar\bilge\water
    foo\bar
    big\path\bilge\water

    This function does not implement logic for adjusting to compensate for these
    inputs because the environment it was design to be used in causes the input
    szCreationStartPoint to point well into the szFullPath input buffer.


--*/
DWORD
DPAPICreateNestedDirectories(
    IN      LPWSTR szFullPath,
    IN      LPWSTR szCreationStartPoint // must point in null-terminated range of szFullPath
    )
{
    DWORD i;
    DWORD cchRemaining;
    DWORD dwLastError = STATUS_SUCCESS;

    BOOL fSuccess = FALSE;


    if( szCreationStartPoint < szFullPath ||
        szCreationStartPoint  > (lstrlenW(szFullPath) + szFullPath)
        )
    {
        return STATUS_INVALID_PARAMETER;
    }

    cchRemaining = lstrlenW( szCreationStartPoint );

    //
    // scan from left to right in the szCreationStartPoint string
    // looking for directory delimiter.
    //

    for ( i = 0 ; i < cchRemaining ; i++ ) 
    {
        WCHAR charReplaced = szCreationStartPoint[ i ];

        if( charReplaced == L'\\' || charReplaced == L'/' ) 
        {

            szCreationStartPoint[ i ] = L'\0';

            dwLastError = CreateSystemDirectory(szFullPath);

            szCreationStartPoint[ i ] = charReplaced;

            if(dwLastError == STATUS_OBJECT_NAME_COLLISION)
            {
                dwLastError = STATUS_SUCCESS;
            }

            //
            // Continue onwards regardless of errors, trying to create the
            // specified subdirectories. This is done to address the obscure 
            // scenario where the Bypass Traverse Checking Privilege allows 
            // the caller to create directories below an existing path where 
            // one component denies the user access. We just keep trying 
            // and the last CreateSystemDirectory() result is returned to 
            // the caller.
            //
        }
    }

    return dwLastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\session.cpp ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    session.c

Abstract:

    This module contains routines to support communication with the LSA
    (Local Security Authority) to permit querying of active sessions.

    This module also supports calling into the LSA to retrieve a credential
    derived from a logged on user specified by Logon Identifier.

Author:

    Scott Field (sfield)    02-Mar-97

    Pete Skelly (petesk)    09-May-00 - added credential history and signature code

--*/


#include <pch.cpp>
#pragma hdrstop
#include <ntmsv1_0.h>
#include <crypt.h>
#include "debug.h"
#include "passrec.h"

#define HMAC_K_PADSIZE      (64)

#define CREDENTIAL_HISTORY_VERSION 1

#define CREDENTIAL_HISTORY_SALT_SIZE  16    // 128 bits

#define DEFAULT_KEY_GEN_ALG  CALG_HMAC
#define DEFAULT_ENCRYPTION_ALG CALG_3DES


typedef struct _CREDENTIAL_HISTORY_HEADER
{
    DWORD dwVersion;
    GUID  CredentialID;
    DWORD dwPreviousCredOffset;
} CREDENTIAL_HISTORY_HEADER, *PCREDENTIAL_HISTORY_HEADER;

typedef struct _CREDENTIAL_HISTORY
{
    CREDENTIAL_HISTORY_HEADER Header;
    DWORD dwFlags;
    DWORD KeyGenAlg;
    DWORD cIterationCount;                  // pbkdf2 iteration count
    DWORD cbSid;                            // sid is used as mixing bytes
    DWORD KeyEncrAlg;
    DWORD cbShaOwf;
    DWORD cbNtOwf;
    BYTE  Salt[CREDENTIAL_HISTORY_SALT_SIZE];
} CREDENTIAL_HISTORY, *PCREDENTIAL_HISTORY;


typedef struct _CREDENTIAL_HISTORY_MAP
{
    PSID    pUserSid;
    WCHAR   wszFilePath[MAX_PATH+1];
    HANDLE  hHistoryFile;
    HANDLE  hMapping;
    DWORD   dwMapSize;
    PBYTE   pMapping;
    struct _CREDENTIAL_HISTORY_MAP *pNext;

} CREDENTIAL_HISTORY_MAP, *PCREDENTIAL_HISTORY_MAP;


RTL_CRITICAL_SECTION g_csCredHistoryCache;


DWORD
OpenCredentialHistoryMap(
    HANDLE hUserToken,
    LPWSTR pszProfilePath,
    PCREDENTIAL_HISTORY_MAP *ppMap,
    PCREDENTIAL_HISTORY *ppCurrent);

PCREDENTIAL_HISTORY
GetPreviousCredentialHistory(
                             PCREDENTIAL_HISTORY_MAP pMap,
                             PCREDENTIAL_HISTORY pCurrent
                             );

DWORD
CloseCredentialHistoryMap(PCREDENTIAL_HISTORY_MAP pMap,
                          BOOL fReader);

DWORD
DestroyCredentialHistoryMap(PCREDENTIAL_HISTORY_MAP pMap);

VOID
DeriveWithHMAC_SHA1(
    IN      PBYTE   pbKeyMaterial,              // input key material
    IN      DWORD   cbKeyMaterial,
    IN      PBYTE   pbData,                     // input mixing data
    IN      DWORD   cbData,
    IN OUT  BYTE    rgbHMAC[A_SHA_DIGEST_LEN]   // output buffer
    );

DWORD
DecryptCredentialHistory(PCREDENTIAL_HISTORY pCredential,
                         BYTE rgbDecryptingCredential[A_SHA_DIGEST_LEN],
                         BYTE rgbShaOwf[A_SHA_DIGEST_LEN],
                         BYTE rgbNTOwf[A_SHA_DIGEST_LEN]);




DWORD
RetrieveCurrentDerivedCredential(
    IN      LUID *pLogonId,
    IN      BOOL fDPOWF,
    IN      PBYTE pbMixingBytes,
    IN      DWORD cbMixingBytes,
    IN OUT  BYTE rgbDerivedCredential[A_SHA_DIGEST_LEN]
    )
{
    NTSTATUS ntstatus;
    NTSTATUS AuthPackageStatus;

    PMSV1_0_DERIVECRED_REQUEST pDeriveCredentialRequest;
    DWORD cbDeriveCredentialRequest;
    PMSV1_0_DERIVECRED_RESPONSE pDeriveCredentialResponse;
    ULONG DeriveCredentialResponseLength;
    UNICODE_STRING PackageName;
    HANDLE hToken = NULL;





    RtlInitUnicodeString(&PackageName, L"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0");


    //
    // must specify mixing bytes.
    //

    if( cbMixingBytes == 0 || pbMixingBytes == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Ask authentication package to provide derived credential associated
    // with the specified logon identifier.
    // note: submit buffer must be a single contiguous block.
    //

    cbDeriveCredentialRequest = sizeof(MSV1_0_DERIVECRED_REQUEST) + cbMixingBytes;
    pDeriveCredentialRequest = (MSV1_0_DERIVECRED_REQUEST *)SSAlloc( cbDeriveCredentialRequest );
    if( pDeriveCredentialRequest == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    pDeriveCredentialRequest->MessageType = MsV1_0DeriveCredential;
    CopyMemory( &(pDeriveCredentialRequest->LogonId), pLogonId, sizeof(LUID) );
    pDeriveCredentialRequest->DeriveCredType = fDPOWF?MSV1_0_DERIVECRED_TYPE_SHA1_V2:MSV1_0_DERIVECRED_TYPE_SHA1;
    pDeriveCredentialRequest->DeriveCredInfoLength = cbMixingBytes;

    CopyMemory(pDeriveCredentialRequest->DeriveCredSubmitBuffer, pbMixingBytes, cbMixingBytes);

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE, TRUE, &hToken))
    {
        return GetLastError();
    }


    RevertToSelf();

    // Make this call as local system

    ntstatus = LsaICallPackage(
                                &PackageName,
                                pDeriveCredentialRequest,
                                cbDeriveCredentialRequest,
                                (PVOID *)&pDeriveCredentialResponse,
                                &DeriveCredentialResponseLength,
                                &AuthPackageStatus
                                );

    SSFree( pDeriveCredentialRequest );

    SetThreadToken(NULL, hToken);
    CloseHandle(hToken);


    if(!NT_SUCCESS(ntstatus))
    {
        return ntstatus;
    }

    CopyMemory( rgbDerivedCredential,
                pDeriveCredentialResponse->DeriveCredReturnBuffer,
                pDeriveCredentialResponse->DeriveCredInfoLength
                );


    ZeroMemory( pDeriveCredentialResponse->DeriveCredReturnBuffer,
                pDeriveCredentialResponse->DeriveCredInfoLength
                );

    LsaIFreeReturnBuffer( pDeriveCredentialResponse );

    return ERROR_SUCCESS;
}


DWORD
QueryDerivedCredential(IN GUID * CredentialID,
                        IN      LUID *pLogonId,
                        IN      DWORD dwFlags,
                        IN      PBYTE pbMixingBytes,
                        IN      DWORD cbMixingBytes,
                        IN OUT  BYTE rgbDerivedCredential[A_SHA_DIGEST_LEN]
                        )
{

    DWORD dwLastError = ERROR_SUCCESS;
    PCREDENTIAL_HISTORY pCurrent = NULL;
    PCREDENTIAL_HISTORY pNext = NULL;
    BYTE rgbCurrentDerivedCredential[A_SHA_DIGEST_LEN];
    BYTE rgbCurrentShaOWF[A_SHA_DIGEST_LEN];
    BYTE rgbCurrentNTOWF[A_SHA_DIGEST_LEN];

    PCREDENTIAL_HISTORY_MAP pHistoryMap= NULL;
    WCHAR wszTextualSid[MAX_PATH + 1];
    WCHAR szProfilePath[MAX_PATH + 1];
    DWORD cchTextualSid = 0;
    BOOL fIsRoot = TRUE;

    //
    // Get path to user's profile data. This will typically look something
    // like "c:\Documents and Settings\<user>\Application Data".
    //

    dwLastError = PRGetProfilePath(NULL,
                                   NULL,
                                   szProfilePath);

    if( dwLastError != ERROR_SUCCESS )
    {
        D_DebugLog((DEB_TRACE_API, "DPAPIChangePassword returned 0x%x\n", dwLastError));
        return dwLastError;
    }


    //
    // work-around the fact that much of this (new) code is not thread-safe.
    //

    RtlEnterCriticalSection(&g_csCredHistoryCache);

    //
    // Open history file
    //

    dwLastError = OpenCredentialHistoryMap(NULL, szProfilePath, &pHistoryMap, &pCurrent);


    while((ERROR_SUCCESS == dwLastError) &&
          (pCurrent) &&
          (0 == (dwFlags & USE_ROOT_CREDENTIAL)))
    {

        //
        // We're looking for a specific credential ID
        //
        if((NULL != CredentialID) &&
           (0 == memcmp(&pCurrent->Header.CredentialID, CredentialID, sizeof(GUID))))
        {
            // found it,
            break;
        }


        pNext = GetPreviousCredentialHistory(pHistoryMap, pCurrent);

        if(NULL == pNext)
        {
            if(NULL != CredentialID)
            {
                // If we're looking for a specific credential, but
                // couldn't find it, then return an error
                dwLastError = NTE_BAD_KEY;
            }
            else
            {
                // no credential id was specified, so default to the oldest one.
                dwLastError = ERROR_SUCCESS;
            }
            break;
        }


        //
        // get the textual sid
        //
        cchTextualSid = MAX_PATH;

        if(!GetTextualSid((PBYTE)(pNext + 1), wszTextualSid, &cchTextualSid))
        {
            dwLastError = ERROR_INVALID_PARAMETER;
            break;
        }




        if(fIsRoot)
        {
            //
            // crack the next credential using the current
            // credentials
            //
            dwLastError = RetrieveCurrentDerivedCredential(pLogonId,
                                            (0 != (pNext->dwFlags & USE_DPAPI_OWF)), // always use
                                            (PBYTE)wszTextualSid,
                                            cchTextualSid*sizeof(WCHAR),
                                            rgbCurrentDerivedCredential);

            fIsRoot = FALSE;
        }
        else
        {
            //
            // calculate the current derived credential used to decrypt the
            // next credential history structure by using the decrypted OWF
            // from the previous pass

            DeriveWithHMAC_SHA1((0 != (pNext->dwFlags & USE_DPAPI_OWF))?rgbCurrentShaOWF:rgbCurrentNTOWF,
                                A_SHA_DIGEST_LEN,
                                (PBYTE)wszTextualSid,
                                cchTextualSid*sizeof(WCHAR),
                                rgbCurrentDerivedCredential);

            //
            // we don't need the OWF anymore, so zap it.
            //
            ZeroMemory(rgbCurrentShaOWF, A_SHA_DIGEST_LEN);
            ZeroMemory(rgbCurrentNTOWF, A_SHA_DIGEST_LEN);
        }

        if(ERROR_SUCCESS != dwLastError)
        {
            break;
        }


        //
        // used the derived credential to decrypt
        // the data blob of pNext
        //

        dwLastError = DecryptCredentialHistory(pNext,
                                 rgbCurrentDerivedCredential,
                                 rgbCurrentShaOWF,
                                 rgbCurrentNTOWF);

        if(ERROR_SUCCESS != dwLastError)
        {
            break;
        }

        pCurrent = pNext;
        pNext = NULL;

    }

    if(ERROR_SUCCESS == dwLastError)
    {
        if(fIsRoot)
        {
            //
            // crack the next credential using the current
            // credentials
            //
            dwLastError = RetrieveCurrentDerivedCredential(pLogonId,
                                            (0 != (dwFlags & USE_DPAPI_OWF)),
                                            pbMixingBytes,
                                            cbMixingBytes,
                                            rgbDerivedCredential);

            if(ERROR_SUCCESS == dwLastError)
            {
                if((CredentialID != NULL) &&
                (0 != (dwFlags & USE_ROOT_CREDENTIAL)))
                {
                    CopyMemory(CredentialID, &pCurrent->Header.CredentialID, sizeof(GUID));
                }
            }


        }
        else
        {
            //
            // calculate the current derived credential used to decrypt the
            // next credential history structure by using the decrypted OWF
            // from the previous pass

            DeriveWithHMAC_SHA1((0 != (dwFlags & USE_DPAPI_OWF))?rgbCurrentShaOWF:rgbCurrentNTOWF,
                                A_SHA_DIGEST_LEN,
                                pbMixingBytes,
                                cbMixingBytes,
                                rgbDerivedCredential);
        }
    }


    //
    // Clear out any owf's we may have lying around
    //
    ZeroMemory(rgbCurrentShaOWF, A_SHA_DIGEST_LEN);
    ZeroMemory(rgbCurrentNTOWF, A_SHA_DIGEST_LEN);


    if(pHistoryMap)
    {
        CloseCredentialHistoryMap(pHistoryMap, TRUE);
    }

    RtlLeaveCriticalSection(&g_csCredHistoryCache);

    return dwLastError;

}


VOID
DeriveWithHMAC_SHA1(
    IN      PBYTE   pbKeyMaterial,              // input key material
    IN      DWORD   cbKeyMaterial,
    IN      PBYTE   pbData,                     // input mixing data
    IN      DWORD   cbData,
    IN OUT  BYTE    rgbHMAC[A_SHA_DIGEST_LEN]   // output buffer
    )
{
    unsigned __int64 rgbKipad[ HMAC_K_PADSIZE/sizeof(unsigned __int64) ];
    unsigned __int64 rgbKopad[ HMAC_K_PADSIZE/sizeof(unsigned __int64) ];
    A_SHA_CTX sSHAHash;
    DWORD dwBlock;

    // truncate
    if( cbKeyMaterial > HMAC_K_PADSIZE )
    {
        cbKeyMaterial = HMAC_K_PADSIZE;
    }

    ZeroMemory(rgbKipad, sizeof(rgbKipad));
    ZeroMemory(rgbKopad, sizeof(rgbKopad));

    CopyMemory(rgbKipad, pbKeyMaterial, cbKeyMaterial);
    CopyMemory(rgbKopad, pbKeyMaterial, cbKeyMaterial);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for( dwBlock = 0; dwBlock < (HMAC_K_PADSIZE/sizeof(unsigned __int64)) ; dwBlock++ )
    {
        rgbKipad[dwBlock] ^= 0x3636363636363636;
        rgbKopad[dwBlock] ^= 0x5C5C5C5C5C5C5C5C;
    }

    // prepend Kipad to data, Hash to get H1
    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (PBYTE)rgbKipad, sizeof(rgbKipad));
    A_SHAUpdate(&sSHAHash, pbData, cbData);


    // Finish off the hash
    A_SHAFinal(&sSHAHash, rgbHMAC);

    // prepend Kopad to H1, hash to get HMAC
    // note: done in place to avoid buffer copies

    // final hash: output value into passed-in buffer
    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (PBYTE)rgbKopad, sizeof(rgbKopad));
    A_SHAUpdate(&sSHAHash, rgbHMAC, A_SHA_DIGEST_LEN);
    A_SHAFinal(&sSHAHash, rgbHMAC);


    ZeroMemory( rgbKipad, sizeof(rgbKipad) );
    ZeroMemory( rgbKopad, sizeof(rgbKopad) );
    ZeroMemory( &sSHAHash, sizeof(sSHAHash) );

    return;
}


DWORD
DecryptCredentialHistory(PCREDENTIAL_HISTORY pCredential,
                         BYTE rgbDecryptingCredential[A_SHA_DIGEST_LEN],
                         BYTE rgbShaOwf[A_SHA_DIGEST_LEN],
                         BYTE rgbNTOwf[A_SHA_DIGEST_LEN])
{

    DWORD   dwLastError = ERROR_SUCCESS;
    DWORD j;
    BYTE rgbSymKey[A_SHA_DIGEST_LEN*2]; // big enough to handle 3des keys

    //
    // Derive the protection key
    //

    for(j=0; j < 2; j++)
    {
        if(!PKCS5DervivePBKDF2( rgbDecryptingCredential,
                            A_SHA_DIGEST_LEN,
                            pCredential->Salt,
                            CREDENTIAL_HISTORY_SALT_SIZE,
                            pCredential->KeyGenAlg,
                            pCredential->cIterationCount,
                            j+1,
                            rgbSymKey + j*A_SHA_DIGEST_LEN))
        {
            dwLastError = ERROR_INVALID_DATA;
            goto cleanup;
        }
    }
    if (CALG_3DES == pCredential->KeyEncrAlg)
    {

        DES3TABLE s3DESKey;
        DWORD iBlock;
        BYTE  ResultBlock[2*A_SHA_DIGEST_LEN+DES_BLOCKLEN ];

        //
        // Round up blocks.  it's assumed that the total block size was verified
        // earlier
        //
        DWORD cBlocks = (pCredential->cbShaOwf + pCredential->cbNtOwf + DES_BLOCKLEN - 1)/DES_BLOCKLEN;
        BYTE feedback[ DES_BLOCKLEN ];
        // initialize 3des key
        //
        if((pCredential->cbShaOwf != A_SHA_DIGEST_LEN) ||
           (pCredential->cbNtOwf != A_SHA_DIGEST_LEN))
        {
            return ERROR_INVALID_PARAMETER;
        }

        tripledes3key(&s3DESKey, rgbSymKey);

        //
        // IV is derived from the DES_BLOCKLEN bytes of the calculated
        // rgbSymKey, after the 3des key
        CopyMemory(feedback, rgbSymKey + DES3_KEYSIZE, DES_BLOCKLEN);

        for(iBlock=0; iBlock < cBlocks; iBlock++)
        {
            CBC(tripledes,
                DES_BLOCKLEN,
                ResultBlock+iBlock*DES_BLOCKLEN,
                ((PBYTE)(pCredential + 1) + pCredential->cbSid)+iBlock*DES_BLOCKLEN,
                &s3DESKey,
                DECRYPT,
                feedback);
        }
        CopyMemory(rgbShaOwf, ResultBlock, A_SHA_DIGEST_LEN);
        CopyMemory(rgbNTOwf, ResultBlock + A_SHA_DIGEST_LEN, A_SHA_DIGEST_LEN);
        ZeroMemory(ResultBlock, sizeof(ResultBlock));

    }
    else
    {
        dwLastError = ERROR_INVALID_DATA;
        goto cleanup;
    }

cleanup:
    return dwLastError;
}



DWORD
EncryptCredentialHistory(BYTE rgbEncryptingCredential[A_SHA_DIGEST_LEN],
                         DWORD dwFlags,
                         BYTE SHAOwfToEncrypt[A_SHA_DIGEST_LEN],
                         BYTE NTOwfToEncrypt[A_SHA_DIGEST_LEN],
                         PCREDENTIAL_HISTORY *ppCredential,
                         DWORD *pcbCredential)
{

    DWORD   dwLastError = ERROR_SUCCESS;
    DWORD j;
    BYTE rgbSymKey[A_SHA_DIGEST_LEN*2]; // big enough to handle 3des keys
    PCREDENTIAL_HISTORY pCred = NULL;
    DWORD               cbCred = 0;
    HANDLE hToken = NULL;
    PSID pSidUser = NULL;
    BYTE ResultBuffer[A_SHA_DIGEST_LEN * 2]; // 2 * A_SHA_DIGEST_LEN

    DWORD cBlocks = 0;
    DWORD cbBlock = 0;



    cbBlock = DES_BLOCKLEN;

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
    {
        dwLastError = GetLastError();
        goto error;
    }

    if(!GetTokenUserSid(hToken, &pSidUser))
    {
        dwLastError = GetLastError();
        goto error;
    }


    cBlocks = sizeof(ResultBuffer)/DES_BLOCKLEN;  // this should be 5


    cbCred= sizeof(CREDENTIAL_HISTORY) +
           GetLengthSid(pSidUser) +
           cBlocks*cbBlock;



    pCred = (PCREDENTIAL_HISTORY)LocalAlloc(LMEM_ZEROINIT, cbCred);

    if(NULL == pCred)
    {
        dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    pCred->dwFlags = dwFlags;



    pCred->KeyGenAlg = DEFAULT_KEY_GEN_ALG;
    pCred->cIterationCount = GetIterationCount();
    pCred->KeyEncrAlg = DEFAULT_ENCRYPTION_ALG;

    pCred->cbShaOwf = A_SHA_DIGEST_LEN;
    pCred->cbNtOwf = A_SHA_DIGEST_LEN;


    pCred->cbSid = GetLengthSid(pSidUser);

    CopyMemory((PBYTE)(pCred+1), (PBYTE)pSidUser, pCred->cbSid);

    RtlGenRandom(pCred->Salt, CREDENTIAL_HISTORY_SALT_SIZE);



    for(j=0; j < 2; j++)
    {
        if(!PKCS5DervivePBKDF2( rgbEncryptingCredential,
                            A_SHA_DIGEST_LEN,
                            pCred->Salt,
                            CREDENTIAL_HISTORY_SALT_SIZE,
                            pCred->KeyGenAlg,
                            pCred->cIterationCount,
                            j+1,
                            rgbSymKey + j*A_SHA_DIGEST_LEN))
        {
            dwLastError = ERROR_INVALID_DATA;
            goto error;
        }
    }
    if (CALG_3DES == pCred->KeyEncrAlg)
    {

        DES3TABLE s3DESKey;
        DWORD iBlock;



        //
        // Round up blocks.  it's assumed that the total block size was verified
        // earlier
        //
        BYTE feedback[ DES_BLOCKLEN ];
        // initialize 3des key
        //

        tripledes3key(&s3DESKey, rgbSymKey);

        //
        // IV is derived from the DES_BLOCKLEN bytes of the calculated
        // rgbSymKey, after the 3des key
        CopyMemory(feedback, rgbSymKey + DES3_KEYSIZE, DES_BLOCKLEN);



        CopyMemory(ResultBuffer, SHAOwfToEncrypt, A_SHA_DIGEST_LEN);
        CopyMemory(ResultBuffer+A_SHA_DIGEST_LEN, NTOwfToEncrypt, A_SHA_DIGEST_LEN);

        for(iBlock=0; iBlock < cBlocks; iBlock++)
        {

            CBC(tripledes,
                DES_BLOCKLEN,
                ((PBYTE)(pCred + 1) + pCred->cbSid)+iBlock*DES_BLOCKLEN,
                ResultBuffer + iBlock*DES_BLOCKLEN,
                &s3DESKey,
                ENCRYPT,
                feedback);
        }


        ZeroMemory(ResultBuffer, sizeof(ResultBuffer));
    }
    else
    {
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }

    *ppCredential = pCred;
    *pcbCredential = cbCred;

    pCred = NULL;
error:

    if(pCred)
    {
        LocalFree(pCred);
    }

    if(hToken)
    {
        CloseHandle(hToken);
    }
    return dwLastError;
}


#define PRODUCT_ROOT_STRING     L"\\Microsoft\\Protect\\"

#define HISTORY_FILENAME        L"CREDHIST"

DWORD
CreateCredentialHistoryMap(
    HANDLE hUserToken,
    LPWSTR pszProfilePath,
    PCREDENTIAL_HISTORY_MAP *ppMap,
    BOOL fRead)
{
    PCREDENTIAL_HISTORY_MAP pMap = NULL;

    PCREDENTIAL_HISTORY_MAP pCached = NULL;

    DWORD   dwError = ERROR_SUCCESS;
    DWORD   dwHighFileSize = 0;

    DWORD cbUserStorageRoot;
    HANDLE hTemporaryMapping = NULL;

    WCHAR szFilePath[MAX_PATH + 1];
    PWSTR pszCreationStartPoint;

    NTSTATUS Status;

    if(NULL == ppMap)
    {
        return ERROR_INVALID_PARAMETER;
    }

    pMap = (PCREDENTIAL_HISTORY_MAP)LocalAlloc(LPTR, sizeof(CREDENTIAL_HISTORY_MAP));
    if(NULL == pMap)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    //
    // Obtain the user's SID.
    //

    if(hUserToken)
    {
        if(!GetTokenUserSid(hUserToken, &pMap->pUserSid))
        {
            dwError = GetLastError();
            goto error;
        }
    }
    else
    {
        HANDLE hToken;

        if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
        {
            dwError = GetLastError();
            goto error;
        }

        if(!GetTokenUserSid(hToken, &pMap->pUserSid))
        {
            dwError = GetLastError();
            CloseHandle(hToken);
            goto error;
        }

        CloseHandle(hToken);
    }


    //
    // Open map file
    //

    if(wcslen(pszProfilePath) + wcslen(PRODUCT_ROOT_STRING) + wcslen(HISTORY_FILENAME) > MAX_PATH)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

    wcscpy(szFilePath, pszProfilePath);


    // Build the path in a separate buffer just in case we have to create
    // the directory.
    pszCreationStartPoint = szFilePath + wcslen(szFilePath) + sizeof(WCHAR);
    wcscat(szFilePath, PRODUCT_ROOT_STRING);

    // Copy the path plus the filename over to the map structure.
    wcscpy(pMap->wszFilePath, szFilePath);
    wcscat(pMap->wszFilePath, HISTORY_FILENAME);


    //
    // Create the history file.
    //

    dwError = ERROR_SUCCESS;

    while(TRUE)
    {
        pMap->hHistoryFile = CreateFileWithRetries(
                    pMap->wszFilePath,
                    GENERIC_READ | GENERIC_WRITE,
                    0,  // cannot share this file when open
                    NULL,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_HIDDEN |
                    FILE_ATTRIBUTE_SYSTEM |
                    FILE_FLAG_RANDOM_ACCESS,
                    NULL
                    );

        if(INVALID_HANDLE_VALUE == pMap->hHistoryFile)
        {
            dwError = GetLastError();

            if(dwError == ERROR_PATH_NOT_FOUND)
            {
                // Create the DPAPI directory, and then try to create the file
                // again.
                Status = DPAPICreateNestedDirectories(szFilePath,
                                                      pszCreationStartPoint);

                if(!NT_SUCCESS(Status))
                {
                    goto error;
                }

                dwError = ERROR_SUCCESS;
                continue;
            }
            else
            {
                goto error;
            }
        }

        break;
    }

    

    pMap->dwMapSize = GetFileSize(pMap->hHistoryFile, &dwHighFileSize);

    if((-1 == pMap->dwMapSize) ||
       (dwHighFileSize != 0))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }


    //
    // If this map is too small, we need to create a new header
    //
    if(pMap->dwMapSize < sizeof(CREDENTIAL_HISTORY_HEADER))
    {

        PCREDENTIAL_HISTORY_HEADER pHeader = NULL;

        pMap->dwMapSize = sizeof(CREDENTIAL_HISTORY_HEADER);

        hTemporaryMapping = CreateFileMapping(pMap->hHistoryFile,
                                       NULL,
                                       PAGE_READWRITE,
                                       0,
                                       pMap->dwMapSize,
                                       NULL);

        if(NULL == hTemporaryMapping)
        {
            dwError = GetLastError();
            goto error;
        }

        pHeader = (PCREDENTIAL_HISTORY_HEADER)(PBYTE)MapViewOfFile(hTemporaryMapping,
                                   FILE_MAP_WRITE,
                                   0,
                                   0,
                                   0);

        if(NULL == pHeader)
        {
            dwError = GetLastError();
            goto error;
        }


        //
        // Write a fresh header into the cred history file
        //
        pHeader->dwPreviousCredOffset = 0;
        pHeader->dwVersion = CREDENTIAL_HISTORY_VERSION;
        dwError = UuidCreate( &pHeader->CredentialID );

        FlushViewOfFile(pHeader, pMap->dwMapSize);

        UnmapViewOfFile(pHeader);

        if(ERROR_SUCCESS != dwError)
        {
            goto error;
        }
    }

    *ppMap = pMap;
    pMap = NULL;


error:

    if(pMap)
    {
        DestroyCredentialHistoryMap(pMap);
    }

    if(hTemporaryMapping)
    {
        CloseHandle(hTemporaryMapping);
    }

    return dwError;
}


DWORD
OpenCredentialHistoryMap(
    HANDLE hUserToken,
    LPWSTR pszProfilePath,
    PCREDENTIAL_HISTORY_MAP *ppMap,
    PCREDENTIAL_HISTORY *ppCurrent)
{
    PCREDENTIAL_HISTORY_MAP pMap = NULL;
    PCREDENTIAL_HISTORY pCurrent = NULL;
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   dwHighFileSize = 0;

    WCHAR szFilePath[MAX_PATH+1];
    DWORD cbUserStorageRoot;
    HANDLE hTemporaryMapping = NULL;



    if((NULL == ppMap) ||
       (NULL == ppCurrent))
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwError = CreateCredentialHistoryMap(
                        hUserToken,
                        pszProfilePath,
                        &pMap,
                        TRUE);

    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }

    if(NULL == pMap->hMapping)
    {
        //
        // Open a read-only mapping of the file
        //
        pMap->hMapping = CreateFileMapping(pMap->hHistoryFile,
                                           NULL,
                                           PAGE_READONLY,
                                           dwHighFileSize,
                                           pMap->dwMapSize,
                                           NULL);

        if(NULL == pMap->hMapping)
        {
            dwError = GetLastError();
            goto error;
        }
    }


    if(NULL == pMap->pMapping)
    {

        pMap->pMapping = (PBYTE)MapViewOfFile(pMap->hMapping,
                                       FILE_MAP_READ,
                                       0,
                                       0,
                                       0);

        if(NULL == pMap->pMapping)
        {
            dwError = GetLastError();
            goto error;
        }
    }

    pCurrent = GetPreviousCredentialHistory(pMap, NULL);

    if(NULL == pCurrent)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

    *ppMap = pMap;
    pMap = NULL;

    *ppCurrent = pCurrent;


error:


    if(pMap)
    {
        CloseCredentialHistoryMap(pMap, TRUE);
    }

    return dwError;
}

PCREDENTIAL_HISTORY
GetPreviousCredentialHistory(
                             PCREDENTIAL_HISTORY_MAP pMap,
                             PCREDENTIAL_HISTORY pCurrent
                             )
{
    PCREDENTIAL_HISTORY pPrevious = NULL;
    DWORD cbSize = 0;

    if((NULL == pMap) ||
       (NULL == pMap->pMapping))
    {
        return NULL;
    }

    if(pMap->dwMapSize < sizeof(CREDENTIAL_HISTORY_HEADER))
    {
        return NULL;
    }

    if(NULL == pCurrent)
    {
        pPrevious = (PCREDENTIAL_HISTORY)((PBYTE)pMap->pMapping +
                                         pMap->dwMapSize - sizeof(CREDENTIAL_HISTORY_HEADER));
    }
    else
    {
        if(((PBYTE)pCurrent < pMap->pMapping) ||
            ((PBYTE)pCurrent - pMap->pMapping >= (__int64)pMap->dwMapSize) ||
           ((PBYTE)pCurrent - pMap->pMapping < (__int64)pCurrent->Header.dwPreviousCredOffset))
        {
            return NULL;
        }

        pPrevious = (PCREDENTIAL_HISTORY)((PBYTE)pCurrent - pCurrent->Header.dwPreviousCredOffset);

        cbSize = sizeof(CREDENTIAL_HISTORY) + pPrevious->cbSid;

        if(cbSize > pCurrent->Header.dwPreviousCredOffset)
        {
            return NULL;
        }
        cbSize = pCurrent->Header.dwPreviousCredOffset - cbSize;
        if(cbSize < pPrevious->cbShaOwf + pPrevious->cbNtOwf)
        {
            return NULL;
        }
        if(cbSize % DES_BLOCKLEN)
        {
            return NULL;
        }
        if(!IsValidSid((PSID)(pPrevious+1)))
        {
            return NULL;
        }
        if(GetLengthSid((PSID)(pPrevious+1)) != pPrevious->cbSid)
        {
            return NULL;
        }
    }

    // validate found credential history
    if(pPrevious->Header.dwVersion != CREDENTIAL_HISTORY_VERSION)
    {
        return NULL;
    }

    return pPrevious;
}

DWORD
DestroyCredentialHistoryMap(PCREDENTIAL_HISTORY_MAP pMap)
{
    if(NULL == pMap)
    {
        return ERROR_SUCCESS;
    }

    if(pMap->pMapping)
    {
        UnmapViewOfFile(pMap->pMapping);
        pMap->pMapping = NULL;
    }

    if(pMap->hMapping)
    {
        CloseHandle(pMap->hMapping);
        pMap->hMapping = NULL;
    }


    if(pMap->hHistoryFile)
    {
        CloseHandle(pMap->hHistoryFile);
        pMap->hHistoryFile = NULL;
    }
    LocalFree(pMap);

    return ERROR_SUCCESS;
}


DWORD
CloseCredentialHistoryMap(PCREDENTIAL_HISTORY_MAP pMap, BOOL fReader)
{
    if(NULL == pMap)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(pMap->pMapping)
    {
        UnmapViewOfFile(pMap->pMapping);
        pMap->pMapping = NULL;
    }

    if(pMap->hMapping)
    {
        CloseHandle(pMap->hMapping);
        pMap->hMapping = NULL;
    }


    if(pMap->hHistoryFile)
    {
        CloseHandle(pMap->hHistoryFile);
        pMap->hHistoryFile = NULL;
    }
    return DestroyCredentialHistoryMap(pMap);
}



DWORD
AppendCredentialHistoryMap(
                         PCREDENTIAL_HISTORY_MAP pMap,
                         PCREDENTIAL_HISTORY pCredHistory,
                         DWORD               cbCredHistory
                         )
{
    DWORD   dwLastError = ERROR_SUCCESS;
    DWORD   dwHighFileSize = 0;
    DWORD   dwLowFileSize = 0;

    HANDLE  hWriteMapping = NULL;
    LPVOID  pWriteMapping = NULL;
    PCREDENTIAL_HISTORY_HEADER pHeader = NULL;



    if((NULL == pCredHistory) ||
       (NULL == pMap))
    {
        return ERROR_INVALID_PARAMETER;
    }


    dwLowFileSize = pMap->dwMapSize + cbCredHistory;

    if(dwLowFileSize < pMap->dwMapSize)
    {
        //we wrapped, so fail.

        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }

    // Create a new mapping


    hWriteMapping = CreateFileMapping(pMap->hHistoryFile,
                                   NULL,
                                   PAGE_READWRITE,
                                   0,
                                   dwLowFileSize,
                                   NULL);
    if(NULL == hWriteMapping)
    {
        dwLastError = GetLastError();
        goto error;
    }

    pWriteMapping = (PCREDENTIAL_HISTORY_HEADER)(PBYTE)MapViewOfFile(hWriteMapping,
                               FILE_MAP_WRITE,
                               0,
                               0,
                               dwLowFileSize);

    if(NULL == pWriteMapping)
    {
        dwLastError = GetLastError();
        goto error;
    }

    //
    // Append the rest of the current entry
    //
    CopyMemory((PBYTE)pWriteMapping + pMap->dwMapSize,
               (PBYTE)pCredHistory + sizeof(CREDENTIAL_HISTORY_HEADER),
               cbCredHistory - sizeof(CREDENTIAL_HISTORY_HEADER));


    pHeader = (PCREDENTIAL_HISTORY_HEADER)((PBYTE)pWriteMapping +
                                                   pMap->dwMapSize +
                                                   cbCredHistory -
                                                   sizeof(CREDENTIAL_HISTORY_HEADER));


    //
    // Write a fresh header into the cred history file
    //
    pHeader->dwPreviousCredOffset = cbCredHistory;
    pHeader->dwVersion = CREDENTIAL_HISTORY_VERSION;
    dwLastError = UuidCreate( &pHeader->CredentialID );

    pMap->dwMapSize = dwLowFileSize;

    //
    // Flush and close write mapping
    //

    if(ERROR_SUCCESS == dwLastError)
    {
        if(!FlushViewOfFile(pWriteMapping, pMap->dwMapSize))
        {
            dwLastError = GetLastError();
        }
    }

    UnmapViewOfFile(pWriteMapping);

    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }

    CloseHandle(hWriteMapping);
    hWriteMapping = NULL;






    // Remap the read mapping to bump up the size

    if(pMap->pMapping)
    {
        UnmapViewOfFile(pMap->pMapping);
        pMap->pMapping = NULL;
    }



    if(pMap->hMapping)
    {
        CloseHandle(pMap->hMapping);
        pMap->hMapping = NULL;
    }



    pMap->hMapping = CreateFileMapping(pMap->hHistoryFile,
                                       NULL,
                                       PAGE_READONLY,
                                       dwHighFileSize,
                                       pMap->dwMapSize,
                                       NULL);

    if(NULL == pMap->hMapping)
    {
        dwLastError = GetLastError();
        goto error;
    }

    pMap->pMapping = (PBYTE)MapViewOfFile(pMap->hMapping,
                                   FILE_MAP_READ,
                                   0,
                                   0,
                                   0);

    if(NULL == pMap->pMapping)
    {
        dwLastError = GetLastError();
        goto error;
    }


error:

    return dwLastError;
}


DWORD
DPAPIChangePassword(
    HANDLE hUserToken,
    PUNICODE_STRING UserName,
    BYTE OldPasswordShaOWF[A_SHA_DIGEST_LEN],
    BYTE OldPasswordNTOWF[A_SHA_DIGEST_LEN],
    BYTE NewPasswordOWF[A_SHA_DIGEST_LEN])
{
    DWORD   dwLastError = ERROR_SUCCESS;

    PCREDENTIAL_HISTORY_MAP pMap = NULL;
    PCREDENTIAL_HISTORY pHistory = NULL;

    DWORD cbHistory = 0;
    WCHAR wszUserSid[MAX_PATH+1];
    DWORD cchUserSid = 0;
    BYTE NewEncryptingCred[A_SHA_DIGEST_LEN];
    WCHAR szProfilePath[MAX_PATH + 1];

    HANDLE hOldUser = NULL;

    D_DebugLog((DEB_TRACE_API, "DPAPIChangePassword\n"));


    //
    // Get path to user's profile data. This will typically look something
    // like "c:\Documents and Settings\<user>\Application Data".
    //

    dwLastError = PRGetProfilePath(hUserToken,
                                   UserName,
                                   szProfilePath);

    if( dwLastError != ERROR_SUCCESS )
    {
        D_DebugLog((DEB_TRACE_API, "DPAPIChangePassword returned 0x%x\n", dwLastError));
        return dwLastError;
    }


    //
    // work-around the fact that much of this (new) code is not thread-safe.
    //

    RtlEnterCriticalSection(&g_csCredHistoryCache);


    dwLastError = CreateCredentialHistoryMap(
                     hUserToken,
                     szProfilePath,
                     &pMap,
                     FALSE);

    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }


    //
    // Get textual SID of user.
    //

    cchUserSid = MAX_PATH;

    if(!GetUserTextualSid(hUserToken,
                          wszUserSid,
                          &cchUserSid))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }


    //
    // Encrypt the credential history goo.
    //

    if(hUserToken)
    {
        if(!OpenThreadToken(GetCurrentThread(), 
                        TOKEN_IMPERSONATE | TOKEN_READ,
                        TRUE, 
                        &hOldUser)) 
        {
            hOldUser = NULL;
        }

        if(!ImpersonateLoggedOnUser(hUserToken))
        {
            dwLastError = GetLastError();
            goto error;
        }
    }

    DeriveWithHMAC_SHA1(NewPasswordOWF,
                        A_SHA_DIGEST_LEN,
                        (PBYTE)wszUserSid,
                        cchUserSid*sizeof(WCHAR),
                        NewEncryptingCred);


    dwLastError = EncryptCredentialHistory(NewEncryptingCred,
                                           USE_DPAPI_OWF,
                                           OldPasswordShaOWF,
                                           OldPasswordNTOWF,
                                           &pHistory,
                                           &cbHistory);

    if(hOldUser)
    {
        SetThreadToken(NULL, hOldUser);
        CloseHandle(hOldUser);
        hOldUser = NULL;
    }

    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }


    //
    // Update the CREDHIST file.
    //

    dwLastError = AppendCredentialHistoryMap(pMap, pHistory, cbHistory);
    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }


error:

    if(pMap)
    {
        CloseCredentialHistoryMap(pMap, FALSE);
    }

    RtlLeaveCriticalSection(&g_csCredHistoryCache);

    if(pHistory)
    {
        ZeroMemory(pHistory, cbHistory);
    }
    ZeroMemory(NewEncryptingCred, A_SHA_DIGEST_LEN);

    D_DebugLog((DEB_TRACE_API, "DPAPIChangePassword returned 0x%x\n", dwLastError));

    return dwLastError;
}






#define SIGNATURE_SALT_SIZE (16)
#define CRED_SIGNATURE_VERSION 1


typedef struct _CRED_SIGNATURE
{
    DWORD dwVersion;
    GUID  CredentialID;
    DWORD cIterations;
    BYTE  Salt[SIGNATURE_SALT_SIZE];
    DWORD cbSid;
    DWORD cbSignature;
} CRED_SIGNATURE, *PCRED_SIGNATURE;


DWORD
LogonCredGenerateSignatureKey(
                  IN LUID  *pLogonId,
                  IN DWORD dwFlags,
                  IN PBYTE pbCurrentOWF,
                  IN PCRED_SIGNATURE pSignature,
                  OUT BYTE rgbSignatureKey[A_SHA_DIGEST_LEN])
{
    DWORD dwLastError = ERROR_SUCCESS;
    BYTE rgbDerivedCredential[A_SHA_DIGEST_LEN];

    D_DebugLog((DEB_TRACE_API, "LogonCredGenerateSignatureKey\n"));

    if(NULL == pbCurrentOWF)
    {
        dwLastError = QueryDerivedCredential(&pSignature->CredentialID,
                                            pLogonId,
                                            dwFlags,
                                            (PBYTE)(pSignature+1),
                                            pSignature->cbSid,
                                            rgbDerivedCredential);

        if(ERROR_SUCCESS != dwLastError)
        {
            goto error;
        }
    }
    else
    {
//        D_DebugLog((DEB_TRACE_BUFFERS, "Input CurrentOWF:\n"));
//        D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", pbCurrentOWF, A_SHA_DIGEST_LEN);

        DeriveWithHMAC_SHA1(pbCurrentOWF,
                            A_SHA_DIGEST_LEN,
                            (PBYTE)(pSignature+1),
                            pSignature->cbSid,
                            rgbDerivedCredential);


        if(dwFlags & USE_ROOT_CREDENTIAL)
        {
            ZeroMemory(&pSignature->CredentialID, sizeof(GUID));
        }

    }

//    D_DebugLog((DEB_TRACE_BUFFERS, "Computed DerivedCredential:\n"));
//    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", rgbDerivedCredential, sizeof(rgbDerivedCredential));

    if(!PKCS5DervivePBKDF2( rgbDerivedCredential,
                        A_SHA_DIGEST_LEN,
                        pSignature->Salt,
                        SIGNATURE_SALT_SIZE,
                        CALG_HMAC,
                        pSignature->cIterations,
                        1,
                        rgbSignatureKey))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }

//    D_DebugLog((DEB_TRACE_BUFFERS, "Computed SignatureKey:\n"));
//    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", rgbSignatureKey, A_SHA_DIGEST_LEN);

error:

    ZeroMemory(rgbDerivedCredential, A_SHA_DIGEST_LEN);

    D_DebugLog((DEB_TRACE_API, "LogonCredGenerateSignatureKey returned 0x%x\n", dwLastError));

    return dwLastError;
}


DWORD
LogonCredGenerateSignature(
    IN HANDLE hUserToken,
    IN PBYTE pbData,
    IN DWORD cbData,
    IN  PBYTE pbCurrentOWF,
    OUT PBYTE *ppbSignature,
    OUT DWORD *pcbSignature)
{

    DWORD dwLastError = ERROR_SUCCESS;
    LUID LogonId;

    PCRED_SIGNATURE pSignature = NULL;
    DWORD           cbSignature = 0;
    BYTE            rgbSignatureKey[A_SHA_DIGEST_LEN];
    PSID            pUserSid = NULL;

    D_DebugLog((DEB_TRACE_API, "LogonCredGenerateSignature\n"));

    cbSignature = sizeof(CRED_SIGNATURE);

    if(!GetTokenAuthenticationId(hUserToken, &LogonId))
    {
        dwLastError = GetLastError();
        goto error;
    }

    if(!GetTokenUserSid(hUserToken, &pUserSid))
    {
        dwLastError = GetLastError();
        goto error;
    }

    D_DebugLog((DEB_TRACE_BUFFERS, "User SID:\n"));
    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", (PBYTE)pUserSid, GetLengthSid(pUserSid));

    cbSignature += GetLengthSid(pUserSid);

    cbSignature += A_SHA_DIGEST_LEN;

    pSignature = (PCRED_SIGNATURE)LocalAlloc(LMEM_ZEROINIT, cbSignature);

    if(NULL == pSignature)
    {
        dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    pSignature->cIterations = GetIterationCount();


    pSignature->dwVersion = CRED_SIGNATURE_VERSION;

    pSignature->cbSid = GetLengthSid(pUserSid);


    pSignature->cbSignature = A_SHA_DIGEST_LEN;

    CopyMemory((PBYTE)(pSignature+1),
                      pUserSid,
                      pSignature->cbSid);

    RtlGenRandom(pSignature->Salt, SIGNATURE_SALT_SIZE);

//    D_DebugLog((DEB_TRACE_BUFFERS, "Generated Salt:\n"));
//    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", pSignature->Salt, SIGNATURE_SALT_SIZE);


    dwLastError = LogonCredGenerateSignatureKey(&LogonId,
                                                USE_ROOT_CREDENTIAL | USE_DPAPI_OWF,
                                                pbCurrentOWF,
                                                pSignature,
                                                rgbSignatureKey);

    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }

    if(!FMyPrimitiveHMACParam(
                              rgbSignatureKey,
                              A_SHA_DIGEST_LEN,
                              pbData,
                              cbData,
                              (PBYTE)(pSignature+1) + pSignature->cbSid))
    {
        dwLastError = ERROR_INVALID_DATA;
    }
    else
    {
        D_DebugLog((DEB_TRACE_BUFFERS, "Computed Signature:\n"));
        D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", (PBYTE)(pSignature+1) + pSignature->cbSid, A_SHA_DIGEST_LEN);

        *ppbSignature = (PBYTE)pSignature;
        *pcbSignature = cbSignature;
        pSignature = NULL;

    }

error:

    if(pSignature)
    {
        ZeroMemory(pSignature, cbSignature);
        LocalFree(pSignature);
    }

    if(pUserSid)
    {
        LocalFree(pUserSid);
    }

    D_DebugLog((DEB_TRACE_API, "LogonCredGenerateSignature returned 0x%x\n", dwLastError));

    return dwLastError;
}


DWORD
LogonCredVerifySignature(
    IN HANDLE hUserToken,       // optional
    IN PBYTE pbData,
    IN DWORD cbData,
    IN PBYTE pbCurrentOWF,
    IN PBYTE pbSignature,
    IN DWORD cbSignature)
{
    DWORD dwLastError = ERROR_SUCCESS;
    LUID LogonId;
    HANDLE hOldUser = NULL;
    BOOL fIsMember = FALSE;

    PCRED_SIGNATURE pSignature = (PCRED_SIGNATURE)pbSignature;

    BYTE            rgbSignatureKey[A_SHA_DIGEST_LEN];
    BYTE            rgbSignatureHash[A_SHA_DIGEST_LEN];
    PSID            pUserSid = NULL;

    D_DebugLog((DEB_TRACE_API, "LogonCredVerifySignature\n"));

    if(hUserToken)
    {
        if(!OpenThreadToken(GetCurrentThread(), 
                        TOKEN_IMPERSONATE | TOKEN_READ,
                        TRUE, 
                        &hOldUser)) 
        {
            hOldUser = NULL;
        }

        if(!ImpersonateLoggedOnUser(hUserToken))
        {
            dwLastError = GetLastError();
            goto error;
        }
    }


    if(!GetThreadAuthenticationId(GetCurrentThread(), &LogonId))
    {
        dwLastError = GetLastError();
        goto error;
    }



    //
    // Verify passed in credential
    //
    if((NULL == pSignature) ||
       (sizeof(CRED_SIGNATURE) > cbSignature) ||
       (pSignature->dwVersion != CRED_SIGNATURE_VERSION) ||
       (pSignature->cbSid + pSignature->cbSignature + sizeof(CRED_SIGNATURE) > cbSignature) ||
       (pSignature->cbSignature != A_SHA_DIGEST_LEN))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }

    if(!IsValidSid((PSID)(pSignature+1)))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }

    if(pSignature->cbSid != GetLengthSid((PSID)(pSignature+1)))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }

    D_DebugLog((DEB_TRACE_BUFFERS, "User SID:\n"));
    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", (PBYTE)(pSignature+1), pSignature->cbSid);

    if(!CheckTokenMembership( NULL,
                              (PSID)(pSignature+1),
                              &fIsMember ))
    {
        dwLastError = GetLastError();
        goto error;
    }


    if(!fIsMember)
    {
        dwLastError = ERROR_INVALID_ACCESS;
        goto error;
    }

    dwLastError = LogonCredGenerateSignatureKey(&LogonId,
                                                USE_DPAPI_OWF,
                                                pbCurrentOWF,
                                                pSignature,
                                                rgbSignatureKey);

    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }

    if(!FMyPrimitiveHMACParam(
                              rgbSignatureKey,
                              A_SHA_DIGEST_LEN,
                              pbData,
                              cbData,
                              rgbSignatureHash))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }

    D_DebugLog((DEB_TRACE_BUFFERS, "Computed Signature:\n"));
    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", rgbSignatureHash, A_SHA_DIGEST_LEN);

    D_DebugLog((DEB_TRACE_BUFFERS, "Input Signature:\n"));
    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", (PBYTE)(pSignature+1) + pSignature->cbSid, pSignature->cbSignature);

    if(0 != memcmp(rgbSignatureHash, (PBYTE)(pSignature+1) + pSignature->cbSid, pSignature->cbSignature))
    {
        D_DebugLog((DEB_ERROR, "LogonCredVerifySignature: signature did not verify!\n"));
        dwLastError = ERROR_INVALID_ACCESS;
        goto error;
    }


error:

    if(hOldUser)
    {
        SetThreadToken(NULL, hOldUser);
        CloseHandle(hOldUser);
    }

    D_DebugLog((DEB_TRACE_API, "LogonCredVerifySignature returned 0x%x\n", dwLastError));

    return dwLastError;
}


DWORD
DPAPINotifyPasswordChange(
    IN PUNICODE_STRING NetbiosDomainName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword)
{
    DWORD Status = ERROR_SUCCESS;
    BYTE OldPasswordShaOWF[A_SHA_DIGEST_LEN];
    BYTE OldPasswordNTOWF[A_SHA_DIGEST_LEN];
    BYTE NewPasswordOWF[A_SHA_DIGEST_LEN];
    HANDLE hUserToken = NULL;
    HANDLE hOldUser = NULL;

    PWSTR pszTargetName = NULL;
    PWSTR pszCurrentName = NULL;
    DWORD cchCurrentName;

    PSID pUserSid = NULL;
    PSID pCurrentSid = NULL;
    DWORD cbSid;
    SID_NAME_USE SidType; 
    PWSTR pszDomainName = NULL;
    DWORD cchDomainName;
    BOOL fSameUser = FALSE;
    BOOL fLocalAccount = FALSE;


    D_DebugLog((DEB_TRACE_API, "DPAPINotifyPasswordChange\n"));

    //
    // Validate input parameters.
    //

    if((NetbiosDomainName == NULL) ||
       (UserName    == NULL) ||
       (NewPassword == NULL))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if(NetbiosDomainName->Buffer)
    {
        D_DebugLog((DEB_TRACE_API, "  Domain:%ls\n", NetbiosDomainName->Buffer));
    }
    if(UserName->Buffer)
    {
        D_DebugLog((DEB_TRACE_API, "  Username:%ls\n", UserName->Buffer));
    }

#ifdef COMPILED_BY_DEVELOPER
    if(OldPassword)
    {
        D_DebugLog((DEB_TRACE_API, "  Old password:%ls\n", OldPassword->Buffer));
    }
    D_DebugLog((DEB_TRACE_API, "  New password:%ls\n", NewPassword->Buffer));
#endif

    //
    // Get SID of user whose password is being changed.
    //

    cbSid = 0;

    if(!LookupAccountName(NetbiosDomainName->Buffer,
                          UserName->Buffer,
                          NULL,
                          &cbSid,
                          NULL,
                          &cchDomainName,
                          &SidType))
    {
        Status = GetLastError();

        if(Status != ERROR_INSUFFICIENT_BUFFER)
        {
            goto cleanup;
        }
    }

    pUserSid = LocalAlloc(LPTR, cbSid);
    if(pUserSid == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    pszDomainName = (PWSTR)LocalAlloc(LPTR, cchDomainName * sizeof(WCHAR));
    if(pszDomainName == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    if(!LookupAccountName(NetbiosDomainName->Buffer,
                          UserName->Buffer,
                          pUserSid,
                          &cbSid,
                          pszDomainName,
                          &cchDomainName,
                          &SidType))
    {
        Status = GetLastError();

        if(Status != ERROR_INSUFFICIENT_BUFFER)
        {
            goto cleanup;
        }
    }


    //
    // Determine if we're already logged on as the user whose password
    // is being changed. If we are, then we can skip loading the user
    // profile, etc.
    //

    if(OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hUserToken))
    {
        if(!GetTokenUserSid(hUserToken, &pCurrentSid))
        {
            Status = GetLastError();
            goto cleanup;
        }

        if(EqualSid(pCurrentSid, pUserSid))
        {
            fSameUser = TRUE;
        }

        CloseHandle(hUserToken);
        hUserToken = NULL;
    }


    //
    // Create logon token for user whose password is being changed.
    //

    if(!fSameUser)
    {
        D_DebugLog((DEB_TRACE, "Logging on as user whose password is being changed.\n"));

        if(!LogonUser(UserName->Buffer, 
                      NetbiosDomainName->Buffer, 
                      NewPassword->Buffer, 
                      LOGON32_LOGON_INTERACTIVE,
                      LOGON32_PROVIDER_DEFAULT, 
                      &hUserToken))
        {
            Status = GetLastError();
            D_DebugLog((DEB_ERROR, "Unable to log on as user whose password is being changed (0x%x).\n", Status));
            goto cleanup;
        }
    }
    

    //
    // Is this a local account?
    //

    if(NetbiosDomainName->Buffer)
    {
        WCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 1];
        DWORD cchMachineName;

        cchMachineName = MAX_COMPUTERNAME_LENGTH + 1;

        if(!GetComputerName(szMachineName, &cchMachineName))
        {
            Status = GetLastError();
            goto cleanup;
        }

        if (CSTR_EQUAL == CompareString(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                NetbiosDomainName->Buffer,
                -1,             // cchCount1
                szMachineName,
                -1              // cchCount2
                ))
        {
            fLocalAccount = TRUE;
        }
    }


    if(fLocalAccount)
    {
        D_DebugLog((DEB_TRACE, "Local account\n"));

        if(OldPassword == NULL)
        {
            Status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

        //
        // Compute hashes of old and new passwords.
        //
    
        ZeroMemory(OldPasswordShaOWF, A_SHA_DIGEST_LEN);
        ZeroMemory(OldPasswordNTOWF,  A_SHA_DIGEST_LEN);
        ZeroMemory(NewPasswordOWF,    A_SHA_DIGEST_LEN);
    
        FMyPrimitiveSHA(
                (PBYTE)OldPassword->Buffer,
                OldPassword->Length,
                OldPasswordShaOWF);
    
        Status = RtlCalculateNtOwfPassword( 
                        OldPassword,
                        (PLM_OWF_PASSWORD)OldPasswordNTOWF);
    
        if(Status != ERROR_SUCCESS)
        {
            goto cleanup;
        }
    
        FMyPrimitiveSHA(
                (PBYTE)NewPassword->Buffer,
                NewPassword->Length,
                NewPasswordOWF);

        #ifdef COMPILED_BY_DEVELOPER
        D_DebugLog((DEB_TRACE, "  Old password SHA OWF:\n"));
        D_DPAPIDumpHexData(DEB_TRACE, "  ", OldPasswordShaOWF, A_SHA_DIGEST_LEN);
        D_DebugLog((DEB_TRACE, "  Old password NT OWF:\n"));
        D_DPAPIDumpHexData(DEB_TRACE, "  ", OldPasswordNTOWF, A_SHA_DIGEST_LEN);
        D_DebugLog((DEB_TRACE, "  New password SHA OWF:\n"));
        D_DPAPIDumpHexData(DEB_TRACE, "  ", NewPasswordOWF, A_SHA_DIGEST_LEN);
        #endif


        //
        // Encrypt the CREDHIST file with the new password and append the new password to
        // the end of the file.
        //
        
        Status = DPAPIChangePassword(hUserToken,
                                     UserName,
                                     OldPasswordShaOWF, 
                                     OldPasswordNTOWF, 
                                     NewPasswordOWF);
    
        if(Status != ERROR_SUCCESS)
        {
            goto cleanup;
        }


        //
        // Re-synchronize the master keys.
        //
    
        DPAPISynchronizeMasterKeys(hUserToken);
    
    
        //
        // Encrypt the new password with the recovery public key, and store it
        // in the RECOVERY file. This will allow us to recover the password using the
        // recovery floppy, should the user forget it.
        //
    
        Status = RecoverChangePasswordNotify(hUserToken,
                                             OldPasswordShaOWF,
                                             NewPassword);
        if(Status != ERROR_SUCCESS)
        {
            goto cleanup;
        }
    }
    else
    {
        D_DebugLog((DEB_TRACE, "Domain account\n"));

        //
        // Re-synchronize the master keys.
        //
    
        DPAPISynchronizeMasterKeys(hUserToken);
    }


cleanup:

    if(pUserSid) LocalFree(pUserSid);
    if(pCurrentSid) LocalFree(pCurrentSid);
    if(pszDomainName) LocalFree(pszDomainName);

    if(pszTargetName) LocalFree(pszTargetName);
    if(pszCurrentName) LocalFree(pszCurrentName);

    if(hUserToken)
    {
        CloseHandle(hUserToken);
    }

    D_DebugLog((DEB_TRACE_API, "DPAPINotifyPasswordChange returned 0x%x\n", Status));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\dpapisvc\session.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    session.h

Abstract:

    This module contains prototypes to support communication with the LSA
    (Local Security Authority) to permit querying of active sessions.

Author:

    Scott Field (sfield)    02-Mar-97

--*/

#ifndef __SESSION_H__
#define __SESSION_H__

#ifdef __cplusplus
extern "C" {
#endif


DWORD 
QueryDerivedCredential(
    IN      GUID *CredentialID, 
    IN      LUID *pLogonId,
    IN      DWORD dwFlags,
    IN      PBYTE pbMixingBytes,
    IN      DWORD cbMixingBytes,
    IN OUT  BYTE rgbDerivedCredential[A_SHA_DIGEST_LEN]
    );

DWORD               
DeleteCredentialHistoryMap();

DWORD
LogonCredGenerateSignature(
    IN  HANDLE hUserToken,
    IN  PBYTE pbData,
    IN  DWORD cbData,
    IN  PBYTE pbCurrentOWF,
    OUT PBYTE *ppbSignature,
    OUT DWORD *pcbSignature);

DWORD
LogonCredVerifySignature(
                        IN HANDLE hUserToken,   // optional
                        IN PBYTE pbData,
                        IN DWORD cbData,
                        IN  PBYTE pbCurrentOWF,
                        IN PBYTE pbSignature,
                        IN DWORD cbSignature);

#ifdef __cplusplus
}
#endif


#endif // __SESSION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\debug.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* Snipped from SChannel sources
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

#ifndef __DEBUG_H__
#define __DEBUG_H__


#ifdef __cplusplus
extern "C" {
#endif


#define SECSTOR_INVALID_MAGIC       *(DWORD *)"eerF"


/* Event Logging Definitions */
#define SS_LOG_ERROR                0x0001
#define SS_LOG_WARNING              0x0002
#define SS_LOG_TRACE                0x0004
#define SS_LOG_ALLOC                0x0008
#define SS_LOG_RES                  0x0010

// assert 
#if DBG
void SSAssert(
    void *FailedAssertion, 
    void *FileName, 
    unsigned long LineNumber,
    char * Message);

#define SS_ASSERT(x) \
	    if (!(x)) \
		SSAssert(#x, __FILE__, __LINE__, NULL); else

#else   // DBG
#define SS_ASSERT(x)
#endif  // DBG

// verify
#if DBG
#define SS_VERIFY(x) SS_ASSERT(x)
#else   // DBG
#define SS_VERIFY(x) (x)
#endif  // DBG


// alloc/free
#if DBG
VOID *SSAlloc(DWORD cb);
VOID *SSReAlloc(VOID *pv, DWORD cb);
VOID SSFree(VOID *pv);
SIZE_T SSSize(VOID *pv);
#else   // DBG
#define SSAlloc(cb)         LocalAlloc(LMEM_FIXED, cb)
#define SSReAlloc(pv, cb)   LocalReAlloc(pv, cb, LMEM_MOVEABLE)	  // allow ReAlloc to move
#define SSFree(pv)          LocalFree(pv)
#define SSSize(pv)          LocalSize(pv)
#endif  // DBG


// Error logging routines

#if DBG
long    
SSPrintErrorCode(
    long err, 
    const char *szFile, 
    long lLine);

#else   // DBG
#define SSPrintErrorCode(err, szFile, lLine)
#endif  // DBG


#undef RtlMoveMemory


NTSYSAPI
VOID
NTAPI
RtlMoveMemory (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   SIZE_T Length
   );



#ifdef __cplusplus
}
#endif

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\dispif.h ===
// dispatcher interface file

#ifndef _DISPIF_H_
#define _DISPIF_H_

#ifdef __cplusplus
extern "C" {
#endif


typedef
BOOL FIMPERSONATECLIENT(
    PST_PROVIDER_HANDLE *hPSTProv
    );

FIMPERSONATECLIENT FImpersonateClient;

typedef
BOOL FREVERTTOSELF(
    PST_PROVIDER_HANDLE *hPSTProv
    );

FREVERTTOSELF FRevertToSelf;


typedef
BOOL
FISACLSATISFIED(
    PST_PROVIDER_HANDLE     *hPSTProv,
    PST_ACCESSRULESET       *psRules,
    DWORD                   dwAccess,
    LPVOID      // coming soon: fill a status structure with data about access attempt
    );

FISACLSATISFIED FIsACLSatisfied;

typedef
BOOL FGETCALLERNAME(
        PST_PROVIDER_HANDLE     *hPSTProv,
        LPWSTR*                 ppszCallerName,
        DWORD_PTR               *lpdwBaseAddress
        );

FGETCALLERNAME  FGetCallerName;


typedef
BOOL FGETUSER(
    PST_PROVIDER_HANDLE *hPSTProv,
    LPWSTR* pszUser
    );

FGETUSER        FGetUser;

typedef
BOOL FGETSERVERPARAM(
    IN      PST_PROVIDER_HANDLE *hPSTProv,
    IN      DWORD  dwParam,
    IN      LPVOID pData,
    IN  OUT DWORD *pcbData
    );

FGETSERVERPARAM FGetServerParam;


typedef
BOOL FSETSERVERPARAM(
    IN      PST_PROVIDER_HANDLE *hPSTProv,
    IN      DWORD  dwParam,
    IN      LPVOID pData,
    IN      DWORD pcbData
    );

FSETSERVERPARAM FSetServerParam;


// HACKHACK HACKHACK HACKHACK
typedef
BOOL FGETPASSWORD95LOWERCASE(
    LPBYTE rgbPwd
    );

FGETPASSWORD95LOWERCASE FGetPassword95LowerCase;

// a single structure to hold all of these callbacks
typedef struct _DISPIF_CALLBACKS
{
    DWORD                   cbSize; // sizeof(DISPIF_CALLBACKS)
    FISACLSATISFIED*        pfnFIsACLSatisfied;

    FGETUSER*               pfnFGetUser;
    FGETCALLERNAME*         pfnFGetCallerName;

    FIMPERSONATECLIENT*     pfnFImpersonateClient;
    FREVERTTOSELF*          pfnFRevertToSelf;

    FGETSERVERPARAM*        pfnFGetServerParam;
    FSETSERVERPARAM*        pfnFSetServerParam;

} DISPIF_CALLBACKS, *PDISPIF_CALLBACKS;


//
// private interfaces in the server which are not exported for provider use
//

BOOL
FInternalCreateType(
    PST_PROVIDER_HANDLE *phPSTProv,
    PST_KEY KeyLocation,
    const GUID *pguidType,
    PPST_TYPEINFO pinfoType,
    DWORD dwFlags
    );

BOOL
FInternalCreateSubtype(
    PST_PROVIDER_HANDLE *phPSTProv,
    PST_KEY KeyLocation,
    const GUID *pguidType,
    const GUID *pguidSubtype,
    PPST_TYPEINFO pinfoSubtype,
    DWORD dwFlags
    );

BOOL
FInternalWriteAccessRuleset(
    PST_PROVIDER_HANDLE *phPSTProv,
    PST_KEY KeyLocation,
    const GUID *pguidType,
    const GUID *pguidSubtype,
    PPST_ACCESSRULESET psRules,
    DWORD dwFlags
    );


#ifdef __cplusplus
}
#endif


#endif // _DISPIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\guidcnvt.h ===
#define MAX_GUID_SZ_CHARS  40

#ifdef __cplusplus
extern "C" {
#endif

// guid -> string conversion
DWORD MyGuidToStringA(
    const GUID* pguid, 
    CHAR rgsz[]);

// guid -> string conversion
DWORD MyGuidToStringW(
    const GUID* pguid, 
    WCHAR rgsz[]);


// string -> guid conversion
DWORD MyGuidFromStringA(
    LPSTR sz, 
    GUID* pguid);

// string -> guid conversion
DWORD MyGuidFromStringW(
    LPWSTR szW, 
    GUID* pguid);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\filemisc.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    filemisc.h

Abstract:

    This module contains routines to perform miscellaneous file related
    operations in the protected store.

Author:

    Scott Field (sfield)    27-Nov-96

--*/

#ifndef __FILEMISC_H__
#define __FILEMISC_H__

#ifdef __cplusplus
extern "C" {
#endif


BOOL
GetFileNameFromPath(
    IN      LPCWSTR FullPath,
    IN  OUT LPCWSTR *FileName   // points to filename component in FullPath
    );

BOOL
GetFileNameFromPathA(
    IN      LPCSTR FullPath,
    IN  OUT LPCSTR *FileName    // points to filename component in FullPath
    );

BOOL
TranslateFromSlash(
    IN      LPWSTR szInput,
    IN  OUT LPWSTR *pszOutput
    );

BOOL
TranslateToSlash(
    IN      LPWSTR szInput,
    IN  OUT LPWSTR *pszOutput
    );

BOOL
TranslateString(
    IN      LPWSTR szInput,
    IN  OUT LPWSTR *pszOutput,  // optional
    IN      WCHAR From,
    IN      WCHAR To
    );

BOOL
FindAndOpenFile(
    IN      LPCWSTR szFileName,     // file to search for + open
    IN  OUT LPWSTR  pszFullPath,    // file to fill fullpath with
    IN      DWORD   cchFullPath,    // size of full path buffer, including NULL
    IN  OUT PHANDLE phFile          // resultant open file handle
    );

BOOL
HashEntireDiskImage(
    IN  HANDLE hFile,       // handle of file to hash
    IN  LPBYTE FileHash     // on success, buffer contains file hash
    );

BOOL
HashDiskImage(
    IN  HANDLE hFile,       // handle of file to hash
    IN  LPBYTE FileHash     // on success, buffer contains file hash
    );

HINSTANCE
LoadAndOpenResourceDll(
    IN      LPCWSTR szFileName,     // file name to load + open
    IN  OUT LPWSTR  pszFullPath,    // buffer to fill file fullpath with
    IN      DWORD   cchFullPath,    // size of full path buffer (chars), including NULL
    IN  OUT PHANDLE phFile
    );

#ifdef __cplusplus
}
#endif


#endif // __FILEMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\dpapidbg.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        dpapidbg.h
//
// Contents:    Debug information for DPAPI
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __DPAPIDBG_H__
#define __DPAPIDBG_H__

//
//  NOTE:  DO not remove RETAIL_LOG_SUPPORT from sources,
//  or you'll be busted in DBG builds.
//

#ifdef RETAIL_LOG_SUPPORT

DECLARE_DEBUG2(DPAPI);
#undef DebugLog
#define DebugLog(_x_) DPAPIDebugPrint _x_

#define DPAPI_PARAMETER_PATH    L"System\\CurrentControlSet\\Control\\Lsa\\DPAPI"

#define WSZ_DPAPIDEBUGLEVEL     L"LogLevel"
#define WSZ_FILELOG             L"LogToFile"


#define DEB_TRACE_API           0x0008
#undef  DEB_TRACE_CRED
#define DEB_TRACE_CRED          0x0010
#define DEB_TRACE_CTXT          0x0020
#define DEB_TRACE_LSESS         0x0040
#define DEB_TRACE_TCACHE        0x0080
#define DEB_TRACE_LOGON         0x0100
#define DEB_TRACE_KDC           0x0200
#define DEB_TRACE_CTXT2         0x0400
#define DEB_TRACE_TIME          0x0800
#define DEB_TRACE_USER          0x1000
#define DEB_TRACE_LEAKS         0x2000
#define DEB_TRACE_BUFFERS       0x4000
#undef DEB_TRACE_LOCKS
#define DEB_TRACE_LOCKS         0x01000000
#define DEB_USE_LOG_FILE        0x2000000

//  For extended errors
#define DEB_USE_EXT_ERRORS      0x10000000
 
#define EXT_ERROR_ON(s)         (s & DEB_USE_EXT_ERRORS)            


#define SSAlloc(cb)         LocalAlloc(LMEM_FIXED, cb)
#define SSReAlloc(pv, cb)   LocalReAlloc(pv, cb, LMEM_MOVEABLE)	  // allow ReAlloc to move
#define SSFree(pv)          LocalFree(pv)
#define SSSize(pv)          LocalSize(pv)


VOID
DPAPIInitializeDebugging(VOID);

VOID
DPAPIDumpHexData(
    DWORD LogLevel,
    PSTR  pszPrefix,
    PBYTE pbData,
    DWORD cbData);

#else // RETAIL_LOG_SUPPORT

#define DebugLog(_x_)
#define DPAPIInitializeDebugging()
#define EXT_ERROR_ON(s)                 FALSE


#endif // RETAIL_LOG_SUPPORT  
    
#if DBG
#define D_DebugLog(_x_) DebugLog(_x_) // don't use all debug spew in retail builds
#define D_DPAPIDumpHexData(level, prefix, buffer, count) DPAPIDumpHexData((level), (prefix), (buffer), (count))
#else 
#define D_DebugLog(_x_)
#define D_DPAPIDumpHexData(level, prefix, buffer, count) 
#endif



#endif // __DPAPIDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\keybur.h ===
//
//  Keybur.h
//  
//  Copyright (c) Microsoft Corp, 1997
//
#ifndef __KEYBUR_H__
#define __KEYBUR_H__

#include <windows.h>
#include <winnt.h>
#include <winuser.h>
#include <stdio.h>
#include <stdlib.h>
#include "loggit.h"

//  Action Values for 

#define KB_MUNGEMK    1
#define KB_DELETEMK   2



BOOL
HoseKey(DWORD dwAction, DWORD dwKeyType);

BOOL 
CreateSD(PSECURITY_DESCRIPTOR * pSD);

BOOL
DestroySD(PSECURITY_DESCRIPTOR pSD);

BOOL
SetRegistrySecurity(HKEY hKey,
                    PSECURITY_DESCRIPTOR pSD);

BOOL
SetPrivilege(HANDLE hToken,          
             LPCTSTR Privilege,      
             BOOL bEnablePrivilege);

BOOL
SetCurrentPrivilege(LPCTSTR Privilege,    
                    BOOL bEnablePrivilege);


BOOL
SetRegistrySecurityEnumerated(HKEY hKey,
                              PSECURITY_DESCRIPTOR pSD,
                              DWORD dwAction);

BOOL 
MungeMasterKey(HKEY hKey);


BOOL
GetUserTextualSid(IN  OUT LPWSTR  lpBuffer,
                  IN  OUT LPDWORD nSize,
                  IN      HANDLE  hToken);  


BOOL
GetTextualSid(
    IN      PSID    pSid,        
    IN  OUT LPWSTR  TextualSid,  
    IN  OUT LPDWORD dwBufferLen);
    

BOOL
GetTextualSid(IN      PSID    pSid,         
              IN  OUT LPWSTR  TextualSid,  
              IN  OUT LPDWORD dwBufferLen);

BOOL
GetTokenUserSid(IN      HANDLE  hToken,     
                IN  OUT PSID    *ppUserSid);



BOOL
HoseFileMk(DATA_BLOB Blob);

LPWSTR
GetMK(DATA_BLOB blob,
      LPWSTR    wszPath);


DWORD
MyGuidToStringW(const GUID* pguid, WCHAR rgsz[]);

LPWSTR
GetFilePath();

void
MungeFile(LPBYTE pData);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\pmacros.h ===
#include "pstdef.h"

// count the number of bytes needed to fully store the WSZ
#define WSZ_BYTECOUNT(__z__)   \
    ( (__z__ == NULL) ? 0 : (wcslen(__z__)+1)*sizeof(WCHAR) )

// count the number of elements in the static array
#define ARRAY_COUNT(__z__)     \
    ( (__z__ == NULL) ? 0 : (sizeof( __z__ ) / sizeof( __z__[0] )) )


// if in range of PST_E errors, pass through unmodified
// otherwise, convert HRESULT to a Win32 error
#define PSTERR_TO_HRESULT(__z__)    \
    ( ((__z__ >= MIN_PST_ERROR) && (__z__ <= MAX_PST_ERROR)) ? __z__ : HRESULT_FROM_WIN32(__z__) )

#define HRESULT_TO_PSTERR(__z__)    \
    ( ((__z__ >= MIN_PST_ERROR) && (__z__ <= MAX_PST_ERROR)) ? __z__ : HRESULT_CODE(__z__) )


// map exceptions to win32 errors (used internally)
#define  PSTMAP_EXCEPTION_TO_ERROR(__x__) \
    ((__x__ == 0xC0000005) ? 998 : PST_E_UNKNOWN_EXCEPTION)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\loggit.h ===
#ifndef _LOGGIT_H_
#define _LOGGIT_H_


#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include "debug.h"  


#define FAIL(buff)	printf(buff)
#define BVT_OUT_DIR	"\\\\pkstest\\bvtout"
#define BVT_DIR		"c:\\bvtdir"


//
// Logging functions for automation
//
BOOL LogFinish(DWORD dwErr, LPSTR szTestName);
BOOL LogInit(LPSTR szTestName);
BOOL WriteHeaderInfo();
BOOL Error(LPSTR szMessage, DWORD ErrorCode);
BOOL Comment(LPSTR szMessage);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\rules.h ===
#ifndef __RULES_H__
#define __RULES_H__

//
// externally provides allocation/free services.
//

LPVOID
RulesAlloc(
    IN      DWORD cb
    );

VOID
RulesFree(
    IN      LPVOID pv
    );

// get the length of the entire rules structure
BOOL
GetLengthOfRuleset(
    IN PPST_ACCESSRULESET pRules,
    OUT DWORD *pcbRules
    );

// set up the rules to be output
BOOL
MyCopyOfRuleset(
    IN PPST_ACCESSRULESET pRulesIn,
    OUT PPST_ACCESSRULESET pRulesOut
    );

BOOL
RulesRelativeToAbsolute(
    IN PPST_ACCESSRULESET pRules
    );

BOOL
RulesAbsoluteToRelative(
    IN PPST_ACCESSRULESET NewRules
    );

// free allocated clause data in relative format
void
FreeClauseDataRelative(
    IN PPST_ACCESSRULESET NewRules
    );

#endif // __RULES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by script1.rc
//
#define IDS_PASSWORD_CREATE_MESSAGE     1
#define IDS_PASSWORD_NOMATCH            2
#define IDS_PASSWORD_CHANGE_MESSAGE     5
#define IDS_PASSWORD_MUSTNAME           7
#define IDS_PASSWORD_SOLICIT_OLD_MESSAGE 8
#define IDS_PASSWORD_DUPLICATE          9
#define IDS_PASSWORD_ADD_ERROR          10
#define IDS_PASSWORD_ERROR_DLGTITLE     11
#define IDS_PROMPT_READITEM             12
#define IDS_PROMPT_WRITEITEM            13
#define IDS_PROMPT_DELETEITEM           14
#define IDS_PASSWORD_CHANGE_ERROR       15
#define IDS_PW_PROMPT                   18
#define IDS_PASSWORD_PROMPT_PREFIX      18
#define IDS_PASSWORD_PROMPT_SUFFIX      19
#define IDS_PASSWORD_BANNER             23
#define IDS_ITEM_DETAILS_BANNER         23
#define IDS_PROMPT_OPENITEM             24
#define IDS_WIN95_PASSWORDS_AREGARBAGE  25
#define IDS_SIMPLIFIED_DLG_MSG          26
#define IDS_PROMPT_HIGH_SECURITY        40
#define IDS_PROMPT_MED_SECURITY         41
#define IDS_PROMPT_LOW_SECURITY         42
#define IDS_GET_WINDOWS_PASSWORD_95     51
#define IDS_GET_WINDOWS_PASSWORD_NT     52
#define IDS_PASSWORD_NOVERIFY           53
#define IDS_PASSWORD_WIN_NOVERIFY       54
#define IDS_PASSWORD_CHANGE_REQ         55
#define IDS_TITLE_CONTAINER_MAPPING     56
#define IDS_WINDOWS_NT_SECURITY_ALERT   57
#define IDI_ICON1                       104
#define IDD_SecDetail                   104
#define IDD_SIMPLIFIED_PASSWD           105
#define IDD_PASSWORD_SOLICIT_OLD        106
#define IDD_SecWiz1                     107
#define IDD_PASSWORD_SOLICIT            108
#define IDD_ADVANCED_CONFIRM            109
#define IDD_ITEM_DETAILS                110
#define IDD_PASSWORD_CREATE             111
#define IDD_PASSWORD_CHANGE             114
#define IDD_GET_WINDOWS_PASSWORD        115
#define IDC_MAIN_CAPTION                120
#define IDC_MAIN_CAPTION2               122
#define IDC_MAIN_CAPTION3               123
#define IDC_MAIN_CAPTION4               124
#define IDC_PASSWORD_LABEL              124
#define IDB_BITMAP_BLANK                125
#define IDC_PASSWORD_LABEL2             125
#define IDC_MAIN_CAPTION5               125
#define IDC_PASSWORD_LABEL3             126
#define IDC_PASSWORD_LABEL4             127
#define IDD_SecPass_WinNT               127
#define IDC_PASSWORD_LABEL5             128
#define IDB_BITMAP_LOCKKEY              129
#define IDD_SIMPLIFIED_PASSWORD         131
#define IDD_SecAddMed2                  133
#define IDD_SecPass_Win95               134
#define IDD_SecWiz2a                    135
#define IDD_ADVANCED_CONFIRM_H          135
#define IDB_BITMAP_ALERT                136
#define IDD_SecWiz2b                    137
#define IDD_ADVANCED_CONFIRM_M          137
#define IDD_SecWiz2c                    138
#define IDD_ADVANCED_CONFIRM_L          138
#define IDR_PSTORE_SERVER               666
#define IDR_PSTORE_PROVIDER             777
#define IDC_EDIT1                       1000
#define IDC_EDIT2                       1001
#define IDC_BUTTON2                     1002
#define IDC_MESSAGE                     1003
#define IDC_BUTTON3                     1003
#define IDC_BUTTON5                     1004
#define IDC_MESSAGE2                    1005
#define IDC_ACCESS_TYPE                 1006
#define IDC_ITEM_NAME                   1007
#define IDC_ITEM_TYPE                   1008
#define IDC_APP_MSG                     1009
#define IDC_RADIO1                      1009
#define IDC_RADIO_SELEXISTING           1009
#define IDC_EDIT0                       1010
#define IDC_RADIO2                      1010
#define IDC_RADIO_DEFINENEW             1010
#define IDC_RADIO3                      1011
#define IDC_APP_NAME                    1012
#define IDC_COMBO1                      1012
#define IDC_APP_PATH                    1013
#define IDC_COMBO2                      1013
#define IDC_LABEL_EDIT1                 1014
#define IDC_RADIO_WINPW                 1015
#define IDC_RADIO_NOCONFIRM             1015
#define IDC_LABEL_EDIT2                 1015
#define IDC_COMBO3                      1015
#define IDC_RADIO_ASSIGNPW              1016
#define IDC_COMBO4                      1016
#define IDC_RADIO_OKCANCEL              1017
#define IDC_MYICON                      1019
#define IDC_NEW_PW_BUTTON               1020
#define IDC_ICONBOX                     1021
#define IDC_ADVANCED                    1022
#define IDC_PW_MESSAGE                  1023
#define IDC_CACHEPW                     1024
#define IDC_ST_NEWPW                    1025
#define IDC_SEC_LEVEL                   1026
#define IDC_BUTTON1                     1027
#define IDC_MYTXT                       1028
#define IDC_APPTXT                      1029
#define IDC_EDIT_PASSWD                 1030
#define IDC_PASSWD_NAME                 1031
#define IDC_CHECK_NOASK                 1032
#define IDC_CHANGE_SECURITY             1033
#define IDC_CHANGE_SECURITY2            1034
#define IDC_BACK                        1037
#define IDC_NEXT                        1038
#define IDC_PW_NAME                     1038
#define IDC_PW_NEWNAME                  1039
#define IDC_EDIT1_LABEL                 1040
#define IDC_EDIT2_LABEL                 1041
#define DLG_UPDATE_DATA                 1500
#define OLD_IDD_GET_WINDOWS_PASSWORD    2000
#define OLD_IDD_SIMPLIFIED_PASSWD       2001
#define OLD_IDD_ITEM_DETAILS            2002
#define OLD_IDD_ADVANCED_CONFIRM        2003
#define IDC_STATIC1                     34465
#define IDC_STATIC2                     34466
#define IDC_STATIC3                     34467
#define IDC_STATIC4                     34468
#define IDC_STATIC5                     34469
#define IDC_STATIC6                     34470
#define IDC_STATIC7                     34471
#define IDC_STATIC8                     34472
#define IDC_STATIC9                     34473
#define IDC_SEC_PREFIX                  65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1042
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\listbase.h ===
#ifndef __LISTBASE_H__
#define __LISTBASE_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <sha.h>



// minimal elt data structure
typedef struct _ELT
{
    struct _ELT* pNext;
} ELT;


typedef
BOOL    FISMATCH(ELT* pCandidate, ELT* pTemplate);

typedef
void    FREEELT(ELT* pElt);


class CLinkedList
{
public:
    CLinkedList();
    ~CLinkedList();


    BOOL Initialize();
    BOOL Reset();

private:
    ELT*                m_pHead;
public:
    BOOL                m_fInitialized;
    CRITICAL_SECTION    m_critsecListBusy;
    FISMATCH*           m_pfnIsMatch;
    FREEELT*            m_pfnFreeElt;

public:
    BOOL                AddToList(ELT*);
    BOOL                DelFromList(ELT*);
    ELT*                SearchList(ELT*);

    BOOL                LockList();
    BOOL                UnlockList();

    ELT*                GetHead()
        {   return m_pHead;   }

};

#ifdef __cplusplus
}       // extern "C" {
#endif

#endif // __LISTBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\provif.h ===
// Provider interface header file
//
// all secure provider calls are prefixed by "SP" 
// providers must implement all of these interfaces!
//

#ifdef __cplusplus
extern "C"{
#endif 

// note: we typedef here because it is convenient and needed for 
// filling struct by GetProcAddress() later. After defining the types, 
// we simply instantiate the actual call as an implementation of that type.


// load notification, register callbacks
typedef
HRESULT        SPPROVIDERINITIALIZE(
                DISPIF_CALLBACKS *psCallbacks);

SPPROVIDERINITIALIZE SPProviderInitialize;


// Acquire Context notification
typedef 
HRESULT        SPACQUIRECONTEXT(
                PST_PROVIDER_HANDLE* phPSTProv,
                DWORD           dwFlags);

SPACQUIRECONTEXT SPAcquireContext;


// Release Context notification
typedef 
HRESULT        SPRELEASECONTEXT(
                PST_PROVIDER_HANDLE* phPSTProv,
                DWORD           dwFlags);

SPRELEASECONTEXT SPReleaseContext;


// GetProvInfo
typedef 
HRESULT        SPGETPROVINFO(
    /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppPSTInfo,
    /* [in] */  DWORD dwFlags);

SPGETPROVINFO SPGetProvInfo;


// GetProvParam
typedef
HRESULT     SPGETPROVPARAM(
    /* [in] */  PST_PROVIDER_HANDLE* phPSTProv,
    /* [in] */  DWORD           dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ 
                BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */  DWORD           dwFlags);

SPGETPROVPARAM SPGetProvParam;

// SetProvParam
typedef
HRESULT     SPSETPROVPARAM(
    /* [in] */  PST_PROVIDER_HANDLE* phPSTProv,
    /* [in] */  DWORD           dwParam,
    /* [in] */  DWORD           cbData,
    /* [in] */  BYTE*           pbData,
    /* [in] */  DWORD           dwFlags);

SPSETPROVPARAM SPSetProvParam;


// EnumTypes
typedef 
HRESULT        SPENUMTYPES(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [out] */ GUID *pguidType,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwFlags);

SPENUMTYPES SPEnumTypes;

// GetTypeInfo
typedef
HRESULT         SPGETTYPEINFO( 
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ PPST_TYPEINFO *ppinfoType,
    /* [in] */ DWORD dwFlags);

SPGETTYPEINFO SPGetTypeInfo;

// EnumSubtypes
typedef 
HRESULT        SPENUMSUBTYPES(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [out] */ GUID *pguidSubtype,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwFlags);

SPENUMSUBTYPES SPEnumSubtypes;


// GetSubtypeInfo
typedef
HRESULT         SPGETSUBTYPEINFO( 
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ PPST_TYPEINFO *ppinfoSubtype,
    /* [in] */ DWORD dwFlags);

SPGETSUBTYPEINFO SPGetSubtypeInfo;

// EnumItems
typedef
HRESULT        SPENUMITEMS(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [out] */ LPWSTR *ppszItemName,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwFlags);

SPENUMITEMS SPEnumItems;

// CreateType
typedef
HRESULT        SPCREATETYPE(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ PPST_TYPEINFO pinfoType,
    /* [in] */ DWORD dwFlags);

SPCREATETYPE SPCreateType;

// DeleteType
typedef
HRESULT SPDELETETYPE( 
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ DWORD dwFlags);

SPDELETETYPE SPDeleteType;

// CreateSubtype
typedef
HRESULT        SPCREATESUBTYPE(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ PPST_TYPEINFO pinfoSubtype,
    /* [in] */ PPST_ACCESSRULESET psRules,
    /* [in] */ DWORD dwFlags);

SPCREATESUBTYPE SPCreateSubtype;


// DeleteSubtype
typedef
HRESULT SPDELETESUBTYPE( 
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [in] */ DWORD dwFlags);

SPDELETESUBTYPE SPDeleteSubtype;

// WriteItem
typedef
HRESULT        SPWRITEITEM(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID  *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE *pbData,
    /* [in] */ PPST_PROMPTINFO psPrompt,
    /* [in] */ DWORD dwDefaultConfirmationStyle,
    /* [in] */ DWORD dwFlags);
    
SPWRITEITEM SPWriteItem;

// ReadItem
typedef
HRESULT		SPREADITEM(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [out] */ DWORD *pcbData,
    /* [size_is][size_is][out] */ BYTE **ppbData,
    /* [in] */ PPST_PROMPTINFO psPrompt,
    /* [in] */ DWORD dwFlags);

SPREADITEM SPReadItem;

// OpenItem
typedef 
HRESULT SPOPENITEM( 
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwModeFlags,
    /* [in] */ PPST_PROMPTINFO psPrompt,
    /* [in] */ DWORD dwFlags);

// CloseItem
typedef
HRESULT SPCLOSEITEM( 
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwFlags);

// DeleteItem
typedef
HRESULT		SPDELETEITEM(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PPST_PROMPTINFO psPrompt,
    /* [in] */ DWORD dwFlags);

SPDELETEITEM SPDeleteItem;


// ReadAccessRuleset
typedef 
HRESULT        SPREADACCESSRULESET( 
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [out] */ PPST_ACCESSRULESET *ppsRules,
    /* [in] */ DWORD dwFlags);

SPREADACCESSRULESET SPReadAccessRuleset;

// WriteAccessRuleset
typedef
HRESULT SPWRITEACCESSRULESET( 
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ PPST_ACCESSRULESET psRules,
    /* [in] */ DWORD dwFlags);

SPWRITEACCESSRULESET SPWriteAccessRuleset;
                                      

////////////////////////////////////////////////////
// side door interfaces: dispatcher/provider only

// PasswordChangeNotify
typedef
BOOL FPASSWORDCHANGENOTIFY(
    /* [in] */  LPWSTR  szUser,
    /* [in] */  LPWSTR  szPasswordName,
    /* [in] */  BYTE    rgbOldPwd[],
    /* [in] */  DWORD   cbOldPwd,
    /* [in] */  BYTE    rgbNewPwd[],
    /* [in] */  DWORD   cbNewPwd);

FPASSWORDCHANGENOTIFY FPasswordChangeNotify;


#ifdef __cplusplus
}   // extern C
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\primitiv.h ===
typedef struct _DESKey
{
    BYTE        rgbKey[DES_BLOCKLEN];
    DESTable    sKeyTable;
} DESKEY, *PDESKEY;


// assumes pbKeyMaterial is at least DES_BLOCKLEN bytes
BOOL FMyMakeDESKey(
            PDESKEY     pDESKey,            // out 
            BYTE*       pbKeyMaterial);     // in

BOOL FMyPrimitiveSHA(
			PBYTE       pbData,             // in
			DWORD       cbData,             // in
            BYTE        rgbHash[A_SHA_DIGEST_LEN]); // out


BOOL FMyPrimitiveDESDecrypt(
            PBYTE       pbBlock,            // in out
            DWORD       *pcbBlock,          // in out
            DESKEY      sDESKey);           // in

BOOL FMyPrimitiveDESEncrypt(
            PBYTE*      ppbBlock,           // in out
            DWORD*      pcbBlock,           // in out
            DESKEY      sDESKey);           // in


BOOL FMyPrimitiveDeriveKey(
			PBYTE       pbSalt,             // in
			DWORD       cbSalt,             // in
            PBYTE       pbOtherData,        // in [optional]
            DWORD       cbOtherData,        // in
            DESKEY*     pDesKey);           // out 


BOOL FMyOldPrimitiveHMAC(
            DESKEY      sMacKey,            // in
            PBYTE       pbData,             // in
            DWORD       cbData,             // in
            BYTE        rgbHMAC[A_SHA_DIGEST_LEN]); // out

BOOL FMyPrimitiveHMAC(
            DESKEY      sMacKey,            // in
            PBYTE       pbData,             // in
            DWORD       cbData,             // in
            BYTE        rgbHMAC[A_SHA_DIGEST_LEN]); // out

BOOL FMyPrimitiveHMACParam(
            PBYTE       pbKeyMaterial,      // in
            DWORD       cbKeyMaterial,      // in
            PBYTE       pbData,             // in
            DWORD       cbData,             // in
            BYTE        rgbHMAC[A_SHA_DIGEST_LEN]);  // out


#define PBKDF2_MAX_SALT_SIZE (16)

BOOL PKCS5DervivePBKDF2(
        PBYTE       pbKeyMaterial,
        DWORD       cbKeyMaterial,
        PBYTE       pbSalt,
        DWORD       cbSalt,
        DWORD       KeyGenAlg,
        DWORD       cIterationCount,
        DWORD       iBlockIndex,
        BYTE        rgbPKCS5Key[A_SHA_DIGEST_LEN]  // output buffer
        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\secmisc.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    secmisc.h

Abstract:

    This module contains miscellaneous security routines for the Protected
    Storage.


Author:

    Scott Field (sfield)    25-Mar-97

--*/

#ifndef __SECMISC_H__
#define __SECMISC_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Textual Sids of interesting accounts on WinNT
//

#define TEXTUAL_SID_LOCAL_SYSTEM    L"S-1-5-18"


BOOL
GetUserHKEYEx(
    IN      LPCWSTR szUser,
    IN      DWORD   dwDesiredAccess,
    IN  OUT HKEY    *hKeyUser,
    IN      BOOL    fCheckDefault       // check .Default registry hive ?
    );

BOOL
GetUserHKEY(
    IN      LPCWSTR szUser,
    IN      DWORD   dwDesiredAccess,
    IN  OUT HKEY    *hKeyUser
    );

BOOL
GetUserTextualSid(
    IN      HANDLE  hUserToken,     // optional
    IN  OUT LPWSTR  lpBuffer,
    IN  OUT LPDWORD nSize
    );

BOOL
GetTextualSid(
    IN      PSID    pSid,          // binary Sid
    IN  OUT LPWSTR  TextualSid,  // buffer for Textual representaion of Sid
    IN  OUT LPDWORD dwBufferLen // required/provided TextualSid buffersize
    );

BOOL
GetThreadAuthenticationId(
    IN      HANDLE  hThread,
    IN  OUT PLUID   AuthenticationId
    );

BOOL
GetTokenAuthenticationId(
    IN      HANDLE  hToken,
    IN  OUT PLUID   AuthenticationId
    );

BOOL
GetTokenUserSid(
    IN      HANDLE  hToken,     // token to query
    IN  OUT PSID    *ppUserSid  // resultant user sid
    );

BOOL
SetRegistrySecurity(
    IN      HKEY    hKey
    );

BOOL
SetPrivilege(
    HANDLE hToken,          // token handle
    LPCWSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    );

BOOL
SetCurrentPrivilege(
    LPCWSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    );

BOOL
IsAdministrator(
    VOID
    );

BOOL
IsLocal(
    VOID
    );

BOOL
IsDelegating(
    IN      HANDLE hToken   // token to query, open for at least TOKEN_QUERY access
    );

BOOL
IsUserSidInDomain(
    IN      PSID pSidDomain,    // domain Sid
    IN      PSID pSidUser       // user Sid
    );

BOOL
IsDomainController(
    VOID
    );

LONG
SecureRegDeleteValueU(
    IN      HKEY hKey,          // handle of key
    IN      LPCWSTR lpValueName // address of value name
    );

#ifdef __cplusplus
}
#endif


#endif // __SECMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\service.h ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: service.h
//
//  AUTHOR: Craig Link
//
//
//  Comments:  The use of this header file and the accompanying service.c
//  file simplifies the process of writting a service.  You as a developer
//  simply need to follow the TODO's outlined in this header file, and 
//  implement the ServiceStart() and ServiceStop() functions.
//  
//  There is no need to modify the code in service.c.  Just add service.c
//  to your project and link with the following libraries...
//
//  libcmt.lib kernel32.lib advapi.lib shell32.lib
//
//  This code also supports unicode.  Be sure to compile both service.c and
//  and code #include "service.h" with the same Unicode setting.
//
//  Upon completion, your code will have the following command line interface
//
//  <service exe> -?                to display this list
//  <service exe> -install          to install the service
//  <service exe> -remove           to remove the service
//  <service exe> -debug <params>   to run as a console app for debugging
//
//  Note: This code also implements Ctrl+C and Ctrl+Break handlers
//        when using the debug option.  These console events cause
//        your ServiceStop routine to be called
//
//        Also, this code only handles the OWN_SERVICE service type
//        running in the LOCAL_SYSTEM security context.
//
//        To control your service ( start, stop, etc ) you may use the
//        Services control panel applet or the NET.EXE program.
//
//        To aid in writing/debugging service, the
//        SDK contains a utility (MSTOOLS\BIN\SC.EXE) that
//        can be used to control, configure, or obtain service status.
//        SC displays complete status for any service/driver
//        in the service database, and allows any of the configuration
//        parameters to be easily changed at the command line.
//        For more information on SC.EXE, type SC at the command line.
//

#ifndef _SERVICE_H
#define _SERVICE_H


#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////////////////
//// todo: change to desired strings
////
// name of the executable
#define SZAPPNAME            L"pstores"
// internal name of the service
#define SZSERVICENAME        L"ProtectedStorage"
// displayed name of the service
#define SZSERVICEDISPLAYNAME L"Protected Storage"
#define SZSERVICEDISPLAYNAMEA "Protected Storage"
// list of service dependencies - "dep1\0dep2\0\0"
// RPC must be running for us to work!
#define SZDEPENDENCIES       L"RpcSs\0" // doubly null terminated
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// todo: ServiceStart()must be defined by in your code.
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
DWORD ServiceStart (HINSTANCE hInstance, int nCmdShow);
VOID ServiceStop();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success 
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);


//
//  FUNCTION: AddToMessageLog(LPWSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
void AddToMessageLog(LPWSTR lpszMsg);
//////////////////////////////////////////////////////////////////////////////

void StopRPCServer();


// entry point to start the service from install stub.

DWORD WINAPI Start( LPVOID lpV );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\migrate.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    migrate.h

Abstract:

    This module contains routines to support migration of protected storage
    data from beta1 to beta2.

    Hopefully this code will be pitched after beta2, prior to final release.

Author:

    Scott Field (sfield)    15-Apr-97

--*/

#ifndef __MIGRATE_H__
#define __MIGRATE_H__

BOOL
MigrateData(
    PST_PROVIDER_HANDLE *phPSTProv,
    BOOL                fMigrationNeeded
    );

#endif // __MIGRATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\testu.h ===
#ifndef _TEST_U_H_
#define _TEST_U_H_


//	Header File for Test Utilites
//  For use with console applications

//	Created by:  Todd Stecher

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <windows.h>
#include <wtypes.h>
#include <olectl.h>
#include <objbase.h>
#include "pstore.h"
#include <winnt.h>
#include "unicode.h"
#include <process.h>
#include "loggit.h"

// Security Descriptor Types...
#define SD_GUEST	1
#define SD_USER		2
#define SD_ADMIN	3


#define MEM_START					5
#define MEM_END						6
#define MEM_TEST_START				7
#define MEM_TEST_END				8

#define LOAD_FAILED					11
#define GENERIC_FAIL				666


#define WND_CLASS_NAME				"#32770"
#define WND_TITLE                   "Protected Storage Alert"
#define WND_TITLE_U					L"Protected Storage Alert"
#define MAX_STRING					256
#define STRESS_STRING				2028
#define REG_SACTREE_LOC             L"SOFTWARE\\Microsoft\\Protected Storage System Provider"

#define STR_TYPE					1
#define STR_ITEM					2
#define STR_STYP					3
#define STR_NORM					4


#define MAX_RULES					5
#define MAX_CLAUSES					5
#define NUM_CLAUSES					6

// UI Hooking defines
#define UI_NEW_PSWD					666
#define UI_PRESENT_CHECK			667
#define UI_TEST_PSWD				668
#define UI_ENTER_PSWD				669
#define UI_OK_CANCEL				670


#define TEST_PASSWORD				"test"
#define TEST_PASSWORD_NAME			"test"

#define PS_ITEM						700
#define PS_CHOOSE_PW				701
#define PS_NEW_PW					702
#define PS_OK_CANCEL				703
#define PS_DETAILS					704

//	Several of these are reused, so be careful...
#define IDC_EDIT1					1000
#define IDC_EDIT2                   1001
#define IDC_RADIO_ASSIGNPW			1016
#define IDC_PW_NAME					1005
#define IDC_NEW_PW_BUTTON			1020
#define IDC_ADVANCED                1022
#define IDC_CHANGE_SECURITY         1033





//LPWSTR ClauseToString(PST_ACCESSCLAUSE rgClause);
BOOL NewGenString(LPWSTR * szStr, DWORD dwSize);
BOOL GenerateString(LPWSTR * szString, UINT NameLength, UINT uType);
BOOL CompareSACProviderInfo(PST_PROVIDERINFO SPI1, PST_PROVIDERINFO SPI2);
BOOL CompareAccessRuleset(PST_ACCESSRULESET *pR1, PST_ACCESSRULESET *pR2);
BOOL CompareUUIDS(GUID * pGuid1, GUID * pGuid2);
BOOL CompareData(BYTE * D1, DWORD cbD1, BYTE * D2, DWORD cbD2);
WCHAR RandomCharacter(DWORD seed);
BOOL GenerateByteData(BYTE ** pbData, DWORD size);
BOOL GenerateSequentialString(LPWSTR * szString, DWORD Type, DWORD x);
BOOL CompareTypeInfo(PST_TYPEINFO G1, PST_TYPEINFO G2);
void ChangeData2(USHORT * D2);
DWORD PStoreProviderSetup(IPStore ** ppIProv);
DWORD MemCheckIni();
DWORD MemCheckFree();
DWORD GetMemory(DWORD dwFlags, LPSTR szProcessName);
BOOL CreateTestSecurityDescriptor(SECURITY_DESCRIPTOR * psd, DWORD dwSDType);
PST_ACCESSRULESET * SetRules(DWORD TypeNum, DWORD SubTypeNum, LPWSTR szExeName, LPWSTR szModName);
BOOL FreeRules(PST_ACCESSRULESET * sRules);


//Quick Functions
DWORD 
QCreateType(IPStore * pISecProv, PST_KEY Key, GUID * pType, PST_TYPEINFO * pTypeInfo, DWORD dwFlags);

DWORD 
QCreateSubType(IPStore * pISecProv, PST_KEY Key, GUID * pType, GUID * pSubType, PST_TYPEINFO * pSubTypeInfo, PST_ACCESSRULESET * pRules, DWORD dwFlags);

DWORD
QDeleteType(IPStore * pISecProv, PST_KEY Key, GUID * pType, DWORD dwFlags);

DWORD
QDeleteSubtype(IPStore * pISecProv, PST_KEY Key, GUID * pType, GUID * pSubType, DWORD dwFlags);

// UI Hooking functions
UINT
WINAPI UIEnterPswd(LPVOID lpvThreadParam);

UINT
WINAPI UIAddPswd(LPVOID lpvThreadParam);

UINT
WINAPI UIPresent(LPVOID lpvThreadParam);

HANDLE InitUIHook(DWORD dwFlags);
DWORD KillThread(HANDLE hThread);
HWND MyFindWindow(DWORD dwWinFlag);
HWND CheckPStoreWindowType(DWORD dwWinFlag);
BOOL SelectTestPassword(HWND hDlg);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\misc.h ===
void MyToUpper(LPWSTR wsrc);

BOOL FStringIsValidItemName(LPCWSTR szTrialString);

// allocing wrapper for g_Callback->FGetUser
BOOL FGetCurrentUser(
    PST_PROVIDER_HANDLE* phPSTProv,
    LPWSTR* ppszUser,
    PST_KEY Key);


// GET registry wrapper
DWORD RegGetValue(
    HKEY hItemKey,
    LPWSTR szItem,
    PBYTE* ppb,
    DWORD* pcb);

#if 0
void FreeRuleset(
    PST_ACCESSRULESET *psRules
    );
#endif

BOOL
GetFileDescription(
    LPCWSTR szFile,
    LPWSTR *FileDescription // on success, allocated description
    );


BOOL FIsCachedPassword(
    LPCWSTR szUser,
    LPCWSTR szPassword,
    LUID*   pluidAuthID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\misc.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    misc.cpp

Abstract:

    Functionality in this module:

        GetCurrentUser allocating wrapper
        RegQueryValueEx allocating wrapper
        Rule free logic
        pulling the file description from file

Author:

    Matt Thomlinson (mattt) 22-Oct-96
    Scott Field (sfield)    01-Jan-97

--*/


#include <pch.cpp>
#pragma hdrstop


extern DISPIF_CALLBACKS         g_sCallbacks;

//
// Registry Setable Globals, and handlign goo
//

// Must access key via api's
static HKEY g_hProtectedStorageKey = NULL;

static HANDLE g_hProtectedStorageChangeEvent = NULL;

static CRITICAL_SECTION g_csGlobals;

static BOOL g_fcsGlobalsInitialized = FALSE;





// supply a new, delete operator
void * __cdecl operator new(size_t cb)
{
    return SSAlloc( cb );
}

void __cdecl operator delete(void * pv)
{
    SSFree( pv );
}


BOOL FGetCurrentUser(
    PST_PROVIDER_HANDLE* phPSTProv,
    LPWSTR* ppszUser,
    PST_KEY Key)
{
    BOOL fRet = FALSE;

    if (Key == PST_KEY_LOCAL_MACHINE)
    {
        *ppszUser = (LPWSTR)SSAlloc(sizeof(WSZ_LOCAL_MACHINE));
        if( *ppszUser == NULL )
        {
            return FALSE;
        }

        wcscpy(*ppszUser, WSZ_LOCAL_MACHINE);
    }
    else
    {
        // get current user
        if (!g_sCallbacks.pfnFGetUser(
                phPSTProv,
                ppszUser))
            goto Ret;
    }

    fRet = TRUE;
Ret:
    return fRet;
}


BOOL FStringIsValidItemName(LPCWSTR szTrialString)
{
    // local define
    #define WCH_INVALID_CHAR1 L'\\'

    while(  *szTrialString &&
            (*szTrialString != WCH_INVALID_CHAR1)          )
        szTrialString++;

    // valid=TRUE if we're at the end of the string
    return (*szTrialString == L'\0');
}

// get registry wrapper
DWORD RegGetValue(HKEY hItemKey,
                 LPWSTR szItem,
                 PBYTE* ppb,
                 DWORD* pcb)
{
    // local define
    #define FASTBUFSIZE 64
/*
FASTBUFSIZE from purely empirical testing (2 tpstorec.exe, 1 perform.exe)
    bytes       num requests

    16          1437
    18          22
    20          928
    22          18
    24          2
    32          9
    40          106
    42          700
    48          500
    56          928
    64          718
->
    72          100
    256         500

set cache size at 64. (mattt, 2/3/97)
*/

    DWORD dwRet;
    DWORD dwType;

    BYTE rgbFastBuf[FASTBUFSIZE];   // try using a static buffer

    BOOL fAllocated = FALSE;
    *pcb = FASTBUFSIZE;

    dwRet =
        RegQueryValueExU(
            hItemKey,
            szItem,
            0,
            &dwType,
            rgbFastBuf,
            pcb);

#ifdef DBG
/*
    CHAR szDebugString[40];
    CHAR* psz;
    if (dwRet == ERROR_MORE_DATA)
        psz = "Miss:\t";
    else
        psz = "";
    wsprintfA(szDebugString, "%sRegGetVal Fastbuf %d bytes\n", psz, *pcb);
    OutputDebugStringA((LPSTR)szDebugString);
*/
#endif

    if (dwRet == ERROR_SUCCESS)
    {
        // fastbuf was large enough
        *ppb = (PBYTE)SSAlloc(*pcb);
        if(*ppb == NULL)
        {
            dwRet = (DWORD)PST_E_FAIL;
            goto Ret;
        }

        CopyMemory(*ppb, rgbFastBuf, *pcb);
    }
    else if (dwRet == ERROR_MORE_DATA)
    {
        // didn't fit into fastbuf -- alloc exact size, query
        *ppb = (PBYTE)SSAlloc(*pcb);
        if(*ppb == NULL)
        {
            dwRet = (DWORD)PST_E_FAIL;
            goto Ret;
        }

        fAllocated = TRUE;

        if (ERROR_SUCCESS != (dwRet =
            RegQueryValueExU(
                hItemKey,
                szItem,
                0,
                &dwType,
                *ppb,
                pcb)) )
            goto Ret;
    }
    else
        goto Ret;


    dwRet = PST_E_OK;
Ret:

    if( dwRet != PST_E_OK && fAllocated ) {
        SSFree( *ppb );
        *ppb = NULL;
    }

    return dwRet;
}



#if 0

void FreeRuleset(
        PST_ACCESSRULESET *psRules)
{
    PST_ACCESSCLAUSE* pClause;

    if (psRules == NULL)
        return;

    for (DWORD cRule=0; cRule<psRules->cRules; cRule++)
    {
        // for each Rule in Ruleset, walk all clauses and free assoc pb
        for (DWORD cClause=0; cClause<psRules->rgRules[cRule].cClauses; cClause++)
        {
            pClause = &psRules->rgRules[cRule].rgClauses[cClause];

            if (NULL != pClause->pbClauseData)
                SSFree(pClause->pbClauseData);
        }

        // now free rgClause
        SSFree(psRules->rgRules[cRule].rgClauses);
    }

    // now free rgRules
    SSFree(psRules->rgRules);
}

#endif

BOOL
GetFileDescription(
    LPCWSTR szFile,
    LPWSTR *FileDescription
    )
/*++

Routine Description:

    This function obtains the localized version resource, file description
    string from a specified file.  The input and output parameters are
    both Unicode, and as a result, this requires some "thunking" magic
    for Win95.

Arguments:

    szFile - Pointer to file name (full path if appropriate) to obtain
        the localized file description string from.

    FileDescription - Returns a pointer to an allocated, localized file
        description string associated with the specified file.

Return Value:

    TRUE - success.  Caller must free buffer specified by the FileDescription
        parameter.
    FALSE - error.

Author:

    Scott Field (sfield)    02-Jan-97

--*/
{

    LPCVOID FileName;
    CHAR FileNameA[MAX_PATH];

    DWORD dwVerInfoSize;
    DWORD dwHandle;
    LPVOID VerInfo;

    LPVOID lpBuffer;
    UINT puLen;

    DWORD dwLanguageId;

    LPVOID Trans;
    LPVOID StringFileInfo;
    LPVOID Language;

    CHAR StringFileInfoA[] = "\\StringFileInfo\\%04X%04X\\FileDescription";
    WCHAR StringFileInfoW[] = L"\\StringFileInfo\\%04X%04X\\FileDescription";

    CHAR LanguageA[sizeof(StringFileInfoA)/sizeof(CHAR)];
    WCHAR LanguageW[sizeof(StringFileInfoW)/sizeof(WCHAR)];

    LANGID LangDefault;
    BOOL bSuccess = FALSE;

    typedef BOOL (WINAPI GETFILEVERSIONINFOSIZE)(LPCVOID, LPDWORD);
    typedef BOOL (WINAPI GETFILEVERSIONINFO)(LPCVOID, DWORD, DWORD, LPVOID);
    typedef int (cdecl WSPRINTF)(LPVOID, LPVOID, ...);
    typedef BOOL (WINAPI VERQUERYVALUE)(LPVOID, LPVOID, LPVOID *, PUINT);

    GETFILEVERSIONINFOSIZE *_GetFileVersionInfoSize;
    GETFILEVERSIONINFO *_GetFileVersionInfo;
    WSPRINTF *_wsprintf;
    VERQUERYVALUE *_VerQueryValue;

    static BOOL fLoadedVersionDll = FALSE;
    static FARPROC _GetFileVersionInfoSizeW;
    static FARPROC _GetFileVersionInfoW;
    static FARPROC _VerQueryValueW;
    static FARPROC _GetFileVersionInfoSizeA;
    static FARPROC _GetFileVersionInfoA;
    static FARPROC _VerQueryValueA;


    *FileDescription = NULL;

    if( !fLoadedVersionDll ) {
        HMODULE hVersionDll = LoadLibraryU(L"version.dll");

        if( hVersionDll == NULL )
            return FALSE;

        if(FIsWinNT()) {

            _GetFileVersionInfoSizeW = GetProcAddress(hVersionDll, "GetFileVersionInfoSizeW");
            if(_GetFileVersionInfoSizeW == NULL)
                return FALSE;

            _GetFileVersionInfoW = GetProcAddress(hVersionDll, "GetFileVersionInfoW");
            if(_GetFileVersionInfoW == NULL)
                return FALSE;

            _VerQueryValueW = GetProcAddress(hVersionDll, "VerQueryValueW");
            if(_VerQueryValueW == NULL)
                return FALSE;

        } else {
            _GetFileVersionInfoSizeA = GetProcAddress(hVersionDll, "GetFileVersionInfoSizeA");
            if(_GetFileVersionInfoSizeA == NULL)
                return FALSE;

            _GetFileVersionInfoA = GetProcAddress(hVersionDll, "GetFileVersionInfoA");
            if(_GetFileVersionInfoA == NULL)
                return FALSE;

            _VerQueryValueA = GetProcAddress(hVersionDll, "VerQueryValueA");
            if(_VerQueryValueA == NULL)
                return FALSE;
        }

        fLoadedVersionDll = TRUE;
    }

    //
    // could win95 be any more annoying?
    //

    if(FIsWinNT()) {
        _GetFileVersionInfoSize = (GETFILEVERSIONINFOSIZE*)_GetFileVersionInfoSizeW;
        _GetFileVersionInfo = (GETFILEVERSIONINFO*)_GetFileVersionInfoW;
        _wsprintf = (WSPRINTF *)wsprintfW;
        _VerQueryValue = (VERQUERYVALUE*)_VerQueryValueW;
        Trans = L"\\VarFileInfo\\Translation";
        StringFileInfo = StringFileInfoW;
        Language = LanguageW;
        FileName = szFile; // use unicode input
    } else {
        _GetFileVersionInfoSize = (GETFILEVERSIONINFOSIZE*)_GetFileVersionInfoSizeA;
        _GetFileVersionInfo = (GETFILEVERSIONINFO*)_GetFileVersionInfoA;
        _wsprintf = (WSPRINTF *)wsprintfA;
        _VerQueryValue = (VERQUERYVALUE*)_VerQueryValueA;
        Trans = "\\VarFileInfo\\Translation";
        StringFileInfo = StringFileInfoA;
        Language = LanguageA;
        FileName = FileNameA;

        // convert unicode input to ANSI
        if(WideCharToMultiByte(
                    CP_ACP,
                    0,
                    szFile,
                    -1,
                    (LPSTR)FileName,
                    MAX_PATH,
                    NULL,
                    NULL
                    ) == 0) {

                return FALSE;
            }
    }

    dwVerInfoSize = _GetFileVersionInfoSize(FileName, &dwHandle);
    if(dwVerInfoSize == 0)
        return FALSE;

    VerInfo = SSAlloc(dwVerInfoSize);
    if(VerInfo == NULL)
        return FALSE;

    if(!_GetFileVersionInfo(FileName, dwHandle, dwVerInfoSize, VerInfo))
        goto cleanup;

    //
    // first, try current language
    //

    LangDefault = GetUserDefaultLangID();

    _wsprintf( Language, StringFileInfo, LangDefault, 1200);

    if(_VerQueryValue(VerInfo, Language, &lpBuffer, &puLen)) {
        goto success;
    }

    //
    // try languages in translation table
    //

    if(_VerQueryValue(VerInfo, Trans, &lpBuffer, &puLen)) {
        DWORD dwTranslationCount = puLen / sizeof(DWORD);
        DWORD dwIndexTranslation;

        for(dwIndexTranslation = 0 ;
            dwIndexTranslation < dwTranslationCount ;
            dwIndexTranslation++ ) {

            DWORD LangID, CharSetID;

            LangID = LOWORD( ((DWORD*)lpBuffer)[dwIndexTranslation] );
            CharSetID = HIWORD( ((DWORD*)lpBuffer)[dwIndexTranslation] );

            _wsprintf(Language, StringFileInfo, LangID, CharSetID);

            if(_VerQueryValue(VerInfo, Language, &lpBuffer, &puLen)) {
                goto success;
            }
        } // for
    }

    //
    // try english, Unicode if we didn't already
    //

    if(LangDefault != MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)) {
        _wsprintf(Language, StringFileInfo,
            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
            1200);

        if(_VerQueryValue(VerInfo, Language, &lpBuffer, &puLen)) {
            goto success;
        }
    }

    //
    // try english, code page 1252
    //

    _wsprintf(Language, StringFileInfo,
        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
        1252);

    if(_VerQueryValue(VerInfo, Language, &lpBuffer, &puLen)) {
        goto success;
    }

    //
    // try english, code page 0000
    //

    _wsprintf(Language, StringFileInfo,
        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
        0);

    if(_VerQueryValue(VerInfo, Language, &lpBuffer, &puLen)) {
        goto success;
    }



    //
    // failed! skip to cleanup
    //

    goto cleanup;

success:

    *FileDescription = (LPWSTR)SSAlloc((puLen + 1) * sizeof(WCHAR));
    if(*FileDescription == NULL)
        goto cleanup;

    bSuccess = TRUE; // assume success

    if(FIsWinNT()) {
        wcscpy(*FileDescription, (LPWSTR)lpBuffer);
    } else {

        if(MultiByteToWideChar(
                CP_ACP,
                0,
                (LPSTR)lpBuffer,
                puLen,
                *FileDescription,
                puLen
                ) == 0) {

            bSuccess = FALSE;
        }
    }

cleanup:

    if(!bSuccess && *FileDescription) {
        SSFree(*FileDescription);
        *FileDescription = NULL;
    }

    SSFree(VerInfo);

    return bSuccess;
}

void MyToUpper(LPWSTR szInBuf)
{
    DWORD cch = WSZ_BYTECOUNT(szInBuf);
    LPWSTR szUpperCase = (LPWSTR)LocalAlloc(LMEM_FIXED, cch);

    LCMapStringU(
        LOCALE_SYSTEM_DEFAULT,
        LCMAP_UPPERCASE,
        szInBuf,
        -1,
        szUpperCase,
        cch);

    // no growth or shrinkage
    SS_ASSERT(wcslen(szInBuf) == wcslen(szUpperCase));

    // mash back into passed-in buffer
    wcscpy(szInBuf, szUpperCase);
    LocalFree(szUpperCase);
}


// cached authentication list
extern              CUAList*            g_pCUAList;

BOOL
FIsCachedPassword(
    LPCWSTR     szUser,
    LPCWSTR     szPassword,
    LUID*       pluidAuthID
    )
{
    // see if this MK has been cached
    UACACHE_LIST_ITEM li;
    if(NULL == g_pCUAList)
    {
        return FALSE;
    }

    CreateUACacheListItem(
            &li,
            szUser,
            szPassword,
            pluidAuthID
            );

    // TRUE if cached
    return (NULL != g_pCUAList->SearchList(&li));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\include\spreg.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

#ifndef _SPREG_H_
#define _SPREG_H_

/*
 *[HKEY_LOCAL_MACHINE]
 *   [System]
 *       [CurrentControlSet]
 *           [Control]
 *               [SecurityProviders]
 *                   SecurityProviders:REG_SZ:     - security provider dll's installed on this machine
 *
 *                   [SCHANNEL] or [SSLSSPI]       - this security provider
 *                       EventLogging:REG_DWORD:   - Flag specifing event logging level
 *                       LogFile:REG_SZ:           - debug logfile name (Not published)
 *                       LogLevel:REG_SZ:          - debug logging level flags.
 *                       DebugBreak:REG_DWORD:     - Flag specifing what type of errors cause a debug break (Not published)
 *                       CertMapper:REG_SZ         - location of cert mapper dll
 *                       ClientCache:REG_DWORD     - size of client cache (defaults to 10)
 *                       ServerCache:REG_DWORD     - size of server cache (defaults to 100)
 *                       ClientCacheTime:REG_DWORD - time to expire client side cache elements
 *                       ServerCacheTime:REG_DWORD - time to expire server side cache elements
 *                       RNGSeed:REG_BINARY        - persistent rng seed
 *
 *                       [Protocols]
 *                           [Unified Hello
 *                               [Client]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                               [Server]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled                          [SSL2]
 *                           [SSL2]
 *                               [Client]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                               [Server]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled                          [SSL2]
 *                           [SSL3]
 *                               [Client]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                               [Server]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                           [PCT1]
 *                               [Client]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                               [Server]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *
 *                       [Ciphers]
 *                           [Cipher Name]
 *                               Enabled:REG_DWORD: - Enable Mask
 *                           [RC4_128]
 *                               Enabled:REG_DWORD: - Is this Ciphers enabled
 *                       [Hashes]
 *                           [Hash Name]
 *                               Enabled:REG_DWORD: - Enable Mask
 *                       [KeyExchangeAlgorithms]
 *                           [Exch Name]
 *                               Enabled:REG_DWORD: - Enable Mask
 *
 *                       [CertificationAuthorities]
 *                           [C=US.....]
 *                               Enabled:REG_DWORD: - Is this Cert enabled
 *                               CACert:REG_BINARY:   - BER encoded self signed certificate.
 *
 *	                            							
 *
 *
 */



/* Key Names */
#define SP_REG_KEY_BASE     TEXT("System\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL")
#define SP_REG_KEY_PROTOCOL TEXT("Protocols")
#define SP_REG_KEY_CIPHERS  TEXT("Ciphers")
#define SP_REG_KEY_HASHES   TEXT("Hashes")
#define SP_REG_KEY_KEYEXCH  TEXT("KeyExchangeAlgorithms")
#define SP_REG_KEY_CA       TEXT("CertificationAuthorities")

/* Value Names */
#define SP_REG_VAL_EVENTLOG  TEXT("EventLogging")
#define SP_REG_VAL_LOGFILE   TEXT("LogFile")
#define SP_REG_VAL_LOGLEVEL  TEXT("LogLevel")
#define SP_REG_VAL_BREAK     TEXT("DebugBreak")
#define SP_REG_VAL_CERTMAPPER TEXT("CertMapper")

#define SP_REG_VAL_CLIENT_CACHE        TEXT("ClientCache")
#define SP_REG_VAL_SERVER_CACHE        TEXT("ServerCache")
#define SP_REG_VAL_CLIENT_CACHE_TIME   TEXT("ClientCacheTime")
#define SP_REG_VAL_SERVER_CACHE_TIME   TEXT("ServerCacheTime")
#define SP_REG_VAL_RNG_SEED            TEXT("RNGSeed")

#define SP_REG_VAL_ENABLED   TEXT("Enabled")
#define SP_REG_VAL_CACERT    TEXT("CACert")
#define SP_REG_VAL_CERT_TYPE TEXT("Type")


#define SP_REG_KEY_CLIENT    TEXT("Client")
#define SP_REG_KEY_SERVER    TEXT("Server")

#define SP_REG_KEY_PCT1      TEXT("PCT 1.0")
#define SP_REG_KEY_SSL2      TEXT("SSL 2.0")
#define SP_REG_KEY_SSL3      TEXT("SSL 3.0")
#define SP_REG_KEY_UNIHELLO  TEXT("Multi-Protocol Unified Hello") 

#define SP_EVENT_CONFIG_CHANGED TEXT("Schannel Config Changed")

/* Base keys, created when DLL is first loaded */
extern HKEY g_hkBase;
extern HKEY g_hkProtocols;
extern HKEY g_hkCiphers;
extern HKEY g_hkHashes;
extern HKEY g_hkKeyExch;
extern HKEY g_hkCA;

BOOL SPInitRegKeys();
BOOL SPCloseRegKeys();

BOOL SPLoadRegOptions();

BOOL SPQueryPersistentSeed(LPBYTE Buffer, DWORD dwBufferSize);
BOOL SPSetPersistentSeed(LPBYTE Buffer, DWORD dwBufferSize);



/* Event Logging Definitions */
#define SP_EVLOG_RESOURCE           0x0001
#define SP_EVLOG_ASSERT             0x0002
#define SP_EVLOG_ILLEGAL_MESSAGE    0x0004
#define SP_EVLOG_SECAUDIT           0x0008


#define SP_LOG_ERROR                0x0001
#define SP_LOG_WARNING              0x0002
#define SP_LOG_TRACE                0x0004
#define SP_LOG_ALLOC                0x0008
#define SP_LOG_RES                  0x0010

#define SP_LOG_FILE             0x80000000

#define SP_LOG_TYPEMASK         0x0000ffff

#define SP_BREAK_ERROR              0x0001
#define SP_BREAK_WARNING            0x0002
#define SP_BREAK_ENTRY              0x0004

#endif // _SPREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\migrate.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    migrate.cpp

Abstract:

    This module contains routines to support migration of protected storage
    data from beta1 to beta2.

    Hopefully this code will be pitched after beta2, prior to final release.

Author:

    Scott Field (sfield)    15-Apr-97

--*/

#include <pch.cpp>
#pragma hdrstop

#include <lmcons.h>

#include "provif.h"
#include "storage.h"
#include "secure.h"

#include "secmisc.h"
#include "passwd.h"



#include "migrate.h"

//#define MIGRATE_FLAG    1 // indicates whether beta1 -> beta2 migration done.
#define MIGRATE_FLAG    2 // indicates whether beta2 -> RTW migration done.


extern      DISPIF_CALLBACKS g_sCallbacks;



BOOL
IsMigrationComplete(
    HKEY hKey
    );

BOOL
SetMigrationComplete(
    HKEY hKey
    );

BOOL
MigrateWin9xData(
    PST_PROVIDER_HANDLE *phPSTProv,
    HKEY hKeySource,
    HKEY hKeyDestination,
    LPWSTR szUserName9x,
    LPWSTR szUserNameNT     // Windows NT username
    );

BOOL
MigrateWin9xDataRetry(
    PST_PROVIDER_HANDLE *phPSTProv,
    HKEY hKeyDestination,
    LPWSTR szUserName9x,
    LPWSTR szUserNameNT
    );


BOOL
SetRegistrySecurityEnumerated(
    HKEY hKey,
    PSECURITY_DESCRIPTOR pSD
    );

BOOL
SetRegistrySecuritySingle(
    HKEY hKey,
    PSECURITY_DESCRIPTOR pSD
    );


BOOL
MigrateData(
    PST_PROVIDER_HANDLE *phPSTProv,
    BOOL                fMigrationNeeded
    )
{
    LPWSTR szUser = NULL;
    HKEY hKeyUsers = NULL;
    HKEY hKeyUserKey = NULL;
    HKEY hKey = NULL;
    BYTE rgbPwd[A_SHA_DIGEST_LEN];
    LONG lRet;
    DWORD dwDisposition;

    BOOL bUpdateMigrationStatus = FALSE;
    BOOL bSuccess = FALSE;


    // get current user
    if (!g_sCallbacks.pfnFGetUser(
            phPSTProv,
            &szUser))
        goto cleanup;

    //
    // open up the registry key associated with the protected storage
    // note: this opens the old registry location.
    //


    // HKEY_USERS\<Name>

    if(!GetUserHKEY(
                    szUser,
                    KEY_QUERY_VALUE,
                    &hKeyUsers
                    )) {

        if(FIsWinNT())
            goto cleanup;

        //
        // Win95, profiles may be disabled, so go to
        // HKEY_LOCAL_MACHINE\xxx\szContainer
        // see secstor\prov\storage.cpp for details
        //

        hKeyUsers = HKEY_LOCAL_MACHINE;

    }

    // SOFTWARE\Microsoft\...
    // Here, CreateKeyEx is used, because win9x profiles may have been
    // disabled, which leads to a non-existent HKCU ProtectedStorageKey.
    //

    lRet = RegCreateKeyExU(
                    hKeyUsers,
                    REG_PSTTREE_LOC,
                    0,
                    NULL,
                    0,
                    KEY_QUERY_VALUE,
                    NULL,
                    &hKeyUserKey,
                    &dwDisposition
                    );


    //
    // close the intermediate key
    //

    RegCloseKey(hKeyUsers);

    if( lRet != ERROR_SUCCESS ) {
        goto cleanup;
    }


    // ...\<Name>

    lRet = RegOpenKeyExU(
                    hKeyUserKey,
                    szUser,
                    0,
                    KEY_SET_VALUE | KEY_QUERY_VALUE |
                    DELETE | KEY_ENUMERATE_SUB_KEYS, // for failed migration
                    &hKey
                    );

    if(FIsWinNT() && lRet != ERROR_SUCCESS) {
        WCHAR szUserName[ UNLEN + 1 ];
        WCHAR szUserName9x[ UNLEN + 1 ];
        DWORD cch;
        BOOL fRet;

        //
        // get win9x form of username.
        //
        if(!g_sCallbacks.pfnFImpersonateClient( phPSTProv ))
            goto tried_migration;

        cch = sizeof(szUserName) / sizeof( szUserName[0] );
        fRet = GetUserNameW(szUserName, &cch);

        g_sCallbacks.pfnFRevertToSelf( phPSTProv );

        if( !fRet )
            goto tried_migration;

        if(LCMapStringW(
                        LOCALE_SYSTEM_DEFAULT,
                        LCMAP_LOWERCASE,
                        szUserName,
                        cch,
                        szUserName9x,
                        cch) == 0)
            goto tried_migration;


        //
        // failed to open the key:
        // check if win9x migration is necessary.
        //

        if(!MigrateWin9xData( phPSTProv, hKeyUserKey, hKeyUserKey, szUserName9x, szUser )) {
            MigrateWin9xDataRetry( phPSTProv, hKeyUserKey, szUserName9x, szUser );
        }

tried_migration:

        //
        // tried moving any win9x data, so proceed with any other
        // migration activities.
        //

        lRet = RegOpenKeyExU(
                        hKeyUserKey,
                        szUser,
                        0,
                        KEY_SET_VALUE | KEY_QUERY_VALUE |
                        DELETE | KEY_ENUMERATE_SUB_KEYS, // for failed migration
                        &hKey
                        );

    }

    RegCloseKey( hKeyUserKey );

    if( lRet != ERROR_SUCCESS ) {
        goto cleanup;
    }


    //
    // see if migration has already been done.  If so, get out with SUCCESS.
    //

    if( IsMigrationComplete( hKey ) ) {
        bSuccess = TRUE;
        goto cleanup;
    }


    if(fMigrationNeeded) {

        //
        // do the migration
        //

        if(BPVerifyPwd(
            phPSTProv,
            szUser,
            WSZ_PASSWORD_WINDOWS,
            rgbPwd,
            BP_CONFIRM_NONE
            ) == PST_E_WRONG_PASSWORD) {

            //
            // if password could not be changed/verified correctly, nuke existing
            // data.
            //

            DeleteAllUserData( hKey );

        }

    }


    //
    // set the flag to update migration status, regardless of whether migration
    // succeeds.  If it doesn't succeed the first time, it isn't likely to
    // ever succeed, so get on with life.
    //

    bUpdateMigrationStatus = TRUE;

cleanup:

    if(bUpdateMigrationStatus && hKey) {
        SetMigrationComplete( hKey );
    }

    if(szUser != NULL)
        SSFree(szUser);

    if(hKey != NULL)
        RegCloseKey(hKey);

    return bSuccess;
}



BOOL
IsMigrationComplete(
    HKEY hKey
    )
/*++

    This function determines if migration has been performed for the user
    specified by the supplied hKey registry key.

--*/
{
    DWORD dwType;

    DWORD dwMigrationStatus;
    DWORD cbMigrationStatus = sizeof(dwMigrationStatus);
    LONG lRet;

    lRet = RegQueryValueExU(
        hKey,
        L"Migrate",
        NULL,
        &dwType,
        (LPBYTE)&dwMigrationStatus,
        &cbMigrationStatus
        );

    if(lRet != ERROR_SUCCESS)
        return FALSE;

    if(dwType == REG_DWORD && dwMigrationStatus >= MIGRATE_FLAG)
        return TRUE;

    return FALSE;
}


BOOL
SetMigrationComplete(
    HKEY hKey
    )
/*++

    This function sets the data migration flag associated with the user
    specified by the supplied hKey registry key.

    The flag is set to indicate that migration has been completed and no
    future processing is required for this user.

--*/
{
    DWORD dwMigrationStatus = MIGRATE_FLAG;
    DWORD cbMigrationStatus = sizeof(dwMigrationStatus);
    LONG lRet;

    lRet = RegSetValueExU(
        hKey,
        L"Migrate",
        0,
        REG_DWORD,
        (LPBYTE)&dwMigrationStatus,
        cbMigrationStatus
        );

    if(lRet != ERROR_SUCCESS)
        return FALSE;

    return TRUE;
}

BOOL
MigrateWin9xData(
    PST_PROVIDER_HANDLE *phPSTProv,
    HKEY hKeySource,
    HKEY hKeyDestination,
    LPWSTR szUserName9x,
    LPWSTR szUserNameNT     // Windows NT username
    )
{
    HKEY hKeyOldData = NULL;
    HKEY hKeyNewData = NULL;
    DWORD dwDisposition;


    WCHAR szTempPath[ MAX_PATH + 1 ];
    DWORD cchTempPath;
    DWORD cch;

    WCHAR szTempFile[ MAX_PATH + 1 ];
    BOOL fTempFile = FALSE;

    HANDLE hThreadToken = NULL;
    BOOL fRevertToSelf = FALSE;

    BYTE rgbOldPwd[ A_SHA_DIGEST_LEN ];
    BYTE rgbNewPwd[ A_SHA_DIGEST_LEN ];
    BYTE rgbSalt[PASSWORD_SALT_LEN];
    BYTE rgbConfirm[A_SHA_DIGEST_LEN];

    PBYTE   pbMK = NULL;
    DWORD   cbMK;
    BOOL fRemoveImported = FALSE;
    HKEY hKeyMasterKey = NULL;
    HKEY hKeyIntermediate = NULL;

    BOOL fProfilesDisabled = FALSE;

    PSID pLocalSystemSid = NULL;
    PACL pDacl = NULL;


    LONG lRet;
    BOOL fSuccess = FALSE;

    //
    // see if win9x data present.
    //

    lRet = RegOpenKeyExW(
                    hKeySource,
                    szUserName9x,
                    0,
                    KEY_ALL_ACCESS,
                    &hKeyOldData
                    );

    if( lRet != ERROR_SUCCESS )
        return FALSE;


    //
    // attempt decrypt with computed win9x style pwd.
    //

    if( hKeySource != hKeyDestination && lstrcmpW(szUserName9x, L"*Default*") == 0) {

        //
        // win9x profiles were disabled, don't nuke old data either.
        //

        fProfilesDisabled = TRUE;
        if(!FMyGetWinPassword( phPSTProv, L"", rgbOldPwd ))
            goto cleanup;
    } else {

        if(!FMyGetWinPassword( phPSTProv, szUserName9x, rgbOldPwd ))
            goto cleanup;
    }

    lRet = RegOpenKeyExW(
            hKeyOldData,
            L"Data 2",
            0,
            KEY_QUERY_VALUE,
            &hKeyIntermediate
            );

    if( lRet != ERROR_SUCCESS )
        goto cleanup;

    lRet = RegOpenKeyExW(
            hKeyIntermediate,
            WSZ_PASSWORD_WINDOWS,
            0,
            KEY_QUERY_VALUE,
            &hKeyMasterKey
            );

    RegCloseKey( hKeyIntermediate );
    hKeyIntermediate = NULL;

    if( lRet != ERROR_SUCCESS )
        goto cleanup;


    // confirm is just get state and attempt MK decrypt
    if (!FBPGetSecurityStateFromHKEY(
            hKeyMasterKey,
            rgbSalt,
            sizeof(rgbSalt),
            rgbConfirm,
            sizeof(rgbConfirm),
            &pbMK,
            &cbMK
            ))
    {
        goto cleanup;
    }

    RegCloseKey( hKeyMasterKey );
    hKeyMasterKey = NULL;

    // found state; is pwd correct?
    if (!FMyDecryptMK(
                rgbSalt,
                sizeof(rgbSalt),
                rgbOldPwd,
                rgbConfirm,
                &pbMK,
                &cbMK
                ))
    {
        goto cleanup;
    }



    //
    // masterkey is now decrypted.
    //



    //
    // construct temporary file path to hold registry branch.
    //

    cchTempPath = sizeof(szTempPath) / sizeof( szTempPath[0] );
    cch = GetTempPathW(cchTempPath, szTempPath);
    if( cch == 0 || cch > cchTempPath )
        goto cleanup;

    if( GetTempFileNameW( szTempPath, L"PST", 0, szTempFile ) == 0 )
        goto cleanup;

    if(!DeleteFileW( szTempFile ))
        goto cleanup;


    //
    // impersonate self, so we can enable and use backup&restore privs
    // in a thread safe fashion.
    //

    if(!ImpersonateSelf( SecurityImpersonation ))
        goto cleanup;

    fRevertToSelf = TRUE;


    if(!OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
                FALSE,
                &hThreadToken
                )) {

        goto cleanup;
    }

    if(!SetPrivilege( hThreadToken, L"SeRestorePrivilege", TRUE ))
        goto cleanup;

    if(!SetPrivilege( hThreadToken, L"SeBackupPrivilege", TRUE ))
        goto cleanup;

    //
    // save registry branch as file.
    //

    lRet = RegSaveKeyW( hKeyOldData, szTempFile, NULL );

    if( lRet != ERROR_SUCCESS )
        goto cleanup;

    fTempFile = TRUE;

    //
    // import branch into new location.
    //

    lRet = RegCreateKeyExW(
                    hKeyDestination,
                    szUserNameNT,
                    0,
                    NULL,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKeyNewData,
                    &dwDisposition
                    );

    if( lRet != ERROR_SUCCESS )
        goto cleanup;


    lRet = RegRestoreKeyW( hKeyNewData, szTempFile, 0 );

    if( lRet != ERROR_SUCCESS )
        goto cleanup;


    //
    // update acls on imported data, since none were present on win9x.
    // note that sebackup & serestore privileges enabled above, which
    // allows REG_OPTION_BACKUP_RESTORE to work.
    //


    while (TRUE) {
        SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
        SECURITY_DESCRIPTOR sd;
        DWORD dwAclSize;

        if(!AllocateAndInitializeSid(
            &sia,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &pLocalSystemSid
            )) break;

        //
        // compute size of new acl
        //

        dwAclSize = sizeof(ACL) +
            1 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
            GetLengthSid(pLocalSystemSid) ;

        //
        // allocate storage for Acl
        //

        pDacl = (PACL)SSAlloc(dwAclSize);
        if(pDacl == NULL)
            break;

        if(!InitializeAcl(pDacl, dwAclSize, ACL_REVISION))
            break;

        if(!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            KEY_ALL_ACCESS,
            pLocalSystemSid
            )) break;

        if(!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
            break;

        if(!SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE))
            break;

        SetRegistrySecurityEnumerated(hKeyNewData, &sd);

        // add SYSTEM inherit Ace to base
        SetRegistrySecurity( hKeyNewData );

        break;
    }



    //
    // change existing password data.
    // assume worst case: we fail to change the state, in which case we
    // cleanup the restored registry key.
    //

    if(!FMyGetWinPassword( phPSTProv, szUserNameNT, rgbNewPwd ))
        goto cleanup;

    fRemoveImported = TRUE;

    if (!FMyEncryptMK(
                rgbSalt,
                sizeof(rgbSalt),
                rgbNewPwd,
                rgbConfirm,
                &pbMK,
                &cbMK))
    {
        goto cleanup;
    }

    if (!FBPSetSecurityState(
                szUserNameNT,
                WSZ_PASSWORD_WINDOWS,
                rgbSalt,
                PASSWORD_SALT_LEN,
                rgbConfirm,
                sizeof(rgbConfirm),
                pbMK,
                cbMK))
    {

        goto cleanup;
    }

    fRemoveImported = FALSE;


    //
    // everything went ok: nuke the old data.
    //

    // NTBUG 413234: do not delete old user data, because, user may not
    // have joined domain during Win9x upgrade.  so allow data to migrate
    // again to domain user once joined.
    //

#if 0
    if(!fProfilesDisabled && DeleteAllUserData( hKeyOldData )) {
        RegCloseKey( hKeyOldData );
        hKeyOldData = NULL;
        RegDeleteKeyW( hKeySource, szUserName9x );
    }
#endif

    fSuccess = TRUE;

cleanup:

    if( fTempFile ) {
        DeleteFileW( szTempFile );
    }

    if( fRevertToSelf )
        RevertToSelf();

    if( fRemoveImported ) {
        DeleteAllUserData( hKeyNewData );
        // but leave parent key alone, since it will contain an indicator
        // of a failed attempt, which prevents futile retries.
    }

    if( hThreadToken )
        CloseHandle( hThreadToken );

    if( hKeyOldData )
        RegCloseKey( hKeyOldData );

    if( hKeyNewData )
        RegCloseKey( hKeyNewData );

    if( hKeyMasterKey )
        RegCloseKey( hKeyMasterKey );

    if( hKeyIntermediate )
        RegCloseKey( hKeyIntermediate );

    if ( pbMK ) {
        ZeroMemory( pbMK, cbMK );
        SSFree( pbMK );
    }

    if( pLocalSystemSid )
        FreeSid( pLocalSystemSid );

    if( pDacl )
        SSFree( pDacl );

    return fSuccess;
}


BOOL
MigrateWin9xDataRetry(
    PST_PROVIDER_HANDLE *phPSTProv,
    HKEY hKeyDestination,
    LPWSTR szUserName9x,
    LPWSTR szUserNameNT
    )
{
    HKEY hKeyBaseLM = NULL;
    BOOL fSuccess = FALSE;

    // HKLM\SOFTWARE\Microsoft\...

    if(RegOpenKeyExU(
                    HKEY_LOCAL_MACHINE,
                    REG_PSTTREE_LOC,
                    0,
                    KEY_QUERY_VALUE,
                    &hKeyBaseLM
                    ) != ERROR_SUCCESS )
    {
        return FALSE;
    }


    //
    // try HKLM\Username
    // (profiles disabled on win9x)
    //

    fSuccess = MigrateWin9xData( phPSTProv, hKeyBaseLM, hKeyDestination, szUserName9x, szUserNameNT );

    if( !fSuccess ) {

        //
        // try HKLM\*Default*
        // (escape from logon)
        //

        fSuccess = MigrateWin9xData( phPSTProv, hKeyBaseLM, hKeyDestination, L"*Default*", szUserNameNT );
    }

    if( hKeyBaseLM )
        RegCloseKey( hKeyBaseLM );

    return fSuccess;
}


BOOL
SetRegistrySecurityEnumerated(
    HKEY hKey,
    PSECURITY_DESCRIPTOR pSD
    )
{
    LONG rc;

    WCHAR szSubKey[MAX_PATH];
    DWORD dwSubKeyLength;
    DWORD dwSubKeyIndex;
    DWORD dwDisposition;

    dwSubKeyIndex = 0;
    dwSubKeyLength = MAX_PATH;

    //
    // update security on specified key
    //

    if(!SetRegistrySecuritySingle(hKey, pSD))
        return FALSE;

    while((rc=RegEnumKeyExU(
                        hKey,
                        dwSubKeyIndex,
                        szSubKey,
                        &dwSubKeyLength,
                        NULL,
                        NULL,
                        NULL,
                        NULL)
                        ) != ERROR_NO_MORE_ITEMS) { // are we done?

        if(rc == ERROR_SUCCESS)
        {
            HKEY hSubKey;
            LONG lRet;

            lRet = RegCreateKeyExU(
                            hKey,
                            szSubKey,
                            0,
                            NULL,
                            REG_OPTION_BACKUP_RESTORE, // in winnt.h
                            KEY_ENUMERATE_SUB_KEYS | WRITE_DAC,
                            NULL,
                            &hSubKey,
                            &dwDisposition
                            );

            if(lRet != ERROR_SUCCESS)
                return FALSE;


            //
            // recurse
            //
            SetRegistrySecurityEnumerated(hSubKey, pSD);

            RegCloseKey(hSubKey);


            // increment index into the key
            dwSubKeyIndex++;

            // reset buffer size
            dwSubKeyLength=MAX_PATH;

            // Continue the festivities
            continue;
        }
        else
        {
           //
           // note: we need to watch for ERROR_MORE_DATA
           // this indicates we need a bigger szSubKey buffer
           //
            return FALSE;
        }

    } // while


    return TRUE;
}


BOOL
SetRegistrySecuritySingle(
    HKEY hKey,
    PSECURITY_DESCRIPTOR pSD
    )
{
    LONG lRetCode;

    //
    // apply the security descriptor to the registry key
    //

    lRetCode = RegSetKeySecurity(
        hKey,
        (SECURITY_INFORMATION)DACL_SECURITY_INFORMATION,
        pSD
        );

    if(lRetCode != ERROR_SUCCESS)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\lnklist.cpp ===
#include <pch.cpp>
#pragma hdrstop

#include "crtem.h"






//////////////////////////
// OpenItem list
COpenItemList::COpenItemList()
{
    m_pfnIsMatch = OpenItemIsMatch;
    m_pfnFreeElt = OpenItemFreeElt;
}

void CreateOpenListItem(OPENITEM_LIST_ITEM* pli,
                        PST_PROVIDER_HANDLE* phPSTProv,
                        PST_KEY     Key,
                        const GUID* pguidType,
                        const GUID* pguidSubtype,
                        LPCWSTR     szItemName)
{
    pli->pNext = NULL;
    CopyMemory(&pli->hPSTProv, phPSTProv, sizeof(PST_PROVIDER_HANDLE));
    pli->Key = Key;
    CopyMemory(&pli->guidType, pguidType, sizeof(GUID));
    CopyMemory(&pli->guidSubtype, pguidSubtype, sizeof(GUID));
    pli->szItemName = (LPWSTR)szItemName;
}


BOOL OpenItemIsMatch(
        ELT* pCandidate,
        ELT* pTemplate)
{
    POPENITEM_LIST_ITEM pliCandidate = (POPENITEM_LIST_ITEM) pCandidate;
    POPENITEM_LIST_ITEM pliTemplate = (POPENITEM_LIST_ITEM) pTemplate;

    if (
        (0 == memcmp(&pliCandidate->hPSTProv, &pliTemplate->hPSTProv, sizeof(PST_PROVIDER_HANDLE))) &&
        (pliCandidate->Key == pliTemplate->Key) &&
        (0 == memcmp(&pliCandidate->guidType, &pliTemplate->guidType, sizeof(GUID))) &&
        (0 == memcmp(&pliCandidate->guidSubtype, &pliTemplate->guidSubtype, sizeof(GUID))) &&
        (0 == wcscmp(pliCandidate->szItemName, pliTemplate->szItemName))
       )
       return TRUE;

    return FALSE;
}

void OpenItemFreeElt(
        ELT* p)
{
    if (NULL == p)
        return;

    POPENITEM_LIST_ITEM pli = (POPENITEM_LIST_ITEM) p;

    // do all necessary freeing
    if (pli->szItemName != NULL)
        SSFree(pli->szItemName);

    if (pli->szMasterKey != NULL)
        SSFree(pli->szMasterKey);

    ZeroMemory(pli, sizeof(OPENITEM_LIST_ITEM)); // make sure contents invalid

    SSFree(pli);
}




//////////////////////////
// UACache list
CUAList::CUAList()
{
    m_pfnIsMatch = UACacheIsMatch;
    m_pfnFreeElt = UACacheFreeElt;
}

void CreateUACacheListItem(UACACHE_LIST_ITEM* pli,
                        LPCWSTR     szUserName,
                        LPCWSTR     szMKName,
                        LUID        *pluidAuthID)
{
    pli->pNext = NULL;
    pli->szUserName = (LPWSTR)szUserName;
    pli->szMKName = (LPWSTR)szMKName;

    CopyMemory( &(pli->luidAuthID), pluidAuthID, sizeof(LUID) );
}

BOOL UACacheIsMatch(
        ELT* pCandidate,
        ELT* pTemplate)
{
    PUACACHE_LIST_ITEM pliCandidate = (PUACACHE_LIST_ITEM) pCandidate;
    PUACACHE_LIST_ITEM pliTemplate = (PUACACHE_LIST_ITEM) pTemplate;

    if (
        (0 == wcscmp(pliCandidate->szUserName, pliTemplate->szUserName)) &&
        (0 == wcscmp(pliCandidate->szMKName, pliTemplate->szMKName))
       ) {

        //
        // sfield:
        // on WinNT, expand cache matching based on authentication ID.
        //

        if(FIsWinNT()) {
            if(memcmp(&(pliCandidate->luidAuthID), &(pliTemplate->luidAuthID), sizeof(LUID)) != 0)
                return FALSE;
        }

        return TRUE;
    }

    return FALSE;
}

void UACacheFreeElt(
        ELT* p)
{
    if (NULL == p)
        return;

    PUACACHE_LIST_ITEM pli = (PUACACHE_LIST_ITEM) p;

    // do all necessary freeing
    if (pli->szUserName != NULL)
        SSFree(pli->szUserName);

    if (pli->szMKName != NULL)
        SSFree(pli->szMKName);

    ZeroMemory(pli, sizeof(UACACHE_LIST_ITEM)); // make sure contents invalid

    SSFree(pli);
}




////////////////////////
// Cryptographic Provider handle list

CCryptProvList::CCryptProvList()
{
    m_pfnIsMatch = CryptProvIsMatch;
    m_pfnFreeElt = CryptProvFreeElt;
}

void CreateCryptProvListItem(CRYPTPROV_LIST_ITEM* pli,
                        DWORD       dwAlgId1,
                        DWORD       dwKeySize1,
                        DWORD       dwAlgId2,
                        DWORD       dwKeySize2,
                        HCRYPTPROV  hProvider)
{
    pli->pNext = NULL;

    pli->dwAlgId1 = dwAlgId1;
    pli->dwKeySize1 = dwKeySize1;

    pli->dwAlgId2 = dwAlgId2;
    pli->dwKeySize2 = dwKeySize2;

    pli->hProv = hProvider;
}

BOOL CryptProvIsMatch(
        ELT* pCandidate,
        ELT* pTemplate)
{
    PCRYPTPROV_LIST_ITEM pliCandidate = (PCRYPTPROV_LIST_ITEM) pCandidate;
    PCRYPTPROV_LIST_ITEM pliTemplate = (PCRYPTPROV_LIST_ITEM) pTemplate;

    // if both algids match
    if ((pliCandidate->dwAlgId1 == pliTemplate->dwAlgId1) &&
        (pliCandidate->dwAlgId2 == pliTemplate->dwAlgId2))
    {
        // if both sizes match
        if ((pliCandidate->dwKeySize1 == -1) ||
            (pliTemplate->dwKeySize1 == -1) ||
            (pliCandidate->dwKeySize1 == pliTemplate->dwKeySize1))
        {
            if ((pliCandidate->dwKeySize2 == -1) ||
                (pliTemplate->dwKeySize2 == -1) ||
                (pliCandidate->dwKeySize2 == pliTemplate->dwKeySize2))
               return TRUE;
        }
    }

    return FALSE;
}

void CryptProvFreeElt(
        ELT* p)
{
    if (NULL == p)
        return;

    PCRYPTPROV_LIST_ITEM pli = (PCRYPTPROV_LIST_ITEM) p;

    // do all necessary freeing
    if (pli->hProv != 0)
        CryptReleaseContext((HCRYPTPROV)pli->hProv, 0);

    ZeroMemory(pli, sizeof(CRYPTPROV_LIST_ITEM)); // make sure contents invalid

    SSFree(pli);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\lnklist.h ===
#ifndef __LNKLIST_H__
#define __LNKLIST_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "pstypes.h"
#include "listbase.h"
#include <sha.h>


//////////////////////
// OpenItem list

// item list element
typedef struct _OPENITEM_LIST_ITEM
{
    // internal to list
    struct _OPENITEM_LIST_ITEM *      pNext;

    // Lookup devices: set by creator before adding to list
    PST_PROVIDER_HANDLE     hPSTProv;
    PST_KEY                 Key;
    GUID                    guidType;
    GUID                    guidSubtype;
    LPWSTR                  szItemName;

    // item data
    BYTE                    rgbPwd[A_SHA_DIGEST_LEN];
    BYTE                    rgbPwdLowerCase[A_SHA_DIGEST_LEN];
    LPWSTR                  szMasterKey;
    PST_ACCESSMODE          ModeFlags;

} OPENITEM_LIST_ITEM, *POPENITEM_LIST_ITEM;

class COpenItemList : public CLinkedList
{
//    CLinkedList list;

public:
    COpenItemList();


    BOOL             AddToList(POPENITEM_LIST_ITEM pli)
    {   return CLinkedList::AddToList((ELT*)pli);   }

    BOOL    DelFromList(POPENITEM_LIST_ITEM pli)
    {   return CLinkedList::DelFromList((ELT*)pli);  }

    POPENITEM_LIST_ITEM  SearchList(POPENITEM_LIST_ITEM pli)
    {   return (POPENITEM_LIST_ITEM)  CLinkedList::SearchList((ELT*)pli);  }
};


//////////////////////////
// Associated functions
void CreateOpenListItem(
        OPENITEM_LIST_ITEM* pli,
        PST_PROVIDER_HANDLE* phPSTProv,
        PST_KEY     Key,
        const GUID* pguidType,
        const GUID* pguidSubtype,
        LPCWSTR     szItemName);

BOOL OpenItemIsMatch(
        ELT* pCandidate,
        ELT* pTemplate);

void OpenItemFreeElt(
        ELT* pli);




//////////////////////
// User Authentication Cache list

// item list element
typedef struct _UACACHE_LIST_ITEM
{
    // internal to list
    struct _UACACHE_LIST_ITEM *      pNext;

    // Lookup devices: set by creator before adding to list
    LPWSTR                  szUserName;
    LPWSTR                  szMKName;
    LUID                    luidAuthID; // NT authentication ID

    // item data
    BYTE                    rgbPwd[A_SHA_DIGEST_LEN];
    BYTE                    rgbPwdLowerCase[A_SHA_DIGEST_LEN];

} UACACHE_LIST_ITEM, *PUACACHE_LIST_ITEM;

class CUAList : public CLinkedList
{

public:
    CUAList();

    BOOL                 AddToList(PUACACHE_LIST_ITEM pli)
    {   return CLinkedList::AddToList((ELT*)pli);   }

    BOOL    DelFromList(PUACACHE_LIST_ITEM pli)
    {   return CLinkedList::DelFromList((ELT*)pli);  }

    PUACACHE_LIST_ITEM   SearchList(PUACACHE_LIST_ITEM pli)
    {   return (PUACACHE_LIST_ITEM)  CLinkedList::SearchList((ELT*)pli);  }

};

///////////////////////////
// Associated functions
void CreateUACacheListItem(
        UACACHE_LIST_ITEM* pli,
        LPCWSTR     szUserName,
        LPCWSTR     szMKName,
        LUID        *pluidAuthID);

BOOL UACacheIsMatch(
        ELT* pCandidate,
        ELT* pTemplate);

void UACacheFreeElt(
        ELT* pli);



//////////////////////////////
// CryptProv list

// item list element
typedef struct _CRYPTPROV_LIST_ITEM
{
    // internal to list
    struct _CRYPTPROV_LIST_ITEM *      pNext;

    // Lookup device
//    DWORD                   dwProvID;
    DWORD                   dwAlgId1;
    DWORD                   dwKeySize1;

    DWORD                   dwAlgId2;
    DWORD                   dwKeySize2;

    // item data
    HCRYPTPROV              hProv;

} CRYPTPROV_LIST_ITEM, *PCRYPTPROV_LIST_ITEM;

class CCryptProvList : public CLinkedList
{

public:
    CCryptProvList();

    BOOL                AddToList(PCRYPTPROV_LIST_ITEM pli)
    {   return CLinkedList::AddToList((ELT*)pli);   }

    BOOL    DelFromList(PCRYPTPROV_LIST_ITEM pli)
    {   return CLinkedList::DelFromList((ELT*)pli);  }

    PCRYPTPROV_LIST_ITEM   SearchList(PCRYPTPROV_LIST_ITEM pli)
    {   return (PCRYPTPROV_LIST_ITEM)  CLinkedList::SearchList((ELT*)pli);  }

};


///////////////////////////
// Associated functions
void CreateCryptProvListItem(CRYPTPROV_LIST_ITEM* pli,
                        DWORD       dwAlgId1,
                        DWORD       dwKeySize1,
                        DWORD       dwAlgId2,
                        DWORD       dwKeySize2,
                        HCRYPTPROV  hCryptProv);

BOOL CryptProvIsMatch(
        ELT* pCandidate,
        ELT* pTemplate);

void CryptProvFreeElt(
        ELT* p);





#ifdef __cplusplus
}
#endif

#endif // __LNKLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\pch.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pch.cpp

Abstract:

    pch header files


Author:

    petesk 2/2/2000

Revision History:

    

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lm.h>

#include <shlobj.h>


// crypto headers
#include <sha.h>
#include <rc4.h>
#include <des.h>
#include <tripldes.h>
#include <modes.h>
#include <crypt.h>
#include <wincrypt.h>


#include "pstypes.h"
#include "dpapiprv.h"     // for registry entries
#include "pstprv.h"     // for registry entries
#include "pmacros.h"
#include "pstdef.h"

#include "unicode.h"
#include "unicode5.h"
#include "guidcnvt.h"
#include "secmisc.h"
#include "debug.h"
#include "primitiv.h"

#include "lnklist.h"
#include "misc.h"
#include "prov.h"
#include "secure.h"
#include "resource.h"
#include "dispif.h"

#pragma hdrstop


//#include "keyrpc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\passwd.cpp ===
/*
    File:       Passwd.cpp

    Title:      Protected Storage User Confirm wrappers
    Author:     Matt Thomlinson
    Date:       2/25/97

    Passwd.cpp simply houses a few of the password-management
    functions. These functions are called on to return the
    user-confirmation derived buffer, and check synchronization
    in certain cases.

    As the Authentication provider interface gets defined, this
    could end up getting moved into a seperate provider.



*/

#include <pch.cpp>
#pragma hdrstop




#include "provui.h"
#include "storage.h"

#include "passwd.h"



extern              DISPIF_CALLBACKS    g_sCallbacks;
extern              PRIVATE_CALLBACKS   g_sPrivateCallbacks;
extern              CUAList*            g_pCUAList;


///////////////////////////////////////////////////////////////////////
// non-user editable passwords

BOOL FIsUserMasterKey(LPCWSTR szMasterKey)
{
    if (0 == wcscmp(szMasterKey, WSZ_PASSWORD_WINDOWS))
        return FALSE;

    return TRUE;
}

BOOL    FMyGetWinPassword(
    PST_PROVIDER_HANDLE* phPSTProv,
    LPCWSTR szUser,
    BYTE rgbPwd[A_SHA_DIGEST_LEN] )
{
    // nab pwd
    if (0 == wcscmp(szUser, WSZ_LOCAL_MACHINE))
    {
        CopyMemory(rgbPwd, RGB_LOCALMACHINE_KEY, A_SHA_DIGEST_LEN);
    }
    else
    {
 /*
        if (! g_sPrivateCallbacks.pfnFGetWindowsPassword(
                phPSTProv,
                rgbPwd,
                A_SHA_DIGEST_LEN))
            return FALSE;
  */
        A_SHA_CTX context;
        DWORD cb = lstrlenW(szUser) * sizeof(WCHAR);
        BYTE Magic1[] = {0x66, 0x41, 0xa3, 0x29};
        BYTE Magic2[] = {0x14, 0x9a, 0xef, 0x82};

        A_SHAInit(&context);
        // note: the three Update calls get buffered up internally to
        // multiples of 64 bytes.
        //
        A_SHAUpdate(&context, Magic1, sizeof(Magic1));
        A_SHAUpdate(&context, (LPBYTE)szUser, cb);
        A_SHAUpdate(&context, Magic2, (cb+sizeof(Magic2)) % sizeof(Magic2));
        A_SHAFinal(&context, rgbPwd);
    }

    return TRUE;
}

// Base Provider specific fxn: check the password
DWORD BPVerifyPwd(
    PST_PROVIDER_HANDLE*    phPSTProv,
    LPCWSTR                 szUser,
    LPCWSTR                 szMasterKey,
    BYTE                    rgbPwd[],
    DWORD                   dwPasswordOption)
{
    DWORD dwRet = (DWORD)PST_E_WRONG_PASSWORD;

    if (dwPasswordOption != BP_CONFIRM_PASSWORDUI)
    {
        // only non-user keys can be silent (WinPWs only, to be exact)
        if (FIsUserMasterKey(szMasterKey))
            goto Ret;

        // get the Windows pwd
        if (!FMyGetWinPassword(phPSTProv, szUser, rgbPwd))
            goto Ret;

        // check
        if (!FCheckPWConfirm(
                szUser,
                szMasterKey,
                rgbPwd))
        {
            dwRet = (DWORD)PST_E_WRONG_PASSWORD;
            goto Ret;
        }
    }
    else    // UI wanted
    {
        // is it the windows password?
        if (0 == wcscmp(szMasterKey, WSZ_PASSWORD_WINDOWS))
        {
            BYTE rgbWinPwd[A_SHA_DIGEST_LEN];

            // we need to keep user, WinPW in sync
            if(!FMyGetWinPassword(
                    phPSTProv,
                    szUser,
                    rgbWinPwd
                    ))
            {
                dwRet = (DWORD)PST_E_WRONG_PASSWORD;
                goto Ret;
            }

            if (0 != memcmp(rgbWinPwd, rgbPwd, sizeof(rgbWinPwd) ))
            {
                // no match: user entered old password?
                if (FCheckPWConfirm(
                        szUser,
                        szMasterKey,
                        rgbPwd))
                {
                    // err: user entered neither old nor new password
                    dwRet = (DWORD)PST_E_WRONG_PASSWORD;
                    goto Ret;
                }
            }
            else
            {
                // matched: user entered password we consider good
                if (!FCheckPWConfirm(
                        szUser,
                        szMasterKey,
                        rgbPwd))
                {
                    dwRet = (DWORD)PST_E_WRONG_PASSWORD;
                    goto Ret;
                }
            }

        }
        else
        {
            // else: not win pw, just do pw correctness check
            if (!FCheckPWConfirm(
                    szUser,
                    szMasterKey,
                    rgbPwd))
            {
                dwRet = (DWORD)PST_E_WRONG_PASSWORD;
                goto Ret;
            }
        }
    }

    dwRet = (DWORD)PST_E_OK;
Ret:
    return dwRet;
}


HRESULT GetUserConfirmDefaults(
    PST_PROVIDER_HANDLE*    phPSTProv,
    DWORD*                  pdwDefaultConfirmationStyle,
    LPWSTR*                 ppszMasterKey)
{
    SS_ASSERT(ppszMasterKey != NULL);
    SS_ASSERT(pdwDefaultConfirmationStyle != NULL);

    PBYTE pbData = NULL;
    DWORD cbData;
    HRESULT hr = PST_E_FAIL;

    // if not found, restore the machine defaults

    // alloc sizeof string + dword
    cbData = sizeof(WSZ_PASSWORD_WINDOWS) + sizeof(DWORD);
    pbData = (PBYTE)SSAlloc(cbData);
    if(pbData == NULL)
        return PST_E_FAIL;

    // copy string, DWORD confirmation type
    *(DWORD*)pbData = BP_CONFIRM_OKCANCEL;
    CopyMemory(pbData+sizeof(DWORD), WSZ_PASSWORD_WINDOWS, sizeof(WSZ_PASSWORD_WINDOWS));

    // format: confirmation style DWORD, sz
    *pdwDefaultConfirmationStyle = *(DWORD*)pbData;
    *ppszMasterKey = (LPWSTR)SSAlloc(WSZ_BYTECOUNT((LPWSTR)(pbData+sizeof(DWORD))));

    if(*ppszMasterKey != NULL) {
        wcscpy(*ppszMasterKey, (LPWSTR) (pbData+sizeof(DWORD)) );
        hr = PST_E_OK;
    }

    // free what ConfigData returned
    if (pbData)
        SSFree(pbData);

    return hr;
}


void NotifyOfWrongPassword(
            HWND hwnd,
            LPCWSTR szItemName,
            LPCWSTR szPasswordName)
{
    LPWSTR szMessage;

    if (0 == wcscmp(szPasswordName, WSZ_PASSWORD_WINDOWS))
        szMessage = g_PasswordWinNoVerify;
    else
        szMessage = g_PasswordNoVerify;     // error doesn't deal with win pw

    MessageBoxW(hwnd, szMessage, szItemName, MB_OK | MB_SERVICE_NOTIFICATION);
}

// #define to force an unreadable confirmation to bail from read proc
#define PST_CF_STORED_ONLY  0xcf000001

HRESULT GetUserConfirmBuf(
    PST_PROVIDER_HANDLE*    phPSTProv,
    LPCWSTR                 szUser,
    PST_KEY                 Key,
    LPCWSTR                 szType,
    const GUID*             pguidType,
    LPCWSTR                 szSubtype,
    const GUID*             pguidSubtype,
    LPCWSTR                 szItemName,
    PPST_PROMPTINFO         psPrompt,
    LPCWSTR                 szAction,
    LPWSTR*                 ppszMasterKey,
    BYTE                    rgbPwd[A_SHA_DIGEST_LEN],
    DWORD                   dwFlags)
{
    return GetUserConfirmBuf(
        phPSTProv,
        szUser,
        Key,
        szType,
        pguidType,
        szSubtype,
        pguidSubtype,
        szItemName,
        psPrompt,
        szAction,
        PST_CF_STORED_ONLY,        // hardcoded: must be able to retreive in order to show ui
        ppszMasterKey,
        rgbPwd,
        dwFlags);
}

#define MAX_PASSWD_TRIALS 3

HRESULT GetUserConfirmBuf(
    PST_PROVIDER_HANDLE*    phPSTProv,
    LPCWSTR                 szUser,
    PST_KEY                 Key,
    LPCWSTR                 szType,
    const GUID*             pguidType,
    LPCWSTR                 szSubtype,
    const GUID*             pguidSubtype,
    LPCWSTR                 szItemName,
    PPST_PROMPTINFO         psPrompt,
    LPCWSTR                 szAction,
    DWORD                   dwDefaultConfirmationStyle,
    LPWSTR*                 ppszMasterKey,
    BYTE                    rgbOutPwd[A_SHA_DIGEST_LEN],
    DWORD                   dwFlags)
{
    HRESULT     hr;
    DWORD       dwStoredConfirm, dwChosenConfirm;
    LPWSTR      szCallerName = NULL;
    BOOL        fPromptedUser = FALSE;

    BOOL        fIsCached = FALSE;
    BOOL        fCacheItNow = FALSE;

    BOOL        fPwdVerified = FALSE;

    SS_ASSERT(*ppszMasterKey == NULL);   // don't whack existing memory


    if (Key == PST_KEY_LOCAL_MACHINE)
    {
        // short-circuit password gathering, setting
        *ppszMasterKey = (LPWSTR) SSAlloc(sizeof(WSZ_PASSWORD_WINDOWS));
        if( *ppszMasterKey == NULL )
        {
            hr = PST_E_FAIL;
            goto Ret;
        }

        wcscpy(*ppszMasterKey, WSZ_PASSWORD_WINDOWS);

        CopyMemory(rgbOutPwd, RGB_LOCALMACHINE_KEY, A_SHA_DIGEST_LEN);

        // done
        hr = PST_E_OK;
        goto Ret;
    }


    if (!g_sCallbacks.pfnFGetCallerName(phPSTProv, &szCallerName, NULL)) {
        hr = PST_E_FAIL;
        goto Ret;
    }

    // Which is this: item creation, item access?
    // item access does user authentication
    SS_ASSERT(szItemName != NULL);

    // per-item key
    if (PST_E_OK != (hr =
        BPGetItemConfirm(
            phPSTProv,
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &dwStoredConfirm,
            ppszMasterKey)) )
    {
        // this could be a failure in
        // * confirmation: tampering detected!!
        // * password: couldn't grab user pwd
        if (dwDefaultConfirmationStyle == PST_CF_STORED_ONLY)
            goto Ret;

        //
        // if UI is not allowed (eg, Local System account), over-ride
        // confirmation style.
        //
        if (dwDefaultConfirmationStyle != PST_CF_NONE)
        {
            if(!FIsProviderUIAllowed( szUser ))
                dwDefaultConfirmationStyle = PST_CF_NONE;
        }

        // if app asked to have no confirm, set item that way
        if (dwDefaultConfirmationStyle == PST_CF_NONE)
        {
            dwChosenConfirm = BP_CONFIRM_NONE;

            // short-circuit password gathering, setting
            *ppszMasterKey = (LPWSTR) SSAlloc(sizeof(WSZ_PASSWORD_WINDOWS));
            if(*ppszMasterKey == NULL)
            {
                hr = PST_E_FAIL;
                goto Ret;
            }
            wcscpy(*ppszMasterKey, WSZ_PASSWORD_WINDOWS);
        }
        else    // app allows user to decide
        {
            // get user default
            if (PST_E_OK != (hr = GetUserConfirmDefaults(
                    phPSTProv,
                    &dwChosenConfirm,
                    ppszMasterKey)) )
                goto Ret;
        }

        // if user default is silent, don't bother user
        switch(dwChosenConfirm)
        {
            // if no confirm
            case BP_CONFIRM_NONE:
                break;

            // if we know the confirm type
            case BP_CONFIRM_PASSWORDUI:
            {
                // make sure we're not asking the user for a password he can't satisfy
                if (!FIsUserMasterKey(*ppszMasterKey))
                {
                    hr = PST_E_NO_PERMISSIONS;
                    goto Ret;
                }

                // else fall through to prompting case
            }

            case BP_CONFIRM_OKCANCEL:
            {
                int i;
                fPromptedUser = TRUE;

                for(i=1;  ; i++)
                {
                    BYTE rgbOutPwdLowerCase[A_SHA_DIGEST_LEN];

                    // Request the user apply a new password
                    if (!FSimplifiedPasswordConfirm(
                            phPSTProv,
                            szUser,
                            szCallerName,
                            szType,
                            szSubtype,
                            szItemName,
                            psPrompt,
                            szAction,
                            ppszMasterKey,
                            &dwChosenConfirm,
                            TRUE,           // user select which pwd
                            rgbOutPwd,
                            A_SHA_DIGEST_LEN,
                            rgbOutPwdLowerCase,
                            A_SHA_DIGEST_LEN,
                            dwFlags
                            ))
                    {
                        hr = PST_E_NO_PERMISSIONS;
                        goto Ret;
                    }

                    // verify whatever password we got
                    if (PST_E_OK != (hr =
                        BPVerifyPwd(
                            phPSTProv,
                            szUser,
                            *ppszMasterKey,
                            rgbOutPwd,
                            dwChosenConfirm)) )
                    {

                        //
                        // try lower-case form to handle Win9x migration case.
                        //

                        if (PST_E_OK != (hr =
                            BPVerifyPwd(
                                phPSTProv,
                                szUser,
                                *ppszMasterKey,
                                rgbOutPwdLowerCase,
                                dwChosenConfirm)) )
                        {
                            // too many trials? break out of loop
                            if (i < MAX_PASSWD_TRIALS)
                            {
                                // notify user, give them another chance
                                NotifyOfWrongPassword((HWND)psPrompt->hwndApp, szItemName, *ppszMasterKey);

                                continue;
                            } else {
                                break;  // break out
                            }
                        } else {

                            CopyMemory( rgbOutPwd, rgbOutPwdLowerCase, A_SHA_DIGEST_LEN );

                        }
                    }

                    // passed verify password test: break out of loop!
                    fPwdVerified = TRUE;
                    break;
                }

                if (!fPwdVerified)
                {
                    hr = PST_E_NO_PERMISSIONS;
                    goto Ret;
                }
            }
        }


        // and remember the selections made
        if (PST_E_OK != (hr =
            BPSetItemConfirm(
                phPSTProv,
                szUser,
                pguidType,
                pguidSubtype,
                szItemName,
                dwChosenConfirm,
                *ppszMasterKey)) )
            goto Ret;

        // now, _this_ is the stored confirm
        dwStoredConfirm = dwChosenConfirm;
    }
    else
    {
        // keep a copy of the stored key
        LPWSTR szStoredMasterKey = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(*ppszMasterKey));
        if(NULL != szStoredMasterKey)
        {
            CopyMemory(szStoredMasterKey, *ppszMasterKey, WSZ_BYTECOUNT(*ppszMasterKey));
        }

        // we retrieved confirmation behavior
        dwChosenConfirm = dwStoredConfirm;  // already chosen for you

        switch (dwStoredConfirm)
        {
            // if no confirm
            case BP_CONFIRM_NONE:
                break;

            // if we know the confirm type
            case BP_CONFIRM_PASSWORDUI:
            {
                // else fall through to prompting case
            }

            case BP_CONFIRM_OKCANCEL:
            {
                // retrieved item, must show ui, but not allowed to show ui
                if (psPrompt->dwPromptFlags & PST_PF_NEVER_SHOW)
                {
                    hr = ERROR_PASSWORD_RESTRICTION;
                    goto Ret;
                }

                // found that a pwd is req'd
                fPromptedUser = TRUE;
                fCacheItNow = fIsCached;

                int i;

                for(i=1;  ; i++)
                {
                    BYTE rgbOutPwdLowerCase[A_SHA_DIGEST_LEN];

                    // ask the user for it
                    if (!FSimplifiedPasswordConfirm(
                            phPSTProv,
                            szUser,
                            szCallerName,
                            szType,
                            szSubtype,
                            szItemName,
                            psPrompt,
                            szAction,
                            ppszMasterKey,
                            &dwChosenConfirm,
                            TRUE,           // allow user to select pwd
                            rgbOutPwd,
                            A_SHA_DIGEST_LEN,
                            rgbOutPwdLowerCase,
                            A_SHA_DIGEST_LEN,
                            dwFlags
                            ))
                    {
                        hr = PST_E_NO_PERMISSIONS;
                        goto Ret;
                    }

                    // if we got it from the cache and user left it alone
                    {
                        // verify whatever password we got
                        if (PST_E_OK != (hr =
                            BPVerifyPwd(
                                phPSTProv,
                                szUser,
                                *ppszMasterKey,
                                rgbOutPwd,
                                dwChosenConfirm)) )
                        {
                            //
                            // check lower case form.
                            //

                            if (PST_E_OK != (hr =
                                BPVerifyPwd(
                                    phPSTProv,
                                    szUser,
                                    *ppszMasterKey,
                                    rgbOutPwdLowerCase,
                                    dwChosenConfirm)) )
                            {

                                // too many trials? break out of loop
                                if (i < MAX_PASSWD_TRIALS)
                                {
                                    // notify user, give them another chance
                                    NotifyOfWrongPassword((HWND)psPrompt->hwndApp, szItemName, *ppszMasterKey);

                                    continue;
                                }
                                else
                                {
                                    hr = PST_E_NO_PERMISSIONS;
                                    goto Ret;
                                }
                            } else {

                                CopyMemory( rgbOutPwd, rgbOutPwdLowerCase, A_SHA_DIGEST_LEN );
                            }
                        }

                        fPwdVerified = TRUE;
                    }

                    // passed verify password test: break out of loop!
                    break;
                }

                break;
            }

        } // end switch


        // have we received all data we need from the user?
        // user may choose to change the way items are encrypted;
        // if stored under password, we must make them enter the old pwd
        if ((dwStoredConfirm != dwChosenConfirm) ||                     // confirm type changed  OR
            (NULL == szStoredMasterKey) || 
            (0 != wcscmp(*ppszMasterKey, szStoredMasterKey)) )          // difft master key

        {
            BYTE rgbOldPwd[A_SHA_DIGEST_LEN];
            BOOL fDontAllowCache = FALSE;
            BOOL fOldPwdVerified = FALSE;

            PST_PROMPTINFO         sGetOldPWPrompt = {sizeof(PST_PROMPTINFO), psPrompt->dwPromptFlags, psPrompt->hwndApp, g_PasswordSolicitOld};

            // only re-display if originally passworded
            if (dwStoredConfirm == BP_CONFIRM_PASSWORDUI)
            {
                for(int i=1;  ; i++)
                {
                    BYTE rgbOldPwdLowerCase[A_SHA_DIGEST_LEN];

                    // ask the user for it
                    if (!FSimplifiedPasswordConfirm(
                            phPSTProv,
                            szUser,
                            szCallerName,
                            szType,
                            szSubtype,
                            szItemName,
                            &sGetOldPWPrompt,
                            szAction,
                            &szStoredMasterKey,
                            &dwStoredConfirm,
                            FALSE,           // don't allow user to get around this one
                            rgbOldPwd,
                            sizeof(rgbOldPwd),
                            rgbOldPwdLowerCase,
                            sizeof(rgbOldPwdLowerCase),
                            dwFlags
                            ))
                    {
                        hr = PST_E_NO_PERMISSIONS;
                        goto Ret;
                    }

                    // verify whatever password we got
                    if (PST_E_OK != (hr =
                        BPVerifyPwd(
                            phPSTProv,
                            szUser,
                            szStoredMasterKey,
                            rgbOldPwd,
                            dwStoredConfirm)) )
                    {
                        if (PST_E_OK != (hr =
                            BPVerifyPwd(
                                phPSTProv,
                                szUser,
                                szStoredMasterKey,
                                rgbOldPwdLowerCase,
                                dwStoredConfirm)) )
                        {
                            // too many trials? break out of loop
                            if (i < MAX_PASSWD_TRIALS)
                            {
                                // notify user, give them another chance
                                NotifyOfWrongPassword((HWND)sGetOldPWPrompt.hwndApp, szItemName, szStoredMasterKey);

                                continue;
                            } else {
                                break;  // break out
                            }
                        } else {
                            CopyMemory( rgbOldPwd, rgbOldPwdLowerCase, A_SHA_DIGEST_LEN );
                        }
                    }

                    // passed verify password test: break out of loop!
                    fOldPwdVerified = TRUE;
                    break;
                }

                if (!fOldPwdVerified)
                {
                    hr = PST_E_NO_PERMISSIONS;
                    goto Ret;
                }
            }
            else
            {
                // ok/cancel; silent pwd usage

                // use VerifyPwd fxn to retrieve the pwd
                if (PST_E_OK != (hr =
                    BPVerifyPwd(
                        phPSTProv,
                        szUser,
                        szStoredMasterKey,
                        rgbOldPwd,
                        dwStoredConfirm)) )
                {
                    hr = PST_E_NO_PERMISSIONS;
                    goto Ret;
                }
            }

            //////
            // execute pwd change HERE
            {
                PBYTE pbData = NULL;
                DWORD cbData;

                // FBPGetSecuredItemData        // decrypt data with old
                if (!FBPGetSecuredItemData(
                        szUser,
                        szStoredMasterKey,
                        rgbOldPwd,
                        pguidType,
                        pguidSubtype,
                        szItemName,
                        &pbData,
                        &cbData))
                {
                    hr = PST_E_STORAGE_ERROR;
                    goto Ret;
                }

                // FBPSetSecuredItemData        // encrypt data with new
                if (!FBPSetSecuredItemData(
                        szUser,
                        *ppszMasterKey,
                        rgbOutPwd,
                        pguidType,
                        pguidSubtype,
                        szItemName,
                        pbData,
                        cbData))
                {
                    hr = PST_E_STORAGE_ERROR;
                    goto Ret;
                }

                if (pbData)
                    SSFree(pbData);

                // BPSetItemConfirm             // store new confirm type
                if (PST_E_OK !=
                    BPSetItemConfirm(
                        phPSTProv,
                        szUser,
                        pguidType,
                        pguidSubtype,
                        szItemName,
                        dwChosenConfirm,
                        *ppszMasterKey))
                {
                    hr = PST_E_STORAGE_ERROR;
                    goto Ret;
                }
            }

        }


        if (szStoredMasterKey)
        {
            SSFree(szStoredMasterKey);
            szStoredMasterKey = NULL;
        }
    }



    // verify whatever password we got if not yet verified
    if (!fPwdVerified)
    {
        if (PST_E_OK != (hr =
            BPVerifyPwd(
                phPSTProv,
                szUser,
                *ppszMasterKey,
                rgbOutPwd,
                dwChosenConfirm)) )
            goto Ret;
    }

    // Now correct pwd is in rgbOutPwd ALWAYS

    // if we haven't prompted user and were supposed to
    if (!fPromptedUser && (psPrompt->dwPromptFlags == PST_PF_ALWAYS_SHOW))
    {
        // we must've retrieved from cache OR Automagic WinPW
        SS_ASSERT(fIsCached || (BP_CONFIRM_NONE == dwStoredConfirm));

        BYTE rgbBarfPwd[A_SHA_DIGEST_LEN*2];
        BYTE rgbBarfPwdLowerCase[A_SHA_DIGEST_LEN];

        // haven't prompted user but must confirm
        if (!FSimplifiedPasswordConfirm(
                phPSTProv,
                szUser,
                szCallerName,
                szType,
                szSubtype,
                szItemName,
                psPrompt,
                szAction,
                ppszMasterKey,
                &dwChosenConfirm,
                FALSE,
                rgbBarfPwd,
                sizeof(rgbBarfPwd),
                rgbBarfPwdLowerCase,
                sizeof(rgbBarfPwdLowerCase),
                dwFlags
                ) )
        {
            hr = PST_E_NO_PERMISSIONS;
            goto Ret;
        }

    }

    hr = PST_E_OK;
Ret:

    if (szCallerName)
        SSFree(szCallerName);

    return hr;
}



HRESULT ShowOKCancelUI(
    PST_PROVIDER_HANDLE*    phPSTProv,
    LPCWSTR                 szUser,
    PST_KEY                 Key,
    LPCWSTR                 szType,
    LPCWSTR                 szSubtype,
    LPCWSTR                 szItemName,
    PPST_PROMPTINFO         psPrompt,
    LPCWSTR                 szAction)
{
    BOOL fCache = FALSE;
    BYTE rgbTrash[A_SHA_DIGEST_LEN*2];
    BYTE rgbTrashLowerCase[A_SHA_DIGEST_LEN];
    DWORD dwConfirmOptions = BP_CONFIRM_OKCANCEL;

    LPWSTR szMasterKey = NULL;
    LPWSTR szCallerName = NULL;

    DWORD dwRet = PST_E_FAIL;

    if (Key == PST_KEY_LOCAL_MACHINE)
    {
        // done
        dwRet = PST_E_OK;
        goto Ret;
    }

    szMasterKey = (LPWSTR)SSAlloc(sizeof(WSZ_NULLSTRING));

    if(szMasterKey)
    {
        wcscpy(szMasterKey, WSZ_NULLSTRING);
    }

    if (!g_sCallbacks.pfnFGetCallerName(phPSTProv, &szCallerName, NULL))
        goto Ret;

    if (!FSimplifiedPasswordConfirm(
            phPSTProv,
            szUser,
            szCallerName,
            szType,
            szSubtype,
            szItemName,
            psPrompt,
            szAction,
            &szMasterKey,
            &dwConfirmOptions,
            FALSE,
            rgbTrash,
            sizeof(rgbTrash),
            rgbTrashLowerCase,
            sizeof(rgbTrashLowerCase),
            0
            ) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (szCallerName)
        SSFree(szCallerName);

    if (szMasterKey)
        SSFree(szMasterKey);

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\prov.h ===
///////////////////////////////////////////////////////////////////////////////
// Base provider defines

#define WSZ_NULLSTRING          L""

// UI behavior types
#define BP_CONFIRM_NONE            0x00000002   // never ask for pwd 
#define BP_CONFIRM_PASSWORDUI      0x00000004   // password
#define BP_CONFIRM_OKCANCEL        0x00000008   // ok / cancel box


#define WSZ_PASSWORD_WINDOWS    L"Windows"

#define WSZ_LOCAL_MACHINE       L"*Local Machine*"
// #define WSZ_LOCALMACHINE_MKNAME L"Machine Default"

static 
BYTE RGB_LOCALMACHINE_KEY[] = 
    {  0x12, 0x60, 0xBF, 0x5C, 0x0B, 
       0x36, 0x7E, 0x1B, 0xFE, 0xF9,
       0xFC, 0x6B, 0x25, 0x36, 0x99,
       0x98, 0x5A, 0xCB, 0xB2, 0x8C };


// UNDONE UNDONE:
// make this live in general protected storage config area

#define PST_BASEPROV_SUBTYPE_STRING     L"MS Base Provider"
// 7F019FC0-AAC0-11d0-8C68-00C04FC297EB 
#define PST_BASEPROV_SUBTYPE_GUID                       \
{                                                       \
    0x7f019fc0,                                         \
    0xaac0,                                             \
    0x11d0,                                             \
    { 0x8c, 0x68, 0x0, 0xc0, 0x4f, 0xc2, 0x97, 0xeb }   \
}

// items that live in the base provider config area
#define WSZ_CONFIG_USERCONFIRM_DEFAULTS    L"User Confirmation Defaults"



//////////////////
// Protect APIs

// stored at base protect key
#define     REGSZ_DEFAULT_ALLOW_CACHEPW         L"AllowCachePW"

// stored at provider subkey
#define     REGSZ_DEFAULT_ENCR_ALG              L"Encr Alg"
#define     REGSZ_DEFAULT_MAC_ALG               L"MAC Alg"
#define     REGSZ_DEFAULT_ENCR_ALG_KEYSIZE      L"Encr Alg Key Size"
#define     REGSZ_DEFAULT_MAC_ALG_KEYSIZE       L"MAC Alg Key Size"
#define     REGSZ_DEFAULT_CRYPT_PROV_TYPE       L"Default CSP Type"

BOOL FInitProtectAPIGlobals();
BOOL FDeleteProtectAPIGlobals();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\secure.cpp ===
/*
    File:       Secure.cpp

    Title:      Cryptographic Funcs for Protected Storage
    Author:     Matt Thomlinson
    Date:       11/18/96

    Builds up usable cryptographic functionality and exports for
    usage by storage module. Since CryptoAPI base provider may call
    us, we can't use CryptXXX primitives (circular dependencies
    may result). Instead, we build up functions from SHA-1
    hash and DES-CBC primitives to Encrypt/Decrypt key blocks, MAC
    items, and check password confirmation blocks.


    **Master Key Usage**

    Encryption is done in a strange way to ease password management
    headaches.

        // derive a key from the user password, and the password-unique salt
        // Salt foils certain (dictionary) attacks on the password

        // PWSalt is PASSWORD_SALT_LEN
        // UserPW is SHA-1 hash of password excluding zt
        // DerivedKey1 is 56-bit DES key

            DerivedKey1 = DeriveKey(UserPW | PWSalt);


        // using the derived key, decrypt the encrypted master keys

        // encrypted master keys are E(master key bits | pwd confirm bits)

            MasterBits | PwdConfirmBits = Decrypt( (MasterKey|PwdConfirmKey), DerivedKey1);


        // Now we have recovered keys
        // MasterKey, PwdConfirmKey are 56-bit DES keys

            MasterKey
            PwdConfirmKey


        // check to make sure this is correct MasterKey by MACing
        // the global confirmation string and checking against stored MAC

            PwdConfirmMAC = HMAC(g_ConfirmBuf, PwdConfirmKey)
            if (0 != memcmp(PwdConfirmMac, rgbStoredMAC, 20)
                // wrong pwd!!


    We've derived a master key that we can create reproducibly and
    be changed without touching every item encrypted by it. That is,
    If the user changes the password, we simply need to keep the
    MasterBits constant and Encrypt with the new DerivedKey1 to find
    the EncryptedMasterBits to write to disk. In this way, we can change
    the password without changing the (exceedingly long) master key.

    We also have an immediate indication of whether or not the password
    used to decrypt the master key is correct.


    **Encrypting/MACing a single item**

        // assume we have 56-bit DES MasterKey from above
        // use master key to decrypt the encrypted item keyblock
        // key block holds two keys: Item key and MAC key

            ItemKeyBits | MACKeyBits = Decrypt( (ItemKey|MACKey), MasterKey);

        // Recovered two DES keys
        // ItemKey is 56 bits
        // MACKey is 56 bits

            ItemKey
            MACKey

        // MAC the item

            ItemMAC = HMAC(pbItemData, MACKey);

        // Tack the items' MAC onto the item, and encrypt

            EncryptedItem = ENCRYPTED_DATA_VER | Encrypt(pbItemData | ItemMAC, ItemKey);

    We've succeeded in encrypting and MACing an item using the single DES
    MasterKey from above. The item is both privacy and integrity protected.


  **Derive Key**
  **HMAC**

    Above we've skimmed over the definition of key derivation and HMAC.
    See primitiv.cpp for a description of how this primitive
    functionality is implemented.


    //  Format of the encrypted item data stream:
    //  version | size(keyblk) | keyblk | size(encryptedblk) | Encrypted{ size(data) | data | size(MAC) | MAC}



*/

#include <pch.cpp>
#pragma hdrstop
#include "storage.h"




// from des.h
#define DES_KEYLEN 8


// MAC buffer we use to check correct decryption
static      BYTE g_rgbConfirmBuf[] = "(c) 1996 Microsoft, All Rights Reserved";



// Data Version
//
// #define     ENCRYPTED_DATA_VER     0x01
// 6-12-97: version incremented. Previous versions
// should use MyOldPrimitiveHMAC -- different MAC attached to items
#define     ENCRYPTED_DATA_VER          0x02

// MK Version
//
// #define     ENCRYPTED_MASTERKEY_VER     0x01
// 6-12-97: version incremented. Previous versions
// should use MyOldPrimitiveHMAC -- different MAC attached to items
// #define     ENCRYPTED_MASTERKEY_VER     0x02
// 5-3-99: version incremented. Previous versions
// should use sizeof(rgbpwd)
#define     ENCRYPTED_MASTERKEY_VER     0x03


// given pwd, salt, and ptr to master key buffer,
// decrypts and checks MAC on master key
BOOL FMyDecryptMK(
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],
            BYTE    rgbConfirm[A_SHA_DIGEST_LEN],
            PBYTE*  ppbMK,
            DWORD*  pcbMK)
{

    BOOL fResetSecurityState;

    return FMyDecryptMKEx(
            rgbSalt,
            cbSalt,
            rgbPwd,
            rgbConfirm,
            ppbMK,
            pcbMK,
            &fResetSecurityState
            );

}

BOOL
FMyDecryptMKEx(
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],
            BYTE    rgbConfirm[A_SHA_DIGEST_LEN],
            PBYTE*  ppbMK,
            DWORD*  pcbMK,
            BOOL    *pfResetSecurityState
            )
{
    BOOL fRet = FALSE;
    DESKEY  sDerivedKey1;
    DESKEY  sConfirmKey;
    DWORD   dwMKVersion;

    BYTE    rgbHMACResult[A_SHA_DIGEST_LEN];


    // version check!!
    dwMKVersion = *(DWORD*)*ppbMK;
    if (ENCRYPTED_MASTERKEY_VER < dwMKVersion)
        goto Ret;


    if( dwMKVersion < 0x03 ) {

        *pfResetSecurityState = TRUE;

        // DK1 = DeriveKey(SHA(pw), Salt)
        if (!FMyPrimitiveDeriveKey(
                rgbSalt,
                cbSalt,
                rgbPwd,
                sizeof(rgbPwd),
                &sDerivedKey1))
            goto Ret;

    } else {

        *pfResetSecurityState = FALSE;

        // DK1 = DeriveKey(SHA(pw), Salt)
        if (!FMyPrimitiveDeriveKey(
                rgbSalt,
                cbSalt,
                rgbPwd,
                A_SHA_DIGEST_LEN,
                &sDerivedKey1))
            goto Ret;
    }



    *pcbMK -= sizeof(DWORD);
    MoveMemory(*ppbMK, *ppbMK + sizeof(DWORD), *pcbMK); // shift data left 1 dw, splat version
    *ppbMK = (PBYTE)SSReAlloc(*ppbMK, *pcbMK);
    if (*ppbMK == NULL)     // check allocation
        goto Ret;


    // Decrypt MK bits
    if (!FMyPrimitiveDESDecrypt(
            *ppbMK,
            pcbMK,
            sDerivedKey1))
        goto Ret;

    // assumes is at least 2*DES_KEYLEN bytes
    if (*pcbMK != 2*DES_KEYLEN)
        goto Ret;

    if (!FMyMakeDESKey(
            &sConfirmKey,               // out
            *ppbMK + DES_KEYLEN))       // in
        goto Ret;

    if (dwMKVersion == 0x01)
    {
        // items created with tag 0x01 used different HMACing algorithm
        if (!FMyOldPrimitiveHMAC(
                sConfirmKey,
                g_rgbConfirmBuf,
                sizeof(g_rgbConfirmBuf),
                rgbHMACResult))
            goto Ret;
    }
    else
    {
        if (!FMyPrimitiveHMAC(
                sConfirmKey,
                g_rgbConfirmBuf,
                sizeof(g_rgbConfirmBuf),
                rgbHMACResult))
            goto Ret;
    }

    if (0 != memcmp(rgbHMACResult, rgbConfirm, A_SHA_DIGEST_LEN))
        goto Ret;

    fRet = TRUE;
Ret:

    return fRet;
}

// retrieve key block and derive Item/MAC keys using MK
BOOL FMyDecryptKeyBlock(
            LPCWSTR szUser,
            LPCWSTR szMasterKey,
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],
            PBYTE   pbKeyBlock,
            DWORD   cbKeyBlock,
            DESKEY* psItemKey,
            DESKEY* psMacKey)
{
    BOOL    fRet = FALSE;

    DESKEY  sMK;

    BYTE    rgbSalt[PASSWORD_SALT_LEN];
    BYTE    rgbConfirm[A_SHA_DIGEST_LEN];

    PBYTE   pbMK = NULL;
    DWORD   cbMK;

    if (!FBPGetSecurityState(
            szUser,
            szMasterKey,
            rgbSalt,
            sizeof(rgbSalt),
            rgbConfirm,
            sizeof(rgbConfirm),
            &pbMK,
            &cbMK))
        return FALSE;

    // unwrap master key
    if (!FMyDecryptMK(
            rgbSalt,
            sizeof(rgbSalt),
            rgbPwd,
            rgbConfirm,
            &pbMK,
            &cbMK
            ))
        goto Ret;


    // assumes pbMK is at least 2*DES_KEYLEN bytes
    if (cbMK != 2*DES_KEYLEN)
        goto Ret;

    if (!FMyMakeDESKey(
            &sMK,            // out
            pbMK))           // in
        goto Ret;

    // use MK to decrypt key block
    if (!FMyPrimitiveDESDecrypt(
            pbKeyBlock,
            &cbKeyBlock,
            sMK))
        goto Ret;

    // fill in ItemKey, MacKey from decrypted key block
    if (cbKeyBlock != 2*DES_KEYLEN)
        goto Ret;

    // assumes pbKeyBlock is at least 2*DES_KEYLEN bytes
    if (!FMyMakeDESKey(
            psItemKey,       // out
            pbKeyBlock))     // in
        goto Ret;
    if (!FMyMakeDESKey(
            psMacKey,        // out
            pbKeyBlock + DES_KEYLEN)) // in
        goto Ret;

    fRet = TRUE;
Ret:

    if(pbMK != NULL) {
        ZeroMemory(pbMK, cbMK); // sfield: zero it
        SSFree(pbMK);   // sfield: fix illusive memory leak
    }

    return fRet;
}

// given encrypted data and password, decrypt and check MAC on data
BOOL FProvDecryptData(
            LPCWSTR szUser,         // in
            LPCWSTR szMasterKey,    // in
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],       // in
            PBYTE*  ppbMyData,      // in out
            DWORD*  pcbMyData)      // in out
{
    BOOL fRet = FALSE;

    DESKEY  sItemKey;
    DESKEY  sMacKey;

    BYTE    rgbHMAC[A_SHA_DIGEST_LEN];

    DWORD   dwDataVer;


    // pointers to teardown stream
    PBYTE   pbCurPtr = *ppbMyData;

    PBYTE   pbSecureData;
    DWORD   cbSecureData;

    PBYTE   pbInlineKeyBlock;
    DWORD   cbInlineKeyBlock;

    PBYTE   pbDecrypted;
    DWORD   cbDecrypted;

    PBYTE   pbMAC;
    DWORD   cbMAC;

//  ENCRYPTED ITEM DATA FORMAT:
//  version | size(keyblk) | keyblk | size(encryptedblk) | Encrypted{ size(data) | data | size(MAC) | MAC}

    // version check -- only handle V1 data for now
    dwDataVer = *(DWORD*)pbCurPtr;
    if (ENCRYPTED_DATA_VER < dwDataVer)
        goto Ret;
    pbCurPtr += sizeof(DWORD);

    // pointers to key block
    cbInlineKeyBlock = *(DWORD UNALIGNED *)pbCurPtr;       // keyblock size
    pbCurPtr += sizeof(DWORD);                  // fwd past size
    pbInlineKeyBlock = pbCurPtr;                // points to key block
    pbCurPtr += cbInlineKeyBlock;               // fwd past data

    // pointers to secure data
    cbSecureData = *(DWORD UNALIGNED *)pbCurPtr;           // secure data size member
    pbCurPtr += sizeof(DWORD);                  // fwd past size
    pbSecureData = pbCurPtr;                    // points to secure data

    // retrieve key block using MK, etc
    if (!FMyDecryptKeyBlock(
            szUser,
            szMasterKey,
            rgbPwd,
            pbInlineKeyBlock,
            cbInlineKeyBlock,
            &sItemKey,
            &sMacKey))
        goto Ret;

    // keys derived, now recover data inplace
    if (!FMyPrimitiveDESDecrypt(
            pbSecureData,
            &cbSecureData,
            sItemKey))
        goto Ret;

    cbDecrypted = *(DWORD UNALIGNED *)pbCurPtr;            // plaintext size
    pbCurPtr += sizeof(DWORD);                  // fwd past size
    pbDecrypted = pbCurPtr;                     // points to plaintext
    pbCurPtr += cbDecrypted;                    // fwd past data

    // pointers to HMAC
    cbMAC = *(DWORD UNALIGNED *)pbCurPtr;                  // MAC size member
    pbCurPtr += sizeof(DWORD);                  // fwd past size
    pbMAC = pbCurPtr;                           // points to MAC
    pbCurPtr += cbMAC;                          // fwd past data

    if (A_SHA_DIGEST_LEN != cbMAC)              // verify HMAC size member
        goto Ret;


    // chk MAC

    // Compute HMAC over plaintext data

    if (dwDataVer == 0x01)
    {
        // version 0x1 used different HMAC code
        if (!FMyOldPrimitiveHMAC(
                sMacKey,
                pbDecrypted,
                cbDecrypted,
                rgbHMAC))
            goto Ret;
    }
    else
    {
        if (!FMyPrimitiveHMAC(
                sMacKey,
                pbDecrypted,
                cbDecrypted,
                rgbHMAC))
            goto Ret;
    }

    // now compare against HMAC in tail of msg
    if (0 != memcmp(pbMAC, rgbHMAC, A_SHA_DIGEST_LEN))
        goto Ret;

    // if everything went well, return secure data (shift to far left, realloc)
    MoveMemory(*ppbMyData, pbDecrypted, cbDecrypted);

    *ppbMyData = (PBYTE)SSReAlloc(*ppbMyData, cbDecrypted);
    if (*ppbMyData == NULL)     // check allocation
        goto Ret;

    *pcbMyData = cbDecrypted;


    fRet = TRUE;
Ret:
    // TODO free ppbMyData on failure?
    return fRet;
}

// given pwd, salt, and Master Key buffer, MACs and Encrypts Master Key buffer
BOOL FMyEncryptMK(
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],
            BYTE    rgbConfirm[A_SHA_DIGEST_LEN],
            PBYTE*  ppbMK,
            DWORD*  pcbMK)
{
    BOOL fRet = FALSE;
    DESKEY  sDerivedKey1;
    DESKEY  sConfirmKey;

    // assumes pbKeyBlock is at least 2*DES_KEYLEN bytes
    if (*pcbMK != 2*DES_KEYLEN)
        goto Ret;

    // confirmation key is 2nd in buffer
    if (!FMyMakeDESKey(
            &sConfirmKey,    // out
            *ppbMK + DES_KEYLEN))     // in
        goto Ret;


    if (!FMyPrimitiveHMAC(
            sConfirmKey,
            g_rgbConfirmBuf,
            sizeof(g_rgbConfirmBuf),
            rgbConfirm))
        goto Ret;

    // DK1 = DeriveKey(SHA(pw), Salt)
    if (!FMyPrimitiveDeriveKey(
            rgbSalt,
            cbSalt,
            rgbPwd,
            A_SHA_DIGEST_LEN, ///sizeof(rgbPwd),
            &sDerivedKey1))
        goto Ret;

    // Encrypt MK w/ DK1, return
    if (!FMyPrimitiveDESEncrypt(
            ppbMK,
            pcbMK,
            sDerivedKey1))
        goto Ret;

    // Mash version onto front!!
    *ppbMK = (PBYTE)SSReAlloc(*ppbMK, *pcbMK+sizeof(DWORD));   // realloc bigger for ver
    if (*ppbMK == NULL)     // check allocation
        goto Ret;

    MoveMemory(*ppbMK+sizeof(DWORD), *ppbMK, *pcbMK);   // move data 1 dw right
    *pcbMK += sizeof(DWORD);                            // inc size
    *(DWORD*)(*ppbMK) = (DWORD)ENCRYPTED_MASTERKEY_VER; // whack version in there!


    fRet = TRUE;
Ret:
    return fRet;
}


// returns a new key block encrypted with master key
// creates and stores master key state if none exists
BOOL FMyEncryptKeyBlock(
            LPCWSTR szUser,
            LPCWSTR szMasterKey,
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],
            PBYTE*  ppbKeyBlock,
            DWORD*  pcbKeyBlock,
            DESKEY* psItemKey,
            DESKEY* psMacKey)
{
    BOOL    fRet = FALSE;
    *ppbKeyBlock = NULL;

    BYTE    rgbSalt[PASSWORD_SALT_LEN];
    BYTE    rgbConfirm[A_SHA_DIGEST_LEN];

    PBYTE   pbMK = NULL;
    DWORD   cbMK;

    PBYTE   pbTmp = NULL;
    DWORD   cbTmp;

    DESKEY  sMK;

    // gen a random key block: 2 keys
    *pcbKeyBlock = 2*DES_KEYLEN;
    *ppbKeyBlock = (PBYTE) SSAlloc(*pcbKeyBlock + DES_BLOCKLEN);    // performance fudge factor (realloc)
    if (*ppbKeyBlock == NULL)     // check allocation
        goto Ret;

    if (!RtlGenRandom(*ppbKeyBlock, *pcbKeyBlock))
        goto Ret;

    // INSERT: FRENCH GOVT. THOUGHT CONTROL CODE
    if (! FIsEncryptionPermitted())
    {
        // Protected Storage addition, 5/27/97
        // If encryption is not allowed, pretend faulty
        // RNG generated encryption key { 6d 8a 88 6a   4e aa 37 a8 }

        SS_ASSERT(DES_KEYLEN == sizeof(DWORD)*2);

        *(DWORD*)(*ppbKeyBlock) = 0x6d8a886a;
        *(DWORD*)(*ppbKeyBlock + sizeof(DWORD)) = 0x4eaa37a8;


        // PS: Remind me not to move to FRANCE
    }


    // assumes pbKeyBlock is at least 2*DES_KEYLEN bytes
    SS_ASSERT(*pcbKeyBlock == 2*DES_KEYLEN);

    if (!FMyMakeDESKey(
            psItemKey,                  // out
            *ppbKeyBlock))     // in
        goto Ret;

    if (!FMyMakeDESKey(
            psMacKey,          // out
            *ppbKeyBlock + DES_KEYLEN))     // in
        goto Ret;

    // first derive a key from PW
    if (FBPGetSecurityState(
            szUser,
            szMasterKey,
            rgbSalt,
            sizeof(rgbSalt),
            rgbConfirm,
            sizeof(rgbConfirm),
            &pbMK,
            &cbMK))
    {
        // unwrap master key
        if (!FMyDecryptMK(
                rgbSalt,
                sizeof(rgbSalt),
                rgbPwd,
                rgbConfirm,
                &pbMK,
                &cbMK))
            goto Ret;

        // done, have MK unwrapped.
    }
    else
    {
        // if we couldn't retrieve state, assume we must generate it
        if (!RtlGenRandom(rgbSalt, PASSWORD_SALT_LEN))
            goto Ret;

        cbMK = 2*DES_KEYSIZE;
        pbMK = (PBYTE)SSAlloc(cbMK + DES_BLOCKLEN);     // performance fudge factor (realloc)
        if (pbMK == NULL)     // check allocation
            goto Ret;

        if (!RtlGenRandom(pbMK, cbMK))
            goto Ret;

        // this is final MK: encrypt a copy
        cbTmp = cbMK;
        pbTmp = (PBYTE)SSAlloc(cbTmp);
        if (pbTmp == NULL)     // check allocation
            goto Ret;

        CopyMemory(pbTmp, pbMK, cbMK);


        // now wrap MK up and stuff in registry
        if (!FMyEncryptMK(
                rgbSalt,
                sizeof(rgbSalt),
                rgbPwd,
                rgbConfirm,
                &pbTmp,
                &cbTmp))
            goto Ret;

        if (!FBPSetSecurityState(
                szUser,
                szMasterKey,
                rgbSalt,
                PASSWORD_SALT_LEN,
                rgbConfirm,
                sizeof(rgbConfirm),
                pbTmp,
                cbTmp))
            goto Ret;

    }

    if (cbMK != 2*DES_KEYSIZE)
        goto Ret;

    if (!FMyMakeDESKey(
            &sMK,           // out
            pbMK))          // in
        goto Ret;

    if (*pcbKeyBlock != 2*DES_KEYLEN)
        goto Ret;

    if (!FMyPrimitiveDESEncrypt(
            ppbKeyBlock,
            pcbKeyBlock,
            sMK))
        goto Ret;

    fRet = TRUE;
Ret:
    if (!fRet)
    {
        if (*ppbKeyBlock) {
            SSFree(*ppbKeyBlock);
            *ppbKeyBlock = NULL;
        }
    }

    if (pbMK) {
        ZeroMemory(pbMK, cbMK);
        SSFree(pbMK);
    }

    if (pbTmp) {
        ZeroMemory(pbTmp, cbTmp); // sfield: zero memory
        SSFree(pbTmp);
    }

    return fRet;
}

// given data, will generate a key block and
// return encrypt/mac'd data
BOOL FProvEncryptData(
            LPCWSTR szUser,         // in
            LPCWSTR szMasterKey,    // in
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],       // in
            PBYTE*  ppbMyData,      // in out
            DWORD*  pcbMyData)      // in out
{
    BOOL fRet = FALSE;

    DESKEY  sItemKey;
    DESKEY  sMacKey;

    BYTE    rgbHMAC[A_SHA_DIGEST_LEN];

    // helpful pointers
    PBYTE   pbCurPtr = *ppbMyData;

    PBYTE   pbKeyBlock = NULL;
    DWORD   cbKeyBlock = 0;

    DWORD   cbDataSize;

    // return an item key, mac key
    // store in an encrypted key block using MK, etc.
    if (!FMyEncryptKeyBlock(
            szUser,
            szMasterKey,
            rgbPwd,
            &pbKeyBlock,
            &cbKeyBlock,
            &sItemKey,
            &sMacKey))
        goto Ret;

    // now secure data

    // Compute HMAC
    if (!FMyPrimitiveHMAC(sMacKey, *ppbMyData, *pcbMyData, rgbHMAC))
        goto Ret;

//  DATA FORMAT:
//  version | size(keyblk) | keyblk | size(encryptedblk) | Encrypted{ size(data) | data | size(MAC) | MAC}

    // lengthen data seg by data size member, MAC and MAC size member
    cbDataSize = *pcbMyData;                            // save current size
    *pcbMyData += A_SHA_DIGEST_LEN + 2*sizeof(DWORD);   // sizeof(data), MAC, sizeof(MAC)
    *ppbMyData = (PBYTE)SSReAlloc(*ppbMyData, *pcbMyData);
    if (*ppbMyData == NULL)     // check allocation
        goto Ret;

    pbCurPtr = *ppbMyData;

    // size, data
    MoveMemory(pbCurPtr+sizeof(DWORD), pbCurPtr, cbDataSize); // shift right data for size insertion
    *(DWORD UNALIGNED *)pbCurPtr = cbDataSize;                     // size of data
    pbCurPtr += sizeof(DWORD);                          // fwd past size
    pbCurPtr += cbDataSize;                             // fwd past data

    // size, MAC
    *(DWORD UNALIGNED *)pbCurPtr = A_SHA_DIGEST_LEN;               // size of MAC
    pbCurPtr += sizeof(DWORD);                          // fwd past size
    CopyMemory(pbCurPtr, rgbHMAC, A_SHA_DIGEST_LEN);    // MAC
    pbCurPtr += A_SHA_DIGEST_LEN;                       // fwd past MAC

    if (!FMyPrimitiveDESEncrypt(
            ppbMyData,      // in out
            pcbMyData,      // in out
            sItemKey))
        goto Ret;

    cbDataSize = *pcbMyData;                            // save current size
    *pcbMyData += 3*sizeof(DWORD) + cbKeyBlock;         // ver, sizeof(keyblk), keyblk, sizeof(encrdata)
    *ppbMyData = (PBYTE)SSReAlloc(*ppbMyData, *pcbMyData);
    if (*ppbMyData == NULL)     // check allocation
        goto Ret;

    pbCurPtr = *ppbMyData;

    // shift right data for size, keyblk insertions
    MoveMemory(pbCurPtr + 3*sizeof(DWORD) + cbKeyBlock, pbCurPtr, cbDataSize);

    // throw version tag in front
    *(DWORD UNALIGNED *)pbCurPtr = (DWORD)ENCRYPTED_DATA_VER;
    pbCurPtr += sizeof(DWORD);

    // insert keyblock
    *(DWORD UNALIGNED *)pbCurPtr = cbKeyBlock;                     // size of data
    pbCurPtr += sizeof(DWORD);                          // fwd past size
    CopyMemory(pbCurPtr, pbKeyBlock, cbKeyBlock);       // data
    pbCurPtr += cbKeyBlock;                             // fwd past data

    // insert sizeof encrypted blob
    *(DWORD UNALIGNED *)pbCurPtr = cbDataSize;                     // size of data


    fRet = TRUE;
Ret:
    ZeroMemory(&sItemKey, sizeof(DESKEY));
    ZeroMemory(&sMacKey, sizeof(DESKEY));

    if (pbKeyBlock)
        SSFree(pbKeyBlock);

    return fRet;
}

// given password, and master key, will decrypt and
// verify MAC on master key
BOOL FCheckPWConfirm(
        LPCWSTR szUser,         // in
        LPCWSTR szMasterKey,    // in
        BYTE    rgbPwd[A_SHA_DIGEST_LEN])       // in
{
    BOOL fRet = FALSE;

    BYTE    rgbSalt[PASSWORD_SALT_LEN];
    BYTE    rgbConfirm[A_SHA_DIGEST_LEN];

    PBYTE   pbMK = NULL;
    DWORD   cbMK;

    // confirm is just get state and attempt MK decrypt
    if (FBPGetSecurityState(
            szUser,
            szMasterKey,
            rgbSalt,
            sizeof(rgbSalt),
            rgbConfirm,
            sizeof(rgbConfirm),
            &pbMK,
            &cbMK))
    {
        BOOL fResetSecurityState;

        // found state; is pwd correct?
        if (!FMyDecryptMKEx(
                rgbSalt,
                sizeof(rgbSalt),
                rgbPwd,
                rgbConfirm,
                &pbMK,
                &cbMK,
                &fResetSecurityState
                ))
            goto Ret;


        if( fResetSecurityState )
        {

            // now wrap MK up and stuff in registry

            if(FMyEncryptMK(
                    rgbSalt,
                    sizeof(rgbSalt),
                    rgbPwd,
                    rgbConfirm,
                    &pbMK,
                    &cbMK
                    )) {

                if (FBPSetSecurityState(
                        szUser,
                        szMasterKey,
                        rgbSalt,
                        sizeof(rgbSalt),
                        rgbConfirm,
                        sizeof(rgbConfirm),
                        pbMK,
                        cbMK
                        ))
                {

                    // found state; is pwd correct?
                    if (!FMyDecryptMKEx(
                            rgbSalt,
                            sizeof(rgbSalt),
                            rgbPwd,
                            rgbConfirm,
                            &pbMK,
                            &cbMK,
                            &fResetSecurityState
                            )) {
                        OutputDebugString(TEXT("fail to dec\n"));
                        goto Ret;
                    }
                }

            }
        }   // reset security state.
    }
    else
    {
        // didn't find state; create it
        // if we couldn't retrieve state, assume we must generate it
        if (!RtlGenRandom(rgbSalt, PASSWORD_SALT_LEN))
            goto Ret;

        cbMK = 2*DES_KEYLEN;
        pbMK = (PBYTE)SSAlloc(cbMK);
        if (pbMK == NULL)     // check allocation
            goto Ret;

        if (!RtlGenRandom(pbMK, cbMK))
            goto Ret;

        // now wrap MK up and stuff in registry
        if (!FMyEncryptMK(
                rgbSalt,
                sizeof(rgbSalt),
                rgbPwd,
                rgbConfirm,
                &pbMK,
                &cbMK))
            goto Ret;

        if (!FBPSetSecurityState(
                szUser,
                szMasterKey,
                rgbSalt,
                PASSWORD_SALT_LEN,
                rgbConfirm,
                sizeof(rgbConfirm),
                pbMK,
                cbMK))
            goto Ret;
    }

    fRet = TRUE;
Ret:
    if (pbMK) {
        ZeroMemory(pbMK, cbMK); // sfield: zero memory
        SSFree(pbMK);
    }

    return fRet;
}


// callback for changing a password. On password change,
// MasterKey is decrypted and re-encrypted
BOOL FPasswordChangeNotify(
        LPCWSTR szUser,                         // in
        LPCWSTR szPasswordName,                 // in
        BYTE    rgbOldPwd[A_SHA_DIGEST_LEN],    // in
        DWORD   cbOldPwd,                       // in
        BYTE    rgbNewPwd[A_SHA_DIGEST_LEN],    // in
        DWORD   cbNewPwd)                       // in
{
    // allows unattended pw change (callback from svr)

    BOOL fRet = FALSE;
    BYTE    rgbSalt[PASSWORD_SALT_LEN];
    BYTE    rgbConfirm[A_SHA_DIGEST_LEN];

    PBYTE pbMK = NULL;
    DWORD cbMK;

    BOOL fNewPassword = (cbOldPwd == 0);

    // can't modify a non-user changable pw
//    if (!FIsUserMasterKey(szPasswordName))
//        goto Ret;

    if (cbNewPwd != A_SHA_DIGEST_LEN)
        goto Ret;

    // ensure old pwd exists
    if (!FBPGetSecurityState(
            szUser,
            szPasswordName,
            rgbSalt,
            sizeof(rgbSalt),
            rgbConfirm,
            sizeof(rgbConfirm),
            &pbMK,
            &cbMK))
    {
        // couldn't retreive old PW, create a new one
        if (!FCheckPWConfirm(
                szUser,
                szPasswordName,
                rgbNewPwd))
            goto Ret;

        fRet = TRUE;
        goto Ret;
    }
    else
    {
        // state was retrieved
        if (fNewPassword)
        {
            SetLastError((DWORD)PST_E_ITEM_EXISTS);
            goto Ret;
        }
    }

    // old pwd retrieved -- time to update
    if (!FMyDecryptMK(
            rgbSalt,
            sizeof(rgbSalt),
            rgbOldPwd,
            rgbConfirm,
            &pbMK,
            &cbMK))
    {
        SetLastError((DWORD)PST_E_WRONG_PASSWORD);
        goto Ret;
    }

    // MK is naked here

    // rewrap and save state
    if (!FMyEncryptMK(
            rgbSalt,
            sizeof(rgbSalt),
            rgbNewPwd,
            rgbConfirm,
            &pbMK,
            &cbMK))
        goto Ret;
    if (!FBPSetSecurityState(
            szUser,
            szPasswordName,
            rgbSalt,
            sizeof(rgbSalt),
            rgbConfirm,
            sizeof(rgbConfirm),
            pbMK,
            cbMK))
        goto Ret;

    fRet = TRUE;
Ret:
    if (pbMK) {
        ZeroMemory(pbMK, cbMK);
        SSFree(pbMK);
    }

    return fRet;
}



BOOL FHMACGeographicallySensitiveData(
            LPCWSTR szUser,                         // in
            LPCWSTR szPasswordName,                 // in
            DWORD   dwHMACVersion,                  // in
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],       // in
            const GUID* pguidType,                  // in
            const GUID* pguidSubtype,               // in
            LPCWSTR szItem,                         // in: may be NULL
            PBYTE pbBuf,                            // in
            DWORD cbBuf,                            // in
            BYTE rgbHMAC[A_SHA_DIGEST_LEN])         // out
{
    BOOL fRet = FALSE;

    // helpful pointer
    PBYTE pbCurrent;

    PBYTE   pbKeyBlock = NULL;
    DWORD   cbKeyBlock;
    DESKEY  sBogusKey;
    DESKEY  sMacKey;

    DWORD cbTmp = (DWORD)(cbBuf + 2*sizeof(GUID) + WSZ_BYTECOUNT(szItem));
    PBYTE pbTmp = (PBYTE)SSAlloc(cbTmp);
    if (pbTmp == NULL)     // check allocation
        goto Ret;

    // helpful pointer
    pbCurrent = pbTmp;

    // snag the MAC key
    if (!FGetInternalMACKey(szUser, &pbKeyBlock, &cbKeyBlock))
    {
        // create a key block
        if (!FMyEncryptKeyBlock(
                    szUser,
                    szPasswordName,
                    rgbPwd,
                    &pbKeyBlock,
                    &cbKeyBlock,
                    &sBogusKey,
                    &sMacKey))
                goto Ret;

        if (!FSetInternalMACKey(szUser, pbKeyBlock, cbKeyBlock))
            goto Ret;
    }
    else
    {
        // key already exists; get it
        if (!FMyDecryptKeyBlock(
                szUser,
                szPasswordName,
                rgbPwd,
                pbKeyBlock,
                cbKeyBlock,
                &sBogusKey,
                &sMacKey))
            goto Ret;
    }


    // HMAC format:
    // HMAC( guidType | guidSubtype | szItemName | pbData )

    // copy type
    CopyMemory(pbCurrent, pguidType, sizeof(GUID));
    pbCurrent += sizeof(GUID);

    // copy subtype
    CopyMemory(pbCurrent, pguidSubtype, sizeof(GUID));
    pbCurrent += sizeof(GUID);

    // copy item name
    CopyMemory(pbCurrent, szItem, WSZ_BYTECOUNT(szItem));
    pbCurrent += WSZ_BYTECOUNT(szItem);

    // copy actual data
    CopyMemory(pbCurrent, pbBuf, cbBuf);

    if (dwHMACVersion == OLD_HMAC_VERSION)
    {
        // now do HMAC on this
        if (!FMyOldPrimitiveHMAC(
                sMacKey,
                pbTmp,
                cbTmp,
                rgbHMAC))
            goto Ret;
    }
    else
    {
        // now do HMAC on this
        if (!FMyPrimitiveHMAC(
                sMacKey,
                pbTmp,
                cbTmp,
                rgbHMAC))
            goto Ret;
    }

    fRet = TRUE;

Ret:
    if (pbTmp)
        SSFree(pbTmp);

    if (pbKeyBlock)
        SSFree(pbKeyBlock);

    return fRet;
}


// lifted (nearly) directly from RSABase ntagum.c

// do locale check once
static BOOL g_fEncryptionIsPermitted;
static BOOL g_fIKnowEncryptionPermitted = FALSE;

BOOL FIsEncryptionPermitted()
/*++

Routine Description:

    This routine checks whether encryption is getting the system default
    LCID and checking whether the country code is CTRY_FRANCE.

Arguments:

    none


Return Value:

    TRUE - encryption is permitted
    FALSE - encryption is not permitted


--*/
{
    LCID DefaultLcid;
    CHAR CountryCode[10];
    ULONG CountryValue;

    if (!g_fIKnowEncryptionPermitted)
    {
        // assume okay (unless found otherwise)
        g_fEncryptionIsPermitted = TRUE;

        DefaultLcid = GetSystemDefaultLCID();
        //
        // Check if the default language is Standard French
        //
        if (LANGIDFROMLCID(DefaultLcid) == 0x40c)
            g_fEncryptionIsPermitted = FALSE;

        //
        // Check if the users's country is set to FRANCE
        //
        if (GetLocaleInfoA(DefaultLcid,LOCALE_ICOUNTRY,CountryCode,10) == 0)
            g_fEncryptionIsPermitted = FALSE;

        /*
        CountryValue = (ULONG) atol(CountryCode);
        if (CountryValue == CTRY_FRANCE)
            return(FALSE);
        */

        //
        // begin    remove dependency on atol and msvcrt
        //
        // from winnls.h:
        //    #define CTRY_FRANCE               33          // France
        SS_ASSERT(CTRY_FRANCE == 33);
        if (0 == lstrcmpA(CountryCode, "33"))
            g_fEncryptionIsPermitted = FALSE;
        //
        //  end     remove dependency on atol and msvcrt
        //

        g_fIKnowEncryptionPermitted = TRUE;
    }

    return g_fEncryptionIsPermitted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\provui.h ===
#ifndef _PROVUI_H_
#define _PROVUI_H_

#include "pstypes.h"
#include "dispif.h"

//////////////////////////////
// string resources we load 
extern LPWSTR g_PromptReadItem;
extern LPWSTR g_PromptOpenItem;
extern LPWSTR g_PromptWriteItem;
extern LPWSTR g_PromptDeleteItem;

extern LPWSTR g_PasswordNoVerify;
extern LPWSTR g_PasswordWinNoVerify;
extern LPWSTR g_PasswordSolicitOld;

//////////////////////////////
// String load/unload routines
BOOL InitUI();
BOOL ReleaseUI();

//////////////////////////////
// Miscellaneous support

BOOL
FIsProviderUIAllowed(
    LPCWSTR szUser
    );


//////////////////////////////
// Dialogs

BOOL FSimplifiedPasswordConfirm(
        PST_PROVIDER_HANDLE*    phPSTProv,
        LPCWSTR                 szUserName,        
        LPCWSTR                 szCallerName, 
        LPCWSTR                 szType,
        LPCWSTR                 szSubtype,
        LPCWSTR                 szItemName,
        PPST_PROMPTINFO         psPrompt,   
        LPCWSTR                 szAccessType,
        LPWSTR*                 ppszPWName,
        DWORD*                  pdwPasswordOptions,
        BOOL                    fAllowUserFreedom,
//        BOOL*                   pfCacheThisPasswd,
        BYTE                    rgbPasswordDerivedBytes[], 
        DWORD                   cbPasswordDerivedBytes,
        BYTE                    rgbPasswordDerivedBytesLowerCase[],
        DWORD                   cbPasswordDerivedBytesLowerCase,
        DWORD                   dwFlags);

BOOL FChangePassword(
        HWND                    hParentWnd,
        LPCWSTR                 szUserName);

BOOL FGetChangedPassword(
        PST_PROVIDER_HANDLE*    phPSTProv,
        HWND                    hParentWnd,
        LPCWSTR                 szUserName,
        LPCWSTR                 szPasswordName,
        BYTE                    rgbNewPasswordDerivedBytes[]);

//////////////////////////////
// Dialog box args

typedef struct _PW_DIALOG_ARGS
{
    PST_PROVIDER_HANDLE*    phPSTProv;
    LPCWSTR     szAppName;
    LPCWSTR     szAccess;
    LPCWSTR     szPrompt;
    LPCWSTR     szItemType;
    LPCWSTR     szItemName;
    LPCWSTR     szUserName;
    LPWSTR*     ppszPWName;
    LPWSTR*     ppszPW;
    DWORD*      pdwPasswordOptions;

    BOOL        fAllowConfirmChange;    // defining subtype
    BOOL*       pfCacheThisPasswd;      

    BYTE*       rgbPwd;             // A_SHA_DIGEST_LEN
    BYTE*       rgbPwdLowerCase;    // A_SHA_DIGEST_LEN
    LUID        luidAuthID;         // Windows NT authentication ID
    DWORD       dwFlags;            // dwFlags to SP calls.

    HDC hMyDC;
    HICON hIcon;
    int xIconPos;
    int yIconPos;
} PW_DIALOG_ARGS, *PPW_DIALOG_ARGS;

/*
typedef struct _NEWPW_DIALOGARGS
{
    LPCWSTR     szUserName;
    LPWSTR*     ppszPWName;
    LPWSTR*     ppszPW;
} NEWPW_DIALOGARGS, *PNEWPW_DIALOGARGS;
*/

typedef struct _OLDNEWPW_DIALOGARGS
{
    LPCWSTR     szUserName;
    LPWSTR*     ppszPWName;
    LPWSTR*     ppszOldPW;
    LPWSTR*     ppszNewPW;
} OLDNEWPW_DIALOGARGS, *POLDNEWPW_DIALOGARGS; 

typedef struct _SOLICITOLDPW_DIALOGARGS
{
    LPCWSTR     szPWName;
    LPWSTR*     ppszOldPW;
    LPWSTR*     ppszNewPW;
} SOLICITOLDPW_DIALOGARGS, *PSOLICITOLDPW_DIALOGARGS; 


typedef struct _ADVANCEDCONFIRM_DIALOGARGS
{
    LPCWSTR     szUserName;
    LPWSTR*     ppszPWName;
    LPWSTR*     ppszPW;
    DWORD*      pdwPasswordOptions;
    LPCWSTR     szItemName;
} ADVANCEDCONFIRM_DIALOGARGS, *PADVANCEDCONFIRM_DIALOGARGS; 


#endif // _PROVUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\provui.cpp ===
/*
    File:       ProvUI.cpp

    Title:      Base provider user interface
    Author:     Matt Thomlinson
    Date:       12/13/96

    ProvUI houses all user interface for the provider. During
    startup, InitUI() fetches all user strings from the resource
    string table. During shutdown, ReleaseUI() frees them.

    The other miscellaneous functions gather passwords,
    define new password groups and retrieve the windows password
    if it has changed.

*/
#include <pch.cpp>
#pragma hdrstop


#include <commctrl.h>


#include "provui.h"


#include "storage.h"

#include "passwd.h"
#include "filemisc.h"

extern DISPIF_CALLBACKS     g_sCallbacks;
extern PRIVATE_CALLBACKS    g_sPrivateCallbacks;
extern HINSTANCE            g_hInst;
extern BOOL                 g_fAllowCachePW;

// cached authentication list
extern              CUAList*            g_pCUAList;

HICON g_DefaultIcon = NULL;


BOOL g_fUIInitialized = FALSE;
CRITICAL_SECTION g_csUIInitialized;


// string resources

LPWSTR g_StringBlock = NULL; // single allocated block containing all sz strings

LPWSTR g_ItemDetailsBannerMessage;
LPWSTR g_PasswordDuplicate;
LPWSTR g_PasswordAddError;
LPWSTR g_PasswordChangeError;
LPWSTR g_PasswordCreate;
LPWSTR g_PasswordNoMatch;
LPWSTR g_PasswordMustName;
LPWSTR g_PasswordChange;
LPWSTR g_PasswordSolicitOld;
LPWSTR g_PasswordErrorDlgTitle;

LPWSTR g_PasswordWin95Garbage;
LPWSTR g_PasswordNoVerify;
LPWSTR g_PasswordWinNoVerify;

LPWSTR g_PWPromptPrefix;
LPWSTR g_PWPromptSuffix;
LPWSTR g_SimplifiedDlgMessageFormat;

LPWSTR g_PromptReadItem;
LPWSTR g_PromptOpenItem;
LPWSTR g_PromptWriteItem;
LPWSTR g_PromptDeleteItem;

LPWSTR g_PromptHighSecurity;
LPWSTR g_PromptMedSecurity;
LPWSTR g_PromptLowSecurity;

LPWSTR g_TitleContainerMapping;


#define MAX_PW_LEN  160
#define MAX_STRING_RSC_SIZE 512

// define something not likely to be entered by a user
#define WSZ_PASSWORD_CHANGE_DETECT_TOKEN L"[]{}9d1Dq"

//
// this one comes and goes only when needed
//

typedef DWORD (WINAPI *WNETVERIFYPASSWORD)(
    LPCSTR lpszPassword,
    BOOL *pfMatch
    );


///////////////////////////////////////////////////////////////////////////
// Forwards
INT_PTR CALLBACK DialogAdvancedConfirmH(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
);

INT_PTR CALLBACK DialogAccessDetails(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
);

INT_PTR CALLBACK DialogOldNewPassword(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
);


INT_PTR CALLBACK DialogSolicitOldPassword(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
);

INT_PTR CALLBACK DialogSetSecurityLevel(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
);

INT_PTR CALLBACK DialogSimplifiedPasswordConfirm(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
);

INT_PTR CALLBACK DialogWaitForOKCancel(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
);

int
ServicesDialogBoxParam(
    HINSTANCE hInstance,    // handle to application instance
    LPCTSTR lpTemplateName, // identifies dialog box template
    HWND hWndParent,    // handle to owner window
    DLGPROC lpDialogFunc,   // pointer to dialog box procedure
    LPARAM dwInitParam  // initialization value
);



BOOL
FetchString(
    HMODULE hModule,                // module to get string from
    UINT ResourceId,                // resource identifier
    LPWSTR *String,                 // target buffer for string
    LPWSTR *StringBlock,            // string buffer block
    DWORD *dwBufferSize,            // size of string buffer block
    DWORD *dwRemainingBufferSize    // remaining size of string buffer block
    );

BOOL
CALLBACK
FMyLoadIcon(
    HINSTANCE hModule,  // resource-module handle
    LPCTSTR lpszType,    // pointer to resource type
    LPWSTR lpszName,     // pointer to resource name
    LONG_PTR lParam      // application-defined parameter
    );

///////////////////////////////////////////////////////////////////////////
// Exposed functions

#define GLOBAL_STRING_BUFFERSIZE 3800

BOOL InitUI()
{
    DWORD dwBufferSize;
    DWORD dwRemainingBufferSize;
    BOOL bSuccess = FALSE;

    if( g_fUIInitialized )
        return TRUE;

    //
    // take crit sec
    //

    EnterCriticalSection( &g_csUIInitialized );

    //
    // check the global to prevent a race condition that would cause
    // re-init to occur.
    //

    if( g_fUIInitialized ) {
        bSuccess = TRUE;
        goto cleanup;
    }


    g_DefaultIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_ICON1));
    if(g_DefaultIcon == NULL)
        goto cleanup;

    //
    // get size of all string resources, and then allocate a single block
    // of memory to contain all the strings.  This way, we only have to
    // free one block and we benefit memory wise due to locality of reference.
    //

    dwBufferSize = dwRemainingBufferSize = GLOBAL_STRING_BUFFERSIZE;

    g_StringBlock = (LPWSTR)SSAlloc(dwBufferSize);
    if(g_StringBlock == NULL)
        goto cleanup;


    if(!FetchString(g_hInst, IDS_ITEM_DETAILS_BANNER, &g_ItemDetailsBannerMessage, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_CREATE_MESSAGE, &g_PasswordCreate, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_NOMATCH, &g_PasswordNoMatch, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_CHANGE_MESSAGE, &g_PasswordChange, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_MUSTNAME, &g_PasswordMustName, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_SOLICIT_OLD_MESSAGE, &g_PasswordSolicitOld, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_DUPLICATE, &g_PasswordDuplicate, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_ADD_ERROR, &g_PasswordAddError, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_CHANGE_ERROR, &g_PasswordChangeError, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_ERROR_DLGTITLE, &g_PasswordErrorDlgTitle, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;


    if(!FetchString(g_hInst, IDS_WIN95_PASSWORDS_AREGARBAGE, &g_PasswordWin95Garbage, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_NOVERIFY, &g_PasswordNoVerify, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_WIN_NOVERIFY, &g_PasswordWinNoVerify, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;



    if(!FetchString(g_hInst, IDS_PASSWORD_PROMPT_PREFIX, &g_PWPromptPrefix, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_PROMPT_SUFFIX, &g_PWPromptSuffix, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;


    if(!FetchString(g_hInst, IDS_SIMPLIFIED_DLG_MSG, &g_SimplifiedDlgMessageFormat, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PROMPT_READITEM, &g_PromptReadItem, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PROMPT_OPENITEM, &g_PromptOpenItem, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PROMPT_WRITEITEM, &g_PromptWriteItem, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PROMPT_DELETEITEM, &g_PromptDeleteItem, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;


    if(!FetchString(g_hInst, IDS_PROMPT_HIGH_SECURITY, &g_PromptHighSecurity, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PROMPT_MED_SECURITY, &g_PromptMedSecurity, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PROMPT_LOW_SECURITY, &g_PromptLowSecurity, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_TITLE_CONTAINER_MAPPING, &g_TitleContainerMapping, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    //
    // if the block was realloc'ed to a different location, re-fetch strings
    // very unlikely to ever happen
    //

#if DBG
    if(GLOBAL_STRING_BUFFERSIZE != dwBufferSize)
        OutputDebugString(TEXT("Forced to realloc global string area in provui.cpp:InitUI()\n"));
#endif

    bSuccess = TRUE;

cleanup:

    if(!bSuccess) {
        if(g_StringBlock) {
            SSFree(g_StringBlock);
            g_StringBlock = NULL;
        }
    } else {
        g_fUIInitialized = TRUE;
    }

    LeaveCriticalSection( &g_csUIInitialized );

    return bSuccess;
}



BOOL ReleaseUI()
{
    g_DefaultIcon = NULL;

    if(g_StringBlock) {
        SSFree(g_StringBlock);
        g_StringBlock = NULL;
    }

#if 0
    g_PasswordDuplicate = g_PasswordAddError = g_PasswordChangeError =
    g_PasswordCreate = g_PasswordNoMatch = g_PasswordMustName = g_PasswordChange =
    g_PasswordSolicitOld = g_PasswordErrorDlgTitle = g_PasswordWin95Garbage =
    g_PasswordNoVerify = g_PasswordWinNoVerify =

    g_PWPromptPrefix = g_PWPromptSuffix = g_SimplifiedDlgMessageFormat =

    g_PromptReadItem = g_PromptOpenItem = g_PromptWriteItem =
    g_PromptDeleteItem = g_PromptHighSecurity = g_PromptMedSecurity =
    g_PromptLowSecurity =

    NULL;

#endif

    return TRUE;
}


BOOL
FIsProviderUIAllowed(
    LPCWSTR szUser
    )
{
    //
    // UI always allowed under Win95.
    //

    if(!FIsWinNT())
        return TRUE;

    //
    // UI is not allowed on NT when running as local system.
    //

    if(lstrcmpiW(szUser, TEXTUAL_SID_LOCAL_SYSTEM) == 0)
        return FALSE;

    return TRUE;
}


LPWSTR SZMakeDisplayableType(LPCWSTR szType,LPCWSTR szSubtype)
{
    // create a nice UI string
    LPWSTR szUIType = (LPWSTR)SSAlloc((
        wcslen(szType)+
        3 + // L" ()"
        wcslen(szSubtype) +
        1   // L"\0"
        ) * sizeof(WCHAR));


    if(szUIType == NULL)
        return FALSE;

    // sprintf: Subtype(Type)
    wcscpy(szUIType, szSubtype);
    wcscat(szUIType, L" (");
    wcscat(szUIType, szType);
    wcscat(szUIType, L")");

    return szUIType;
}


BOOL
MyGetPwdHashEx(
    LPWSTR szPW,
    BYTE rgbPasswordDerivedBytes[A_SHA_DIGEST_LEN],
    BOOL fLowerCase
    )
{
    A_SHA_CTX   sSHAHash;
    DWORD       cbPassword;
    LPWSTR TemporaryPassword = NULL;

    LPWSTR PasswordToHash;

    // don't include NULL termination
    cbPassword = WSZ_BYTECOUNT(szPW) - sizeof(WCHAR);

    if ( fLowerCase )
    {
        TemporaryPassword = (LPWSTR) SSAlloc( cbPassword + sizeof(WCHAR) );

        if( TemporaryPassword == NULL )
            return FALSE;

        CopyMemory(TemporaryPassword, szPW, cbPassword + sizeof(WCHAR) );

        //
        // Win95: inconsistent handling of pwds
        // forces inplace convert to uppercase
        //

        MyToUpper(TemporaryPassword);

        PasswordToHash = TemporaryPassword;
    } else {

        PasswordToHash = szPW;
    }

    // hash pwd, copy out
    A_SHAInit(&sSHAHash);

    // Hash password
    A_SHAUpdate(&sSHAHash, (BYTE *) PasswordToHash, cbPassword);
    A_SHAFinal(&sSHAHash, rgbPasswordDerivedBytes);

    if( TemporaryPassword )
        SSFree( TemporaryPassword );

    return TRUE;
}

BOOL
MyGetPwdHash(
    LPWSTR szPW,
    BYTE rgbPasswordDerivedBytes[A_SHA_DIGEST_LEN]
    )
{

    if (!FIsWinNT())
    {
        // Win95: inconsistent handling of pwds
        // forces inplace convert to uppercase
        MyGetPwdHashEx( szPW, rgbPasswordDerivedBytes, TRUE );
    } else {
        MyGetPwdHashEx( szPW, rgbPasswordDerivedBytes, FALSE );
    }

    return TRUE;
}


BOOL
FetchString(
    HMODULE hModule,                // module to get string from
    UINT ResourceId,                // resource identifier
    LPWSTR *String,                 // target buffer for string
    LPWSTR *StringBlock,            // string buffer block
    DWORD *dwBufferSize,            // size of string buffer block
    DWORD *dwRemainingBufferSize    // remaining size of string buffer block
    )
{
    WCHAR szMessage[MAX_STRING_RSC_SIZE];
    DWORD cchMessage;

    if(StringBlock == NULL || *StringBlock == NULL || String == NULL)
        return FALSE;

    cchMessage = LoadStringU(
            hModule,
            ResourceId,
            szMessage,
            MAX_STRING_RSC_SIZE);

    if(cchMessage == 0)
        return FALSE;

    if(*dwRemainingBufferSize < (cchMessage+1) * sizeof(WCHAR)) {

        //
        // realloc buffer and update size
        //

        DWORD dwOldSize = *dwBufferSize;
        DWORD dwNewSize = dwOldSize + ((cchMessage + 1) * sizeof(WCHAR)) ;

        *StringBlock = (LPWSTR)SSReAlloc( *StringBlock, dwNewSize );
        if(*StringBlock == NULL) return FALSE;

        *dwBufferSize = dwNewSize;
        *dwRemainingBufferSize += dwNewSize - dwOldSize;
    }

    *String = (LPWSTR)((LPBYTE)*StringBlock + *dwBufferSize - *dwRemainingBufferSize);
    wcscpy(*String, szMessage);
    *dwRemainingBufferSize -= (cchMessage + 1) * sizeof(WCHAR);

    return TRUE;
}



int
ServicesDialogBoxParam(
    HINSTANCE hInstance,    // handle to application instance
    LPCTSTR lpTemplateName, // identifies dialog box template
    HWND hWndParent,    // handle to owner window
    DLGPROC lpDialogFunc,   // pointer to dialog box procedure
    LPARAM dwInitParam  // initialization value
    )
/*++

    This function is implemented to allow UI to originate from the
    Protected Storage service on Windows NT 5.0 installations.

    This UI will go to the user desktop, rather than an invisible desktop
    which would otherwise cause DialogBoxParam() calls to fail.

--*/
{
    HWINSTA hOldWinsta = NULL;
    HWINSTA hNewWinsta = NULL;
    HDESK hOldDesk = NULL;
    HDESK hNewDesk = NULL;
    int iRet = -1;

    if( FIsWinNT5() ) {

        hOldWinsta = GetProcessWindowStation();
        if(hOldWinsta == NULL)
            goto cleanup;

        hOldDesk = GetThreadDesktop( GetCurrentThreadId() );
        if(hOldDesk == NULL)
            goto cleanup;

        hNewWinsta = OpenWindowStationW( L"WinSta0", FALSE, MAXIMUM_ALLOWED );
        if(hNewWinsta == NULL)
            goto cleanup;

        if(!SetProcessWindowStation( hNewWinsta ))
            goto cleanup;

        hNewDesk = OpenDesktopW( L"default", 0, FALSE, MAXIMUM_ALLOWED );
        if(hNewDesk == NULL)
            goto cleanup;

        if(!SetThreadDesktop( hNewDesk )) {
            if( GetLastError() != ERROR_BUSY )
                goto cleanup;

            //
            // the desktop object is locked/in-use.  Most likely explanation
            // is nested dialog box calls.  Just put the process windowstation
            // back and continue..
            //

            SetProcessWindowStation( hOldWinsta );
        }

    }
    
    INITCOMMONCONTROLSEX        initcomm;
    initcomm.dwSize = sizeof(initcomm);
    initcomm.dwICC = ICC_STANDARD_CLASSES | ICC_WIN95_CLASSES;

    InitCommonControlsEx(&initcomm);

    iRet = (int)DialogBoxParam(
                hInstance,      // handle to application instance
                lpTemplateName, // identifies dialog box template
                hWndParent,     // handle to owner window
                lpDialogFunc,   // pointer to dialog box procedure
                dwInitParam     // initialization value
                );

cleanup:

    if( hOldWinsta ) {
        SetProcessWindowStation( hOldWinsta );
    }

    if( hOldDesk ) {
        SetThreadDesktop( hOldDesk );
    }

    if( hNewWinsta ) {
        CloseWindowStation( hNewWinsta );
    }

    if( hNewDesk ) {
        CloseDesktop( hNewDesk );
    }

    return iRet;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
// exposed Dialog setup functions





BOOL FSimplifiedPasswordConfirm(
        PST_PROVIDER_HANDLE*    phPSTProv,
        LPCWSTR                 szUserName,
        LPCWSTR                 szCallerName,
        LPCWSTR                 szType,
        LPCWSTR                 szSubtype,
        LPCWSTR                 szItemName,
        PPST_PROMPTINFO         psPrompt,
        LPCWSTR                 szAccessType,
        LPWSTR*                 ppszPWName,
        DWORD*                  pdwPasswordOptions,
        BOOL                    fAllowUserFreedom,
        BYTE                    rgbPasswordDerivedBytes[],
        DWORD                   cbPasswordDerivedBytes,
        BYTE                    rgbPasswordDerivedBytesLowerCase[],
        DWORD                   cbPasswordDerivedBytesLowerCase,
        DWORD                   dwFlags
        )
{
    if ((rgbPasswordDerivedBytes == NULL) || (cbPasswordDerivedBytes < A_SHA_DIGEST_LEN))
        return FALSE;

    if ((rgbPasswordDerivedBytesLowerCase == NULL) || (cbPasswordDerivedBytesLowerCase < A_SHA_DIGEST_LEN))
        return FALSE;

    BOOL    fRet = FALSE;
    LPWSTR  pszUIPassword = NULL;   // actual pwd
    LPWSTR  szUIType = NULL;

    BOOL    fCacheThisPasswd;         // unDONE UNDONE going away

    DWORD cchItemName;
    LPCWSTR szTitle = szItemName;   // default titlebar to itemname.


    //
    // check if szItemName is a GUID, if so, map the title to something legible.
    //

    cchItemName = lstrlenW( szItemName );

    if( cchItemName == 36 ) {

        if( szItemName[ 8  ] == L'-' &&
            szItemName[ 13 ] == L'-' &&
            szItemName[ 18 ] == L'-' &&
            szItemName[ 23 ] == L'-' ) {

            szTitle = g_TitleContainerMapping;
        }
    } else if( cchItemName == 38 ) {

        if( szItemName[ 0  ] == L'{' &&
            szItemName[ 9  ] == L'-' &&
            szItemName[ 14 ] == L'-' &&
            szItemName[ 19 ] == L'-' &&
            szItemName[ 24 ] == L'-' &&
            szItemName[ 37 ] == L'}' ) {

            szTitle = g_TitleContainerMapping;
        }
    }


    if (NULL == (szUIType =
        SZMakeDisplayableType(
            szType,
            szSubtype)) )
        return FALSE;

    int iRet;

    // PST_ flags go in..

    // okay, take the hit
    PW_DIALOG_ARGS DialogArgs =
        {
            phPSTProv,
            szCallerName,
            szAccessType,
            psPrompt->szPrompt,
            szUIType,
            szTitle,
            szUserName,
            ppszPWName,
            &pszUIPassword,
            pdwPasswordOptions,
            fAllowUserFreedom,           // allow user to change protection?
            &fCacheThisPasswd,
            rgbPasswordDerivedBytes,
            rgbPasswordDerivedBytesLowerCase
        };



    if(FIsWinNT()) {
        BOOL fAuthID;

        if (!g_sCallbacks.pfnFImpersonateClient( phPSTProv )) {
            goto Ret;
        }

        fAuthID = GetThreadAuthenticationId(GetCurrentThread(), &(DialogArgs.luidAuthID));

        g_sCallbacks.pfnFRevertToSelf( phPSTProv );

        if( !fAuthID ) {
            goto Ret;
        }
    }

    DialogArgs.dwFlags = dwFlags;


    iRet = ServicesDialogBoxParam(
                g_hInst,
                MAKEINTRESOURCE(IDD_SIMPLIFIED_PASSWD),
                (HWND)psPrompt->hwndApp,
                DialogSimplifiedPasswordConfirm,
                (LPARAM)&DialogArgs);


    if(iRet != IDOK) goto Ret;

    // BP_ flags, derived bytes come out

    fRet = TRUE;
Ret:

    if (pszUIPassword)
        SSFree(pszUIPassword);

    if (szUIType)
        SSFree(szUIType);

    return fRet;
}


BOOL FChangePassword(
        HWND                    hParentWnd,
        LPCWSTR                 szUserName)
{
    BOOL fRet = FALSE;

    LPWSTR pszOldPW = NULL, pszNewPW = NULL, pszSelectedPW = NULL;

    BYTE rgbOldPasswordDerivedBytes[A_SHA_DIGEST_LEN];
    BYTE rgbNewPasswordDerivedBytes[A_SHA_DIGEST_LEN];


    int iRet;

    OLDNEWPW_DIALOGARGS DialogArgs = {szUserName, &pszSelectedPW, &pszOldPW, &pszNewPW};
    iRet = ServicesDialogBoxParam(
            g_hInst,
            MAKEINTRESOURCE(IDD_PASSWORD_CHANGE),
            hParentWnd,
            DialogOldNewPassword,
            (LPARAM)&DialogArgs);

    if(iRet != IDOK) goto Ret;

    // and check response
    if ((pszOldPW == NULL) || (pszNewPW == NULL) || (pszSelectedPW == NULL))
        goto Ret;


    if (!MyGetPwdHash(pszNewPW, rgbNewPasswordDerivedBytes))
        goto Ret;
    ZeroMemory(pszNewPW, WSZ_BYTECOUNT(pszNewPW)); // sfield: zero the password


    if (!MyGetPwdHash(pszOldPW, rgbOldPasswordDerivedBytes))
        goto Ret;

    // and now commit change
    if (!FPasswordChangeNotify(
                        szUserName,
                        pszSelectedPW,
                        rgbOldPasswordDerivedBytes,
                        sizeof(rgbOldPasswordDerivedBytes),
                        rgbNewPasswordDerivedBytes,
                        sizeof(rgbNewPasswordDerivedBytes) ))
    {
        // this W implemented in both Win95 & NT!
        MessageBoxW(
            NULL, // hParentWnd,
            g_PasswordChangeError,
            g_PasswordErrorDlgTitle,
            MB_OK | MB_ICONEXCLAMATION | MB_SERVICE_NOTIFICATION);

        goto Ret;
    }

    ZeroMemory(pszOldPW, WSZ_BYTECOUNT(pszOldPW)); // sfield: zero the password

    fRet = TRUE;
Ret:
    if (pszOldPW)
        SSFree(pszOldPW);

    if (pszNewPW)
        SSFree(pszNewPW);

    if (pszSelectedPW)
        SSFree(pszSelectedPW);

    return fRet;
}

// In the case I detected a pwd change, but need the old password to migrate
// (NOTE: assume I already have had the new password typed in once)
BOOL FGetChangedPassword(
        PST_PROVIDER_HANDLE*    phPSTProv,
        HWND                    hParentWnd,
        LPCWSTR                 szUserName,
        LPCWSTR                 szPasswordName,
        BYTE                    rgbNewPasswordDerivedBytes[])
{
    BOOL fRet = FALSE;

    LPWSTR pszOldPW = NULL;
    LPWSTR pszNewPW = NULL;
    BYTE rgbOldPasswordDerivedBytes[A_SHA_DIGEST_LEN];

    if(wcscmp(szPasswordName, WSZ_PASSWORD_WINDOWS) == 0) {

        //
        // migrate old style windows password to new style.
        //

        if(!g_sPrivateCallbacks.pfnFGetWindowsPassword(
                        phPSTProv,
                        rgbOldPasswordDerivedBytes,
                        A_SHA_DIGEST_LEN
                        ))
                    goto Ret;

    } else {

        int iRet;
        SOLICITOLDPW_DIALOGARGS DialogArgs = {szPasswordName, &pszOldPW, (FIsWinNT() ? NULL : &pszNewPW)};

        while(TRUE)
        {
            iRet = ServicesDialogBoxParam(
                        g_hInst,
                        FIsWinNT() ? MAKEINTRESOURCE(IDD_SecPass_WinNT) : MAKEINTRESOURCE(IDD_SecPass_Win95),
                        NULL,
                        DialogSolicitOldPassword,
                        (LPARAM)&DialogArgs);

            if(iRet != IDOK) goto Ret;

            // if win95, verify 'new' win pwd
            if ((!FIsWinNT()) && (0 == wcscmp(szPasswordName, WSZ_PASSWORD_WINDOWS)) )
            {
                BOOL bSuccess = FALSE;
                CHAR PasswordANSI[MAX_PW_LEN];
                HMODULE hMprModule;
                WNETVERIFYPASSWORD _WNetVerifyPassword;

                // on fail, uh... continue?
                if (NULL == (hMprModule = LoadLibraryA("mpr.dll")) )
                    goto FailGracefully;

                if (NULL == (_WNetVerifyPassword = (WNETVERIFYPASSWORD)GetProcAddress(hMprModule, "WNetVerifyPasswordA")) )
                    goto FailGracefully;

                if (0 == (WideCharToMultiByte(
                        CP_ACP,
                        0,
                        *DialogArgs.ppszNewPW,
                        -1,
                        PasswordANSI,
                        MAX_PW_LEN,
                        NULL,
                        NULL)) )
                    goto FailGracefully;

                if(_WNetVerifyPassword(PasswordANSI, &bSuccess) != WN_SUCCESS)
                    goto FailGracefully;

                if (!bSuccess)
                {
                    MessageBoxW(
                        NULL, // hParentWnd,
                        g_PasswordWin95Garbage,
                        g_PasswordErrorDlgTitle,
                        MB_OK|MB_SERVICE_NOTIFICATION);
                    continue; // loop
                }


                // slam over the top of NewPasswordDerivedBytes -- this pwd is always correct
                if (!MyGetPwdHash(*DialogArgs.ppszNewPW, rgbNewPasswordDerivedBytes))
                    goto Ret;

    FailGracefully:

                // cleanup
                ZeroMemory(*DialogArgs.ppszNewPW, WSZ_BYTECOUNT(*DialogArgs.ppszNewPW));
                SSFree(*DialogArgs.ppszNewPW);

                ZeroMemory(PasswordANSI, sizeof(PasswordANSI));

                FreeLibrary(hMprModule);
            }

            break;
        }


        // and check response
        if (pszOldPW == NULL)
            goto Ret;

        if (!MyGetPwdHash(pszOldPW, rgbOldPasswordDerivedBytes))
            goto Ret;

    }

    // and now commit change
    if (!FPasswordChangeNotify(
                        szUserName,
                        szPasswordName,
                        rgbOldPasswordDerivedBytes,
                        sizeof(rgbOldPasswordDerivedBytes),
                        rgbNewPasswordDerivedBytes,
                        A_SHA_DIGEST_LEN))
    {
        // this W implemented in both Win95 & NT!
        MessageBoxW(
            NULL, // hParentWnd,
            g_PasswordChangeError,
            g_PasswordErrorDlgTitle,
            MB_OK | MB_ICONEXCLAMATION | MB_SERVICE_NOTIFICATION);

        goto Ret;
    }


    fRet = TRUE;

Ret:

    if (pszOldPW) {
        ZeroMemory(pszOldPW, WSZ_BYTECOUNT(pszOldPW)); // sfield: zero the password
        SSFree(pszOldPW);
    }

    if(!fRet && wcscmp(szPasswordName, WSZ_PASSWORD_WINDOWS) == 0) {

        //
        // TODO: migration of existing Windows key failed!
        // Nuke existing data.
        //

    }

    return fRet;
}

BOOL FInternal_CreateNewPasswordEntry(
        HWND        hParentWnd,
        LPCWSTR     szUserName,
        LPWSTR      szPWName,
        LPWSTR      szPW)
{
    BOOL fRet = FALSE;

    BYTE rgbPasswordDerivedBytes[A_SHA_DIGEST_LEN];

    // and check response
    if ((szPW == NULL) || (szPWName == NULL))
        goto Ret;

    // everything went fine, now derive the password bits!
    if (!MyGetPwdHash(szPW, rgbPasswordDerivedBytes))
        goto Ret;

    // and now commit change
    if (!FPasswordChangeNotify(
                        szUserName,
                        szPWName,
                        NULL,
                        0,
                        rgbPasswordDerivedBytes,
                        A_SHA_DIGEST_LEN ))
    {
        LPWSTR szMessage;

        if (PST_E_ITEM_EXISTS == GetLastError())
        {
            szMessage = g_PasswordDuplicate;
        }
        else
        {
            szMessage = g_PasswordAddError;
        }

        // this W implemented in both Win95 & NT!
        MessageBoxW(
            NULL, //hParentWnd,
            szMessage,
            g_PasswordErrorDlgTitle,
            MB_OK | MB_ICONEXCLAMATION | MB_SERVICE_NOTIFICATION);

        goto Ret;
    }

    fRet = TRUE;
Ret:

    return fRet;
}

BOOL
ChooseSecurityWizard(HWND hDlg, ADVANCEDCONFIRM_DIALOGARGS* pDialogArgs)
{
    // make copy of pDialogArgs so we don't change original
    // unless everything goes ok


    LPWSTR      szPWName_Stack = NULL;
    LPWSTR      szPW_Stack = NULL; // no need to pull original password out
    DWORD       dwPasswordOptions_Stack;
    DWORD       dwReturnStatus;

    ADVANCEDCONFIRM_DIALOGARGS DlgArgs_Stack = {
            pDialogArgs->szUserName,
            &szPWName_Stack,
            &szPW_Stack,
            &dwPasswordOptions_Stack,
            pDialogArgs->szItemName};

    if(*(pDialogArgs->ppszPWName) != NULL)
    {
        szPWName_Stack = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(*(pDialogArgs->ppszPWName)));
        if(szPWName_Stack == NULL)
        {
            goto Ret;
        }
        wcscpy(szPWName_Stack, *(pDialogArgs->ppszPWName));
    }

    dwPasswordOptions_Stack = *(pDialogArgs->pdwPasswordOptions);


Choose_Step1:

    dwReturnStatus = ServicesDialogBoxParam(
            g_hInst,
            MAKEINTRESOURCE(IDD_ADVANCED_CONFIRM),
            (HWND)hDlg,
            DialogSetSecurityLevel,
            (LPARAM)&DlgArgs_Stack);

    // if user decides not to choose, bail
    if (IDOK != dwReturnStatus)
        goto Ret;

    // else, switch on his decision

    switch (*(DlgArgs_Stack.pdwPasswordOptions))
    {
    case (BP_CONFIRM_PASSWORDUI):
        {
            dwReturnStatus =
                ServicesDialogBoxParam(
                    g_hInst,
                    MAKEINTRESOURCE(IDD_ADVANCED_CONFIRM_H),
                    (HWND)hDlg,
                    DialogAdvancedConfirmH,
                    (LPARAM)&DlgArgs_Stack);

            // if user hits okay, execute
            if (IDOK == dwReturnStatus)
                goto ExecuteChange;

            // if user wants back, go back
            if (IDC_BACK == dwReturnStatus)
                goto Choose_Step1;

            // else, bail
            break;
        }
    case (BP_CONFIRM_OKCANCEL):
        {
            dwReturnStatus =
                ServicesDialogBoxParam(
                    g_hInst,
                    MAKEINTRESOURCE(IDD_ADVANCED_CONFIRM_M),
                    (HWND)hDlg,
                    DialogWaitForOKCancel,
                    (LPARAM)pDialogArgs);

            // if user hits okay, execute
            if (IDOK == dwReturnStatus)
                goto ExecuteChange;

            // if user wants back, go back
            if (IDC_BACK == dwReturnStatus)
                goto Choose_Step1;

            // else, bail
            break;
        }
    case (BP_CONFIRM_NONE):
        {
            dwReturnStatus =
                ServicesDialogBoxParam(
                    g_hInst,
                    MAKEINTRESOURCE(IDD_ADVANCED_CONFIRM_L),
                    (HWND)hDlg,
                    DialogWaitForOKCancel,
                    (LPARAM)pDialogArgs);

            // if user hits okay, execute
            if (IDOK == dwReturnStatus)
                goto ExecuteChange;

            // if user wants back, go back
            if (IDC_BACK == dwReturnStatus)
                goto Choose_Step1;

            // else, bail
            break;
        }
    default:
        break;
    }


Ret:
    // free dyn alloced DialogArgs we aren't returning
    if (*(DlgArgs_Stack.ppszPWName))
        SSFree(*(DlgArgs_Stack.ppszPWName));
    if (*(DlgArgs_Stack.ppszPW))
        SSFree(*(DlgArgs_Stack.ppszPW));

    return FALSE;

ExecuteChange:
    // free what we already know, point to newly alloc'ed pointers
    if (*(pDialogArgs->ppszPWName))
        SSFree(*(pDialogArgs->ppszPWName));
    *(pDialogArgs->ppszPWName) = szPWName_Stack;

    if (*(pDialogArgs->ppszPW))
        SSFree(*(pDialogArgs->ppszPW));
    *(pDialogArgs->ppszPW) = szPW_Stack;

    *(pDialogArgs->pdwPasswordOptions) = dwPasswordOptions_Stack;

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
// Actual Dialog Callbacks

INT_PTR CALLBACK DialogAdvancedConfirmH(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
)
{
    BOOL bSuccess = FALSE; // assume error
    PADVANCEDCONFIRM_DIALOGARGS pDialogArgs;
    BYTE rgb1[_MAX_PATH];
    LPWSTR  pszMasterKey=NULL;
    char *  szBuffer = NULL;
    DWORD dwCount;
    DWORD dwStatus;

    switch (message)
    {
        case WM_INITDIALOG:

            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }
            // lParam is struct
            pDialogArgs = (PADVANCEDCONFIRM_DIALOGARGS)lParam;

            // set dialog title
            SetWindowTextU(hDlg, pDialogArgs->szItemName);

            SetWindowTextU(GetDlgItem(hDlg, IDC_MESSAGE), g_PasswordCreate);

            // clear pwds
            SendDlgItemMessage(hDlg, IDC_PW_NAME, CB_RESETCONTENT, 0, 0);

            // Add known pwds
            for (dwCount=0; ;dwCount++)
            {

                if (PST_E_OK !=
                    BPEnumMasterKeys(
                        pDialogArgs->szUserName,
                        dwCount,
                        &pszMasterKey))
                    break;

                // don't add non-editable passwords
                if (!FIsUserMasterKey(pszMasterKey))
                    continue;

                // add this to the list and continue
                if (FIsWinNT())
                {
                    SendDlgItemMessageW(hDlg, IDC_PW_NAME, CB_ADDSTRING, 0, (LPARAM) pszMasterKey);
                }
#ifdef _M_IX86
                else
                {
                    // only add if (! (NULL username && Windows password))
                    if (
                       (0 != wcscmp(pDialogArgs->szUserName, L"")) ||
                       (0 != wcscmp(pszMasterKey, WSZ_PASSWORD_WINDOWS))
                       )
                    {
                        MkMBStr(rgb1, _MAX_PATH, pszMasterKey, &szBuffer);
                        SendDlgItemMessageA(hDlg, IDC_PW_NAME, CB_ADDSTRING, 0, (LPARAM) szBuffer);
                        FreeMBStr(rgb1, szBuffer);
                    }
                }
#endif // _M_IX86
                SSFree(pszMasterKey);
            }


            // check to see if there are any items in listbox
            dwStatus = (DWORD) SendDlgItemMessageW(hDlg, IDC_PW_NAME, CB_GETCOUNT, 0, 0);
            if ((dwStatus == CB_ERR) || (dwStatus == 0))
            {
                // Listbox empty!
                // set default dialog selection to be "new password"
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_SELEXISTING), FALSE);
                SendMessage(hDlg, WM_COMMAND, IDC_RADIO_DEFINENEW, 0);      // as if user clicked NEW
                SendDlgItemMessage(hDlg, IDC_RADIO_DEFINENEW, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
            }
            else
            {
                // Items do exist!

                // set default in dropdown
                if (FIsWinNT())
                    dwStatus = (DWORD) SendDlgItemMessageW(hDlg, IDC_PW_NAME, CB_SELECTSTRING, (WORD)-1, (LPARAM) *(pDialogArgs->ppszPWName));
#ifdef _M_IX86
                else
                {
                    MkMBStr(rgb1, _MAX_PATH, (*pDialogArgs->ppszPWName), &szBuffer);
                    dwStatus = SendDlgItemMessageA(hDlg, IDC_PW_NAME, CB_SELECTSTRING, (WORD)-1, (LONG) szBuffer);
                    FreeMBStr(rgb1, szBuffer);
                }
#endif // _M_IX86
                // if search failed, select first item in listbox
                if (dwStatus == CB_ERR)
                    SendDlgItemMessage(hDlg, IDC_PW_NAME, CB_SETCURSEL, 0, 0);


                // set default dialog selection to be "existing pw"
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_SELEXISTING), TRUE);
                SendMessage(hDlg, WM_COMMAND, IDC_RADIO_SELEXISTING, 0);    // as if user clicked EXISTING
                SendDlgItemMessage(hDlg, IDC_RADIO_SELEXISTING, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
            }

            return TRUE;

        case WM_COMMAND:
        {
            pDialogArgs = (PADVANCEDCONFIRM_DIALOGARGS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if(pDialogArgs == 0) break; // TODO: bail out

            switch (LOWORD(wParam))
            {
                case (IDOK):
                {
                    if( *(pDialogArgs->ppszPWName) ) {
                        SSFree(*(pDialogArgs->ppszPWName));
                        *(pDialogArgs->ppszPWName) = NULL;
                    }

                    if(BST_CHECKED == SendDlgItemMessage(hDlg, IDC_RADIO_SELEXISTING, BM_GETCHECK, 0, 0))
                    {
                        WCHAR sz1[MAX_PW_LEN];
                        DWORD cch1;

                        // and get password name
                        cch1 = GetDlgItemTextU(
                            hDlg,
                            IDC_PW_NAME,
                            sz1,
                            MAX_PW_LEN);

                        *(pDialogArgs->ppszPWName) = (LPWSTR)SSAlloc((cch1+1)*sizeof(WCHAR));
                        if(NULL != *(pDialogArgs->ppszPWName))

                        {
                            wcscpy(*(pDialogArgs->ppszPWName), sz1);
                        }
                    }
                    else
                    {
                        LPWSTR* ppszPW;
                        LPWSTR* ppszPWName;
                        WCHAR sz1[MAX_PW_LEN];
                        WCHAR sz2[MAX_PW_LEN];
                        WCHAR szPWName[MAX_PW_LEN];

                        DWORD cch1 = 0, cch2 = 0, cchPWName = 0;

                        ppszPW = pDialogArgs->ppszPW;
                        ppszPWName = pDialogArgs->ppszPWName;

                        // don't stomp existing ppszPW/ppszPWName until we know we're okay

                        cch1 = GetDlgItemTextU(
                            hDlg,
                            IDC_EDIT1,
                            sz1,
                            MAX_PW_LEN);

                        cch2 = GetDlgItemTextU(
                            hDlg,
                            IDC_EDIT2,
                            sz2,
                            MAX_PW_LEN);

                        if ( (cch1 != cch2) || (0 != wcscmp(sz1, sz2)) )
                        {
                            // this W implemented in both Win95 & NT!
                            MessageBoxW(
                                    NULL, // hDlg,
                                    g_PasswordNoMatch,
                                    g_PasswordErrorDlgTitle,
                                    MB_OK | MB_ICONEXCLAMATION | MB_SERVICE_NOTIFICATION);

                            SetWindowTextU(GetDlgItem(hDlg, IDC_EDIT1), WSZ_NULLSTRING);
                            SetWindowTextU(GetDlgItem(hDlg, IDC_EDIT2), WSZ_NULLSTRING);

                            goto cleanup;
                        }

                        cchPWName = GetDlgItemTextU(
                            hDlg,
                            IDC_PW_NEWNAME,
                            szPWName,
                            MAX_PW_LEN);

                        if (cchPWName == 0)
                        {
                            // this W implemented in both Win95 & NT!
                            MessageBoxW(
                                    NULL, // hDlg,
                                    g_PasswordMustName,
                                    g_PasswordErrorDlgTitle,
                                    MB_OK | MB_ICONEXCLAMATION | MB_SERVICE_NOTIFICATION);
                            goto cleanup;
                        }

                        // trim spaces off rhs
                        while(0 == memcmp(&szPWName[cchPWName-1], L" ", sizeof(WCHAR)))
                            cchPWName--;
                        szPWName[cchPWName] = L'\0';

                        // try and create the pw entry
                        if (!FInternal_CreateNewPasswordEntry(
                                hDlg,
                                pDialogArgs->szUserName,
                                szPWName,
                                sz1) )
                            goto cleanup;

                        // now bite it: save both
                        SS_ASSERT(ppszPW != NULL);
                        *ppszPW = (LPWSTR)SSAlloc( (cch1+1) * sizeof(WCHAR) );
                        if(*ppszPW == NULL) goto cleanup;

                        SS_ASSERT(ppszPWName != NULL);
                        *ppszPWName = (LPWSTR)SSAlloc( (cchPWName + 1) * sizeof(WCHAR));
                        if(*ppszPWName == NULL) goto cleanup;

                        //
                        // sfield: defer copying strings until we know everything succeeded.
                        // this way, we don't have to zero these buffers if some
                        // allocs + copies succeed, and others fail.
                        //
                        wcscpy(*ppszPW, sz1);
                        wcscpy(*ppszPWName, szPWName);

                        bSuccess = TRUE;
        cleanup:

                        if(cch1) ZeroMemory(sz1, cch1 * sizeof(WCHAR));
                        if(cch2) ZeroMemory(sz2, cch2 * sizeof(WCHAR));
                        if(cchPWName) ZeroMemory(szPWName, cchPWName * sizeof(WCHAR));

                        if(!bSuccess)
                        {
                            // UNDONE: investigate freeing ppsz's on error here
                            return FALSE;
                        }

                        break; // things went OK, just bail to EndDialog
                    }
                } // IDOK

                // gray out options
                case IDC_RADIO_SELEXISTING:
                    // set default selection to be "existing pw"
                    EnableWindow(GetDlgItem(hDlg, IDC_PW_NAME), TRUE);

                    EnableWindow(GetDlgItem(hDlg, IDC_PW_NEWNAME), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT2), FALSE);

                    // set focus to first box under button
                    SetFocus(GetDlgItem(hDlg, IDC_PW_NAME));
                    break;
                case IDC_RADIO_DEFINENEW:
                    // set default selection to be "existing pw"
                    EnableWindow(GetDlgItem(hDlg, IDC_PW_NAME), FALSE);

                    EnableWindow(GetDlgItem(hDlg, IDC_PW_NEWNAME), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT2), TRUE);

                    // set focus to first box under button
                    SetFocus(GetDlgItem(hDlg, IDC_PW_NEWNAME));
                    break;

                default:
                    break;
            }

            if (
               (LOWORD(wParam) == IDOK) ||
               (LOWORD(wParam) == IDCANCEL) ||
               (LOWORD(wParam) == IDC_BACK)
               )
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }

            break;
        }
    }

    return FALSE;
}

INT_PTR CALLBACK DialogWaitForOKCancel(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
)
{
    PADVANCEDCONFIRM_DIALOGARGS pDialogArgs;

    switch (message)
    {
        case WM_INITDIALOG:
            {
                pDialogArgs = (PADVANCEDCONFIRM_DIALOGARGS)lParam;

                // set dialog title
                SetWindowTextU(hDlg, pDialogArgs->szItemName);
            }
            return TRUE;

        case WM_COMMAND:
        {
            if (
               (LOWORD(wParam) == IDOK) ||
               (LOWORD(wParam) == IDCANCEL) ||
               (LOWORD(wParam) == IDC_BACK)
               )
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }

            break;
        }
        default:
            break;
    }

    return FALSE;
}

//
// make string LPTSTR types due to the way that the call back is prototyped
// when file is not compiled with #define UNICODE
// we should look at compiling everything with #define UNICODE later
//


BOOL
CALLBACK
FMyLoadIcon(
    HINSTANCE hModule,  // resource-module handle
    LPCWSTR lpszType,    // pointer to resource type
    LPWSTR lpszName,     // pointer to resource name
    LONG_PTR lParam      // application-defined parameter
    )
{
    if ((LPCWSTR)RT_GROUP_ICON != lpszType)
        return TRUE;    // keep looking, you fool!

    //
    // LoadIcon _may_ not work on Win95 if LOAD_LIBRARY_AS_DATAFILE was
    // specified to LoadLibraryEx.
    // We want to avoid calling DLL_PROCESS_ATTACH code for anything
    // because that's a way to get arbitrary code to run in our address space
    //

    if(FIsWinNT()) {
        //
        // load the image via LoadImage, instead of LoadIcon, because
        // LoadIcon does erroneous caching in some scenarios.
        //

        *(HICON*)lParam = (HICON)LoadImageW(
                hModule,
                lpszName,
                IMAGE_ICON,
                0,
                0,
                LR_DEFAULTCOLOR | LR_DEFAULTSIZE
                );
        return FALSE;       // we've got at least one icon; stop!
    } else {

        //
        // this more convoluted approach doesn't seem to work on NT, due
        // to a limitation in CreateIconFromResource()
        // This approach is good for Win95 because it allows us to use all
        // Unicode API calls.
        //

        HRSRC   hRsrc = NULL;
        HGLOBAL hGlobal = NULL;
        LPVOID  lpRes = NULL;
        int     nID;

        *(HICON*)lParam = NULL;

        hRsrc = FindResourceW(hModule, lpszName, lpszType);

        if(hRsrc == NULL)
            return FALSE;

        hGlobal = LoadResource(hModule, hRsrc);
        if(hGlobal == NULL)
            return FALSE;

        lpRes = LockResource(hGlobal);
        if(lpRes == NULL)
            return FALSE;

        nID = LookupIconIdFromDirectory( (PBYTE)lpRes, TRUE );
        hRsrc = FindResourceW( hModule, MAKEINTRESOURCEW(nID), (LPCWSTR)RT_ICON );
        if(hRsrc == NULL)
            return FALSE;

        hGlobal = LoadResource( hModule, hRsrc );
        if(hGlobal == NULL)
            return FALSE;

        lpRes = LockResource(hGlobal);
        if(lpRes == NULL)
            return FALSE;

        // Let the OS make us an icon
        *(HICON*)lParam = CreateIconFromResource( (PBYTE)lpRes, SizeofResource(hModule, hRsrc), TRUE, 0x00030000 );

        return FALSE;

    }
}



INT_PTR CALLBACK DialogAccessDetails(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
)
/*++

    NOTENOTE

    Anybody calling this dialog box routine should be imperonsating the client
    associated with the call.  This allows access to icon and any on-disk
    resources to occur in the security context of the client.

--*/
{
    LPCWSTR ApplicationName;
    LPWSTR  FileDescription = NULL;
    BOOL    fDlgEnterPassword;
    PPW_DIALOG_ARGS pDialogArgs;

    // TODO this function needs more cleanup


    switch (message)
    {
        case WM_INITDIALOG:
        {
            BOOL fImpersonated;

            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }

            // lParam is struct
            pDialogArgs = (PPW_DIALOG_ARGS)lParam;

            // init static vars
            pDialogArgs->hMyDC = GetDC(hDlg);


            // set dialog title
            SetWindowTextU(hDlg, pDialogArgs->szItemName);


            //
            // set application name, path
            //

            fImpersonated = g_sCallbacks.pfnFImpersonateClient(pDialogArgs->phPSTProv);

            SetWindowTextU(GetDlgItem(hDlg,IDC_APP_PATH), pDialogArgs->szAppName);
            if(GetFileDescription(pDialogArgs->szAppName, &FileDescription))
                ApplicationName = FileDescription;
            else
                GetFileNameFromPath(pDialogArgs->szAppName, &ApplicationName);

            if(fImpersonated)
                g_sCallbacks.pfnFRevertToSelf(pDialogArgs->phPSTProv);


            SetWindowTextU(GetDlgItem(hDlg, IDC_APP_NAME), ApplicationName);
            if(FileDescription)
            {
                SSFree(FileDescription);
                FileDescription = NULL;
            }


            // set item name, type
            SetWindowTextU(GetDlgItem(hDlg, IDC_ITEM_NAME), pDialogArgs->szItemName);
            SetWindowTextU(GetDlgItem(hDlg, IDC_ITEM_TYPE), pDialogArgs->szItemType);

            // set messages
            SetWindowTextU(GetDlgItem(hDlg, IDC_MESSAGE), g_ItemDetailsBannerMessage);

            // set access description
            SetWindowTextU(GetDlgItem(hDlg, IDC_ACCESS_TYPE), pDialogArgs->szAccess);

            //
            // set app icon
            //

            fImpersonated = g_sCallbacks.pfnFImpersonateClient(pDialogArgs->phPSTProv);

            HINSTANCE hCallerInst;
            hCallerInst = LoadLibraryExU(pDialogArgs->szAppName, NULL, LOAD_LIBRARY_AS_DATAFILE);
            if (hCallerInst)
            {
                EnumResourceNamesW(hCallerInst, (LPCWSTR)RT_GROUP_ICON, FMyLoadIcon, (LPARAM)&pDialogArgs->hIcon);  // never fails, unfortunately
                FreeLibrary(hCallerInst);
            }

            if(fImpersonated)
                g_sCallbacks.pfnFRevertToSelf(pDialogArgs->phPSTProv);


            HWND hIconBox;
            RECT rect;
            POINT point;
            hIconBox = GetDlgItem(hDlg, IDC_ICONBOX);
            if ((NULL != pDialogArgs) &&
                GetWindowRect(hIconBox, &rect) && 
                (pDialogArgs->hMyDC != NULL) && 
                GetDCOrgEx(pDialogArgs->hMyDC, &point) )       // rect on window, window on screen
            {
                // need pos of icon on DC: subtract GetWindowRect()-GetDCOrgEx()
                pDialogArgs->xIconPos = rect.left - point.x;
                pDialogArgs->yIconPos = rect.top - point.y;
            }


            // update the changable data view
            SendMessage(hDlg, WM_COMMAND, (WORD)DLG_UPDATE_DATA, 0);

            return (TRUE);
        } // WM_INITDIALOG
        case WM_PAINT:
        {
            HDC hMyDC;
            HICON hIcon;

            int xIconPos, yIconPos;

            pDialogArgs = (PPW_DIALOG_ARGS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if(pDialogArgs == 0) break; // TODO:   bail out

            hMyDC = pDialogArgs->hMyDC;
            hIcon = pDialogArgs->hIcon;
            xIconPos = pDialogArgs->xIconPos;
            yIconPos = pDialogArgs->yIconPos;

            if ((hMyDC != NULL) && (hIcon != NULL) && (xIconPos != 0) && (yIconPos != 0))
                DrawIcon(hMyDC, xIconPos, yIconPos, hIcon);

            return (0);
        } // WM_PAINT

        case WM_COMMAND:

            pDialogArgs = (PPW_DIALOG_ARGS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if(pDialogArgs == 0) break; // TODO:   bail out

            switch (LOWORD(wParam))
            {
            case IDOK:
                break;

            default:
                break;
            } // switch

            if (
               (LOWORD(wParam) == IDOK) ||
               (LOWORD(wParam) == IDCANCEL)
               )
            {
                ReleaseDC(hDlg, pDialogArgs->hMyDC);
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }

            break;
    } // switch (message)

    return FALSE;
}

INT_PTR CALLBACK DialogSimplifiedPasswordConfirm(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
)
/*++

    NOTENOTE

    Anybody calling this dialog box routine should be imperonsating the client
    associated with the call.  This allows access to icon and any on-disk
    resources to occur in the security context of the client.

--*/
{
    LPCWSTR ApplicationName;
    LPWSTR  FileDescription = NULL;
    BOOL    fDlgEnterPassword;
    PPW_DIALOG_ARGS pDialogArgs;

    // TODO this function needs more cleanup


    switch (message)
    {
        case WM_INITDIALOG:
        {
            BOOL fImpersonated;

            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }

            // lParam is struct
            pDialogArgs = (PPW_DIALOG_ARGS)lParam;

            // init static vars
            pDialogArgs->hMyDC = GetDC(hDlg);

            // Messages to User

            // Dialog Bar = item name
            SetWindowTextU(hDlg, pDialogArgs->szItemName);

            // application friendly name
            {
                // get application friendly name

                fImpersonated = g_sCallbacks.pfnFImpersonateClient(pDialogArgs->phPSTProv);

                if(GetFileDescription(pDialogArgs->szAppName, &FileDescription))
                    ApplicationName = FileDescription;
                else
                    GetFileNameFromPath(pDialogArgs->szAppName, &ApplicationName);

                if(fImpersonated)
                    g_sCallbacks.pfnFRevertToSelf(pDialogArgs->phPSTProv);

                if(ApplicationName)
                {
                    SetWindowTextU(GetDlgItem(hDlg, IDC_MESSAGE), ApplicationName);
                }

                if(FileDescription)
                {
                    SSFree(FileDescription);
                    FileDescription = NULL;
                }
            }

            // app msg
            SetWindowTextU(GetDlgItem(hDlg, IDC_APP_MSG), pDialogArgs->szPrompt);


#ifdef SHOW_APP_IDENTITY
            //
            // set app icon
            //

            fImpersonated = g_sCallbacks.pfnFImpersonateClient(pDialogArgs->phPSTProv);

            HINSTANCE hCallerInst;
            hCallerInst = LoadLibraryExU(pDialogArgs->szAppName, NULL, LOAD_LIBRARY_AS_DATAFILE);
            if (hCallerInst)
            {
                HWND hIconBox;
                RECT rect;
                POINT point;

                EnumResourceNamesW(hCallerInst, (LPCWSTR)RT_GROUP_ICON, FMyLoadIcon, (LPARAM)&pDialogArgs->hIcon);  // never fails, unfortunately

                hIconBox = GetDlgItem(hDlg, IDC_ICONBOX);
                if (GetWindowRect(hIconBox, &rect) && GetDCOrgEx(pDialogArgs->hMyDC, &point) )       // rect on window, window on screen
                {
                    // need pos of icon on DC: subtract GetWindowRect()-GetDCOrgEx()
                    pDialogArgs->xIconPos = rect.left - point.x;
                    pDialogArgs->yIconPos = rect.top - point.y;
                }

                SendMessage(hDlg, WM_PAINT, 0,0);
                FreeLibrary(hCallerInst);
            }

            if(fImpersonated)
                g_sCallbacks.pfnFRevertToSelf(pDialogArgs->phPSTProv);

#endif  // SHOW_APP_IDENTITY


            // update the changable data view
            SendMessage(hDlg, WM_COMMAND, (WORD)DLG_UPDATE_DATA, 0);

            //
            // if migration disposition, bail out of UI now for OK-Cancel style.
            //

            if( (pDialogArgs->dwFlags & PST_NO_UI_MIGRATION) &&
                ((*pDialogArgs->pdwPasswordOptions) & BP_CONFIRM_OKCANCEL)
                )
            {
                SendMessage(hDlg, WM_COMMAND, IDOK, 0);
            }

            return (TRUE);
        } // WM_INITDIALOG

        case WM_PAINT:
        {
            HDC hMyDC;
            HICON hIcon;

            int xIconPos, yIconPos;

            pDialogArgs = (PPW_DIALOG_ARGS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if(pDialogArgs == 0) break; // TODO:  bail out

            hMyDC = pDialogArgs->hMyDC;
            hIcon = pDialogArgs->hIcon;
            xIconPos = pDialogArgs->xIconPos;
            yIconPos = pDialogArgs->yIconPos;

            if ((hMyDC != NULL) && (hIcon != NULL) && (xIconPos != 0) && (yIconPos != 0))
                DrawIcon(hMyDC, xIconPos, yIconPos, hIcon);

            return (0);

        } // WM_PAINT

        case WM_COMMAND:
            PLUID pluidAuthID;

            pDialogArgs = (PPW_DIALOG_ARGS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if(pDialogArgs == 0) break; // TODO:  bail out

            pluidAuthID = &(pDialogArgs->luidAuthID);

            switch (LOWORD(wParam))
            {
            case IDOK:

                if(NULL == g_pCUAList)
                {
                    return FALSE;
                }
                if (*(pDialogArgs->pdwPasswordOptions) == BP_CONFIRM_PASSWORDUI)
                {
                    WCHAR sz1[MAX_PW_LEN];
                    DWORD cch1;

                    BOOL fUserSaysCache;

                    if( g_fAllowCachePW )
                    {
                        fUserSaysCache = (BST_CHECKED == SendMessage(GetDlgItem(hDlg, IDC_CACHEPW), BM_GETCHECK, 0, 0));
                    } else {
                        fUserSaysCache = FALSE;
                    }

                    // get password
                    cch1 = GetDlgItemTextU(
                        hDlg,
                        IDC_EDIT1,
                        sz1,
                        MAX_PW_LEN);

                    //
                    // compute hashs from scratch
                    //

                    if (!MyGetPwdHash(sz1, pDialogArgs->rgbPwd))
                        break;

                    if (!MyGetPwdHashEx(sz1, pDialogArgs->rgbPwdLowerCase, TRUE))
                        break;

                    // query cache for password
                    if (FIsCachedPassword(pDialogArgs->szUserName, *pDialogArgs->ppszPWName, pluidAuthID))
                    {
                        // find cached pwd
                        UACACHE_LIST_ITEM li, *pli;
                        CreateUACacheListItem(
                                &li,
                                pDialogArgs->szUserName,
                                *pDialogArgs->ppszPWName,
                                pluidAuthID);


                        g_pCUAList->LockList();

                        // find in list
                        if (NULL == (pli = g_pCUAList->SearchList(&li))) {
                            g_pCUAList->UnlockList();
                            break;
                        }

                        // change behavior based on if user tampered with pwd
                        if (0 == wcscmp(WSZ_PASSWORD_CHANGE_DETECT_TOKEN, sz1))
                        {
                            // no; copy cached password to outbuf
                            CopyMemory(pDialogArgs->rgbPwd, pli->rgbPwd, A_SHA_DIGEST_LEN);

                            // no; copy cached password to outbuf
                            CopyMemory(pDialogArgs->rgbPwdLowerCase, pli->rgbPwdLowerCase, A_SHA_DIGEST_LEN);
                        }
                        else
                        {
                            // yes: overwrite cached entry with user-entered
                            CopyMemory(pli->rgbPwd, pDialogArgs->rgbPwd, A_SHA_DIGEST_LEN);

                            // yes: overwrite cached entry with user-entered
                            CopyMemory(pli->rgbPwdLowerCase, pDialogArgs->rgbPwdLowerCase, A_SHA_DIGEST_LEN);
                        }

                        g_pCUAList->UnlockList();


                        if (!fUserSaysCache)
                        {
                            // is already cached, and don't want it to be used

                            // remove from cache
                            g_pCUAList->DelFromList(&li);
                        }

                    }
                    else
                    {
                        if (fUserSaysCache)
                        {
                            // isn't already cached, and want it to be used

                            // create element
                            UACACHE_LIST_ITEM* pli = (UACACHE_LIST_ITEM*) SSAlloc(sizeof(UACACHE_LIST_ITEM));
                            CreateUACacheListItem(
                                    pli,
                                    NULL,
                                    NULL,
                                    pluidAuthID);

                            pli->szUserName = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(pDialogArgs->szUserName));
                            wcscpy(pli->szUserName, pDialogArgs->szUserName);

                            pli->szMKName = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(*pDialogArgs->ppszPWName));
                            wcscpy(pli->szMKName, *pDialogArgs->ppszPWName);

                            CopyMemory(pli->rgbPwd, pDialogArgs->rgbPwd, A_SHA_DIGEST_LEN);
                            CopyMemory(pli->rgbPwdLowerCase, pDialogArgs->rgbPwdLowerCase, A_SHA_DIGEST_LEN);

                            // add to list
                            g_pCUAList->AddToList(pli);
                        }
                        else
                        {
                            // isn't already cached, and don't want it to be used
                        }
                    }

                    ZeroMemory(sz1, WSZ_BYTECOUNT(sz1));
                }

                // else

                break;

            case IDC_ADVANCED:
                {
                    // make copy so static members (x, y, hIcon) don't get stomped
                    PW_DIALOG_ARGS DetailDlgParms;
                    CopyMemory(&DetailDlgParms, pDialogArgs, sizeof(PW_DIALOG_ARGS));

                    ServicesDialogBoxParam(
                        g_hInst,
                        MAKEINTRESOURCE(IDD_ITEM_DETAILS),
                        (HWND)hDlg,
                        DialogAccessDetails,
                        (LPARAM)&DetailDlgParms);

                    // update the changable data view
                    SendMessage(hDlg, WM_COMMAND, (WORD)DLG_UPDATE_DATA, 0);
                }

                break;

            case IDC_CHANGE_SECURITY:
                {
                    ADVANCEDCONFIRM_DIALOGARGS DialogArgs = {pDialogArgs->szUserName, pDialogArgs->ppszPWName, pDialogArgs->ppszPW, pDialogArgs->pdwPasswordOptions, pDialogArgs->szItemName};

                    ChooseSecurityWizard(hDlg, &DialogArgs);

                    // commit changes
                    SendMessage(hDlg, WM_COMMAND, (WORD)DLG_UPDATE_DATA, 0);

                    break;
                }

            case DLG_UPDATE_DATA:
                {
                    WCHAR szDialogMessage[MAX_STRING_RSC_SIZE] = L"\0"; 

                    // show or hide pwd entry box?
                    fDlgEnterPassword = (*(pDialogArgs->pdwPasswordOptions) == BP_CONFIRM_PASSWORDUI);
                    if (fDlgEnterPassword)
                    {
//
// comment out the following because we don't use %ls format string at the moment.
//
                        wcscpy(szDialogMessage, g_PWPromptPrefix);
                        wcscat(szDialogMessage, *(pDialogArgs->ppszPWName));
                        wcscat(szDialogMessage, g_PWPromptSuffix);

                        SetWindowTextU(GetDlgItem(hDlg, IDC_LABEL_EDIT1), szDialogMessage);


                        // we should not hide these windows
                        ShowWindow(GetDlgItem(hDlg, IDC_EDIT1), SW_SHOW);
                        EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), TRUE);

                        ShowWindow(GetDlgItem(hDlg, IDC_LABEL_EDIT1), SW_SHOW);
                        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_EDIT1), TRUE);




                        if( pDialogArgs->fAllowConfirmChange &&
                            g_fAllowCachePW )
                        {
                            // show or hide "cache this password" button
                            ShowWindow(GetDlgItem(hDlg, IDC_CACHEPW), SW_SHOW );
                            EnableWindow(GetDlgItem(hDlg, IDC_CACHEPW), TRUE );
                        } else {
                            ShowWindow(GetDlgItem(hDlg, IDC_CACHEPW), SW_HIDE );
                            EnableWindow(GetDlgItem(hDlg, IDC_CACHEPW), FALSE );

                        }

                        // put untypable token into pwd field
                        if (FIsCachedPassword(pDialogArgs->szUserName, *pDialogArgs->ppszPWName, pluidAuthID))
                            SetWindowTextU(GetDlgItem(hDlg, IDC_EDIT1), WSZ_PASSWORD_CHANGE_DETECT_TOKEN);

                        // show if this password is cached
                        SendMessage(GetDlgItem(hDlg, IDC_CACHEPW), BM_SETCHECK, (WPARAM)(FIsCachedPassword(pDialogArgs->szUserName, *pDialogArgs->ppszPWName, pluidAuthID)), 0);


                        SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                    }
                    else
                    {
                        // hide pw
                        ShowWindow(GetDlgItem(hDlg, IDC_EDIT1), SW_HIDE);
                        ShowWindow(GetDlgItem(hDlg, IDC_LABEL_EDIT1), SW_HIDE);
                        EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), FALSE);
                        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_EDIT1), FALSE);

                        ShowWindow(GetDlgItem(hDlg, IDC_CACHEPW), SW_HIDE);
                        EnableWindow(GetDlgItem(hDlg, IDC_CACHEPW), FALSE);
                    }

                    // show or hide "change security" button
                    ShowWindow(GetDlgItem(hDlg, IDC_CHANGE_SECURITY), ((pDialogArgs->fAllowConfirmChange) ? SW_SHOW : SW_HIDE));
                    EnableWindow(GetDlgItem(hDlg, IDC_CHANGE_SECURITY), ((pDialogArgs->fAllowConfirmChange) ? TRUE : FALSE));

                    // show or hide "details" button
                    ShowWindow(GetDlgItem(hDlg, IDC_ADVANCED), ((pDialogArgs->fAllowConfirmChange) ? SW_SHOW : SW_HIDE));
                    EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED), ((pDialogArgs->fAllowConfirmChange) ? TRUE : FALSE));

                    // show or hide "level currently set to *"
                    ShowWindow(GetDlgItem(hDlg, IDC_SEC_PREFIX), ((pDialogArgs->fAllowConfirmChange) ? SW_SHOW : SW_HIDE));
                    ShowWindow(GetDlgItem(hDlg, IDC_SEC_LEVEL), ((pDialogArgs->fAllowConfirmChange) ? SW_SHOW : SW_HIDE));


                    // jam the current security setting
                    switch(*pDialogArgs->pdwPasswordOptions)
                    {
                    case BP_CONFIRM_PASSWORDUI:
                        SetWindowTextU(GetDlgItem(hDlg, IDC_SEC_LEVEL), g_PromptHighSecurity);
                        break;
                    case BP_CONFIRM_OKCANCEL:
                        SetWindowTextU(GetDlgItem(hDlg, IDC_SEC_LEVEL), g_PromptMedSecurity);
                        break;
                    case BP_CONFIRM_NONE:
                        SetWindowTextU(GetDlgItem(hDlg, IDC_SEC_LEVEL), g_PromptLowSecurity);
                        break;
                    }

                }
                break;

            default:
                break;
            } // switch

            if (
               (LOWORD(wParam) == IDOK) ||
               (LOWORD(wParam) == IDCANCEL)
               )
            {
                ReleaseDC(hDlg, pDialogArgs->hMyDC);
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }

            break;
    } // switch (message)

    return FALSE;
}

INT_PTR CALLBACK DialogOldNewPassword(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
)
{
    LPCWSTR  szUserName;
    LPWSTR*  ppszPWName;
    LPWSTR*  ppszPW;
    LPWSTR*  ppszPWNew;

    POLDNEWPW_DIALOGARGS pDialogArgs;

    DWORD   dwCount;
    BYTE rgb1[_MAX_PATH];
    LPWSTR  pszMasterKey=NULL;
    char *  szBuffer = NULL;

    // TODO this function needs more cleanup

    switch (message)
    {
        case WM_INITDIALOG:
        {
            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }

            // lParam is POLDNEWPW_DIALOGARGS
            pDialogArgs = (POLDNEWPW_DIALOGARGS)lParam;

            szUserName = pDialogArgs->szUserName;
            ppszPWName = pDialogArgs->ppszPWName;
            ppszPW = pDialogArgs->ppszOldPW;
            ppszPWNew = pDialogArgs->ppszNewPW;

            // Add known pwds
            for (dwCount=0; ;dwCount++)
            {
                if (PST_E_OK !=
                    BPEnumMasterKeys(
                        szUserName,
                        dwCount,
                        &pszMasterKey))
                    break;

                // don't add non-editable passwords
                if (!FIsUserMasterKey(pszMasterKey))
                    continue;

                // else, add this to the list and continue
                if (FIsWinNT())
                {
                    SendDlgItemMessageW(hDlg, IDC_PW_NAME, CB_ADDSTRING, 0, (LPARAM) pszMasterKey);
                }
#ifdef _M_IX86
                else
                {
                    MkMBStr(rgb1, _MAX_PATH, pszMasterKey, &szBuffer);
                    SendDlgItemMessageA(hDlg, IDC_PW_NAME, CB_ADDSTRING, 0, (LPARAM) szBuffer);
                    FreeMBStr(rgb1, szBuffer);
                }
#endif
                SSFree(pszMasterKey);
            }
            SendDlgItemMessage(hDlg, IDC_PW_NAME, CB_SETCURSEL, 0, 0);

            SetWindowTextU(GetDlgItem(hDlg, IDC_MESSAGE), g_PasswordChange);

            return (TRUE);
        } // WM_INITDIALOG

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                WCHAR sz1[MAX_PW_LEN];
                WCHAR sz2[MAX_PW_LEN];
                DWORD cch1, cch2;

                pDialogArgs = (POLDNEWPW_DIALOGARGS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
                if(pDialogArgs == 0) break; // TODO:  bail out

                szUserName = pDialogArgs->szUserName;
                ppszPWName = pDialogArgs->ppszPWName;
                ppszPW = pDialogArgs->ppszOldPW;
                ppszPWNew = pDialogArgs->ppszNewPW;

                cch1 = GetDlgItemTextU(
                    hDlg,
                    IDC_EDIT1,
                    sz1,
                    MAX_PW_LEN);

                cch2 = GetDlgItemTextU(
                    hDlg,
                    IDC_EDIT2,
                    sz2,
                    MAX_PW_LEN);

                if ( (cch1 != cch2) || (0 != wcscmp(sz1, sz2)) )
                {
                    // this W implemented in both Win95 & NT!
                    MessageBoxW(
                            NULL, //hDlg,
                            g_PasswordNoMatch,
                            g_PasswordErrorDlgTitle,
                            MB_OK | MB_ICONEXCLAMATION | MB_SERVICE_NOTIFICATION);

                    SetWindowTextU(GetDlgItem(hDlg, IDC_EDIT1), WSZ_NULLSTRING);
                    SetWindowTextU(GetDlgItem(hDlg, IDC_EDIT2), WSZ_NULLSTRING);

                    break;
                }

                // and sock NEW PW away
                SS_ASSERT(ppszPWNew != NULL);
                *ppszPWNew = (LPWSTR)SSAlloc((cch1+1)*sizeof(WCHAR));
                if(NULL != (*ppszPWNew))
                {
                    wcscpy(*ppszPWNew, sz1);
                }

                ZeroMemory(sz1, cch1 * sizeof(WCHAR));


                // and sock OLD PW away
                cch1 = GetDlgItemTextU(
                    hDlg,
                    IDC_EDIT0,
                    sz1,
                    MAX_PW_LEN);
                SS_ASSERT(ppszPW != NULL);
                *ppszPW = (LPWSTR)SSAlloc((cch1+1)*sizeof(WCHAR));
                // TODO check allocation failure
                wcscpy(*ppszPW, sz1);
                ZeroMemory(sz1, cch1 * sizeof(WCHAR));


                // and get password name
                cch1 = GetDlgItemTextU(
                    hDlg,
                    IDC_PW_NAME,
                    sz1,
                    MAX_PW_LEN);
                SS_ASSERT(ppszPWName != NULL);
                *ppszPWName = (LPWSTR)SSAlloc((cch1+1)*sizeof(WCHAR));
                // TODO check allocation failure
                wcscpy(*ppszPWName, sz1);
                ZeroMemory(sz1, cch1 * sizeof(WCHAR));

            }

            if (
               (LOWORD(wParam) == IDOK) ||
               (LOWORD(wParam) == IDCANCEL)
               )
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }
            break;
    }
    return FALSE;
}

INT_PTR CALLBACK DialogSolicitOldPassword(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
)
{
    PSOLICITOLDPW_DIALOGARGS pDialogArgs;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }

            // lParam is PSOLICITOLDPW_DIALOGARGS
            pDialogArgs = (PSOLICITOLDPW_DIALOGARGS)lParam;

            SetWindowTextU(GetDlgItem(hDlg, IDC_PW_NAME), pDialogArgs->szPWName);
            SetWindowTextU(GetDlgItem(hDlg, IDC_MESSAGE), g_PasswordSolicitOld);

            if (pDialogArgs->ppszNewPW == NULL)
            {
                // if NT, we don't need extra user confirmation of new passwd
                ShowWindow(GetDlgItem(hDlg, IDC_ST_NEWPW), FALSE);

                ShowWindow(GetDlgItem(hDlg, IDC_EDIT1), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), FALSE);
            }


            return TRUE;
        } // WM_INITDIALOG

        case WM_COMMAND:
        {
            LPWSTR*   ppszPW;
            BOOL bSuccess = FALSE;

            if (LOWORD(wParam) == IDOK)
            {
                WCHAR sz1[MAX_PW_LEN];
                DWORD cch1;

                pDialogArgs = (PSOLICITOLDPW_DIALOGARGS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
                if(pDialogArgs == 0) break; // TODO:  bail out

                ppszPW = pDialogArgs->ppszOldPW;

                // if asked for, sock NEW PW away
                if (pDialogArgs->ppszNewPW != NULL)
                {
                    LPWSTR* ppszNewPW = pDialogArgs->ppszNewPW;

                    // copy out "new" pwd
                    cch1 = GetDlgItemTextU(
                        hDlg,
                        IDC_EDIT1,
                        sz1,
                        MAX_PW_LEN);

                    SS_ASSERT(ppszNewPW != NULL);
                    *ppszNewPW = (LPWSTR)SSAlloc((cch1+1)*sizeof(WCHAR));
                    if(NULL !=  *ppszNewPW)
                    {
                        wcscpy(*ppszNewPW, sz1);
                    }
                }

                // and sock OLD PW away
                cch1 = GetDlgItemTextU(
                    hDlg,
                    IDC_EDIT0,
                    sz1,
                    MAX_PW_LEN);

                SS_ASSERT(ppszPW != NULL);
                *ppszPW = (LPWSTR)SSAlloc((cch1+1)*sizeof(WCHAR));
                if(*ppszPW != NULL) {
                    wcscpy(*ppszPW, sz1);
                    bSuccess = TRUE;
                }

                ZeroMemory(sz1, cch1 * sizeof(WCHAR));
            }

            if (
               (LOWORD(wParam) == IDOK) ||
               (LOWORD(wParam) == IDCANCEL)
               )
            {
                EndDialog(hDlg, LOWORD(wParam));
                return bSuccess;
            }
        } // WM_COMMAND

        default:
            return FALSE;
    }

    return FALSE;
}

INT_PTR CALLBACK DialogSetSecurityLevel(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
)
{
    PADVANCEDCONFIRM_DIALOGARGS pDialogArgs;

    BYTE        rgb1[_MAX_PATH];
    LPWSTR      pszMasterKey=NULL;
    char *      szBuffer = NULL;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }

            // lParam is PADVANCEDCONFIRM_DIALOGARGS
            pDialogArgs = (PADVANCEDCONFIRM_DIALOGARGS)lParam;

            // set the dialog title
            SetWindowTextU(hDlg, pDialogArgs->szItemName);

            switch(*(pDialogArgs->pdwPasswordOptions))
            {
            case BP_CONFIRM_NONE:
                SendDlgItemMessage(hDlg, IDC_RADIO_NOCONFIRM, BM_SETCHECK, BST_CHECKED, 0);
                SendMessage(hDlg, WM_COMMAND, (WORD)IDC_RADIO_NOCONFIRM, 0);
                break;

            case BP_CONFIRM_OKCANCEL:
                SendDlgItemMessage(hDlg, IDC_RADIO_OKCANCEL, BM_SETCHECK, BST_CHECKED, 0);
                SendMessage(hDlg, WM_COMMAND, (WORD)IDC_RADIO_OKCANCEL, 0);
                break;

            case BP_CONFIRM_PASSWORDUI:
            default:
                SendDlgItemMessage(hDlg, IDC_RADIO_ASSIGNPW, BM_SETCHECK, BST_CHECKED, 0);
                SendMessage(hDlg, WM_COMMAND, (WORD)IDC_RADIO_ASSIGNPW, 0);
                break;
            }


            return TRUE;
        } // WM_INITDIALOG

        case WM_COMMAND:
        {
            LPWSTR*   ppszPW;
            BOOL bSuccess = FALSE;

            switch (LOWORD(wParam))
            {
            case IDC_NEXT:
            case IDOK:
                {
                    pDialogArgs = (PADVANCEDCONFIRM_DIALOGARGS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
                    if(pDialogArgs == 0) break; // TODO:  bail out

                    // modify *(pDialogArgs->pdwPasswordOptions);
                    if (BST_CHECKED == SendDlgItemMessage(hDlg, IDC_RADIO_ASSIGNPW, BM_GETCHECK, 0, 0))
                    {
                        *(pDialogArgs->pdwPasswordOptions) = BP_CONFIRM_PASSWORDUI;
                    }
                    else
                        if (BST_CHECKED == SendDlgItemMessage(hDlg, IDC_RADIO_NOCONFIRM, BM_GETCHECK, 0, 0))
                            *(pDialogArgs->pdwPasswordOptions) = BP_CONFIRM_NONE;
                        else
                            *(pDialogArgs->pdwPasswordOptions) = BP_CONFIRM_OKCANCEL;

                    if (BP_CONFIRM_PASSWORDUI != *(pDialogArgs->pdwPasswordOptions))
                    {
                        *(pDialogArgs->ppszPWName) = (LPWSTR)SSAlloc(sizeof(WSZ_PASSWORD_WINDOWS));
                        if(*(pDialogArgs->ppszPWName) != NULL)
                        {
                            wcscpy(*(pDialogArgs->ppszPWName), WSZ_PASSWORD_WINDOWS);
                        }
                    }

                    break;
                }

                default:
                    break;
            }

            if (
               (LOWORD(wParam) == IDOK) ||
               (LOWORD(wParam) == IDCANCEL) ||
               (LOWORD(wParam) == IDC_NEXT)
               )
            {
                EndDialog(hDlg, LOWORD(wParam));
                return bSuccess;
            }
        } // WM_COMMAND

        default:
            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\prov.cpp ===
/*
    File:       Prov.cpp

    Title:      Protected Storage Base Provider
    Author:     Matt Thomlinson
    Date:       10/22/96

    Protected storage is an area to safely store user belongings.
    This storage is available on both NT and Win95, and offers finer
    granularity over access than do NT ACLs.

    The PStore architecture resembles the CryptoAPI provider architecture.
    The PStore server, PStoreS, takes requests and forwards them to any one
    of a number of providers, of which PSBase is a single instance. (The
    server exports some basic functionality to ease the pain of provider
    writers, like impersonating the caller and checking access rules.) The
    server gets requests through LPC from a client (PStoreC.dll),
    which wraps a number of operations into a COM object.

    The base provider supports user storage, where items are stored under
    the namespace of which user called protected storage, and local machine
    storage, a global area that can be accessed by everyone.

    Rules can be set on subtypes describing under what conditions accesses
    are allowed. Rules can specify callers be Authenticode signed, callers
    simply be unmodified from access to access, and normal (arbitrary) NT Acls
    be satisfied.

    In addition, items stored in the user namespace have user authentication
    by default, where the user gets to specify what type of user
    confirmation they want to see appear. This confirmation could be
    no confirmation, an ok/cancel dialog, a password, a retinal scan, a
    fingerprint, etc.

    The base provider stores items in the registry, DES-encrypted with a
    key derived from the user password. Items are also integrity-protected
    by a keyed MAC.

    Interoperability and transport issues are solved by adding a provider
    supporting the PFX interchange format.

    The base provider is slightly more special than all other providers, since
    the server stores bootstrap configuration data here. (The base provider
    is guaranteed to always be present). The configuration data includes
    what other providers are ok to be loaded.

*/

#include <pch.cpp>
#pragma hdrstop


#include "provif.h"
#include "provui.h"
#include "storage.h"

#include "passwd.h"


// sfield: legacy migration hack
#include "migrate.h"


BOOL                g_fAllowCachePW = TRUE;

// fwd (secure.cpp)
BOOL FIsEncryptionPermitted();


HINSTANCE           g_hInst = NULL;
BOOL                g_fImagesIntegrid = FALSE;

DISPIF_CALLBACKS    g_sCallbacks;
BOOL                g_fCallbacksInitialized = FALSE;

PRIVATE_CALLBACKS   g_sPrivateCallbacks;

CUAList*            g_pCUAList = NULL;
COpenItemList*      g_pCOpenItemList = NULL;
CCryptProvList*     g_pCProvList = NULL;

extern CRITICAL_SECTION g_csUIInitialized;


/////////////////////////////////////////////////////////////////////////
// Very important to hook DllMain, do caller authentication



BOOL   WINAPI   DllMain (HMODULE hInst,
                        ULONG ul_reason_for_call,
                        LPVOID lpReserved)
{
    switch( ul_reason_for_call )
    {
    case DLL_PROCESS_ATTACH:
        {

        g_hInst = hInst;
        InitializeCriticalSection( &g_csUIInitialized );

        //
        // just hard-code image verification succeeded.
        //

        g_fImagesIntegrid = TRUE;


        // set up global lists
        g_pCUAList = new CUAList;
        if(g_pCUAList)
        {
            if(!g_pCUAList->Initialize())
            {
                delete g_pCUAList;
                g_pCUAList = NULL;
            }
        }

        g_pCOpenItemList = new COpenItemList;
        if(g_pCOpenItemList)
        {
            if(!g_pCOpenItemList->Initialize())
            {
                delete g_pCOpenItemList;
                g_pCOpenItemList = NULL;
            }
        }

        g_pCProvList = new CCryptProvList;
        if(g_pCProvList)
        {
            if(!g_pCProvList->Initialize())
            {
                delete g_pCProvList;
                g_pCProvList = NULL;
            }
        }




        DisableThreadLibraryCalls(hInst);

        // call EncryptionPermitted routine once to initialize globals
        FIsEncryptionPermitted();
        FInitProtectAPIGlobals();


        break;
        }

    case DLL_PROCESS_DETACH:

        // tear down global lists
        if(g_pCUAList)
        {
            delete g_pCUAList;
            g_pCUAList = NULL;
        }

        if(g_pCOpenItemList)
        {
            delete g_pCOpenItemList;
            g_pCOpenItemList = NULL;
        }

        if(g_pCProvList)
        {
            delete g_pCProvList;
            g_pCProvList = NULL;
        }

        ReleaseUI();



        DeleteCriticalSection( &g_csUIInitialized );

        break;

    default:
        break;
    }

    return TRUE;
}


HRESULT        SPProviderInitialize(
        DISPIF_CALLBACKS *psCallbacks)
{
    // only allow one initialization (security check)
    if (g_fCallbacksInitialized)
        return PST_E_FAIL;

    if( psCallbacks->cbSize < sizeof(DISPIF_CALLBACKS) )
        return PST_E_FAIL;

    // tuck these callback fxns for later use
    CopyMemory(&g_sCallbacks, psCallbacks, sizeof(DISPIF_CALLBACKS));

    // now, get the private callbacks from the server
    DWORD cbPrivateCallbacks = sizeof(g_sPrivateCallbacks);

    if(!g_sCallbacks.pfnFGetServerParam(
            NULL,
            SS_SERVERPARAM_CALLBACKS,
            &g_sPrivateCallbacks,
            &cbPrivateCallbacks
            ))
            return PST_E_FAIL;

    if(g_sPrivateCallbacks.cbSize != sizeof(g_sPrivateCallbacks))
        return PST_E_FAIL;

    g_fCallbacksInitialized = TRUE;

    return PST_E_OK;
}


HRESULT        SPAcquireContext(
    /* [in] */  PST_PROVIDER_HANDLE* phPSTProv,
    /* [in] */  DWORD   dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    BOOL fExisted = FALSE;
    LPWSTR szUser = NULL;

    HKEY hUserKey = NULL;
    BOOL fUserExisted;

    if(!InitUI())
        return FALSE;


    if (0 != dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // get current user
    if (!g_sCallbacks.pfnFGetUser(
            phPSTProv,
            &szUser))
        goto Ret;

    //
    // migrate password data.  This doesn't do anything internally if migration
    // already took place.
    //

    MigrateData(phPSTProv, TRUE);

    // One-Time WinPW Init Code
    if (!BPMasterKeyExists(
            szUser,
            WSZ_PASSWORD_WINDOWS))
    {
        BYTE rgbPwd[A_SHA_DIGEST_LEN];

        // Init the Users' Windows password entry
        if (!FMyGetWinPassword(
                phPSTProv,
                szUser,
                rgbPwd
                ))
            goto Ret;

        if (!FCheckPWConfirm(
                szUser,
                WSZ_PASSWORD_WINDOWS,
                rgbPwd))
            goto Ret;

        //
        // newly created key: data migration is not necessary.
        // specify that only the migration flag need be updated
        //

        MigrateData(phPSTProv, FALSE);
    }


    dwRet = PST_E_OK;
Ret:
    if (hUserKey)
        RegCloseKey(hUserKey);

    if (szUser)
        SSFree(szUser);

    return dwRet;

}

HRESULT        SPReleaseContext(
    /* [in] */  PST_PROVIDER_HANDLE* phPSTProv,
    /* [in] */  DWORD   dwFlags)
{
    return PST_E_OK;
}

HRESULT        SPGetProvInfo(
        PPST_PROVIDERINFO*   ppPSTInfo,
        DWORD           dwFlags)
{
    HRESULT hr = PST_E_FAIL;

    if (0 != dwFlags)
        return PST_E_BAD_FLAGS;

    // Note: not linked to a specific context (hPSTProv)
    // Note: caller not verified -- give this info to anyone

    PPST_PROVIDERINFO pPSTInfo;
    if (NULL == (pPSTInfo = (PST_PROVIDERINFO*)SSAlloc(sizeof(PST_PROVIDERINFO))) )
        return PST_E_FAIL;
    ZeroMemory(pPSTInfo, sizeof(PST_PROVIDERINFO));


    pPSTInfo->cbSize = sizeof(PST_PROVIDERINFO);
    GUID guidBaseProvider = MS_BASE_PSTPROVIDER_ID;
    CopyMemory(&pPSTInfo->ID, &guidBaseProvider, sizeof(pPSTInfo->ID));

    pPSTInfo->Capabilities = PST_PC_ROAMABLE;

    if (NULL == (pPSTInfo->szProviderName = (LPWSTR)SSAlloc(sizeof(MS_BASE_PSTPROVIDER_NAME))) )
        goto Ret;
    wcscpy(pPSTInfo->szProviderName, MS_BASE_PSTPROVIDER_NAME);

    hr = PST_E_OK;
Ret:
    if (hr != PST_E_OK)
    {
        if (pPSTInfo->szProviderName)
            SSFree(pPSTInfo->szProviderName);

        SSFree(pPSTInfo);
        pPSTInfo = NULL;
    }

    // in either case, return pPSTInfo
    *ppPSTInfo = pPSTInfo;

    return hr;
}


HRESULT     SPGetProvParam(
    /* [in] */  PST_PROVIDER_HANDLE* phPSTProv,
    /* [in] */  DWORD           dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */
                BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */  DWORD           dwFlags)
{

    if( pcbData )
        *pcbData = 0;

    switch(dwParam)
    {

        case PST_PP_FLUSH_PW_CACHE:
        {
            return PST_E_OK;
        }

        default:
        {
            return PST_E_NYI;
        }

    }
}


HRESULT     SPSetProvParam(
    /* [in] */  PST_PROVIDER_HANDLE* phPSTProv,
    /* [in] */  DWORD           dwParam,
    /* [in] */  DWORD           cbData,
    /* [in] */  BYTE*           pbData,
    /* [in] */  DWORD           dwFlags)
{
    LPWSTR szUser = NULL;
    HRESULT hr = PST_E_OK;

    switch(dwParam)
    {
    case PST_PP_FLUSH_PW_CACHE:
        {
            if(g_pCUAList)
            {
                g_pCUAList->Reset();
                hr = PST_E_OK;
            }
            else
                hr = PST_E_FAIL;
            break;
        }

    case 0x324: // a yet unnamed param
        {
            hr = PST_E_FAIL;

            // get current user
            if (!g_sCallbacks.pfnFGetUser(
                    phPSTProv,
                    &szUser))
                goto Ret;

            // UI to chg pwds - uses callback to notify us
            if (!FChangePassword(NULL, szUser))
                goto Ret;

            hr = PST_E_OK;
            break;
        }
    default:
        {
            hr = PST_E_NYI;
            break;
        }
    }


Ret:
    if (szUser)
        SSFree(szUser);

    return hr;
}



HRESULT        SPEnumTypes(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [out] */ GUID *pguidType,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    LPWSTR szUser = NULL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    if (PST_E_OK != (dwRet =
        BPEnumTypes(
            szUser,
            dwIndex,
            pguidType)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT         SPGetTypeInfo(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ PPST_TYPEINFO *ppinfoType,
    /* [in] */ DWORD dwFlags)
{
    PST_TYPEINFO infoType = {sizeof(PST_TYPEINFO)};
    *ppinfoType = NULL;

    LPWSTR szUser = NULL;
    HRESULT dwRet = PST_E_FAIL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    if (PST_E_OK != (dwRet =
        BPGetTypeName(
            szUser,
            pguidType,
            &infoType.szDisplayName)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (dwRet == PST_E_OK)
    {
        *ppinfoType = (PPST_TYPEINFO)SSAlloc(sizeof(PST_TYPEINFO));
        if(NULL != *ppinfoType)
        {
            CopyMemory(*ppinfoType, &infoType, sizeof(PST_TYPEINFO));
        }
    }

    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT        SPEnumSubtypes(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [out] */ GUID *pguidSubtype,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    LPWSTR szUser = NULL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    if (PST_E_OK != (dwRet =
        BPEnumSubtypes(
            szUser,
            dwIndex,
            pguidType,
            pguidSubtype)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT         SPGetSubtypeInfo(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ PPST_TYPEINFO *ppinfoSubtype,
    /* [in] */ DWORD dwFlags)
{
    *ppinfoSubtype = NULL;
    PST_TYPEINFO infoSubtype = {sizeof(PST_TYPEINFO)};

    LPWSTR szUser = NULL;
    HRESULT dwRet = PST_E_FAIL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    if (PST_E_OK != (dwRet =
        BPGetSubtypeName(
            szUser,
            pguidType,
            pguidSubtype,
            &infoSubtype.szDisplayName)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (dwRet == PST_E_OK)
    {
        *ppinfoSubtype = (PPST_TYPEINFO)SSAlloc(sizeof(PST_TYPEINFO));
        if(NULL != *ppinfoSubtype)
        {
            CopyMemory(*ppinfoSubtype, &infoSubtype, sizeof(PST_TYPEINFO));
        }
    }

    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT        SPEnumItems(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [out] */ LPWSTR *ppszItemName,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    LPWSTR szUser = NULL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }


    if (PST_E_OK != (dwRet =
        BPEnumItems(
            szUser,
            pguidType,
            pguidSubtype,
            dwIndex,
            ppszItemName)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT        SPCreateType(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ PPST_TYPEINFO pinfoType,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    LPWSTR szUser = NULL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // Check for invalid "" input
    if (pinfoType == NULL ||
        pinfoType->szDisplayName == NULL ||
        (wcslen(pinfoType->szDisplayName) == 0)
        )
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    // if fail or already exist, fail!
    if (PST_E_OK != (dwRet =
        BPCreateType(
            szUser,
            pguidType,
            pinfoType)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:

    // if creation didn't happen, item shouldn't exist
    if ((dwRet != PST_E_OK) && (dwRet != PST_E_TYPE_EXISTS))
        BPDeleteType(szUser, pguidType);

    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT SPDeleteType(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    LPWSTR szUser = NULL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    // if fail or not empty, fail!
    if (PST_E_OK != (dwRet =
        BPDeleteType(
            szUser,
            pguidType)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:

    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT        SPCreateSubtype(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ PPST_TYPEINFO pinfoSubtype,
    /* [in] */ PPST_ACCESSRULESET psRules,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    LPWSTR  szUser = NULL;


    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags != 0)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // NULL Rules
    if (psRules == NULL)
    {
        dwRet = PST_E_INVALID_RULESET;
        goto Ret;
    }

    // Check for invalid "" input
    if (pinfoSubtype->szDisplayName == NULL || wcslen(pinfoSubtype->szDisplayName) == 0)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    // if fail or already exist, fail!
    if (PST_E_OK != (dwRet =
        BPCreateSubtype(
            szUser,
            pguidType,
            pguidSubtype,
            pinfoSubtype)) )
        goto Ret;


    dwRet = PST_E_OK;
Ret:
    // if creation didn't happen, item shouldn't exist
    if ((dwRet != PST_E_OK) && (dwRet != PST_E_TYPE_EXISTS))
        BPDeleteSubtype(szUser, pguidType, pguidSubtype);

    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT SPDeleteSubtype(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    LPWSTR szUser = NULL;

    PST_ACCESSRULESET sRules = {sizeof(sRules), 0, NULL};

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }


    // if fail or not empty, fail!
    if (PST_E_OK != (dwRet =
        BPDeleteSubtype(
            szUser,
            pguidType,
            pguidSubtype)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:

    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT     SPWriteItem(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID  *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE *pbData,
    /* [in] */ PPST_PROMPTINFO psPrompt,
    /* [in] */ DWORD dwDefaultConfirmationStyle,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;

    // assume we've made no change
    BOOL    fExisted = TRUE;
    LPWSTR  szUser = NULL;

    PST_ACCESSRULESET sRules = {sizeof(sRules), 0, NULL};

    BYTE rgbPwd[A_SHA_DIGEST_LEN];
    LPWSTR szMasterKey = NULL;

    LPWSTR szType=NULL, szSubtype=NULL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if ((dwFlags & ~(PST_UNRESTRICTED_ITEMDATA | PST_NO_OVERWRITE
        )) != 0)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    if ((dwDefaultConfirmationStyle & ~( PST_CF_DEFAULT |
                                    PST_CF_NONE
        )) != 0)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // Disable UI on write item.
    dwDefaultConfirmationStyle = PST_CF_NONE;
    if(psPrompt != NULL)
    {
        psPrompt->dwPromptFlags = 0;
    }


    // Check for invalid "" input
    if (wcslen(szItemName) == 0)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    if (dwFlags & PST_UNRESTRICTED_ITEMDATA)
    {
        // store insecure data stream
        if (PST_E_OK != (dwRet =
            BPSetInsecureItemData(
                szUser,
                pguidType,
                pguidSubtype,
                szItemName,
                pbData,
                cbData)) )
            goto Ret;

        dwRet = PST_E_OK;
        goto Ret;
    }

    // ELSE: secure stream

    {
        POPENITEM_LIST_ITEM pli;

        OPENITEM_LIST_ITEM li;
        if(NULL == g_pCOpenItemList)
        {
            dwRet = PST_E_FAIL;
            goto Ret;
        }
        CreateOpenListItem(&li, phPSTProv, Key, pguidType, pguidSubtype, szItemName);

        g_pCOpenItemList->LockList();

        // get opened (cached) item
        pli = g_pCOpenItemList->SearchList(&li);

        if ((pli != NULL) && (pli->ModeFlags & PST_WRITE) )
        {
            // Error if cached (it must exist) and "No Overwrite" specified
            if (dwFlags & PST_NO_OVERWRITE)
            {
                g_pCOpenItemList->UnlockList();
                dwRet = PST_E_ITEM_EXISTS;
                goto Ret;
            }

            // found cached item; pull real pwd
            CopyMemory(rgbPwd, pli->rgbPwd, A_SHA_DIGEST_LEN);
            szMasterKey = (LPWSTR) SSAlloc(WSZ_BYTECOUNT(pli->szMasterKey));

            if( szMasterKey )
                wcscpy(szMasterKey, pli->szMasterKey);

            //
            // unlock list.
            //

            g_pCOpenItemList->UnlockList();

            if( szMasterKey == NULL ) {
                dwRet = E_OUTOFMEMORY;
                goto Ret;
            }

            // PST_PF_ALWAYS_SHOW always forces UI
            if (PST_PF_ALWAYS_SHOW == psPrompt->dwPromptFlags)
            {
                // retrieve names of type, subtype
                if (PST_E_OK != (dwRet =
                    BPGetTypeName(
                        szUser,
                        pguidType,
                        &szType)) )
                    goto Ret;

                if (PST_E_OK != (dwRet =
                    BPGetSubtypeName(
                        szUser,
                        pguidType,
                        pguidSubtype,
                        &szSubtype)) )
                    goto Ret;

                if (PST_E_OK != (dwRet =
                    ShowOKCancelUI(
                        phPSTProv,
                        szUser,
                        Key,
                        szType,
                        szSubtype,
                        szItemName,
                        psPrompt,
                        g_PromptWriteItem)) )
                    goto Ret;
            }
        }
        else
        {
            //
            // unlock list.
            //

            g_pCOpenItemList->UnlockList();

            // not cached; do actual work

            // if fail or already exist
            if (PST_E_OK != (dwRet =
                BPCreateItem(
                    szUser,
                    pguidType,
                    pguidSubtype,
                    szItemName)) )
            {

                // on "No Overwrite", hr has right error code
                if (dwFlags & PST_NO_OVERWRITE)
                    goto Ret;

                // else swallow overwrite error
                if (dwRet != PST_E_ITEM_EXISTS)
                    goto Ret;
            }

            fExisted = (dwRet == PST_E_ITEM_EXISTS);

            // retrieve names of type, subtype
            if (PST_E_OK != (dwRet =
                BPGetTypeName(
                    szUser,
                    pguidType,
                    &szType)) )
                goto Ret;

            if (PST_E_OK != (dwRet =
                BPGetSubtypeName(
                    szUser,
                    pguidType,
                    pguidSubtype,
                    &szSubtype)) )
                goto Ret;

            // does ALL user confirm work
            if (PST_E_OK != (dwRet =
                GetUserConfirmBuf(
                    phPSTProv,
                    szUser,
                    Key,
                    szType,
                    pguidType,
                    szSubtype,
                    pguidSubtype,
                    szItemName,
                    psPrompt,
                    g_PromptWriteItem,
                    dwDefaultConfirmationStyle,
                    &szMasterKey,
                    rgbPwd,
                    0)) )
                goto Ret;
        }
    }

    // store the data itself
    if (!FBPSetSecuredItemData(
            szUser,
            szMasterKey,
            rgbPwd,
            pguidType,
            pguidSubtype,
            szItemName,
            pbData,
            cbData))
    {
        dwRet = PST_E_STORAGE_ERROR;
        goto Ret;
    }

    dwRet = PST_E_OK;
Ret:

    // if creation didn't happen, item shouldn't exist
    if ((dwRet != PST_E_OK) && (!fExisted))
        BPDeleteItem(szUser, pguidType, pguidSubtype, szItemName);


    if (szMasterKey)
        SSFree(szMasterKey);

    if (szUser)
        SSFree(szUser);

    if (szType)
        SSFree(szType);

    if (szSubtype)
        SSFree(szSubtype);

    return dwRet;
}

HRESULT     SPReadItem(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [out] */ DWORD *pcbData,
    /* [size_is][size_is][out] */ BYTE **ppbData,
    /* [in] */ PPST_PROMPTINFO psPrompt,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    PST_ACCESSRULESET sRules = {sizeof(sRules), 0, NULL};

    LPWSTR  szUser = NULL;
    LPWSTR  szMasterKey = NULL;
    LPWSTR  szCallerName = NULL;

    BYTE    rgbPwd[A_SHA_DIGEST_LEN];
    LPWSTR szType=NULL, szSubtype=NULL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if ((dwFlags & ~(PST_UNRESTRICTED_ITEMDATA | PST_PROMPT_QUERY |
                    PST_NO_UI_MIGRATION
        )) != 0)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // Disable unnecessary UI.
    dwFlags |= PST_NO_UI_MIGRATION;

    // Check for invalid "" input
    if (wcslen(szItemName) == 0)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    if (dwFlags & PST_UNRESTRICTED_ITEMDATA)
    {
        // read insecure data stream
        if (PST_E_OK != (dwRet =
            BPGetInsecureItemData(
                szUser,
                pguidType,
                pguidSubtype,
                szItemName,
                ppbData,
                pcbData)) )
            goto Ret;

        dwRet = PST_E_OK;
        goto Ret;
    }
    // ELSE: secure stream

    {
        POPENITEM_LIST_ITEM pli;

        OPENITEM_LIST_ITEM li;
        if(NULL == g_pCOpenItemList)
        {
            dwRet = PST_E_FAIL;
            goto Ret;
        }
        CreateOpenListItem(&li, phPSTProv, Key, pguidType, pguidSubtype, szItemName);

        g_pCOpenItemList->LockList();

        // get opened (cached) item
        pli = g_pCOpenItemList->SearchList(&li);

        if ((pli != NULL) && (pli->ModeFlags & PST_READ))
        {
            // found cached item; pull pwd
            CopyMemory(rgbPwd, pli->rgbPwd, A_SHA_DIGEST_LEN);
            szMasterKey = (LPWSTR) SSAlloc(WSZ_BYTECOUNT(pli->szMasterKey));
            if( szMasterKey )
                wcscpy(szMasterKey, pli->szMasterKey);

            //
            // unlock list.
            //

            g_pCOpenItemList->UnlockList();

            if( szMasterKey == NULL ) {
                dwRet = E_OUTOFMEMORY;
                goto Ret;
            }

            // PST_PF_ALWAYS_SHOW always forces UI
            if (PST_PF_ALWAYS_SHOW == psPrompt->dwPromptFlags)
            {
                // retrieve names of type, subtype
                if (PST_E_OK != (dwRet =
                    BPGetTypeName(
                        szUser,
                        pguidType,
                        &szType)) )
                    goto Ret;

                if (PST_E_OK != (dwRet =
                    BPGetSubtypeName(
                        szUser,
                        pguidType,
                        pguidSubtype,
                        &szSubtype)) )
                    goto Ret;

                if (PST_E_OK != (dwRet =
                    ShowOKCancelUI(
                        phPSTProv,
                        szUser,
                        Key,
                        szType,
                        szSubtype,
                        szItemName,
                        psPrompt,
                        g_PromptReadItem)) )
                    goto Ret;
            }
        }
        else
        {

            //
            // unlock list.
            //

            g_pCOpenItemList->UnlockList();

            // not cached; do actual work

            // retrieve names of type, subtype
            if (PST_E_OK != (dwRet =
                BPGetTypeName(
                    szUser,
                    pguidType,
                    &szType)) )
                goto Ret;

            if (PST_E_OK != (dwRet =
                BPGetSubtypeName(
                    szUser,
                    pguidType,
                    pguidSubtype,
                    &szSubtype)) )
                goto Ret;

            // does ALL user confirm work
            if (PST_E_OK != (dwRet =
                GetUserConfirmBuf(
                    phPSTProv,
                    szUser,
                    Key,
                    szType,
                    pguidType,
                    szSubtype,
                    pguidSubtype,
                    szItemName,
                    psPrompt,
                    g_PromptReadItem,
                    &szMasterKey,
                    rgbPwd,
                    dwFlags)) )
                goto Ret;

        }
    }

    // if checked out, then actually retrieve item
    if (!FBPGetSecuredItemData(
            szUser,
            szMasterKey,
            rgbPwd,
            pguidType,
            pguidSubtype,
            szItemName,
            ppbData,
            pcbData))
    {
        dwRet = PST_E_STORAGE_ERROR;
        goto Ret;
    }

    dwRet = PST_E_OK;

Ret:

    //
    // see if caller requested UI disposition on item.
    //

    if( dwRet == PST_E_OK && dwFlags & PST_PROMPT_QUERY ) {
        DWORD dwStoredConfirm;
        LPWSTR pszMasterKey;
        DWORD dwRetVal;

        dwRetVal = BPGetItemConfirm(
                        phPSTProv,
                        szUser,
                        pguidType,
                        pguidSubtype,
                        szItemName,
                        &dwStoredConfirm,
                        &pszMasterKey
                        );

        if( dwRetVal == PST_E_OK ) {

            SSFree( pszMasterKey );

            if( !(dwStoredConfirm & BP_CONFIRM_NONE) ) {
                if(FIsProviderUIAllowed( szUser ))
                    dwRet = PST_E_ITEM_EXISTS;
            }
        }
    }


    if (szUser)
        SSFree(szUser);

    if (szMasterKey)
        SSFree(szMasterKey);

    if (szType)
        SSFree(szType);

    if (szSubtype)
        SSFree(szSubtype);

    if (szCallerName)
        SSFree(szCallerName);

    return dwRet;
}

HRESULT     SPDeleteItem(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PPST_PROMPTINFO psPrompt,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    PST_ACCESSRULESET sRules = {sizeof(sRules), 0, NULL};

    LPWSTR  szUser = NULL;
    LPWSTR  szMasterKey = NULL;
    LPWSTR  szCallerName = NULL;

    BYTE    rgbPwd[A_SHA_DIGEST_LEN];
    LPWSTR szType=NULL, szSubtype=NULL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags & ~(PST_NO_UI_MIGRATION))
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // Disable unnecessary UI.
    dwFlags |= PST_NO_UI_MIGRATION;


    // Check for invalid "" input
    if (wcslen(szItemName) == 0)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }



    {
        POPENITEM_LIST_ITEM pli;

        OPENITEM_LIST_ITEM li;

        if(NULL == g_pCOpenItemList)
        {
            dwRet = PST_E_FAIL;
            goto Ret;
        }
        CreateOpenListItem(&li, phPSTProv, Key, pguidType, pguidSubtype, szItemName);

        g_pCOpenItemList->LockList();

        // get opened (cached) item
        pli = g_pCOpenItemList->SearchList(&li);

        if ((pli != NULL) && (pli->ModeFlags & PST_WRITE))
        {
            // found cached item; pull pwd
            CopyMemory(rgbPwd, pli->rgbPwd, A_SHA_DIGEST_LEN);
            szMasterKey = (LPWSTR) SSAlloc(WSZ_BYTECOUNT(pli->szMasterKey));
            if( szMasterKey )
                wcscpy(szMasterKey, pli->szMasterKey);

            g_pCOpenItemList->UnlockList();

            if( szMasterKey == NULL ) {
                dwRet = E_OUTOFMEMORY;
                goto Ret;
            }

            // PST_PF_ALWAYS_SHOW always forces UI
            if (PST_PF_ALWAYS_SHOW == psPrompt->dwPromptFlags)
            {
                // retrieve names of type, subtype
                if (PST_E_OK != (dwRet =
                    BPGetTypeName(
                        szUser,
                        pguidType,
                        &szType)) )
                    goto Ret;

                if (PST_E_OK != (dwRet =
                    BPGetSubtypeName(
                        szUser,
                        pguidType,
                        pguidSubtype,
                        &szSubtype)) )
                    goto Ret;

                if (PST_E_OK != (dwRet =
                    ShowOKCancelUI(
                        phPSTProv,
                        szUser,
                        Key,
                        szType,
                        szSubtype,
                        szItemName,
                        psPrompt,
                        g_PromptDeleteItem)) )
                    goto Ret;
            }
        }
        else
        {
            //
            // unlock list.
            //

            g_pCOpenItemList->UnlockList();


            // retrieve names of type, subtype
            if (PST_E_OK != (dwRet =
                BPGetTypeName(
                    szUser,
                    pguidType,
                    &szType)) )
                goto Ret;

            if (PST_E_OK != (dwRet =
                BPGetSubtypeName(
                    szUser,
                    pguidType,
                    pguidSubtype,
                    &szSubtype)) )
                goto Ret;

            // does ALL user confirm work
            if (PST_E_OK != (dwRet =
                GetUserConfirmBuf(
                    phPSTProv,
                    szUser,
                    Key,
                    szType,
                    pguidType,
                    szSubtype,
                    pguidSubtype,
                    szItemName,
                    psPrompt,
                    g_PromptDeleteItem,
                    &szMasterKey,
                    rgbPwd,
                    dwFlags)) )
                goto Ret;
        }
    }

    // if checked out, then actually remove item
    if (PST_E_OK != (dwRet =
        BPDeleteItem(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName)) )
        goto Ret;

    dwRet = PST_E_OK;

Ret:


    if (szUser)
        SSFree(szUser);

    if (szMasterKey)
        SSFree(szMasterKey);

    if (szType)
        SSFree(szType);

    if (szSubtype)
        SSFree(szSubtype);

    if (szCallerName)
        SSFree(szCallerName);

    return dwRet;
}



HRESULT     SPOpenItem(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PST_ACCESSMODE ModeFlags,
    /* [in] */ PPST_PROMPTINFO psPrompt,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    PST_ACCESSRULESET sRules = {sizeof(sRules), 0, NULL};

    LPWSTR  szUser = NULL;
    LPWSTR  szMasterKey = NULL;
    LPWSTR  szCallerName = NULL;

    BYTE    rgbPwd[A_SHA_DIGEST_LEN];
    LPWSTR szType=NULL, szSubtype=NULL;

    POPENITEM_LIST_ITEM pli = NULL;


    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // Check for invalid "" input
    if (wcslen(szItemName) == 0)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // check for item already open
    {
        OPENITEM_LIST_ITEM li;
        if(NULL == g_pCOpenItemList)
        {
            dwRet = PST_E_FAIL;
            goto Ret;
        }
        CreateOpenListItem(&li, phPSTProv, Key, pguidType, pguidSubtype, szItemName);

        // get opened (cached) item
        pli = g_pCOpenItemList->SearchList(&li);

        if (pli != NULL)
        {
            // item already cached; error!
            dwRet = (DWORD)PST_E_ALREADY_OPEN;
            goto Ret;
        }
    }


    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    // retrieve names of type, subtype
    if (PST_E_OK != (dwRet =
        BPGetTypeName(
            szUser,
            pguidType,
            &szType)) )
        goto Ret;

    if (PST_E_OK != (dwRet =
        BPGetSubtypeName(
            szUser,
            pguidType,
            pguidSubtype,
            &szSubtype)) )
        goto Ret;


    // does ALL user confirm work
    if (PST_E_OK != (dwRet =
        GetUserConfirmBuf(
            phPSTProv,
            szUser,
            Key,
            szType,
            pguidType,
            szSubtype,
            pguidSubtype,
            szItemName,
            psPrompt,
            g_PromptOpenItem,
            &szMasterKey,
            rgbPwd,
            0)) )
        goto Ret;

    // if checked out, then add to open item list
    pli = (POPENITEM_LIST_ITEM) SSAlloc(sizeof(OPENITEM_LIST_ITEM));
    if(NULL == pli)
    {
        dwRet = PST_E_FAIL;
        goto Ret;
    }


    // fill in contents
    CreateOpenListItem(pli, phPSTProv, Key, pguidType, pguidSubtype, NULL);

    pli->szItemName = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(szItemName));
    wcscpy(pli->szItemName, szItemName);

    pli->szMasterKey = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(szMasterKey));
    wcscpy(pli->szMasterKey, szMasterKey);

    CopyMemory(pli->rgbPwd, rgbPwd, A_SHA_DIGEST_LEN);
    pli->ModeFlags = ModeFlags;

    // add to the open list
    g_pCOpenItemList->AddToList(pli);

    dwRet = PST_E_OK;
Ret:


    if (szUser)
        SSFree(szUser);

    if (szMasterKey)
        SSFree(szMasterKey);

    if (szType)
        SSFree(szType);

    if (szSubtype)
        SSFree(szSubtype);

    if (szCallerName)
        SSFree(szCallerName);

    return dwRet;
}


HRESULT     SPCloseItem(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // Check for invalid "" input
    if (wcslen(szItemName) == 0)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // if item found in list, remove it
    OPENITEM_LIST_ITEM li;
    if(NULL == g_pCOpenItemList)
    {
        dwRet = PST_E_FAIL;
        goto Ret;
    }
    CreateOpenListItem(&li, phPSTProv, Key, pguidType, pguidSubtype, szItemName);

    if (!g_pCOpenItemList->DelFromList(&li))
    {
        dwRet = PST_E_NOT_OPEN;
        goto Ret;
    }

    dwRet = PST_E_OK;
Ret:

    return dwRet;
}


///////////////////////////////////////////////////
// FInitProtectAPIGlobals
//
// Checks for registry overrides for some default values
// registry entries can change what algs are being used,
// as well as what provider is used.
BOOL FInitProtectAPIGlobals()
{
    HKEY    hProtectKey = NULL;
    HKEY    hProviderKey = NULL;
    DWORD   dwTemp, dwType, cbSize;
    DWORD   dwCreate;
    static const WCHAR szProtectKeyName[] = REG_CRYPTPROTECT_LOC;
    static const WCHAR szProviderKeyName[] = L"\\" REG_CRYPTPROTECT_PROVIDERS_SUBKEYLOC L"\\" CRYPTPROTECT_DEFAULT_PROVIDER_GUIDSZ ;

    LONG    lRet;





    //
    // get password cache policy setting.
    //


    lRet = RegOpenKeyExU(
                    HKEY_LOCAL_MACHINE,
                    L"Software\\Policies\\Microsoft\\Cryptography\\Protect",
                    0,
                    KEY_QUERY_VALUE,
                    &hProtectKey
                    );

    if( lRet == ERROR_SUCCESS ) {

        DWORD cbSize;
        DWORD dwTemp;
        DWORD dwType;

        //
        // query EnableCachePW value.
        //


        cbSize = sizeof(DWORD);
        lRet = RegQueryValueExU(
                        hProtectKey,
                        REG_CRYPTPROTECT_ALLOW_CACHEPW,
                        NULL,
                        &dwType,
                        (PBYTE)&dwTemp,
                        &cbSize
                        );

        if( lRet == ERROR_SUCCESS &&
            dwType == REG_DWORD &&
            dwTemp == 0 // 0 == disablePW cache
            ) {
            g_fAllowCachePW = FALSE;
        } else {
            g_fAllowCachePW = TRUE;
        }


        RegCloseKey( hProtectKey );
        hProtectKey = NULL;
    } else {

        g_fAllowCachePW = TRUE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\passwd.h ===
// is this a user key or not? 
BOOL    FIsUserMasterKey(
    LPCWSTR                 szMasterKey);


// retreive the users' windows password buffer
BOOL    FMyGetWinPassword(
    PST_PROVIDER_HANDLE* phPSTProv, 
    LPCWSTR szUser,
    BYTE rgbPwd[A_SHA_DIGEST_LEN]);

DWORD BPVerifyPwd(
    PST_PROVIDER_HANDLE*    phPSTProv,
    LPCWSTR                 szUser,
    LPCWSTR                 szMasterKey,
    BYTE                    rgbPwd[],
    DWORD                   dwPasswordOption);

// retrieves user defaults
HRESULT GetUserConfirmDefaults(
    PST_PROVIDER_HANDLE*    phPSTProv,
    DWORD*                  pdwDefaultConfirmationStyle,
    LPWSTR*                 ppszMasterKey);

// Be-all, end-all of user confirmation APIs
// gets whatever confirmation is necessary
HRESULT GetUserConfirmBuf(
    PST_PROVIDER_HANDLE*    phPSTProv,
    LPCWSTR                 szUser,
    PST_KEY                 Key,
    LPCWSTR                 szType,
    const GUID*             pguidType,
    LPCWSTR                 szSubtype,
    const GUID*             pguidSubtype,
    LPCWSTR                 szItemName,
    PPST_PROMPTINFO         psPrompt,
    LPCWSTR                 szAction,
    DWORD                   dwDefaultConfirmationStyle,
    LPWSTR*                 ppszMasterKey,
    BYTE                    rgbPwd[A_SHA_DIGEST_LEN],
    DWORD                   dwFlags);

// Calls above API with PST_CF_DEFAULT as dwDefaultConfirmationStyle
HRESULT GetUserConfirmBuf(
    PST_PROVIDER_HANDLE*    phPSTProv,
    LPCWSTR                 szUser,
    PST_KEY                 Key,
    LPCWSTR                 szType,
    const GUID*             pguidType,
    LPCWSTR                 szSubtype,
    const GUID*             pguidSubtype,
    LPCWSTR                 szItemName,
    PPST_PROMPTINFO         psPrompt,
    LPCWSTR                 szAction,
    LPWSTR*                 ppszMasterKey,
    BYTE                    rgbPwd[A_SHA_DIGEST_LEN],
    DWORD                   dwFlags);

// forces UI with OK/Cancel behavior
HRESULT ShowOKCancelUI(
    PST_PROVIDER_HANDLE*    phPSTProv,
    LPCWSTR                 szUser,
    PST_KEY                 Key,
    LPCWSTR                 szType,
    LPCWSTR                 szSubtype,
    LPCWSTR                 szItemName,
    PPST_PROMPTINFO         psPrompt,
    LPCWSTR                 szAction);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\secure.h ===
// length of the salt to append to password
#define     PASSWORD_SALT_LEN       16

// Primitive functions not shown 
#define OLD_HMAC_VERSION    0x01
#define NEW_HMAC_VERSION    0x02

// externally used functions
BOOL FProvEncryptData(
            LPCWSTR  szUser,        // in
            LPCWSTR  szMasterKey,   // in
            BYTE    rgbPwd[],       // in, must be A_SHA_DIGEST_LEN
            PBYTE*	ppbMyData,      // in out
            DWORD*	pcbMyData);     // in out

BOOL FProvDecryptData(
            LPCWSTR  szUser,        // in
            LPCWSTR  szMasterKey,   // in
            BYTE    rgbPwd[],       // in, must be A_SHA_DIGEST_LEN
            PBYTE*  ppbData,        // in out
            DWORD*  pcbData);       // in out

BOOL FCheckPWConfirm(
            LPCWSTR  szUser,        // in
            LPCWSTR  szMasterKey,   // in
		    BYTE    rgbPwd[]);  	// in

BOOL FPasswordChangeNotify(
            LPCWSTR  szUser,        // in
            LPCWSTR  szPasswordName,// in
            BYTE    rgbOldPwd[],    // in, must be A_SHA_DIGEST_LEN
            DWORD   cbOldPwd,       // in
            BYTE    rgbNewPwd[],    // in, must be A_SHA_DIGEST_LEN
            DWORD   cbNewPwd);      // in


// performs MAC with location data, making data immovable
BOOL FHMACGeographicallySensitiveData(
            LPCWSTR szUser,                         // in
            LPCWSTR szPasswordName,                 // in
            DWORD   dwMACVersion,                   // handle old, new MACs
            BYTE    rgbPwd[],	                    // in, must be A_SHA_DIGEST_LEN
            const GUID* pguidType,                  // in
            const GUID* pguidSubtype,               // in
            LPCWSTR szItem,                         // in, may be NULL
            PBYTE pbBuf,                            // in
            DWORD cbBuf,                            // in
            BYTE rgbHMAC[]);                        // out, must be A_SHA_DIGEST_LEN

// given pwd, salt, and ptr to master key buffer,
// decrypts and checks MAC on master key
BOOL FMyDecryptMK(
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],
            BYTE    rgbConfirm[A_SHA_DIGEST_LEN],
            PBYTE*  ppbMK,
            DWORD*  pcbMK);

BOOL
FMyDecryptMKEx(
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],
            BYTE    rgbConfirm[A_SHA_DIGEST_LEN],
            PBYTE*  ppbMK,
            DWORD*  pcbMK,
            BOOL    *pfResetSecurityState
            );

// given pwd, salt, and Master Key buffer, MACs and Encrypts Master Key buffer
BOOL FMyEncryptMK(
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],
            BYTE    rgbConfirm[A_SHA_DIGEST_LEN],
            PBYTE*  ppbMK,
            DWORD*  pcbMK);


// France check
BOOL FIsEncryptionPermitted();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\svr\acl.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    acl.h

Abstract:

    This module contains routines to support core security operations in
    the Protected Storage Server.

Author:

    Scott Field (sfield)    25-Nov-96

--*/

#include "pstypes.h"
#include "dispif.h"


// allows server service and providers to impersonate calling client
BOOL
FImpersonateClient(
    IN  PST_PROVIDER_HANDLE *hPSTProv
    );

BOOL
FRevertToSelf(
    IN  PST_PROVIDER_HANDLE *hPSTProv
    );

// gets the user that made the call
BOOL
FGetUserName(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    OUT LPWSTR*             ppszUser
    );

// gets the image name for the process
BOOL
FGetParentFileName(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    OUT LPWSTR*             ppszName,
    OUT DWORD_PTR               *lpdwBaseAddress
    );

// gets hash of specified filename
BOOL
FGetDiskHash(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    IN  LPWSTR              szImageName,
    IN  BYTE                Hash[A_SHA_DIGEST_LEN]
    );

// check if specified file matches authenticode criteria
BOOL
FIsSignedBinary(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    IN  LPWSTR              szFileName,     // File name (path) to validate against
    IN  LPWSTR              szRootCA,       // Root CA
    IN  LPWSTR              szIssuer,       // Issuer
    IN  LPWSTR              szPublisher,    // publisher
    IN  LPWSTR              szProgramName,  // Program name (opus info)
    IN  BOOL                fPartialMatch   // partial or full field matching
    );

// determines if memory image matches expected value
BOOL
FCheckMemoryImage(
    IN  PST_PROVIDER_HANDLE *hPSTProv,      // handle to identify "owner"
    IN  LPWSTR              szImagePath,    // file to compute+check memory hash
    IN  DWORD               dwBaseAddress   // base address where module loaded
    );

// gets the direct caller to pstore COM interface module path + base address
BOOL
FGetDirectCaller(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    OUT LPWSTR              *pszDirectCaller,
    OUT LPVOID              *BaseAddress
    );
#if 0

BOOL
FCheckSecurityDescriptor(
    IN  PST_PROVIDER_HANDLE     *hPSTProv,
    IN  PSECURITY_DESCRIPTOR    pSD,
    IN  DWORD                   dwDesiredAccess
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\storage.cpp ===
#include <pch.cpp>
#pragma hdrstop


#include "guidcnvt.h"

#include "passwd.h"
#include "storage.h"




extern DISPIF_CALLBACKS    g_sCallbacks;


// note: REG_PSTTREE_LOC moved to pstprv.h

#define REG_DATA_LOC                L"Data"
#define REG_MK_LOC                  L"Data 2"

#define REG_ACCESSRULE_LOC          L"Access Rules"
#define REG_DISPLAYSTRING_VALNAME   L"Display String"

#define REG_USER_INTERNAL_MAC_KEY   L"Blocking"

#define REG_ITEM_SECURE_DATA_VALNAME   L"Item Data"
#define REG_ITEM_INSECURE_DATA_VALNAME L"Insecure Data"
#define REG_ITEM_MK_VALNAME         L"Behavior"

#define REG_SECURITY_SALT_VALNAME   L"Value"



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// PRIMITIVIES for snagging registry keys

DWORD GetPSTUserHKEY(LPCWSTR szUser, HKEY* phUserKey, BOOL* pfExisted)
{
    HKEY hKeyBase = NULL;
    DWORD dwRet = (DWORD)PST_E_STORAGE_ERROR;

    DWORD dwCreate;
    DWORD cbKeyName;
    LPWSTR szKeyName = NULL;
    WCHAR FastBuffer[(sizeof(REG_PSTTREE_LOC) / sizeof(WCHAR)) + 64];
    LPWSTR SlowBuffer = NULL;
    LPCWSTR szContainer = szUser;
    DWORD dwDesiredAccess = KEY_READ | KEY_WRITE;

    cbKeyName = sizeof(REG_PSTTREE_LOC) ;

    //
    // For Win95, we may have an empty or NULL container
    // name (szUser), so use a default storage area for
    // that scenario
    //

    if(szContainer == NULL || szContainer[0] == L'\0') {
        // "*" is an invalid LM username character
        szContainer = L"*Default*";
        hKeyBase = HKEY_LOCAL_MACHINE;
    } else {

        //
        // see if we should go to HKEY_LOCAL_MACHINE or
        // HKEY_CURRENT_USER
        //

        if( _wcsicmp(WSZ_LOCAL_MACHINE, szContainer) == 0 ) {
            // HKEY_LOCAL_MACHINE
            hKeyBase = HKEY_LOCAL_MACHINE;
        } else {
            // HKEY_CURRENT_USER
            if(!GetUserHKEY(szContainer, dwDesiredAccess, &hKeyBase)) {
                if(FIsWinNT()) {
                    goto Ret;
                }

                //
                // Win95, profiles may be disabled, so go to
                // HKEY_LOCAL_MACHINE\xxx\szContainer
                //

                hKeyBase = HKEY_LOCAL_MACHINE;

            } else {

                //
                // no container name when going to HKEY_CURRENT_USER
                //

                //
                // sfield: continue to use a container name for HKEY_CURRENT_USER
                // because the configuration may be shared, roamable hives
                // (mandatators profiles, etc, which we are telling people not
                //  to use anymore, but never-the-less, this could come up
                //

    //            szContainer = L"\0";
            }
        }
    }

    cbKeyName += (lstrlenW(szContainer) * sizeof(WCHAR)) +
                 sizeof(WCHAR) + // L'\\'
                 sizeof(WCHAR) ; // terminal NULL

    //
    // use faster stack based buffer if the material fits
    //

    if(cbKeyName > sizeof(FastBuffer)) {
        SlowBuffer = (LPWSTR)SSAlloc( cbKeyName );

        if (SlowBuffer == NULL)
        {
            dwRet = (DWORD)PST_E_FAIL;
            goto Ret;
        }
        szKeyName = SlowBuffer;
    } else {
        szKeyName = FastBuffer;
    }

    wcscpy(szKeyName, REG_PSTTREE_LOC);

    //
    // work-around bug in RegCreateKeyEx that returns the wrong
    // creation disposition if a trailing "\" is in the key name
    //

    if(szContainer && szContainer[0] != L'\0') {
        wcscat(szKeyName, L"\\");
        wcscat(szKeyName, szContainer);
    }

    // Open Base Key //
    // get current user, open (REG_PSTTREE_LOC\\CurrentUser)
    if (ERROR_SUCCESS !=
        RegCreateKeyExU(
            hKeyBase,
            szKeyName,
            0,
            NULL,                       // address of class string
            0,
            dwDesiredAccess,
            NULL,
            phUserKey,
            &dwCreate))
    {
        goto Ret;
    }

    if (pfExisted) {
        *pfExisted = (dwCreate == REG_OPENED_EXISTING_KEY);
    }

    if(dwCreate == REG_CREATED_NEW_KEY && FIsWinNT()) {

        //
        // WinNT: restrict access to Local System on newly created key.
        //

        HKEY hKeyWriteDac;

        //
        // duplicate to WRITE_DAC access key and use that
        //

        if(ERROR_SUCCESS == RegOpenKeyExW(*phUserKey, NULL, 0, WRITE_DAC, &hKeyWriteDac)) {
            SetRegistrySecurity(hKeyWriteDac);
            RegCloseKey(hKeyWriteDac);
        }
    }

    dwRet = PST_E_OK;
Ret:

    if (SlowBuffer)
        SSFree(SlowBuffer);

    //
    // close the per-user "root" key
    //

    if(hKeyBase != NULL && hKeyBase != HKEY_LOCAL_MACHINE)
        RegCloseKey(hKeyBase);

    return dwRet;
}


DWORD GetPSTTypeHKEY(LPCWSTR szUser, const GUID* pguidType, HKEY* phTypeKey)
{
    DWORD dwRet;
    HKEY hBaseKey = NULL;
    HKEY hDataKey = NULL;

    CHAR rgszTypeGuid[MAX_GUID_SZ_CHARS];

    // Open User Key //
    if (PST_E_OK != (dwRet =
        GetPSTUserHKEY(
            szUser,
            &hBaseKey,
            NULL)) )
        goto Ret;

    // Open Data Key //
    if (ERROR_SUCCESS !=
        RegOpenKeyExU(
            hBaseKey,
            REG_DATA_LOC,
            0,
            KEY_READ | KEY_WRITE,
            &hDataKey))
    {
        dwRet = (DWORD)PST_E_TYPE_NO_EXISTS;
        goto Ret;
    }

    if (PST_E_OK != (dwRet =
        MyGuidToStringA(
            pguidType,
            rgszTypeGuid)) )
        goto Ret;

    // Open Category Key //
    if (ERROR_SUCCESS !=
        RegOpenKeyExA(
            hDataKey,
            rgszTypeGuid,
            0,
            KEY_READ | KEY_WRITE,
            phTypeKey))
    {
        dwRet = (DWORD)PST_E_TYPE_NO_EXISTS;
        goto Ret;
    }

    dwRet = PST_E_OK;
Ret:
    if (hBaseKey)
        RegCloseKey(hBaseKey);

    if (hDataKey)
        RegCloseKey(hDataKey);

    return dwRet;
}


DWORD CreatePSTTypeHKEY(LPCWSTR szUser, const GUID* pguidType, HKEY* phTypeKey, BOOL* pfExisted)
{
    DWORD dwRet;
    DWORD dwCreate;
    HKEY hBaseKey = NULL;
    HKEY hDataKey = NULL;

    CHAR rgszTypeGuid[MAX_GUID_SZ_CHARS];

    // Open User Key //
    if (PST_E_OK != (dwRet =
        GetPSTUserHKEY(
            szUser,
            &hBaseKey,
            NULL)) )
        goto Ret;

    // Open Data Key //
    if (ERROR_SUCCESS !=
        RegCreateKeyExU(
            hBaseKey,
            REG_DATA_LOC,
            0,
            NULL,                       // address of class string
            0,
            KEY_READ | KEY_WRITE,
            NULL,
            &hDataKey,
            &dwCreate))
    {
        dwRet = (DWORD)PST_E_STORAGE_ERROR;
        goto Ret;
    }

    if (PST_E_OK != (dwRet =
        MyGuidToStringA(
            pguidType,
            rgszTypeGuid)) )
        goto Ret;

    // Open Category Key //
    if (ERROR_SUCCESS !=
        RegCreateKeyExA(
            hDataKey,
            rgszTypeGuid,
            0,
            NULL,                       // address of class string
            0,
            KEY_READ | KEY_WRITE,
            NULL,
            phTypeKey,
            &dwCreate))
    {
        dwRet = (DWORD)PST_E_STORAGE_ERROR;
        goto Ret;
    }

    if (pfExisted)
        *pfExisted = (dwCreate == REG_OPENED_EXISTING_KEY);

    dwRet = PST_E_OK;
Ret:
    if (hBaseKey)
        RegCloseKey(hBaseKey);

    if (hDataKey)
        RegCloseKey(hDataKey);

    return dwRet;
}

DWORD GetPSTMasterKeyHKEY(LPCWSTR szUser, LPCWSTR szMasterKey, HKEY* phMyKey)
{
    DWORD dwRet;
    DWORD dwCreate;
    HKEY hBaseKey = NULL;
    HKEY hMKKey = NULL;

    // Open User Key //
    if (PST_E_OK != (dwRet =
        GetPSTUserHKEY(
            szUser,
            &hBaseKey,
            NULL)) )
        goto Ret;

    // Open Master Key section //
    if (ERROR_SUCCESS !=
        RegCreateKeyExU(
            hBaseKey,
            REG_MK_LOC,
            0,
            NULL,                       // address of class string
            0,
            KEY_READ | KEY_WRITE,
            NULL,
            &hMKKey,
            &dwCreate))
    {
        dwRet = (DWORD)PST_E_STORAGE_ERROR;
        goto Ret;
    }

    if (szMasterKey)
    {
        // Open specific Master Key //
        if (ERROR_SUCCESS !=
            RegCreateKeyExU(
                hMKKey,
                szMasterKey,
                0,
                NULL,                       // address of class string
                0,
                KEY_READ | KEY_WRITE,
                NULL,
                phMyKey,
                &dwCreate))
        {
            dwRet = (DWORD)PST_E_STORAGE_ERROR;
            goto Ret;
        }
    }
    else
    {
        // wanted master parent, not specific MK
        *phMyKey = hMKKey;
    }

    dwRet = PST_E_OK;
Ret:
    if (hBaseKey)
        RegCloseKey(hBaseKey);

    // wanted parent, not specific MK
    if ((*phMyKey != hMKKey) && (hMKKey))
        RegCloseKey(hMKKey);

    return dwRet;
}

DWORD GetPSTSubtypeHKEY(LPCWSTR szUser, const GUID* pguidType, const GUID* pguidSubtype, HKEY* phSubTypeKey)
{
    DWORD dwRet;
    DWORD dwCreate;
    HKEY hTypeKey = NULL;
    CHAR rgszSubtypeGuid[MAX_GUID_SZ_CHARS];

    // Open User Key //
    if (PST_E_OK != (dwRet =
        GetPSTTypeHKEY(
            szUser,
            pguidType,
            &hTypeKey)) )
        goto Ret;

    if (PST_E_OK != (dwRet =
        MyGuidToStringA(
            pguidSubtype,
            rgszSubtypeGuid)) )
        goto Ret;

    // Open SubType Key //
    if (ERROR_SUCCESS !=
        RegOpenKeyExA(
            hTypeKey,
            rgszSubtypeGuid,
            0,
            KEY_READ | KEY_WRITE,
            phSubTypeKey))
    {
        dwRet = (DWORD)PST_E_TYPE_NO_EXISTS;
        goto Ret;
    }

    dwRet = PST_E_OK;
Ret:
    if (hTypeKey)
        RegCloseKey(hTypeKey);

    return dwRet;
}


DWORD CreatePSTSubtypeHKEY(LPCWSTR szUser, const GUID* pguidType, const GUID* pguidSubtype, HKEY* phSubTypeKey, BOOL* pfExisted)
{
    DWORD dwRet;
    DWORD dwCreate;
    HKEY hTypeKey = NULL;
    CHAR rgszSubtypeGuid[MAX_GUID_SZ_CHARS];

    // Open Type Key //
    if (PST_E_OK != (dwRet =
        GetPSTTypeHKEY(
            szUser,
            pguidType,
            &hTypeKey)) )
        goto Ret;

    if (PST_E_OK != (dwRet =
        MyGuidToStringA(
            pguidSubtype,
            rgszSubtypeGuid)) )
        goto Ret;

    // Open SubType Key //
    if (ERROR_SUCCESS !=
        RegCreateKeyExA(
            hTypeKey,
            rgszSubtypeGuid,
            0,
            NULL,                       // address of class string
            0,
            KEY_READ | KEY_WRITE,
            NULL,
            phSubTypeKey,
            &dwCreate))
    {
        dwRet = (DWORD)PST_E_STORAGE_ERROR;
        goto Ret;
    }

    if (pfExisted)
        *pfExisted = (dwCreate == REG_OPENED_EXISTING_KEY);

    dwRet = PST_E_OK;
Ret:
    if (hTypeKey)
        RegCloseKey(hTypeKey);

    return dwRet;
}

DWORD CreatePSTItemHKEY(LPCWSTR szUser, const GUID* pguidType, const GUID* pguidSubtype, LPCWSTR szItemName, HKEY* phItemKey, BOOL* pfExisted)
{
    BOOL dwRet;
    DWORD dwCreate;
    HKEY hSubTypeKey = NULL;

    // Open SubType key //
    if (PST_E_OK != (dwRet =
        GetPSTSubtypeHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            &hSubTypeKey)) )
        goto Ret;

    // Open name key //
    if (ERROR_SUCCESS !=
        RegCreateKeyExU(
            hSubTypeKey,
            szItemName,
            0,
            NULL,                       // address of class string
            0,
            KEY_READ | KEY_WRITE,
            NULL,
            phItemKey,
            &dwCreate))
    {
        dwRet = (DWORD)PST_E_STORAGE_ERROR;
        goto Ret;
    }

    if (pfExisted)
        *pfExisted = (dwCreate == REG_OPENED_EXISTING_KEY);

    dwRet = PST_E_OK;
Ret:
    if (hSubTypeKey)
        RegCloseKey(hSubTypeKey);

    return dwRet;
}

DWORD GetPSTItemHKEY(LPCWSTR szUser, const GUID* pguidType, const GUID* pguidSubtype, LPCWSTR szItemName, HKEY* phItemKey)
{
    DWORD dwRet;
    DWORD dwCreate;
    HKEY hSubtypeKey = NULL;

    // Open SubType key //
    if (PST_E_OK != (dwRet =
        GetPSTSubtypeHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            &hSubtypeKey)) )
        goto Ret;

    // Open name key //
    if (ERROR_SUCCESS !=
        RegOpenKeyExU(
            hSubtypeKey,
            szItemName,
            0,
            KEY_READ | KEY_WRITE,
            phItemKey))
    {
        dwRet = (DWORD)PST_E_ITEM_NO_EXISTS;
        goto Ret;
    }

    dwRet = PST_E_OK;
Ret:
    if (hSubtypeKey)
        RegCloseKey(hSubtypeKey);

    return dwRet;
}

// end PRIMITIVES
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// PICKLE routines

#if 0

BOOL FAccessRulesPickle(
            PST_ACCESSRULESET *psRules,
            PBYTE* ppbPickled,
            DWORD* pcbPickled)
{
    BOOL fRet = FALSE;
    DWORD cbTotal = 0;
    DWORD dwRule;
    
    // ease-of-use write pointer
    PBYTE pbCurrentWrite;

    // init out params
    *ppbPickled = NULL;
    *pcbPickled = 0;

    // ASSERT new size member was initialized
    SS_ASSERT(psRules->cbSize == sizeof(PST_ACCESSRULESET));
    if (psRules->cbSize != sizeof(PST_ACCESSRULESET))
        goto Ret;

    cbTotal += sizeof(DWORD);               // Ruleset struct versioning

    cbTotal += sizeof(DWORD);               // # Rules in Ruleset

    // walk through each Rule in Ruleset
    for (dwRule=0; dwRule<psRules->cRules; dwRule++)
    {
        DWORD cClause;
        
        // ASSERT new size member was initialized
        SS_ASSERT(psRules->rgRules[dwRule].cbSize == sizeof(PST_ACCESSRULE));
        if (psRules->rgRules[dwRule].cbSize != sizeof(PST_ACCESSRULE))
            goto Ret;

        cbTotal += sizeof(DWORD);           // Rule struct versioning

        cbTotal += sizeof(PST_ACCESSMODE);  // mode in each Rule
        cbTotal += sizeof(DWORD);           // # Clauses in Rule

        // for each Rule, we'll have array of clauses
        for (cClause=0; cClause<psRules->rgRules[dwRule].cClauses; cClause++)
        {
            // ASSERT new size member was initialized
            SS_ASSERT(psRules->rgRules[dwRule].rgClauses[cClause].cbSize == sizeof(PST_ACCESSCLAUSE));
            if (psRules->rgRules[dwRule].rgClauses[cClause].cbSize != sizeof(PST_ACCESSCLAUSE))
                goto Ret;

            cbTotal += sizeof(DWORD);           // Clause struct versioning

            // we'll see every clause here
            cbTotal += sizeof(PST_ACCESSCLAUSETYPE);    // type in each clause
            cbTotal += sizeof(DWORD);       // # bytes in clause buffer
            cbTotal += psRules->rgRules[dwRule].rgClauses[cClause].cbClauseData; // buffer itself
        }
    }

    *ppbPickled = (BYTE*)SSAlloc(cbTotal);
    if(*ppbPickled == NULL)
        goto Ret;

    pbCurrentWrite = *ppbPickled;

    *pcbPickled = cbTotal;


    // copy Ruleset struct version
    *(DWORD*)pbCurrentWrite = psRules->cbSize;
    pbCurrentWrite += sizeof(DWORD);

    // copy # rules in ruleset
    *(DWORD*)pbCurrentWrite = psRules->cRules;
    pbCurrentWrite += sizeof(DWORD);

    // walk through each Rule in Ruleset
    for (dwRule=0; dwRule<psRules->cRules; dwRule++)
    {
        // copy Rule struct version
        *(DWORD*)pbCurrentWrite = psRules->rgRules[dwRule].cbSize;
        pbCurrentWrite += sizeof(DWORD);

        // copy # clauses in rule
        *(DWORD*)pbCurrentWrite = psRules->rgRules[dwRule].cClauses;
        pbCurrentWrite += sizeof(DWORD);

        // copy rule accessmode
        CopyMemory(pbCurrentWrite, &psRules->rgRules[dwRule].AccessModeFlags, sizeof(PST_ACCESSMODE));
        pbCurrentWrite += sizeof(PST_ACCESSMODE);

        // now for each Rule, we'll have array of clauses
        for (DWORD cClause=0; cClause<psRules->rgRules[dwRule].cClauses; cClause++)
        {
            PST_ACCESSCLAUSE* pTmp = &psRules->rgRules[dwRule].rgClauses[cClause];

            // copy clause struct version
            *(DWORD*)pbCurrentWrite = pTmp->cbSize;
            pbCurrentWrite += sizeof(DWORD);

            // clause type
            CopyMemory(pbCurrentWrite, &pTmp->ClauseType, sizeof(PST_ACCESSCLAUSETYPE));
            pbCurrentWrite += sizeof(PST_ACCESSCLAUSETYPE);

            // clause data buffer len
            *(DWORD*)pbCurrentWrite = pTmp->cbClauseData;
            pbCurrentWrite += sizeof(DWORD);

            // buffer itself
            CopyMemory(pbCurrentWrite, pTmp->pbClauseData, pTmp->cbClauseData);
            pbCurrentWrite += pTmp->cbClauseData;
        }
    }

#if DBG
    {
        // ASSERT!
        DWORD dwWroteBytes = (DWORD) (((DWORD_PTR)pbCurrentWrite) - ((DWORD_PTR)*ppbPickled));
        SS_ASSERT(dwWroteBytes == cbTotal);
        SS_ASSERT(cbTotal == *pcbPickled);
    }
#endif


    fRet = TRUE;
Ret:

    // on error and alloc, free
    if ((!fRet) && (*ppbPickled != NULL))
    {
        SSFree(*ppbPickled);
        *ppbPickled = NULL;
    }

    return fRet;
}



BOOL FAccessRulesUnPickle(
            PPST_ACCESSRULESET psRules,   // out
            PBYTE pbPickled,
            DWORD cbPickled)
{
    BOOL fRet = FALSE;

    PBYTE pbCurrentRead = pbPickled;
    DWORD cRule;

    // Ruleset struct version
    psRules->cbSize = *(DWORD*)pbCurrentRead;
    pbCurrentRead += sizeof(DWORD);

    // currently only one version known
    if (psRules->cbSize != sizeof(PST_ACCESSRULESET))
        goto Ret;

    // get # rules in ruleset
    cRule = *(DWORD*)pbCurrentRead;
    pbCurrentRead += sizeof(DWORD);

    // now we know how many Rule in Ruleset
    psRules->rgRules = (PST_ACCESSRULE*)SSAlloc(sizeof(PST_ACCESSRULE)*cRule);
    if(psRules->rgRules == NULL)
        goto Ret;

    psRules->cRules = cRule;

    // now unpack each Rule
    for (cRule=0; cRule<psRules->cRules; cRule++)
    {
        DWORD cClauses;

        // Ruleset struct version
        psRules->rgRules[cRule].cbSize = *(DWORD*)pbCurrentRead;
        // currently only one version known
        if (psRules->rgRules[cRule].cbSize != sizeof(PST_ACCESSRULE))
            goto Ret;

        pbCurrentRead += sizeof(DWORD);

        // get # clauses in rule
        cClauses = *(DWORD*)pbCurrentRead;
        pbCurrentRead += sizeof(DWORD);

        // now we know how many Clauses in Rule
        psRules->rgRules[cRule].rgClauses = (PST_ACCESSCLAUSE*)SSAlloc(sizeof(PST_ACCESSCLAUSE)*cClauses);
        if (psRules->rgRules[cRule].rgClauses == NULL)  // check allocation
            goto Ret;
        psRules->rgRules[cRule].cClauses = cClauses;

        // copy rule accessmode flags
        CopyMemory(&psRules->rgRules[cRule].AccessModeFlags, pbCurrentRead, sizeof(PST_ACCESSMODE));
        pbCurrentRead += sizeof(PST_ACCESSMODE);

        // now load each Clause
        for (DWORD cClause=0; cClause<psRules->rgRules[cRule].cClauses; cClause++)
        {
            PST_ACCESSCLAUSE* pTmp = &psRules->rgRules[cRule].rgClauses[cClause];

            // Clause struct version
            pTmp->cbSize = *(DWORD*)pbCurrentRead;
            // currently only one version known
            if (pTmp->cbSize != sizeof(PST_ACCESSCLAUSE))
                goto Ret;
            pbCurrentRead += sizeof(DWORD);


            CopyMemory(&pTmp->ClauseType, pbCurrentRead, sizeof(PST_ACCESSCLAUSETYPE));
            pbCurrentRead += sizeof(PST_ACCESSCLAUSETYPE);

            // clause data buffer len
            pTmp->cbClauseData = *(DWORD*)pbCurrentRead;
            pbCurrentRead += sizeof(DWORD);

            // buffer itself
            pTmp->pbClauseData = (PBYTE) SSAlloc(pTmp->cbClauseData);
            if (pTmp->pbClauseData == NULL)     // check allocation
                goto Ret;
            CopyMemory(pTmp->pbClauseData, pbCurrentRead, pTmp->cbClauseData);
            pbCurrentRead += pTmp->cbClauseData;
        }
    }

#if DBG
    {
        // ASSERT!
        DWORD dwReadBytes = (DWORD) (((DWORD_PTR)pbCurrentRead) - ((DWORD_PTR)pbPickled));
        SS_ASSERT(dwReadBytes == cbPickled);
    }
#endif

    fRet = TRUE;
Ret:
    if (!fRet)
        FreeRuleset(psRules);
    

    return fRet;
}


#endif

// end PICKLE routines
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// TYPE management

DWORD BPCreateType(
        LPCWSTR  szUser,            // in
        const GUID*   pguidType,          // in
        PST_TYPEINFO* pinfoType)    // in
{
    DWORD dwRet;
    BOOL fExisted;
    HKEY    hKey = NULL;

    // now we need to create entries in hierarchy
    if (PST_E_OK != (dwRet =
        CreatePSTTypeHKEY(
            szUser,
            pguidType,
            &hKey,
            &fExisted)) )
        goto Ret;

    // if we didn't create it, setting is an error
    if (fExisted)
    {
        dwRet = (DWORD)PST_E_TYPE_EXISTS;
        goto Ret;
    }

    if (ERROR_SUCCESS != (dwRet =
        RegSetValueExU(
            hKey,
            REG_DISPLAYSTRING_VALNAME,
            0,
            REG_SZ,
            (PBYTE)pinfoType->szDisplayName,
            WSZ_BYTECOUNT(pinfoType->szDisplayName))) )
        goto Ret;


    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwRet;
}

DWORD BPDeleteType(
        LPCWSTR  szUser,         // in
        const GUID*   pguidType)      // in
{
    DWORD dwRet;
    CHAR rgszTypeGuid[MAX_GUID_SZ_CHARS];

    // now remove the entry in hierarchy
    HKEY hBaseKey = NULL;
    HKEY hDataKey = NULL;

    if (PST_E_OK != (dwRet =
        GetPSTUserHKEY(
            szUser,
            &hBaseKey,
            NULL)) )
        goto Ret;

    // Open Data Key //
    if (ERROR_SUCCESS != (dwRet =
        RegOpenKeyExU(
            hBaseKey,
            REG_DATA_LOC,
            0,
            KEY_READ | KEY_WRITE,
            &hDataKey)) )
        goto Ret;

    if (PST_E_OK != (dwRet =
        MyGuidToStringA(
            pguidType,
            rgszTypeGuid)) )
        goto Ret;

    if (!FIsWinNT())
    {
        CHAR rgszTmp[MAX_GUID_SZ_CHARS];
        DWORD cbTmp = MAX_GUID_SZ_CHARS;
        FILETIME ft;
        HKEY hTestEmptyKey = NULL;

        // open the type
        if (ERROR_SUCCESS != (dwRet =
            RegOpenKeyExA(
                hDataKey,
                rgszTypeGuid,
                0,
                KEY_ALL_ACCESS,
                &hTestEmptyKey)) )
            goto Ret;

        // check for emptiness
        if (ERROR_NO_MORE_ITEMS !=
            RegEnumKeyExA(
                hTestEmptyKey,
                0,
                rgszTmp, // address of buffer for subkey name
                &cbTmp, // address for size of subkey buffer
                NULL,       // reserved
                NULL,       // pbclass
                NULL,       // cbclass
                &ft))
        {
            RegCloseKey(hTestEmptyKey);
            dwRet = (DWORD)PST_E_NOTEMPTY;
            goto Ret;
        }

        // close key before deletion
        RegCloseKey(hTestEmptyKey);
    }

    // now, remove the friendly name
    if (ERROR_SUCCESS != (dwRet =
        RegDeleteKeyA(
            hDataKey,
            rgszTypeGuid)) )
    {
        if (dwRet == ERROR_ACCESS_DENIED)
            dwRet = (DWORD)PST_E_NOTEMPTY;

        goto Ret;
    }

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hBaseKey)
        RegCloseKey(hBaseKey);

    if (hDataKey)
        RegCloseKey(hDataKey);

    return dwRet;
}

DWORD BPEnumTypes(
        LPCWSTR  szUser,         // in
        DWORD   dwIndex,        // in
        GUID*   pguidType)      // out
{
    DWORD dwRet;

    CHAR rgszGuidType[MAX_GUID_SZ_CHARS];
    DWORD cbName = MAX_GUID_SZ_CHARS;

    FILETIME ft;

    // now walk through types, returning them one by one
    HKEY hKey=NULL, hDataKey=NULL;

    if (PST_E_OK != (dwRet =
        GetPSTUserHKEY(
            szUser,
            &hKey,
            NULL)) )
        goto Ret;

    // Open Data Key //
    if (ERROR_SUCCESS != (dwRet =
        RegOpenKeyExU(
            hKey,
            REG_DATA_LOC,
            0,
            KEY_READ | KEY_WRITE,
            &hDataKey)) )
        goto Ret;

    // enum the dwIndex'th item, alloc & return
    if (ERROR_SUCCESS != (dwRet =
        RegEnumKeyExA(
            hDataKey,
            dwIndex,
            rgszGuidType, // address of buffer for subkey name
            &cbName,    // address for size of subkey buffer
            NULL,       // reserved
            NULL,       // pbclass
            NULL,       // cbclass
            &ft)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        MyGuidFromStringA(
            rgszGuidType,
            pguidType)) )
        goto Ret;

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hKey)
        RegCloseKey(hKey);

    if (hDataKey)
        RegCloseKey(hDataKey);

    return dwRet;
}

DWORD BPGetTypeName(
        LPCWSTR  szUser,            // in
        const GUID*   pguidType,          // in
        LPWSTR* ppszType)           // out
{
    HKEY hKey = NULL;
    DWORD cbName = 0;
    DWORD dwRet;

    if (PST_E_OK != (dwRet =
        GetPSTTypeHKEY(
            szUser,
            pguidType,
            &hKey)) )
    {
        dwRet = (DWORD)PST_E_TYPE_NO_EXISTS;
        goto Ret;
    }

    if (ERROR_SUCCESS != (dwRet =
        RegGetValue(
            hKey,
            REG_DISPLAYSTRING_VALNAME,
            (PBYTE*)ppszType,
            &cbName)) )
        goto Ret;

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwRet;
}

// end TYPE management
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// SUBTYPE management

DWORD BPCreateSubtype(
        LPCWSTR  szUser,            // in
        const GUID*   pguidType,          // in
        const GUID*   pguidSubtype,       // in
        PST_TYPEINFO* pinfoSubtype) // in
{
    DWORD dwRet;
    BOOL fExisted;

    // now we need to create entries in hierarchy
    HKEY    hKey = NULL;
    if (PST_E_OK != (dwRet =
        CreatePSTSubtypeHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            &hKey,
            &fExisted)) )
        goto Ret;

    // if we didn't create it, setting is an error
    if (fExisted)
    {
        dwRet = (DWORD)PST_E_TYPE_EXISTS;
        goto Ret;
    }

    if (ERROR_SUCCESS != (dwRet =
        RegSetValueExU(
            hKey,
            REG_DISPLAYSTRING_VALNAME,
            0,
            REG_SZ,
            (PBYTE)pinfoSubtype->szDisplayName,
            WSZ_BYTECOUNT(pinfoSubtype->szDisplayName) )) )
        goto Ret;

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwRet;
}

DWORD BPDeleteSubtype(
        LPCWSTR  szUser,         // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype)   // in
{
    DWORD dwRet;
    CHAR rgszSubtypeGuid[MAX_GUID_SZ_CHARS];

    // now remove the entry in hierarchy
    HKEY hKey = NULL;
    if (PST_E_OK != (dwRet =
        GetPSTTypeHKEY(
            szUser,
            pguidType,
            &hKey)) )
    {
        dwRet = (DWORD)PST_E_TYPE_NO_EXISTS;
        goto Ret;
    }

    if (PST_E_OK != (dwRet =
        MyGuidToStringA(
            pguidSubtype,
            rgszSubtypeGuid)) )
        goto Ret;

    if (!FIsWinNT())
    {
        CHAR rgszTmp[MAX_GUID_SZ_CHARS];
        DWORD cbTmp = MAX_GUID_SZ_CHARS;
        FILETIME ft;
        HKEY hTestEmptyKey = NULL;

        // open the subtype
        if (ERROR_SUCCESS != (dwRet =
            RegOpenKeyExA(
                hKey,
                rgszSubtypeGuid,
                0,
                KEY_ALL_ACCESS,
                &hTestEmptyKey)) )
            goto Ret;

        // check for emptiness
        if (ERROR_NO_MORE_ITEMS !=
            RegEnumKeyExA(
                hTestEmptyKey,
                0,
                rgszTmp, // address of buffer for subkey name
                &cbTmp, // address for size of subkey buffer
                NULL,       // reserved
                NULL,       // pbclass
                NULL,       // cbclass
                &ft))
        {
            RegCloseKey(hTestEmptyKey);
            dwRet = (DWORD)PST_E_NOTEMPTY;
            goto Ret;
        }

        // close key before deletion
        RegCloseKey(hTestEmptyKey);
    }

    // now, remove the friendly name
    if (ERROR_SUCCESS != (dwRet =
        RegDeleteKeyA(
            hKey,
            rgszSubtypeGuid)) )
    {
        if (dwRet == ERROR_ACCESS_DENIED)
            dwRet = (DWORD)PST_E_NOTEMPTY;

        goto Ret;
    }

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwRet;
}

DWORD BPEnumSubtypes(
        LPCWSTR  szUser,         // in
        DWORD   dwIndex,        // in
        const GUID*   pguidType,      // in
        GUID*   pguidSubtype)   // out
{
    DWORD dwRet;

    CHAR rgszGuidSubtype[MAX_GUID_SZ_CHARS];
    DWORD cbName = MAX_GUID_SZ_CHARS;

    FILETIME ft;

    // now walk through types, returning them one by one
    HKEY hTypeKey=NULL, hSubtypeKey=NULL;

    if (PST_E_OK != (dwRet =
        GetPSTTypeHKEY(
            szUser,
            pguidType,
            &hTypeKey)) )
        goto Ret;

    // enum the dwIndex'th item, alloc & return
    if (ERROR_SUCCESS != (dwRet =
        RegEnumKeyExA(
            hTypeKey,
            dwIndex,
            rgszGuidSubtype, // address of buffer for subkey name
            &cbName,    // address for size of subkey buffer
            NULL,       // reserved
            NULL,       // pbclass
            NULL,       // cbclass
            &ft)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        MyGuidFromStringA(
            rgszGuidSubtype,
            pguidSubtype)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        RegOpenKeyExA(
            hTypeKey,
            rgszGuidSubtype,
            0,
            KEY_READ | KEY_WRITE,
            &hSubtypeKey)) )
        goto Ret;

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hTypeKey)
        RegCloseKey(hTypeKey);

    if (hSubtypeKey)
        RegCloseKey(hSubtypeKey);

    return dwRet;
}

DWORD BPGetSubtypeName(
        LPCWSTR  szUser,             // in
        const GUID*   pguidType,          // in
        const GUID*   pguidSubtype,       // in
        LPWSTR* ppszSubtype)        // out
{
    HKEY hKey = NULL;
    DWORD cbName = 0;
    DWORD dwRet;

    if (PST_E_OK != (dwRet =
        GetPSTSubtypeHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            &hKey)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        RegGetValue(
            hKey,
            REG_DISPLAYSTRING_VALNAME,
            (PBYTE*)ppszSubtype,
            &cbName)) )
        goto Ret;

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwRet;
}

// end SUBTYPE management
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// ITEM management

// given uuid, push entries into storage
DWORD BPCreateItem(
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName)    // in
{
    DWORD dwRet;
    BOOL fExisted;
    HKEY    hKey = NULL;


    //
    // mattt 2/5/97: allow items with \ in them to be created. Urgh!
    //
    // mattt 4/28/97: begin restricting strings. 
    // Cert request code has been changed to not create this type of key name
    //
/*
    if (!FStringIsValidItemName(szItemName))
    {
        dwRet = (DWORD)PST_E_INVALID_STRING;
        goto Ret;
    }
*/
    // now we need to create entries in hierarchy
    if (PST_E_OK != (dwRet =
        CreatePSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hKey,
            &fExisted)) )
        goto Ret;

    if (fExisted)
    {
        dwRet = (DWORD)PST_E_ITEM_EXISTS;
        goto Ret;
    }

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwRet;
}


DWORD BPDeleteItem(
        LPCWSTR  szUser,         // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName)     // in
{
    DWORD dwRet;
    HKEY    hSubTypeKey = NULL;

    // now we need to remove entries in hierarchy
    if (PST_E_OK != (dwRet =
        GetPSTSubtypeHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            &hSubTypeKey)) )
        goto Ret;

    // now, remove the friendly name
    if (ERROR_SUCCESS != (dwRet =
        RegDeleteKeyU(
            hSubTypeKey,
            szItemName)) )
        goto Ret;

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hSubTypeKey)
        RegCloseKey(hSubTypeKey);

    return dwRet;
}

// Warning: Item path must be fully specified.. szName returned
DWORD BPEnumItems(
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        DWORD   dwIndex,        // in
        LPWSTR* ppszName)       // out
{
    DWORD dwRet;

    WCHAR szName[MAX_PATH];
    DWORD cchName = MAX_PATH;
    FILETIME ft;

    // now walk through types, returning them one by one
    HKEY hKey = NULL;

    // Open SubType key //
    if (PST_E_OK != (dwRet =
        GetPSTSubtypeHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            &hKey)) )
        goto Ret;

    // enum the dwIndex'th item, alloc & return
    if (ERROR_SUCCESS != (dwRet =
        RegEnumKeyExU(
            hKey,
            dwIndex,
            szName,     // address of buffer for subkey name
            &cchName,   // address for size of subkey buffer
            NULL,       // reserved
            NULL,       // pbclass
            NULL,       // cbclass
            &ft)) )
        goto Ret;

    *ppszName = (LPWSTR)SSAlloc((cchName+1)*sizeof(WCHAR));
    if(*ppszName == NULL)
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    wcscpy(*ppszName, szName);

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwRet;
}

// end ITEM management
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// SECURED DATA

BOOL FBPGetSecuredItemData(
        LPCWSTR  szUser,         // in
        LPCWSTR  szMasterKey,    // in
        BYTE    rgbPwd[A_SHA_DIGEST_LEN],       // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,     // in
        PBYTE*  ppbData,        // out
        DWORD*  pcbData)        // out
{
    DWORD dwRet;

    *ppbData = NULL;    // on err return NULL
    *pcbData = 0;

    HKEY    hItemKey = NULL;

    if (PST_E_OK != (dwRet =
        GetPSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hItemKey)) )
        goto Ret;

    // Version | Key Block | Secure Data [...]
    if (ERROR_SUCCESS != (dwRet =
        RegGetValue(
            hItemKey,
            REG_ITEM_SECURE_DATA_VALNAME,
            ppbData,
            pcbData)) )
        goto Ret;

    if (!FProvDecryptData(
            szUser,
            szMasterKey,
            rgbPwd,         // in
            ppbData,        // in out
            pcbData))       // in out
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    dwRet = PST_E_OK;
Ret:
    if ((dwRet != PST_E_OK) && (*ppbData != NULL))
    {
        SSFree(*ppbData);
        *ppbData = NULL;
        *pcbData = 0;
    }

    if (hItemKey)
        RegCloseKey(hItemKey);

    return (dwRet == PST_E_OK);
}

BOOL FBPSetSecuredItemData(
        LPCWSTR  szUser,         // in
        LPCWSTR  szMasterKey,    // in
        BYTE    rgbPwd[A_SHA_DIGEST_LEN],       // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,     // in
        PBYTE   pbData,         // in
        DWORD   cbData)         // in
{
#define REALLOC_FUDGESIZE   96  // 5dw + SHA_LEN + KeyBlock + DES_BLOCKLEN (block encr expansion)

    DWORD dwRet;

    HKEY    hItemKey = NULL;

    PBYTE   pbMyData = NULL;
    DWORD   cbMyData;

    // make whackable copy
    cbMyData = cbData;
    pbMyData = (PBYTE)SSAlloc(cbMyData + REALLOC_FUDGESIZE);
    if (pbMyData == NULL)
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    CopyMemory(pbMyData, pbData, cbData);


    if (PST_E_OK != (dwRet =
        GetPSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hItemKey)) )
        goto Ret;

    if (!FProvEncryptData(
            szUser,
            szMasterKey,
            rgbPwd,             // in
            &pbMyData,          // in out
            &cbMyData))         // in out
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    if (ERROR_SUCCESS != (dwRet =
        RegSetValueExU(
            hItemKey,
            REG_ITEM_SECURE_DATA_VALNAME,
            0,
            REG_BINARY,
            pbMyData,
            cbMyData)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (hItemKey)
        RegCloseKey(hItemKey);

    if (pbMyData)
        SSFree(pbMyData);

    return (dwRet == PST_E_OK);
}

// end SECURED DATA
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// INSECURE DATA

DWORD BPGetInsecureItemData(
        LPCWSTR  szUser,         // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,     // in
        PBYTE*  ppbData,        // out
        DWORD*  pcbData)        // out
{
    DWORD dwRet;
    *ppbData = NULL;

    HKEY    hItemKey = NULL;

    if (PST_E_OK != (dwRet =
        GetPSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hItemKey)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        RegGetValue(
            hItemKey,
            REG_ITEM_INSECURE_DATA_VALNAME,
            ppbData,
            pcbData)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:

    if (hItemKey)
        RegCloseKey(hItemKey);

    return dwRet;
}

DWORD BPSetInsecureItemData(
        LPCWSTR  szUser,         // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,     // in
        PBYTE   pbData,         // in
        DWORD   cbData)         // in
{
    DWORD dwRet;

    HKEY    hItemKey = NULL;

    if (PST_E_OK != (dwRet =
        GetPSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hItemKey)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        RegSetValueExU(
            hItemKey,
            REG_ITEM_INSECURE_DATA_VALNAME,
            0,
            REG_BINARY,
            pbData,
            cbData)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (hItemKey)
        RegCloseKey(hItemKey);

    return dwRet;
}

// end INSECURE DATA
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// RULESETS

// #define RULESET_VERSION 0x1
// 6-12-97 incremented version; version 0x1 contains old HMAC
#define RULESET_VERSION 0x2


#if 0

DWORD BPGetSubtypeRuleset(
        PST_PROVIDER_HANDLE*    phPSTProv, // in
        LPCWSTR  szUser,                // in
        const GUID*   pguidType,        // in
        const GUID*   pguidSubtype,     // in
        PST_ACCESSRULESET* psRules)     // out
{
    DWORD dwRet;
    HKEY hSubtypeKey = NULL;

    BYTE rgbHMAC[A_SHA_DIGEST_LEN];
    BYTE rgbPwd[A_SHA_DIGEST_LEN];

    PBYTE pbBuf = NULL;
    DWORD cbBuf;

    PBYTE pbCurrent;
    DWORD cbRuleSize;
    PBYTE pbRuleSet;

    DWORD dwVersion;

    // Open Subtype //
    if (PST_E_OK != (dwRet =
        GetPSTSubtypeHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            &hSubtypeKey)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        RegGetValue(
            hSubtypeKey,
            REG_ACCESSRULE_LOC,
            &pbBuf,
            &cbBuf)) )
        goto Ret;


//  RULESET DATA FORMAT:
//  version | size(ruleset) | ruleset | size(MAC) | MAC {of type, subtype, ruleset}
    pbCurrent = pbBuf;

    if( cbBuf < (sizeof(DWORD)*2) ) {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    // version check
    dwVersion = *(DWORD*)pbCurrent;
    if (dwVersion > RULESET_VERSION)
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    pbCurrent += sizeof(DWORD);


    cbRuleSize = *(DWORD*)pbCurrent;

    // get WinPW
	if (PST_E_OK != 
		BPVerifyPwd(
			phPSTProv,
			szUser,
			WSZ_PASSWORD_WINDOWS,
			rgbPwd,
			BP_CONFIRM_NONE))
	{
        dwRet = (DWORD)PST_E_WRONG_PASSWORD;
        goto Ret;
	}

    // check MAC

    // Compute Geographically sensitive (can't move) HMAC on { size(ruleset), ruleset }
    if (!FHMACGeographicallySensitiveData(
            szUser,
            WSZ_PASSWORD_WINDOWS,
            (dwVersion == 0x01) ? OLD_HMAC_VERSION : NEW_HMAC_VERSION, 
            rgbPwd,
            pguidType,
            pguidSubtype,
            NULL,
            pbCurrent,
            cbRuleSize + sizeof(DWORD),     // include the rulesize
            rgbHMAC))
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    pbCurrent += sizeof(DWORD); // skip past cbRuleSize (already snarfed)
    pbRuleSet = pbCurrent;      // point to rules
    pbCurrent += cbRuleSize;    // skip past rules

    // check MAC len
    if (*(DWORD*)pbCurrent != A_SHA_DIGEST_LEN)
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }
    pbCurrent += sizeof(DWORD); // skip past sizeof(MAC)

    // check MAC
    if (0 != memcmp(rgbHMAC, pbCurrent, A_SHA_DIGEST_LEN))
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    // MAC okay! shrink to rulesize
    MoveMemory(pbBuf, pbRuleSet, cbRuleSize);
    cbBuf = cbRuleSize;
    pbBuf = (PBYTE)SSReAlloc(pbBuf, cbBuf); 
    if (pbBuf == NULL)      // check allocation
    {
        dwRet = PST_E_FAIL;
        goto Ret;
    }


    // serialize rules out of the buffer
    if (!FAccessRulesUnPickle(
            psRules,
            pbBuf,
            cbBuf))
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (pbBuf)
        SSFree(pbBuf);

    if (hSubtypeKey)
        RegCloseKey(hSubtypeKey);

    return dwRet;
}



DWORD BPSetSubtypeRuleset(
        PST_PROVIDER_HANDLE*    phPSTProv,              // in
        LPCWSTR  szUser,                                // in
        const GUID*   pguidType,                        // in
        const GUID*   pguidSubtype,                     // in
        PST_ACCESSRULESET *psRules)                     // in
{
    DWORD dwRet;
    HKEY hSubtypeKey = NULL;

    BYTE rgbHMAC[A_SHA_DIGEST_LEN];
    BYTE rgbPwd[A_SHA_DIGEST_LEN];

    PBYTE pbBuf = NULL;
    DWORD cbBuf;

    PBYTE pbCurPtr;
    DWORD cbNewSize;

    // serialize rules into a buffer
    if (!FAccessRulesPickle(
            psRules,
            &pbBuf,
            &cbBuf))
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

//  RULESET DATA FORMAT:
//  version | size(ruleset) | ruleset | size(MAC) | Geographical MAC {size(ruleset), ruleset}
    cbNewSize = cbBuf + 3*sizeof(DWORD) + A_SHA_DIGEST_LEN;
    pbBuf = (PBYTE)SSReAlloc(pbBuf, cbNewSize);
    if (pbBuf == NULL)      // check allocation
    {
        dwRet = PST_E_FAIL;
        goto Ret;
    }
    MoveMemory(pbBuf + 2*sizeof(DWORD), pbBuf, cbBuf);

    // helpful pointer
    pbCurPtr = pbBuf;

    // version
    *(DWORD*)pbCurPtr = (DWORD)RULESET_VERSION;
    pbCurPtr += sizeof(DWORD);

    // size(ruleset)
    *(DWORD*)pbCurPtr = (DWORD)cbBuf;
    pbCurPtr += sizeof(DWORD);

    // ruleset previously moved by MoveMemory call
    pbCurPtr += cbBuf;  // fwd past ruleset

    // get WinPW
	if (PST_E_OK != 
		BPVerifyPwd(
			phPSTProv,
			szUser,
			WSZ_PASSWORD_WINDOWS,
			rgbPwd,
			BP_CONFIRM_NONE))
	{
        dwRet = (DWORD)PST_E_WRONG_PASSWORD;
        goto Ret;
	}

    // check MAC
    // Compute Geographically sensitive (can't move) HMAC on { size(ruleset), ruleset }
    if (!FHMACGeographicallySensitiveData(
            szUser,
            WSZ_PASSWORD_WINDOWS,
            NEW_HMAC_VERSION,
            rgbPwd,
            pguidType,
            pguidSubtype,
            NULL,
            pbBuf + sizeof(DWORD),
            cbBuf + sizeof(DWORD),
            rgbHMAC))
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    // HMAC size
    *(DWORD*)pbCurPtr = (DWORD) sizeof(rgbHMAC);
    pbCurPtr += sizeof(DWORD);

    // HMAC
    CopyMemory(pbCurPtr, rgbHMAC, sizeof(rgbHMAC));

    // done; set cbBuf = new size
    cbBuf = cbNewSize;


    // Open Subtype //
    if (PST_E_OK != (dwRet =
        GetPSTSubtypeHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            &hSubtypeKey)) )
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    // now write item
    if (ERROR_SUCCESS != (dwRet =
        RegSetValueExU(
            hSubtypeKey,
            REG_ACCESSRULE_LOC,
            0,
            REG_BINARY,
            pbBuf,
            cbBuf)) )
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (pbBuf)
        SSFree(pbBuf);

    if (hSubtypeKey)
        RegCloseKey(hSubtypeKey);

    return dwRet;
}


DWORD BPGetItemRuleset(
        PST_PROVIDER_HANDLE* phPSTProv,                 // in
        LPCWSTR  szUser,                                // in
        const GUID*   pguidType,                        // in
        const GUID*   pguidSubtype,                     // in
        LPCWSTR  szItemName,                            // in
        PST_ACCESSRULESET* psRules)                     // out
{
    DWORD dwRet;
    HKEY hItemKey = NULL;

    PBYTE pbBuf = NULL;
    DWORD cbBuf;

    if (PST_E_OK != (dwRet =
        GetPSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hItemKey)) )
        goto Ret;           // item doesn't exist -- ouch!!

    if (ERROR_SUCCESS != (dwRet =
        RegGetValue(
            hItemKey,
            REG_ACCESSRULE_LOC,
            &pbBuf,
            &cbBuf)) )
    {
        // item exists, rules don't
        // fall back on subtype ruleset
        if (PST_E_OK != (dwRet =
            BPGetSubtypeRuleset(
                phPSTProv,
                szUser,
                pguidType,
                pguidSubtype,
                psRules)) )
            goto Ret;
    }
    else
    {
        // serialize rules into a buffer
        if (!FAccessRulesUnPickle(
                psRules,
                pbBuf,
                cbBuf))
        {
            dwRet = (DWORD)PST_E_INVALID_RULESET;
            goto Ret;
        }
    }

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (pbBuf)
        SSFree(pbBuf);

    if (hItemKey)
        RegCloseKey(hItemKey);

    return dwRet;
}


DWORD BPSetItemRuleset(
        PST_PROVIDER_HANDLE* phPSTProv,                 // in
        LPCWSTR  szUser,                                // in
        const GUID*   pguidType,                        // in
        const GUID*   pguidSubtype,                     // in
        LPCWSTR  szItemName,                            // in
        PST_ACCESSRULESET *psRules)                     // in
{
    DWORD dwRet;

    HKEY hItemKey = NULL;

    PBYTE pbBuf = NULL;
    DWORD cbBuf;

    // serialize rules into a buffer
    if (!FAccessRulesPickle(
            psRules,
            &pbBuf,
            &cbBuf))
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    // Open Subtype //
    if (PST_E_OK != (dwRet =
        GetPSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hItemKey)) )
        goto Ret;

    // now write item
    if (ERROR_SUCCESS != (dwRet =
        RegSetValueExU(
            hItemKey,
            REG_ACCESSRULE_LOC,
            0,
            REG_BINARY,
            pbBuf,
            cbBuf)) )
        goto Ret;

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (pbBuf)
        SSFree(pbBuf);

    if (hItemKey)
        RegCloseKey(hItemKey);

    return dwRet;
}

#endif

// end RULESETS
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// ITEM CONFIRM INFO
// #define CONFIRMATION_VERSION    0x01
// 6-12-97 incremented version: version 0x1 contains old HMAC
#define CONFIRMATION_VERSION    0x02

DWORD BPGetItemConfirm(
        PST_PROVIDER_HANDLE* phPSTProv, // in
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,    // in
        DWORD*  pdwConfirm,     // in
        LPWSTR* pszMK)          // in
{
    DWORD dwRet;
    HKEY hItemKey = NULL;


    PBYTE pbBuf = NULL;
    DWORD cbBuf = 0;

    BYTE rgbHMAC[A_SHA_DIGEST_LEN];
    BYTE rgbPwd[A_SHA_DIGEST_LEN];

    // helpful pointers
    PBYTE pbCurPtr = NULL;

    PBYTE pbString;
    DWORD cbString;

    DWORD dwVersion;

    // Open nonexistent item master key
    if (PST_E_OK != (dwRet =
        GetPSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hItemKey)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        RegGetValue(
            hItemKey,
            REG_ITEM_MK_VALNAME,
            &pbBuf,
            &cbBuf)) )
        goto Ret;

    // Confirmation data format
    // Version | dwConfirm | size(szMasterKey) | szMasterKey | size(MAC) | Geographical MAC { dwConfirm | size(szMasterKey) | szMasterKey }

    // version check
    dwVersion = *(DWORD*)pbBuf;
    if (CONFIRMATION_VERSION < dwVersion)
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }
    pbCurPtr = pbBuf + sizeof(DWORD);   // fwd past vers


    // get WinPW
	if (PST_E_OK != 
		BPVerifyPwd(
			phPSTProv,
			szUser,
			WSZ_PASSWORD_WINDOWS,
			rgbPwd,
			BP_CONFIRM_NONE))
	{
        dwRet = (DWORD)PST_E_WRONG_PASSWORD;
        goto Ret;
	}

    // check MAC
    // Compute Geographically sensitive (can't move) HMAC on { dwConfirm | size(szMasterKey) | szMasterKey }
    if (!FHMACGeographicallySensitiveData(
            szUser,
            WSZ_PASSWORD_WINDOWS,
            (dwVersion == 0x01) ? OLD_HMAC_VERSION : NEW_HMAC_VERSION,
            rgbPwd,
            pguidType,
            pguidSubtype,
            szItemName,
            pbBuf + sizeof(DWORD),   // fwd past Version
            cbBuf - 2*sizeof(DWORD) - A_SHA_DIGEST_LEN, // Version, size(MAC), MAC
            rgbHMAC))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    // dwConfirm
    *pdwConfirm = *(DWORD*)pbCurPtr;    // dwConfirm
    pbCurPtr += sizeof(DWORD);          // fwd past dwConfirm

    // szMasterKey
    cbString = *(DWORD*)pbCurPtr;       // strlen
    pbCurPtr += sizeof(DWORD);          // fwd past len
    pbString = pbCurPtr;                // save ptr to string
    pbCurPtr += cbString;            // skip string

    if (*(DWORD*)pbCurPtr != A_SHA_DIGEST_LEN)
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }
    pbCurPtr += sizeof(DWORD);

    if (0 != memcmp(pbCurPtr, rgbHMAC, A_SHA_DIGEST_LEN))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }


    MoveMemory(pbBuf, pbString, cbString);   // shift left string
    pbBuf = (PBYTE)SSReAlloc(pbBuf, cbString);      // shorten to strlen
    if (pbBuf == NULL)      // check allocation
    {
        dwRet = PST_E_FAIL;
        goto Ret;
    }


    dwRet = (DWORD)PST_E_OK;
Ret:
    *pszMK = (LPWSTR)pbBuf;             // assign to out param

    if (hItemKey)
        RegCloseKey(hItemKey);

    return dwRet;
}

DWORD BPSetItemConfirm(
        PST_PROVIDER_HANDLE* phPSTProv, // in
        LPCWSTR  szUser,         // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,     // in
        DWORD   dwConfirm,      // in
        LPCWSTR  szMK)           // in
{
    DWORD dwRet;
    HKEY hItemKey = NULL;

    BYTE rgbHMAC[A_SHA_DIGEST_LEN];
    BYTE rgbPwd[A_SHA_DIGEST_LEN];

    // helpful pointer
    PBYTE pbCurPtr;

    // Confirmation data format
    // Version | dwConfirm | size(szMasterKey) | szMasterKey | size(MAC) | Geographical MAC { dwConfirm | size(szMasterKey) | szMasterKey }
    DWORD cbBuf = WSZ_BYTECOUNT(szMK)+ 4*sizeof(DWORD) + A_SHA_DIGEST_LEN;
    PBYTE pbBuf = (PBYTE)SSAlloc(cbBuf);
    if (pbBuf == NULL)      // check allocation
    {
        dwRet = PST_E_FAIL;
        goto Ret;
    }

    pbCurPtr = pbBuf;

    // version
    *(DWORD*)pbCurPtr = (DWORD)CONFIRMATION_VERSION;
    pbCurPtr += sizeof(DWORD);

    // dwConfirm
    *(DWORD*)pbCurPtr = dwConfirm;
    pbCurPtr += sizeof(DWORD);

    // szMasterKey size
    *(DWORD*)pbCurPtr = (DWORD)WSZ_BYTECOUNT(szMK);
    pbCurPtr += sizeof(DWORD);

    // szMasterKey
    wcscpy((LPWSTR)pbCurPtr, szMK);
    pbCurPtr += WSZ_BYTECOUNT(szMK);    // fwd past szMK


    // get WinPW
	if (PST_E_OK != 
		BPVerifyPwd(
			phPSTProv,
			szUser,
			WSZ_PASSWORD_WINDOWS,
			rgbPwd,
			BP_CONFIRM_NONE))
	{
        dwRet = (DWORD)PST_E_WRONG_PASSWORD;
        goto Ret;
	}

    // check MAC
    // Compute Geographically sensitive (can't move) HMAC on { dwConfirm | size(szMasterKey) | szMasterKey }
    if (!FHMACGeographicallySensitiveData(
            szUser,
            WSZ_PASSWORD_WINDOWS,
            NEW_HMAC_VERSION,
            rgbPwd,
            pguidType,
            pguidSubtype,
            szItemName,
            pbBuf + sizeof(DWORD), // fwd past Version
            cbBuf - 2*sizeof(DWORD) - A_SHA_DIGEST_LEN, // Version, size(MAC), MAC
            rgbHMAC))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    // HMAC size
    *(DWORD*)pbCurPtr = (DWORD) sizeof(rgbHMAC);
    pbCurPtr += sizeof(DWORD);

    // HMAC
    CopyMemory(pbCurPtr, rgbHMAC, sizeof(rgbHMAC));


    // Open Item //
    if (PST_E_OK != (dwRet =
        GetPSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hItemKey)) )
        goto Ret;

    // now write item
    if (ERROR_SUCCESS != (dwRet =
        RegSetValueExU(
            hItemKey,
            REG_ITEM_MK_VALNAME,
            0,
            REG_BINARY,
            pbBuf,
            cbBuf)) )
        goto Ret;

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hItemKey)
        RegCloseKey(hItemKey);

    if (pbBuf)
        SSFree(pbBuf);

    return dwRet;
}

// ITEM CONFIRM INFO
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// MASTER KEYS
BOOL BPMasterKeyExists(
        LPCWSTR  szUser,            // in
        LPWSTR   szMasterKey)       // in
{
    BOOL fRet = FALSE;
    HKEY hMyKey = NULL;
    HKEY hMasterKey = NULL;

    // Open Master parent key //
    if (PST_E_OK !=
        GetPSTMasterKeyHKEY(
            szUser,
            NULL,
            &hMyKey))
        goto Ret;

    // attempt to open the master key location
    if (ERROR_SUCCESS !=
        RegOpenKeyExU(
            hMyKey,
            szMasterKey,
            0,
            KEY_QUERY_VALUE,
            &hMasterKey))
        goto Ret;

    // key does exist
    fRet = TRUE;
Ret:
    if (hMyKey)
        RegCloseKey(hMyKey);

    if (hMasterKey)
        RegCloseKey(hMasterKey);

    return fRet;
}

DWORD BPEnumMasterKeys(
        LPCWSTR  szUser,            // in
        DWORD   dwIndex,            // in
        LPWSTR* ppszMasterKey)      // out
{
    DWORD dwRet;
    HKEY hMyKey = NULL;

    WCHAR szName[MAX_PATH];
    DWORD cchName = MAX_PATH;
    FILETIME ft;

    // Open Master parent key //
    if (PST_E_OK != (dwRet =
        GetPSTMasterKeyHKEY(
            szUser,
            NULL,
            &hMyKey)) )
        goto Ret;

    // enum the dwIndex'th item, alloc & return
    if (ERROR_SUCCESS != (dwRet =
        RegEnumKeyExU(
            hMyKey,
            dwIndex,
            szName,     // address of buffer for subkey name
            &cchName,   // address for size of subkey buffer
            NULL,       // reserved
            NULL,       // pbclass
            NULL,       // cbclass
            &ft)) )
        goto Ret;

    *ppszMasterKey = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(szName));
    if(*ppszMasterKey == NULL)
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    wcscpy(*ppszMasterKey, szName);

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hMyKey)
        RegCloseKey(hMyKey);

    return dwRet;
}

DWORD BPGetMasterKeys(
        LPCWSTR  szUser,
        LPWSTR  rgszMasterKeys[],
        DWORD*  pcbMasterKeys,
        BOOL    fUserFilter)
{
    DWORD dwRet;
    DWORD cKeys=0;

    for (DWORD cntEnum=0; cntEnum<*pcbMasterKeys; cntEnum++)
    {
        if (PST_E_OK != (dwRet =
            BPEnumMasterKeys(
                szUser,
                cntEnum,
                &rgszMasterKeys[cKeys])) )
            break;

        cKeys++;

        // filter out non-user keys
        if (fUserFilter)
        {
            if (!FIsUserMasterKey(rgszMasterKeys[cKeys-1]))
                SSFree(rgszMasterKeys[--cKeys]);
        }
    }

    *pcbMasterKeys = cKeys;

    return PST_E_OK;
}

// end MASTER KEYS
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// SECURITY STATE
#define SECURITY_STATE_VERSION 0x01

BOOL FBPGetSecurityState(
            LPCWSTR  szUser,
            LPCWSTR  szMK,
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbConfirm[],
            DWORD   cbConfirm,
            PBYTE*  ppbMK,
            DWORD*  pcbMK)
{
    DWORD dwRet;
    HKEY hMKKey = NULL;

    // Open MK Key //
    if (PST_E_OK != (dwRet =
        GetPSTMasterKeyHKEY(
            szUser,
            szMK,
            &hMKKey)) )
        goto Ret;

    dwRet = PST_E_FAIL;

    if(!FBPGetSecurityStateFromHKEY(
                hMKKey,
                rgbSalt,
                cbSalt,
                rgbConfirm,
                cbConfirm,
                ppbMK,
                pcbMK))
        goto Ret;


    dwRet = PST_E_OK;
Ret:
    if (hMKKey)
        RegCloseKey(hMKKey);

    return (dwRet == PST_E_OK);
}

BOOL FBPGetSecurityStateFromHKEY(
            HKEY hMKKey,
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbConfirm[],
            DWORD   cbConfirm,
            PBYTE*  ppbMK,
            DWORD*  pcbMK)
{
    DWORD dwRet;

    PBYTE pbBuf = NULL;
    DWORD cbBuf;

    // helpful pointer
    PBYTE pbCurPtr;

    DWORD dwMemberSize;
    DWORD dwCreated;


    PBYTE pbLocalSalt;
    PBYTE pbLocalMK;
    PBYTE pbLocalConfirm;

    DWORD cbLocalSalt;
    DWORD cbLocalMK;
    DWORD cbLocalConfirm;

    PBYTE pbMaximumPtr;
    PBYTE pbMinimumPtr;



    if (ERROR_SUCCESS != (dwRet =
        RegGetValue(
            hMKKey,
            REG_SECURITY_SALT_VALNAME,
            &pbBuf,
            &cbBuf)) )
        goto Ret;

    dwRet = PST_E_FAIL;

    // Security data format
    // Version | size(MK) | MK | size(Salt) | Salt | size(Confirm) | Confirm

    if ( cbBuf < (sizeof(DWORD)*4) )
        goto Ret;

    // version check
    if (SECURITY_STATE_VERSION != *(DWORD*)pbBuf)
        goto Ret;

    pbCurPtr = pbBuf + sizeof(DWORD);   // fwd past vers

    pbMinimumPtr = pbCurPtr;
    pbMaximumPtr = (pbBuf+cbBuf);


    //
    // MK
    //

    if( pbCurPtr >= pbMaximumPtr || pbCurPtr < pbMinimumPtr )
        goto Ret;

    cbLocalMK = *(DWORD*)pbCurPtr;      // size

    if( cbLocalMK > cbBuf )
        goto Ret;

    pbCurPtr += sizeof(DWORD);          // fwd past size

    pbLocalMK = pbCurPtr;

    pbCurPtr += cbLocalMK;              // fwd past data

    //
    // Salt
    //

    if( pbCurPtr >= pbMaximumPtr || pbCurPtr < pbMinimumPtr )
        goto Ret;

    cbLocalSalt = *(DWORD*)pbCurPtr;    // size
    if( cbLocalSalt > cbBuf )
        goto Ret;

    pbCurPtr += sizeof(DWORD);          // fwd past size

    pbLocalSalt = pbCurPtr;

    if (cbLocalSalt != cbSalt)          // sizechk
        goto Ret;

    pbCurPtr += cbSalt;                 // fwd past data

    //
    // Confirm
    //

    if( pbCurPtr >= pbMaximumPtr || pbCurPtr < pbMinimumPtr )
        goto Ret;

    cbLocalConfirm = *(DWORD*)pbCurPtr; // size
    if( cbLocalConfirm > cbBuf )
        goto Ret;

    pbCurPtr += sizeof(DWORD);          // fwd past size

    pbLocalConfirm = pbCurPtr;

    if (cbLocalConfirm != cbConfirm)    // sizechk
        goto Ret;

    pbCurPtr += cbConfirm;              // fwd past data


    //
    // do a single size sanity check before copying data out.
    //

    if( pbCurPtr != (pbBuf + cbBuf) )
        goto Ret;

    MoveMemory(pbBuf, pbLocalMK, cbLocalMK);        // move left to front for later realloc
    CopyMemory(rgbSalt, pbLocalSalt, cbLocalSalt);  // data
    CopyMemory(rgbConfirm, pbLocalConfirm, cbLocalConfirm); // data

    //
    // MK fixup
    //

    *pcbMK = cbLocalMK;

    pbBuf = (PBYTE)SSReAlloc(pbBuf, *pcbMK);      // shorten to MK data
    if (pbBuf == NULL)
    {
        dwRet = PST_E_FAIL;
        goto Ret;
    }
    *ppbMK = pbBuf;


    dwRet = PST_E_OK;
Ret:

    return (dwRet == PST_E_OK);
}

BOOL FBPSetSecurityState(
            LPCWSTR  szUser,
            LPCWSTR  szMK,
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbConfirm[],
            DWORD   cbConfirm,
            PBYTE   pbMK,
            DWORD   cbMK)
{
    DWORD   dwRet;
    HKEY    hMKKey = NULL;
    
    // helpful pointer
    PBYTE pbCurPtr;

    DWORD cbBuf = cbSalt + cbConfirm + cbMK + 4*sizeof(DWORD);  // ver + size + data
    PBYTE pbBuf = (PBYTE)SSAlloc(cbBuf);
    if (pbBuf == NULL)
    {
        dwRet = PST_E_FAIL;
        goto Ret;
    }

    pbCurPtr = pbBuf;


    // Security data format
    // Version | size(MK) | MK | size(Salt) | Salt | size(Confirm) | Confirm

    *(DWORD*)pbCurPtr = SECURITY_STATE_VERSION;     // ver
    pbCurPtr += sizeof(DWORD);                  // fwd past ver

    // MK
    *(DWORD*)pbCurPtr = cbMK;                   // size
    pbCurPtr += sizeof(DWORD);                  // fwd past size
    CopyMemory(pbCurPtr, pbMK, cbMK);           // data
    pbCurPtr += cbMK;                           // fwd past data

    // Salt
    *(DWORD*)pbCurPtr = cbSalt;                 // size
    pbCurPtr += sizeof(DWORD);                  // fwd past size
    CopyMemory(pbCurPtr, rgbSalt, cbSalt);      // data
    pbCurPtr += cbSalt;                         // fwd past data

    // Confirm
    *(DWORD*)pbCurPtr = cbConfirm;              // size
    pbCurPtr += sizeof(DWORD);                  // fwd past size
    CopyMemory(pbCurPtr, rgbConfirm, cbConfirm);// data
    pbCurPtr += cbConfirm;                      // fwd past data



    // Open User Key //
    if (PST_E_OK != (dwRet =
        GetPSTMasterKeyHKEY(
            szUser,
            szMK,
            &hMKKey)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        RegSetValueExU(
            hMKKey,
            REG_SECURITY_SALT_VALNAME,
            0,
            REG_BINARY,
            pbBuf,
            cbBuf)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (hMKKey)
        RegCloseKey(hMKKey);

    if (pbBuf)
        SSFree(pbBuf);

    return (dwRet == PST_E_OK);
}

// end SECURITY STATE
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// begin global MAC Key storage
#define INTERNAL_MAC_KEY_VERSION 0x1

BOOL FGetInternalMACKey(LPCWSTR szUser, PBYTE* ppbKey, DWORD* pcbKey)
{
    BOOL fRet = FALSE;
    HKEY hBaseKey = NULL;
    HKEY hDataKey = NULL;

    // Open User Key //
    if (PST_E_OK !=
        GetPSTUserHKEY(
            szUser,
            &hBaseKey,
            NULL))
        goto Ret;

    // Open Data Key //
    if (ERROR_SUCCESS !=
        RegOpenKeyExU(
            hBaseKey,
            REG_DATA_LOC,
            0,
            KEY_READ | KEY_WRITE,
            &hDataKey))
        goto Ret;

    if (ERROR_SUCCESS !=
        RegGetValue(
            hDataKey,
            REG_USER_INTERNAL_MAC_KEY,
            ppbKey,
            pcbKey))
        goto Ret;

    // only know about ver 1 keys
    if (*(DWORD*)*ppbKey != INTERNAL_MAC_KEY_VERSION)
        goto Ret;

    // strip version tag, shift left
    *pcbKey -= sizeof(DWORD);
    MoveMemory(*ppbKey, *ppbKey + sizeof(DWORD), *pcbKey);

    fRet = TRUE;
Ret:
    if (hBaseKey)
        RegCloseKey(hBaseKey);

    if (hDataKey)
        RegCloseKey(hDataKey);

    return fRet;
}

BOOL FSetInternalMACKey(LPCWSTR szUser, PBYTE pbKey, DWORD cbKey)
{
    BOOL fRet = FALSE;
    HKEY hBaseKey = NULL;
    HKEY hDataKey = NULL;

    DWORD dwCreate;

    // no need to alloc, we assume we know cbKey size (2 deskeys + blocklen pad + dwVersion)
    BYTE rgbTmp[(8*3)+sizeof(DWORD)];

    // ASSUME: two deskeys, each 8 bytes + blocklen pad
    if (cbKey != (8*3))
        goto Ret;

    // tack version on front
    *(DWORD*)rgbTmp = (DWORD)INTERNAL_MAC_KEY_VERSION;
    CopyMemory(rgbTmp + sizeof(DWORD), pbKey, cbKey);

    // Open User Key //
    if (PST_E_OK !=
        GetPSTUserHKEY(
            szUser,
            &hBaseKey,
            NULL))
        goto Ret;

    // Open/Create Data Key //
    if (ERROR_SUCCESS !=
        RegCreateKeyExU(
            hBaseKey,
            REG_DATA_LOC,
            0,
            NULL,                       // address of class string
            0,
            KEY_READ | KEY_WRITE,
            NULL,
            &hDataKey,
            &dwCreate))
        goto Ret;

    if (ERROR_SUCCESS !=
        RegSetValueExU(
            hDataKey,
            REG_USER_INTERNAL_MAC_KEY,
            0,
            REG_BINARY,
            rgbTmp,
            sizeof(rgbTmp) ))
        goto Ret;

    fRet = TRUE;
Ret:
    if (hBaseKey)
        RegCloseKey(hBaseKey);

    if (hDataKey)
        RegCloseKey(hDataKey);

    return fRet;
}

// end global MAC Key storage
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

BOOL
DeleteAllUserData(
    HKEY hKey
    )
{
    BOOL fRestorePrivs = FALSE;
    BOOL fRet = FALSE;

    //
    // enable backup and restore privs on NT to circumvent any security
    // settings.
    //

    if(FIsWinNT()) {
        SetCurrentPrivilege(L"SeRestorePrivilege", TRUE);
        SetCurrentPrivilege(L"SeBackupPrivilege", TRUE);

        fRestorePrivs = TRUE;
    }

    fRet = DeleteUserData( hKey );

    if(fRestorePrivs) {
        SetCurrentPrivilege(L"SeRestorePrivilege", FALSE);
        SetCurrentPrivilege(L"SeBackupPrivilege", FALSE);
    }

    return fRet;
}

BOOL
DeleteUserData(
    HKEY hKey
    )
{
    LONG rc;

    WCHAR szSubKey[MAX_PATH];
    DWORD cchSubKeyLength;
    DWORD dwSubKeyMaxIndex;
    DWORD dwDisposition;

    cchSubKeyLength = sizeof(szSubKey) / sizeof(WCHAR);

    // First, get the number of subkeys, so we can decrement the index,
    // and avoid and re-indexing of the subkeys

    if (ERROR_SUCCESS != RegQueryInfoKeyA(hKey,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &dwSubKeyMaxIndex,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL))
    {
        return FALSE;
    }

    if (dwSubKeyMaxIndex) dwSubKeyMaxIndex--;  // 0 based index, so index = #keys -1


    while((rc=RegEnumKeyExU(
                        hKey,
                        dwSubKeyMaxIndex,
                        szSubKey,
                        &cchSubKeyLength,
                        NULL,
                        NULL,
                        NULL,
                        NULL)
                        ) != ERROR_NO_MORE_ITEMS) { // are we done?

        if(rc == ERROR_SUCCESS)
        {
            HKEY hSubKey;
            LONG lRet;

            lRet = RegCreateKeyExU(
                            hKey,
                            szSubKey,
                            0,
                            NULL,
                            REG_OPTION_BACKUP_RESTORE, // in winnt.h
                            DELETE | KEY_ENUMERATE_SUB_KEYS,
                            NULL,
                            &hSubKey,
                            &dwDisposition
                            );

            if(lRet != ERROR_SUCCESS)
                return FALSE;


            //
            // recurse
            //

            DeleteUserData(hSubKey);
            RegDeleteKeyU(hKey, szSubKey);

            RegCloseKey(hSubKey);
           

            // increment index into the key
            dwSubKeyMaxIndex--;

            // reset buffer size
            cchSubKeyLength = sizeof(szSubKey) / sizeof(WCHAR);

            // Continue the festivities
            continue;
        }
        else
        {
           //
           // note: we need to watch for ERROR_MORE_DATA
           // this indicates we need a bigger szSubKey buffer
           //
            return FALSE;
        }

    } 

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\svr\acl.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    acl.cpp

Abstract:

    This module contains routines to support core security operations in
    the Protected Storage Server.

Author:

    Scott Field (sfield)    25-Nov-96

--*/

#include <pch.cpp>
#pragma hdrstop






BOOL
FImpersonateClient(
    IN  PST_PROVIDER_HANDLE *hPSTProv
    )
{
    handle_t hBinding = ((PCALL_STATE)hPSTProv)->hBinding;
    RPC_STATUS RpcStatus;

    if(!FIsWinNT())
        return TRUE;

    if(hPSTProv == NULL)
        return FALSE;

    if (hBinding == NULL)
    {
        if ((hPSTProv->LowPart == 0) && (hPSTProv->HighPart == 0) )
            return ImpersonateSelf(SecurityImpersonation);
        else
            return FALSE;
    }

    RpcStatus = RpcImpersonateClient(hBinding);

    if(RpcStatus != RPC_S_OK) {
        SetLastError(RpcStatus);
        return FALSE;
    }

    return TRUE;
}

BOOL
FRevertToSelf(
    IN  PST_PROVIDER_HANDLE *hPSTProv
    )
{
    handle_t hBinding = ((PCALL_STATE)hPSTProv)->hBinding;
    RPC_STATUS RpcStatus;

    if(!FIsWinNT())
        return TRUE;

    if(hPSTProv == NULL)
        return FALSE;

    if (hBinding == NULL)
    {
        if ((hPSTProv->LowPart == 0) && (hPSTProv->HighPart == 0) )
            return RevertToSelf();
        else
            return FALSE;
    }

    RpcStatus = RpcRevertToSelfEx(hBinding);

    if(RpcStatus != RPC_S_OK) {
        SetLastError(RpcStatus);
        return FALSE;
    }

    return TRUE;
}


// dispatch module callback interface given to providers to ask about callers

BOOL
FGetUserName(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    OUT LPWSTR*             ppszUser
    )
/*++
    This routine obtains the username (Win95) or Textual Sid (WinNT)
    associated with the calling thread.  If the cached entry is not present,
    the cached entry is initialized with the current user name, and for WinNT,
    the authentication Id associated with the username.  For WinNT, on
    subsequent calls, the calling threads authentication Id is checked to see
    if it matches the cached authentication Id - if true, the cached user
    string is released, otherwise, the current thread is evaluated and the
    result released to the client (note this is unlikely to happen unless
    the client process is impersonating multiple users and using the same
    context handle).

    If ppszUser parameter is set to NULL, the function does not allocate
    and copy user string to caller.  This is useful to initialize the cached
    entry or to determine if the user string is valid and available.

--*/
{
    DWORD cch = MAX_PATH;
    WCHAR szBuf[MAX_PATH];
    BOOL f = FALSE; // assume failure.  indicates if we inited OK, too.

    if (FIsWinNT())
    {
        // impersonating client should be easy way of nabbing this info
        if(!FImpersonateClient(hPSTProv))
            return FALSE;

        f = GetUserTextualSid(
                NULL,
                szBuf,
                &cch);

        if(!FRevertToSelf(hPSTProv))
            return FALSE;
    } else {
        f = GetUserNameU(
                szBuf,
                &cch);

        if(!f) {
            // for Win95, if nobody is logged on, empty user name
            if(GetLastError() == ERROR_NOT_LOGGED_ON) {
                szBuf[ 0 ] = L'\0';
                cch = 1;
                f = TRUE;
            }
        }
    }

    if (!f)
        return FALSE;

    if( ppszUser ) {
        *ppszUser = (LPWSTR)SSAlloc( cch * sizeof(WCHAR) );
        if (*ppszUser == NULL)
            return FALSE;
        CopyMemory(*ppszUser, szBuf, cch * sizeof(WCHAR) );
    }

    return TRUE;
}

// gets the image name for the process
BOOL
FGetParentFileName(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    OUT LPWSTR*             ppszName,
    OUT DWORD_PTR               *lpdwBaseAddress
    )
/*++

    If ppszName parameter is set to NULL, the function does not allocate
    and copy string to caller.  This is useful to initialize the cached
    entry or to determine if the string is valid and available.

    If lpdwBaseAddress is NULL, the caller is not provided the base address
    associated with the process image.

--*/
{
    CALL_STATE *pCallState = (CALL_STATE *)hPSTProv;
    HANDLE hProcess;
    DWORD dwProcessId;
    DWORD_PTR dwProcessBaseAddress;

    WCHAR   szBuf[MAX_PATH+1];
    DWORD   cchProcessName = MAX_PATH;
    BOOL    fImpersonated = FALSE;
    BOOL    fSuccess = FALSE;

    hProcess = pCallState->hProcess;
    dwProcessId = pCallState->dwProcessId;

    if(hProcess == NULL)
        return FALSE;

    //
    // impersonate around the call to insure we can access the file.
    //

    fImpersonated = FImpersonateClient(hPSTProv);

    //
    // get full path to process based on process handle or process Id
    //

    fSuccess = GetProcessPath(
            hProcess,
            dwProcessId,
            szBuf,
            &cchProcessName,
            &dwProcessBaseAddress
            );

    if(fImpersonated)
        FRevertToSelf(hPSTProv);

    if(!fSuccess)
        return FALSE;

    if( ppszName ) {
        *ppszName = (LPWSTR)SSAlloc( cchProcessName * sizeof(WCHAR) );
        if(*ppszName == NULL)
            return FALSE;

        CopyMemory( *ppszName, szBuf, cchProcessName * sizeof(WCHAR) );
    }

    if(lpdwBaseAddress) {
        *lpdwBaseAddress = dwProcessBaseAddress;
    }

    return TRUE;
}

#if 0
BOOL
FGetDiskHash(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    IN  LPWSTR              szImageName,
    IN  BYTE                Hash[A_SHA_DIGEST_LEN]
    )
{
    BOOL bImpersonated = FALSE;
    HANDLE hFile;
    BOOL bSuccess = FALSE;

    if (FIsWinNT())
    {
        //
        // impersonate around hashing disk image since file may be on network
        // if impersonation fails, just try it anyway
        //

        bImpersonated = FImpersonateClient(hPSTProv);
    }


    hFile = CreateFileU(
                szImageName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );

    if( hFile != INVALID_HANDLE_VALUE ) {

        bSuccess = HashDiskImage( hFile, Hash );
        CloseHandle( hFile );
    }

    if(bImpersonated)
        FRevertToSelf(hPSTProv);

    return bSuccess;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\svr\dynalink.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    dynalink.c

Abstract:

    This module contains routines to perform dynamic linking to interfaces
    during protected storage server startup.  This is required because some
    interfaces do not exist on both target platforms, or, due to setup/install
    requirements where some of these .dlls may not be on the system when
    we are run the first time to do install initialization.

Author:

    Scott Field (sfield)    03-Feb-97

--*/

#include <windows.h>

#include "dynalink.h"

#if 1
BOOL
InitDynamicInterfaces(
    VOID
    )
{
    return TRUE;
}
#else
#include "unicode.h"

// WinNT specific
extern FARPROC pNtQueryInformationProcess;

extern FARPROC _NtOpenEvent;
FARPROC _NtWaitForSingleObject = NULL;
FARPROC _ZwClose = NULL;
//FARPROC _DbgPrint = NULL;
FARPROC _ZwRequestWaitReplyPort = NULL;
FARPROC _RtlInitUnicodeString = NULL;
FARPROC _NtClose = NULL;
//FARPROC _strncpy = NULL;
FARPROC _ZwConnectPort = NULL;
FARPROC _ZwFreeVirtualMemory = NULL;
FARPROC _RtlInitString = NULL;

FARPROC _ZwWaitForSingleObject = NULL;
FARPROC _ZwOpenEvent = NULL;


#ifdef WIN95_LEGACY
// Win95 specific
// kernel.dll
extern FARPROC pCreateToolhelp32Snapshot;
extern FARPROC pModule32First;
extern FARPROC pModule32Next;
extern FARPROC pProcess32First;
extern FARPROC pProcess32Next;
extern FARPROC _WNetGetUserA;
#endif  // WIN95_LEGACY

//
// common
// authenticode related (wintrust.dll, crypt32.dll)
//
extern BOOL g_bAuthenticodeInitialized; // authenticode available for us to use?

BOOL
InitDynamicInterfaces(
    VOID
    )
{
    UINT uPriorErrorMode;
    BOOL bSuccess = FALSE;

    //
    // insure no popups are seen about missing files,
    // entry points, etc.
    //

    uPriorErrorMode = SetErrorMode(
                        SEM_FAILCRITICALERRORS |
                        SEM_NOGPFAULTERRORBOX |
                        SEM_NOOPENFILEERRORBOX
                        );

    if(FIsWinNT()) {

        //
        // get WinNT specific interfaces
        //

        HINSTANCE hNtDll;

        // we LoadLibrary ntdll.dll even though it is likely to be in our
        // address space - we don't want to assume it is so because it may not be.
        hNtDll = LoadLibraryW(L"ntdll.dll");
        if(hNtDll == NULL) goto cleanup;

        if((pNtQueryInformationProcess = GetProcAddress(hNtDll, "NtQueryInformationProcess")) == NULL)
            goto cleanup;

        // interfaces required for lsadll.lib
        if((_NtWaitForSingleObject = GetProcAddress(hNtDll, "NtWaitForSingleObject")) == NULL)
            goto cleanup;

        if((_ZwClose = GetProcAddress(hNtDll, "ZwClose")) == NULL)
            goto cleanup;

//      if((_DbgPrint = GetProcAddress(hNtDll, "DbgPrint")) == NULL)
//          goto cleanup;

        if((_ZwRequestWaitReplyPort = GetProcAddress(hNtDll, "ZwRequestWaitReplyPort")) == NULL)
            goto cleanup;

        if((_RtlInitUnicodeString = GetProcAddress(hNtDll, "RtlInitUnicodeString")) == NULL)
            goto cleanup;

        if((_NtOpenEvent = GetProcAddress(hNtDll, "NtOpenEvent")) == NULL)
            goto cleanup;

        if((_NtClose = GetProcAddress(hNtDll, "NtClose")) == NULL)
            goto cleanup;

//      if((_strncpy = GetProcAddress(hNtDll, "strncpy")) == NULL)
//          goto cleanup;

        if((_ZwConnectPort = GetProcAddress(hNtDll, "ZwConnectPort")) == NULL)
            goto cleanup;

        if((_ZwFreeVirtualMemory = GetProcAddress(hNtDll, "ZwFreeVirtualMemory")) == NULL)
            goto cleanup;

        if((_RtlInitString = GetProcAddress(hNtDll, "RtlInitString")) == NULL)
            goto cleanup;

        if((_ZwWaitForSingleObject = GetProcAddress(hNtDll, "ZwWaitForSingleObject")) == NULL)
            goto cleanup;

        if((_ZwOpenEvent = GetProcAddress(hNtDll, "ZwOpenEvent")) == NULL)
            goto cleanup;

        bSuccess = TRUE;
    }
#ifdef WIN95_LEGACY
    else {

        //
        // get Win95 specific interfaces
        //

        HMODULE hKernel = NULL;
        HMODULE hMpr = NULL;

        hKernel = GetModuleHandle("KERNEL32.DLL");

        pCreateToolhelp32Snapshot = GetProcAddress(
            hKernel,
            "CreateToolhelp32Snapshot");

        if(pCreateToolhelp32Snapshot == NULL)
            goto cleanup;

        pModule32First  = GetProcAddress(
            hKernel,
            "Module32First");

        if(pModule32First == NULL)
            goto cleanup;

        pModule32Next   = GetProcAddress(
            hKernel,
            "Module32Next");

        if(pModule32Next == NULL)
            goto cleanup;

        pProcess32First  = GetProcAddress(
            hKernel,
            "Process32First");

        if(pProcess32First == NULL)
            goto cleanup;

        pProcess32Next  = GetProcAddress(
            hKernel,
            "Process32Next");

        if(pProcess32Next == NULL)
            goto cleanup;

        hMpr = LoadLibraryA("MPR.DLL");

        if(hMpr == NULL)
            goto cleanup;

        _WNetGetUserA = GetProcAddress(
            hMpr,
            "WNetGetUserA"
            );

        if(_WNetGetUserA == NULL)
            goto cleanup;

        bSuccess = TRUE;
    }
#endif  // WIN95_LEGACY

cleanup:

    //
    // restore previous error mode.
    //

    SetErrorMode(uPriorErrorMode);

    return bSuccess;
}

ULONG
NTAPI
NtWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
{
    return (ULONG)_NtWaitForSingleObject(Handle, Alertable, Timeout);
}


ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    )
{
    return 0;
}


VOID
NTAPI
RtlInitUnicodeString(
    PVOID DestinationString,
    PCWSTR SourceString
    )
{
    _RtlInitUnicodeString(DestinationString, SourceString);
}

VOID
NTAPI
RtlInitString(
    PVOID DestinationString,
    PVOID SourceString
    )
{
    _RtlInitString(DestinationString, SourceString);
}

ULONG
NTAPI
NtOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PVOID ObjectAttributes
    )
{
    return (ULONG)_NtOpenEvent(EventHandle, DesiredAccess, ObjectAttributes);
}

ULONG
NTAPI
NtClose(
    IN HANDLE Handle
    )
{

    return (ULONG)_NtClose( Handle );
}


ULONG
NTAPI
ZwClose(
    IN HANDLE Handle
    )
{
    return (ULONG)_ZwClose(Handle);
}

ULONG
NTAPI
ZwRequestWaitReplyPort(
    IN HANDLE PortHandle,
    IN PVOID RequestMessage,
    OUT PVOID ReplyMessage
    )
{
    return (ULONG)_ZwRequestWaitReplyPort(
                PortHandle,
                RequestMessage,
                ReplyMessage
                );

}

ULONG
NTAPI
ZwConnectPort(
    OUT PHANDLE PortHandle,
    IN PVOID PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT PVOID ClientView OPTIONAL,
    OUT PVOID ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN OUT PVOID ConnectionInformation OPTIONAL,
    IN OUT PULONG ConnectionInformationLength OPTIONAL
    )
{
    return (ULONG)_ZwConnectPort(
                PortHandle,
                PortName,
                SecurityQos,
                ClientView,
                ServerView,
                MaxMessageLength,
                ConnectionInformation,
                ConnectionInformationLength
                );
}

ULONG
NTAPI
ZwFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PULONG RegionSize,
    IN ULONG FreeType
    )
{
    return (ULONG)_ZwFreeVirtualMemory(
                ProcessHandle,
                BaseAddress,
                RegionSize,
                FreeType
                );
}



ULONG
NTAPI
ZwWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
{
    return (ULONG)_ZwWaitForSingleObject(Handle, Alertable, Timeout);
}

ULONG
NTAPI
ZwOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PVOID ObjectAttributes
    )
{
    return (ULONG)_ZwOpenEvent(EventHandle, DesiredAccess, ObjectAttributes);
}

VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    )
{
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\svr\dynalink.h ===
#ifndef __DYNALINK_H__
#define __DYNALINK_H__

#ifdef __cplusplus
extern "C" {
#endif

BOOL
InitDynamicInterfaces(
	VOID
	);



#ifdef __cplusplus
}
#endif


#endif // __DYNALINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\prov\storage.h ===
// Per-user data items

// export for one-time initialization
DWORD GetPSTUserHKEY(
        LPCWSTR szUser,         // in
        HKEY* phUserKey,        // out
        BOOL* pfExisted);       // out

// types
DWORD BPCreateType(            // fills in PST_GUIDNAME's sz if NULL
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,    // in
        PST_TYPEINFO* pinfoType);   // in

DWORD BPDeleteType(
        LPCWSTR  szUser,        // in
        const GUID*   pguidType);     // in

DWORD BPEnumTypes(
        LPCWSTR  szUser,        // in
        DWORD   dwIndex,        // in
        GUID*   pguidType);     // out

DWORD BPGetTypeName(           // fills in PST_GUIDNAME's sz
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        LPWSTR* ppszType);      // out


// subtypes
DWORD BPCreateSubtype(         // fills in PST_GUIDNAME's sz if NULL
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        PST_TYPEINFO* pinfoSubtype);    // in

DWORD BPDeleteSubtype(
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype);  // in

DWORD BPEnumSubtypes(
        LPCWSTR  szUser,        // in
        DWORD   dwIndex,        // in
        const GUID*   pguidType,      // in
        GUID*   pguidSubtype);  // out

DWORD BPGetSubtypeName(        // fills in PST_GUIDNAME's sz
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPWSTR* ppszSubtype);   // out


// items
DWORD BPCreateItem(            
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName);   // in

DWORD BPDeleteItem(
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName);   // in

DWORD BPEnumItems(
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        DWORD   dwIndex,        // in
        LPWSTR* ppszName);      // out


#if 0

// rulesets
DWORD BPGetSubtypeRuleset(
        PST_PROVIDER_HANDLE* phPSTProv, // in
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        PST_ACCESSRULESET* psRules); // out

DWORD BPSetSubtypeRuleset(
        PST_PROVIDER_HANDLE* phPSTProv, // in
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        PST_ACCESSRULESET *sRules); // in

DWORD BPGetItemRuleset(
        PST_PROVIDER_HANDLE* phPSTProv, // in
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,    // in
        PST_ACCESSRULESET* psRules); // out

DWORD BPSetItemRuleset(
        PST_PROVIDER_HANDLE* phPSTProv, // in
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,    // in
        PST_ACCESSRULESET *sRules); // in

#endif

      
// secured data 
BOOL FBPGetSecuredItemData(
        LPCWSTR  szUser,        // in
        LPCWSTR  szMasterKey,   // in
		BYTE    rgbPwd[],	    // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,    // in
        PBYTE*  ppbData,        // out
        DWORD*  pcbData);       // out

BOOL FBPSetSecuredItemData(   
        LPCWSTR  szUser,        // in
        LPCWSTR  szMasterKey,   // in
		BYTE    rgbPwd[],		// in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,    // in
        PBYTE   pbData,         // in
        DWORD   cbData);        // in

// insecure data 
DWORD BPGetInsecureItemData(
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,    // in
        PBYTE*  ppbData,        // out
        DWORD*  pcbData);       // out

DWORD BPSetInsecureItemData(
        LPCWSTR szUser,         // in
        const GUID*     pguidType,      // in
        const GUID*     pguidSubtype,   // in
        LPCWSTR szItemName,     // in
        PBYTE   pbData,         // in
        DWORD   cbData);        // in


// Item Confirmation 
DWORD BPGetItemConfirm(
        PST_PROVIDER_HANDLE* phPSTProv, // in
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in           
        LPCWSTR  szItemName,    // in
        DWORD*  pdwConfirm,     // out
        LPWSTR* pszMK);         // out

DWORD BPSetItemConfirm(
        PST_PROVIDER_HANDLE* phPSTProv, // in
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in           
        LPCWSTR  szItemName,    // in
        DWORD   dwConfirm,      // in
        LPCWSTR  szMK);         // in


// Master Keys
BOOL BPMasterKeyExists(
        LPCWSTR  szUser,        // in
        LPWSTR   szMasterKey);  // in

DWORD BPEnumMasterKeys(
        LPCWSTR  szUser,        // in
        DWORD   dwIndex,        // in
        LPWSTR* ppszMasterKey); // out

DWORD BPGetMasterKeys(
        LPCWSTR  szUser,        // in
        LPCWSTR  rgszMasterKeys[],  // in 
        DWORD*  pcbMasterKeys,  // in, out
        BOOL    fUserFilter);   // in

// security state
BOOL FBPGetSecurityState(
        LPCWSTR  szUser,        // in
        LPCWSTR  szMK,          // in
        BYTE    rgbSalt[],      // out
        DWORD   cbSalt,         // in
        BYTE    rgbConfirm[],   // out
        DWORD   cbConfirm,      // in
        PBYTE*  ppbMK,          // out
        DWORD*  pcbMK);         // out

BOOL FBPGetSecurityStateFromHKEY(
            HKEY    hMKKey,
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbConfirm[],
            DWORD   cbConfirm,
            PBYTE*  ppbMK,
            DWORD*  pcbMK);

BOOL FBPSetSecurityState(
        LPCWSTR  szUser,        // in
        LPCWSTR  szMK,          // in
        BYTE    rgbSalt[],      // in
        DWORD   cbSalt,         // in
        BYTE    rgbConfirm[],   // in
        DWORD   cbConfirm,      // in
        PBYTE   pbMK,           // in
        DWORD   cbMK);          // in


// MAC keys
BOOL FGetInternalMACKey(
        LPCWSTR szUser,         // in
        PBYTE* ppbKey,          // out
        DWORD* pcbKey);         // out

BOOL FSetInternalMACKey(
        LPCWSTR szUser,         // in
        PBYTE pbKey,            // in
        DWORD cbKey);           // in

// nuke existing user data
BOOL
DeleteAllUserData(
    HKEY hKey
    );

BOOL
DeleteUserData(
    HKEY hKey
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\svr\dispif.cpp ===
#include <pch.cpp>
#pragma hdrstop


#define MAX_PW_LEN  160
#define MAX_STRING_RSC_SIZE 512

#define WSZ_NULLSTRING L""

extern HINSTANCE    g_hInst;

extern "C" {

typedef DWORD (WINAPI *WNETGETUSERA)(
    LPCSTR lpName,
    LPSTR lpUserName,
    LPDWORD lpnLength
    );

extern WNETGETUSERA _WNetGetUserA;

}




typedef struct _GETWINPW_DIALOGARGS
{
    LPWSTR* ppszPW;
    PST_PROVIDER_HANDLE     *phPSTProv;

} GETWINPW_DIALOGARGS, *PGETWINPW_DIALOGARGS;


INT_PTR CALLBACK DialogGetWindowsPassword(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
)
{
    int iRet = IDCANCEL; // assume cancel
    BOOL bSuccess = FALSE; // assume error

    WCHAR szMessage[MAX_STRING_RSC_SIZE];
    WCHAR szDlgTitle[MAX_STRING_RSC_SIZE];

    switch (message)
    {
        case WM_INITDIALOG:
        {
            UINT uResString;

            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }

            if(FIsWinNT()) {
                uResString = IDS_GET_WINDOWS_PASSWORD_NT;
            } else {
                uResString = IDS_GET_WINDOWS_PASSWORD_95;
            }

            LoadStringU(
                g_hInst,
                uResString,
                szMessage,
                MAX_STRING_RSC_SIZE);

            SetWindowTextU(GetDlgItem(hDlg, IDC_MESSAGE), szMessage);

            return TRUE;
        }

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                PGETWINPW_DIALOGARGS pDlgArgs;
                LPWSTR* ppszPW;
                WCHAR sz1[MAX_PW_LEN];

                DWORD cch1 = 0;
                BOOL bPasswordVerified;

                pDlgArgs = (PGETWINPW_DIALOGARGS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
                if(pDlgArgs == 0) break; // TODO:   bail out

                ppszPW = pDlgArgs->ppszPW;
                *ppszPW = NULL;

                // must impersonate client.  If it fails, bail.
                if(!FImpersonateClient(pDlgArgs->phPSTProv))
                    break;

                cch1 = GetDlgItemTextU(
                    hDlg,
                    IDC_EDIT1,
                    sz1,
                    MAX_PW_LEN);

                // push an hourglass to the screen
                HCURSOR curOld;
                curOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

                // validate  password
                bPasswordVerified = VerifyWindowsPassword(sz1);

                // put old cursor back
                SetCursor(curOld);

                FRevertToSelf(pDlgArgs->phPSTProv);

                // Clear any queued user keyboard entry turds before returning
                MSG sMsg;
                while (PeekMessage(&sMsg, hDlg, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))
                    ;

                if(!bPasswordVerified)
                {
                    szMessage[0] = L'\0';
                    LoadStringU(
                        g_hInst,
                        IDS_PASSWORD_NOVERIFY,
                        szMessage,
                        MAX_STRING_RSC_SIZE);

                    szDlgTitle[0] = L'\0';
                    LoadStringU(
                        g_hInst,
                        IDS_PASSWORD_ERROR_DLGTITLE,
                        szDlgTitle,
                        MAX_STRING_RSC_SIZE);

                    // this W implemented in both Win95 & NT!
                    MessageBoxW(
                            NULL, // hDlg,
                            szMessage,
                            szDlgTitle,
                            MB_OK|MB_ICONEXCLAMATION|MB_SERVICE_NOTIFICATION);

                    SetWindowTextU(GetDlgItem(hDlg, IDC_EDIT1), WSZ_NULLSTRING);

                    goto cleanup;
                }

                // now bite it: save

                SS_ASSERT(ppszPW != NULL);
                *ppszPW = (LPWSTR)SSAlloc( (cch1+1) * sizeof(WCHAR) );
                if(*ppszPW == NULL) goto cleanup;

                //
                // sfield: defer copying strings until we know everything succeeded.
                // this way, we don't have to zero these buffers if some
                // allocs + copies succeed, and others fail.
                //
                wcscpy(*ppszPW, sz1);

                iRet = IDOK;
                bSuccess = TRUE;

cleanup:

                if(cch1) ZeroMemory(sz1, cch1 * sizeof(WCHAR));

                if(!bSuccess)
                {
                    if(*ppszPW)
                    {
                        SSFree(*ppszPW);
                        *ppszPW = NULL;
                    }

                    return FALSE;
                }

                break; // things went OK, just bail to EndDialog

            } // IDOK

            if( LOWORD(wParam) == IDCANCEL )
                break;

        default:
            return FALSE;
    }

    EndDialog(hDlg, iRet);

    return bSuccess;
}


BOOL
FGetWindowsPassword(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    IN  BYTE                rgbPasswordDerivedBytes[],
    IN  DWORD               cbPasswordDerivedBytes
    )
{
    BOOL fRet;
    LPWSTR pszPW = NULL;


    if ((rgbPasswordDerivedBytes == NULL) || (cbPasswordDerivedBytes < A_SHA_DIGEST_LEN))
        return FALSE;


    //
    // the general event flow for this routine:
    //
    // 1. Search cache for credentials.  WinNT requires impersonating around search.
    // 2. If search fails on Win95, try to get the password directly from MPR
    // 3. If search fails on WinNT, check for special cases like LocalSystem and NETWORK
    //     Allow Local System by building fixed credential.
    //     Disallow NETWORK because no credentials exist (return FAILURE).
    // 4. If we still don't have credentials, prompt user via UI.
    //




    if(FIsWinNT())
    {

        //
        // we must be impersonating around this call !!!
        //

        if(!FImpersonateClient(hPSTProv))
            return FALSE;

        fRet = GetPasswordNT(rgbPasswordDerivedBytes);

        FRevertToSelf(hPSTProv);

    }
    else
    {
        fRet = GetPassword95(rgbPasswordDerivedBytes);
    }


    // if either GetPassword routine fails
    if (!fRet)
    {
        INT_PTR iRet;
        DWORD cbPassword;
        BOOL fCachePassword = TRUE; // cache the results by default


#ifdef WIN95_LEGACY

        if(!FIsWinNT()) {

            //
            // on Win95, call our hack which tries to get the current password
            //

            fRet = GetHackPassword95(rgbPasswordDerivedBytes);

            if(fRet)
                fCachePassword = FALSE; // do not cache grovelled password
            else {

                //
                // Win95: bail out now, do not throw up UI to get the
                // windows Password.  We do this because the grovel above
                // will only fail on Memphis - we have no installed base
                // on Memphis today because it has not been released yet.
                //

                goto Ret;
            }
        } else
#endif  // WIN95_LEGACY
        {

            BOOL fSpecialCase;

            if(!FImpersonateClient(hPSTProv))
                goto Ret;

            //
            // WinNT: check for some special cases, namely, if we are runninng
            // under Local System or Network credentials.
            //

            fRet = GetSpecialCasePasswordNT(
                            rgbPasswordDerivedBytes,    // derived bits when fSpecialCase == TRUE
                            &fSpecialCase               // legal special case encountered?
                            );

            FRevertToSelf(hPSTProv);

            //
            // if the query failed bail out, since we encountered an illegal
            // or inapproriate condition.
            //

            if(!fRet)
                goto Ret;

            //
            // now, set fRet to the result of the special case test.
            // so, if we encountered an allowed special case, we have an
            // validly filled rgbPasswordDerivedBytes buffer.  If we didn't
            // encounter a legal special case, we continue on our quest for
            // a password.
            //

            fRet = fSpecialCase;

        }

        //
        // re-evaluate fRet for the special hack for Win95 above.
        //

        if(!fRet) {

            // return a validated password
            GETWINPW_DIALOGARGS DialogArgs = {&pszPW, hPSTProv};
            iRet = DialogBoxParam(
                    g_hInst,
                    MAKEINTRESOURCE(IDD_GET_WINDOWS_PASSWORD),
                    NULL,
                    DialogGetWindowsPassword,
                    (LPARAM)&DialogArgs);

            if(iRet != IDOK) goto Ret;

            if (pszPW == NULL)
                goto Ret;

            //
            // everything went fine, now derive the password bits!
            //
            if (!FIsWinNT())
            {
                DWORD cbUpper = WSZ_BYTECOUNT(pszPW);
                LPWSTR szUpper = (LPWSTR)SSAlloc(cbUpper);

                // cnvt all Win95 pwds to uppercase
                LCMapStringU(
                        LOCALE_SYSTEM_DEFAULT,
                        LCMAP_UPPERCASE,
                        pszPW,
                        -1,
                        szUpper,
                        cbUpper);
                wcscpy(pszPW, szUpper);
                ZeroMemory(szUpper, cbUpper);
                SSFree(szUpper);
            }

            cbPassword = WSZ_BYTECOUNT(pszPW) - sizeof(WCHAR) ;

            // hash pwd, copy out
            A_SHA_CTX   sSHAHash;
            A_SHAInit(&sSHAHash);
            A_SHAUpdate(&sSHAHash, (BYTE *) pszPW, cbPassword);
            ZeroMemory(pszPW, cbPassword); // sfield: zero the password

            // Finish off the hash
            A_SHAFinal(&sSHAHash, rgbPasswordDerivedBytes);
        }

        //
        // now, update the password cache
        //
        if(fCachePassword) {

            if (FIsWinNT())
            {
                LUID AuthenticationId;

                // get user LUID

                //
                // we must be impersonating around this call !!!
                //

                if(!FImpersonateClient(hPSTProv))
                    goto Ret;

                if(!GetThreadAuthenticationId(
                        GetCurrentThread(),
                        &AuthenticationId))
                {
                    FRevertToSelf(hPSTProv);
                    goto Ret;
                }

                if (!SetPasswordNT(
                        &AuthenticationId,
                        rgbPasswordDerivedBytes))
                {
                    FRevertToSelf(hPSTProv);
                    goto Ret;
                }

                FRevertToSelf(hPSTProv);

            }
            else
            {
                A_SHA_CTX shactxtUserName;
                BYTE HashUsername[A_SHA_DIGEST_LEN];
                CHAR Username[UNLEN+1];
                DWORD cchUsername = UNLEN;

                //
                // compute hash of username
                // sfield: use WNetGetUser() instead of GetUserName() as WNetGetUser()
                // will correspond to the password associated with what the network
                // provider gave us.
                //
                if(_WNetGetUserA(NULL, Username, &cchUsername) != NO_ERROR) {

                    //
                    // for Win95, if nobody is logged on, empty user name + password
                    //

                    if(GetLastError() != ERROR_NOT_LOGGED_ON)
                        goto Ret;

                    Username[0] = '\0'; // not really necessary
                    cchUsername = 1;
                } else {
                    // arg, WNetGetUserA() doesn't fill in cchUsername
                    cchUsername = lstrlenA(Username) + 1; // include terminal NULL
                }

                cchUsername--; // do not include terminal NULL

                A_SHAInit(&shactxtUserName);
                A_SHAUpdate(&shactxtUserName, (PBYTE)Username, cchUsername);
                A_SHAFinal(&shactxtUserName, HashUsername);

                if (!SetPassword95(
                        HashUsername,
                        rgbPasswordDerivedBytes))
                    goto Ret;
            }
        } // fCachePassword
    }

    fRet = TRUE;
Ret:
    if (pszPW)
        SSFree(pszPW);

    return fRet;
}


BOOL
FIsACLSatisfied(
    IN          PST_PROVIDER_HANDLE     *hPSTProv,
    IN          PST_ACCESSRULESET       *psRules,
    IN          DWORD                   dwAccess,
    IN  OUT     LPVOID      // coming soon: fill a status structure with data about access attempt
    )
{
    if ((psRules->cRules == 0)||(psRules->rgRules == NULL))
        return TRUE;

    //
    // parent exe name.  cached through loop
    //

    LPWSTR pszParentExeName = NULL;

    //
    // direct caller image.  cached through loop
    //

    LPWSTR pszDirectCaller = NULL;

    //
    // base address of direct call module
    //

    DWORD_PTR BaseAddressDirect;

    //
    // module that is the subject of analysis
    //

    LPWSTR szHashTarget;


    //
    // search for a list of terms that are completely satisfied
    //

    for(DWORD cRule=0; cRule<psRules->cRules; cRule++)
    {
        // check only those rules that govern the right access
        //
        // loop while we still have dwAccess modes to check
        //
        if (0 == (psRules->rgRules[cRule].AccessModeFlags & dwAccess))
            continue;

        // evaluate the ith term
        PPST_ACCESSCLAUSE pClause;

        // walk down list
        for(DWORD cClause=0; cClause<psRules->rgRules[cRule].cClauses; cClause++)
        {
            pClause = &psRules->rgRules[cRule].rgClauses[cClause];

            // for each term, make sure ALL ENTRIES are satisfied

            // TODO: what to do if clause data not self relative?
            // not possible at this point in time, but it may come up later
            //

            switch(pClause->ClauseType & ~PST_SELF_RELATIVE_CLAUSE)
            {
            // for each type, may use the pClause->pbClauseData
            case PST_SECURITY_DESCRIPTOR:
                {
                    // passed test
                    continue;   // next clause
                }
            case PST_AUTHENTICODE:
                {
                    // passed test
                    continue;       // next clause
                }
            case PST_BINARY_CHECK:
                {
                    // passed test
                    continue;       // next clause
                }

            default:
                // unknown type in ACL: this chain failed, goto next chain
                goto NextRule;    // next rule
            }
        }

        // YES! ALL clauses evaluated and OK

        // turn off the bits that got us into this clause chain
        dwAccess &= ~ psRules->rgRules[cRule].AccessModeFlags;

NextRule:

        continue;
    }

//Cleanup:

    // cleanup
    if (pszParentExeName)
        SSFree(pszParentExeName);

    if(pszDirectCaller)
        SSFree(pszDirectCaller);

    return (dwAccess == 0);
}


BOOL FGetUser(
        PST_PROVIDER_HANDLE *hPSTProv,
        LPWSTR* ppszUser)
{
    return FGetUserName(hPSTProv, ppszUser);
}

BOOL
FGetCallerName(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    OUT LPWSTR* ppszCallerName,
    OUT DWORD_PTR *lpdwBaseAddress
    )
{
    return FGetParentFileName(hPSTProv, ppszCallerName, lpdwBaseAddress);
}

BOOL
FGetServerParam(
    IN      PST_PROVIDER_HANDLE *hPSTProv,
    IN      DWORD  dwParam,
    IN      LPVOID pData,
    IN  OUT DWORD *pcbData
    )
{
    //
    // check for the server get param that asks for private dispatch interfaces
    //

    if( dwParam == SS_SERVERPARAM_CALLBACKS &&
        *pcbData >= sizeof( PRIVATE_CALLBACKS )) {

        PRIVATE_CALLBACKS *PrivateCallbacks = (PRIVATE_CALLBACKS *)pData;

        PrivateCallbacks->cbSize = sizeof( PRIVATE_CALLBACKS );
        PrivateCallbacks->pfnFGetWindowsPassword = FGetWindowsPassword;
        PrivateCallbacks->pfnAuthenticodeInitPolicy = NULL;
        PrivateCallbacks->pfnAuthenticodeFinalPolicy = NULL;

        *pcbData = sizeof( PRIVATE_CALLBACKS );

        return TRUE;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
FSetServerParam(
    IN      PST_PROVIDER_HANDLE *hPSTProv,
    IN      DWORD  dwParam,
    IN      LPVOID pData,
    IN      DWORD pcbData
    )
{

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\svr\config.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    config.cpp

Abstract:

    This module contains routines to perform configuration data item management
    in the protected store.

Author:

    Scott Field (sfield)    28-Mar-97

--*/

#include <pch.cpp>
#pragma hdrstop

//
// these are temporary until better home is found.
//

extern PST_PROVIDERID g_guidBaseProvider;
extern CALL_STATE g_sDummyCallState;
extern PLIST_ITEM g_psDummyListItem;

BOOL
AllocatePseudoUniqueHandle(
    PST_PROVIDER_HANDLE *phPSTProv
    );

BOOL
FAcquireProvider(
    PST_PROVIDERID*  pProviderID
    );

BOOL
CreateDummyUserContext(
    IN      PST_PROVIDER_HANDLE *hPSTProv,
    IN      CALL_STATE *pNewContext
    );

BOOL
DeleteDummyUserContext(
    IN      CALL_STATE *pNewContext
    );

//
// ... end of temporary section.
//


LPVOID
RulesAlloc(
    IN      DWORD cb
    )
{
    return SSAlloc( cb );
}

VOID
RulesFree(
    IN      LPVOID pv
    )
{
    SSFree( pv );
}

BOOL
FGetConfigurationData(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    IN  PST_KEY KeyLocation,
    IN  GUID *pguidSubtype,
    IN  LPCWSTR szItemName,
    OUT BYTE **ppbData,
    OUT DWORD *pcbData
    )
{
    PST_PROVIDER_HANDLE *phNewPSTProv = NULL;
    CALL_STATE          NewContext;
    BOOL                fDummyContext = FALSE;
    BOOL                fSuccess = FALSE;

    HRESULT             hr;

    if(KeyLocation != PST_KEY_CURRENT_USER && KeyLocation != PST_KEY_LOCAL_MACHINE) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Hard case is PST_KEY_CURRENT_USER.  Prepare user context for that
    // scenario.
    //

    if(KeyLocation == PST_KEY_CURRENT_USER) {
        phNewPSTProv = (PST_PROVIDER_HANDLE *)&NewContext;

        //
        // hard case: PST_KEY_CURRENT_USER
        //


        fDummyContext = CreateDummyUserContext( hPSTProv, &NewContext );

        if(!fDummyContext)
            goto cleanup;
    } else {

        //
        // PST_KEY_LOCAL_MACHINE : global dummy call state
        //

        phNewPSTProv = (PST_PROVIDER_HANDLE *)&g_sDummyCallState;
    }

    __try {

        //
        // get the system provider (dispatch table)
        //

        PPROV_LIST_ITEM pli = SearchProvListByID(&g_guidBaseProvider);
        GUID guidType =  PST_CONFIGDATA_TYPE_GUID;
        PST_PROMPTINFO sPrompt = {sizeof(PST_PROMPTINFO), 0, 0, L""};

        if( pli == NULL )
            goto cleanup;

        //
        // make call with the new context we setup
        //

        hr = pli->fnList.SPReadItem(
                    phNewPSTProv,
                    KeyLocation,    // target PST_KEY_CURRENT_USER or PST_KEY_LOCAL_MACHINE
                    &guidType,
                    pguidSubtype,
                    szItemName,
                    pcbData,
                    ppbData,
                    &sPrompt,
                    0
                    );

        if( hr == S_OK )
            fSuccess = TRUE;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        // swallow
        fSuccess = FALSE;
    }

cleanup:


    if(fDummyContext) {
        DeleteDummyUserContext( &NewContext );
    }

    return fSuccess;
}

BOOL
FSetConfigurationData(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    IN  PST_KEY KeyLocation,
    IN  GUID *pguidSubtype,
    IN  LPCWSTR szItemName,
    IN  BYTE *pbData,
    IN  DWORD cbData
    )
{
    PST_PROVIDER_HANDLE *phNewPSTProv = NULL;
    CALL_STATE          NewContext;
    BOOL                fDummyContext = FALSE;
    BOOL                fSuccess = FALSE;

    HRESULT             hr;

    if(KeyLocation != PST_KEY_CURRENT_USER && KeyLocation != PST_KEY_LOCAL_MACHINE) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Hard case is PST_KEY_CURRENT_USER.  Prepare user context for that
    // scenario.
    //

    if(KeyLocation == PST_KEY_CURRENT_USER) {
        phNewPSTProv = (PST_PROVIDER_HANDLE *)&NewContext;

        //
        // hard case: PST_KEY_CURRENT_USER
        //


        fDummyContext = CreateDummyUserContext( hPSTProv, &NewContext );

        if(!fDummyContext)
            goto cleanup;
    } else {

        //
        // PST_KEY_LOCAL_MACHINE : global dummy call state
        //

        phNewPSTProv = (PST_PROVIDER_HANDLE *)&g_sDummyCallState;
    }

    __try {

        //
        // get the system provider (dispatch table)
        //

        PPROV_LIST_ITEM pli = SearchProvListByID(&g_guidBaseProvider);
        GUID guidType =  PST_CONFIGDATA_TYPE_GUID;
        PST_PROMPTINFO sPrompt = {sizeof(PST_PROMPTINFO), 0, 0, L""};

        if( pli == NULL )
            goto cleanup;

        //
        // make call with the new context we setup
        //

        hr = pli->fnList.SPWriteItem(
                    phNewPSTProv,
                    KeyLocation,    // target PST_KEY_CURRENT_USER or PST_KEY_LOCAL_MACHINE
                    &guidType,
                    pguidSubtype,
                    szItemName,
                    cbData,
                    pbData,
                    &sPrompt,
                    0,
                    0
                    );

        if( hr == S_OK )
            fSuccess = TRUE;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        // swallow
        fSuccess = FALSE;
    }

cleanup:


    if(fDummyContext) {
        DeleteDummyUserContext( &NewContext );
    }

    return fSuccess;
}

BOOL
FInternalCreateType(
    PST_PROVIDER_HANDLE *phPSTProv,
    PST_KEY KeyLocation,
    const GUID *pguidType,
    PPST_TYPEINFO pinfoType,
    DWORD dwFlags
    )
{

    PST_PROVIDER_HANDLE *phNewPSTProv = NULL;
    CALL_STATE          NewContext;
    BOOL                fDummyContext = FALSE;
    BOOL                fSuccess = FALSE;

    PST_ACCESSRULESET   Rules;
    HRESULT             hr;

    if(KeyLocation != PST_KEY_CURRENT_USER && KeyLocation != PST_KEY_LOCAL_MACHINE) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Hard case is PST_KEY_CURRENT_USER.  Prepare user context for that
    // scenario.
    //

    if(KeyLocation == PST_KEY_CURRENT_USER) {
        phNewPSTProv = (PST_PROVIDER_HANDLE *)&NewContext;

        //
        // hard case: PST_KEY_CURRENT_USER
        //


        fDummyContext = CreateDummyUserContext( phPSTProv, &NewContext );

        if(!fDummyContext)
            goto cleanup;
    } else {

        //
        // PST_KEY_LOCAL_MACHINE : global dummy call state
        //

        phNewPSTProv = (PST_PROVIDER_HANDLE *)&g_sDummyCallState;
    }

    __try {

        //
        // get the system provider (dispatch table)
        //

        PPROV_LIST_ITEM pli = SearchProvListByID(&g_guidBaseProvider);

        if( pli == NULL )
            goto cleanup;

        //
        // make call with the new context we setup
        //

        Rules.cbSize = sizeof( Rules );
        Rules.cRules = 0;
        Rules.rgRules = NULL;

        hr = pli->fnList.SPCreateType(
                    phNewPSTProv,
                    KeyLocation,
                    pguidType,
                    pinfoType,
                    dwFlags
                    );

        if(hr == S_OK || hr == PST_E_TYPE_EXISTS)
            fSuccess = TRUE;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        // swallow
        fSuccess = FALSE;
    }

cleanup:


    if(fDummyContext) {
        DeleteDummyUserContext( &NewContext );
    }

    return fSuccess;
}

BOOL
FInternalCreateSubtype(
    PST_PROVIDER_HANDLE *phPSTProv,
    PST_KEY KeyLocation,
    const GUID *pguidType,
    const GUID *pguidSubtype,
    PPST_TYPEINFO pinfoSubtype,
    DWORD dwFlags
    )
/*++

    This routine allows the protected storage server to create a subtype
    within the Microsoft Protected Storage Base Provider.

    The subtype is created with no access ruleset.  The caller should use
    the FInternalWriteAccessRuleset() if an access ruleset needs to be applied
    after the subtype is created.

--*/
{

    PST_PROVIDER_HANDLE *phNewPSTProv = NULL;
    CALL_STATE          NewContext;
    BOOL                fDummyContext = FALSE;
    BOOL                fSuccess = FALSE;

    PST_ACCESSRULESET   Rules;
    HRESULT             hr;

    if(KeyLocation != PST_KEY_CURRENT_USER && KeyLocation != PST_KEY_LOCAL_MACHINE) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Hard case is PST_KEY_CURRENT_USER.  Prepare user context for that
    // scenario.
    //

    if(KeyLocation == PST_KEY_CURRENT_USER) {
        phNewPSTProv = (PST_PROVIDER_HANDLE *)&NewContext;

        //
        // hard case: PST_KEY_CURRENT_USER
        //


        fDummyContext = CreateDummyUserContext( phPSTProv, &NewContext );

        if(!fDummyContext)
            goto cleanup;
    } else {

        //
        // PST_KEY_LOCAL_MACHINE : global dummy call state
        //

        phNewPSTProv = (PST_PROVIDER_HANDLE *)&g_sDummyCallState;
    }

    __try {

        //
        // get the system provider (dispatch table)
        //

        PPROV_LIST_ITEM pli = SearchProvListByID(&g_guidBaseProvider);

        if( pli == NULL )
            goto cleanup;

        //
        // make call with the new context we setup
        //

        Rules.cbSize = sizeof( Rules );
        Rules.cRules = 0;
        Rules.rgRules = NULL;

        hr = pli->fnList.SPCreateSubtype(
                    phNewPSTProv,
                    KeyLocation,
                    pguidType,
                    pguidSubtype,
                    pinfoSubtype,
                    &Rules,
                    dwFlags
                    );

        if(hr == S_OK || hr == PST_E_TYPE_EXISTS)
            fSuccess = TRUE;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        // swallow
        fSuccess = FALSE;
    }

cleanup:


    if(fDummyContext) {
        DeleteDummyUserContext( &NewContext );
    }

    return fSuccess;
}


BOOL
FInternalWriteAccessRuleset(
    PST_PROVIDER_HANDLE *phPSTProv,
    PST_KEY KeyLocation,
    const GUID *pguidType,
    const GUID *pguidSubtype,
    PPST_ACCESSRULESET psRules,
    DWORD dwFlags
    )
{
    PST_PROVIDER_HANDLE *phNewPSTProv = NULL;
    CALL_STATE          NewContext;
    BOOL                fDummyContext = FALSE;
    BOOL                fSuccess = FALSE;

    PPST_ACCESSRULESET  NewRules = NULL;

    HRESULT             hr = S_OK;

    if(KeyLocation != PST_KEY_CURRENT_USER && KeyLocation != PST_KEY_LOCAL_MACHINE) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Hard case is PST_KEY_CURRENT_USER.  Prepare user context for that
    // scenario.
    //

    if(KeyLocation == PST_KEY_CURRENT_USER) {
        phNewPSTProv = (PST_PROVIDER_HANDLE *)&NewContext;

        //
        // hard case: PST_KEY_CURRENT_USER
        //


        fDummyContext = CreateDummyUserContext( phPSTProv, &NewContext );

        if(!fDummyContext)
            goto cleanup;
    } else {

        //
        // PST_KEY_LOCAL_MACHINE : global dummy call state
        //

        phNewPSTProv = (PST_PROVIDER_HANDLE *)&g_sDummyCallState;
    }

    __try {

        //
        // get the system provider (dispatch table)
        //

        PPROV_LIST_ITEM pli = SearchProvListByID(&g_guidBaseProvider);

        if( pli == NULL )
            goto cleanup;


        //
        // Need to make rule data contiguous for push across RPC
        //

        DWORD cbRules;

        // get the length of the entire ruleset structure
        if (!GetLengthOfRuleset(psRules, &cbRules))
        {
            hr = PST_E_INVALID_RULESET;
            goto cleanup;
        }

        // allocate space for the rules
        if (NULL == (NewRules = (PST_ACCESSRULESET*)SSAlloc(cbRules)))
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        ZeroMemory(NewRules, cbRules);

        // set up the rules to be output
        if (!MyCopyOfRuleset(psRules, NewRules))
        {
            hr = PST_E_FAIL;
            goto cleanup;
        }

        // make clause data relative
        if(!RulesAbsoluteToRelative(NewRules))
        {
            hr = PST_E_INVALID_RULESET;
            goto cleanup;
        }

        //
        // make call with the new context we setup
        //

        hr = pli->fnList.SPWriteAccessRuleset(
                    phNewPSTProv,
                    KeyLocation,
                    pguidType,
                    pguidSubtype,
                    NewRules,
                    dwFlags
                    );

        if(hr == S_OK || hr == PST_E_TYPE_EXISTS)
            fSuccess = TRUE;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        // swallow
        fSuccess = FALSE;
    }

cleanup:


    if(fDummyContext) {
        DeleteDummyUserContext( &NewContext );
    }

    if(NewRules)
    {
        FreeClauseDataRelative( NewRules );
        SSFree( NewRules );
    }

    if(!fSuccess && hr != S_OK)
        SetLastError((DWORD) hr);

    return fSuccess;
}

BOOL
CreateDummyUserContext(
    IN      PST_PROVIDER_HANDLE *hPSTProv,
    IN      CALL_STATE *pNewContext
    )
{
    //
    // hard case: PST_KEY_CURRENT_USER
    //

    PLIST_ITEM pliCaller; // list item associated with user calling this function
    PLIST_ITEM pliNew;    // newly allocated list item
    DWORD cbName;

    CALL_STATE *CallerContext = (CALL_STATE *)hPSTProv;

    BOOL bSuccess = FALSE;

    if (NULL == (pliCaller = SearchListByHandleT(hPSTProv)))
        return FALSE;


    //
    // allocate memory for new list item, and initially populate
    // it with information from the calling list item.
    //

    pliNew = (PLIST_ITEM)SSAlloc(sizeof(LIST_ITEM));
    if(pliNew == NULL)
        return FALSE;

    CopyMemory(pliNew, pliCaller, sizeof(LIST_ITEM));
    pliNew->szProcessName = NULL;
    pliNew->szCallerUsername = NULL;


    //
    // now, overwrite with some server related elements to
    // make it look like the server is accessing the data as the calling
    // user.
    //

    if(!AllocatePseudoUniqueHandle( &(pliNew->hPSTProv) ))
        goto cleanup;

    CopyMemory(&(pliNew->ProviderID), &g_guidBaseProvider, sizeof(PST_PROVIDERID));
    pliNew->hProcess = g_psDummyListItem->hProcess;
    pliNew->hThread = g_psDummyListItem->hThread;
    pliNew->dwProcessId = g_psDummyListItem->dwProcessId;

    //
    // allocate new copy of process name string because it get separately freed
    // by DelItemFromList
    //
    // TODO: consider not allocating copies of szProcessName and szCallerUsername
    // and just set these member to NULL prior to calling DelItemFromList()
    //

    cbName = (lstrlenW(g_psDummyListItem->szProcessName) + 1) * sizeof(WCHAR);
    pliNew->szProcessName = (LPWSTR)SSAlloc(cbName);
    if(pliNew->szProcessName == NULL)
        goto cleanup;
    CopyMemory(pliNew->szProcessName, g_psDummyListItem->szProcessName, cbName);

    //
    // user name associated with caller.
    //

    cbName = (lstrlenW(pliCaller->szCallerUsername) + 1) * sizeof(WCHAR);
    pliNew->szCallerUsername = (LPWSTR)SSAlloc(cbName);
    if(pliNew->szCallerUsername == NULL)
        goto cleanup;
    CopyMemory(pliNew->szCallerUsername, pliCaller->szCallerUsername, cbName);


    //
    // build new PST_PROVIDER_HANDLE, which is really a CALL_CONTEXT in disguise
    //

    ZeroMemory( pNewContext, sizeof(CALL_STATE) );

    CopyMemory(&(pNewContext->hPSTProv), &(pliNew->hPSTProv), sizeof(PST_PROVIDER_HANDLE));
    pNewContext->hBinding = CallerContext->hBinding;

    //
    // pickup stuff from server context
    //

    pNewContext->hThread = pliNew->hThread;
    pNewContext->hProcess = pliNew->hProcess;
    pNewContext->dwProcessId = pliNew->dwProcessId;


    //
    // add to list
    //

    AddItemToList(pliNew);

    //
    // make sure ref count is raised - caller in PST_KEY_CURRENT_USER
    // case is responsible for decrementing when finished.
    //

    bSuccess = FAcquireProvider(&g_guidBaseProvider);

cleanup:

    if(!bSuccess && pliNew) {

        //
        // these should only be non-NULL if we allocated storage that
        // was not freed as a result of the call to DelItemFromList()
        //

        if(pliNew->szProcessName)
            SSFree(pliNew->szProcessName);

        if(pliNew->szCallerUsername)
            SSFree(pliNew->szCallerUsername);

        SSFree(pliNew);
    }

    return bSuccess;
}

BOOL
DeleteDummyUserContext(
    IN      CALL_STATE *pNewContext
    )
{
    PST_PROVIDER_HANDLE *phProv = (PST_PROVIDER_HANDLE *)pNewContext;

    DelItemFromList( phProv );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\svr\lnklist.cpp ===
#include <pch.cpp>
#pragma hdrstop

static DWORD            g_dwHandleListUseCount;
static PPROV_LIST_ITEM  g_pProvList = NULL;         // ptr to loaded providers


extern HANDLE hServerStopEvent;
extern DWORD g_dwLastHandleIssued;

// sacp.cpp
BOOL        InitMyProviderHandle();
void        UnInitMyProviderHandle();
PROV_LIST_ITEM  g_liProv = {0}; // global list item for base prov.


BOOL ListConstruct()
{
    // create internal provider handle

    if(!InitMyProviderHandle())
        return FALSE;


    return TRUE;
}

void ListTeardown()
{

    // free internal provider handle
    UnInitMyProviderHandle();

}


// internal: prov search by name
PPROV_LIST_ITEM SearchProvListByID(const PST_PROVIDERID* pProviderID)
{
    SS_ASSERT(pProviderID != NULL);

    static const GUID guidBaseProvider = MS_BASE_PSTPROVIDER_ID;

    if( memcmp( &guidBaseProvider, pProviderID, sizeof(guidBaseProvider) ) != 0 )
        return NULL;

    return &g_liProv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\svr\lnklist.h ===
#ifndef __LNKLIST_H__
#define __LNKLIST_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "pstypes.h"
#include "dispif.h"
#include "provif.h"
#include <sha.h>

// a structure with a bunch of funcs
typedef struct FuncList
{
    SPACQUIRECONTEXT*       SPAcquireContext;
    SPRELEASECONTEXT*       SPReleaseContext;
    SPGETPROVINFO*          SPGetProvInfo;
    SPGETTYPEINFO*          SPGetTypeInfo;
    SPGETSUBTYPEINFO*       SPGetSubtypeInfo;
    SPGETPROVPARAM*         SPGetProvParam;
    SPSETPROVPARAM*         SPSetProvParam;
    SPENUMTYPES*            SPEnumTypes;
    SPENUMSUBTYPES*         SPEnumSubtypes;
    SPENUMITEMS*            SPEnumItems;
    SPCREATETYPE*           SPCreateType;
    SPDELETETYPE*           SPDeleteType;
    SPCREATESUBTYPE*        SPCreateSubtype;
    SPDELETESUBTYPE*        SPDeleteSubtype;
    SPREADITEM*             SPReadItem;
    SPWRITEITEM*            SPWriteItem;
    SPOPENITEM*             SPOpenItem;
    SPCLOSEITEM*            SPCloseItem;
    SPDELETEITEM*           SPDeleteItem;
    SPWRITEACCESSRULESET*   SPWriteAccessRuleset;
    SPREADACCESSRULESET*    SPReadAccessRuleset;

    FPASSWORDCHANGENOTIFY*  FPasswordChangeNotify;

} FUNCLIST, *PFUNCLIST;


// provider list element
typedef struct _PROV_LISTITEM
{
    // set by creator before adding to list
    PST_PROVIDERINFO        sProviderInfo;

    HINSTANCE               hInst;
    FUNCLIST                fnList;

} PROV_LIST_ITEM, *PPROV_LIST_ITEM;

//
// milliseconds stale image cache elements live
//

#ifdef DBG
#define IMAGE_TTL (60*1000)     // 1 minute in debug
#else
#define IMAGE_TTL (60*1000*60)  // 60 minutes retail
#endif // DBG

typedef struct _NT_HASHED_PASSWORD {
    LUID LogonID;
    BYTE HashedPassword[A_SHA_DIGEST_LEN];
    DWORD dwLastAccess;
    struct _NT_HASHED_PASSWORD *Next;
} NT_HASHED_PASSWORD, *PNT_HASHED_PASSWORD, *LPNT_HASHED_PASSWORD;


// construct, destruct lists
BOOL ListConstruct();
void ListTeardown();


//////////////////////
// Item list

// search
PPROV_LIST_ITEM  SearchProvListByID(const PST_PROVIDERID* pProvID);

#ifdef __cplusplus
}
#endif

#endif // __LNKLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\svr\pch.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pch.cpp

Abstract:

    pch header files


Author:

    petesk 2/2/2000

Revision History:

    

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lm.h>
#include <rpc.h>
// crypto headers

#include <sha.h>
#include <des.h>

#include "pstypes.h"
#include "pstrpc.h"
#include "pstprv.h"
#include "pstdef.h"
#include "crtem.h"
#include "unicode.h"
#include "unicode5.h"

#include "secmisc.h"
#include "filemisc.h"
#include "primitiv.h"
#include "pmacros.h"
#include "debug.h"
#include "guidcnvt.h"



#include "acl.h"
#include "lnklist.h"
#include "winpw.h"
#include "module.h"
#include "resource.h"
#include "dispif.h"
#include "rules.h"


#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\svr\module.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    module.h

Abstract:

    This module contains routines to perform module related query activities
    in the protected store.

Author:

    Scott Field (sfield)    27-Nov-96

--*/

#ifndef __MODULE_H__
#define __MODULE_H__

#ifdef __cplusplus
extern "C" {
#endif


BOOL
GetProcessPath(
    IN      HANDLE hProcess,
    IN      DWORD dwProcessId,
    IN      LPWSTR ProcessName,
    IN  OUT DWORD *cchProcessName,
    IN  OUT DWORD_PTR *lpdwBaseAddress
    );

BOOL
EnumRemoteProcessModules(
    IN  HANDLE hProcess,
    IN  DWORD dwProcessId,
    OUT DWORD_PTR *lpdwBaseAddrClient
    );

BOOL
GetFileNameFromBaseAddr(
    IN  HANDLE  hProcess,
    IN  DWORD   dwProcessId,
    IN  DWORD_PTR   dwBaseAddr,
    OUT LPWSTR  *lpszDirectCaller
    );

#ifdef WIN95_LEGACY

BOOL
GetProcessIdFromPath95(
    IN      LPCSTR  szProcessPath,
    IN OUT  DWORD   *dwProcessId
    );

BOOL
GetBaseAddressModule95(
    IN      DWORD   dwProcessId,
    IN      LPCSTR  szImagePath,
    IN  OUT DWORD_PTR   *dwBaseAddress,
    IN  OUT DWORD   *dwUseCount
    );

#endif  // WIN95_LEGACY

#ifdef __cplusplus
}
#endif


#endif // __MODULE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\svr\sacp.cpp ===
#include <pch.cpp>
#pragma hdrstop

BOOL
InitCallState(
    CALL_STATE *CallState,              // result call state
    PST_CALL_CONTEXT *CallerContext,    // client caller context
    handle_t h                          // binding handle
    );

BOOL
FAcquireProvider(
    const PST_PROVIDERID*  pProviderID
    );


extern HANDLE hServerStopEvent;
extern PROV_LIST_ITEM g_liProv;
BOOL g_fBaseInitialized = FALSE;

static LPCWSTR g_szBaseDLL = L"psbase.dll";
const PST_PROVIDERID g_guidBaseProvider = MS_BASE_PSTPROVIDER_ID;

DWORD g_dwLastHandleIssued = 0;

BOOL InitMyProviderHandle()
{
    // load the base provider!
    return FAcquireProvider(&g_guidBaseProvider);
}

void UnInitMyProviderHandle()
{
    PROV_LIST_ITEM *pliProv = &g_liProv;

    if (pliProv->hInst)
        FreeLibrary(pliProv->hInst);

    if (pliProv->sProviderInfo.szProviderName)
        SSFree(pliProv->sProviderInfo.szProviderName);

    ZeroMemory(pliProv, sizeof(PROV_LIST_ITEM));
    g_fBaseInitialized = FALSE;

}



BOOL FAcquireProvider(
    const PST_PROVIDERID*  pProviderID
    )
{
    PPROV_LIST_ITEM pliProv = &g_liProv;

    WCHAR szFullPath[ 256 ];
    DWORD cchFullPath = sizeof(szFullPath) / sizeof(WCHAR);
    HANDLE hFile;

    SS_ASSERT(pProviderID);

    if (0 != memcmp(pProviderID, &g_guidBaseProvider, sizeof(PST_PROVIDERID))) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if( g_fBaseInitialized )
        return TRUE;

    if(!FindAndOpenFile( g_szBaseDLL, szFullPath, cchFullPath, &hFile ))
        return FALSE;

    CloseHandle( hFile );

    pliProv->hInst = LoadLibraryU( szFullPath );

    if(pliProv->hInst == NULL)
        goto Ret;

    // everything loaded correctly

    // init callbacks
    {
        SPPROVIDERINITIALIZE* pfnProvInit;
        if (NULL == (pfnProvInit = (SPPROVIDERINITIALIZE*) GetProcAddress(pliProv->hInst, "SPProviderInitialize")))
            goto Ret;

        DISPIF_CALLBACKS sCallbacks;

        sCallbacks.cbSize = sizeof(DISPIF_CALLBACKS);

        sCallbacks.pfnFIsACLSatisfied = FIsACLSatisfied;

        sCallbacks.pfnFGetUser = FGetUser;
        sCallbacks.pfnFGetCallerName = FGetCallerName;

        sCallbacks.pfnFImpersonateClient = FImpersonateClient;
        sCallbacks.pfnFRevertToSelf = FRevertToSelf;

        sCallbacks.pfnFGetServerParam = FGetServerParam;
        sCallbacks.pfnFSetServerParam = FSetServerParam;

        // register the callbacks I expose
        if (PST_E_OK != pfnProvInit( &sCallbacks ))
            goto Ret;
    }

    // everything okay - load list element pfns
    if (NULL == (pliProv->fnList.SPAcquireContext   = (SPACQUIRECONTEXT*)  GetProcAddress(pliProv->hInst, "SPAcquireContext")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPReleaseContext   = (SPRELEASECONTEXT*)  GetProcAddress(pliProv->hInst, "SPReleaseContext")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPGetProvInfo   = (SPGETPROVINFO*)  GetProcAddress(pliProv->hInst, "SPGetProvInfo")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPGetTypeInfo   = (SPGETTYPEINFO*)  GetProcAddress(pliProv->hInst, "SPGetTypeInfo")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPGetSubtypeInfo   = (SPGETSUBTYPEINFO*)  GetProcAddress(pliProv->hInst, "SPGetSubtypeInfo")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPGetProvParam   = (SPGETPROVPARAM*)  GetProcAddress(pliProv->hInst, "SPGetProvParam")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPSetProvParam   = (SPSETPROVPARAM*)  GetProcAddress(pliProv->hInst, "SPSetProvParam")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPEnumTypes     = (SPENUMTYPES*)    GetProcAddress(pliProv->hInst, "SPEnumTypes")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPEnumSubtypes  = (SPENUMSUBTYPES*)    GetProcAddress(pliProv->hInst, "SPEnumSubtypes")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPEnumItems     = (SPENUMITEMS*)    GetProcAddress(pliProv->hInst, "SPEnumItems")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPCreateType    = (SPCREATETYPE*)   GetProcAddress(pliProv->hInst, "SPCreateType")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPDeleteType   = (SPDELETETYPE*)  GetProcAddress(pliProv->hInst, "SPDeleteType")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPCreateSubtype = (SPCREATESUBTYPE*)   GetProcAddress(pliProv->hInst, "SPCreateSubtype")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPDeleteSubtype = (SPDELETESUBTYPE*)  GetProcAddress(pliProv->hInst, "SPDeleteSubtype")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPDeleteItem    = (SPDELETEITEM*)   GetProcAddress(pliProv->hInst, "SPDeleteItem")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPReadItem      = (SPREADITEM*)     GetProcAddress(pliProv->hInst, "SPReadItem")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPWriteItem     = (SPWRITEITEM*)    GetProcAddress(pliProv->hInst, "SPWriteItem")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPOpenItem      = (SPOPENITEM*)     GetProcAddress(pliProv->hInst, "SPOpenItem")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPCloseItem     = (SPCLOSEITEM*)    GetProcAddress(pliProv->hInst, "SPCloseItem")))
        goto Ret;

    // side door interface
    if (NULL == (pliProv->fnList.FPasswordChangeNotify = (FPASSWORDCHANGENOTIFY*)GetProcAddress(pliProv->hInst, "FPasswordChangeNotify")))
        goto Ret;

    // fill in the provider info
    {
        PPST_PROVIDERINFO pReportedProviderInfo;

        if (RPC_S_OK !=
            pliProv->fnList.SPGetProvInfo(
                &pReportedProviderInfo,
                0))
            goto Ret;

        // They better report the friendly name they're registered as having
        if (0 != memcmp(&pReportedProviderInfo->ID, pProviderID, sizeof(PST_PROVIDERID)))
            goto Ret;

        CopyMemory(&pliProv->sProviderInfo, pReportedProviderInfo, sizeof(PST_PROVIDERINFO));

        // don't free the indirections -- pliProv->sProviderInfo owns them
        SSFree(pReportedProviderInfo);
    }

    g_fBaseInitialized = TRUE;

Ret:

    return g_fBaseInitialized;
}


/////////////////////////////////////////////////////////////////////////
// Dispatcher-only routines

HRESULT s_SSPStoreEnumProviders(
    /* [in] */ handle_t         h,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [out] */ PPST_PROVIDERINFO*   ppPSTInfo,
    /* [in] */ DWORD            dwIndex,
    /* [in] */ DWORD            dwFlags)
{
    HRESULT hr;
    PST_PROVIDERID ProvID;

    __try
    {
        PPROV_LIST_ITEM pli;

        if (dwIndex != 0)
        {
            hr = ERROR_NO_MORE_ITEMS;
            goto Ret;
        }
        else
        {
            // base provider is index 0; not in list
            CopyMemory(&ProvID, &g_guidBaseProvider, sizeof(PST_PROVIDERID));
        }

        // now we have the Provider ID
        *ppPSTInfo = (PST_PROVIDERINFO*)SSAlloc(sizeof(PST_PROVIDERINFO));
        if( *ppPSTInfo == NULL ) {
            hr = E_OUTOFMEMORY;
            goto Ret;
        }

        ZeroMemory(*ppPSTInfo, sizeof(PST_PROVIDERINFO));

        // retrieve from list
        if (NULL == (pli = SearchProvListByID(&ProvID)))
        {
            hr = PST_E_PROV_DLL_NOT_FOUND;
            goto RefuseLoad;
        }

        // copy direct members
        CopyMemory(*ppPSTInfo, &pli->sProviderInfo, sizeof(PST_PROVIDERINFO));

        // copy indirects
        (*ppPSTInfo)->szProviderName = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(pli->sProviderInfo.szProviderName));

        if( (*ppPSTInfo)->szProviderName == NULL ) {
            hr = E_OUTOFMEMORY;
            goto Ret;
        }

        wcscpy((*ppPSTInfo)->szProviderName, pli->sProviderInfo.szProviderName);

        hr = PST_E_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = GetExceptionCode();
    }

Ret:

    if(hr != PST_E_OK)
    {
        if( *ppPSTInfo ) {

            if( (*ppPSTInfo)->szProviderName )
                SSFree( (*ppPSTInfo)->szProviderName );

            SSFree( *ppPSTInfo );
            *ppPSTInfo = NULL;
        }
    }

    return hr;


RefuseLoad:
    // copy dummy provider info
    (*ppPSTInfo)->cbSize = sizeof(PST_PROVIDERINFO);
    CopyMemory(&(*ppPSTInfo)->ID, &ProvID, sizeof(GUID));

    // notify that we couldn't touch this provider (in a graceful way)
    (*ppPSTInfo)->Capabilities = PST_PC_NOT_AVAILABLE;

    // eat error code here -- they can see it during acquire ctxt if they want
    return PST_E_OK;
}

BOOL
AllocatePseudoUniqueHandle(
    PST_PROVIDER_HANDLE *phPSTProv
    )
/*++

    This is here because:
    AllocateLocallyUniqueId() is not present on Win95.
    UuidCreate() requires too much baggage and memory to store handle.

--*/
{
    static LONG HighPart;


    //
    // GetTickCount() yields ~49 days of unique handles
    //

    phPSTProv->LowPart = GetTickCount(); // sneaky, huh?

    //
    // interlocked increment thread-safe insurance of no collision at same time
    // ~4 billion values
    //

    phPSTProv->HighPart = InterlockedIncrement(&HighPart);

    //
    // after ~49 days, we may collide with old handles
    // this is here just to be correct, but slim likelihood of no reboot
    // within 49 days on most machines.
    //

    //
    // update time of last handle issue.
    //

    g_dwLastHandleIssued = GetTickCount();

    return TRUE;
}


BOOL
InitCallState(
    CALL_STATE *CallState,              // result call state
    PST_CALL_CONTEXT *CallerContext,    // client caller context
    handle_t h                          // binding handle
    )
{
    HANDLE hThread;
    DWORD dwProcessId;
    BOOL bSuccess = FALSE;

    if(CallerContext == NULL)
        return FALSE;

    ZeroMemory( CallState, sizeof(CALL_STATE) );

    CallState->hBinding = h;
    CallState->dwProcessId = CallerContext->Address;
    CallState->hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, CallState->dwProcessId );
    if( CallState->hProcess == NULL )
        return FALSE;

    if(DuplicateHandle(
                CallState->hProcess,
                (HANDLE)CallerContext->Handle, // source handle
                GetCurrentProcess(),
                &hThread,
                THREAD_ALL_ACCESS, // tone down later
                FALSE,
                0)) {

        CallState->hThread = hThread;
        bSuccess = TRUE;
    }

    if(!bSuccess) {
        if( CallState->hProcess )
            CloseHandle( CallState->hProcess );
    }

    return bSuccess;
}

BOOL
DeleteCallState(
    CALL_STATE *CallState
    )
{
    BOOL bSuccess;

    __try {

        if(CallState->hThread != NULL)
            CloseHandle(CallState->hThread);
        if(CallState->hProcess)
            CloseHandle(CallState->hProcess);

        memset(CallState, 0, sizeof(CALL_STATE));

        bSuccess = TRUE;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        bSuccess = FALSE;
    }

    return bSuccess;
}

HRESULT s_SSAcquireContext(
    /* [in] */ handle_t         h,
    /* [in] */ PPST_PROVIDERID  pProviderID,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ DWORD            pidCaller,
    /* [out] */ PST_PROVIDER_HANDLE* phPSTProv,
    /* [in] */ DWORD_PTR        lpReserved,
    /* [in] */ DWORD            dwFlags)
{
    PPROV_LIST_ITEM pliProv;
    CALL_STATE CallState;
    BOOL bDelItemFromList = FALSE; // free list item on failure?
    BOOL bCallState = FALSE;
    HRESULT hr = PST_E_FAIL;

    //
    // lpReserved must currently be NULL.
    //

    if(lpReserved != 0)
        return ERROR_INVALID_PARAMETER;

    __try
    {
        if(!AllocatePseudoUniqueHandle(phPSTProv))
            return PST_E_FAIL;

        bCallState = InitCallState(&CallState, &CallerContext, h);

        if(!bCallState) {
            hr = PST_E_INVALID_HANDLE;
            goto cleanup;
        }

        // now allow SPAcquireContext to be called: look up interface
        // (call state already initialized)
        if (NULL == (pliProv = SearchProvListByID(pProviderID)))
        {
            hr = PST_E_INVALID_HANDLE;
            goto cleanup;
        }

        hr = pliProv->fnList.SPAcquireContext(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            dwFlags);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

cleanup:

    if(bCallState)
        DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSReleaseContext(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ DWORD            dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPReleaseContext(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            dwFlags);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

// interface to communicate passwords from external sources
// such as credential managers.
// this is a currently a private interface and is likely to stay that way

HRESULT s_SSPasswordInterface(
    /* [in] */                      handle_t    h,
    /* [in] */                      DWORD       dwParam,
    /* [in] */                      DWORD       cbData,
    /* [in][size_is(cbData)] */     BYTE*       pbData)
{
    __try {
        PLUID pLogonID;
        PBYTE pHashedUsername;
        PBYTE pHashedPassword;

        switch(dwParam) {

        case PASSWORD_LOGON_NT:
        {
            if(cbData == A_SHA_DIGEST_LEN + sizeof(LUID)) {

                pLogonID = (PLUID)pbData;
                pHashedPassword = (PBYTE)pbData + sizeof(LUID);

                SetPasswordNT(pLogonID, pHashedPassword);

                return PST_E_OK;
            }
        }

#ifdef WIN95_LEGACY

        //
        // legacy case-sensitive password material for Win95
        //

        case PASSWORD_LOGON_LEGACY_95:
        {
            if(cbData == A_SHA_DIGEST_LEN + A_SHA_DIGEST_LEN) {

                // for legacy logon notification, just flush Win95 password.
                SetPassword95(NULL, NULL);
                return PST_E_OK;
            }
        }

        //
        // case-insensitive password material for Win95
        //

        case PASSWORD_LOGON_95:
        {
            if(cbData == A_SHA_DIGEST_LEN + A_SHA_DIGEST_LEN) {
                pHashedUsername = pbData;
                pHashedPassword = pbData + A_SHA_DIGEST_LEN;

                SetPassword95(pHashedUsername, pHashedPassword);
                return PST_E_OK;
            }
        }

        case PASSWORD_LOGOFF_95:
        {
            HRESULT hr = ERROR_INVALID_PARAMETER;

            //
            // scrub existing password material on logoff
            //

            if(cbData == 0) {
                SetPassword95(NULL, NULL);
                hr = PST_E_OK;
            }

            //
            // shutdown server (us) at logoff on Win95.
            //

            PulseEvent(hServerStopEvent);

            return hr;
        }

#endif  // WIN95_LEGACY

        default:
            return ERROR_INVALID_PARAMETER;

        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        return PST_E_UNKNOWN_EXCEPTION;
    }
}



/////////////////////////////////////////////////////////////////////////
// Wrapper functions destined for provider

HRESULT s_SSGetProvInfo(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [out] */ PPST_PROVIDERINFO*   ppPSTInfo,
    /* [in] */ DWORD            dwFlags)
{
    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        return (pliProv->fnList.SPGetProvInfo(
                            ppPSTInfo,
                            dwFlags));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        return PST_E_UNKNOWN_EXCEPTION;
    }
}

HRESULT     s_SSGetTypeInfo(
    /* [in] */ handle_t        h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY         Key,
    /* [in] */ const GUID*     pguidType,
    /* [in] */ PPST_TYPEINFO   *ppinfoType,
    /* [in] */ DWORD           dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPGetTypeInfo(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            ppinfoType,
                            dwFlags);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT     s_SSGetSubtypeInfo(
    /* [in] */ handle_t        h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY         Key,
    /* [in] */ const GUID*     pguidType,
    /* [in] */ const GUID*     pguidSubtype,
    /* [in] */ PPST_TYPEINFO   *ppinfoSubtype,
    /* [in] */ DWORD           dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPGetSubtypeInfo(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            ppinfoSubtype,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT     s_SSGetProvParam(
    /* [in] */  handle_t        h,
    /* [in] */  PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */  PST_CALL_CONTEXT CallerContext,
    /* [in] */  DWORD           dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */
                BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */  DWORD           dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPGetProvParam(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            dwParam,
                            pcbData,
                            ppbData,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT     s_SSSetProvParam(
    /* [in] */  handle_t        h,
    /* [in] */  PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */  PST_CALL_CONTEXT CallerContext,
    /* [in] */  DWORD           dwParam,
    /* [in] */  DWORD           cbData,
    /* [in] */  BYTE*           pbData,
    /* [in] */  DWORD           dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPSetProvParam(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            dwParam,
                            cbData,
                            pbData,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}


HRESULT s_SSEnumTypes(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [out] */GUID*            pguidType,
    /* [in] */ DWORD            dwIndex,
    /* [in] */ DWORD            dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPEnumTypes(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            dwIndex,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSEnumSubtypes(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [out] */ GUID __RPC_FAR *pguidSubtype,
    /* [in] */ DWORD            dwIndex,
    /* [in] */ DWORD            dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPEnumSubtypes(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            dwIndex,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSEnumItems(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [out] */ LPWSTR __RPC_FAR *ppszItemName,
    /* [in] */ DWORD            dwIndex,
    /* [in] */ DWORD            dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPEnumItems(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            ppszItemName,
                            dwIndex,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSCreateType(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID*      pguidType,
    /* [in] */ PPST_TYPEINFO    pinfoType,
    /* [in] */ DWORD            dwFlags)
{
    PPROV_LIST_ITEM pliProv;
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPCreateType(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pinfoType,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSCreateSubtype(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID*      pguidType,
    /* [in] */ const GUID*      pguidSubtype,
    /* [in] */ PPST_TYPEINFO    pinfoSubtype,
    /* [in] */ PPST_ACCESSRULESET psRules,
    /* [in] */ DWORD            dwFlags)
{
    PPROV_LIST_ITEM pliProv;
    CALL_STATE CallState;
    HRESULT hr;

    __try
     {
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPCreateSubtype(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            pinfoSubtype,
                            psRules,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT     s_SSDeleteType(
    /* [in] */  handle_t        h,
    /* [in] */  PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */  PST_CALL_CONTEXT CallerContext,
    /* [in] */  PST_KEY         Key,
    /* [in] */  const GUID*     pguidType,
    /* [in] */  DWORD           dwFlags)
{
    PPROV_LIST_ITEM pliProv;
    PPST_TYPEINFO   ppinfoType = NULL;
    CALL_STATE      CallState;
    HRESULT         hr;
    HRESULT         hrTypeInfo = E_FAIL;

    __try
    {
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPDeleteType(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT     s_SSDeleteSubtype(
    /* [in] */  handle_t        h,
    /* [in] */  PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */  PST_CALL_CONTEXT CallerContext,
    /* [in] */  PST_KEY         Key,
    /* [in] */  const GUID*     pguidType,
    /* [in] */  const GUID*     pguidSubtype,
    /* [in] */  DWORD           dwFlags)
{
    PPROV_LIST_ITEM pliProv;
    PPST_TYPEINFO   ppinfoSubtype = NULL;
    CALL_STATE      CallState;
    HRESULT         hr;
    HRESULT         hrSubtypeInfo = E_FAIL;

    __try
    {
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPDeleteSubtype(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSDeleteItem(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [in] */ LPCWSTR          szItemName,
    /* [in] */ PPST_PROMPTINFO  psPrompt,
    /* [in] */ DWORD            dwFlags)
{
    PPROV_LIST_ITEM pliProv;
    PPST_TYPEINFO   ppinfoType = NULL;
    PPST_TYPEINFO   ppinfoSubtype = NULL;
    CALL_STATE CallState;
    HRESULT hr;
    HRESULT         hrTypeInfo = E_FAIL;
    HRESULT         hrSubtypeInfo = E_FAIL;

    __try
    {
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPDeleteItem(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            szItemName,
                            psPrompt,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSReadItem(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [in] */ LPCWSTR          szItemName,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ PPST_PROMPTINFO  psPrompt,
    /* [in] */ DWORD            dwFlags)
{
    PPROV_LIST_ITEM pliProv;
    PPST_TYPEINFO   ppinfoType = NULL;
    PPST_TYPEINFO   ppinfoSubtype = NULL;
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPReadItem(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            szItemName,
                            pcbData,
                            ppbData,
                            psPrompt,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSWriteItem(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [in] */ LPCWSTR          szItemName,
    /* [in] */ DWORD            cbData,
    /* [size_is][in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ PPST_PROMPTINFO  psPrompt,
    /* [in] */ DWORD            dwDefaultConfirmationStyle,
    /* [in] */ DWORD            dwFlags)
{
    PPST_TYPEINFO   ppinfoType = NULL;
    PPST_TYPEINFO   ppinfoSubtype = NULL;
    PPROV_LIST_ITEM pliProv;
    CALL_STATE      CallState;
    HRESULT         hr;

    __try
    {
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPWriteItem(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            szItemName,
                            cbData,
                            pbData,
                            psPrompt,
                            dwDefaultConfirmationStyle,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}


HRESULT s_SSReadAccessRuleset(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [out] */ PPST_ACCESSRULESET *ppsRules,
    /* [in] */ DWORD            dwFlags)
{
    return ERROR_NOT_SUPPORTED;
}

HRESULT s_SSWriteAccessRuleset(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [in] */ PPST_ACCESSRULESET psRules,
    /* [in] */ DWORD            dwFlags)
{
    return ERROR_NOT_SUPPORTED;
}

HRESULT s_SSOpenItem(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [in] */ LPCWSTR          szItemName,
    /* [in] */ PST_ACCESSMODE   ModeFlags,
    /* [in] */ PPST_PROMPTINFO  psPrompt,
    /* [in] */ DWORD            dwFlags)
{
    PPST_TYPEINFO   ppinfoType = NULL;
    PPST_TYPEINFO   ppinfoSubtype = NULL;
    PPROV_LIST_ITEM pliProv;
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPOpenItem(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            szItemName,
                            ModeFlags,
                            psPrompt,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSCloseItem(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [in] */ LPCWSTR          szItemName,
    /* [in] */ DWORD            dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPCloseItem(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            szItemName,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\svr\module.c ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    module.c

Abstract:

    This module contains routines to perform module related query activities
    in the protected store.

Author:

    Scott Field (sfield)    27-Nov-96

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <tlhelp32.h>

#include "module.h"
#include "filemisc.h"

#include "unicode.h"
#include "debug.h"

#include "pstypes.h"
#include "pstprv.h"


//
// common function typedefs + pointers
//

typedef BOOL (WINAPI *SYMLOADMODULE)(
    IN HANDLE hProcess,
    IN HANDLE hFile,
    IN LPSTR ImageName,
    IN LPSTR ModuleName,
    IN DWORD_PTR BaseOfDll,
    IN DWORD SizeOfDll
    );

SYMLOADMODULE _SymLoadModule                    = NULL;

//
// winnt specific function typedefs + pointers
//

typedef NTSTATUS (NTAPI *NTQUERYPROCESS)(
    HANDLE ProcessHandle,
    PROCESSINFOCLASS ProcessInformationClass,
    PVOID ProcessInformation,
    ULONG ProcessInformationLength,
    PULONG ReturnLength OPTIONAL
    );


#ifdef WIN95_LEGACY

//
// win95 specific function typedefs + pointers.
//

typedef BOOL (WINAPI *MODULEWALK)(
    HANDLE hSnapshot,
    LPMODULEENTRY32 lpme
    );

typedef BOOL (WINAPI *THREADWALK)(
    HANDLE hSnapshot,
    LPTHREADENTRY32 lpte
    );

typedef BOOL (WINAPI *PROCESSWALK)(
    HANDLE hSnapshot,
    LPPROCESSENTRY32 lppe
    );

typedef HANDLE (WINAPI *CREATESNAPSHOT)(
    DWORD dwFlags,
    DWORD th32ProcessID
    );

CREATESNAPSHOT pCreateToolhelp32Snapshot = NULL;
MODULEWALK  pModule32First = NULL;
MODULEWALK  pModule32Next = NULL;
PROCESSWALK pProcess32First = NULL;
PROCESSWALK pProcess32Next = NULL;

#endif  // WIN95_LEGACY

extern FARPROC _ImageNtHeader;


//
// private function prototypes
//

VOID
FixupBrokenLoaderPath(
    IN      LPWSTR szFilePath
    );

BOOL
GetProcessPathNT(
    IN      HANDLE hProcess,
    OUT     LPWSTR ProcessName,
    IN  OUT DWORD *cchProcessName,
    IN OUT  DWORD_PTR *lpdwBaseAddress,
    IN OUT  DWORD *lpdwUseCount
    );

BOOL
EnumRemoteProcessModulesNT(
    IN  HANDLE hProcess,
    IN  DWORD dwProcessId,
    OUT DWORD_PTR *lpdwBaseAddrClient
    );

BOOL
GetFileNameFromBaseAddrNT(
    IN  HANDLE  hProcess,
    IN  DWORD   dwProcessId,
    IN  DWORD_PTR   dwBaseAddr,
    OUT LPWSTR  *lpszDirectCaller
    );


#ifdef WIN95_LEGACY

BOOL
GetProcessPath95(
    IN      DWORD dwProcessId,
    OUT     LPWSTR ProcessName,
    IN OUT  DWORD *cchProcessName,
    IN OUT  DWORD_PTR *lpdwBaseAddress,
    IN OUT  DWORD *lpdwUseCount
    );

BOOL
EnumRemoteProcessModules95(
    IN  HANDLE hProcess,
    IN  DWORD dwProcessId,
    OUT DWORD_PTR *lpdwBaseAddrClient
    );

BOOL
GetFileNameFromBaseAddr95(
    IN  HANDLE  hProcess,
    IN  DWORD   dwProcessId,
    IN  DWORD_PTR   dwBaseAddr,
    OUT LPWSTR  *lpszDirectCaller
    );

#endif  // WIN95_LEGACY

VOID
FixupBrokenLoaderPath(
    IN      LPWSTR szFilePath
    )
{
    if( !FIsWinNT() || szFilePath == NULL )
        return;


    //
    // sfield, 28-Oct-97 (NTbug 118803 filed against MarkL)
    // for WinNT, the loader data structures are broken:
    // a path len extension prefix of \??\ is used instead of \\?\
    //

    if( szFilePath[0] == L'\\' &&
        szFilePath[1] == L'?' &&
        szFilePath[2] == L'?' &&
        szFilePath[3] == L'\\' ) {

        szFilePath[1] = L'\\';

    }

}


BOOL
GetProcessPath(
    IN      HANDLE hProcess,
    IN      DWORD dwProcessId,
    IN      LPWSTR ProcessName,
    IN  OUT DWORD *cchProcessName,
    IN  OUT DWORD_PTR *lpdwBaseAddress
    )
/*++

    This routine obtains the full path name associated with the process
    specified by the hProcess or dwProcessId parameters.

    For WinNT, hProcess is utilized, and dwProcessId is ignored.
    For Win95, hProcess is ignored, and dwProcessId is utilized.

    If the return value is FALSE, and GetLastError() indicated
    ERROR_INSUFFICIENT_BUFFER, the cchProcessName parameter will indicate
    how many characters must be allocated for the call to succeed.
    The advisory input buffer length is MAX_PATH characters.  Note that on
    Win95, this should never be exceeded.  On WinNT, it is possible for this
    to be exceeded, but quite unlikely (via the \\?\ prefix).

--*/
{
    DWORD_PTR dwBaseAddress;
    DWORD dwUseCount;
    DWORD dwPrefLoadAddr;
    BOOL fSuccess = FALSE;

    if(FIsWinNT()) {
        fSuccess = GetProcessPathNT(
                        hProcess,
                        ProcessName,
                        cchProcessName,
                        &dwBaseAddress,
                        &dwUseCount
                        );
    }
#ifdef WIN95_LEGACY
    else {
        fSuccess = GetProcessPath95(
                        dwProcessId,
                        ProcessName,
                        cchProcessName,
                        &dwBaseAddress,
                        &dwUseCount
                        );
    }
#endif  // WIN95_LEGACY

    if(!fSuccess)
        return FALSE;


    *lpdwBaseAddress = dwBaseAddress;

    return TRUE;
}


BOOL
GetProcessPathNT(
    IN      HANDLE hProcess,
    OUT     LPWSTR ProcessName,
    IN OUT  DWORD *cchProcessName,
    IN OUT  DWORD_PTR *lpdwBaseAddress,
    IN OUT  DWORD *lpdwUseCount
    )
{
    PROCESS_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;
    PPEB Peb;
    HMODULE hModule;
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        return FALSE;
    }

    Peb = BasicInfo.PebBaseAddress;

    //
    // base address of process
    //

    if(!ReadProcessMemory(hProcess, &Peb->ImageBaseAddress, &hModule, sizeof(hModule), NULL))
        return FALSE;

    //
    // Ldr = Peb->Ldr
    //

    if(!ReadProcessMemory(hProcess, &Peb->Ldr, &Ldr, sizeof(Ldr), NULL))
        return FALSE;

    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    if(!ReadProcessMemory(hProcess, &LdrHead->Flink, &LdrNext, sizeof(LdrNext), NULL))
        return FALSE;

    while (LdrNext != LdrHead) {
        PLDR_DATA_TABLE_ENTRY LdrEntry;
        LDR_DATA_TABLE_ENTRY LdrEntryData;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if(!ReadProcessMemory(hProcess, LdrEntry, &LdrEntryData, sizeof(LdrEntryData), NULL))
            return FALSE;

        if ((HMODULE) LdrEntryData.DllBase == hModule) {
            DWORD cb;

            cb = LdrEntryData.FullDllName.MaximumLength;

            if(cb > (*cchProcessName * sizeof(WCHAR)) ) {
                *cchProcessName = cb / sizeof(WCHAR);
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return FALSE;
            }

            if(!ReadProcessMemory(hProcess, LdrEntryData.FullDllName.Buffer, ProcessName, cb, NULL))
                return FALSE;

            FixupBrokenLoaderPath(ProcessName);

            *cchProcessName = cb / sizeof(WCHAR);
            *lpdwBaseAddress = (DWORD_PTR)(LdrEntryData.DllBase);
            *lpdwUseCount = (DWORD)(LdrEntryData.LoadCount);

            return TRUE;
        }

        LdrNext = LdrEntryData.InMemoryOrderLinks.Flink;
    } // while

    return FALSE; // module not found
}

#ifdef WIN95_LEGACY

BOOL
GetProcessPath95(
    IN      DWORD dwProcessId,
    OUT     LPWSTR ProcessName,
    IN OUT  DWORD *cchProcessName,
    IN OUT  DWORD_PTR *lpdwBaseAddress,
    IN OUT  DWORD *lpdwUseCount
    )
{
    HANDLE hSnapshot;
    PROCESSENTRY32 pe32;
    DWORD dwLastError = 0;
    BOOL bSuccess;
    BOOL bFound = FALSE; // assume no match found

    hSnapshot = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hSnapshot == INVALID_HANDLE_VALUE)
        return FALSE;

    pe32.dwSize = sizeof(pe32);

    bSuccess = pProcess32First(hSnapshot, &pe32);

    while(bSuccess) {

        if(pe32.th32ProcessID == dwProcessId) {

            DWORD cchProcessLen = lstrlenA(pe32.szExeFile) + 1;
            DWORD cchCopied;

            if(cchProcessLen > *cchProcessName) {
                dwLastError = ERROR_INSUFFICIENT_BUFFER;
                *cchProcessName = cchProcessLen;

                break;
            }

            //
            // convert ANSI buffer to Unicode
            //

            cchCopied = MultiByteToWideChar(
                CP_ACP,
                0,
                pe32.szExeFile,
                cchProcessLen,
                ProcessName,
                *cchProcessName
                );

            if(cchCopied == 0) {
                dwLastError = GetLastError();
                break;
            }

            *cchProcessName = cchCopied;

            //
            // get module base address and use count associated with this image.
            //

            bFound = GetBaseAddressModule95(
                dwProcessId,
                pe32.szExeFile,
                lpdwBaseAddress,
                lpdwUseCount
                );

            break;
        }

        pe32.dwSize = sizeof(pe32);
        bSuccess = pProcess32Next(hSnapshot, &pe32);
    }

    CloseHandle(hSnapshot);

    if(!bFound && dwLastError) {
        SetLastError(dwLastError);
    }

    return bFound;
}

#endif  // WIN95_LEGACY


BOOL
EnumRemoteProcessModules(
    IN  HANDLE hProcess,
    IN  DWORD dwProcessId,
    OUT DWORD_PTR *lpdwBaseAddrClient
    )
{
    if(FIsWinNT()) {
        return EnumRemoteProcessModulesNT( hProcess, dwProcessId, lpdwBaseAddrClient );
    }
#ifdef WIN95_LEGACY
    else {
        return EnumRemoteProcessModules95( hProcess, dwProcessId, lpdwBaseAddrClient );
    }
#endif  // WIN95_LEGACY

    return FALSE;
}


#ifdef WIN95_LEGACY

BOOL
EnumRemoteProcessModules95(
    IN  HANDLE hProcess,
    IN  DWORD dwProcessId,
    OUT DWORD_PTR *lpdwBaseAddrClient
    )
/*++

    This routine examines a process in order to derive the full path names
    of modules loaded into that process.  This approach queries information
    derived from the system.

    While evaluating the process, each image that is encountered will be
    loaded into the imagehlp debugging API list of loaded images.  This is
    later used by the StackWalk() API for the basis of determining the call
    stack of a remote thread.

    This technique also works well to defeat code injection at arbitrary
    addresses because the piece of code injected (via WriteProcessMemory)
    was not loaded by the system loader, and will not evaluate sucessfully
    during StackWalk().

--*/
{
    HANDLE hSnapshot;
    MODULEENTRY32 me32;
    DWORD dwModuleCount;
    BOOL bSuccess;

    hSnapshot = pCreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwProcessId);
    if(hSnapshot == INVALID_HANDLE_VALUE)
        return FALSE;

    me32.dwSize = sizeof(me32);
    dwModuleCount = 0;

    bSuccess = pModule32First(hSnapshot, &me32);

    while(bSuccess) {

        if(!_SymLoadModule(
                hProcess,
                NULL,
                me32.szExePath,
                NULL,
                (DWORD_PTR)me32.modBaseAddr,
                me32.modBaseSize)) {

            dwModuleCount = 0;
            bSuccess = FALSE;
            break;
        }

        dwModuleCount++;

        me32.dwSize = sizeof(me32);
        bSuccess = pModule32Next(hSnapshot, &me32);
    }

    if(dwModuleCount && GetLastError() == ERROR_NO_MORE_FILES)
        bSuccess = TRUE;

    CloseHandle(hSnapshot);

    return bSuccess;
}

#endif  // WIN95_LEGACY

BOOL
EnumRemoteProcessModulesNT(
    IN  HANDLE hProcess,
    IN  DWORD dwProcessId,
    OUT DWORD_PTR *lpdwBaseAddrClient
    )
/*++

    This routine examines a process in order to derive the full path names
    of modules loaded into that process.  This approach queries loader data
    structures, which allows for increased security over other approaches
    (eg. querying HKEY_PERFORMANCE_DATA), in addition to providing good
    performance characteristics.

    While evaluating the process, each image that is encountered will be
    loaded into the imagehlp debugging API list of loaded images.  This is
    later used by the StackWalk() API for the basis of determining the call
    stack of a remote thread.

    This technique also works well to defeat code injection at arbitrary
    addresses because the piece of code injected (via WriteProcessMemory)
    was not loaded by the system loader, and will not evaluate sucessfully
    during StackWalk().

--*/
{
    PROCESS_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;
    PPEB Peb;
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;
    DWORD dwModuleIndex = 0;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        return FALSE;
    }

    Peb = BasicInfo.PebBaseAddress;

    //
    // Ldr = Peb->Ldr
    //

    if(!ReadProcessMemory(hProcess, &Peb->Ldr, &Ldr, sizeof(Ldr), NULL))
        return FALSE;

    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    if(!ReadProcessMemory(hProcess, &LdrHead->Flink, &LdrNext, sizeof(LdrNext), NULL))
        return FALSE;

    while (LdrNext != LdrHead) {
        PLDR_DATA_TABLE_ENTRY LdrEntry;
        LDR_DATA_TABLE_ENTRY LdrEntryData;

        WCHAR ImagePathW[MAX_PATH];
        LPCWSTR ImageName;
        CHAR ImagePathA[MAX_PATH];
        DWORD cb;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if(!ReadProcessMemory(hProcess, LdrEntry, &LdrEntryData, sizeof(LdrEntryData), NULL))
            return FALSE;

        cb = LdrEntryData.FullDllName.MaximumLength;

        if(cb > (MAX_PATH * sizeof(WCHAR)) ) return FALSE; // TODO: realloc?

        if(!ReadProcessMemory(hProcess, LdrEntryData.FullDllName.Buffer, ImagePathW, cb, NULL))
            return FALSE;

        FixupBrokenLoaderPath(ImagePathW);

        //
        // if the encountered image is our client interface, tell the caller
        // about it.
        //

        GetFileNameFromPath(ImagePathW, &ImageName);

        if(lstrcmpiW(ImageName, FILENAME_CLIENT_INTERFACE) == 0) {
            *lpdwBaseAddrClient = (DWORD_PTR)LdrEntryData.DllBase;
        }

#ifdef _M_XI86

        //
        // Don't bother to convert the real module name to ANSI - what we
        // do is just fill in bogus module names, and then we come back later
        // and query the Unicode name of the single image we are interested in.
        //

        wsprintfA(ImagePathA, "%lu", dwModuleIndex++);
#else

        //
        // non X86 needs real image paths for SymFunctionTableAccess() until
        // we implement our own SymFunctionTableAccess().
        //

        if(WideCharToMultiByte(
                CP_ACP,
                0,
                ImagePathW,
                cb / sizeof(WCHAR),
                ImagePathA,
                cb / sizeof(WCHAR),
                NULL,
                NULL) == 0)
            return FALSE;

#endif // _M_XI86


        if(!_SymLoadModule(
                hProcess,
                NULL,
                ImagePathA,
                NULL,
                (DWORD_PTR)LdrEntryData.DllBase,
                LdrEntryData.SizeOfImage))
            return FALSE;

        LdrNext = LdrEntryData.InMemoryOrderLinks.Flink;

    } // while


    return TRUE;
}


BOOL
GetFileNameFromBaseAddr(
    IN  HANDLE  hProcess,
    IN  DWORD   dwProcessId,
    IN  DWORD_PTR   dwBaseAddr,
    OUT LPWSTR  *lpszDirectCaller
    )
/*++

    This routine determines what the path and filename is to the module
    associated with the specified dwBaseAddr.  The process specified by the
    hProcess and dwProcessId parameters is queried.

    On success, the return value is TRUE, and the lpszDirectCaller parameter
    is points to an allocated buffer containing the path and filename.  The
    caller must free the buffer when it is no longer needed.

    On failure, the return value is FALSE.

--*/
{
    if(FIsWinNT()) {
        return GetFileNameFromBaseAddrNT(hProcess, dwProcessId, dwBaseAddr, lpszDirectCaller);
    }
#ifdef WIN95_LEGACY
    else {
        return GetFileNameFromBaseAddr95(hProcess, dwProcessId, dwBaseAddr, lpszDirectCaller);
    }
#endif  // WIN95_LEGACY

    return FALSE;
}


BOOL
GetFileNameFromBaseAddrNT(
    IN  HANDLE  hProcess,
    IN  DWORD   dwProcessId,
    IN  DWORD_PTR   dwBaseAddr,
    OUT LPWSTR  *lpszDirectCaller
    )
{
    PROCESS_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;
    PPEB Peb;
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        return FALSE;
    }

    Peb = BasicInfo.PebBaseAddress;

    //
    // Ldr = Peb->Ldr
    //

    if(!ReadProcessMemory(hProcess, &Peb->Ldr, &Ldr, sizeof(Ldr), NULL))
        return FALSE;

    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    if(!ReadProcessMemory(hProcess, &LdrHead->Flink, &LdrNext, sizeof(LdrNext), NULL))
        return FALSE;

    while (LdrNext != LdrHead) {
        PLDR_DATA_TABLE_ENTRY LdrEntry;
        LDR_DATA_TABLE_ENTRY LdrEntryData;

        WCHAR ImagePathW[MAX_PATH];
        DWORD cb;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if(!ReadProcessMemory(hProcess, LdrEntry, &LdrEntryData, sizeof(LdrEntryData), NULL))
            return FALSE;

        cb = LdrEntryData.FullDllName.MaximumLength;

        if(cb > (MAX_PATH * sizeof(WCHAR)) ) return FALSE; // TODO: realloc?

        if(!ReadProcessMemory(hProcess, LdrEntryData.FullDllName.Buffer, ImagePathW, cb, NULL))
            return FALSE;

        FixupBrokenLoaderPath(ImagePathW);


        if((DWORD_PTR)LdrEntryData.DllBase == dwBaseAddr) {
            *lpszDirectCaller = (LPWSTR)SSAlloc( cb );
            if(*lpszDirectCaller == NULL)
                break;

            CopyMemory(*lpszDirectCaller, ImagePathW, cb);
            return TRUE;
        }

        LdrNext = LdrEntryData.InMemoryOrderLinks.Flink;

    } // while


    return FALSE;
}

#ifdef WIN95_LEGACY

BOOL
GetFileNameFromBaseAddr95(
    IN  HANDLE  hProcess,
    IN  DWORD   dwProcessId,
    IN  DWORD_PTR   dwBaseAddr,
    OUT LPWSTR  *lpszDirectCaller
    )
{
    HANDLE hSnapshot;
    MODULEENTRY32 me32;
    BOOL bSuccess = FALSE;
    BOOL bFound = FALSE;

    *lpszDirectCaller = NULL;

    hSnapshot = pCreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwProcessId);
    if(hSnapshot == INVALID_HANDLE_VALUE)
        return FALSE;

    me32.dwSize = sizeof(me32);

    bSuccess = pModule32First(hSnapshot, &me32);

    while(bSuccess) {
        LPCSTR szFileName;
        DWORD cchModule;

        if((DWORD_PTR)me32.modBaseAddr != dwBaseAddr) {
            me32.dwSize = sizeof(me32);
            bSuccess = pModule32Next(hSnapshot, &me32);
            continue;
        }

        cchModule = lstrlenA(me32.szExePath) + 1;

        *lpszDirectCaller = (LPWSTR)SSAlloc(cchModule * sizeof(WCHAR));
        if(*lpszDirectCaller == NULL)
            break;

        if(MultiByteToWideChar(
            0,
            0,
            me32.szExePath,
            cchModule,
            *lpszDirectCaller,
            cchModule
            ) != 0) {

            bFound = TRUE;
        }

        break;
    }

    CloseHandle(hSnapshot);

    if(!bFound) {
        if(*lpszDirectCaller) {
            SSFree(*lpszDirectCaller);
            *lpszDirectCaller = NULL;
        }
    }

    return bFound;
}

BOOL
GetProcessIdFromPath95(
    IN      LPCSTR  szProcessPath,
    IN OUT  DWORD   *dwProcessId
    )
{
    LPCSTR szProcessName;
    HANDLE hSnapshot;
    PROCESSENTRY32 pe32;
    DWORD dwLastError = 0;
    BOOL bSuccess;
    BOOL bFound = FALSE; // assume no match found

    if(!GetFileNameFromPathA(szProcessPath, &szProcessName))
        return FALSE;

    hSnapshot = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hSnapshot == INVALID_HANDLE_VALUE)
        return FALSE;

    pe32.dwSize = sizeof(pe32);

    bSuccess = pProcess32First(hSnapshot, &pe32);

    while(bSuccess) {
        LPCSTR szFileName;

        GetFileNameFromPathA(pe32.szExeFile, &szFileName);

        if(lstrcmpiA( szFileName, szProcessName ) == 0) {
            *dwProcessId = pe32.th32ProcessID;
            bFound = TRUE;
            break;
        }

        pe32.dwSize = sizeof(pe32);
        bSuccess = pProcess32Next(hSnapshot, &pe32);
    }

    CloseHandle(hSnapshot);

    if(!bFound && dwLastError) {
        SetLastError(dwLastError);
    }

    return bFound;
}


BOOL
GetBaseAddressModule95(
    IN      DWORD   dwProcessId,
    IN      LPCSTR  szImagePath,
    IN  OUT DWORD_PTR   *dwBaseAddress,
    IN  OUT DWORD   *dwUseCount
    )
{
    LPSTR szImageName;
    HANDLE hSnapshot;
    MODULEENTRY32 me32;
    BOOL bSuccess = FALSE;
    BOOL bFound = FALSE;

    if(!GetFileNameFromPathA(szImagePath, &szImageName))
        return FALSE;

    hSnapshot = pCreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwProcessId);
    if(hSnapshot == INVALID_HANDLE_VALUE)
        return FALSE;

    me32.dwSize = sizeof(me32);

    bSuccess = pModule32First(hSnapshot, &me32);

    while(bSuccess) {
        LPCSTR szFileName;

        GetFileNameFromPathA(me32.szExePath, &szFileName);

        if(lstrcmpiA( szFileName, szImageName ) == 0) {
            *dwBaseAddress = (DWORD_PTR)me32.modBaseAddr;
            *dwUseCount = me32.ProccntUsage;
            bFound = TRUE;
            break;
        }

        me32.dwSize = sizeof(me32);
        bSuccess = pModule32Next(hSnapshot, &me32);
    }

    CloseHandle(hSnapshot);

    return bFound;
}

#endif  // WIN95_LEGACY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\svr\tlhelp32.h ===
/*****************************************************************************\
*                                                                             *
* tlhelp32.h -	WIN32 tool help functions, types, and definitions	      *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* NOTE: windows.h/winbase.h must be #included first			      *
*                                                                             *
* Copyright (c) 1994-1995, Microsoft Corp.   All rights reserved. 	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_TOOLHELP32
#define _INC_TOOLHELP32

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#define MAX_MODULE_NAME32 255

/****** Shapshot function **********************************************/

HANDLE WINAPI CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
//
// The th32ProcessID argument is only used if TH32CS_SNAPHEAPLIST or
// TH32CS_SNAPMODULE is specified. th32ProcessID == 0 means the current
// process.
//
// NOTE that all of the snapshots are global except for the heap and module
//	lists which are process specific. To enumerate the heap or module
//	state for all WIN32 processes call with TH32CS_SNAPALL and the
//	current process. Then for each process in the TH32CS_SNAPPROCESS
//	list that isn't the current process, do a call with just
//	TH32CS_SNAPHEAPLIST and/or TH32CS_SNAPMODULE.
//
// dwFlags
//
#define TH32CS_SNAPHEAPLIST 0x00000001
#define TH32CS_SNAPPROCESS  0x00000002
#define TH32CS_SNAPTHREAD   0x00000004
#define TH32CS_SNAPMODULE   0x00000008
#define TH32CS_SNAPALL	    (TH32CS_SNAPHEAPLIST | TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD | TH32CS_SNAPMODULE)
#define TH32CS_INHERIT	    0x80000000
//
// Use CloseHandle to destroy the snapshot
//

/****** heap walking ***************************************************/

typedef struct tagHEAPLIST32
{
    DWORD  dwSize;
    DWORD  th32ProcessID;   // owning process
    DWORD  th32HeapID;	    // heap (in owning process's context!)
    DWORD  dwFlags;
} HEAPLIST32;
typedef HEAPLIST32 *  PHEAPLIST32;
typedef HEAPLIST32 *  LPHEAPLIST32;
//
// dwFlags
//
#define HF32_DEFAULT	  1  // process's default heap
#define HF32_SHARED	  2  // is shared heap

BOOL WINAPI Heap32ListFirst(HANDLE hSnapshot, LPHEAPLIST32 lphl);
BOOL WINAPI Heap32ListNext(HANDLE hSnapshot, LPHEAPLIST32 lphl);

typedef struct tagHEAPENTRY32
{
    DWORD  dwSize;
    HANDLE hHandle;	// Handle of this heap block
    DWORD  dwAddress;	// Linear address of start of block
    DWORD  dwBlockSize; // Size of block in bytes
    DWORD  dwFlags;
    DWORD  dwLockCount;
    DWORD  dwResvd;
    DWORD  th32ProcessID;   // owning process
    DWORD  th32HeapID;	    // heap block is in
} HEAPENTRY32;
typedef HEAPENTRY32 *  PHEAPENTRY32;
typedef HEAPENTRY32 *  LPHEAPENTRY32;
//
// dwFlags
//
#define LF32_FIXED    0x00000001
#define LF32_FREE     0x00000002
#define LF32_MOVEABLE 0x00000004

BOOL WINAPI Heap32First(LPHEAPENTRY32 lphe, DWORD th32ProcessID,
			DWORD th32HeapID);
BOOL WINAPI Heap32Next(LPHEAPENTRY32 lphe);
BOOL WINAPI Toolhelp32ReadProcessMemory(DWORD	th32ProcessID,
					LPCVOID lpBaseAddress,
					LPVOID	lpBuffer,
					DWORD	cbRead,
					LPDWORD lpNumberOfBytesRead);

/***** Process walking *************************************************/

typedef struct tagPROCESSENTRY32
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ProcessID;	    // this process
    DWORD   th32DefaultHeapID;
    DWORD   th32ModuleID;	    // associated exe
    DWORD   cntThreads;
    DWORD   th32ParentProcessID;    // this process's parent process
    LONG    pcPriClassBase;	    // Base priority of process's threads
    DWORD   dwFlags;
    char    szExeFile[MAX_PATH];    // Path
} PROCESSENTRY32;
typedef PROCESSENTRY32 *  PPROCESSENTRY32;
typedef PROCESSENTRY32 *  LPPROCESSENTRY32;

BOOL WINAPI Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
BOOL WINAPI Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);

/***** Thread walking **************************************************/

typedef struct tagTHREADENTRY32
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ThreadID;	// this thread
    DWORD   th32OwnerProcessID; // Process this thread is associated with
    LONG    tpBasePri;
    LONG    tpDeltaPri;
    DWORD   dwFlags;
} THREADENTRY32;
typedef THREADENTRY32 *  PTHREADENTRY32;
typedef THREADENTRY32 *  LPTHREADENTRY32;

BOOL WINAPI Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
BOOL WINAPI Thread32Next(HANDLE hSnapshot, LPTHREADENTRY32 lpte);

/***** Module walking *************************************************/

typedef struct tagMODULEENTRY32
{
    DWORD   dwSize;
    DWORD   th32ModuleID;	// This module
    DWORD   th32ProcessID;	// owning process
    DWORD   GlblcntUsage;	// Global usage count on the module
    DWORD   ProccntUsage;	// Module usage count in th32ProcessID's context
    BYTE  * modBaseAddr;	// Base address of module in th32ProcessID's context
    DWORD   modBaseSize;	// Size in bytes of module starting at modBaseAddr
    HMODULE hModule;		// The hModule of this module in th32ProcessID's context
    char    szModule[MAX_MODULE_NAME32 + 1];
    char    szExePath[MAX_PATH];
} MODULEENTRY32;
typedef MODULEENTRY32 *  PMODULEENTRY32;
typedef MODULEENTRY32 *  LPMODULEENTRY32;

//
// NOTE CAREFULLY that the modBaseAddr and hModule fields are valid ONLY
// in th32ProcessID's process context.
//

BOOL WINAPI Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
BOOL WINAPI Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme);

#ifdef __cplusplus
}
#endif

#endif // _INC_TOOLHELP32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\svr\winpw.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    winpw.h

Abstract:

    This module contains routines for retrieving and verification of
    Windows [NT] password associated with client calling protected storage.

Author:

    Scott Field (sfield)    12-Dec-96

--*/

#ifndef __WINPW_H__
#define __WINPW_H__

#ifdef __cplusplus
extern "C" {
#endif


typedef struct {
    BYTE HashedUsername[A_SHA_DIGEST_LEN];  // hash of ANSI username, not include terminal NULL
    BYTE HashedPassword[A_SHA_DIGEST_LEN];  // hash of Unicode password, not include terminal NULL
    BOOL bValid;                            // indicates if structure contents valid
} WIN95_PASSWORD, *PWIN95_PASSWORD, *LPWIN95_PASSWORD;


BOOL
SetPasswordNT(
    PLUID LogonID,
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    );

BOOL
GetPasswordNT(
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    );

BOOL
GetSpecialCasePasswordNT(
    BYTE    HashedPassword[A_SHA_DIGEST_LEN],   // derived bits when fSpecialCase == TRUE
    LPBOOL  fSpecialCase                        // legal special case encountered?
    );

BOOL
SetPassword95(
    BYTE HashedUsername[A_SHA_DIGEST_LEN],
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    );

BOOL
GetPassword95(
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    );

BOOL
GetHackPassword95(
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    );

BOOL
VerifyWindowsPassword(
    LPCWSTR Password             // password to validate
    );


#ifdef __cplusplus
}
#endif


#endif // __WINPW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\svr\service.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   service.c
//
//  PURPOSE:  Implements functions required by all services
//            and takes into account dumbed-down win95 services
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//    service_ctrl(DWORD dwCtrlCode);
//    PSTOREServiceMain(DWORD dwArgc, LPWSTR *lpszArgv);
//    WinNTDebugService(int argc, char **argv);
//    ControlHandler ( DWORD dwCtrlType );
//
//  COMMENTS:
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//  MODIFIED: Matt Thomlinson
//            Scott Field
//


#include <pch.cpp>
#pragma hdrstop

#include <svcs.h>
#include "service.h"

// this event is signalled when the
// service should end
//
HANDLE  hServerStopEvent = NULL;

//
// this event is used to allow external code to determine if we are initialized
// and running.  Currently, this is only used by the WinNT and Win95 credential
// managers to prevent logon delays when the service is not available.
//

HANDLE  hServiceStarted = NULL;

PACL    pDaclInitEvent = NULL;


extern DWORD GlobalSecurityMask;
extern BOOL g_bAudit;


//
// waitable thread pool handle.
//

HANDLE hRegisteredWait = NULL;


VOID
TeardownServer(
    DWORD dwLastError
    );

VOID
NTAPI
TerminationNotify(
    PVOID Context,
    BOOLEAN TimerOrWaitFired
    );


#define RTN_OK                  0   // no errors
#define RTN_USAGE               1   // usage error (invalid commandline)
#define RTN_ERROR_INIT          2   // error during service initialization
#define RTN_ERROR_INSTALL       13  // error during -install or -remove
#define RTN_ERROR_INSTALL_SIG   14  // error installing signature(s)
#define RTN_ERROR_INSTALL_START 15  // could not start service during install
#define RTN_ERROR_INSTALL_SHEXT 16  // error installing shell extension

//
// global module handle used to reference resources contained in this module.
//

HINSTANCE   g_hInst = NULL;


// internal variables
static SERVICE_STATUS   ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;


// internal function prototypes
void WINAPI service_ctrl(DWORD dwCtrlCode);
void WINAPI PSTOREServiceMain(DWORD dwArgc, LPWSTR *lpszArgv);

DWORD
WINAPI
Start(
    LPVOID lpV
    );


BOOL
WINAPI
DllMain(
    HMODULE hInst,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    if( dwReason == DLL_PROCESS_ATTACH ) {
        g_hInst = hInst;
        DisableThreadLibraryCalls(hInst);
    }

    return TRUE;
}


VOID
WINAPI
ServiceEntry(
    DWORD NumArgs,
    LPWSTR *ArgsArray,
    PVOID LmsvcsGlobalData,
    HANDLE SvcRefHandle
    )
{
    Start( NULL );
}


DWORD
WINAPI
Start(
    LPVOID lpV
    )
{
    BOOL fIsNT = FIsWinNT();
    int iRet;


    //
    // surpress dialog boxes generated by missing files, etc.
    //

    SetErrorMode(SEM_NOOPENFILEERRORBOX);

    SERVICE_TABLE_ENTRYW dispatchTable[] =
    {
        { SZSERVICENAME, (LPSERVICE_MAIN_FUNCTIONW)PSTOREServiceMain },
        { NULL, NULL }
    };

#ifdef WIN95_LEGACY

    if (!fIsNT)
        goto dispatch95;

#endif  // WIN95_LEGACY

    // if it doesn't match any of the above parameters
    // the service control manager may be starting the service
    // so we must call StartServiceCtrlDispatcher

    if(!FIsWinNT5()) {
        if (!StartServiceCtrlDispatcherW(dispatchTable))
            AddToMessageLog(L"StartServiceCtrlDispatcher failed.");
    } else {
        PSTOREServiceMain( 0, NULL );
    }

    return RTN_OK;

#ifdef WIN95_LEGACY

dispatch95:


    //
    // Win95 doesn't support services, except as pseudo-.exe files
    //

    HMODULE hKernel = GetModuleHandleA("kernel32.dll");
    if (NULL == hKernel)
    {
        AddToMessageLog(L"RegisterServiceProcess module handle failed");
        return RTN_ERROR_INIT;
    }

    // inline typedef: COOL!
    typedef DWORD REGISTERSERVICEPROCESS(
        DWORD dwProcessId,
        DWORD dwServiceType);

    REGISTERSERVICEPROCESS* pfnRegSvcProc = NULL;

    // Make sure Win95 Logoff won't stop our .exe
    if (NULL == (pfnRegSvcProc = (REGISTERSERVICEPROCESS*)GetProcAddress(hKernel, "RegisterServiceProcess")))
    {
        AddToMessageLog(L"RegisterServiceProcess failed");
        return RTN_ERROR_INIT;
    }

    pfnRegSvcProc(GetCurrentProcessId(), TRUE);  // register this process ID as a service process

    //
    // call re-entry point and return with result of it.
    //

    iRet = ServiceStart(0, 0);

    if(iRet != ERROR_SUCCESS)
        AddToMessageLog(L"ServiceStart error!");

    return iRet;

#endif  // WIN95_LEGACY

}

//
//  FUNCTION: PSTOREServiceMain
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined ServiceStart() routine to perform majority
//    of the work.
//
void WINAPI PSTOREServiceMain(DWORD dwArgc, LPWSTR * /*lpszArgv*/)
{
    DWORD dwLastError = ERROR_SUCCESS;

    // register our service control handler:
    //
    sshStatusHandle = RegisterServiceCtrlHandlerW( SZSERVICENAME, service_ctrl);

    if (!sshStatusHandle)
        return;

    // SERVICE_STATUS members that don't change in example
    //
    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;


    // report the status to the service control manager.
    //

    if (!ReportStatusToSCMgr(
                    SERVICE_START_PENDING, // service state
                    NO_ERROR,              // exit code
                    3000                   // wait hint
                    )) return ;

    dwLastError = ServiceStart(0, 0);

    return;
}



//
//  FUNCTION: service_ctrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode - type of control requested
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID WINAPI service_ctrl(DWORD dwCtrlCode)
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        case SERVICE_CONTROL_STOP:

            //
            // tell the SCM we are stopping before triggering StopService() code
            // to avoid potential race condition during STOP_PENDING -> STOPPED transition
            //

            ssStatus.dwCurrentState = SERVICE_STOP_PENDING;
            ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);
            ServiceStop();
            return;

        // Update the service status.
        //
        case SERVICE_CONTROL_INTERROGATE:
            break;

        // invalid control code
        //
        default:
            break;

    }

    ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);
}



//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;


    if (dwCurrentState == SERVICE_START_PENDING)
        ssStatus.dwControlsAccepted = 0;
    else
        ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    ssStatus.dwCurrentState = dwCurrentState;
    if(dwWin32ExitCode == 0) {
        ssStatus.dwWin32ExitCode = 0;
    } else {
        ssStatus.dwServiceSpecificExitCode = dwWin32ExitCode;
        ssStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
    }

    ssStatus.dwWaitHint = dwWaitHint;

    if ( ( dwCurrentState == SERVICE_RUNNING ) ||
         ( dwCurrentState == SERVICE_STOPPED ) )
        ssStatus.dwCheckPoint = 0;
    else
        ssStatus.dwCheckPoint = dwCheckPoint++;


    // Report the status of the service to the service control manager.
    //
    if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus))) {
        AddToMessageLog(L"SetServiceStatus");
    }

    return fResult;
}



//
//  FUNCTION: AddToMessageLog(LPWSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID AddToMessageLog(LPWSTR lpszMsg)
{
    DWORD dwLastError = GetLastError();

    if(FIsWinNT()) {

        //
        // WinNT: Use event logging to log the error.
        //

        WCHAR   szMsg[512];
        HANDLE  hEventSource;
        LPWSTR  lpszStrings[2];

        hEventSource = RegisterEventSourceW(NULL, SZSERVICENAME);

        if(hEventSource == NULL)
            return;

        wsprintfW(szMsg, L"%s error: %lu", SZSERVICENAME, dwLastError);
        lpszStrings[0] = szMsg;
        lpszStrings[1] = lpszMsg;

        ReportEventW(hEventSource, // handle of event source
            EVENTLOG_ERROR_TYPE,  // event type
            0,                    // event category
            0,                    // event ID
            NULL,                 // current user's SID
            2,                    // strings in lpszStrings
            0,                    // no bytes of raw data
            (LPCWSTR*)lpszStrings,          // array of error strings
            NULL);                // no raw data

        (VOID) DeregisterEventSource(hEventSource);

    }
#ifdef WIN95_LEGACY
    else {

        //
        // Win95: log error to file
        //

        HANDLE hFile;
        SYSTEMTIME st;
        CHAR szMsgOut[512];
        DWORD cchMsgOut;
        DWORD dwBytesWritten;

        hFile = CreateFileA(
            "pstore.log",
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            OPEN_ALWAYS,
            0,
            NULL
            );

        if(hFile == INVALID_HANDLE_VALUE)
            return;

        GetSystemTime( &st );

        cchMsgOut = wsprintfA(szMsgOut, "%.2u-%.2u-%.2u %.2u:%.2u:%.2u %ls (rc=%lu)\015\012",
            st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond,
            lpszMsg,
            dwLastError
            );

        //
        // seek to EOF
        //

        SetFilePointer(hFile, 0, NULL, FILE_END);

        WriteFile(hFile, szMsgOut, cchMsgOut, &dwBytesWritten, NULL);
        CloseHandle(hFile);
    }
#endif  // WIN95_LEGACY

}









//
//  FUNCTION: ServiceStart
//
//  COMMENTS:
//    The service
//    stops when hServerStopEvent is signalled

DWORD
ServiceStart(
    HINSTANCE hInstance,
    int nCmdShow
    )
{
    SECURITY_ATTRIBUTES sa;

    PSID pEveryoneSid = NULL;
    SECURITY_DESCRIPTOR sdInitEvent;
    RPC_STATUS status = 0;


    SID_IDENTIFIER_AUTHORITY sia = SECURITY_WORLD_SID_AUTHORITY;
    DWORD EveryoneSidBuffer[6];

    DWORD dwAclSize;

    DWORD dwLastError = ERROR_SUCCESS;
    BOOL fStartedKeyService = FALSE;
    BOOL bListConstruct = FALSE;

    pEveryoneSid = (PSID)EveryoneSidBuffer;
    InitializeSid(pEveryoneSid, &sia, 1);
    *(GetSidSubAuthority( pEveryoneSid, 0)) = SECURITY_WORLD_RID; 


    dwAclSize = sizeof(ACL) +
        1 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(pEveryoneSid) ;

    pDaclInitEvent = (PACL)SSAlloc(dwAclSize);
    if(pDaclInitEvent == NULL)
    {
        dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    if(!InitializeAcl(pDaclInitEvent, dwAclSize, ACL_REVISION))
    {
        dwLastError = GetLastError();
        goto cleanup;
    }

    if(!AddAccessAllowedAce(
        pDaclInitEvent,
        ACL_REVISION,
        SYNCHRONIZE,
        pEveryoneSid
        ))
    {
        dwLastError = GetLastError();
        goto cleanup;
    }

    if(!InitializeSecurityDescriptor(
        &sdInitEvent,
        SECURITY_DESCRIPTOR_REVISION
        ))
    {
        dwLastError = GetLastError();
        goto cleanup;
    }

    if(!SetSecurityDescriptorDacl(
        &sdInitEvent,
        TRUE,
        pDaclInitEvent,
        FALSE
        ))
    {
        dwLastError = GetLastError();
        goto cleanup;
    }


    sa.lpSecurityDescriptor = &sdInitEvent;



    //
    // create the event object. The control handler function signals
    // this event when it receives the "stop" control code.
    // On WinNT, we let security default to local system+admins access.
    // On WinNT, the ServiceStop() API is the correct way to cause a service
    // to stop, so we let Service Control manager dictate who can do it.
    //

    // Only on Win95 do we use a named event, in order to support shutting
    // down the server cleanly on that platform, since Win95 does not support
    // real services.

    hServerStopEvent = CreateEventA(
            NULL,
            TRUE,           // manual reset event
            FALSE,          // not-signalled
            (FIsWinNT() ? NULL : PST_EVENT_STOP)    // WinNT: unnamed, Win95 named
            );

    //
    // if event already exists, terminate quietly so that only one instance
    // of the service is allowed.
    //

    if(hServerStopEvent && GetLastError() == ERROR_ALREADY_EXISTS) {
        CloseHandle(hServerStopEvent);
        hServerStopEvent = NULL;
    }

    if(hServerStopEvent == NULL) {
        dwLastError = GetLastError();
        goto cleanup;
    }

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = FALSE;

    hServiceStarted = CreateEventA(
                        &sa,        // security attributes for WinNT
                        TRUE,       // manual reset event
                        FALSE,      // not-signalled
                        PST_EVENT_INIT_NT5
                        );


    if(hServiceStarted == NULL) {
        dwLastError = GetLastError();
        goto cleanup;
    }


    //
    // free Dacl on event, since we no longer need it.
    //

    if(pDaclInitEvent) {
        SSFree(pDaclInitEvent);
        pDaclInitEvent = NULL;
    }

    //
    // report the status to the service control manager.
    // (service start still pending).
    //

    if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING,  // service state
            NO_ERROR,               // exit code
            3000                    // wait hint
            )) {
        dwLastError = GetLastError();
        goto cleanup;
    }

    bListConstruct = ListConstruct();

    if(!bListConstruct)
    {
        dwLastError = GetLastError();
        goto cleanup;
    }

    status = RpcServerUseProtseqEpW(PSTORE_LOCAL_PROT_SEQ,   //ncalrpc 
                                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT, 
                                    PSTORE_LOCAL_ENDPOINT,   //protected_storage
                                    NULL);              //Security Descriptor

    if(RPC_S_DUPLICATE_ENDPOINT == status)
    {
        status = RPC_S_OK;
    }

    if ( status != RPC_S_OK )
    {
        dwLastError = status;
        goto cleanup;
    }


    status = RpcServerRegisterIfEx(s_IPStoreProv_v1_0_s_ifspec, 
                                   NULL, 
                                   NULL,
                                   RPC_IF_AUTOLISTEN,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   NULL);

    if ( status != RPC_S_OK )
    {
        dwLastError = status;
        goto cleanup;
    }





    SetEvent(hServiceStarted); // signal service is ready to take requests


    //
    // report the status to the service control manager.
    //

    if (!ReportStatusToSCMgr(
            SERVICE_RUNNING,       // service state
            NO_ERROR,              // exit code
            0                      // wait hint
            )) {
        dwLastError = GetLastError();
        goto cleanup;
    }


    //
    // on WinNT5, ask services.exe to notify us when the service is shutting
    // down, and return this thread to the work item queue.
    //


    if(!RegisterWaitForSingleObject(
                            &hRegisteredWait,
                            hServerStopEvent,   // wait handle
                            TerminationNotify,  // callback fcn
                            NULL,               // parameter
                            INFINITE,           // timeout
                            WT_EXECUTELONGFUNCTION | WT_EXECUTEONLYONCE
                            )) {

        hRegisteredWait = NULL;
        dwLastError = GetLastError();
    }

    return dwLastError;


cleanup:

    TeardownServer( dwLastError );

    return dwLastError;
}

VOID
NTAPI
TerminationNotify(
    PVOID Context,
    BOOLEAN TimerOrWaitFired
    )
/*++

Routine Description:

    This function gets called by a services worker thread when the
    termination event gets signaled.

Arguments:

Return Value:

--*/
{
    //
    // per JSchwart:
    // safe to unregister during callback.
    //

    if( hRegisteredWait ) {
        UnregisterWaitEx( hRegisteredWait, NULL );
        hRegisteredWait = NULL;
    }

    TeardownServer( ERROR_SUCCESS );
}

VOID
TeardownServer(
    DWORD dwLastError
    )
{
    //
    // ignore errors because we are shutting down
    //

    RpcServerUnregisterIf(s_IPStoreProv_v1_0_s_ifspec, 0, 0);




    if(pDaclInitEvent) {
        SSFree(pDaclInitEvent);
        pDaclInitEvent = NULL;
    }

    if(hServiceStarted) {
        ResetEvent(hServiceStarted);
        CloseHandle(hServiceStarted);
        hServiceStarted = NULL;
    }


    if(hServerStopEvent) {
        SetEvent(hServerStopEvent); // make event signalled to release anyone waiting for termination
        CloseHandle(hServerStopEvent);
        hServerStopEvent = NULL;
    }

    ListTeardown();



    ReportStatusToSCMgr(
                        SERVICE_STOPPED,
                        dwLastError,
                        0
                        );

}

//  FUNCTION: ServiceStop
//
//  PURPOSE: Stops the service
//
//  COMMENTS:
//    If a ServiceStop procedure is going to
//    take longer than 3 seconds to execute,
//    it should spawn a thread to execute the
//    stop code, and return.  Otherwise, the
//    ServiceControlManager will believe that
//    the service has stopped responding.
//
VOID ServiceStop()
{

    if(hServiceStarted) {
        ResetEvent(hServiceStarted);
        CloseHandle(hServiceStarted);
        hServiceStarted = NULL;
    }

    if(hServerStopEvent)
        PulseEvent(hServerStopEvent); // signal waiting threads and reset to non-signalled
}

/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_API midl_user_allocate(size_t len)
{
    return(SSAlloc(len));
}

void __RPC_API midl_user_free(void __RPC_FAR * ptr)
{
    //
    // sfield: zero memory before freeing it.
    // do this because RPC allocates alot on our behalf, and we want to
    // be as sanitary as possible with respect to not letting anything
    // sensitive go to pagefile.
    //

    ZeroMemory( ptr, SSSize( ptr ) );
    SSFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\certtest\certtest.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       certtest.h
//
//  Contents:   Certificate Test Helper API Prototypes and Definitions
//
//  History:    11-Apr-96   philh   created
//--------------------------------------------------------------------------

#ifndef __CERTTEST_H__
#define __CERTTEST_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "wincrypt.h"
#include "mssip.h"
#include "sipbase.h"
#include "softpub.h"
#include "signutil.h"

#define MAX_HASH_LEN  20

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
void PrintError(LPCSTR pszMsg);
void PrintLastError(LPCSTR pszMsg);

//+-------------------------------------------------------------------------
//  Test allocation and free routines
//--------------------------------------------------------------------------
LPVOID
WINAPI
TestAlloc(
    IN size_t cbBytes
    );


LPVOID
WINAPI
TestRealloc(
    IN LPVOID pvOrg,
    IN size_t cbBytes
    );

VOID
WINAPI
TestFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  Allocate and convert a multi-byte string to a wide string
//--------------------------------------------------------------------------
LPWSTR AllocAndSzToWsz(LPCSTR psz);

//+-------------------------------------------------------------------------
//  Useful display functions
//--------------------------------------------------------------------------
LPCSTR FileTimeText(FILETIME *pft);
void PrintBytes(LPCSTR pszHdr, BYTE *pb, DWORD cbSize);

//+-------------------------------------------------------------------------
//  Allocate and read an encoded DER blob from a file
//--------------------------------------------------------------------------
BOOL ReadDERFromFile(
    LPCSTR  pszFileName,
    PBYTE   *ppbDER,
    PDWORD  pcbDER
    );

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
BOOL WriteDERToFile(
    LPCSTR  pszFileName,
    PBYTE   pbDER,
    DWORD   cbDER
    );

//+-------------------------------------------------------------------------
//  Get the default Crypt Provider. Create the private signature/exchange
//  if they don't already exist.
//--------------------------------------------------------------------------
HCRYPTPROV GetCryptProv();

//+-------------------------------------------------------------------------
//  Open/Save the specified cert store
//--------------------------------------------------------------------------
HCERTSTORE OpenStore(BOOL fSystemStore, LPCSTR pszStoreFilename);
HCERTSTORE OpenStoreEx(BOOL fSystemStore, LPCSTR pszStoreFilename,
    DWORD dwFlags);
// returns NULL if unable to open. Doesn't open memory store as in the above
// 2 versions of OpenStore
HCERTSTORE OpenSystemStoreOrFile(BOOL fSystemStore, LPCSTR pszStoreFilename,
    DWORD dwFlags);
void SaveStore(HCERTSTORE hStore, LPCSTR pszSaveFilename);
void SaveStoreEx(HCERTSTORE hStore, BOOL fPKCS7Save, LPCSTR pszSaveFilename);

//+-------------------------------------------------------------------------
//  Open the specified cert store or SPC file
//
//  No longer supported. The above OpenStore tries opening as
//  SPC if unable to open as a store.
//--------------------------------------------------------------------------
HCERTSTORE OpenStoreOrSpc(BOOL fSystemStore, LPCSTR pszStoreFilename,
    BOOL *pfSpc);

//+-------------------------------------------------------------------------
//  Certificate encoding type used by cert test routines.
//  The default is X509_ASN_ENCODING;
//--------------------------------------------------------------------------
extern DWORD dwCertEncodingType;

//+-------------------------------------------------------------------------
//  Message encoding type used by cert test routines.
//  The default is PKCS_7_ASN_ENCODING;
//--------------------------------------------------------------------------
extern DWORD dwMsgEncodingType;


//+-------------------------------------------------------------------------
//  Message and certificate encoding type used by cert test routines.
//  The default is PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
//--------------------------------------------------------------------------
extern DWORD dwMsgAndCertEncodingType;

//+-------------------------------------------------------------------------
//  Certificate Display definitions and APIs
//--------------------------------------------------------------------------
// Display flags
#define DISPLAY_VERBOSE_FLAG        0x00000001
#define DISPLAY_CHECK_FLAG          0x00000002
#define DISPLAY_BRIEF_FLAG          0x00000004
#define DISPLAY_KEY_THUMB_FLAG      0x00000008
#define DISPLAY_UI_FLAG             0x00000010
#define DISPLAY_NO_ISSUER_FLAG      0x00000100
#define DISPLAY_CHECK_SIGN_FLAG     0x00001000
#define DISPLAY_CHECK_TIME_FLAG     0x00002000

void DisplayVerifyFlags(LPSTR pszHdr, DWORD dwFlags);

void DisplayCert(
    PCCERT_CONTEXT pCert,
    DWORD dwDisplayFlags = 0,
    DWORD dwIssuer = 0
    );
void DisplayCert2(
    HCERTSTORE hStore,          // needed when displaying cert from file
    PCCERT_CONTEXT pCert,
    DWORD dwDisplayFlags = 0,
    DWORD dwIssuer = 0
    );
void DisplayCrl(
    PCCRL_CONTEXT pCrl,
    DWORD dwDisplayFlags = 0
    );
void DisplayCtl(
    PCCTL_CONTEXT pCtl,
    DWORD dwDisplayFlags = 0,
    HCERTSTORE hStore = NULL
    );

void DisplaySignerInfo(
    HCRYPTMSG hMsg,
    DWORD dwSignerIndex = 0,
    DWORD dwDisplayFlags = 0
    );

void DisplayStore(
    IN HCERTSTORE hStore,
    IN DWORD dwDisplayFlags = 0
    );

// Not displayed when DISPLAY_BRIEF_FLAG is set
void DisplayCertKeyProvInfo(
    PCCERT_CONTEXT pCert,
    DWORD dwDisplayFlags = 0
    );

void PrintCrlEntries(
    DWORD cEntry,
    PCRL_ENTRY pEntry,
    DWORD dwDisplayFlags = 0
    );

//+-------------------------------------------------------------------------
//  Returns TRUE if the CTL is still time valid.
//
//  A CTL without a NextUpdate is considered time valid.
//--------------------------------------------------------------------------
BOOL IsTimeValidCtl(
    IN PCCTL_CONTEXT pCtl
    );

//+-------------------------------------------------------------------------
//  Display structures used in Software Publishing Certificate (SPC)
//--------------------------------------------------------------------------
void DisplaySpcLink(PSPC_LINK pSpcLink);

//+-------------------------------------------------------------------------
//  Returns OID's name string. If not found returns L"???".
//--------------------------------------------------------------------------
LPCWSTR GetOIDName(LPCSTR pszOID, DWORD dwGroupId = 0);

//+-------------------------------------------------------------------------
//  Returns OID's Algid. If not found returns 0.
//--------------------------------------------------------------------------
ALG_ID GetAlgid(LPCSTR pszOID, DWORD dwGroupId = 0);

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\secstor\svr\winpw.c ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    winpw.c

Abstract:

    This module contains routines for retrieving and verification of the
    Windows NT and Windows 95 password associated with the client calling
    protected storage.

Author:

    Scott Field (sfield)    12-Dec-96

--*/

#include <windows.h>
#include <lmcons.h>
#include <sha.h>
#include "lnklist.h"
#include "winpw.h"
#include "module.h"
#include "unicode.h"
#include "unicode5.h"
#include "debug.h"

#include "secmisc.h"

#define MPR_PROCESS     "MPREXE.EXE"
#define MPRSERV_MODULE  "MPRSERV.DLL"

#define GLOBAL_USERNAME 0x0E8
#define PWL_USERNAME    0x170
#define GLOBAL_PASSWORD 0x188
#define PWL_PASSWORD    0x210

//
// this one comes and goes only when needed
//

typedef DWORD (WINAPI *WNETVERIFYPASSWORD)(
    LPCSTR lpszPassword,
    BOOL *pfMatch
    );

typedef DWORD (WINAPI *WNETGETUSERA)(
    LPCSTR lpName,
    LPSTR lpUserName,
    LPDWORD lpnLength
    );

WNETGETUSERA _WNetGetUserA = NULL;

//
// global Win95 password buffer.  Only need one entry because Win95
// only allows one user logged on at a time.
//

static WIN95_PASSWORD g_Win95Password;

BOOL
VerifyWindowsPasswordNT(
    LPCWSTR Password
    );

#ifdef WIN95_LEGACY

BOOL
VerifyWindowsPassword95(
    LPCWSTR Password
    );

BOOL
GetHackPassword95Global(
    HANDLE hProcess,
    DWORD_PTR dwBaseAddress,
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    );

BOOL
GetDataMPR(
    IN  HANDLE hProcessMPR,
    IN  DWORD_PTR dwBaseAddressDataSection,
    IN  DWORD dwType,
    IN  LPSTR szBuffer,
    IN  DWORD cbBuffer
    );

#endif  // WIN95_LEGACY

BOOL
GetTokenLogonType(
    HANDLE hToken,
    LPDWORD lpdwLogonType
    );

BOOL
GetTokenLogonType(
    HANDLE hToken,
    LPDWORD lpdwLogonType
    )
/*++
    This function retrieves the logon type associated with the
    access token specified by the hToken parameter.  On success,
    the DWORD buffer provided by the dwLogonType parameter is
    filled with the logon type which corresponds to the currently
    known logon types supported by the LogonUser() Windows NT
    API call.

    The token specified by the hToken parameter must have been
    opened with at least TOKEN_QUERY access.

    This function is only relevant on Windows NT and should not
    be called on Windows 95, as it will always return FALSE.

--*/
{
    UCHAR InfoBuffer[1024];
    DWORD dwInfoBufferSize = sizeof(InfoBuffer);
    PTOKEN_GROUPS SlowBuffer = NULL;
    PTOKEN_GROUPS ptgGroups = (PTOKEN_GROUPS)InfoBuffer;
    PSID psidInteractive = NULL;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    BOOL bSuccess;

    bSuccess = GetTokenInformation(
            hToken,
            TokenGroups,
            ptgGroups,
            dwInfoBufferSize,
            &dwInfoBufferSize
            );

    //
    // if fast buffer wasn't big enough, allocate enough storage
    // and try again.
    //

    if(!bSuccess && GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        SlowBuffer = (PTOKEN_GROUPS)SSAlloc(dwInfoBufferSize);
        if(SlowBuffer != NULL) {

            ptgGroups = SlowBuffer;
            bSuccess = GetTokenInformation(
                    hToken,
                    TokenGroups,
                    ptgGroups,
                    dwInfoBufferSize,
                    &dwInfoBufferSize
                    );

            if(!bSuccess) {
                SSFree(SlowBuffer);
                SlowBuffer = NULL;
            }
        }
    }

    if(!bSuccess)
        return FALSE;

    //
    // initialize a single well-known logon Sid, since
    // we only compare the prefix and then the Rid
    // note that if performance were of utmost importance, we should
    // use InitializeSid + GetSidSubAuthority (to _set_ the Rid).
    // also note that we could do a simple memcmp against just the sid
    // identifier authority, but this assumes that Sid versions/layouts don't
    // change
    //

    bSuccess = AllocateAndInitializeSid(
            &siaNtAuthority,
            1,
            SECURITY_INTERACTIVE_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidInteractive
            );

    if(bSuccess) {
        UINT x;

        bSuccess = FALSE; // assume no match

        //
        // loop through groups checking for equality against
        // the well-known logon Sids.
        //

        for(x = 0 ; x < ptgGroups->GroupCount ; x++)
        {
            DWORD Rid;

            //
            // first, see if subauthority count matches, since
            // not too many sids have only one subauthority.
            //

            if(*GetSidSubAuthorityCount(ptgGroups->Groups[x].Sid) != 1)
                continue;

            //
            // next, see if the Sid prefix matches, since
            // all the logon Sids have the same prefix
            // "S-1-5"
            //

            if(!EqualPrefixSid(psidInteractive, ptgGroups->Groups[x].Sid))
                continue;

            //
            // if it's a logon sid prefix, just compare the Rid
            // to the known values.
            //

            Rid = *GetSidSubAuthority(ptgGroups->Groups[x].Sid, 0);
            switch (Rid) {
                case SECURITY_INTERACTIVE_RID:
                    *lpdwLogonType = LOGON32_LOGON_INTERACTIVE;
                    break;

                case SECURITY_BATCH_RID:
                    *lpdwLogonType = LOGON32_LOGON_BATCH;
                    break;

                case SECURITY_SERVICE_RID:
                    *lpdwLogonType = LOGON32_LOGON_SERVICE;
                    break;

                case SECURITY_NETWORK_RID:
                    *lpdwLogonType = LOGON32_LOGON_NETWORK;
                    break;

                default:
                    continue;   // ignore unknown logon type and continue
            }

            bSuccess = TRUE;    // indicate success and bail
            break;
        }
    }

    if(SlowBuffer)
        SSFree(SlowBuffer);

    if(psidInteractive)
        FreeSid(psidInteractive);

    return bSuccess;
}

BOOL
SetPasswordNT(
    PLUID LogonID,
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    )

/*++

    This function adds the hashed password that is referenced by the specified
    Logon ID.

--*/

{
#if 0
    return AddNTPassword(LogonID, HashedPassword);
#else
    return TRUE; // do nothing, just return success
#endif
}


BOOL
GetPasswordNT(
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    )
/*++

    This function retrieves the hashed password associated with the calling
    thread access token.  This requires that the calling thread is impersonating
    the user associated with the password request.  The credentials associated
    with the authentication ID are returned.  This is done because WinNT
    supports multiple logged on users, and we must return the correct credentials.

--*/
{
#if 0
    LUID AuthenticationId;

    if(!GetThreadAuthenticationId(
            GetCurrentThread(),
            &AuthenticationId
            )) return FALSE;

    return FindNTPassword(&AuthenticationId, HashedPassword);
#else

    return FALSE; // no cache to search, just return FALSE

#endif

}

BOOL
GetSpecialCasePasswordNT(
    BYTE    HashedPassword[A_SHA_DIGEST_LEN],   // derived bits when fSpecialCase == TRUE
    LPBOOL  fSpecialCase                        // legal special case encountered?
    )
/*++

    This routine determines if the calling thread's access token is eligible
    to recieve a special case hashed password.

    If an legal special case is encountered (Local System Account), we
    fill the HashPassword buffer with an consistent hash, set fSpecialCase to
    TRUE, and return TRUE.

    If an illegal special case is encountered (Network SID), fSpecialCase is
    set FALSE, and we return FALSE.

    If we encounter an access token that appears to have valid credentials,
    but we have no way to get at them (Interactive, Batch, Service ... ),
    fSpecialCase is set FALSE and we return TRUE.

    The calling thread MUST be imperonsating the client in question prior to
    making this call.

--*/
{
    HANDLE hToken = NULL;
    DWORD dwLogonType;
    A_SHA_CTX context;
    BOOL fSuccess = FALSE;

    *fSpecialCase = FALSE;

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
        return FALSE;

    //
    // first, get the token logon type.
    //

    fSuccess = GetTokenLogonType(hToken, &dwLogonType);

    //
    // if we got the token logon type ok, check if it's an appropriate type.
    // otherwise, check for the local system special case.
    //

    if(fSuccess) {

        //
        // we only indicate success for the interactive logon type.
        // note default is fSuccess == TRUE when going to cleanup
        //

        if(dwLogonType != LOGON32_LOGON_INTERACTIVE)
            fSuccess = FALSE;

        goto cleanup;
    } else {

        SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
        PSID pSystemSid;
        PSID pTokenSid;

        fSuccess = GetTokenUserSid(hToken, &pTokenSid);
        if(!fSuccess)
            goto cleanup;


        //
        // build local system sid and compare.
        //

        fSuccess = AllocateAndInitializeSid(
                            &sia,
                            1,
                            SECURITY_LOCAL_SYSTEM_RID,
                            0, 0, 0, 0, 0, 0, 0,
                            &pSystemSid
                            );

        if( fSuccess ) {

            //
            // check sid equality.  If so, hash and tell the caller about it.
            //

            if( EqualSid(pSystemSid, pTokenSid) ) {

                //
                // hash the special case user Sid
                //

                A_SHAInit(&context);
                A_SHAUpdate(&context, (LPBYTE)pTokenSid, GetLengthSid(pTokenSid));
                A_SHAFinal(&context, HashedPassword);

                *fSpecialCase = TRUE;
            }

            FreeSid(pSystemSid);
        }

        SSFree(pTokenSid);
    }



cleanup:

    if(hToken)
        CloseHandle(hToken);

    return fSuccess;
}




BOOL
SetPassword95(
    BYTE HashedUsername[A_SHA_DIGEST_LEN],
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    )
/*++

    This function adds the hashed password that is referenced by the hashed
    user name.

    Set HashedUsername and HashedPassword to NULL when calling to zero-out
    the single password entry.

--*/
{
    if(HashedUsername == NULL || HashedPassword == NULL) {
        g_Win95Password.bValid = FALSE;
        ZeroMemory(g_Win95Password.HashedPassword, A_SHA_DIGEST_LEN);
        ZeroMemory(g_Win95Password.HashedUsername, A_SHA_DIGEST_LEN);

        return TRUE;
    }


    memcpy(g_Win95Password.HashedUsername, HashedUsername, A_SHA_DIGEST_LEN);
    memcpy(g_Win95Password.HashedPassword, HashedPassword, A_SHA_DIGEST_LEN);

    g_Win95Password.bValid = TRUE;

    return TRUE;
}


BOOL
GetPassword95(
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    )
/*++

    This function retrieves the hashed password associated with the calling
    thread.  In Win95, only one user is logged on, so this operation is
    a simple copy from global memory, once the hash of the current user
    matches that which was stored with the hashed credential.

--*/
{
    A_SHA_CTX context;
    BYTE HashUsername[A_SHA_DIGEST_LEN];
    CHAR Username[UNLEN+1];
    DWORD cchUsername = UNLEN;

    //
    // don't release credential unless hash of username matches
    // sfield: use WNetGetUser() instead of GetUserName() as WNetGetUser()
    // will correspond to the password associated with what the network
    // provider gave us.
    //

    if(_WNetGetUserA(NULL, Username, &cchUsername) != NO_ERROR) {

        //
        // for Win95, if nobody is logged on, empty user name + password
        //

        if(GetLastError() != ERROR_NOT_LOGGED_ON)
            return FALSE;

        Username[0] = '\0'; // not really necessary
        cchUsername = 1;
    } else {

        // arg, WNetGetUserA() doesn't fill in cchUsername
        cchUsername = lstrlenA(Username) + 1; // include terminal NULL
        if(g_Win95Password.bValid == FALSE)
            return FALSE;
    }

    cchUsername--; // do not include terminal NULL

    A_SHAInit(&context);
    A_SHAUpdate(&context, Username, cchUsername);
    A_SHAFinal(&context, HashUsername);

    //
    // non empty username, may not be empty password
    //

    if(cchUsername) {
        if(memcmp(HashUsername, g_Win95Password.HashedUsername, A_SHA_DIGEST_LEN) != 0) {
            //
            // rare case on Win95: if we didn't automatically flush the entry
            // during a logoff (this can occur if network provider not hooked),
            // flush it now because we know the entry cannot possibly be valid.
            //
            g_Win95Password.bValid = FALSE;
            return FALSE;
        }

        memcpy(HashedPassword, g_Win95Password.HashedPassword, A_SHA_DIGEST_LEN);

        return TRUE;
    }

    //
    // empty user name == empty password
    //

    memcpy(HashedPassword, HashUsername, A_SHA_DIGEST_LEN);

    return TRUE;
}


BOOL
VerifyWindowsPassword(
    LPCWSTR Password
    )
/*++
    This function verifies that the specified password matches that of the
    current user.

    On Windows 95, the current user equates to the user is currently logged
    onto the machine.

    On Windows NT, the current user equates to the user which is being
    impersonated during the call.  On Windows NT, the caller MUST be
    impersonating the user associated with the validation.

    On Windows NT, a side effect of the validation is notification of
    a new logon to the credential manager.  This is ignored because the
    authentication ID present in the new logon does not match the
    authentication ID present in the impersonated access token.

--*/
{
    if(FIsWinNT()) {
        return VerifyWindowsPasswordNT(Password);
    }
#ifdef WIN95_LEGACY
    else {
        return VerifyWindowsPassword95(Password);
    }
#endif  // WIN95_LEGACY

    return FALSE;
}

BOOL
VerifyWindowsPasswordNT(
    LPCWSTR Password
    )
{
    HANDLE hPriorToken = NULL;
    HANDLE hToken;
    HANDLE hLogonToken = NULL;
    PTOKEN_USER pTokenInfo = NULL;
    DWORD cbTokenInfoSize;
    WCHAR User[UNLEN+1];
    WCHAR Domain[DNLEN+1];
    DWORD cchUser = UNLEN;
    DWORD cchDomain = DNLEN;
    SID_NAME_USE peUse;
    BOOL bSuccess = FALSE;

    //
    // find out domain and user name associated with current user
    //

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
        return FALSE;

    cbTokenInfoSize = 512;
    pTokenInfo = (PTOKEN_USER)SSAlloc(cbTokenInfoSize);
    if(pTokenInfo == NULL)
        goto cleanup;

    if(!GetTokenInformation(
            hToken,
            TokenUser,
            pTokenInfo,
            cbTokenInfoSize,
            &cbTokenInfoSize
            )) {

        //
        // realloc and try again
        //

        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            pTokenInfo = (PTOKEN_USER)SSReAlloc(pTokenInfo, cbTokenInfoSize);
            if(pTokenInfo == NULL)
                goto cleanup;

            if(!GetTokenInformation(
                hToken,
                TokenUser,
                pTokenInfo,
                cbTokenInfoSize,
                &cbTokenInfoSize
                )) {
                goto cleanup;
            }

        } else {
            goto cleanup;
        }
    }

    if(!LookupAccountSidW(
            NULL, // default lookup logic
            pTokenInfo->User.Sid,
            User,
            &cchUser,
            Domain,
            &cchDomain,
            &peUse
            ))
        goto cleanup;


    //
    // WinNT:
    // first try network logon type, if that fails, grovel the token
    // and try the same logon type which is associated with the impersonation
    // token.
    //


    //
    // arg! LogonUser() fails in some cases if we are impersonating!
    // so save off impersonation token, revert, and put it back later.
    //

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &hPriorToken)) {
        hPriorToken = NULL;
    } else {
        RevertToSelf();
    }

    //
    // network logon type is fastest, and in default NT install, everyone
    // has the SeNetworkLogonRight, so it's very likely to pass the logon right
    // test
    //

    if(!LogonUserW(
            User,
            Domain,
            (LPWSTR)Password,
            LOGON32_LOGON_NETWORK,
            LOGON32_PROVIDER_DEFAULT,
            &hLogonToken
            )) {

        DWORD dwLastError = GetLastError();
        DWORD dwLogonType;

        //
        // retry with different logon type if necessary.
        // note: ERROR_LOGON_TYPE_NOT_GRANTED currently only occurs
        // if the password matches but user didn't have specified logon
        // type.  So, currently, we could treat this as a successful validation
        // without retrying, but this is subject to change in future, so retry
        // anyway.
        //

        if( dwLastError == ERROR_LOGON_TYPE_NOT_GRANTED &&
            GetTokenLogonType(hPriorToken, &dwLogonType)
            ) {

            bSuccess = LogonUserW(
                    User,
                    Domain,
                    (LPWSTR)Password,
                    dwLogonType,
                    LOGON32_PROVIDER_DEFAULT,
                    &hLogonToken
                    );
        }

        if(!bSuccess)
            hLogonToken = NULL; // LogonUser() has tendency to leave garbage in hToken

        goto cleanup;
    }

    bSuccess = TRUE;

cleanup:

    if(hPriorToken != NULL) {
        SetThreadToken(NULL, hPriorToken);
        CloseHandle(hPriorToken);
    }

    CloseHandle(hToken);

    if(hLogonToken)
        CloseHandle(hLogonToken);

    if(pTokenInfo)
        SSFree(pTokenInfo);

    return bSuccess;
}

#ifdef WIN95_LEGACY

BOOL
VerifyWindowsPassword95(
    LPCWSTR Password
    )
{
    HMODULE hMprModule;
    WNETVERIFYPASSWORD _WNetVerifyPassword;

    CHAR PasswordANSI[PWLEN+1];
    DWORD cchPassword;
    BOOL bSuccess = FALSE;

    hMprModule = LoadLibraryA("mpr.dll");
    if(hMprModule == NULL)
        return FALSE;

    _WNetVerifyPassword = (WNETVERIFYPASSWORD)GetProcAddress(hMprModule, "WNetVerifyPasswordA");
    if(_WNetVerifyPassword == NULL)
        goto cleanup;

    cchPassword = wcslen(Password);

    if(cchPassword == 0) {
        PasswordANSI[0] = '\0';
    } else {

        if(WideCharToMultiByte(
                CP_ACP,
                0,
                Password,
                cchPassword + 1, // include terminal null in conversion
                PasswordANSI,
                PWLEN,
                NULL,
                NULL
                ) == 0)
            goto cleanup;
    }

    if(_WNetVerifyPassword(PasswordANSI, &bSuccess) != WN_SUCCESS)
        bSuccess = FALSE;

    ZeroMemory(PasswordANSI, sizeof(PasswordANSI));

cleanup:

    FreeLibrary(hMprModule);

    return bSuccess;
}

BOOL
GetHackPassword95(
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    )
/*++

    This funtion grovels the MPR address space and attempts to get the
    PWL (all-uppercased) password.

    If the verification fails against the PWL password, and the PWL password
    is NULL, we grab the Global password, upper-case it, and try that.

    The password is hashed and the result is returned to the caller in the
    buffer specified by the HashedPassword parameter.

--*/
{
    HANDLE hProcessMPR;
    DWORD dwProcessId;
    DWORD_PTR dwBaseAddress;
    DWORD dwUseCount; // unused.
    DWORD_PTR dwBaseAddressDataSection;

    CHAR szPWLPassword[PWLEN+1];
    WCHAR wszPassword[PWLEN+1];

    BOOL fTryGlobalPassword = FALSE; // fallback and attempt via Global password?
    BOOL fSuccess = FALSE;

    if(!GetProcessIdFromPath95(MPR_PROCESS, &dwProcessId))
        return FALSE;

    if(!GetBaseAddressModule95(dwProcessId, MPRSERV_MODULE, &dwBaseAddress, &dwUseCount))
        return FALSE;

    hProcessMPR = OpenProcess(PROCESS_VM_READ, 0, dwProcessId);
    if(hProcessMPR == NULL)
        return FALSE;

    //
    // paranoid thing we could do, but isn't necessary: compute the offset
    // of the .data section within the MPRSERV.DLL.  We observed it to be
    // 0x00014000, so that won't change for a while.
    //

    dwBaseAddressDataSection = dwBaseAddress + 0x00014000;

    if(GetDataMPR(
            hProcessMPR,
            dwBaseAddressDataSection,
            PWL_PASSWORD,
            szPWLPassword,
            sizeof(szPWLPassword)
            )) {

        do {

            A_SHA_CTX context;
            DWORD cchPassword; // includes terminal null
            DWORD cchPasswordW;

            //
            // get length of returned buffer, and insure that it's null terminated
            // within the boundries of the buffer.
            //

            __try {
                cchPassword = lstrlenA(szPWLPassword) + 1;
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                cchPassword = 0xFFFFFFFF;
            }

            if(cchPassword > sizeof(szPWLPassword))
                break;

            //
            // convert the ANSI string to Unicode
            //

            cchPasswordW = MultiByteToWideChar(
                    CP_ACP,
                    0,
                    szPWLPassword,
                    cchPassword,
                    wszPassword,
                    sizeof(wszPassword) / sizeof(WCHAR)
                    );

            if(cchPasswordW == 0)
                break;

            cchPasswordW--; // drop trailing NULL from count.

            //
            // verify the Unicode string is the correct password
            //

            if(!VerifyWindowsPassword(wszPassword)) {

                //
                // try the global password if the PWL was NULL
                //

                if(cchPasswordW == 0) {
                    fTryGlobalPassword = TRUE;
                }

                break;
            }

            //
            // hash the Unicode string
            //

            A_SHAInit(&context);
            A_SHAUpdate(&context, (unsigned char *)wszPassword, cchPasswordW * sizeof(WCHAR));
            A_SHAFinal(&context, HashedPassword);

            ZeroMemory(&context, sizeof(context));

            fSuccess = TRUE;
        } while (FALSE);
    }

    ZeroMemory(szPWLPassword, sizeof(szPWLPassword));
    ZeroMemory(wszPassword, sizeof(wszPassword));

    //
    // if it failed against the PWL password, try the global password if
    // appropriate.
    //

    if( fTryGlobalPassword && !fSuccess ) {
        fSuccess = GetHackPassword95Global(hProcessMPR, dwBaseAddress, HashedPassword);
    }

    CloseHandle( hProcessMPR );

    return fSuccess;
}

BOOL
GetHackPassword95Global(
    HANDLE hProcess,                        // handle to MPREXE.EXE
    DWORD_PTR dwBaseAddress,                    // base address where MPRSERV loaded
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    )
/*++

    This function grovels the MPR address space in order to obtain the Global
    Password.  On success, the Global password is upper-cased, converted to
    Unicode, and then hashed via SHA-1.  The resultant hash is returned to the
    caller via the supplied HashedPassword buffer.

--*/
{
    DWORD_PTR dwBaseAddressDataSection;
    CHAR szGlobalPassword[128+1];
    CHAR szPWLPassword[PWLEN+1];
    WCHAR wszPassword[PWLEN+1];

    BOOL fSuccess = FALSE;

    //
    // paranoid thing we could do, but isn't necessary: compute the offset
    // of the .data section within the MPRSERV.DLL.  We observed it to be
    // 0x00014000, so that won't change for a while.
    //

    dwBaseAddressDataSection = dwBaseAddress + 0x00014000;

    if(GetDataMPR(
            hProcess,
            dwBaseAddressDataSection,
            GLOBAL_PASSWORD,
            szGlobalPassword,
            sizeof(szGlobalPassword)
            )) {

        //
        // null terminate global password at LanMan limit
        //

        if(PWLEN < sizeof(szGlobalPassword))
            szGlobalPassword[ PWLEN ] = '\0';

        do {

            A_SHA_CTX context;
            DWORD cchPassword; // includes terminal null
            DWORD cchPasswordW;

            //
            // get length of returned buffer, and insure that it's null terminated
            // within the boundries of the buffer.
            //

            __try {
                cchPassword = lstrlenA(szGlobalPassword) + 1;
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                cchPassword = 0xFFFFFFFF;
            }

            if(cchPassword > sizeof(szGlobalPassword))
                break;

            // cnvt all Win95 pwds to uppercase
            cchPassword =
                LCMapStringA(
                    LOCALE_SYSTEM_DEFAULT,
                    LCMAP_UPPERCASE,
                    szGlobalPassword,
                    cchPassword,    // include NULL
                    szPWLPassword,
                    sizeof(szPWLPassword)
                    );


            //
            // convert the ANSI string to Unicode
            //

            cchPasswordW = MultiByteToWideChar(
                    CP_ACP,
                    0,
                    szPWLPassword,
                    cchPassword,
                    wszPassword,
                    sizeof(wszPassword) / sizeof(WCHAR)
                    );

            if(cchPasswordW == 0)
                break;

            cchPasswordW--; // drop trailing NULL from count.

            //
            // verify the Unicode string is the correct password
            //

            if(!VerifyWindowsPassword(wszPassword))
                break;

            //
            // hash the Unicode string
            //

            A_SHAInit(&context);
            A_SHAUpdate(&context, (unsigned char *)wszPassword, cchPasswordW * sizeof(WCHAR));
            A_SHAFinal(&context, HashedPassword);

            ZeroMemory(&context, sizeof(context));

            fSuccess = TRUE;
        } while (FALSE);
    }

    return fSuccess;
}


BOOL
GetDataMPR(
    IN  HANDLE hProcessMPR,
    IN  DWORD_PTR dwBaseAddressDataSection,
    IN  DWORD dwType,
    IN  LPSTR szBuffer,
    IN  DWORD cbBuffer
    )
{
    DWORD cbBytesRead;

    if( dwType != GLOBAL_USERNAME && dwType != PWL_USERNAME &&
        dwType != GLOBAL_PASSWORD && dwType != PWL_PASSWORD
        ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return ReadProcessMemory(
            hProcessMPR,
            ((LPBYTE)dwBaseAddressDataSection + dwType),
            szBuffer,
            cbBuffer,
            &cbBytesRead
            );

}

#endif  // WIN95_LEGACY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\certtest\certtest.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       certtest.cpp
//
//  Contents:   Certificate Test Helper APIs
//
//  History:	11-Apr-96   philh   created
//				31-May-96	helles	Removed check for a particular error code,
//									NTE_PROV_TYPE_NOT_DEF, since this can get
//									overwritten due to known problem with
//									the msvcr40d.dll on Win95.
//              20-Aug-96   jeffspel name changes
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "certtest.h"
#include "cryptuiapi.h"
#include "spc.h"
#include "setcert.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <stddef.h>

DWORD dwCertEncodingType = X509_ASN_ENCODING;
DWORD dwMsgEncodingType = PKCS_7_ASN_ENCODING;
DWORD dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;

#define NULL_ASN_TAG    0x05

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
void PrintError(LPCSTR pszMsg)
{
    printf("%s\n", pszMsg);
}
void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

LPCSTR FileTimeText(FILETIME *pft)
{
    static char buf[80];
    FILETIME ftLocal;
    struct tm ctm;
    SYSTEMTIME st;

    FileTimeToLocalFileTime(pft, &ftLocal);
    if (FileTimeToSystemTime(&ftLocal, &st))
    {
        ctm.tm_sec = st.wSecond;
        ctm.tm_min = st.wMinute;
        ctm.tm_hour = st.wHour;
        ctm.tm_mday = st.wDay;
        ctm.tm_mon = st.wMonth-1;
        ctm.tm_year = st.wYear-1900;
        ctm.tm_wday = st.wDayOfWeek;
        ctm.tm_yday  = 0;
        ctm.tm_isdst = 0;
        strcpy(buf, asctime(&ctm));
        buf[strlen(buf)-1] = 0;

        if (st.wMilliseconds) {
            char *pch = buf + strlen(buf);
            sprintf(pch, " <milliseconds:: %03d>", st.wMilliseconds);
        }
    }
    else
        sprintf(buf, "<FILETIME %08lX:%08lX>", pft->dwHighDateTime,
                pft->dwLowDateTime);
    return buf;
}

#define CROW 16
void PrintBytes(LPCSTR pszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;

    if (cbSize == 0) {
        printf("%s NO Value Bytes\n", pszHdr);
        return;
    }

    while (cbSize > 0)
    {
        printf("%s", pszHdr);
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            printf(" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        pb += cb;
        printf("'\n");
    }
}

//+-------------------------------------------------------------------------
//  Test allocation and free routines
//--------------------------------------------------------------------------
LPVOID
WINAPI
TestAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
    pv = malloc(cbBytes);
    if (pv == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("TestAlloc");
    }
    return pv;
}

LPVOID
WINAPI
TestRealloc(
    IN LPVOID pvOrg,
    IN size_t cbBytes
    )
{
    LPVOID pv;
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cbBytes) : malloc(cbBytes))) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("TestAlloc");
    }
    return pv;
}

VOID
WINAPI
TestFree(
    IN LPVOID pv
    )
{
    if (pv)
        free(pv);
}

//+-------------------------------------------------------------------------
//  Allocate and convert a multi-byte string to a wide string
//--------------------------------------------------------------------------
LPWSTR AllocAndSzToWsz(LPCSTR psz)
{
    size_t  cb;
    LPWSTR  pwsz = NULL;

    if (-1 == (cb = mbstowcs( NULL, psz, strlen(psz))))
        goto bad_param;
    cb += 1;        // terminating NULL
    if (NULL == (pwsz = (LPWSTR)TestAlloc( cb * sizeof(WCHAR)))) {
        PrintLastError("AllocAndSzToWsz");
        goto failed;
    }
    if (-1 == mbstowcs( pwsz, psz, cb))
        goto bad_param;
    goto common_return;

bad_param:
    PrintError("Bad AllocAndSzToWsz");
failed:
    if (pwsz) {
        TestFree(pwsz);
        pwsz = NULL;
    }
common_return:
    return pwsz;
}

static CRYPT_DECODE_PARA TestDecodePara = {
    offsetof(CRYPT_DECODE_PARA, pfnFree) + sizeof(TestDecodePara.pfnFree),
    TestAlloc,
    TestFree
};

static void *TestNoCopyDecodeObject(
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbStructInfo = NULL
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG,
            &TestDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    if (pcbStructInfo)
        *pcbStructInfo = cbStructInfo;
    return pvStructInfo;

ErrorReturn:
    if ((DWORD_PTR) lpszStructType <= 0xFFFF)
        printf("CryptDecodeObject(StructType: %d)",
            (DWORD)(DWORD_PTR) lpszStructType);
    else
        printf("CryptDecodeObject(StructType: %s)",
            lpszStructType);
    PrintLastError("");

    pvStructInfo = NULL;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Allocate and read an encoded DER blob from a file
//--------------------------------------------------------------------------
BOOL ReadDERFromFile(
    LPCSTR  pszFileName,
    PBYTE   *ppbDER,
    PDWORD  pcbDER
    )
{
    BOOL        fRet;
    HANDLE      hFile = 0;
    PBYTE       pbDER = NULL;
    DWORD       cbDER;
    DWORD       cbRead;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile( pszFileName, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        printf( "can't open %s\n", pszFileName);
        goto ErrorReturn;
    }

    cbDER = GetFileSize( hFile, NULL);
    if (cbDER == 0) {
        printf( "empty file %s\n", pszFileName);
        goto ErrorReturn;
    }
    if (NULL == (pbDER = (PBYTE)TestAlloc(cbDER))) {
        printf( "can't alloc %d bytes\n", cbDER);
        goto ErrorReturn;
    }
    if (!ReadFile( hFile, pbDER, cbDER, &cbRead, NULL) ||
            (cbRead != cbDER)) {
        printf( "can't read %s\n", pszFileName);
        goto ErrorReturn;
    }

    *ppbDER = pbDER;
    *pcbDER = cbDER;
    fRet = TRUE;
CommonReturn:
    if (hFile)
        CloseHandle(hFile);
    return fRet;
ErrorReturn:
    if (pbDER)
        TestFree(pbDER);
    *ppbDER = NULL;
    *pcbDER = 0;
    fRet = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
BOOL WriteDERToFile(
    LPCSTR  pszFileName,
    PBYTE   pbDER,
    DWORD   cbDER
    )
{
    BOOL fResult;

    // Write the Encoded Blob to the file
    HANDLE hFile;
    hFile = CreateFile(pszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        fResult = FALSE;
        PrintLastError("WriteDERToFile::CreateFile");
    } else {
        DWORD dwBytesWritten;
        if (!(fResult = WriteFile(
                hFile,
                pbDER,
                cbDER,
                &dwBytesWritten,
                NULL            // lpOverlapped
                )))
            PrintLastError("WriteDERToFile::WriteFile");
        CloseHandle(hFile);
    }
    return fResult;
}

HCRYPTPROV GetCryptProvEx(BOOL fVerbose)
{
    HCRYPTPROV hProv = 0;
    BOOL fResult;

    // First, try the STT payment server provider
    DWORD dwCryptProvType = PROV_STT_ACQ;

    fResult = CryptAcquireContext(
                &hProv,
                NULL,           // pszContainer
                NULL,           // pszProvider
                dwCryptProvType,
                0               // dwFlags
                );
//	Removed check for a particular error code,
//  NTE_PROV_TYPE_NOT_DEF, since this can get overwritten due to known  
//	problem with the msvcr40d.dll on Win95. 
//    if (!fResult && GetLastError() == NTE_PROV_TYPE_NOT_DEF) {
    if (!fResult) {
        // Try the default provider
        dwCryptProvType = PROV_RSA_FULL;
        fResult = CryptAcquireContext(
                    &hProv,
                    NULL,
                    NULL,           // pszProvider
                    dwCryptProvType,
                    0               // dwFlags
                    );
    }
    if (fResult) {
        if (fVerbose)
            printf("Using default sign and xchg keys for provider: %d\n",
                dwCryptProvType);
    } else {
        DWORD dwErr = GetLastError();
        if (dwErr == NTE_BAD_KEYSET) {

            // Need to create the keys
            printf("Generating SIGNATURE and EXCHANGE private keys\n");

            hProv = 0;
            fResult = CryptAcquireContext(
                    &hProv,
                    NULL,           // pszContainer
                    NULL,           // pszProvider
                    dwCryptProvType,
                    CRYPT_NEWKEYSET
                    );
            if (!fResult || hProv == 0) {
                PrintLastError("CryptAcquireContext");
                return 0;
            }

            HCRYPTKEY hKey = 0;
            fResult = CryptGenKey(
                    hProv,
                    AT_SIGNATURE,
                    CRYPT_EXPORTABLE,
                    &hKey
                    );
            if (!fResult || hKey == 0)
                PrintLastError("CryptGenKey(AT_SIGNATURE)");
            else
                CryptDestroyKey(hKey);

            hKey = 0;
            fResult = CryptGenKey(
                    hProv,
                    AT_KEYEXCHANGE,
                    CRYPT_EXPORTABLE,
                    &hKey
                    );
            if (!fResult || hKey == 0)
                PrintLastError("CryptGenKey(AT_KEYEXCHANGE)");
            else
                CryptDestroyKey(hKey);

        } else {
            PrintLastError("CryptAcquireContext");
            return 0;
        }
    }
    return hProv;
}

HCRYPTPROV GetCryptProv() {
    return GetCryptProvEx(TRUE);
}


static HKEY OpenRelocateKey(
    IN OUT LPCSTR *ppszStoreFilename,
    IN DWORD dwFlags
    )
{
    LPCSTR pszStoreFilename = *ppszStoreFilename;
    HKEY hKeyRelocate;
    char szRelocate[256];
    LPCSTR pszRelocate;
    int i = 0;
    HKEY hKeyBase;
    LONG err;

    // Use the following characters until the terminating ":" as the
    // relocation path
    while ('\0' != *pszStoreFilename && ':' != *pszStoreFilename) {
        if (i >= sizeof(szRelocate) - 1)
            break;
        szRelocate[i++] = *pszStoreFilename++;
    }

    if (':' == *pszStoreFilename)
        pszStoreFilename++;
    szRelocate[i] = '\0';
    *ppszStoreFilename = pszStoreFilename;


    if (0 == _stricmp(szRelocate, "NULL")) {
        return NULL;
    } else if (0 == _strnicmp(szRelocate, "HKCU", 4)) {
        hKeyRelocate = HKEY_CURRENT_USER;
        pszRelocate = szRelocate+4;
        if ('\\' == *pszRelocate)
            pszRelocate++;
    } else if (0 == _strnicmp(szRelocate, "HKLM", 4)) {
        hKeyRelocate = HKEY_LOCAL_MACHINE;
        pszRelocate = szRelocate+4;
        if ('\\' == *pszRelocate)
            pszRelocate++;
    } else {
        hKeyRelocate = HKEY_CURRENT_USER;
        pszRelocate = szRelocate;
    }

    if (dwFlags & (CERT_STORE_READONLY_FLAG | CERT_STORE_OPEN_EXISTING_FLAG)) {
        REGSAM samDesired;
        if (dwFlags & CERT_STORE_READONLY_FLAG)
            samDesired = KEY_READ;
        else
            samDesired = KEY_ALL_ACCESS;

        if (ERROR_SUCCESS != (err = RegOpenKeyExA(
                hKeyRelocate,
                pszRelocate,
                0,                      // dwReserved
                samDesired,
                &hKeyBase))) {
            printf("RegOpenKeyExA(%s) failed => %d 0x%x\n",
                pszRelocate, err, err);
            hKeyBase = NULL;
        }
    } else {
        DWORD dwDisposition;
        if (ERROR_SUCCESS != (err = RegCreateKeyExA(
                hKeyRelocate,
                pszRelocate,
                0,                      // dwReserved
                NULL,                   // lpClass
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,                   // lpSecurityAttributes
                &hKeyBase,
                &dwDisposition))) {
            printf("RegCreateKeyExA(%s) failed => %d 0x%x\n",
                pszRelocate, err, err);
            hKeyBase = NULL;
        }
    }

    return hKeyBase;
}

// LastError can get globbered when doing remote registry access
static void CloseRelocateKey(
    IN HKEY hKey
    )
{
    if (hKey) {
        DWORD dwErr = GetLastError();
        LONG RegCloseKeyStatus;
        RegCloseKeyStatus = RegCloseKey(hKey);
        assert(ERROR_SUCCESS == RegCloseKeyStatus);
        SetLastError(dwErr);
    }
}

typedef struct _SYSTEM_LOCATION_INFO {
    LPCSTR      pszPrefix;
    DWORD       dwStoreLocation;
} SYSTEM_LOCATION_INFO;


static SYSTEM_LOCATION_INFO rgSystemLocationInfo[] = {
    "LocalMachine:", CERT_SYSTEM_STORE_LOCAL_MACHINE,
    "LM:", CERT_SYSTEM_STORE_LOCAL_MACHINE,
    "Services:", CERT_SYSTEM_STORE_SERVICES,
    "Users:", CERT_SYSTEM_STORE_USERS,
    "CurrentService:", CERT_SYSTEM_STORE_CURRENT_SERVICE,
    "CS:", CERT_SYSTEM_STORE_CURRENT_SERVICE,
    "CurrentUser:", CERT_SYSTEM_STORE_CURRENT_USER,
    "CU:", CERT_SYSTEM_STORE_CURRENT_USER,
    "CUGP:", CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY,
    "LMGP:", CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY,
    "Enterprise:", CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE,
    "EP:", CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
};
#define NUM_SYSTEM_LOCATION (sizeof(rgSystemLocationInfo) / \
                                sizeof(rgSystemLocationInfo[0]))

// returns NULL if unable to open. Doesn't open memory store.
HCERTSTORE OpenStoreEx2(BOOL fSystemStore, LPCSTR pszStoreFilename,
    DWORD dwFlags)
{
    HCERTSTORE hStore = NULL;

    if (fSystemStore) {
        DWORD i;

        // Check for special System Location Prefix. If found, strip off,
        // set store location and try again
        for (i = 0; i < NUM_SYSTEM_LOCATION; i++) {
            LPCSTR pszPrefix = rgSystemLocationInfo[i].pszPrefix;
            DWORD cchPrefix = strlen(pszPrefix);
            if (0 == _strnicmp(pszPrefix, pszStoreFilename, cchPrefix)) {
                if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
                    dwFlags |= rgSystemLocationInfo[i].dwStoreLocation;
                return OpenStoreEx2(TRUE, pszStoreFilename + cchPrefix,
                    dwFlags);
            }
        }

        // Check for special "archived:" Prefix. If found, strip off and
        // set ENUM_ARCHIVE flag and try again
        if (0 == _strnicmp("archived:", pszStoreFilename, 9)) {
            dwFlags |= CERT_STORE_ENUM_ARCHIVED_FLAG;
            return OpenStoreEx2(TRUE, pszStoreFilename + 9,
                dwFlags);
        }

        // Check for special "reg:", "unprotected:",  "phy:", "prov:ProvName:",
        // "rel:<RegPath>:", "relreg:<RegPath>:" or "relphy:<RegPath>:" prefix
        //
        // Where <RegPath> is <string>, HKCU\<string>, HKLM\<string> or
        // NULL. <string> defaults to HKCU.
        if (0 == _strnicmp("reg:", pszStoreFilename, 4)) {
            if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
                dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
            hStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_REGISTRY_A,
                    dwCertEncodingType | dwMsgEncodingType,
                    0,                      // hCryptProv
                    dwFlags,
                    (const void *) (pszStoreFilename + 4)
                    );
        } else if (0 == _strnicmp("unprotected:", pszStoreFilename, 12)) {
            if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
                dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
            hStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_REGISTRY_A,
                    dwCertEncodingType | dwMsgEncodingType,
                    0,                      // hCryptProv
                    dwFlags | CERT_SYSTEM_STORE_UNPROTECTED_FLAG,
                    (const void *) (pszStoreFilename + 12)
                    );
        } else if (0 == _strnicmp("phy:", pszStoreFilename, 4)) {
            LPWSTR pwszStore;

            if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
                dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
            if (pwszStore = AllocAndSzToWsz(pszStoreFilename + 4)) {
                hStore = CertOpenStore(
                        CERT_STORE_PROV_PHYSICAL,
                        dwCertEncodingType | dwMsgEncodingType,
                        0,                      // hCryptProv
                        dwFlags,
                        (const void *) pwszStore
                        );
                TestFree(pwszStore);
            }
        } else if (0 == _strnicmp("prov:", pszStoreFilename, 5)) {
            LPWSTR pwszStore;
            char ch;
            char szStoreProvider[256];
            int i = 0;
            
            // Advance past "prov:"
            pszStoreFilename += 5;

            // Use the following characters until the terminating ":" as the
            // store provider
            while ('\0' != *pszStoreFilename && ':' != *pszStoreFilename) {
                if (i >= sizeof(szStoreProvider) - 1)
                    break;
                szStoreProvider[i++] = *pszStoreFilename++;
            }

            if (':' == *pszStoreFilename)
                pszStoreFilename++;
            szStoreProvider[i] = '\0';

            if (pwszStore = AllocAndSzToWsz(pszStoreFilename)) {
                hStore = CertOpenStore(
                        szStoreProvider,
                        dwCertEncodingType | dwMsgEncodingType,
                        0,                      // hCryptProv
                        dwFlags,
                        (const void *) pwszStore
                        );
                TestFree(pwszStore);
            }
        } else if (0 == _strnicmp("rel:", pszStoreFilename, 4)) {
            CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

            pszStoreFilename += 4;
            RelocatePara.hKeyBase = OpenRelocateKey(&pszStoreFilename, dwFlags);
            RelocatePara.pszSystemStore = pszStoreFilename;

            if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
                dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
            dwFlags |= CERT_SYSTEM_STORE_RELOCATE_FLAG;

            hStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_A,
                    dwCertEncodingType | dwMsgEncodingType,
                    0,                      // hCryptProv
                    dwFlags,
                    (const void *) &RelocatePara
                    );
            CloseRelocateKey(RelocatePara.hKeyBase);
        } else if (0 == _strnicmp("relsys:", pszStoreFilename, 7)) {
            CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

            pszStoreFilename += 7;
            RelocatePara.hKeyBase = OpenRelocateKey(&pszStoreFilename, dwFlags);
            RelocatePara.pszSystemStore = pszStoreFilename;

            if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
                dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
            dwFlags |= CERT_SYSTEM_STORE_RELOCATE_FLAG;

            hStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_REGISTRY_A,
                    dwCertEncodingType | dwMsgEncodingType,
                    0,                      // hCryptProv
                    dwFlags,
                    (const void *) &RelocatePara
                    );
            CloseRelocateKey(RelocatePara.hKeyBase);
        } else if (0 == _strnicmp("relphy:", pszStoreFilename, 7)) {
            LPWSTR pwszStore;
            CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

            pszStoreFilename += 7;
            RelocatePara.hKeyBase = OpenRelocateKey(&pszStoreFilename, dwFlags);

            if (pwszStore = AllocAndSzToWsz(pszStoreFilename)) {
                RelocatePara.pwszSystemStore = pwszStore;

                if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
                    dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
                dwFlags |= CERT_SYSTEM_STORE_RELOCATE_FLAG;

                hStore = CertOpenStore(
                        CERT_STORE_PROV_PHYSICAL_W,
                        dwCertEncodingType | dwMsgEncodingType,
                        0,                      // hCryptProv
                        dwFlags,
                        (const void *) &RelocatePara
                        );
                TestFree(pwszStore);
            }
            CloseRelocateKey(RelocatePara.hKeyBase);
        } else if (0 != (dwFlags & ~CERT_STORE_SET_LOCALIZED_NAME_FLAG)) {
            if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
                dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
            hStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_A,
                    dwCertEncodingType | dwMsgEncodingType,
                    0,                      // hCryptProv
                    dwFlags,
                    (const void *) pszStoreFilename
                    );
        } else
            hStore = CertOpenSystemStore(NULL, pszStoreFilename);

    } else
        hStore = CertOpenStore(
                CERT_STORE_PROV_FILENAME_A,
                dwCertEncodingType | dwMsgEncodingType,
                0,                      // hCryptProv
                dwFlags,
                (const void *) pszStoreFilename
                );

    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        if (NULL != hStore)
            printf(
                "failed => CERT_STORE_DELETE_FLAG returned non-NULL hStore\n");
        else {
            if (0 == GetLastError())
                printf("Successful delete store\n");
            else
                PrintLastError("CertOpenStore(CERT_STORE_DELETE_FLAG)");
        }

        hStore = NULL;
    } else if (NULL == hStore) {
        DWORD dwErr = GetLastError();
        printf("NULL OpenStoreEx %d 0x%x\n", dwErr, dwErr);
    } else {
        if (dwFlags & CERT_STORE_SET_LOCALIZED_NAME_FLAG) {
            LPWSTR pwszLocalizedName;
            DWORD cbLocalizedName;

            if (!CertGetStoreProperty(
                    hStore,
                    CERT_STORE_LOCALIZED_NAME_PROP_ID,
                    NULL,
                    &cbLocalizedName
                    )) {
                if (CRYPT_E_NOT_FOUND == GetLastError())
                    printf("No localized store name property\n");
                else
                    PrintLastError("CertGetStoreProperty");
            } else if (pwszLocalizedName = (LPWSTR) TestAlloc(
                    cbLocalizedName)) {
                if (!CertGetStoreProperty(
                        hStore,
                        CERT_STORE_LOCALIZED_NAME_PROP_ID,
                        pwszLocalizedName,
                        &cbLocalizedName
                        ))
                    PrintLastError("CertGetStoreProperty");
                else
                    printf("Localized Store Name:: %S\n", pwszLocalizedName);
                TestFree(pwszLocalizedName);
            }
        }

        DWORD dwAccessStateFlags;
        DWORD cbData = sizeof(dwAccessStateFlags);

        CertGetStoreProperty(
            hStore,
            CERT_ACCESS_STATE_PROP_ID,
            &dwAccessStateFlags,
            &cbData
            );
        if (0 == cbData)
            printf("No Store AccessState PropId\n");
        else {
            printf("Store AccessState PropId dwFlags:: 0x%x",
                dwAccessStateFlags);
            if (dwAccessStateFlags & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG)
                printf(" WRITE_PERSIST");
            if (dwAccessStateFlags & CERT_ACCESS_STATE_SYSTEM_STORE_FLAG)
                printf(" SYSTEM_STORE");
            printf("\n");
        }
    }
    return hStore;
}

HCERTSTORE OpenSystemStoreOrFile(BOOL fSystemStore, LPCSTR pszStoreFilename,
    DWORD dwFlags)
{
    HCERTSTORE hStore;

    hStore = OpenStoreEx2(fSystemStore, pszStoreFilename, dwFlags);
    if (hStore == NULL) {
        DWORD dwErr = GetLastError();
        printf( "can't open %s\n", pszStoreFilename);
        SetLastError(dwErr);
        PrintLastError("CertOpenStore");
    }
    return hStore;
}

HCERTSTORE OpenStoreEx(BOOL fSystemStore, LPCSTR pszStoreFilename,
    DWORD dwFlags)
{
    HCERTSTORE hStore;
    hStore = OpenStoreEx2(fSystemStore, pszStoreFilename, dwFlags);

    if (hStore == NULL) {
        printf( "can't open %s\n", pszStoreFilename);
        hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            );
    }

    if (hStore == NULL)
        PrintLastError("CertOpenStore");

    return hStore;
}

HCERTSTORE OpenStore(BOOL fSystemStore, LPCSTR pszStoreFilename)
{
    return OpenStoreEx(fSystemStore, pszStoreFilename, 0);
}

HCERTSTORE OpenStoreOrSpc(BOOL fSystemStore, LPCSTR pszStoreFilename,
    BOOL *pfSpc)
{
    *pfSpc = FALSE;
    return OpenStore(fSystemStore, pszStoreFilename);
}


void SaveStore(HCERTSTORE hStore, LPCSTR pszSaveFilename)
{
    HANDLE hFile;
    hFile = CreateFile(pszSaveFilename,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        printf( "can't open %s\n", pszSaveFilename);
        PrintLastError("CloseStore::CreateFile");
    } else {
        printf("Saving store to %s\n", pszSaveFilename);
        if (!CertSaveStore(
                hStore,
                0,                          // dwEncodingType,
                CERT_STORE_SAVE_AS_STORE,
                CERT_STORE_SAVE_TO_FILE,
                (void *) hFile,
                0                           // dwFlags
                ))
            PrintLastError("CertSaveStore");
        CloseHandle(hFile);
    }
}

void SaveStoreEx(HCERTSTORE hStore, BOOL fPKCS7Save, LPCSTR pszSaveFilename)
{
    DWORD dwSaveAs;
    if (fPKCS7Save) {
        dwSaveAs = CERT_STORE_SAVE_AS_PKCS7;
        printf("Saving store as PKCS #7 to %s\n", pszSaveFilename);
    } else {
        dwSaveAs = CERT_STORE_SAVE_AS_STORE;
        printf("Saving store to %s\n", pszSaveFilename);
    }

    if (!CertSaveStore(
            hStore,
            dwCertEncodingType | dwMsgEncodingType,
            dwSaveAs,
            CERT_STORE_SAVE_TO_FILENAME_A,
            (void *) pszSaveFilename,
            0                   // dwFlags
            ))
        PrintLastError("CertSaveStore");
}

LPCWSTR GetOIDName(LPCSTR pszOID, DWORD dwGroupId)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszOID,
            dwGroupId
            )) {
        if (L'\0' != pInfo->pwszName[0])
            return pInfo->pwszName;
    }

    return L"???";
}

ALG_ID GetAlgid(LPCSTR pszOID, DWORD dwGroupId)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszOID,
            dwGroupId
            ))
        return pInfo->Algid;
    return 0;
}

static void GetSignAlgids(
    IN LPCSTR pszOID,
    OUT ALG_ID *paiHash,
    OUT ALG_ID *paiPubKey
    )
{
    PCCRYPT_OID_INFO pInfo;

    *paiHash = 0;
    *paiPubKey = 0;
    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszOID,
            CRYPT_SIGN_ALG_OID_GROUP_ID
            )) {
        DWORD cExtra = pInfo->ExtraInfo.cbData / sizeof(DWORD);
        DWORD *pdwExtra = (DWORD *) pInfo->ExtraInfo.pbData;

        *paiHash = pInfo->Algid;
        if (1 <= cExtra)
            *paiPubKey = pdwExtra[0];
    }
}


void DisplayVerifyFlags(LPSTR pszHdr, DWORD dwFlags)
{
    if (dwFlags == CERT_STORE_TIME_VALIDITY_FLAG)
        printf("*****  %s: Warning:: Time Invalid\n", pszHdr);
    else if (dwFlags != 0) {
        printf("*****  %s: Failed Verification Checks:: ", pszHdr);
        if (dwFlags & CERT_STORE_SIGNATURE_FLAG)
            printf("SIGNATURE ");
        if (dwFlags & CERT_STORE_TIME_VALIDITY_FLAG)
            printf("TIME ");
        if (dwFlags & CERT_STORE_REVOCATION_FLAG)
            printf("REVOCATION ");
        if (dwFlags & CERT_STORE_NO_CRL_FLAG)
            printf("NO_CRL ");
        if (dwFlags & CERT_STORE_NO_ISSUER_FLAG)
            printf("NO_ISSUER ");
        if (dwFlags & CERT_STORE_DELTA_CRL_FLAG)
            printf("NOT_DELTA_CRL ");
        if (dwFlags & CERT_STORE_BASE_CRL_FLAG)
            printf("NOT_BASE_CRL ");
        printf("\n");
    }
}

static void DisplayThumbprint(
    LPCSTR pszHash,
    BYTE *pbHash,
    DWORD cbHash
    )
{
    printf("%s Thumbprint:: ", pszHash);
    if (cbHash == 0)
        printf("???");
    else {
        ULONG cb;

        while (cbHash > 0) {
            cb = min(4, cbHash);
            cbHash -= cb;
            for (; cb > 0; cb--, pbHash++)
                printf("%02X", *pbHash);
            printf(" ");
        }
    }
    printf("\n");
}

static void DisplaySerialNumber(
    PCRYPT_INTEGER_BLOB pSerialNumber
    )
{
    DWORD cb;
    BYTE *pb;
    for (cb = pSerialNumber->cbData,
         pb = pSerialNumber->pbData + (cb - 1); cb > 0; cb--, pb--) {
        printf(" %02X", *pb);
    }
}

static void DisplayAnyString(
    LPCSTR pszPrefix,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags
    )
{
    PCERT_NAME_VALUE pInfo = NULL;

    if (NULL == (pInfo = (PCERT_NAME_VALUE) TestNoCopyDecodeObject(
            X509_UNICODE_ANY_STRING,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->dwValueType == CERT_RDN_ENCODED_BLOB ||
            pInfo->dwValueType == CERT_RDN_OCTET_STRING) {
        printf("%s ValueType: %d\n", pszPrefix, pInfo->dwValueType);
        PrintBytes("    ", pInfo->Value.pbData, pInfo->Value.cbData);
    } else
        printf("%s ValueType: %d String: %S\n",
            pszPrefix, pInfo->dwValueType, pInfo->Value.pbData);

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayBits(
    LPCSTR pszPrefix,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_BIT_BLOB pInfo = NULL;

    if (NULL == (pInfo = (PCRYPT_BIT_BLOB) TestNoCopyDecodeObject(
            X509_BITS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    printf("%s", pszPrefix);
    if (1 == pInfo->cbData) {
        printf(" %02X", *pInfo->pbData);
        if (pInfo->cUnusedBits)
            printf(" UnusedBits: %d\n", pInfo->cUnusedBits);
        else
            printf("\n");
    } else {
        if (pInfo->cbData) {
            printf("\n");
            PrintBytes("    ", pInfo->pbData, pInfo->cbData);
            printf("    UnusedBits: %d\n", pInfo->cUnusedBits);
        } else
            printf(" NONE\n");
    }

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayInteger(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    int iInfo = 0;
    DWORD cbInfo;

    cbInfo = sizeof(iInfo);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            X509_INTEGER,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &iInfo,
            &cbInfo
            )) {
        PrintLastError("IntegerDecode");
        goto CommonReturn;
    }

    printf("  Integer:: %d (0x%x)\n", iInfo, iInfo);

CommonReturn:
    return;
}

static void DisplayOctetString(
    LPCSTR pszPrefix,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_DATA_BLOB pInfo = NULL;

    if (NULL == (pInfo = (PCRYPT_DATA_BLOB) TestNoCopyDecodeObject(
            X509_OCTET_STRING,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    printf("%s", pszPrefix);
    if (pInfo->cbData) {
        printf("\n");
        PrintBytes("    ", pInfo->pbData, pInfo->cbData);
    } else
        printf(" NONE\n");

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static BOOL DecodeName(BYTE *pbEncoded, DWORD cbEncoded, DWORD dwDisplayFlags)
{
    BOOL fResult;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD i,j;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;

#if 0
    {
        CERT_NAME_BLOB Name;
        DWORD cwsz;
        LPWSTR pwsz;
        DWORD csz;
        LPSTR psz;
        Name.pbData = pbEncoded;
        Name.cbData = cbEncoded;

        DWORD rgdwStrType[] = {
            CERT_SIMPLE_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG |
                CERT_NAME_STR_NO_PLUS_FLAG | CERT_NAME_STR_NO_QUOTING_FLAG,
            CERT_OID_NAME_STR,
            CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG |
                CERT_NAME_STR_NO_QUOTING_FLAG,
            0
        };

        DWORD *pdwStrType;

        cwsz = CertNameToStrW(
            dwCertEncodingType,
            &Name,
            CERT_X500_NAME_STR,
            NULL,                   // pwsz
            0);                     // cwsz
        if (pwsz = (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR))) {
            CertNameToStrW(
                dwCertEncodingType,
                &Name,
                CERT_X500_NAME_STR,
                pwsz,
                cwsz);
            printf("  %S\n", pwsz);
            TestFree(pwsz);
        }

        for (pdwStrType = rgdwStrType; *pdwStrType; pdwStrType++) {
            csz = CertNameToStrA(
                dwCertEncodingType,
                &Name,
                *pdwStrType,
                NULL,                   // psz
                0);                     // csz
            if (psz = (LPSTR) TestAlloc(csz)) {
                CertNameToStrA(
                    dwCertEncodingType,
                    &Name,
                    *pdwStrType,
                    psz,
                    csz);
                printf("  %s\n", psz);
                TestFree(psz);
            }
        }
    }
#endif

    if (NULL == (pInfo = (PCERT_NAME_INFO) TestNoCopyDecodeObject(
            X509_NAME,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    for (i = 0, pRDN = pInfo->rgRDN; i < pInfo->cRDN; i++, pRDN++) {
        for (j = 0, pAttr = pRDN->rgRDNAttr; j < pRDN->cRDNAttr; j++, pAttr++) {
            LPSTR pszObjId = pAttr->pszObjId;
            if (pszObjId == NULL)
                pszObjId = "<NULL OBJID>";
            if ((dwDisplayFlags & DISPLAY_VERBOSE_FLAG) ||
                (pAttr->dwValueType == CERT_RDN_ENCODED_BLOB) ||
                (pAttr->dwValueType == CERT_RDN_OCTET_STRING)) {
                printf("  [%d,%d] %s (%S) ValueType: %d\n",
                    i, j, pszObjId, GetOIDName(pszObjId), pAttr->dwValueType);
                PrintBytes("    ", pAttr->Value.pbData, pAttr->Value.cbData);
            } else if (pAttr->dwValueType == CERT_RDN_UNIVERSAL_STRING) {
                printf("  [%d,%d] %s (%S)",
                    i, j, pszObjId, GetOIDName(pszObjId));

                DWORD cdw = pAttr->Value.cbData / 4;
                DWORD *pdw = (DWORD *) pAttr->Value.pbData;
                for ( ; cdw > 0; cdw--, pdw++)
                    printf(" 0x%08X", *pdw);
                printf("\n");

                DWORD csz;
                csz = CertRDNValueToStrA(
                    pAttr->dwValueType,
                    &pAttr->Value,
                    NULL,               // psz
                    0                   // csz
                    );
                if (csz > 1) {
                    LPSTR psz = (LPSTR) TestAlloc(csz);
                    if (psz) {
                        CertRDNValueToStrA(
                            pAttr->dwValueType,
                            &pAttr->Value,
                            psz,
                            csz
                            );
                        printf("    Str: %s\n", psz);
                        PrintBytes("    ", (BYTE *) psz, csz);
                        TestFree(psz);
                    }
                }

                DWORD cwsz;
                cwsz = CertRDNValueToStrW(
                    pAttr->dwValueType,
                    &pAttr->Value,
                    NULL,               // pwsz
                    0                   // cwsz
                    );
                if (cwsz > 1) {
                    LPWSTR pwsz =
                        (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR));
                    if (pwsz) {
                        CertRDNValueToStrW(
                            pAttr->dwValueType,
                            &pAttr->Value,
                            pwsz,
                            cwsz
                            );
                        printf("    WStr: %S\n", pwsz);
                        PrintBytes("    ", (BYTE *) pwsz, cwsz * sizeof(WCHAR));
                        TestFree(pwsz);
                    }
                }
            } else if (pAttr->dwValueType == CERT_RDN_BMP_STRING ||
                    pAttr->dwValueType == CERT_RDN_UTF8_STRING) {
                printf("  [%d,%d] %s (%S) %S\n",
                    i, j, pszObjId, GetOIDName(pszObjId), pAttr->Value.pbData);
            } else
                printf("  [%d,%d] %s (%S) %s\n",
                    i, j, pszObjId, GetOIDName(pszObjId), pAttr->Value.pbData);
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static void DisplayAltNameEntry(
    PCERT_ALT_NAME_ENTRY pEntry,
    DWORD dwDisplayFlags)
{

    switch (pEntry->dwAltNameChoice) {
    case CERT_ALT_NAME_OTHER_NAME:
        printf("OtherName: %s\n", pEntry->pOtherName->pszObjId);
        PrintBytes("    ", pEntry->pOtherName->Value.pbData,
            pEntry->pOtherName->Value.cbData);
        break;
    case CERT_ALT_NAME_X400_ADDRESS:
        printf("X400Address:\n");
        break;
    case CERT_ALT_NAME_DIRECTORY_NAME:
        printf("DirectoryName:\n");
        DecodeName(pEntry->DirectoryName.pbData,
            pEntry->DirectoryName.cbData, dwDisplayFlags);
        break;
    case CERT_ALT_NAME_EDI_PARTY_NAME:
        printf("EdiPartyName:\n");
        break;
    case CERT_ALT_NAME_RFC822_NAME:
        printf("RFC822: %S\n", pEntry->pwszRfc822Name);
        break;
    case CERT_ALT_NAME_DNS_NAME:
        printf("DNS: %S\n", pEntry->pwszDNSName);
        break;
    case CERT_ALT_NAME_URL:
        printf("URL: %S\n", pEntry->pwszURL);
        break;
    case CERT_ALT_NAME_IP_ADDRESS:
        printf("IPAddress:\n");
        PrintBytes("    ", pEntry->IPAddress.pbData, pEntry->IPAddress.cbData);
        break;
    case CERT_ALT_NAME_REGISTERED_ID:
        printf("RegisteredID: %s\n", pEntry->pszRegisteredID);
        break;
    default:
        printf("Unknown choice: %d\n", pEntry->dwAltNameChoice);
    }
}

static void DisplayAltName(
    PCERT_ALT_NAME_INFO pInfo,
    DWORD dwDisplayFlags)
{
    DWORD i;
    PCERT_ALT_NAME_ENTRY pEntry = pInfo->rgAltEntry;
    DWORD cEntry = pInfo->cAltEntry;

    for (i = 0; i < cEntry; i++, pEntry++) {
        printf("    [%d] ", i);
        DisplayAltNameEntry(pEntry, dwDisplayFlags);
    }
}

static void DecodeAndDisplayAltName(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_ALT_NAME_INFO pInfo = NULL;

    if (NULL == (pInfo = (PCERT_ALT_NAME_INFO) TestNoCopyDecodeObject(
            X509_ALTERNATE_NAME,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    DisplayAltName(pInfo, dwDisplayFlags);

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayAuthorityKeyIdExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_AUTHORITY_KEY_ID_INFO pInfo;
    printf("  <AuthorityKeyId>\n");
    if (NULL == (pInfo = (PCERT_AUTHORITY_KEY_ID_INFO) TestNoCopyDecodeObject(
            X509_AUTHORITY_KEY_ID,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->KeyId.cbData) {
        printf("  KeyId::\n");
        PrintBytes("    ", pInfo->KeyId.pbData, pInfo->KeyId.cbData);
    }

    if (pInfo->CertIssuer.cbData) {
        printf("  CertIssuer::\n");
        DecodeName(pInfo->CertIssuer.pbData, pInfo->CertIssuer.cbData,
            dwDisplayFlags);
    }
    if (pInfo->CertSerialNumber.cbData) {
        printf("  CertSerialNumber::");
        DisplaySerialNumber(&pInfo->CertSerialNumber);
        printf("\n");
    }

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayAuthorityKeyId2Extension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_AUTHORITY_KEY_ID2_INFO pInfo;
    printf("  <AuthorityKeyId #2>\n");
    if (NULL == (pInfo = (PCERT_AUTHORITY_KEY_ID2_INFO) TestNoCopyDecodeObject(
            X509_AUTHORITY_KEY_ID2,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->KeyId.cbData) {
        printf("  KeyId::\n");
        PrintBytes("    ", pInfo->KeyId.pbData, pInfo->KeyId.cbData);
    }

    if (pInfo->AuthorityCertIssuer.cAltEntry) {
        printf("  AuthorityCertIssuer::\n");
        DisplayAltName(&pInfo->AuthorityCertIssuer, dwDisplayFlags);
    }
    if (pInfo->AuthorityCertSerialNumber.cbData) {
        printf("  AuthorityCertSerialNumber::");
        DisplaySerialNumber(&pInfo->AuthorityCertSerialNumber);
        printf("\n");
    }

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayKeyAttrExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_KEY_ATTRIBUTES_INFO pInfo;
    if (NULL == (pInfo = (PCERT_KEY_ATTRIBUTES_INFO) TestNoCopyDecodeObject(
            X509_KEY_ATTRIBUTES,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->KeyId.cbData) {
        printf("  KeyId::\n");
        PrintBytes("    ", pInfo->KeyId.pbData, pInfo->KeyId.cbData);
    }

    if (pInfo->IntendedKeyUsage.cbData) {
        BYTE bFlags = *pInfo->IntendedKeyUsage.pbData;

        printf("  IntendedKeyUsage:: ");
        if (bFlags == 0)
            printf("<NONE> ");
        if (bFlags & CERT_DIGITAL_SIGNATURE_KEY_USAGE)
            printf("DIGITAL_SIGNATURE ");
        if (bFlags &  CERT_NON_REPUDIATION_KEY_USAGE)
            printf("NON_REPUDIATION ");
        if (bFlags & CERT_KEY_ENCIPHERMENT_KEY_USAGE)
            printf("KEY_ENCIPHERMENT ");
        if (bFlags & CERT_DATA_ENCIPHERMENT_KEY_USAGE)
            printf("DATA_ENCIPHERMENT ");
        if (bFlags & CERT_KEY_AGREEMENT_KEY_USAGE)
            printf("KEY_AGREEMENT ");
        if (bFlags & CERT_KEY_CERT_SIGN_KEY_USAGE)
            printf("KEY_CERT ");
        if (bFlags & CERT_OFFLINE_CRL_SIGN_KEY_USAGE)
            printf("OFFLINE_CRL_SIGN ");
        printf("\n");
    }

    if (pInfo->pPrivateKeyUsagePeriod) {
        PCERT_PRIVATE_KEY_VALIDITY p = pInfo->pPrivateKeyUsagePeriod;
        printf("  NotBefore:: %s\n", FileTimeText(&p->NotBefore));
        printf("  NotAfter:: %s\n", FileTimeText(&p->NotAfter));
    }

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayKeyUsageRestrictionExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_KEY_USAGE_RESTRICTION_INFO pInfo;
    if (NULL == (pInfo =
            (PCERT_KEY_USAGE_RESTRICTION_INFO) TestNoCopyDecodeObject(
                X509_KEY_USAGE_RESTRICTION,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;

    if (pInfo->cCertPolicyId) {
        DWORD i, j;
        printf("  CertPolicySet::\n");

        PCERT_POLICY_ID pPolicyId = pInfo->rgCertPolicyId;
        for (i = 0; i < pInfo->cCertPolicyId; i++, pPolicyId++) {
            if (pPolicyId->cCertPolicyElementId == 0)
                printf("     [%d,*] <NO ELEMENTS>\n", i);
            LPSTR *ppszObjId = pPolicyId->rgpszCertPolicyElementId;
            for (j = 0; j < pPolicyId->cCertPolicyElementId; j++, ppszObjId++) {
                LPSTR pszObjId = *ppszObjId;
                if (pszObjId == NULL)
                    pszObjId = "<NULL OBJID>";
                printf("     [%d,%d] %s\n", i, j, pszObjId);
            }
        }
    }

    if (pInfo->RestrictedKeyUsage.cbData) {
        BYTE bFlags = *pInfo->RestrictedKeyUsage.pbData;

        printf("  RestrictedKeyUsage:: ");
        if (bFlags == 0)
            printf("<NONE> ");
        if (bFlags & CERT_DIGITAL_SIGNATURE_KEY_USAGE)
            printf("DIGITAL_SIGNATURE ");
        if (bFlags &  CERT_NON_REPUDIATION_KEY_USAGE)
            printf("NON_REPUDIATION ");
        if (bFlags & CERT_KEY_ENCIPHERMENT_KEY_USAGE)
            printf("KEY_ENCIPHERMENT ");
        if (bFlags & CERT_DATA_ENCIPHERMENT_KEY_USAGE)
            printf("DATA_ENCIPHERMENT ");
        if (bFlags & CERT_KEY_AGREEMENT_KEY_USAGE)
            printf("KEY_AGREEMENT ");
        if (bFlags & CERT_KEY_CERT_SIGN_KEY_USAGE)
            printf("KEY_CERT ");
        if (bFlags & CERT_OFFLINE_CRL_SIGN_KEY_USAGE)
            printf("OFFLINE_CRL_SIGN ");
        printf("\n");
    }

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayBasicConstraintsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_BASIC_CONSTRAINTS_INFO pInfo;
    if (NULL == (pInfo = (PCERT_BASIC_CONSTRAINTS_INFO) TestNoCopyDecodeObject(
            X509_BASIC_CONSTRAINTS,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    printf("  SubjectType:: ");
    if (pInfo->SubjectType.cbData == 0)
        printf("<NONE> ");
    else {
        BYTE bSubjectType = *pInfo->SubjectType.pbData;
        if (bSubjectType == 0)
            printf("<NONE> ");
        if (bSubjectType & CERT_CA_SUBJECT_FLAG)
            printf("CA ");
        if (bSubjectType & CERT_END_ENTITY_SUBJECT_FLAG)
            printf("END_ENTITY ");
    }
    printf("\n");

    printf("  PathLenConstraint:: ");
    if (pInfo->fPathLenConstraint)
        printf("%d", pInfo->dwPathLenConstraint);
    else
        printf("<NONE>");
    printf("\n");

    if (pInfo->cSubtreesConstraint) {
        DWORD i;
        PCERT_NAME_BLOB pSubtrees = pInfo->rgSubtreesConstraint;
        for (i = 0; i < pInfo->cSubtreesConstraint; i++, pSubtrees++) {
            printf("  SubtreesConstraint[%d]::\n", i);
            DecodeName(pSubtrees->pbData, pSubtrees->cbData, dwDisplayFlags);
        }
    }

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayKeyUsageExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_BIT_BLOB pInfo;
    BYTE bFlags;

    if (NULL == (pInfo =
            (PCRYPT_BIT_BLOB) TestNoCopyDecodeObject(
                X509_KEY_USAGE,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;

    printf("  KeyUsage:: ");
    if (pInfo->cbData)
        bFlags = *pInfo->pbData;
    else
        bFlags = 0;

    if (bFlags == 0)
        printf("<NONE> ");
    if (bFlags & CERT_DIGITAL_SIGNATURE_KEY_USAGE)
        printf("DIGITAL_SIGNATURE ");
    if (bFlags &  CERT_NON_REPUDIATION_KEY_USAGE)
        printf("NON_REPUDIATION ");
    if (bFlags & CERT_KEY_ENCIPHERMENT_KEY_USAGE)
        printf("KEY_ENCIPHERMENT ");
    if (bFlags & CERT_DATA_ENCIPHERMENT_KEY_USAGE)
        printf("DATA_ENCIPHERMENT ");
    if (bFlags & CERT_KEY_AGREEMENT_KEY_USAGE)
        printf("KEY_AGREEMENT ");
    if (bFlags & CERT_KEY_CERT_SIGN_KEY_USAGE)
        printf("KEY_CERT ");
    if (bFlags & CERT_OFFLINE_CRL_SIGN_KEY_USAGE)
        printf("OFFLINE_CRL_SIGN ");
    printf("\n");


ErrorReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayBasicConstraints2Extension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo;
    if (NULL == (pInfo = (PCERT_BASIC_CONSTRAINTS2_INFO) TestNoCopyDecodeObject(
            X509_BASIC_CONSTRAINTS2,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    
    printf("  Basic Constraints:: ");
    if (pInfo->fCA)
        printf("CA\n");
    else
        printf("End-user\n");

    printf("  PathLenConstraint:: ");
    if (pInfo->fPathLenConstraint)
        printf("%d", pInfo->dwPathLenConstraint);
    else
        printf("<NONE>");
    printf("\n");

ErrorReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayPoliciesExtension(
    LPSTR pszType,          // "Certificate" | "Revocation" | "Application"
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_POLICIES_INFO pInfo;
    DWORD cPolicy;
    PCERT_POLICY_INFO pPolicy;
    DWORD i;

    if (NULL == (pInfo =
            (PCERT_POLICIES_INFO) TestNoCopyDecodeObject(
                X509_CERT_POLICIES,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;

    cPolicy = pInfo->cPolicyInfo;
    pPolicy = pInfo->rgPolicyInfo;

    if (cPolicy == 0)
        printf("  No %s Policies\n", pszType);
    else
        printf("  %s Policies::\n", pszType);

    for (i = 0; i < cPolicy; i++, pPolicy++) {
        DWORD cQualifier = pPolicy->cPolicyQualifier;
        PCERT_POLICY_QUALIFIER_INFO pQualifier;
        DWORD j;
        if (pPolicy->pszPolicyIdentifier)
            printf("    [%d] %s", i, pPolicy->pszPolicyIdentifier);
        if (cQualifier)
            printf(" Qualifiers::");
        printf("\n");

        pQualifier = pPolicy->rgPolicyQualifier;
        for (j = 0; j < cQualifier; j++, pQualifier++) {
            printf("      [%d] %s", j, pQualifier->pszPolicyQualifierId);
            if (pQualifier->Qualifier.cbData) {
                printf(" Encoded Data::\n");
                PrintBytes("    ",
                    pQualifier->Qualifier.pbData, pQualifier->Qualifier.cbData);
            } else
                printf("\n");
                    
        }
    }

ErrorReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplaySMIMECapabilitiesExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_SMIME_CAPABILITIES pInfo;
    DWORD cCap;
    PCRYPT_SMIME_CAPABILITY pCap;
    DWORD i;

    if (NULL == (pInfo =
            (PCRYPT_SMIME_CAPABILITIES) TestNoCopyDecodeObject(
                PKCS_SMIME_CAPABILITIES,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;

    cCap = pInfo->cCapability;
    pCap = pInfo->rgCapability;

    if (cCap == 0)
        printf("  No SMIME Capabilities\n");
    else
        printf("  SMIME Capabilties::\n");

    for (i = 0; i < cCap; i++, pCap++) {
        LPSTR pszObjId = pCap->pszObjId;
        printf("    [%d] %s (%S)", i, pszObjId, GetOIDName(pszObjId));
        if (pCap->Parameters.cbData) {
            printf(" Parameters::\n");
            PrintBytes("      ",
                pCap->Parameters.pbData,
                pCap->Parameters.cbData);
        } else
            printf("\n");
    }

ErrorReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DecodeAndDisplayCtlUsage(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCTL_USAGE pInfo;
    DWORD cId;
    LPSTR *ppszId;
    DWORD i;

    if (NULL == (pInfo =
            (PCTL_USAGE) TestNoCopyDecodeObject(
                X509_ENHANCED_KEY_USAGE,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;

    cId = pInfo->cUsageIdentifier;
    ppszId = pInfo->rgpszUsageIdentifier;

    if (cId == 0)
        printf("    No Usage Identifiers\n");

    for (i = 0; i < cId; i++, ppszId++)
        printf("    [%d] %s\n", i, *ppszId);

ErrorReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayEnhancedKeyUsageExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    printf("  EnhancedKeyUsage::\n");
    DecodeAndDisplayCtlUsage(pbEncoded, cbEncoded, dwDisplayFlags);
}

static void DisplayAltNameExtension(
    LPCSTR pszExt,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    printf("  <%s>\n", pszExt);
    DecodeAndDisplayAltName(pbEncoded, cbEncoded, dwDisplayFlags);
}

static void DisplayNameConstraintsSubtree(
    DWORD cSubtree,
    PCERT_GENERAL_SUBTREE pSubtree,
    DWORD dwDisplayFlags
    )
{
    DWORD i;

    for (i = 0; i < cSubtree; i++, pSubtree++) {
        printf("    Subtree[%d] ", i);
        if (pSubtree->dwMinimum || pSubtree->fMaximum) {
            printf("(%d ", pSubtree->dwMinimum);
            if (pSubtree->fMaximum)
                printf("- %d)  ", pSubtree->dwMaximum);
            else
                printf("...)  ");
        }
        DisplayAltNameEntry(&pSubtree->Base, dwDisplayFlags);
    }

}
static void DisplayNameConstraintsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_NAME_CONSTRAINTS_INFO pInfo = NULL;

    if (NULL == (pInfo = (PCERT_NAME_CONSTRAINTS_INFO) TestNoCopyDecodeObject(
            X509_NAME_CONSTRAINTS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->cPermittedSubtree) {
        printf("  <PermittedSubtree>\n");
        DisplayNameConstraintsSubtree(pInfo->cPermittedSubtree,
            pInfo->rgPermittedSubtree, dwDisplayFlags);
    } else
        printf("  No PermittedSubtree\n");

    if (pInfo->cExcludedSubtree) {
        printf("  <ExcludedSubtree>\n");
        DisplayNameConstraintsSubtree(pInfo->cExcludedSubtree,
            pInfo->rgExcludedSubtree, dwDisplayFlags);
    } else
        printf("  No ExcludedSubtree\n");


CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayPolicyMappingsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_POLICY_MAPPINGS_INFO pInfo = NULL;
    DWORD i;

    if (NULL == (pInfo = (PCERT_POLICY_MAPPINGS_INFO) TestNoCopyDecodeObject(
            X509_POLICY_MAPPINGS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->cPolicyMapping) {
        for (i = 0; i < pInfo->cPolicyMapping; i++) {
            printf("  [%d] Issuer: %s  Subject: %s\n", i,
                pInfo->rgPolicyMapping[i].pszIssuerDomainPolicy,
                pInfo->rgPolicyMapping[i].pszSubjectDomainPolicy);
        }
    } else
        printf("  No PolicyMappings\n");

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayPolicyConstraintsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_POLICY_CONSTRAINTS_INFO pInfo = NULL;

    if (NULL == (pInfo = (PCERT_POLICY_CONSTRAINTS_INFO) TestNoCopyDecodeObject(
            X509_POLICY_CONSTRAINTS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->fRequireExplicitPolicy)
        printf("  RequireExplicitPolicySkipCerts: %d",
            pInfo->dwRequireExplicitPolicySkipCerts);
    if (pInfo->fInhibitPolicyMapping)
        printf("  InhibitPolicyMappingSkipCerts: %d",
            pInfo->dwInhibitPolicyMappingSkipCerts);
    printf("\n");

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayCrossCertDistPointsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCROSS_CERT_DIST_POINTS_INFO pInfo = NULL;
    DWORD i;

    if (NULL == (pInfo = (PCROSS_CERT_DIST_POINTS_INFO) TestNoCopyDecodeObject(
            X509_CROSS_CERT_DIST_POINTS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    printf("  SyncDeltaTime (seconds) : %d\n", pInfo->dwSyncDeltaTime);
    for (i = 0; i < pInfo->cDistPoint; i++) {
        printf("  DistPoint[%d]\n", i);
        DisplayAltName(&pInfo->rgDistPoint[i], dwDisplayFlags);
    }

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayAccessDescriptions(
    LPCSTR pszAccDescr,
    DWORD cAccDescr,
    PCERT_ACCESS_DESCRIPTION pAccDescr,
    DWORD dwDisplayFlags)
{
    DWORD i;

    for (i = 0; i < cAccDescr; i++, pAccDescr++) {
        printf("    %s[%d] %s ", pszAccDescr, i, pAccDescr->pszAccessMethod);
        DisplayAltNameEntry(&pAccDescr->AccessLocation, dwDisplayFlags);
    }
}

static void DisplayAuthorityInfoAccessExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_AUTHORITY_INFO_ACCESS pInfo = NULL;

    if (NULL == (pInfo = (PCERT_AUTHORITY_INFO_ACCESS) TestNoCopyDecodeObject(
            X509_AUTHORITY_INFO_ACCESS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    printf("  <AuthorityInfoAccess>\n");
    if (pInfo->cAccDescr)
        DisplayAccessDescriptions("",
            pInfo->cAccDescr, pInfo->rgAccDescr, dwDisplayFlags);

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayCrlDistPointsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRL_DIST_POINTS_INFO pInfo = NULL;
    DWORD i;

    if (NULL == (pInfo = (PCRL_DIST_POINTS_INFO) TestNoCopyDecodeObject(
            X509_CRL_DIST_POINTS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (0 == pInfo->cDistPoint)
        printf("    NO CRL Distribution Points\n");
    else {
        DWORD cPoint = pInfo->cDistPoint;
        PCRL_DIST_POINT pPoint = pInfo->rgDistPoint;

        for (i = 0; i < cPoint; i++, pPoint++) {
            printf("  CRL Distribution Point[%d]\n", i);
            DWORD dwNameChoice = pPoint->DistPointName.dwDistPointNameChoice;
            switch (dwNameChoice) {
                case CRL_DIST_POINT_NO_NAME:
                    break;
                case CRL_DIST_POINT_FULL_NAME:
                    printf("    FullName:\n");
                    DisplayAltName(&pPoint->DistPointName.FullName,
                        dwDisplayFlags);
                    break;
                case CRL_DIST_POINT_ISSUER_RDN_NAME:
                    printf("    IssuerRDN: (Not Implemented)\n");
                    break;
                default:
                    printf("    Unknown name choice: %d\n", dwNameChoice);
            }

            if (pPoint->ReasonFlags.cbData) {
                BYTE bFlags;
                printf("    ReasonFlags: ");
                bFlags = *pPoint->ReasonFlags.pbData;

                if (bFlags == 0)
                    printf("<NONE> ");
                if (bFlags & CRL_REASON_UNUSED_FLAG)
                    printf("UNUSED ");
                if (bFlags & CRL_REASON_KEY_COMPROMISE_FLAG)
                    printf("KEY_COMPROMISE ");
                if (bFlags & CRL_REASON_CA_COMPROMISE_FLAG)
                    printf("CA_COMPROMISE ");
                if (bFlags & CRL_REASON_AFFILIATION_CHANGED_FLAG)
                    printf("AFFILIATION_CHANGED ");
                if (bFlags & CRL_REASON_SUPERSEDED_FLAG)
                    printf("SUPERSEDED ");
                if (bFlags & CRL_REASON_CESSATION_OF_OPERATION_FLAG)
                    printf("CESSATION_OF_OPERATION ");
                if (bFlags & CRL_REASON_CERTIFICATE_HOLD_FLAG)
                    printf("CERTIFICATE_HOLD ");
                printf("\n");
            }

            if (pPoint->CRLIssuer.cAltEntry) {
                printf("    CRLIssuer:");
                DisplayAltName(&pPoint->CRLIssuer, dwDisplayFlags);
            }
        }
    }

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayIssuingDistPointExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRL_ISSUING_DIST_POINT pInfo = NULL;
    DWORD i;
    DWORD dwNameChoice;

    if (NULL == (pInfo = (PCRL_ISSUING_DIST_POINT) TestNoCopyDecodeObject(
            X509_ISSUING_DIST_POINT,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    dwNameChoice = pInfo->DistPointName.dwDistPointNameChoice;
    switch (dwNameChoice) {
        case CRL_DIST_POINT_NO_NAME:
            printf("  No DistPointName\n");
            break;
        case CRL_DIST_POINT_FULL_NAME:
            printf("  DistPointName FullName:\n");
            DisplayAltName(&pInfo->DistPointName.FullName,
                dwDisplayFlags);
            break;
        case CRL_DIST_POINT_ISSUER_RDN_NAME:
            printf("  DistPointName IssuerRDN: (Not Implemented)\n");
            break;
        default:
            printf("  Unknown DistPointName choice: %d\n", dwNameChoice);
    }

    if (pInfo->fOnlyContainsUserCerts ||
            pInfo->fOnlyContainsCACerts ||
            pInfo->fIndirectCRL
            ) {
        printf(" ");
        if (pInfo->fOnlyContainsUserCerts)
            printf(" OnlyContainsUserCerts");
        if (pInfo->fOnlyContainsCACerts)
            printf(" OnlyContainsCACerts");
        if (pInfo->fIndirectCRL)
            printf(" IndirectCRL");
        printf("\n");
    }

    if (pInfo->OnlySomeReasonFlags.cbData) {
        BYTE bFlags;
        printf("  OnlySomeReasonFlags: ");
        bFlags = *pInfo->OnlySomeReasonFlags.pbData;

        if (bFlags == 0)
            printf("<NONE> ");
        if (bFlags & CRL_REASON_UNUSED_FLAG)
            printf("UNUSED ");
        if (bFlags & CRL_REASON_KEY_COMPROMISE_FLAG)
            printf("KEY_COMPROMISE ");
        if (bFlags & CRL_REASON_CA_COMPROMISE_FLAG)
            printf("CA_COMPROMISE ");
        if (bFlags & CRL_REASON_AFFILIATION_CHANGED_FLAG)
            printf("AFFILIATION_CHANGED ");
        if (bFlags & CRL_REASON_SUPERSEDED_FLAG)
            printf("SUPERSEDED ");
        if (bFlags & CRL_REASON_CESSATION_OF_OPERATION_FLAG)
            printf("CESSATION_OF_OPERATION ");
        if (bFlags & CRL_REASON_CERTIFICATE_HOLD_FLAG)
            printf("CERTIFICATE_HOLD ");
        printf("\n");
    }


CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplaySETAccountAliasExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    BOOL bInfo = FALSE;
    DWORD cbInfo;

    cbInfo = sizeof(bInfo);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            szOID_SET_ACCOUNT_ALIAS,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &bInfo,
            &cbInfo
            )) {
        PrintLastError("SETAccountAliasDecode");
        goto CommonReturn;
    }

    if (bInfo)
        printf("  SETAccountAlias:: TRUE\n");
    else
        printf("  SETAccountAlias:: FALSE\n");

CommonReturn:
    return;
}

static void DisplaySETHashedRootKeyExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    BYTE rgbInfo[SET_HASHED_ROOT_LEN];
    DWORD cbInfo;

    cbInfo = sizeof(rgbInfo);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            szOID_SET_HASHED_ROOT_KEY,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            rgbInfo,
            &cbInfo
            )) {
        PrintLastError("SETHashedRootKeyDecode");
        goto CommonReturn;
    }

    DisplayThumbprint("  SETHashedRootKey", rgbInfo, cbInfo);

CommonReturn:
    return;
}

static void DisplaySETCertTypeExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_BIT_BLOB pInfo;
    if (NULL == (pInfo = (PCRYPT_BIT_BLOB) TestNoCopyDecodeObject(
            szOID_SET_CERTIFICATE_TYPE,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    printf("  SETCertificateType:: ");
    if (pInfo->cbData == 0)
        printf("<NONE> ");
    else {
        DWORD cb;
        BYTE *pb;
        for (cb = pInfo->cbData, pb = pInfo->pbData; cb > 0; cb--, pb++)
            printf(" %02X", *pb);
    }
    printf("\n");

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplaySETMerchantDataExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PSET_MERCHANT_DATA_INFO pInfo;
    if (NULL == (pInfo = (PSET_MERCHANT_DATA_INFO) TestNoCopyDecodeObject(
            szOID_SET_MERCHANT_DATA,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    printf("  SETMerchantData:: \n");
    if(pInfo->pszMerID && *pInfo->pszMerID)
        printf("    MerID: %s\n", pInfo->pszMerID);
    if(pInfo->pszMerAcquirerBIN && *pInfo->pszMerAcquirerBIN)
        printf("    MerAcquirerBIN: %s\n", pInfo->pszMerAcquirerBIN);
    if(pInfo->pszMerTermID && *pInfo->pszMerTermID)
        printf("    MerTermID: %s\n", pInfo->pszMerTermID);
    if(pInfo->pszMerName && *pInfo->pszMerName)
        printf("    MerName: %s\n", pInfo->pszMerName);
    if(pInfo->pszMerCity && *pInfo->pszMerCity)
        printf("    MerCity: %s\n", pInfo->pszMerCity);
    if(pInfo->pszMerStateProvince && *pInfo->pszMerStateProvince)
        printf("    MerStateProvince: %s\n", pInfo->pszMerStateProvince);
    if(pInfo->pszMerPostalCode && *pInfo->pszMerPostalCode)
        printf("    MerPostalCode: %s\n", pInfo->pszMerPostalCode);
    if(pInfo->pszMerCountry && *pInfo->pszMerCountry)
        printf("    MerCountry: %s\n", pInfo->pszMerCountry);
    if(pInfo->pszMerPhone && *pInfo->pszMerPhone)
        printf("    MerPhone: %s\n", pInfo->pszMerPhone);
    if(pInfo->fMerPhoneRelease)
        printf("    MerPhoneRelease: TRUE\n");
    else
        printf("    MerPhoneRelease: FALSE\n");
    if(pInfo->fMerAuthFlag)
        printf("    MerAuthFlag: TRUE\n");
    else
        printf("    MerAuthFlag: FALSE\n");

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}
#pragma pack(1)
struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};
#pragma pack()

static char *GuidText(GUID *pguid)
{
    static char buf[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    sprintf(buf, "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return buf;
}


void DisplaySpcLink(PSPC_LINK pSpcLink)
{
    switch (pSpcLink->dwLinkChoice) {
    case SPC_URL_LINK_CHOICE:
        printf("URL=> %S\n", pSpcLink->pwszUrl);
        break;
    case SPC_MONIKER_LINK_CHOICE:
        printf("%s\n", GuidText((GUID *) pSpcLink->Moniker.ClassId));
        if (pSpcLink->Moniker.SerializedData.cbData) {
            printf("     SerializedData::\n");
            PrintBytes("    ", pSpcLink->Moniker.SerializedData.pbData,
                pSpcLink->Moniker.SerializedData.cbData);
        }
        break;
    case SPC_FILE_LINK_CHOICE:
        printf("FILE=> %S\n", pSpcLink->pwszFile);
        break;
    default:
        printf("Bad SPC Link Choice:: %d\n", pSpcLink->dwLinkChoice);
    }
}

static void DisplaySpcSpAgencyExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PSPC_SP_AGENCY_INFO pInfo;
    if (NULL == (pInfo = (PSPC_SP_AGENCY_INFO) TestNoCopyDecodeObject(
            SPC_SP_AGENCY_INFO_OBJID,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    printf("  SpAgencyInfo::\n");
    if (pInfo->pPolicyInformation) {
        printf("    PolicyInformation: ");
        DisplaySpcLink(pInfo->pPolicyInformation);
    }
    if (pInfo->pwszPolicyDisplayText) {
        printf("    PolicyDisplayText: %S\n", pInfo->pwszPolicyDisplayText);
    }
    if (pInfo->pLogoImage) {
        PSPC_IMAGE pImage = pInfo->pLogoImage;
        if (pImage->pImageLink) {
            printf("    ImageLink: ");
            DisplaySpcLink(pImage->pImageLink);
        }
        if (pImage->Bitmap.cbData) {
            printf("    Bitmap:\n");
            PrintBytes("    ", pImage->Bitmap.pbData, pImage->Bitmap.cbData);
        }
        if (pImage->Metafile.cbData) {
            printf("    Metafile:\n");
            PrintBytes("    ", pImage->Metafile.pbData,
                pImage->Metafile.cbData);
        }
        if (pImage->EnhancedMetafile.cbData) {
            printf("    EnhancedMetafile:\n");
            PrintBytes("    ", pImage->EnhancedMetafile.pbData,
                pImage->EnhancedMetafile.cbData);
        }
        if (pImage->GifFile.cbData) {
            printf("    GifFile:\n");
            PrintBytes("    ", pImage->GifFile.pbData,
                pImage->GifFile.cbData);
        }
    }
    if (pInfo->pLogoLink) {
        printf("    LogoLink: ");
        DisplaySpcLink(pInfo->pLogoLink);
    }

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplaySpcFinancialCriteriaExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    SPC_FINANCIAL_CRITERIA FinancialCriteria;
    DWORD cbInfo = sizeof(FinancialCriteria);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            SPC_FINANCIAL_CRITERIA_OBJID,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &FinancialCriteria,
            &cbInfo
            )) {
        PrintLastError("SpcFinancialCriteriaInfoDecode");
        return;
    }

    printf("  FinancialCriteria:: ");
    if (FinancialCriteria.fFinancialInfoAvailable)
        printf("Financial Info Available.");
    else
        printf("NO Financial Info.");
    if (FinancialCriteria.fMeetsCriteria)
        printf(" Meets Criteria.");
    else
        printf(" Doesn't Meet Criteria.");
    printf("\n");
}

static void DisplaySpcMinimalCriteriaExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    BOOL fMinimalCriteria;
    DWORD cbInfo = sizeof(fMinimalCriteria);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            SPC_MINIMAL_CRITERIA_OBJID,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &fMinimalCriteria,
            &cbInfo)) {
        PrintLastError("SpcMinimalCriteriaInfoDecode");
        return;
    }

    printf("  MinimalCriteria:: ");
    if (fMinimalCriteria)
        printf("Meets Minimal Criteria.");
    else
        printf("Doesn't Meet Minimal Criteria.");
    printf("\n");
}

static void DisplayCommonNameExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_NAME_VALUE pInfo = NULL;
    LPWSTR pwsz = NULL;
    DWORD cwsz;

    if (NULL == (pInfo = (PCERT_NAME_VALUE) TestNoCopyDecodeObject(
            X509_NAME_VALUE,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    cwsz = CertRDNValueToStrW(
        pInfo->dwValueType,
        &pInfo->Value,
        NULL,               // pwsz
        0                   // cwsz
        );
    if (cwsz > 1) {
        pwsz = (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR));
        if (pwsz)
            CertRDNValueToStrW(
                pInfo->dwValueType,
                &pInfo->Value,
                pwsz,
                cwsz
                );
    }

    printf("  CommonName:: ValueType: %d String: ", pInfo->dwValueType);
    if (pwsz)
        printf("%S\n", pwsz);
    else
        printf("NULL");

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    if (pwsz)
        TestFree(pwsz);
}

static void DisplayCRLReason(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    DWORD cbInfo;
    int CRLReason;

    cbInfo = sizeof(CRLReason);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            szOID_CRL_REASON_CODE,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &CRLReason,
            &cbInfo
            )) {
        PrintLastError("CRLReason");
        return;
    }

    printf("  CRL Reason:: ");
    switch (CRLReason) {
        case CRL_REASON_UNSPECIFIED:
            printf("Unspecified");
            break;
        case CRL_REASON_KEY_COMPROMISE:
            printf("Key Compromise");
            break;
        case CRL_REASON_CA_COMPROMISE:
            printf("CA Compromise");
            break;
        case CRL_REASON_AFFILIATION_CHANGED:
            printf("Affiliation Changed");
            break;
        case CRL_REASON_SUPERSEDED:
            printf("Superseded");
            break;
        case CRL_REASON_CESSATION_OF_OPERATION:
            printf("Cessation of Operation");
            break;
        case CRL_REASON_CERTIFICATE_HOLD:
            printf("Certificate Hold");
            break;
        case CRL_REASON_REMOVE_FROM_CRL:
            printf("Remove from CRL");
            break;
        default:
            printf("%d", CRLReason);
            break;
    }
    printf("\n");
}


static void PrintExtensions(DWORD cExt, PCERT_EXTENSION pExt, DWORD dwDisplayFlags)
{
    DWORD i;

    for (i = 0; i < cExt; i++, pExt++) {
        LPSTR pszObjId = pExt->pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        LPSTR pszCritical = pExt->fCritical ? "TRUE" : "FALSE";
        printf("Extension[%d] %s (%S) Critical: %s::\n",
            i, pszObjId, GetOIDName(pszObjId), pszCritical);
        PrintBytes("    ", pExt->Value.pbData, pExt->Value.cbData);

        if (strcmp(pszObjId, szOID_AUTHORITY_KEY_IDENTIFIER) == 0)
            DisplayAuthorityKeyIdExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_AUTHORITY_KEY_IDENTIFIER2) == 0)
            DisplayAuthorityKeyId2Extension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_AUTHORITY_INFO_ACCESS) == 0)
            DisplayAuthorityInfoAccessExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_CRL_DIST_POINTS) == 0)
            DisplayCrlDistPointsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SUBJECT_KEY_IDENTIFIER) == 0)
            DisplayOctetString("  SubjectKeyIdentifer::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_KEY_ATTRIBUTES) == 0)
            DisplayKeyAttrExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SUBJECT_ALT_NAME) == 0)
            DisplayAltNameExtension("Subject AltName",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_ISSUER_ALT_NAME) == 0)
            DisplayAltNameExtension("Issuer AltName",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SUBJECT_ALT_NAME2) == 0)
            DisplayAltNameExtension("Subject AltName #2",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_ISSUER_ALT_NAME2) == 0)
            DisplayAltNameExtension("Issuer AltName #2",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NEXT_UPDATE_LOCATION) == 0)
            DisplayAltNameExtension("NextUpdateLocation",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_KEY_USAGE_RESTRICTION) == 0)
            DisplayKeyUsageRestrictionExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_BASIC_CONSTRAINTS) == 0)
            DisplayBasicConstraintsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_KEY_USAGE) == 0)
            DisplayKeyUsageExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_BASIC_CONSTRAINTS2) == 0)
            DisplayBasicConstraints2Extension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_CERT_POLICIES) == 0)
            DisplayPoliciesExtension("Certificate",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_CERT_POLICIES_95) == 0)
            DisplayPoliciesExtension("Certificate",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_APPLICATION_CERT_POLICIES) == 0)
            DisplayPoliciesExtension("Application",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SET_ACCOUNT_ALIAS) == 0)
            DisplaySETAccountAliasExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SET_HASHED_ROOT_KEY) == 0)
            DisplaySETHashedRootKeyExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SET_CERTIFICATE_TYPE) == 0)
            DisplaySETCertTypeExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SET_MERCHANT_DATA) == 0)
            DisplaySETMerchantDataExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, SPC_SP_AGENCY_INFO_OBJID) == 0)
            DisplaySpcSpAgencyExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, SPC_FINANCIAL_CRITERIA_OBJID) == 0)
            DisplaySpcFinancialCriteriaExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, SPC_MINIMAL_CRITERIA_OBJID) == 0)
            DisplaySpcMinimalCriteriaExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_COMMON_NAME) == 0)
            DisplayCommonNameExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        else if (strcmp(pszObjId, szOID_ENHANCED_KEY_USAGE) == 0)
            DisplayEnhancedKeyUsageExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_RSA_SMIMECapabilities) == 0)
            DisplaySMIMECapabilitiesExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        // CRL extensions
        else if (strcmp(pszObjId, szOID_CRL_REASON_CODE) == 0)
            DisplayCRLReason(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        else if (strcmp(pszObjId, szOID_CRL_NUMBER) == 0)
            DisplayInteger(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_DELTA_CRL_INDICATOR) == 0)
            DisplayInteger(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_ISSUING_DIST_POINT) == 0)
            DisplayIssuingDistPointExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_FRESHEST_CRL) == 0)
            DisplayCrlDistPointsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NAME_CONSTRAINTS) == 0)
            DisplayNameConstraintsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_POLICY_MAPPINGS) == 0)
            DisplayPolicyMappingsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_LEGACY_POLICY_MAPPINGS) == 0)
            DisplayPolicyMappingsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_APPLICATION_POLICY_MAPPINGS) == 0)
            DisplayPolicyMappingsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_POLICY_CONSTRAINTS) == 0)
            DisplayPolicyConstraintsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_APPLICATION_POLICY_CONSTRAINTS) == 0)
            DisplayPolicyConstraintsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_CROSS_CERT_DIST_POINTS) == 0)
            DisplayCrossCertDistPointsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        // Netscape extensions
        else if (strcmp(pszObjId, szOID_NETSCAPE_CERT_TYPE) == 0)
            DisplayBits("  NetscapeCertType::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_BASE_URL) == 0)
            DisplayAnyString("  NetscapeBaseURL::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_REVOCATION_URL) == 0)
            DisplayAnyString("  NetscapeRevocationURL::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_CA_REVOCATION_URL) == 0)
            DisplayAnyString("  NetscapeCARevocationURL::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_CERT_RENEWAL_URL) == 0)
            DisplayAnyString("  NetscapeCertRenewalURL::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_CA_POLICY_URL) == 0)
            DisplayAnyString("  NetscapeCAPolicyURL::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_SSL_SERVER_NAME) == 0)
            DisplayAnyString("  NetscapeSSLServerName::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_COMMENT) == 0)
            DisplayAnyString("  NetscapeComment::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
    }
}

static void DecodeAndDisplayDSSParameters(
    IN BYTE *pbData,
    IN DWORD cbData
    )
{
    PCERT_DSS_PARAMETERS pDssParameters;
    DWORD cbDssParameters;
    if (pDssParameters =
        (PCERT_DSS_PARAMETERS) TestNoCopyDecodeObject(
            X509_DSS_PARAMETERS,
            pbData,
            cbData,
            &cbDssParameters
            )) {
        DWORD cbKey = pDssParameters->p.cbData;
        printf("DSS Key Length:: %d bytes, %d bits\n", cbKey,
            cbKey*8);
        printf("DSS P (little endian)::\n");
        PrintBytes("    ", pDssParameters->p.pbData,
            pDssParameters->p.cbData);
        printf("DSS Q (little endian)::\n");
        PrintBytes("    ", pDssParameters->q.pbData,
            pDssParameters->q.cbData);
        printf("DSS G (little endian)::\n");
        PrintBytes("    ", pDssParameters->g.pbData,
            pDssParameters->g.cbData);
        TestFree(pDssParameters);
    }
}

static void PrintAuxCertProperties(
    PCCERT_CONTEXT pCert,
    DWORD dwDisplayFlags
    )
{
    if (0 == (dwDisplayFlags & DISPLAY_VERBOSE_FLAG))
        return;

    DWORD dwPropId = 0;
    while (dwPropId = CertEnumCertificateContextProperties(pCert, dwPropId)) {
        switch (dwPropId) {
        case CERT_KEY_PROV_INFO_PROP_ID:
        case CERT_SHA1_HASH_PROP_ID:
        case CERT_MD5_HASH_PROP_ID:
        case CERT_SIGNATURE_HASH_PROP_ID:
        case CERT_KEY_CONTEXT_PROP_ID:
        case CERT_KEY_IDENTIFIER_PROP_ID:
            // Formatted elsewhere
            break;
        default:
            {
                BYTE *pbData;
                DWORD cbData;

                if (CERT_ARCHIVED_PROP_ID == dwPropId)
                    printf("Archived PropId %d (0x%x) ::\n",
                        dwPropId, dwPropId);
                else
                    printf("Aux PropId %d (0x%x) ::\n", dwPropId, dwPropId);
                CertGetCertificateContextProperty(
                    pCert,
                    dwPropId,
                    NULL,                           // pvData
                    &cbData
                    );
                if (cbData) {
                    if (pbData = (BYTE *) TestAlloc(cbData)) {
                        // Try without a large enough buffer
                        DWORD cbSmall = cbData - 1;

                        if (CertGetCertificateContextProperty(
                                pCert,
                                dwPropId,
                                pbData,
                                &cbSmall
                                ))
                            printf("failed => returned success for too small buffer\n");
                        else {
                            DWORD dwErr = GetLastError();
                            if (ERROR_MORE_DATA != dwErr)
                                printf("failed => returned: %d 0x%x instead of ERROR_MORE_DATA\n", dwErr, dwErr);
                        }
                        if (cbSmall != cbData)
                            printf("failed => wrong size returned for small buffer\n");


                        if (CertGetCertificateContextProperty(
                                pCert,
                                dwPropId,
                                pbData,
                                &cbData
                                )) {
                            PrintBytes("    ", pbData, cbData);
                            if (CERT_CTL_USAGE_PROP_ID == dwPropId) {
                                printf("  EnhancedKeyUsage::\n");
                                DecodeAndDisplayCtlUsage(pbData, cbData,
                                    dwDisplayFlags);
                            } else if (CERT_CROSS_CERT_DIST_POINTS_PROP_ID ==
                                    dwPropId) {
                                printf("  CrossCertDistPoints::\n");
                                DisplayCrossCertDistPointsExtension(
                                    pbData, cbData, dwDisplayFlags);
#ifdef CERT_PUBKEY_ALG_PARA_PROP_ID
                            } else if (CERT_PUBKEY_ALG_PARA_PROP_ID ==
                                    dwPropId) {
                                DecodeAndDisplayDSSParameters(pbData, cbData);
#endif
                            }
                        } else
                            printf("     ERROR getting property bytes\n");
                        TestFree(pbData);
                    }
                } else
                    printf("     NO Property Bytes\n");
            }
            break;
        }
    }
}

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            )
{
    // reverse in place
    PBYTE	pbLo;
    PBYTE	pbHi;
    BYTE	bTmp;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }
}

static void DisplaySignature(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags
    )
{
    PCERT_SIGNED_CONTENT_INFO pSignedContent;
    
    if (pSignedContent = (PCERT_SIGNED_CONTENT_INFO) TestNoCopyDecodeObject(
            X509_CERT,
            pbEncoded,
            cbEncoded
            )) {
        LPSTR pszObjId;

        pszObjId = pSignedContent->SignatureAlgorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        printf("Content SignatureAlgorithm:: %s (%S)\n",
            pszObjId, GetOIDName(pszObjId, CRYPT_SIGN_ALG_OID_GROUP_ID));
        if (pSignedContent->SignatureAlgorithm.Parameters.cbData) {
            printf("Content SignatureAlgorithm.Parameters::\n");
            PrintBytes("    ",
                pSignedContent->SignatureAlgorithm.Parameters.pbData,
                pSignedContent->SignatureAlgorithm.Parameters.cbData);
        }

        if (pSignedContent->Signature.cbData) {
            ALG_ID aiHash;
            ALG_ID aiPubKey;

            printf("Content Signature (little endian)::\n");
            PrintBytes("    ", pSignedContent->Signature.pbData,
                pSignedContent->Signature.cbData);

            GetSignAlgids(pszObjId, &aiHash, &aiPubKey);
            if (CALG_SHA == aiHash && CALG_DSS_SIGN == aiPubKey) {
                BYTE *pbDssSignature;
                DWORD cbDssSignature;

                ReverseBytes(pSignedContent->Signature.pbData,
                    pSignedContent->Signature.cbData);

                if (pbDssSignature =
                    (BYTE *) TestNoCopyDecodeObject(
                        X509_DSS_SIGNATURE,
                        pSignedContent->Signature.pbData,
                        pSignedContent->Signature.cbData,
                        &cbDssSignature
                        )) {
                    if (CERT_DSS_SIGNATURE_LEN == cbDssSignature) {
                        printf("DSS R (little endian)::\n");
                        PrintBytes("    ", pbDssSignature, CERT_DSS_R_LEN);
                        printf("DSS S (little endian)::\n");
                        PrintBytes("    ", pbDssSignature + CERT_DSS_R_LEN,
                            CERT_DSS_S_LEN);
                    } else {
                        printf("DSS Signature (unexpected length, little endian)::\n");
                        PrintBytes("    ", pbDssSignature, cbDssSignature);
                    }
                    TestFree(pbDssSignature);
                }
            }
        } else
            printf("Content Signature:: NONE\n");

        printf("Content Length:: %d\n", pSignedContent->ToBeSigned.cbData);
        TestFree(pSignedContent);
    }
}

void DisplayStore(
    IN HCERTSTORE hStore,
    IN DWORD dwDisplayFlags
    )
{
    DWORD i;
    DWORD dwFlags;
    PCCERT_CONTEXT pCert;
    PCCRL_CONTEXT pCrl;
    PCCTL_CONTEXT pCtl;

    printf("####  Certificates  ####\n");
    pCert = NULL;
    i = 0;
    while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
        printf("=====  %d  =====\n", i);
        DisplayCert(pCert, dwDisplayFlags);
        i++;
    }

    printf("####  CRLs  ####\n");
    pCrl = NULL;
    i = 0;
    while (pCrl = CertEnumCRLsInStore(hStore, pCrl)) {
        printf("=====  %d  =====\n", i);
        DisplayCrl(pCrl, dwDisplayFlags);
        i++;
    }

    printf("####  CTLs  ####\n");
    pCtl = NULL;
    i = 0;
    while (pCtl = CertEnumCTLsInStore(hStore, pCtl)) {
        printf("=====  %d  =====\n", i);
        DisplayCtl(pCtl, dwDisplayFlags);
        i++;
    }
}

// Not displayed when DISPLAY_BRIEF_FLAG is set
void DisplayCertKeyProvInfo(
    PCCERT_CONTEXT pCert,
    DWORD dwDisplayFlags
    )
{
    PCRYPT_KEY_PROV_INFO pInfo = NULL;
    DWORD cbInfo;

    if (dwDisplayFlags & DISPLAY_BRIEF_FLAG)
        return;

    cbInfo = 0;
    CertGetCertificateContextProperty(
        pCert,
        CERT_KEY_PROV_INFO_PROP_ID,
        NULL,                           // pvData
        &cbInfo
        );
    if (cbInfo) {
        pInfo = (PCRYPT_KEY_PROV_INFO) TestAlloc(cbInfo);
        if (pInfo) {
            // Try without a large enough buffer
            DWORD cbSmall = cbInfo - 1;

            if (CertGetCertificateContextProperty(
                    pCert,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    pInfo,
                    &cbSmall
                    ))
                printf("failed => returned success for too small buffer\n");
            else {
                DWORD dwErr = GetLastError();
                if (ERROR_MORE_DATA != dwErr)
                    printf("failed => returned: %d 0x%x instead of ERROR_MORE_DATA\n", dwErr, dwErr);
            }
            if (cbSmall != cbInfo)
                printf("failed => wrong size returned for small buffer\n");

            if (CertGetCertificateContextProperty(
                    pCert,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    pInfo,
                    &cbInfo
                    )) {
                printf("Key Provider:: Type: %d", pInfo->dwProvType);
                if (pInfo->pwszProvName)
                    printf(" Name: %S", pInfo->pwszProvName);
                if (pInfo->dwFlags) {
                    printf(" Flags: 0x%x", pInfo->dwFlags);
                    if (pInfo->dwFlags & CRYPT_MACHINE_KEYSET)
                        printf(" (MACHINE_KEYSET)");
                    if (pInfo->dwFlags & CERT_SET_KEY_CONTEXT_PROP_ID)
                        printf(" (SET_KEY_CONTEXT_PROP)");
                    printf(" ");
                }
                if (pInfo->pwszContainerName)
                    printf(" Container: %S", pInfo->pwszContainerName);
                if (pInfo->dwKeySpec)
                    printf(" KeySpec: %d", pInfo->dwKeySpec);
                printf("\n");
                if (pInfo->cProvParam) {
                    DWORD i;
                    printf("Key Provider Params::\n");
                    for (i = 0; i < pInfo->cProvParam; i++) {
                        PCRYPT_KEY_PROV_PARAM pParam =
                            &pInfo->rgProvParam[i];
                        printf(" [%d] dwParam: 0x%x dwFlags: 0x%x\n",
                            i, pParam->dwParam, pParam->dwFlags);
                        if (pParam->cbData)
                            PrintBytes("      ",
                                pParam->pbData, pParam->cbData);
                    }
                }
            } else
                PrintLastError("CertGetCertificateContextProperty");
            TestFree(pInfo);
        }
    }
}

void DisplayFriendlyName(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwDisplayFlags
    )
{
    DWORD cch;
    LPWSTR pwsz = NULL;

    if (0 == (dwDisplayFlags & DISPLAY_VERBOSE_FLAG))
        return;

    cch = CertGetNameStringW(
        pCertContext,
        CERT_NAME_FRIENDLY_DISPLAY_TYPE,
        0,                                  // dwFlags
        NULL,                               // pvTypePara
        NULL,                               // pwsz
        0);                                 // cch
    if (cch <= 1) {
        DWORD dwErr = GetLastError();

        printf("failed => CertGetNameStringW returned empty string\n");
    } else if (pwsz = (LPWSTR) TestAlloc(cch * sizeof(WCHAR))) {
        cch = CertGetNameStringW(
            pCertContext,
            CERT_NAME_FRIENDLY_DISPLAY_TYPE,
            0,                              // dwFlags
            NULL,                           // pvTypePara
            pwsz,
            cch);
        printf("Friendly Name:: <%S>\n", pwsz);
        TestFree(pwsz);
    }
}

void DisplayUPN(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwDisplayFlags
    )
{
    DWORD cch;
    LPWSTR pwsz = NULL;

    if (0 == (dwDisplayFlags & DISPLAY_VERBOSE_FLAG))
        return;

    cch = CertGetNameStringW(
        pCertContext,
        CERT_NAME_UPN_TYPE,
        0,                                  // dwFlags
        NULL,                               // pvTypePara
        NULL,                               // pwsz
        0);                                 // cch
    if (cch <= 1) {
        ;
    } else if (pwsz = (LPWSTR) TestAlloc(cch * sizeof(WCHAR))) {
        cch = CertGetNameStringW(
            pCertContext,
            CERT_NAME_UPN_TYPE,
            0,                              // dwFlags
            NULL,                           // pvTypePara
            pwsz,
            cch);
        printf("UPN Name:: <%S>\n", pwsz);
        TestFree(pwsz);
    }
}

void DisplayCert(
    PCCERT_CONTEXT pCert,
    DWORD dwDisplayFlags,
    DWORD dwIssuer
    )
{
    DisplayCert2(
        pCert->hCertStore,
        pCert,
        dwDisplayFlags,
        dwIssuer
        );
}

typedef BOOL (WINAPI *PFN_CRYPT_UI_DLG_VIEW_CONTEXT)(
    IN DWORD dwContextType,
    IN const void *pvContext,
    IN OPTIONAL HWND hwnd,              // Defaults to the desktop window
    IN OPTIONAL LPCWSTR pwszTitle,      // Defaults to the context type title
    IN DWORD dwFlags,
    IN void *pvReserved
    );

void DisplayContextUI(
    IN DWORD dwContextType,
    IN const void *pvContext
    )
{
    HMODULE hDll = NULL;
    PFN_CRYPT_UI_DLG_VIEW_CONTEXT pfnCryptUIDlgViewContext;

    if (NULL == (hDll = LoadLibraryA("cryptui.dll"))) {
        PrintLastError("LoadLibraryA(cryptui.dll)");
        goto CommonReturn;
    }

    if (NULL == (pfnCryptUIDlgViewContext =
            (PFN_CRYPT_UI_DLG_VIEW_CONTEXT) GetProcAddress(hDll,
                "CryptUIDlgViewContext"))) {
        PrintLastError("GetProcAddress(CryptUIDlgViewContext)");
        goto CommonReturn;
    }

    if (!pfnCryptUIDlgViewContext(
            dwContextType,
            pvContext,
            NULL,       // hHwnd
            NULL,       // pwszTitle
            0,          // dwFlags
            NULL        // pvReserved
            ))
        PrintLastError("CryptUIDlgViewContext");

CommonReturn:
    if (hDll)
        FreeLibrary(hDll);
}


void DisplayCert2(
    HCERTSTORE hStore,
    PCCERT_CONTEXT pCert,
    DWORD dwDisplayFlags,
    DWORD dwIssuer
    )
{
    if (dwDisplayFlags & DISPLAY_UI_FLAG) {
        DisplayContextUI(CERT_STORE_CERTIFICATE_CONTEXT, pCert);
        dwDisplayFlags = DISPLAY_BRIEF_FLAG;
    }

    DisplayFriendlyName(pCert, dwDisplayFlags);
    DisplayUPN(pCert, dwDisplayFlags);

    printf("Subject::\n");
    DecodeName(pCert->pCertInfo->Subject.pbData,
        pCert->pCertInfo->Subject.cbData, dwDisplayFlags);
    if (!(dwDisplayFlags & DISPLAY_BRIEF_FLAG)) {
        printf("Issuer::\n");
        DecodeName(pCert->pCertInfo->Issuer.pbData,
            pCert->pCertInfo->Issuer.cbData, dwDisplayFlags);
        {
            printf("SerialNumber::");
            DisplaySerialNumber(&pCert->pCertInfo->SerialNumber);
            printf("\n");
        }
    }

    {
        BYTE rgbHash[MAX_HASH_LEN];
        DWORD cbHash = MAX_HASH_LEN;

#define MAX_KEY_ID_LEN  128
        BYTE rgbKeyId[MAX_KEY_ID_LEN];
        DWORD cbKeyId;

        CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("SHA1", rgbHash, cbHash);
        cbHash = MAX_HASH_LEN;
        CertGetCertificateContextProperty(
            pCert,
            CERT_MD5_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("MD5", rgbHash, cbHash);
        cbHash = MAX_HASH_LEN;
        CertGetCertificateContextProperty(
            pCert,
            CERT_SIGNATURE_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("Signature", rgbHash, cbHash);


        cbKeyId = MAX_KEY_ID_LEN;
        if (CertGetCertificateContextProperty(
                pCert,
                CERT_KEY_IDENTIFIER_PROP_ID,
                rgbKeyId,
                &cbKeyId
                ))
            DisplayThumbprint("KeyIdentifier", rgbKeyId, cbKeyId);
        else
            PrintLastError(
                "CertGetCertificateContextProperty(KEY_IDENTIFIER)");

        cbKeyId = MAX_KEY_ID_LEN;
        if (CryptHashPublicKeyInfo(
                NULL,               // hCryptProv
                CALG_SHA1,
                0,                  // dwFlags
                X509_ASN_ENCODING,
                &pCert->pCertInfo->SubjectPublicKeyInfo,
                rgbKeyId,
                &cbKeyId
                ))
            DisplayThumbprint("SHA1 KeyIdentifier", rgbKeyId, cbKeyId);
        else
            PrintLastError(
                "CertGetCertificateContextProperty(SHA1 KEY_IDENTIFIER)");


        if (dwDisplayFlags & DISPLAY_KEY_THUMB_FLAG) {
            HCRYPTPROV hProv = 0;
            CryptAcquireContext(
                &hProv,
                NULL,
                NULL,           // pszProvider
                PROV_RSA_FULL,
                CRYPT_VERIFYCONTEXT
                );
            if (hProv) {
                cbHash = MAX_HASH_LEN;
                CryptHashPublicKeyInfo(
                    hProv,
                    CALG_MD5,
                    0,                  // dwFlags
                    dwCertEncodingType,
                    &pCert->pCertInfo->SubjectPublicKeyInfo,
                    rgbHash,
                    &cbHash
                    );
                DisplayThumbprint("Key (MD5)", rgbHash, cbHash);
                CryptReleaseContext(hProv, 0);
            }
        }
    }

    DisplayCertKeyProvInfo(pCert);

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        DWORD dwAccessStateFlags;
        DWORD cbData = sizeof(dwAccessStateFlags);

        CertGetCertificateContextProperty(
            pCert,
            CERT_ACCESS_STATE_PROP_ID,
            &dwAccessStateFlags,
            &cbData
            );
        if (0 == cbData)
            printf("No AccessState PropId\n");
        else {
            printf("AccessState PropId dwFlags:: 0x%x", dwAccessStateFlags);
            if (dwAccessStateFlags & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG)
                printf(" WRITE_PERSIST");
            if (dwAccessStateFlags & CERT_ACCESS_STATE_SYSTEM_STORE_FLAG)
                printf(" SYSTEM_STORE");
            printf("\n");
        }
    }

    PrintAuxCertProperties(pCert, dwDisplayFlags);

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        LPSTR pszObjId;
        ALG_ID aiPubKey;
        DWORD dwBitLen;

        printf("Version:: %d\n", pCert->pCertInfo->dwVersion);

        pszObjId = pCert->pCertInfo->SignatureAlgorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        printf("SignatureAlgorithm:: %s (%S)\n",
            pszObjId, GetOIDName(pszObjId, CRYPT_SIGN_ALG_OID_GROUP_ID));
        if (pCert->pCertInfo->SignatureAlgorithm.Parameters.cbData) {
            printf("SignatureAlgorithm.Parameters::\n");
            PrintBytes("    ",
                pCert->pCertInfo->SignatureAlgorithm.Parameters.pbData,
                pCert->pCertInfo->SignatureAlgorithm.Parameters.cbData);
        }
        printf("NotBefore:: %s\n", FileTimeText(&pCert->pCertInfo->NotBefore));
        printf("NotAfter:: %s\n", FileTimeText(&pCert->pCertInfo->NotAfter));

        pszObjId = pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        printf("SubjectPublicKeyInfo.Algorithm:: %s (%S)\n",
            pszObjId, GetOIDName(pszObjId, CRYPT_PUBKEY_ALG_OID_GROUP_ID));
        aiPubKey = GetAlgid(pszObjId, CRYPT_PUBKEY_ALG_OID_GROUP_ID);

        if (pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData) {
            printf("SubjectPublicKeyInfo.Algorithm.Parameters::\n");
            PrintBytes("    ",
                pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
                pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData);
            if (NULL_ASN_TAG ==
                    *pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData)
            {
                // NULL parameters
            } else if (CALG_DSS_SIGN == aiPubKey) {
                DecodeAndDisplayDSSParameters(
                    pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
                    pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData);
            } else if (CALG_DH_SF == aiPubKey || CALG_DH_EPHEM == aiPubKey) {
                PCERT_X942_DH_PARAMETERS pDhParameters;
                DWORD cbDhParameters;
                if (pDhParameters =
                    (PCERT_X942_DH_PARAMETERS) TestNoCopyDecodeObject(
                        X942_DH_PARAMETERS,
                        pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
                        pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData,
                        &cbDhParameters
                        )) {
                    DWORD cbKey = pDhParameters->p.cbData;
                    printf("DH Key Length:: %d bytes, %d bits\n", cbKey,
                        cbKey*8);
                    printf("DH P (little endian)::\n");
                    PrintBytes("    ", pDhParameters->p.pbData,
                        pDhParameters->p.cbData);
                    printf("DH G (little endian)::\n");
                    PrintBytes("    ", pDhParameters->g.pbData,
                        pDhParameters->g.cbData);

                    if (pDhParameters->q.cbData) {
                        printf("DH Q (little endian)::\n");
                        PrintBytes("    ", pDhParameters->q.pbData,
                            pDhParameters->q.cbData);
                    }
                    if (pDhParameters->j.cbData) {
                        printf("DH J (little endian)::\n");
                        PrintBytes("    ", pDhParameters->j.pbData,
                            pDhParameters->j.cbData);
                    }
                    if (pDhParameters->pValidationParams) {
                        printf("DH seed ::\n");
                        PrintBytes("    ",
                            pDhParameters->pValidationParams->seed.pbData,
                            pDhParameters->pValidationParams->seed.cbData);
                        printf("DH pgenCounter:: %d (0x%x)\n",
                            pDhParameters->pValidationParams->pgenCounter,
                            pDhParameters->pValidationParams->pgenCounter);
                    }
                    TestFree(pDhParameters);
                }
            }
        }
        printf("SubjectPublicKeyInfo.PublicKey");
        if (0 != (dwBitLen = CertGetPublicKeyLength(
                dwCertEncodingType,
                &pCert->pCertInfo->SubjectPublicKeyInfo)))
            printf(" (BitLength: %d)", dwBitLen);
        if (pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits)
            printf(" (UnusedBits: %d)",
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits);
        printf("::\n");
        if (pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData) {
            PrintBytes("    ",
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData);

            if (CALG_RSA_SIGN == aiPubKey || CALG_RSA_KEYX == aiPubKey) {
                PUBLICKEYSTRUC *pPubKeyStruc;
                DWORD cbPubKeyStruc;

                printf("RSA_CSP_PUBLICKEYBLOB::\n");
                if (pPubKeyStruc = (PUBLICKEYSTRUC *) TestNoCopyDecodeObject(
                        RSA_CSP_PUBLICKEYBLOB,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData,
                        &cbPubKeyStruc
                        )) {
                    PrintBytes("    ", (BYTE *) pPubKeyStruc, cbPubKeyStruc);
                    TestFree(pPubKeyStruc);
                }
            } else if (CALG_DSS_SIGN == aiPubKey) {
                PCRYPT_UINT_BLOB pDssPubKey;
                DWORD cbDssPubKey;
                printf("DSS Y (little endian)::\n");
                if (pDssPubKey = (PCRYPT_UINT_BLOB) TestNoCopyDecodeObject(
                        X509_DSS_PUBLICKEY,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData,
                        &cbDssPubKey
                        )) {
                    PrintBytes("    ", pDssPubKey->pbData, pDssPubKey->cbData);
                    TestFree(pDssPubKey);
                }
            } else if (CALG_DH_SF == aiPubKey || CALG_DH_EPHEM == aiPubKey) {
                PCRYPT_UINT_BLOB pDhPubKey;
                DWORD cbDhPubKey;
                printf("DH Y (little endian)::\n");
                if (pDhPubKey = (PCRYPT_UINT_BLOB) TestNoCopyDecodeObject(
                        X509_DH_PUBLICKEY,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData,
                        &cbDhPubKey
                        )) {
                    PrintBytes("    ", pDhPubKey->pbData, pDhPubKey->cbData);
                    TestFree(pDhPubKey);
                }
            }
        } else
            printf("  No public key\n");

        DisplaySignature(
            pCert->pbCertEncoded,
            pCert->cbCertEncoded,
            dwDisplayFlags);

        if (pCert->pCertInfo->IssuerUniqueId.cbData) {
            printf("IssuerUniqueId");
            if (pCert->pCertInfo->IssuerUniqueId.cUnusedBits)
                printf(" (UnusedBits: %d)",
                    pCert->pCertInfo->IssuerUniqueId.cUnusedBits);
            printf("::\n");
            PrintBytes("    ", pCert->pCertInfo->IssuerUniqueId.pbData,
                pCert->pCertInfo->IssuerUniqueId.cbData);
        }

        if (pCert->pCertInfo->SubjectUniqueId.cbData) {
            printf("SubjectUniqueId");
            if (pCert->pCertInfo->SubjectUniqueId.cUnusedBits)
                printf(" (UnusedBits: %d)",
                    pCert->pCertInfo->SubjectUniqueId.cUnusedBits);
            printf("::\n");
            PrintBytes("    ", pCert->pCertInfo->SubjectUniqueId.pbData,
                pCert->pCertInfo->SubjectUniqueId.cbData);
        }

        if (pCert->pCertInfo->cExtension != 0) {
            PrintExtensions(pCert->pCertInfo->cExtension,
                pCert->pCertInfo->rgExtension, dwDisplayFlags);
        }

    }

    if (dwDisplayFlags & DISPLAY_CHECK_FLAG) {
        // Display any CRLs associated with the certificate
        PCCRL_CONTEXT pCrl = NULL;
        PCCRL_CONTEXT pFindCrl = NULL;
        DWORD dwFlags;
        int i;

        // i = 0 => BASE
        // i = 1 => DELTA
        for (i = 0; i <= 1; i++) {
          while (TRUE) {
            if (dwDisplayFlags &
                    (DISPLAY_CHECK_SIGN_FLAG | DISPLAY_CHECK_TIME_FLAG)) {
                dwFlags = 0;
                if (dwDisplayFlags & DISPLAY_CHECK_SIGN_FLAG)
                    dwFlags |= CERT_STORE_SIGNATURE_FLAG;
                if (dwDisplayFlags & DISPLAY_CHECK_TIME_FLAG)
                    dwFlags |= CERT_STORE_TIME_VALIDITY_FLAG;
            } else
                dwFlags = CERT_STORE_SIGNATURE_FLAG |
                    CERT_STORE_TIME_VALIDITY_FLAG;
            if (i == 0)
                dwFlags |= CERT_STORE_BASE_CRL_FLAG;
            else
                dwFlags |= CERT_STORE_DELTA_CRL_FLAG;
            pCrl = CertGetCRLFromStore(
                hStore,
                pCert,
                pCrl,
                &dwFlags
                );

            // Check that find comes up with the same CRL
            pFindCrl = CertFindCRLInStore(
                hStore,
                pCert->dwCertEncodingType,
                (i == 0) ? CRL_FIND_ISSUED_BY_BASE_FLAG :
                            CRL_FIND_ISSUED_BY_DELTA_FLAG,
                CRL_FIND_ISSUED_BY,
                (const void *) pCert,
                pFindCrl
                );

            if (pCrl == NULL) {
                if (pFindCrl != NULL) {
                    printf("failed => CertFindCRLInStore didn't return expected NULL\n");
                    CertFreeCRLContext(pFindCrl);
                    pFindCrl = NULL;
                }
                break;
            } else if (pFindCrl == NULL) {
                printf("failed => CertFindCRLInStore returned unexpected NULL\n");
                CertFreeCRLContext(pCrl);
                pCrl = NULL;
                break;
            }

            if (!(pFindCrl->pbCrlEncoded == pCrl->pbCrlEncoded
                                    ||
                    (pFindCrl->cbCrlEncoded == pCrl->cbCrlEncoded &&
                        0 == memcmp(pFindCrl->pbCrlEncoded, pCrl->pbCrlEncoded,
                            pFindCrl->cbCrlEncoded))))
                printf("failed => CertFindCRLInStore didn't match CertGetCRLFromStore\n");

            if (i == 0)
                printf("-----  BASE CRL  -----\n");
            else
                printf("-----  DELTA CRL  -----\n");
            DisplayCrl(pCrl, dwDisplayFlags | DISPLAY_NO_ISSUER_FLAG);
            DisplayVerifyFlags("CRL", dwFlags);
        }
      }
    }

    if (dwDisplayFlags & DISPLAY_CHECK_FLAG) {
        BOOL fIssuer = FALSE;
        PCCERT_CONTEXT pIssuer = NULL;
        DWORD dwFlags;

        while (TRUE) {
            if (dwDisplayFlags &
                    (DISPLAY_CHECK_SIGN_FLAG | DISPLAY_CHECK_TIME_FLAG)) {
                dwFlags = 0;
                if (dwDisplayFlags & DISPLAY_CHECK_SIGN_FLAG)
                    dwFlags |= CERT_STORE_SIGNATURE_FLAG;
                if (dwDisplayFlags & DISPLAY_CHECK_TIME_FLAG)
                    dwFlags |= CERT_STORE_TIME_VALIDITY_FLAG;
            } else
                dwFlags = CERT_STORE_SIGNATURE_FLAG |
                    CERT_STORE_TIME_VALIDITY_FLAG |
                    CERT_STORE_REVOCATION_FLAG;
            pIssuer = CertGetIssuerCertificateFromStore(
                hStore,
                pCert,
                pIssuer,
                &dwFlags
                );
            if (pIssuer) {
                printf("-----  Issuer [%d]  -----\n", dwIssuer);
                DisplayVerifyFlags("Above Subject", dwFlags);
                DisplayCert2(hStore, pIssuer, dwDisplayFlags, dwIssuer + 1);
                fIssuer = TRUE;
            } else {
                DWORD dwErr = GetLastError();
                if (dwErr == CRYPT_E_SELF_SIGNED) {
                    printf("-----  Self Signed Issuer   -----\n");
                    DisplayVerifyFlags("Issuer", dwFlags);
                } else if (dwErr != CRYPT_E_NOT_FOUND)
                    PrintLastError("CertGetIssuerCertificateFromStore");
                else if (!fIssuer) {
                    printf("-----  No Issuer   -----\n");
                    DisplayVerifyFlags("Above Subject", dwFlags);
                }
                break;
            }
        }
    }
}


void PrintCrlEntries(
    DWORD cEntry,
    PCRL_ENTRY pEntry,
    DWORD dwDisplayFlags
    )
{
    DWORD i;

    for (i = 0; i < cEntry; i++, pEntry++) {
        {
            printf(" [%d] SerialNumber::", i);
            DisplaySerialNumber(&pEntry->SerialNumber);
            printf("\n");
        }

        if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
            printf(" [%d] RevocationDate:: %s\n", i,
                FileTimeText(&pEntry->RevocationDate));

            if (pEntry->cExtension == 0)
                printf(" [%d] Extensions:: NONE\n", i);
            else {
                printf(" [%d] Extensions::\n", i);
                PrintExtensions(pEntry->cExtension, pEntry->rgExtension,
                    dwDisplayFlags);
            }
        }
    }
}

static void PrintAuxCrlProperties(
    PCCRL_CONTEXT pCrl,
    DWORD dwDisplayFlags
    )
{
    if (0 == (dwDisplayFlags & DISPLAY_VERBOSE_FLAG))
        return;

    DWORD dwPropId = 0;
    while (dwPropId = CertEnumCRLContextProperties(pCrl, dwPropId)) {
        switch (dwPropId) {
        case CERT_SHA1_HASH_PROP_ID:
        case CERT_MD5_HASH_PROP_ID:
            // Formatted elsewhere
            break;
        default:
            {
                BYTE *pbData;
                DWORD cbData;
                printf("Aux PropId %d (0x%x) ::\n", dwPropId, dwPropId);

                CertGetCRLContextProperty(
                    pCrl,
                    dwPropId,
                    NULL,                           // pvData
                    &cbData
                    );
                if (cbData) {
                    if (pbData = (BYTE *) TestAlloc(cbData)) {
                        if (CertGetCRLContextProperty(
                                pCrl,
                                dwPropId,
                                pbData,
                                &cbData
                                ))
                            PrintBytes("    ", pbData, cbData);
                        else
                            printf("    ERROR getting property bytes\n");
                        TestFree(pbData);
                    }
                } else
                    printf("    NO Property Bytes\n");
            }
            break;
        }
    }
}

void DisplayCrl(PCCRL_CONTEXT pCrl, DWORD dwDisplayFlags)
{
    if (dwDisplayFlags & DISPLAY_UI_FLAG) {
        DisplayContextUI(CERT_STORE_CRL_CONTEXT, pCrl);
        dwDisplayFlags = DISPLAY_BRIEF_FLAG;
    }

    if (!(dwDisplayFlags & DISPLAY_NO_ISSUER_FLAG)) {
        printf("Issuer::\n");
        DecodeName(pCrl->pCrlInfo->Issuer.pbData,
            pCrl->pCrlInfo->Issuer.cbData, dwDisplayFlags);
    }

    printf("ThisUpdate:: %s\n", FileTimeText(&pCrl->pCrlInfo->ThisUpdate));
    printf("NextUpdate:: %s\n", FileTimeText(&pCrl->pCrlInfo->NextUpdate));

    {
        BYTE rgbHash[MAX_HASH_LEN];
        DWORD cbHash = MAX_HASH_LEN;
        CertGetCRLContextProperty(
            pCrl,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("SHA1", rgbHash, cbHash);
        cbHash = MAX_HASH_LEN;
        CertGetCRLContextProperty(
            pCrl,
            CERT_MD5_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("MD5", rgbHash, cbHash);
        cbHash = MAX_HASH_LEN;
        CertGetCRLContextProperty(
            pCrl,
            CERT_SIGNATURE_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("Signature", rgbHash, cbHash);
    }

    PrintAuxCrlProperties(pCrl, dwDisplayFlags);

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        LPSTR pszObjId;

        printf("Version:: %d\n", pCrl->pCrlInfo->dwVersion);

        pszObjId = pCrl->pCrlInfo->SignatureAlgorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        printf("SignatureAlgorithm:: %s (%S)\n",
            pszObjId, GetOIDName(pszObjId, CRYPT_SIGN_ALG_OID_GROUP_ID));
        if (pCrl->pCrlInfo->SignatureAlgorithm.Parameters.cbData) {
            printf("SignatureAlgorithm.Parameters::\n");
            PrintBytes("    ",
                pCrl->pCrlInfo->SignatureAlgorithm.Parameters.pbData,
                pCrl->pCrlInfo->SignatureAlgorithm.Parameters.cbData);
        }


        if (pCrl->pCrlInfo->cExtension != 0) {
            PrintExtensions(pCrl->pCrlInfo->cExtension,
                pCrl->pCrlInfo->rgExtension,
                dwDisplayFlags);
        }
    }

    if (pCrl->pCrlInfo->cCRLEntry == 0)
        printf("Entries:: NONE\n");
    else {
        printf("Entries::\n");
        PrintCrlEntries(pCrl->pCrlInfo->cCRLEntry,
            pCrl->pCrlInfo->rgCRLEntry, dwDisplayFlags);
    }
}

static void PrintAttributes(DWORD cAttr, PCRYPT_ATTRIBUTE pAttr,
        DWORD dwDisplayFlags)
{
    DWORD i; 
    DWORD j; 

    for (i = 0; i < cAttr; i++, pAttr++) {
        DWORD cValue = pAttr->cValue;
        PCRYPT_ATTR_BLOB pValue = pAttr->rgValue;
        LPSTR pszObjId = pAttr->pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        if (cValue) {
            for (j = 0; j < cValue; j++, pValue++) {
                printf("  [%d,%d] %s\n", i, j, pszObjId);
                if (pValue->cbData) {
                    PrintBytes("    ", pValue->pbData, pValue->cbData);
                    if (strcmp(pszObjId, szOID_NEXT_UPDATE_LOCATION) == 0) {
                        printf("   NextUpdateLocation::\n");
                        DecodeAndDisplayAltName(pValue->pbData, pValue->cbData,
                            dwDisplayFlags);
                    }
                } else
                    printf("    NO Value Bytes\n");
            }
        } else
            printf("  [%d] %s :: No Values\n", i, pszObjId);
    }
}

static void PrintCtlEntries(
        PCCTL_CONTEXT pCtl,
        DWORD dwDisplayFlags,
        HCERTSTORE hStore)
{
    PCTL_INFO pInfo = pCtl->pCtlInfo;
    DWORD cEntry = pInfo->cCTLEntry;
    PCTL_ENTRY pEntry = pInfo->rgCTLEntry;
    DWORD i;
    DWORD Algid;
    DWORD dwFindType;

    Algid = CertOIDToAlgId(pInfo->SubjectAlgorithm.pszObjId);
    switch (Algid) {
        case CALG_SHA1:
            dwFindType = CERT_FIND_SHA1_HASH;
            break;
        case CALG_MD5:
            dwFindType = CERT_FIND_MD5_HASH;
            break;
        default:
            dwFindType = 0;
    }

    for (i = 0; i < cEntry; i++, pEntry++) {
        printf(" [%d] SubjectIdentifier::\n", i);
        PrintBytes("      ",
            pEntry->SubjectIdentifier.pbData,
            pEntry->SubjectIdentifier.cbData);

        if (hStore && dwFindType) {
            PCCERT_CONTEXT pCert;
            pCert = CertFindCertificateInStore(
                hStore,
                dwCertEncodingType,
                0,                  // dwFindFlags
                dwFindType,
                (void *) &pEntry->SubjectIdentifier,
                NULL                // pPrevCert
                );
            if (pCert) {
                DWORD cwsz;
                LPWSTR pwsz;

                cwsz = CertNameToStrW(
                    dwCertEncodingType,
                    &pCert->pCertInfo->Subject,
                    CERT_SIMPLE_NAME_STR,
                    NULL,                   // pwsz
                    0);                     // cwsz
                if (pwsz = (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR))) {
                    CertNameToStrW(
                        dwCertEncodingType,
                        &pCert->pCertInfo->Subject,
                        CERT_SIMPLE_NAME_STR,
                        pwsz,
                        cwsz);
                    printf("      Subject:  %S\n", pwsz);
                    TestFree(pwsz);
                }
                CertFreeCertificateContext(pCert);
            }
        }

        if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
            if (pEntry->cAttribute) {
                printf(" [%d] Attributes::\n", i);
                PrintAttributes(pEntry->cAttribute, pEntry->rgAttribute,
                    dwDisplayFlags);
            }
        }
    }
}

static void PrintAuxCtlProperties(
    PCCTL_CONTEXT pCtl,
    DWORD dwDisplayFlags
    )
{
    if (0 == (dwDisplayFlags & DISPLAY_VERBOSE_FLAG))
        return;

    DWORD dwPropId = 0;
    while (dwPropId = CertEnumCTLContextProperties(pCtl, dwPropId)) {
        switch (dwPropId) {
        case CERT_SHA1_HASH_PROP_ID:
#if 0
        case CERT_MD5_HASH_PROP_ID:
#endif
            // Formatted elsewhere
            break;
        default:
            {
                BYTE *pbData;
                DWORD cbData;

                printf("Aux PropId %d (0x%x) ::\n", dwPropId, dwPropId);
                CertGetCTLContextProperty(
                    pCtl,
                    dwPropId,
                    NULL,                           // pvData
                    &cbData
                    );
                if (cbData) {
                    if (pbData = (BYTE *) TestAlloc(cbData)) {
                        if (CertGetCTLContextProperty(
                                pCtl,
                                dwPropId,
                                pbData,
                                &cbData
                                )) {
                            PrintBytes("    ", pbData, cbData);
                            if (CERT_NEXT_UPDATE_LOCATION_PROP_ID ==
                                    dwPropId) {
                                printf("  NextUpdateLocation::\n");
                                DecodeAndDisplayAltName(pbData, cbData,
                                    dwDisplayFlags);
                            }
                        } else
                            printf("     ERROR getting property bytes\n");
                        TestFree(pbData);
                    }
                } else
                    printf("     NO Property Bytes\n");
            }
            break;
        }
    }
}

//+-------------------------------------------------------------------------
//  Returns TRUE if the CTL is still time valid.
//
//  A CTL without a NextUpdate is considered time valid.
//--------------------------------------------------------------------------
BOOL IsTimeValidCtl(
    IN PCCTL_CONTEXT pCtl
    )
{
    PCTL_INFO pCtlInfo = pCtl->pCtlInfo;
    SYSTEMTIME SystemTime;
    FILETIME CurrentTime;

    // Get current time to be used to determine if CTLs are time valid
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &CurrentTime);

    // Note, NextUpdate is optional. When not present, its set to 0
    if ((0 == pCtlInfo->NextUpdate.dwLowDateTime &&
                0 == pCtlInfo->NextUpdate.dwHighDateTime) ||
            CompareFileTime(&pCtlInfo->NextUpdate, &CurrentTime) >= 0)
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Allocates and returns the specified cryptographic message parameter.
//--------------------------------------------------------------------------
static void *AllocAndGetMsgParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT DWORD *pcbData
    )
{
    void *pvData;
    DWORD cbData;

    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            NULL,           // pvData
            &cbData) || 0 == cbData)
        goto ErrorReturn;
    if (NULL == (pvData = TestAlloc(cbData)))
        goto ErrorReturn;
    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            pvData,
            &cbData)) {
        TestFree(pvData);
        goto ErrorReturn;
    }

CommonReturn:
    *pcbData = cbData;
    return pvData;
ErrorReturn:
    pvData = NULL;
    cbData = 0;
    goto CommonReturn;
}

void DisplaySignerInfo(
    HCRYPTMSG hMsg,
    DWORD dwSignerIndex,
    DWORD dwDisplayFlags
    )
{
    DWORD cbData;
    PCRYPT_ATTRIBUTES pAttrs;

    if (pAttrs = (PCRYPT_ATTRIBUTES) AllocAndGetMsgParam(
            hMsg,
            CMSG_SIGNER_AUTH_ATTR_PARAM,
            dwSignerIndex,
            &cbData)) {
        printf("-----  Signer [%d] AuthenticatedAttributes  -----\n",
            dwSignerIndex);
        PrintAttributes(pAttrs->cAttr, pAttrs->rgAttr, dwDisplayFlags);
        TestFree(pAttrs);
    }

    if (pAttrs = (PCRYPT_ATTRIBUTES) AllocAndGetMsgParam(
            hMsg,
            CMSG_SIGNER_UNAUTH_ATTR_PARAM,
            dwSignerIndex,
            &cbData)) {
        printf("-----  Signer [%d] UnauthenticatedAttributes  -----\n",
            dwSignerIndex);
        PrintAttributes(pAttrs->cAttr, pAttrs->rgAttr, dwDisplayFlags);
        TestFree(pAttrs);
    }
}

static BOOL CompareSortedAttributes(
    IN DWORD dwSubject,
    IN PCTL_ENTRY pEntry,
    IN PCRYPT_DER_BLOB pEncodedAttributes
    )
{
    BOOL fResult;
    PCRYPT_ATTRIBUTES pAttrs = NULL;
    DWORD i;

    if (0 == pEntry->cAttribute) {
        if (0 != pEncodedAttributes->cbData) {
            printf("failed => Didn't expect sorted attributes for subject %d\n",
                dwSubject);
            return FALSE;
        } else
            return TRUE;
    }

    if (0 == pEncodedAttributes->cbData) {
        printf("failed => Expected sorted attributes for subject %d\n",
            dwSubject);
        return FALSE;
    }

    if (NULL == (pAttrs = (PCRYPT_ATTRIBUTES) TestNoCopyDecodeObject(
            PKCS_ATTRIBUTES,
            pEncodedAttributes->pbData,
            pEncodedAttributes->cbData
            )))
        goto ErrorReturn;

    if (pAttrs->cAttr != pEntry->cAttribute) {
        printf("failed => Wrong number of sorted attributes for subject %d\n",
            dwSubject);
        goto ErrorReturn;
    }

    for (i = 0; i < pAttrs->cAttr; i++) {
        PCRYPT_ATTRIBUTE pAttr = &pEntry->rgAttribute[i];
        PCRYPT_ATTRIBUTE pSortedAttr = &pAttrs->rgAttr[i];
        DWORD j;

        if (0 != strcmp(pAttr->pszObjId, pSortedAttr->pszObjId)) {
            printf("failed => wrong sorted attribute[%d] OID for subject %d\n",
                i, dwSubject);
            goto ErrorReturn;
        }

        if (pAttr->cValue != pSortedAttr->cValue) {
            printf("failed => Wrong number of values for attribute[%d] for subject %d\n",
                i, dwSubject);
            goto ErrorReturn;
        }

        for (j = 0; j < pAttr->cValue; j++) {
            PCRYPT_ATTR_BLOB pValue = &pAttr->rgValue[j];
            PCRYPT_ATTR_BLOB pSortedValue = &pSortedAttr->rgValue[j];
            if (pValue->cbData != pSortedValue->cbData ||
                (0 != pValue->cbData &&
                    0 != memcmp(pValue->pbData, pSortedValue->pbData,
                            pValue->cbData))) {
                printf("failed => bad value[%d, %d] for subject %d\n",
                    i, j, dwSubject);
                goto ErrorReturn;
            }
        }
    }

    fResult = TRUE;

CommonReturn:
    TestFree(pAttrs);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}


void DisplayCtl(PCCTL_CONTEXT pCtl, DWORD dwDisplayFlags, HCERTSTORE hStore)
{
    PCTL_INFO pInfo = pCtl->pCtlInfo;
    PCCTL_CONTEXT pSortedCtl;

    if (dwDisplayFlags & DISPLAY_UI_FLAG) {
        DisplayContextUI(CERT_STORE_CTL_CONTEXT, pCtl);
        dwDisplayFlags = DISPLAY_BRIEF_FLAG;
    }

    // Test the creation of a sorted CTL. Its decoded output should match
    // the normal decoded CTL.
    if (NULL == (pSortedCtl = (PCCTL_CONTEXT) CertCreateContext(
            CERT_STORE_CTL_CONTEXT,
            pCtl->dwMsgAndCertEncodingType,
            pCtl->pbCtlEncoded,
            pCtl->cbCtlEncoded,
            CERT_CREATE_CONTEXT_NOCOPY_FLAG |
                CERT_CREATE_CONTEXT_SORTED_FLAG,
            NULL                                    // pCreatePara
            )))
        PrintLastError("CertCreateContext(CTL => NOCOPY, SORTED)");
    else {
        PCTL_INFO pSortedInfo = pSortedCtl->pCtlInfo;
        DWORD cEntry = pInfo->cCTLEntry;
        PCTL_ENTRY pEntry = pInfo->rgCTLEntry;
        DWORD iEntry;
        void *pvNextSubject;
        CRYPT_DER_BLOB SubjectIdentifier;
        CRYPT_DER_BLOB EncodedAttributes;

        // Check that the sorted info matches
        if (pSortedInfo->dwVersion != pInfo->dwVersion ||
                pSortedInfo->SubjectUsage.cUsageIdentifier !=
                    pInfo->SubjectUsage.cUsageIdentifier ||
                0 != CompareFileTime(&pSortedInfo->ThisUpdate,
                    &pInfo->ThisUpdate) ||
                0 != CompareFileTime(&pSortedInfo->NextUpdate,
                    &pInfo->NextUpdate) ||
                0 != strcmp(pSortedInfo->SubjectAlgorithm.pszObjId,
                        pInfo->SubjectAlgorithm.pszObjId) ||
                pSortedInfo->SubjectAlgorithm.Parameters.cbData !=
                        pInfo->SubjectAlgorithm.Parameters.cbData)
            printf("failed => SortedCtl info doesn't match Ctl info\n");
        else {
            // Check that the sorted extensions match
            DWORD cExt = pInfo->cExtension;
            PCERT_EXTENSION pExt = pInfo->rgExtension;
            DWORD cSortedExt = pSortedInfo->cExtension;
            PCERT_EXTENSION pSortedExt = pSortedInfo->rgExtension;

            if (cExt > 0 && 0 == strcmp(pExt->pszObjId, szOID_SORTED_CTL)) {
                cExt--,
                pExt++;
            }

            if (cSortedExt != cExt)
                printf("failed => SortedCtl extension count doesn't match Ctl\n");
            else {
                for ( ; cExt; cExt--, pSortedExt++, pExt++) {
                    if (0 != strcmp(pSortedExt->pszObjId, pExt->pszObjId) ||
                                pSortedExt->fCritical != pExt->fCritical ||
                            pSortedExt->Value.cbData != pExt->Value.cbData) {
                        printf("failed => SortedCtl extension doesn't match Ctl\n");
                        break;
                    }
                    if (pSortedExt->Value.cbData && 0 != memcmp(
                            pSortedExt->Value.pbData, pExt->Value.pbData,
                                pSortedExt->Value.cbData)) {
                        printf("failed => SortedCtl extension doesn't match Ctl\n");
                        break;
                    }
                }
            }
        }
        

        pvNextSubject = NULL;
        iEntry = 0;
        while (CertEnumSubjectInSortedCTL(
                pSortedCtl,
                &pvNextSubject,
                &SubjectIdentifier,
                &EncodedAttributes
                )) {
            if (iEntry >= cEntry) {
                printf( "failed => CertEnumSubjectInSortedCTL(too many subjects)\n");
                break;
            }
            if (SubjectIdentifier.cbData !=
                        pEntry[iEntry].SubjectIdentifier.cbData ||
                    0 != memcmp(SubjectIdentifier.pbData,
                            pEntry[iEntry].SubjectIdentifier.pbData,
                            SubjectIdentifier.cbData)) {
                printf("failed => CertEnumSubjectsInSortedCTL(invalid subject %d)\n",
                    iEntry);
                iEntry = cEntry;
                break;
            }
            if (!CompareSortedAttributes(
                    iEntry,
                    &pEntry[iEntry],
                    &EncodedAttributes
                    )) {
                iEntry = cEntry;
                break;
            }

            iEntry++;
        }

        if (iEntry != cEntry)
            printf( "failed => CertEnumSubjectInSortedCTL(missing subjects)\n");

        if (0 == cEntry) {
            BYTE rgbIdentifier[] = {0x1, 0x2};
            SubjectIdentifier.pbData = rgbIdentifier;
            SubjectIdentifier.cbData = sizeof(rgbIdentifier);

            if (CertFindSubjectInSortedCTL(
                    &SubjectIdentifier,
                    pSortedCtl,
                    0,                      // dwFlags
                    NULL,                   // pvReserved,
                    &EncodedAttributes
                    ))
                printf("failed => CertFindSubjectInSortedCTL returned success for no entries\n");
            else if (GetLastError() != CRYPT_E_NOT_FOUND)
                printf("failed => CertFindSubjectInSortedCTL didn't return CRYPT_E_NOT_FOUND for no entries\n");
        } else {
            DWORD rgiEntry[] = {0, cEntry/3, cEntry/2, cEntry -1};
            DWORD i;
            for (i = 0; i < sizeof(rgiEntry) / sizeof(rgiEntry[0]); i++) {
                iEntry = rgiEntry[i];
                if (!CertFindSubjectInSortedCTL(
                        &pEntry[iEntry].SubjectIdentifier,
                        pSortedCtl,
                        0,                      // dwFlags
                        NULL,                   // pvReserved,
                        &EncodedAttributes
                        )) {
                    PrintLastError("CertFindSubjectInSortedCTL");
                    break;
                }
            }
        }

        CertFreeCTLContext(pSortedCtl);
    }

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG)
        printf("Version:: %d\n", pInfo->dwVersion);

    {
        DWORD cId;
        LPSTR *ppszId;
        DWORD i;

        printf("SubjectUsage::\n");
        cId = pInfo->SubjectUsage.cUsageIdentifier;
        ppszId = pInfo->SubjectUsage.rgpszUsageIdentifier;
        if (cId == 0)
            printf("  No Usage Identifiers\n");
        for (i = 0; i < cId; i++, ppszId++)
            printf("  [%d] %s\n", i, *ppszId);
    }

    if (pInfo->ListIdentifier.cbData) {
        printf("ListIdentifier::\n");
        PrintBytes("    ",
            pInfo->ListIdentifier.pbData,
            pInfo->ListIdentifier.cbData);
    }
    if (pInfo->SequenceNumber.cbData) {
        printf("SequenceNumber::");
        DisplaySerialNumber(&pInfo->SequenceNumber);
        printf("\n");
    }

    printf("ThisUpdate:: %s\n", FileTimeText(&pCtl->pCtlInfo->ThisUpdate));
    printf("NextUpdate:: %s\n", FileTimeText(&pCtl->pCtlInfo->NextUpdate));
    if (!IsTimeValidCtl(pCtl))
        printf("****** Time Invalid CTL\n");

    {
        BYTE rgbHash[MAX_HASH_LEN];
        DWORD cbHash = MAX_HASH_LEN;
        CertGetCTLContextProperty(
            pCtl,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("SHA1", rgbHash, cbHash);
#if 0
        CertGetCTLContextProperty(
            pCtl,
            CERT_MD5_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("MD5", rgbHash, cbHash);
#endif
    }

    PrintAuxCtlProperties(pCtl, dwDisplayFlags);

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        LPSTR pszObjId;

        pszObjId = pInfo->SubjectAlgorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        printf("SubjectAlgorithm:: %s\n", pszObjId);
        if (pInfo->SubjectAlgorithm.Parameters.cbData) {
            printf("SubjectAlgorithm.Parameters::\n");
            PrintBytes("    ",
                pInfo->SubjectAlgorithm.Parameters.pbData,
                pInfo->SubjectAlgorithm.Parameters.cbData);
        }

        if (pInfo->cExtension != 0) {
            PrintExtensions(pInfo->cExtension, pInfo->rgExtension,
                dwDisplayFlags);
        }
    }

    if (dwDisplayFlags & DISPLAY_NO_ISSUER_FLAG)
        ;
    else if (0 == (dwDisplayFlags & DISPLAY_VERBOSE_FLAG)) {
        DWORD dwFlags;
        PCCERT_CONTEXT pSigner;

        if (dwDisplayFlags & DISPLAY_CHECK_FLAG)
            dwFlags = 0;
        else
            dwFlags = CMSG_SIGNER_ONLY_FLAG;
        if (CryptMsgGetAndVerifySigner(
                pCtl->hCryptMsg,
                1,                  // cSignerStore
                &hStore,            // rghSignerStore
                dwFlags,
                &pSigner,
                NULL                // pdwSignerIndex
                )) {
            printf("-----  Signer  -----\n");
            DisplayCert(pSigner, dwDisplayFlags & DISPLAY_BRIEF_FLAG);
            CertFreeCertificateContext(pSigner);
        } else {
            DWORD dwErr = GetLastError();
            if (CRYPT_E_NO_TRUSTED_SIGNER == dwErr)
                printf("-----  No Trusted Signer  -----\n");
            else {
                printf("-----  Signer  -----\n");
                PrintLastError("CryptMsgGetAndVerifySigner");
            }
        }
    } else {
        DWORD dwSignerCount;
        DWORD cbData;

        cbData = sizeof(dwSignerCount);
        if (!CryptMsgGetParam(
                pCtl->hCryptMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                      // dwIndex
                &dwSignerCount,
                &cbData)) {
            printf("-----  Signer  -----\n");
            PrintLastError("CryptMsgGetParam(SIGNER_COUNT)");
        } else if (0 == dwSignerCount)
            printf("-----  No Signers  -----\n");
        else {
            DWORD dwSignerIndex;
            for (dwSignerIndex = 0; dwSignerIndex < dwSignerCount;
                                                            dwSignerIndex++) {
                DWORD dwFlags;
                PCCERT_CONTEXT pSigner;

                dwFlags = CMSG_USE_SIGNER_INDEX_FLAG;
                if (0 == (dwDisplayFlags & DISPLAY_CHECK_FLAG))
                    dwFlags |= CMSG_SIGNER_ONLY_FLAG;
                if (CryptMsgGetAndVerifySigner(
                        pCtl->hCryptMsg,
                        1,                  // cSignerStore
                        &hStore,            // rghSignerStore
                        dwFlags,
                        &pSigner,
                        &dwSignerIndex
                        )) {
                    printf("-----  Signer [%d]  -----\n", dwSignerIndex);
                    DisplayCert(pSigner, 0);
                    CertFreeCertificateContext(pSigner);
                } else {
                    DWORD dwErr = GetLastError();
                    if (CRYPT_E_NO_TRUSTED_SIGNER == dwErr)
                        printf("-----  No Trusted Signer [%d]  -----\n",
                            dwSignerIndex);
                    else {
                        printf("-----  Signer [%d]  -----\n", dwSignerIndex);
                        PrintLastError("CryptMsgGetAndVerifySigner");
                    }
                }

                DisplaySignerInfo(pCtl->hCryptMsg, dwSignerIndex,
                    dwDisplayFlags);
            }
        }
    }

    if (0 == (dwDisplayFlags & DISPLAY_BRIEF_FLAG)) {
        if (pInfo->cCTLEntry == 0)
            printf("-----  No Entries  -----\n");
        else {
            printf("-----  Entries  -----\n");
            PrintCtlEntries(pCtl, dwDisplayFlags, hStore);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\pkcs8im\pkcs8im.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       pkcs8im.cpp
//
//  Contents:   Private Key Load Test
//
//              See Usage() for list of load options.
//
//  Functions:  main
//
//  History:    6-26-96   
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static struct
{
    LPCSTR      pszName;
    LPCWSTR     pwszKeyTitle;
    DWORD       dwKeySpec;
} KeyTypes[] = {
    "Sign",     L"Signature",   AT_SIGNATURE,
    "Xchg",     L"Exchange",    AT_KEYEXCHANGE
};
#define NKEYTYPES (sizeof(KeyTypes)/sizeof(KeyTypes[0]))


static void Usage(void)
{
    int i;

    printf("Usage: pkcs8im [options] <Filename> <KeyType>\n");
    printf("Options are:\n");
    printf("  -p<name>              - Crypto provider name (if not default)\n");
    printf("  -c<name>              - Crypto key container name\n");
    printf("  -E                    - Exportable private keys\n");
    printf("  -h                    - This message\n");
    printf("\n");
    printf("KeyType (case insensitive):\n");
    for (i = 0; i < NKEYTYPES; i++)
        printf("  %s\n", KeyTypes[i].pszName);
    printf("\n");
}


static BOOL CALLBACK ResolvehCryptFunc(
	CRYPT_PRIVATE_KEY_INFO	*pPrivateKeyInfo,
	HCRYPTPROV			*phCryptProv,
	LPVOID				pVoidResolveFunc)
{
	CRYPT_KEY_PROV_INFO *pCryptKeyProvInfo = (CRYPT_KEY_PROV_INFO *) pVoidResolveFunc;
	
	return (CryptAcquireContext(
				phCryptProv,
				(LPSTR) pCryptKeyProvInfo->pwszContainerName,
				(LPSTR) pCryptKeyProvInfo->pwszProvName,
				PROV_RSA_FULL,
				CRYPT_NEWKEYSET));
}



int _cdecl main(int argc, char * argv[]) 
{
    int ReturnStatus;
    HCRYPTPROV hProv = 0;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    BOOL fForce = FALSE;
    BYTE *pbKey = NULL;
	DWORD cbKey;
    DWORD cbRead;
	LPSTR pszProvider = NULL;
	DWORD numWideChars;
    LPSTR pszContainer = NULL;
    LPSTR pszFilename = NULL;
    LPSTR pszKeyType = NULL;
    int KeyIdx = 0;
    DWORD dwFlags = 0;
	DWORD dwKeySpec = 0;
	CRYPT_KEY_PROV_INFO CryptKeyProvInfo;
	CRYPT_PRIVATE_KEY_BLOB_AND_PARAMS KeyBlobAndParams;
	BYTE *pPrivateKeyBuffer = NULL;


    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'F':
                fForce = TRUE;
                break;
            case 'E':
                dwFlags = CRYPT_EXPORTABLE;
                break;
            case 'p':
                 pszProvider = (LPSTR) argv[0]+2; 
									
                if (*pszContainer == L'\0') {
                    printf("Need to specify crypto key container name\n");
                    goto BadUsage;
                }
                break;
            case 'c':
				pszContainer = (LPSTR) argv[0]+2;
									
                if (*pszContainer == L'\0') {
                    printf("Need to specify crypto key container name\n");
                    goto BadUsage;
                }
                break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (pszFilename == NULL)
                pszFilename = argv[0];
            else if(pszKeyType == NULL)
                pszKeyType = argv[0];
            else {
                printf("Too many arguments\n");
                goto BadUsage;
            }
        }
    }

    if (pszFilename == NULL) {
        printf("missing Filename\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());
    
    if (pszKeyType) {
        for (KeyIdx = 0; KeyIdx < NKEYTYPES; KeyIdx++) {
            if (_stricmp(pszKeyType, KeyTypes[KeyIdx].pszName) == 0)
                break;
        }
        if (KeyIdx >= NKEYTYPES) {
            printf("Bad KeyType: %s\n", pszKeyType);
            goto BadUsage;
        }
    } else {
        printf("No KeyType specified... using type specified in key\n");
    }

    hFile = CreateFileA(
            pszFilename,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,                   // lpsa
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL                    // hTemplateFile
            );
    if (hFile == INVALID_HANDLE_VALUE) {
        printf( "can't open %s\n", pszFilename);
        goto ErrorReturn;
    }
	
	memset(&CryptKeyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));
	CryptKeyProvInfo.pwszContainerName = (LPWSTR) pszContainer;
	CryptKeyProvInfo.pwszProvName = (LPWSTR) pszProvider;
	if (pszKeyType)
		CryptKeyProvInfo.dwKeySpec = KeyTypes[KeyIdx].dwKeySpec;
	else
		CryptKeyProvInfo.dwKeySpec = 0;

    cbKey = GetFileSize(hFile, NULL);
    if (cbKey == 0) {
        printf( "empty file %s\n", pszFilename);
        goto ErrorReturn;
    }
    if (NULL == (pbKey = (PBYTE)TestAlloc(cbKey)))
        goto ErrorReturn;

    if (!ReadFile(hFile, pbKey, cbKey, &cbRead, NULL) ||
            (cbRead != cbKey)) {
        printf( "can't read %s\n", pszFilename);
        goto ErrorReturn;
    }

	KeyBlobAndParams.PrivateKey.cbData = cbKey;
	KeyBlobAndParams.PrivateKey.pbData = pbKey;
	KeyBlobAndParams.pResolvehCryptProvFunc = ResolvehCryptFunc;
	KeyBlobAndParams.pVoidResolveFunc = &CryptKeyProvInfo;
	KeyBlobAndParams.pDecryptPrivateKeyFunc = NULL;
	KeyBlobAndParams.pVoidDecryptFunc = NULL;
    
	if (!CryptImportPKCS8(
			KeyBlobAndParams,
			dwFlags,
			NULL,
			NULL
			)) {
            PrintLastError("CryptImportPKCS8()");
            goto ErrorReturn;
        }

	if (dwKeySpec == AT_SIGNATURE)
		printf("Key imported as type 'Sign'\n");
	else if (dwKeySpec == AT_KEYEXCHANGE)
		printf("Key imported as type 'Xchg'\n");

    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
CommonReturn:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (hProv)
        CryptReleaseContext(hProv, 0);
    if (pbKey)
        TestFree(pbKey);
	if (!ReturnStatus)
            printf("Passed\n");
    else
            printf("Failed\n");

    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\pkcs8ex\pkcs8ex.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       pkcs8ex.cpp
//
//  Contents:   Private Key Save Test
//
//              See Usage() for list of save options.
//
//  Functions:  main
//
//  History:    11-May-96   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static struct
{
    LPCSTR      pszName;
    LPCWSTR     pwszKeyTitle;
    DWORD       dwKeySpec;
} KeyTypes[] = {
    "Sign",     L"Signature",   AT_SIGNATURE,
    "Xchg",     L"Exchange",    AT_KEYEXCHANGE
};
#define NKEYTYPES (sizeof(KeyTypes)/sizeof(KeyTypes[0]))


static void Usage(void)
{
    int i;

    printf("Usage: pkcs8ex [options] <Filename> <KeyType>\n");
    printf("Options are:\n");
    printf("  -p<name>              - Crypto provider name (if not default)\n");
    printf("  -c<name>              - Crypto key container name\n");
    printf("  -d                    - Delete from provider after saving\n");
    printf("  -h                    - This message\n");
    printf("\n");
    printf("KeyType (case insensitive):\n");
    
	for (i = 0; i < NKEYTYPES; i++)
		printf("  %s\n", KeyTypes[i].pszName);
    printf("\n");
}


int _cdecl main(int argc, char * argv[]) 
{
    int ReturnStatus;
    HCRYPTPROV hProv = 0;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwProvType = PROV_RSA_FULL;
    BOOL fDelete = FALSE;
    LPSTR pszContainer = NULL;
    LPSTR pszFilename = NULL;
    BYTE *pbKey = NULL;
	DWORD cbKey = 0;
    LPSTR pszKeyType = NULL;
    int KeyIdx = 0;
	DWORD numBytesWritten;
	DWORD dwFlags;

    while (--argc>0)
    {
		if (**++argv == '-')
		{
			switch(argv[0][1])
			{
			case 'd':
				fDelete = TRUE;
				break;
			case 'p':
				dwProvType = strtoul( argv[0]+2, NULL, 10);
				break;
			case 'c':
				pszContainer = argv[0]+2;
				if (*pszContainer == '\0') {
					printf("Need to specify crypto key container name\n");
					goto BadUsage;
				}
				break;
			case 'h':
				default:
				goto BadUsage;
			}
		} else {
			if (pszFilename == NULL)
				pszFilename = argv[0];
			else if(pszKeyType == NULL)
				pszKeyType = argv[0];
			else {
				printf("Too many arguments\n");
			goto BadUsage;
			}
		}
    }

	printf("command line: %s\n", GetCommandLine());

    if (pszFilename == NULL) {
		printf("missing Filename\n");
		goto BadUsage;
    }


    if (pszKeyType) {
		for (KeyIdx = 0; KeyIdx < NKEYTYPES; KeyIdx++) {
			if (_stricmp(pszKeyType, KeyTypes[KeyIdx].pszName) == 0)
				break;
	}
	if (KeyIdx >= NKEYTYPES) {
	    printf("Bad KeyType: %s\n", pszKeyType);
	    goto BadUsage;
	}
    } else {
		printf("missing KeyType\n");
		goto BadUsage;
    }

    if (!CryptAcquireContext(
			&hProv,
			pszContainer,
			NULL,           // pszProvider
			dwProvType,
			0               // dwFlags
			)) {
		PrintLastError("CryptAcquireContext\n");
		goto ErrorReturn;
    }

    hFile = CreateFileA(
	    pszFilename,
	    GENERIC_READ | GENERIC_WRITE,
	    FILE_SHARE_READ,
	    NULL,                   // lpsa
	    CREATE_ALWAYS,
	    FILE_ATTRIBUTE_NORMAL,
	    NULL                    // hTemplateFile
	    );
    if (hFile == INVALID_HANDLE_VALUE) {
		printf("can't open %s\n", pszFilename);
		printf("Failed");
		goto ErrorReturn;
    }
	
	if (!CryptExportPKCS8(
			hProv,                  
			KeyTypes[KeyIdx].dwKeySpec,             
			szOID_RSA_RSA,
			0,                      
			NULL,                   
			NULL,   
			&cbKey)) {
		PrintLastError("CryptExportPKCS8");
		goto ErrorReturn;
    }

	if (NULL == (pbKey = (BYTE *) TestAlloc(cbKey))) {
		printf("memory allocation error\n");
		goto ErrorReturn;
    }

	/*if (fDelete)
		dwFlags = DELETE_KEYSET;
	else
		dwFlags = 0;*/

	if (!CryptExportPKCS8(
			hProv,                  
			KeyTypes[KeyIdx].dwKeySpec,             
			szOID_RSA_RSA,
			0,                      
			NULL,                   
			pbKey,  
			&cbKey)) {
		PrintLastError("CryptExportPKCS8");
		goto ErrorReturn;
    }

	
	if (!WriteFile( 
			hFile, 
			pbKey, 
			cbKey, 
			&numBytesWritten, 
			NULL)) {
		PrintLastError("WriteFile");
		goto ErrorReturn;
    }
	
	if (fDelete) {
		// Delete the existing keys
		CryptReleaseContext(hProv, 0);
		printf("Deleting existing private keys\n");

		// Note: for CRYPT_DELETEKEYSET, the returned hProv is undefined
		// and must not be released.
		if (!CryptAcquireContext(
				&hProv,
				pszContainer,
				NULL,           // pszProvider
				dwProvType,
				CRYPT_DELETEKEYSET
				)) {
				PrintLastError("CryptAcquireContext(CRYPT_DELETEKEYSET)");
				hProv = 0;
				goto ErrorReturn;
		}
		hProv = 0;
    }
	    
    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
    if (hFile != INVALID_HANDLE_VALUE) {
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
		DeleteFile(pszFilename);
    }
CommonReturn:
    if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
    if (hProv)
		CryptReleaseContext(hProv, 0);
    if (pbKey)
		TestFree(pbKey);

    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tcert\tcert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tcert.cpp
//
//  Contents:   Certificate and CRL Encode/Decode API Tests
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    04-Mar-96   philh   created
//              07-Jun-96   HelleS  Added printing the command line
//                                  and Failed or Passed at the end.
//              20-Aug-96   jeffspel name changes
//              
//--------------------------------------------------------------------------

#include <windows.h>
#include <regstr.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <stddef.h>

#include <wincrypt.h>
#include <signcde.h>
//#include <crypt32l.h>


// Note: the SubjectPublicKey is really the PKCS #1 ASN encoding of the
// following information. However, since the SubjectPublicKeyInfo.PublicKey
// is a CRYPT_BIT_BLOB that following is OK for testing purposes.
#ifndef RSA1
#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#endif
// Build my own CAPI public key
typedef struct _CAPI_PUB_KEY {
    PUBLICKEYSTRUC PubKeyStruc;
    RSAPUBKEY RsaPubKey;
    BYTE rgbModulus[10];
} CAPI_PUB_KEY;

static const CAPI_PUB_KEY SubjectPublicKey = {
    {PUBLICKEYBLOB, CUR_BLOB_VERSION, 0, CALG_RSA_SIGN},    // PUBLICKEYSTRUC
    {RSA1, 10*8, 4},        // RSAPUBKEY
    {0,1,2,3,4,5,6,7,8,9}   // rgbModulus
};

static LPSTR pszReadFilename = NULL;
static LPSTR pszPublicKeyFilename = NULL;
static BOOL fWritePublicKeyInfo = FALSE;

static LPSTR pszForwardCertFilename = NULL;
static LPSTR pszReverseCertFilename = NULL;

//+-------------------------------------------------------------------------
// Parameters, data used to encode the messages.
//--------------------------------------------------------------------------
static DWORD dwCertEncodingType = X509_ASN_ENCODING;

static DWORD dwDecodeObjectFlags = 0;
static BOOL fFormatNameStrings = FALSE;
static BOOL fFormatAllNameStrings = FALSE;
static DWORD dwExtLen = 0;

static LPCSTR pszOIDNoSignHash = szOID_OIWSEC_sha1;

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
static void PrintError(LPCSTR pszMsg)
{
    printf("%s\n", pszMsg);
}
static void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

void PrintNoError(LPCSTR pszMsg)
{
    printf("%s failed => expected error\n", pszMsg);
}

//+-------------------------------------------------------------------------
//  Test allocation and free routines
//--------------------------------------------------------------------------
static void *TestAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("TestAlloc");
    }
    return pv;
}
static void TestFree(
    IN void *pv
    )
{
    if (pv)
        free(pv);
}

static CRYPT_DECODE_PARA TestDecodePara = {
    offsetof(CRYPT_DECODE_PARA, pfnFree) + sizeof(TestDecodePara.pfnFree),
    TestAlloc,
    TestFree
};

static void *TestDecodeObject(
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    OUT OPTIONAL DWORD *pcbStructInfo = NULL
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwDecodeObjectFlags | CRYPT_DECODE_ALLOC_FLAG,
            &TestDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    if (pcbStructInfo)
        *pcbStructInfo = cbStructInfo;
    return pvStructInfo;

ErrorReturn:
    if ((DWORD_PTR) lpszStructType <= 0xFFFF)
        printf("CryptDecodeObject(StructType: %d)",
            (DWORD)(DWORD_PTR) lpszStructType);
    else
        printf("CryptDecodeObject(StructType: %s)",
            lpszStructType);
    PrintLastError("");

    pvStructInfo = NULL;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Allocate and read an encoded DER blob from a file
//--------------------------------------------------------------------------
BOOL
ReadDERFromFile(
    LPCSTR  pszFileName,
    PBYTE   *ppbDER,
    PDWORD  pcbDER
    )
{
    BOOL        fRet;
    HANDLE      hFile = 0;
    PBYTE       pbDER = NULL;
    DWORD       cbDER;
    DWORD       cbRead;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile( pszFileName, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        printf( "can't open %s\n", pszFileName);
        goto ErrorReturn;
    }

    cbDER = GetFileSize( hFile, NULL);
    if (cbDER == 0) {
        printf( "empty file %s\n", pszFileName);
        goto ErrorReturn;
    }
    if (NULL == (pbDER = (PBYTE)TestAlloc(cbDER))) {
        printf( "can't alloc %d bytes\n", cbDER);
        goto ErrorReturn;
    }
    if (!ReadFile( hFile, pbDER, cbDER, &cbRead, NULL) ||
            (cbRead != cbDER)) {
        printf( "can't read %s\n", pszFileName);
        goto ErrorReturn;
    }

    *ppbDER = pbDER;
    *pcbDER = cbDER;
    fRet = TRUE;
CommonReturn:
    if (hFile)
        CloseHandle(hFile);
    return fRet;
ErrorReturn:
    if (pbDER)
        TestFree(pbDER);
    *ppbDER = NULL;
    *pcbDER = 0;
    fRet = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
BOOL
WriteDERToFile(
    LPCSTR  pszFileName,
    PBYTE   pbDER,
    DWORD   cbDER
    )
{
    BOOL fResult;

    // Write the Encoded Blob to the file
    HANDLE hFile;
    hFile = CreateFile(pszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        fResult = FALSE;
        PrintLastError("WriteDERToFile::CreateFile");
    } else {
        DWORD dwBytesWritten;
        if (!(fResult = WriteFile(
                hFile,
                pbDER,
                cbDER,
                &dwBytesWritten,
                NULL            // lpOverlapped
                )))
            PrintLastError("WriteDERToFile::WriteFile");
        CloseHandle(hFile);
    }
    return fResult;
}


typedef BOOL (*PFN_ENCODE)(BYTE **ppbEncoded, DWORD *pcbEncoded);
typedef BOOL (*PFN_DECODE)(BYTE *pbEncoded, DWORD cbEncoded);
typedef struct _TEST {
    LPCSTR      pszName;
    PFN_ENCODE  pfnEncode;
    PFN_DECODE  pfnDecode;
} TEST, *PTEST;

static BOOL EncodeCert(BYTE **ppbEncoded, DWORD *pcbEncoded);
static BOOL DecodeCert(BYTE *pbEncoded, DWORD cbEncoded);
static BOOL EncodeCrl(BYTE **ppbEncoded, DWORD *pcbEncoded);
static BOOL DecodeCrl(BYTE *pbEncoded, DWORD cbEncoded);
static BOOL EncodeCertReq(BYTE **ppbEncoded, DWORD *pcbEncoded);
static BOOL DecodeCertReq(BYTE *pbEncoded, DWORD cbEncoded);
static BOOL EncodeKeygenReq(BYTE **ppbEncoded, DWORD *pcbEncoded);
static BOOL DecodeKeygenReq(BYTE *pbEncoded, DWORD cbEncoded);
static BOOL EncodeContentInfo(BYTE **ppbEncoded, DWORD *pcbEncoded);
static BOOL DecodeContentInfo(BYTE *pbEncoded, DWORD cbEncoded);
static BOOL EncodeCertPair(BYTE **ppbEncoded, DWORD *pcbEncoded);
static BOOL DecodeCertPair(BYTE *pbEncoded, DWORD cbEncoded);

TEST Tests[] = {
    "cert",         EncodeCert,         DecodeCert,
    "crl",          EncodeCrl,          DecodeCrl,
    "certReq",      EncodeCertReq,      DecodeCertReq,
    "keygenReq",    EncodeKeygenReq,    DecodeKeygenReq,
    "ContentInfo",  EncodeContentInfo,  DecodeContentInfo,
    "CertPair",     EncodeCertPair,     DecodeCertPair
};
#define NTESTS (sizeof(Tests)/sizeof(Tests[0]))

static void Usage(void)
{
    int i;

    printf("Usage: tcert [options] [<ContentType>]\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -r<filename>          - Read encoded content from file\n");
    printf("  -w<filename>          - Write encoded content to file\n");
    printf("  -p<filename>          - Write public key to file\n");
    printf("  -P<filename>          - Write Name, PublicKeyInfo to file\n");
    printf("  -f                    - Enable name string formatting\n");
    printf("  -fAll                 - Name string formatting (All types)\n");
    printf("  -N                    - Enable NOCOPY decode\n");
    printf("  -o<OID>               - NoSignHash OID (SHA1 is default)\n");
    printf("  -X<number>            - eXtension byte length\n");
    printf("  -F<CertFilename>      - CertPair Forward certificate\n");
    printf("  -R<CertFilename>      - CertPair Reverse certificate\n");
    printf("\n");
    printf("ContentTypes (case insensitive):\n");
    for (i = 0; i < NTESTS; i++)
        printf("  %s\n", Tests[i].pszName);
    printf("\n");
    printf("Default: %s\n", Tests[0].pszName);
}

int _cdecl main(int argc, char * argv[]) 
{
    int ReturnStatus;
    BOOL fResult;

    LPCSTR pszName = Tests[0].pszName;
    LPSTR pszWriteFilename = NULL;
    int c;
    PTEST pTest;

    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

/*
    if (!Crypt32DllMain( NULL, DLL_PROCESS_ATTACH, NULL)) {
        printf("Crypt32DllMain attach failed, aborting\n");
        ReturnStatus = -1;
        goto CommonReturn;
    }
*/

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'r':
                pszReadFilename = argv[0]+2;
                if (*pszReadFilename == '\0') {
                    printf("Need to specify filename\n");
                    goto BadUsage;
                }
                break;
            case 'w':
                pszWriteFilename = argv[0]+2;
                if (*pszWriteFilename == '\0') {
                    printf("Need to specify filename\n");
                    goto BadUsage;
                }
                break;
            case 'P':
                fWritePublicKeyInfo = TRUE;
            case 'p':
                pszPublicKeyFilename = argv[0]+2;
                if (*pszPublicKeyFilename == '\0') {
                    printf("Need to specify filename\n");
                    goto BadUsage;
                }
                break;
            case 'F':
                pszForwardCertFilename = argv[0]+2;
                if (*pszForwardCertFilename == '\0') {
                    printf("Need to specify Forward filename\n");
                    goto BadUsage;
                }
                break;
            case 'R':
                pszReverseCertFilename = argv[0]+2;
                if (*pszReverseCertFilename == '\0') {
                    printf("Need to specify Reverse filename\n");
                    goto BadUsage;
                }
                break;
            case 'N':
                dwDecodeObjectFlags |= CRYPT_DECODE_NOCOPY_FLAG;
                break;
            case 'X':
                dwExtLen = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'f':
                if (argv[0][2]) {
                    if (0 != _stricmp(argv[0]+2, "ALL")) {
                        printf("Need to specify -fALL\n");
                        goto BadUsage;
                    }
                    fFormatAllNameStrings = TRUE;
                } else
                    fFormatNameStrings = TRUE;
                break;
            case 'o':
                pszOIDNoSignHash = (LPCSTR) argv[0]+2;
                break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else
            pszName = argv[0];
    }

    for (c = NTESTS, pTest = Tests; c > 0; c--, pTest++) {
        if (_stricmp(pszName, pTest->pszName) == 0)
            break;
    }
    if (c == 0) {
        printf("Bad ContentType: %s\n", pszName);
        goto BadUsage;
    }
            
    printf("command line: %s\n", GetCommandLine());

    if (pszReadFilename) printf("Reading from: %s ", pszReadFilename);
    if (pszWriteFilename) printf("Writing to: %s ", pszWriteFilename);
    if (pszPublicKeyFilename) {
        if (fWritePublicKeyInfo)
            printf("PublicKeyInfo to: %s ", pszPublicKeyFilename);
        else
            printf("Public Key to: %s ", pszPublicKeyFilename);
    }
    if (pszForwardCertFilename)
        printf("ForwardCert: %s ", pszForwardCertFilename);
    if (pszReverseCertFilename)
        printf("ReverseCert: %s ", pszReverseCertFilename);
    printf("\n");

    if (pszReadFilename)
        fResult = ReadDERFromFile(pszReadFilename, &pbEncoded, &cbEncoded);
    else
        fResult = pTest->pfnEncode(&pbEncoded, &cbEncoded);

    if (fResult) {
        if (pszWriteFilename)
            WriteDERToFile(pszWriteFilename, pbEncoded, cbEncoded);
        pTest->pfnDecode(pbEncoded, cbEncoded);
        TestFree(pbEncoded);
    }

    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
    ReturnStatus = -1;
CommonReturn:
    if (!ReturnStatus)
            printf("Passed\n");
    else
            printf("Failed\n");

/*
    if (!Crypt32DllMain( NULL, DLL_PROCESS_DETACH, NULL)) {
        printf("Crypt32DllMain detach failed, aborting\n");
        ReturnStatus = -1;
    }
*/

    return ReturnStatus;

}

static BOOL EncodeSignedContent(
    BYTE *pbToBeSigned,
    DWORD cbToBeSigned,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbSignature = NULL;
    DWORD cbSignature;
    CERT_SIGNED_CONTENT_INFO CertEncoding;

    CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm = {
        (LPSTR) pszOIDNoSignHash, 0, 0
    };

    CRYPT_DATA_BLOB EncodedBlob;

    cbSignature = 0;
    if (!CryptSignCertificate(
            NULL,               // hCryptProv
            0,                  // dwKeySpec
            dwCertEncodingType,
            pbToBeSigned,
            cbToBeSigned,
            &SignatureAlgorithm,
            NULL,               // pvHashAuxInfo
            NULL,               // pbSignature
            &cbSignature
            )) {
        PrintLastError("EncodeSignedContent::CryptSignCertificate(cbEncoded == 0)");
        goto ErrorReturn;
    }

    pbSignature = (BYTE *) TestAlloc(cbSignature);
    if (pbSignature == NULL) goto ErrorReturn;
    if (!CryptSignCertificate(
            NULL,               // hCryptProv
            0,                  // dwKeySpec
            dwCertEncodingType,
            pbToBeSigned,
            cbToBeSigned,
            &SignatureAlgorithm,
            NULL,               // pvHashAuxInfo
            pbSignature,
            &cbSignature
            )) {
        PrintLastError("EncodeSignedContent::CryptSignCertificate");
        goto ErrorReturn;
    }

    ZeroMemory(&CertEncoding, sizeof(CertEncoding));
    CertEncoding.ToBeSigned.pbData = pbToBeSigned;
    CertEncoding.ToBeSigned.cbData = cbToBeSigned;
    CertEncoding.SignatureAlgorithm = SignatureAlgorithm;
    CertEncoding.Signature.pbData = pbSignature;
    CertEncoding.Signature.cbData = cbSignature;
    cbEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT,
            &CertEncoding,
            NULL,                       // pbEncoded
            &cbEncoded
            );
    if (cbEncoded == 0) {
        PrintLastError("EncodeSignedContent::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbEncoded = (BYTE *) TestAlloc(cbEncoded);
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT,
            &CertEncoding,
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError("EncodeSignedContent::CryptEncodeObject");
        goto ErrorReturn;
    }

    EncodedBlob.cbData = cbEncoded;
    EncodedBlob.pbData = pbEncoded;

    if (!CryptVerifyCertificateSignatureEx(
            NULL,                   // hCryptProv
            dwCertEncodingType,
            CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB,
            (void *) &EncodedBlob,
            CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL,
            NULL,                   // pvIssuer
            0,                      // dwFlags
            NULL                    // pvReserved
            )) {
        PrintLastError("EncodeSignedContent::CryptVerifyCertificateSignatureEx");
    }


    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbSignature)
        TestFree(pbSignature);
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static void PrintBadUnicodeEncode(LPCSTR pszMsg, DWORD dwExpectedErr,
        DWORD cbEncoded)
{
    DWORD dwErr = GetLastError();

    if (dwErr != dwExpectedErr)
        printf("%s failed => expected : 0x%x (%d), LastError: 0x%x (%d)\n", 
            pszMsg, dwExpectedErr, dwExpectedErr, dwErr, dwErr);
    printf("%s bad unicode encode => LastError: 0x%x (%d) ",
        pszMsg, dwErr, dwErr);
    printf("cbEncoded: 0x%x RDN: %d Attr: %d Value: %d\n",
        cbEncoded,
        GET_CERT_UNICODE_RDN_ERR_INDEX(cbEncoded),
        GET_CERT_UNICODE_ATTR_ERR_INDEX(cbEncoded),
        GET_CERT_UNICODE_VALUE_ERR_INDEX(cbEncoded));
}

static void DoBadEncodeIssuer()
{
    DWORD cbIssuerEncoded;

    CERT_RDN_ATTR rgBadPrintableAttr[] = {
        // 0 - rgdwPrintableOrT61ValueType,
        szOID_COMMON_NAME, 0, 0,
            (BYTE *) L"CN: printable or t61",

        // 1 - rgdwPrintableOrT61ValueType,
        szOID_LOCALITY_NAME, 0, 0,
            (BYTE *) L"L: printable or t61 \"###\"",

        // 2 - BAD rgdwPrintableValueType,
        szOID_COUNTRY_NAME, 0, 0,
            (BYTE *) L"C: printable ### az AZ 09 \'()+,-./:=? "
    };
    CERT_RDN rgBadPrintableRDN[] = {
        1, &rgBadPrintableAttr[0],
        3, &rgBadPrintableAttr[0]
    };
    CERT_NAME_INFO BadPrintableName = {2, rgBadPrintableRDN};

    CERT_RDN_ATTR rgBadNumericAttr[] = {
        // 0 - rgdwPrintableOrT61ValueType,
        szOID_COMMON_NAME, 0, 0,
            (BYTE *) L"CN: printable or t61",

        // 1 - rgdwPrintableValueType,
        szOID_COUNTRY_NAME, 0, 0,
            (BYTE *) L"C: printable az AZ 09 \'()+,-./:=? ",

        // 2 - rgdwPrintableOrT61ValueType,
        szOID_LOCALITY_NAME, 0, 0,
            (BYTE *) L"L: printable or t61 \"###\"",

        // 3 - BAD rgdwNumericValueType,
        szOID_X21_ADDRESS, 0, 0,
            (BYTE *) L"0123456789a ",

        // 4 - none, use default
        szOID_REGISTERED_ADDRESS, 0, 0,
            (BYTE *) L"Default"
    };
    CERT_RDN rgBadNumericRDN[] = {
        1, &rgBadNumericAttr[0],
        1, &rgBadNumericAttr[1],
        1, &rgBadNumericAttr[2],
        1, &rgBadNumericAttr[3],
        1, &rgBadNumericAttr[4]
    };
    CERT_NAME_INFO BadNumericName = {5, rgBadNumericRDN};

    // This one has non-zero dwValueTypes
    CERT_RDN_ATTR rgBadNumericAttr2[] = {
        // 0 - rgdwPrintableOrT61ValueType,
        szOID_COMMON_NAME, CERT_RDN_PRINTABLE_STRING, 0,
            (BYTE *) L"CN: printable or t61",

        // 1 - rgdwPrintableValueType,
        szOID_COUNTRY_NAME, CERT_RDN_PRINTABLE_STRING, 0,
            (BYTE *) L"C: printable az AZ 09 \'()+,-./:=? ",

        // 2 - rgdwPrintableOrT61ValueType,
        szOID_LOCALITY_NAME, CERT_RDN_T61_STRING, 0,
            (BYTE *) L"L: printable or t61 \"###\"",

        // 3 - BAD rgdwNumericValueType,
        szOID_X21_ADDRESS, CERT_RDN_NUMERIC_STRING, 0,
            (BYTE *) L"0123456789a ",

        // 4 - none, use default
        szOID_REGISTERED_ADDRESS, CERT_RDN_IA5_STRING, 0,
            (BYTE *) L"Default"
    };
    CERT_RDN rgBadNumericRDN2[] = {
        1, &rgBadNumericAttr2[0],
        1, &rgBadNumericAttr2[1],
        1, &rgBadNumericAttr2[2],
        4, &rgBadNumericAttr2[1],
        1, &rgBadNumericAttr2[4]
    };
    CERT_NAME_INFO BadNumericName2 = {5, rgBadNumericRDN2};

    BYTE rgbBadIA5[] = {0x80, 0x00, 0x00, 0x00};
    CERT_RDN_ATTR rgBadIA5Attr[] = {
        // 0 - BAD rgdwIA5ValueType
        szOID_RSA_emailAddr, 0, 0,
            rgbBadIA5,
    };
    CERT_RDN rgBadIA5RDN[] = {
        1, &rgBadIA5Attr[0]
    };
    CERT_NAME_INFO BadIA5Name = {1, rgBadIA5RDN};

    cbIssuerEncoded = 0;
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadPrintableName,
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ))
        PrintNoError("X509_UNICODE_NAME:: BadPrintableName");
    else
        PrintBadUnicodeEncode("PrintableString",
            (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING, cbIssuerEncoded);

    cbIssuerEncoded = 0;
    rgBadPrintableAttr[2].dwValueType = CERT_RDN_PRINTABLE_STRING;
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadPrintableName,
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ))
        PrintNoError("X509_UNICODE_NAME:: BadPrintableName(set dwValueType)");
    else
        PrintBadUnicodeEncode("PrintableString(set dwValueType)",
            (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING, cbIssuerEncoded);

    cbIssuerEncoded = 0;
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadPrintableName,
            CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG,
            NULL,               // pEncodePara
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ) || 0 == cbIssuerEncoded)
        PrintLastError("X509_UNICODE_NAME:: DISABLE_CHECK dwFlags");

    rgBadPrintableAttr[2].dwValueType =
        CERT_RDN_DISABLE_CHECK_TYPE_FLAG | CERT_RDN_PRINTABLE_STRING;
    cbIssuerEncoded = 0;
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadPrintableName,
            0,
            NULL,               // pEncodePara
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ) || 0 == cbIssuerEncoded)
        PrintLastError("X509_UNICODE_NAME:: DISABLE_CHECK dwValueType");

    cbIssuerEncoded = 0;
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadPrintableName,
            CRYPT_UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG,
            NULL,               // pEncodePara
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ) || 0 == cbIssuerEncoded)
        PrintLastError("X509_UNICODE_NAME:: ENABLE_T61 dwFlags");

    rgBadPrintableAttr[1].dwValueType =
        CERT_RDN_ENABLE_T61_UNICODE_FLAG;
    cbIssuerEncoded = 0;
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadPrintableName,
            0,
            NULL,               // pEncodePara
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ) || 0 == cbIssuerEncoded)
        PrintLastError("X509_UNICODE_NAME:: ENABLE_T61 dwValueType");

    cbIssuerEncoded = 0;
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadPrintableName,
            CRYPT_UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG,
            NULL,               // pEncodePara
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ) || 0 == cbIssuerEncoded)
        PrintLastError("X509_UNICODE_NAME:: ENABLE_UTF8 dwFlags");

    cbIssuerEncoded = 0;
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadNumericName,
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ))
        PrintNoError("X509_UNICODE_NAME:: BadNumericName");
    else
        PrintBadUnicodeEncode("NumericString",
            (DWORD) CRYPT_E_INVALID_NUMERIC_STRING, cbIssuerEncoded);

    cbIssuerEncoded = 0;
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadNumericName2,
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ))
        PrintNoError("X509_UNICODE_NAME:: BadNumericName2");
    else
        PrintBadUnicodeEncode("NumericString2",
            (DWORD) CRYPT_E_INVALID_NUMERIC_STRING, cbIssuerEncoded);

    cbIssuerEncoded = 0;
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadIA5Name,
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ))
        PrintNoError("X509_UNICODE_NAME:: BadIA5Name");
    else
        PrintBadUnicodeEncode("IA5String",
            (DWORD) CRYPT_E_INVALID_IA5_STRING, cbIssuerEncoded);
}

static BYTE *EncodeIssuer(DWORD *pcbIssuerEncoded)
{
    BYTE *pbIssuerEncoded = NULL;
    DWORD cbIssuerEncoded;

    BYTE rgbOctet[] = {1, 0xFF, 0x7F};
    BYTE rgbEncodedBlob[] = {0x05, 00};

    CERT_RDN_ATTR rgAttr[] = {
        // 0 - rgdwPrintableOrT61ValueType
        szOID_COMMON_NAME, 0, 0,
            (BYTE *) L"CN: printable or t61",

        // 1 - rgdwPrintableValueType
        szOID_COUNTRY_NAME, 0, 0,
            (BYTE *) L"C: printable az AZ 09 \'()+,-./:=? ",

        // 2 - rgdwPrintableOrT61ValueType
        szOID_LOCALITY_NAME, 0, 0,
            (BYTE *) L"L: printable or t61 \"###\"",

        // 3 - rgdwNumericValueType
        szOID_X21_ADDRESS, 0, 0,
            (BYTE *) L" 0123456789 ",

        // 4 - none, use default
        szOID_REGISTERED_ADDRESS, 0, 0,
            (BYTE *) L"Default",

        // 5 - rgdwIA5ValueType
        szOID_RSA_emailAddr, 0, 0,
            (BYTE *) L"Email, IA5 !@#$%^&*()_+{|}",

        // 6 - Unicode
        "1.2.2.5", CERT_RDN_BMP_STRING, 0,
            (BYTE *) L"Null terminated UNICODE",

        // 7 - Unicode
        "1.2.2.5.1", CERT_RDN_BMP_STRING, 10 *2,
            (BYTE *) L"Length UNICODE",

        // 8 - Universal
        "1.2.2.5.2", CERT_RDN_UNIVERSAL_STRING, 0,
            (BYTE *) L"Universal ~!@#$%^&*()_+{}:\"<>?",

        // 9 - Octet
        "1.2.2.5.3", CERT_RDN_OCTET_STRING, sizeof(rgbOctet),
            rgbOctet,

        // 10 - EncodedBlob
        "1.2.2.5.4", CERT_RDN_ENCODED_BLOB, sizeof(rgbEncodedBlob),
            rgbEncodedBlob,

        // 11 - Empty rgdwPrintableOrT61ValueType
        szOID_LOCALITY_NAME, 0, 0, NULL,

        // 12 - Empty rgdwNumericValueType
        szOID_X21_ADDRESS, 0, 0, NULL,

        // 13 - DC (IA5)
        szOID_DOMAIN_COMPONENT, 0, 0,
            (BYTE *) L"microsoft",

        // 14 - DC (IA5)
        szOID_DOMAIN_COMPONENT, 0, 0,
            (BYTE *) L"com",

        // 15 - UTF8
        "1.2.8.5", CERT_RDN_UTF8_STRING, 0,
            (BYTE *) L"Null terminated UTF8",

        // 16 - UTF8
        "1.2.8.5.1", CERT_RDN_UTF8_STRING, 11 *2,
            (BYTE *) L"Length UTF8",

        // Note, FFFE and FFFF are excluded from the UTF8 standard
        // 17 - UTF8
        "1.2.8.5.2", CERT_RDN_UTF8_STRING, 0,
            (BYTE *) L"SPECIAL UTF8: "
        L"\x0001 \x0002 \x007e \x007f "
        L"\x0080 \x0081 \x07fe \x07ff "
        L"\x0800 \x0801 \xfffc \xfffd",

        // 18 - UNICODE
        "1.2.8.5.3", CERT_RDN_UNICODE_STRING, 0,
            (BYTE *) L"SPECIAL UNICODE: "
        L"\x0001 \x0002 \x007e \x007f "
        L"\x0080 \x0081 \x07fe \x07ff "
        L"\x0800 \x0801 \xfffe \xffff",

        // 19 - DC (UTF8)
        szOID_DOMAIN_COMPONENT, 0, 0,
            (BYTE *) L"Unicode DC: "
        L"\x0001 \x0002 \x007e \x007f "
        L"\x0080 \x0081 \x07fe \x07ff "
        L"\x0800 \x0801 \xfffe \xffff",

        // 20 - Universal
        "1.2.2.5.2.1.1.1", CERT_RDN_UNIVERSAL_STRING, 0,
            (BYTE *) L"SPECIAL UNIVERSAL with Surrogate Pairs: "
        L"\xd800\xdc00\xdbff\xdfff"
        L"\xdbfe\xdc03\xd801\xdfcf"
        L"\xd801\x0081\xdc01\xdc02"
        L"\xd805\xd806\xd807\xdc04"
        L"\xd802\xd803\xfffe\xd804",
       
    };

    CERT_RDN rgRDN[] = {
        1, &rgAttr[0],
        1, &rgAttr[1],
        1, &rgAttr[2],
        1, &rgAttr[3],
        1, &rgAttr[4],
        1, &rgAttr[5],
        3, &rgAttr[5],
        13, &rgAttr[8]
    };
    CERT_NAME_INFO Name = {8, rgRDN};

    DoBadEncodeIssuer();

    cbIssuerEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &Name,
            NULL,               // pbEncoded
            &cbIssuerEncoded
            );
    if (cbIssuerEncoded == 0) {
        PrintLastError("EncodeIssuer::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbIssuerEncoded = (BYTE *) TestAlloc(cbIssuerEncoded);
    if (pbIssuerEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &Name,
            pbIssuerEncoded,
            &cbIssuerEncoded
            )) {
        PrintLastError("EncodeIssuer::CryptEncodeObject");
        goto ErrorReturn;
    }

    goto CommonReturn;

ErrorReturn:
    if (pbIssuerEncoded)
        TestFree(pbIssuerEncoded);
    pbIssuerEncoded = NULL;
    cbIssuerEncoded = 0;
CommonReturn:
    *pcbIssuerEncoded = cbIssuerEncoded;
    return pbIssuerEncoded;
}

static BOOL EncodeCert(BYTE **ppbEncoded, DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbIssuerEncoded = NULL;
    DWORD cbIssuerEncoded;

    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded;

    DWORD SerialNumber[2] = {0x12345678, 0x33445566};
    SYSTEMTIME SystemTime;

#define ISSUER_UNIQUE_ID "IssuerUniqueId"

#define ATTR_0_0 "attr 0_0 printable"
#define ATTR_0_1 "attr 0_1 IA5"
#define ATTR_1_0 "attr 1_0 numeric"
#define ATTR_1_1 "attr 1_1 octet"
#define ATTR_2_0 "attr 2_0 teletex"
#define ATTR_2_1 "attr 2_1 videotex"
#define ATTR_2_2 "attr 2_2 graphic"
#define ATTR_2_3 "attr 2_3 visible"
#define ATTR_2_4 "attr 2_4 general"
#define ATTR_2_5 L"attr 2_5 BMP:: Unicode"
#define ATTR_2_6 L"attr 2_6 UTF8:: Unicode"

    ULONG Universal[] = {0x12345678, 0, 0xFFFF1111, 0x87654321,
        0x00FFFF,
        0x010000,
        0x010001,
        0x10FFFE,
        0x10FFFF,
        0x110000,
        0x10F803,
        0x0107CF,
        0x011C04,
        };

    BYTE NullDer[] = {0x05, 0x00};
    BYTE IntegerDer[] = {0x02, 0x01, 0x35};
    CERT_RDN_ATTR rgAttr0[] = {
        "1.2.0.0", CERT_RDN_PRINTABLE_STRING,
            strlen(ATTR_0_0), (BYTE *) ATTR_0_0,
        "1.2.0.1", CERT_RDN_IA5_STRING,
             strlen(ATTR_0_1), (BYTE *) ATTR_0_1
    };
    CERT_RDN_ATTR rgAttr1[] = {
        "1.2.1.0", CERT_RDN_NUMERIC_STRING,
            strlen(ATTR_1_0), (BYTE *) ATTR_1_0,
        "1.2.1.1", CERT_RDN_OCTET_STRING,
            strlen(ATTR_1_1), (BYTE *) ATTR_1_1,
        "1.2.1.2", CERT_RDN_PRINTABLE_STRING,
            0, NULL,
        "1.2.1.3", CERT_RDN_ENCODED_BLOB,
            sizeof(NullDer), NullDer,
        "1.2.1.4", CERT_RDN_ENCODED_BLOB,
            sizeof(IntegerDer), IntegerDer 
    };
    CERT_RDN_ATTR rgAttr2[] = {
        "1.2.2.0", CERT_RDN_TELETEX_STRING,
            strlen(ATTR_2_0), (BYTE *) ATTR_2_0,
        "1.2.2.1", CERT_RDN_VIDEOTEX_STRING,
            strlen(ATTR_2_1), (BYTE *) ATTR_2_1,
        "1.2.2.2", CERT_RDN_GRAPHIC_STRING,
            strlen(ATTR_2_2), (BYTE *) ATTR_2_2,
        "1.2.2.3", CERT_RDN_VISIBLE_STRING,
            strlen(ATTR_2_3), (BYTE *) ATTR_2_3,
        "1.2.2.4", CERT_RDN_GENERAL_STRING,
            strlen(ATTR_2_4), (BYTE *) ATTR_2_4,
        "1.2.2.5", CERT_RDN_BMP_STRING,
            wcslen(ATTR_2_5) * 2, (BYTE *) ATTR_2_5,
        "1.2.2.6", CERT_RDN_UTF8_STRING,
            wcslen(ATTR_2_6) * 2, (BYTE *) ATTR_2_6,
        "1.2.2.7", CERT_RDN_UNIVERSAL_STRING,
            sizeof(Universal), (BYTE *) Universal
    };

    CERT_RDN_ATTR rgAttr3[] = {
        "1.2.2.2", CERT_RDN_OCTET_STRING,
            0, NULL,
        "1.2.2.3", CERT_RDN_NUMERIC_STRING,
            0, NULL,
        "1.2.2.4", CERT_RDN_PRINTABLE_STRING,
            0, NULL,
        "1.2.2.5", CERT_RDN_TELETEX_STRING,
            0, NULL,
        "1.2.2.6", CERT_RDN_VIDEOTEX_STRING,
            0, NULL,
        "1.2.2.7", CERT_RDN_IA5_STRING,
            0, NULL,
        "1.2.2.8", CERT_RDN_GRAPHIC_STRING,
            0, NULL,
        "1.2.2.9", CERT_RDN_VISIBLE_STRING,
            0, NULL,
        "1.2.2.10", CERT_RDN_GENERAL_STRING,
            0, NULL,
        "1.2.2.11", CERT_RDN_UNIVERSAL_STRING,
            0, NULL,
        "1.2.2.12", CERT_RDN_BMP_STRING,
            0, NULL,
        "1.2.2.13", CERT_RDN_UTF8_STRING,
            0, NULL
    };
    CERT_RDN rgRDN[] = {
        2, rgAttr0,
        5, rgAttr1,
        8, rgAttr2,
        12, rgAttr3
    };
    CERT_NAME_INFO Name = {4, rgRDN};

#define EXT_0 "extension 0 ."
#define EXT_1 "extension 1 .."
#define EXT_2 "extension 2 ..."
#define EXT_3 "extension 3 ...."
    CERT_EXTENSION rgExt[] = {
        "1.14.0", TRUE, strlen(EXT_0), (BYTE *) EXT_0,
        "1.14.1.35.45", FALSE, strlen(EXT_1), (BYTE *) EXT_1,
        "1.14.2", TRUE, strlen(EXT_2), (BYTE *) EXT_2,
        "1.14.4", FALSE, strlen(EXT_3), (BYTE *) EXT_3
    };
    CERT_INFO Cert;
    BYTE *pbExt = NULL;

    if (dwExtLen) {
        DWORD i;
        if (NULL == (pbExt = (BYTE *) TestAlloc(dwExtLen)))
            goto ErrorReturn;

        for (i = 0; i < dwExtLen; i++)
            pbExt[i] = (BYTE) i;

        rgExt[3].Value.cbData = dwExtLen;
        rgExt[3].Value.pbData = pbExt;
    }
        
    cbNameEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            NULL,               // pbEncoded
            &cbNameEncoded
            );
    if (cbNameEncoded == 0) {
        PrintLastError("EncodeCert::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbNameEncoded = (BYTE *) TestAlloc(cbNameEncoded);
    if (pbNameEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            pbNameEncoded,
            &cbNameEncoded
            )) {
        PrintLastError("EncodeCert::CryptEncodeObject");
        goto ErrorReturn;
    }

    pbIssuerEncoded = EncodeIssuer(&cbIssuerEncoded);
    if (NULL == pbIssuerEncoded)
        goto ErrorReturn;

    memset(&Cert, 0, sizeof(Cert));
    Cert.dwVersion = CERT_V3;
    Cert.SerialNumber.pbData = (BYTE *) &SerialNumber;
    Cert.SerialNumber.cbData = sizeof(SerialNumber);
    Cert.SignatureAlgorithm.pszObjId = "1.2.4.5.898";
    Cert.Issuer.pbData = pbIssuerEncoded;
    Cert.Issuer.cbData = cbIssuerEncoded;

    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &Cert.NotBefore);
    SystemTime.wYear++;
    SystemTimeToFileTime(&SystemTime, &Cert.NotAfter);

    Cert.Subject.pbData = pbNameEncoded;
    Cert.Subject.cbData = cbNameEncoded;
    Cert.SubjectPublicKeyInfo.Algorithm.pszObjId = "1.3.4.5.911";
    Cert.SubjectPublicKeyInfo.PublicKey.pbData = (BYTE *) &SubjectPublicKey;
    Cert.SubjectPublicKeyInfo.PublicKey.cbData = sizeof(SubjectPublicKey);
    Cert.IssuerUniqueId.pbData = (BYTE *) ISSUER_UNIQUE_ID;
    Cert.IssuerUniqueId.cbData = strlen(ISSUER_UNIQUE_ID);
    Cert.IssuerUniqueId.cUnusedBits = 5;
    // Cert.SubjectUniqueId = 0
    Cert.cExtension = sizeof(rgExt) / sizeof(rgExt[0]);
    Cert.rgExtension = rgExt;

    cbCertEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT_TO_BE_SIGNED,
            &Cert,
            NULL,               // pbEncoded
            &cbCertEncoded
            );
    if (cbCertEncoded == 0) {
        PrintLastError("EncodeCert::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbCertEncoded = (BYTE *) TestAlloc(cbCertEncoded);
    if (pbCertEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT_TO_BE_SIGNED,
            &Cert,
            pbCertEncoded,
            &cbCertEncoded
            )) {
        PrintLastError("EncodeCert::CryptEncodeObject");
        goto ErrorReturn;
    }

    if (!EncodeSignedContent(
            pbCertEncoded,
            cbCertEncoded,
            ppbEncoded,
            pcbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbNameEncoded)
        TestFree(pbNameEncoded);
    if (pbIssuerEncoded)
        TestFree(pbIssuerEncoded);
    if (pbCertEncoded)
        TestFree(pbCertEncoded);
    if (pbExt)
        TestFree(pbExt);

    return fResult;
}

static BOOL EncodeCertReq(BYTE **ppbEncoded, DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;
    BYTE *pbCertReqEncoded = NULL;
    DWORD cbCertReqEncoded;

    BYTE *pbExtEncoded = NULL;
    DWORD cbExtEncoded;


#define CERT_REQ_0 "Cert Request subject 0"
#define CERT_REQ_1 "Cert Request subject 1 ...."
#define CERT_REQ_2 "Cert Request subject 2 ......."
    

    CERT_RDN_ATTR rgNameAttr[] = {
        "1.2.1.0", CERT_RDN_PRINTABLE_STRING,
            strlen(CERT_REQ_0), (BYTE *) CERT_REQ_0,
        "1.2.1.1", CERT_RDN_PRINTABLE_STRING,
            strlen(CERT_REQ_1), (BYTE *) CERT_REQ_1,
        "1.2.1.2", CERT_RDN_PRINTABLE_STRING,
            strlen(CERT_REQ_2), (BYTE *) CERT_REQ_2
    };
    CERT_RDN rgRDN[] = {
        1, &rgNameAttr[0],
        1, &rgNameAttr[1],
        1, &rgNameAttr[2]
    };
    CERT_NAME_INFO Name = {3, rgRDN};

    BYTE NullDer[] = {0x05, 0x00};
    BYTE IntegerDer[] = {0x02, 0x01, 0x35};
    CRYPT_ATTR_BLOB rgAttrBlob[2] = {
            2, (BYTE *) NullDer,
            3, (BYTE *) IntegerDer
    };

    CRYPT_ATTR_BLOB ExtAttrBlob;

    CRYPT_ATTRIBUTE rgAttr[] = {
        szOID_RSA_certExtensions,
            1, &ExtAttrBlob,
        "1.2.3.4.5.0", 
            1, rgAttrBlob,
        "1.2.1.1.1.1.1.1", 
            2, rgAttrBlob
    };

#define REQ_EXT_0 "request extension 0 -"
#define REQ_EXT_1 "request extension 1 --"
#define REQ_EXT_2 "request extension 2 ---"
#define REQ_EXT_3 "request extension 3 ----"
    CERT_EXTENSION rgExt[4] = {
        "2.50.0", FALSE, strlen(REQ_EXT_0), (BYTE *) REQ_EXT_0,
        "2.51.1", TRUE, strlen(REQ_EXT_1), (BYTE *) REQ_EXT_1,
        "2.52.2", FALSE, strlen(REQ_EXT_2), (BYTE *) REQ_EXT_2,
        "2.53.3", FALSE, strlen(REQ_EXT_3), (BYTE *) REQ_EXT_3
    };
    CERT_EXTENSIONS Extensions = {4, &rgExt[0]};

    CERT_REQUEST_INFO CertReq;

    cbNameEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            NULL,               // pbEncoded
            &cbNameEncoded
            );
    if (cbNameEncoded == 0) {
        PrintLastError("EncodeCertReq::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbNameEncoded = (BYTE *) TestAlloc(cbNameEncoded);
    if (pbNameEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            pbNameEncoded,
            &cbNameEncoded
            )) {
        PrintLastError("EncodeCertReq::CryptEncodeObject");
        goto ErrorReturn;
    }

    cbExtEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_EXTENSIONS,
            &Extensions,
            NULL,               // pbEncoded
            &cbExtEncoded
            );
    if (cbExtEncoded == 0) {
        PrintLastError("EncodeCertReq::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbExtEncoded = (BYTE *) TestAlloc(cbExtEncoded);
    if (pbExtEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_EXTENSIONS,
            &Extensions,
            pbExtEncoded,
            &cbExtEncoded
            )) {
        PrintLastError("EncodeCertReq::CryptEncodeObject");
        goto ErrorReturn;
    }
    ExtAttrBlob.pbData = pbExtEncoded;
    ExtAttrBlob.cbData = cbExtEncoded;

    memset(&CertReq, 0, sizeof(CertReq));
    CertReq.dwVersion = 2;
    CertReq.Subject.pbData = pbNameEncoded;
    CertReq.Subject.cbData = cbNameEncoded;
    CertReq.SubjectPublicKeyInfo.Algorithm.pszObjId = "1.3.4.5.911";
    CertReq.SubjectPublicKeyInfo.PublicKey.pbData = (BYTE *) &SubjectPublicKey;
    CertReq.SubjectPublicKeyInfo.PublicKey.cbData = sizeof(SubjectPublicKey);
    CertReq.cAttribute = sizeof(rgAttr) / sizeof(rgAttr[0]);
    CertReq.rgAttribute = rgAttr;

    cbCertReqEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT_REQUEST_TO_BE_SIGNED,
            &CertReq,
            NULL,               // pbEncoded
            &cbCertReqEncoded
            );
    if (cbCertReqEncoded == 0) {
        PrintLastError("EncodeCertReq::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbCertReqEncoded = (BYTE *) TestAlloc(cbCertReqEncoded);
    if (pbCertReqEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT_REQUEST_TO_BE_SIGNED,
            &CertReq,
            pbCertReqEncoded,
            &cbCertReqEncoded
            )) {
        PrintLastError("EncodeCertReq::CryptEncodeObject");
        goto ErrorReturn;
    }

    if (!EncodeSignedContent(
            pbCertReqEncoded,
            cbCertReqEncoded,
            ppbEncoded,
            pcbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbExtEncoded)
        TestFree(pbExtEncoded);
    if (pbNameEncoded)
        TestFree(pbNameEncoded);
    if (pbCertReqEncoded)
        TestFree(pbCertReqEncoded);

    return fResult;
}

static BOOL EncodeKeygenReq(BYTE **ppbEncoded, DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbKeygenReqEncoded = NULL;
    DWORD cbKeygenReqEncoded;

    CERT_KEYGEN_REQUEST_INFO KeygenReq;

    memset(&KeygenReq, 0, sizeof(KeygenReq));
    KeygenReq.dwVersion = CERT_KEYGEN_REQUEST_V1;
    KeygenReq.SubjectPublicKeyInfo.Algorithm.pszObjId = "1.3.4.5.911";
    KeygenReq.SubjectPublicKeyInfo.PublicKey.pbData = (BYTE *) &SubjectPublicKey;
    KeygenReq.SubjectPublicKeyInfo.PublicKey.cbData = sizeof(SubjectPublicKey);
    KeygenReq.pwszChallengeString = L"Keygen Challenge String";

    cbKeygenReqEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_KEYGEN_REQUEST_TO_BE_SIGNED,
            &KeygenReq,
            NULL,               // pbEncoded
            &cbKeygenReqEncoded
            );
    if (cbKeygenReqEncoded == 0) {
        PrintLastError("EncodeKeygenReq::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbKeygenReqEncoded = (BYTE *) TestAlloc(cbKeygenReqEncoded);
    if (pbKeygenReqEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_KEYGEN_REQUEST_TO_BE_SIGNED,
            &KeygenReq,
            pbKeygenReqEncoded,
            &cbKeygenReqEncoded
            )) {
        PrintLastError("EncodeKeygenReq::CryptEncodeObject");
        goto ErrorReturn;
    }

    if (!EncodeSignedContent(
            pbKeygenReqEncoded,
            cbKeygenReqEncoded,
            ppbEncoded,
            pcbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbKeygenReqEncoded)
        TestFree(pbKeygenReqEncoded);

    return fResult;
}

static BOOL EncodeContentInfo(BYTE **ppbEncoded, DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    CRYPT_CONTENT_INFO ContentInfo;
    BYTE rgb0[] = {0x4, 0x5, 0x11, 0x22, 0x33, 0x44, 0x55}; // OCTET STRING
    CRYPT_DER_BLOB Content = {
        sizeof(rgb0), rgb0
    };


    memset(&ContentInfo, 0, sizeof(ContentInfo));
    ContentInfo.pszObjId = "1.2.3.4.5.6.7.8.9.10";
    ContentInfo.Content = Content;

    cbEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            PKCS_CONTENT_INFO,
            &ContentInfo,
            NULL,               // pbEncoded
            &cbEncoded
            );
    if (cbEncoded == 0) {
        PrintLastError("EncodeContentInfo::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbEncoded = (BYTE *) TestAlloc(cbEncoded);
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            PKCS_CONTENT_INFO,
            &ContentInfo,
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError("EncodeContent::CryptEncodeObject");
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;

CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;

    return fResult;
}

static LPCSTR FileTimeText(FILETIME *pft)
{
    static char buf[80];
    FILETIME ftLocal;
    struct tm ctm;
    SYSTEMTIME st;

    FileTimeToLocalFileTime(pft, &ftLocal);
    if (FileTimeToSystemTime(&ftLocal, &st))
    {
        ctm.tm_sec = st.wSecond;
        ctm.tm_min = st.wMinute;
        ctm.tm_hour = st.wHour;
        ctm.tm_mday = st.wDay;
        ctm.tm_mon = st.wMonth-1;
        ctm.tm_year = st.wYear-1900;
        ctm.tm_wday = st.wDayOfWeek;
        ctm.tm_yday  = 0;
        ctm.tm_isdst = 0;
        strcpy(buf, asctime(&ctm));
        buf[strlen(buf)-1] = 0;
    }
    else
        sprintf(buf, "<FILETIME %08lX:%08lX>", pft->dwHighDateTime,
                pft->dwLowDateTime);
    return buf;
}

#define CROW 16
static void PrintBytes(LPCSTR pszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;

    while (cbSize > 0)
    {
        printf("%s", pszHdr);
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            printf(" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        pb += cb;
        printf("'\n");
    }
}

static BOOL DecodeName(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD i,j;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;
    
    if (NULL == (pInfo = (PCERT_NAME_INFO) TestDecodeObject(
            X509_NAME,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    for (i = 0, pRDN = pInfo->rgRDN; i < pInfo->cRDN; i++, pRDN++) {
        for (j = 0, pAttr = pRDN->rgRDNAttr; j < pRDN->cRDNAttr; j++, pAttr++) {
            LPSTR pszObjId = pAttr->pszObjId;
            if (pszObjId == NULL)
                pszObjId = "<NULL OBJID>";
            printf("  [%d,%d] %s ValueType: %d\n",
                i, j, pszObjId, pAttr->dwValueType);
            if (pAttr->Value.cbData)
                PrintBytes("    ", pAttr->Value.pbData, pAttr->Value.cbData);
            else
                printf("    NO Value Bytes\n");
        }
    }

    if (fFormatAllNameStrings) {
        CERT_NAME_BLOB Name;
        DWORD cwsz;
        LPWSTR pwsz;
        DWORD csz;
        LPSTR psz;
        Name.pbData = pbEncoded;
        Name.cbData = cbEncoded;
#define DELTA_DECRMENT    7
        DWORD dwDelta;

        DWORD rgdwStrType[] = {
            CERT_SIMPLE_NAME_STR,
            CERT_OID_NAME_STR,
            CERT_X500_NAME_STR,
            CERT_SIMPLE_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG |
                CERT_NAME_STR_NO_PLUS_FLAG | CERT_NAME_STR_NO_QUOTING_FLAG,
            CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG |
                CERT_NAME_STR_NO_QUOTING_FLAG,
            CERT_X500_NAME_STR | CERT_NAME_STR_CRLF_FLAG,
            0
        };
        DWORD *pdwStrType;

        for (pdwStrType = rgdwStrType, dwDelta = DELTA_DECRMENT; *pdwStrType;
                                pdwStrType++, dwDelta += DELTA_DECRMENT) {
            printf("\nCertNameToStrW(dwStrType == 0x%x)\n", *pdwStrType);
            cwsz = CertNameToStrW(
                dwCertEncodingType,
                &Name,
                *pdwStrType,
                NULL,                   // pwsz
                0);                     // cwsz
            if (pwsz = (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR))) {
                CertNameToStrW(
                    dwCertEncodingType,
                    &Name,
                    *pdwStrType,
                    pwsz,
                    cwsz);
                printf("  %S\n", pwsz);
                if (cwsz > dwDelta) {
                    CertNameToStrW(
                        dwCertEncodingType,
                        &Name,
                        *pdwStrType,
                        pwsz,
                        cwsz - dwDelta);
                    printf("Delta[-%d]\n", dwDelta);
                    printf("  %S\n", pwsz);
                }
                TestFree(pwsz);
            }
        }

        for (pdwStrType = rgdwStrType, dwDelta = DELTA_DECRMENT; *pdwStrType;
                                pdwStrType++, dwDelta += DELTA_DECRMENT) {
            printf("\nCertNameToStrA(dwStrType == 0x%x)\n", *pdwStrType);
            csz = CertNameToStrA(
                dwCertEncodingType,
                &Name,
                *pdwStrType,
                NULL,                   // psz
                0);                     // csz
            if (psz = (LPSTR) TestAlloc(csz)) {
                CertNameToStrA(
                    dwCertEncodingType,
                    &Name,
                    *pdwStrType,
                    psz,
                    csz);
                printf("  %s\n", psz);
                if (csz > dwDelta) {
                    csz = CertNameToStrA(
                        dwCertEncodingType,
                        &Name,
                        *pdwStrType,
                        psz,
                        csz - dwDelta);
                    printf("Delta[-%d]\n", dwDelta);
                    if (1 >= csz) {
                        DWORD dwErr = GetLastError();
                        printf("  No CertNameToStrA string, LastError: 0x%x (%d) \n",
                            dwErr, dwErr);
                    } else
                        printf("  %s\n", psz);
                }
                TestFree(psz);
            }
        }
    } else if (fFormatNameStrings) {
        CERT_NAME_BLOB Name;
        DWORD cwsz;
        LPWSTR pwsz;
        Name.pbData = pbEncoded;
        Name.cbData = cbEncoded;

        cwsz = CertNameToStrW(
            dwCertEncodingType,
            &Name,
            CERT_X500_NAME_STR,
            NULL,                   // pwsz
            0);                     // cwsz
        if (pwsz = (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR))) {
            CertNameToStrW(
                dwCertEncodingType,
                &Name,
                CERT_X500_NAME_STR,
                pwsz,
                cwsz);
            printf("  %S\n", pwsz);
            TestFree(pwsz);
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static void DecodeSignedContent(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    LPCSTR lpszToBeSignedStructType,
    DWORD cbToBeSignedStruct
    )
{
    BOOL fResult;
    PCERT_INFO pInfo = NULL;
    LPSTR pszObjId;
    DWORD cbInfo;

    PCERT_SIGNED_CONTENT_INFO pCertEncoding;
    
    if (NULL == (pCertEncoding = (PCERT_SIGNED_CONTENT_INFO) TestDecodeObject(
            X509_CERT,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    // Decode the ToBeSigned
    cbInfo = 0x12345678;
    if (!CryptDecodeObject(
            dwCertEncodingType,
            lpszToBeSignedStructType,
            pCertEncoding->ToBeSigned.pbData,
            pCertEncoding->ToBeSigned.cbData,
            dwDecodeObjectFlags | CRYPT_DECODE_TO_BE_SIGNED_FLAG,
            NULL,                   // pvInfo
            &cbInfo))
        PrintLastError("CryptDecodeObject(TO_BE_SIGNED_FLAG)");
    else if (cbInfo != cbToBeSignedStruct)
        printf("failed => CryptDecodeObject(TO_BE_SIGNED_FLAG) returned cbInfo = %d, not %d\n",
            cbInfo, cbToBeSignedStruct);
    cbInfo = 0x12345678;
    if (!CryptDecodeObject(
            dwCertEncodingType,
            lpszToBeSignedStructType,
            pCertEncoding->ToBeSigned.pbData,
            pCertEncoding->ToBeSigned.cbData,
            dwDecodeObjectFlags,
            NULL,                   // pvInfo
            &cbInfo))
        PrintLastError("CryptDecodeObject(ToBeSigned, without flag)");
    else if (cbInfo != cbToBeSignedStruct)
        printf("failed => CryptDecodeObject(ToBeSigned without flag) returned cbInfo = %d, not %d\n",
            cbInfo, cbToBeSignedStruct);

    pszObjId = pCertEncoding->SignatureAlgorithm.pszObjId;
    if (pszObjId == NULL)
        pszObjId = "<NULL OBJID>";
    printf("Content SignatureAlgorithm:: %s\n", pszObjId);
    if (pCertEncoding->SignatureAlgorithm.Parameters.cbData) {
        printf("Content SignatureAlgorithm.Parameters::\n");
        PrintBytes("    ", pCertEncoding->SignatureAlgorithm.Parameters.pbData,
            pCertEncoding->SignatureAlgorithm.Parameters.cbData);
    }

    if (pCertEncoding->Signature.cbData) {
        printf("Content Signature::\n");
        PrintBytes("    ", pCertEncoding->Signature.pbData,
            pCertEncoding->Signature.cbData);
    } else
        printf("Content Signature:: NONE\n");

    printf("Content Length:: %d\n", pCertEncoding->ToBeSigned.cbData);

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pCertEncoding)
        TestFree(pCertEncoding);
}

static void PrintExtensions(DWORD cExt, PCERT_EXTENSION pExt)
{
    DWORD i; 

    for (i = 0; i < cExt; i++, pExt++) {
        LPSTR pszObjId = pExt->pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        LPSTR pszCritical = pExt->fCritical ? "TRUE" : "FALSE";
        printf("  [%d] %s Critical: %s\n", i, pszObjId, pszCritical);
        if (pExt->Value.cbData)
            PrintBytes("    ", pExt->Value.pbData, pExt->Value.cbData);
        else
            printf("    NO Value Bytes\n");
    }
}

static void DecodeExtensions(BYTE *pbEncoded, DWORD cbEncoded)
{
    PCERT_EXTENSIONS pInfo;
    if (NULL == (pInfo = (PCERT_EXTENSIONS) TestDecodeObject(
            X509_EXTENSIONS,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    PrintExtensions(pInfo->cExtension, pInfo->rgExtension);
    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void PrintAttributes(DWORD cAttr, PCRYPT_ATTRIBUTE pAttr)
{
    DWORD i; 
    DWORD j; 

    for (i = 0; i < cAttr; i++, pAttr++) {
        DWORD cValue = pAttr->cValue;
        PCRYPT_ATTR_BLOB pValue = pAttr->rgValue;
        LPSTR pszObjId = pAttr->pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        if (cValue) {
            for (j = 0; j < cValue; j++, pValue++) {
                printf("  [%d,%d] %s\n", i, j, pszObjId);
                if (pValue->cbData) {
                    PrintBytes("    ", pValue->pbData, pValue->cbData);
                    if (strcmp(pszObjId, szOID_RSA_certExtensions) == 0 ||
                        strcmp(pszObjId, SPC_CERT_EXTENSIONS_OBJID) == 0) {
                        printf("  Extensions::\n");
                        DecodeExtensions(pValue->pbData, pValue->cbData);
                    }
                } else
                    printf("    NO Value Bytes\n");
            }
        } else
            printf("  [%d] %s :: No Values\n", i, pszObjId);
    }
}

//+-------------------------------------------------------------------------
//  Write the public key to the file
//--------------------------------------------------------------------------
BOOL WritePublicKeyToFile(
    LPCSTR  pszFileName,
    PBYTE   pbPub,
    DWORD   cbPub
    )
{
    FILE *stream;
    DWORD i;

    if (NULL == (stream = fopen(pszFileName, "w"))) {
        printf("Failed to open %s for writing public key\n", pszFileName);
        return FALSE;
    }


    for (i = 0; i < cbPub; i++) {
        fprintf(stream, "0x%02X", pbPub[i]);
        if (i != (cbPub - 1))
            fprintf(stream, ",");
        if ((i + 1) % 16 == 0)
            fprintf(stream, "\n");
    }
    fprintf(stream, "\n");

    fclose(stream);
    return TRUE;
}

void WriteBytesToFile(
    IN FILE *stream,
    IN const BYTE *pb,
    IN DWORD cb
    )
{
    DWORD i;

    fprintf(stream, "= {\n");
    for (i = 0; i < cb; i++) {
        if ((i % 8) == 0)
            fprintf(stream, "    ");
        fprintf(stream, "0x%02X", pb[i]);
        if (i == (cb - 1))
            fprintf(stream, "\n");
        else {
            fprintf(stream, ",");
            if ((i + 1) % 8 == 0)
                fprintf(stream, "\n");
            else
                fprintf(stream, " ");
        }
    }

    fprintf(stream, "};\n\n");

}

//+-------------------------------------------------------------------------
//  Write the Name and PublicKeyInfo to the file
//--------------------------------------------------------------------------
BOOL WritePublicKeyInfoToFile(
    LPCSTR pszFileName,
    PCERT_INFO pCertInfo
    )
{
    BOOL fResult;
    FILE *stream;
    LPWSTR pwszName = NULL;
    DWORD cchName;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    if (NULL == (stream = fopen(pszFileName, "w"))) {
        printf("Failed to open %s for writing PublicKeyInfo\n", pszFileName);
        return FALSE;
    }

    // Output the Subject X500 name string as a comment
    cchName = CertNameToStrW(
        X509_ASN_ENCODING,
        &pCertInfo->Subject,
        CERT_X500_NAME_STR,
        NULL,                   // pwsz
        0                       // cch
        );
    if (NULL == (pwszName = (LPWSTR) TestAlloc(cchName * sizeof(WCHAR))))
        goto ErrorReturn;
    cchName = CertNameToStrW(
        X509_ASN_ENCODING,
        &pCertInfo->Subject,
        CERT_NAME_STR_REVERSE_FLAG |
            CERT_X500_NAME_STR,
        pwszName,
        cchName
        );

    fprintf(stream, "// Name:: <%S>\n", pwszName);
    // Write the encoded Subject Name bytes
    WriteBytesToFile(stream, pCertInfo->Subject.pbData,
        pCertInfo->Subject.cbData);

    fprintf(stream, "// PublicKeyInfo\n");

    // Encode and write the PublicKeyInfo bytes

    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            X509_PUBLIC_KEY_INFO,
            &pCertInfo->SubjectPublicKeyInfo,
            NULL,                       // pbEncoded
            &cbEncoded
            )) {
        PrintLastError("CryptEncodeObject(X509_PUBLIC_KEY_INFO)");
        goto ErrorReturn;
    }
    pbEncoded = (BYTE *) TestAlloc(cbEncoded);
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            X509_PUBLIC_KEY_INFO,
            &pCertInfo->SubjectPublicKeyInfo,
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError("CryptEncodeObject(X509_PUBLIC_KEY_INFO)");
        goto ErrorReturn;
    }

    WriteBytesToFile(stream, pbEncoded, cbEncoded);

    fprintf(stream, "\n");

    fResult = TRUE;
CommonReturn:
    fclose(stream);

    TestFree(pwszName);
    TestFree(pbEncoded);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL DecodeCert(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult;
    PCERT_INFO pInfo = NULL;
    DWORD cbInfo;
    LPSTR pszObjId;
    
    if (NULL == (pInfo = (PCERT_INFO) TestDecodeObject(
            X509_CERT_TO_BE_SIGNED,
            pbEncoded,
            cbEncoded,
            &cbInfo
            ))) goto ErrorReturn;

    printf("Version:: %d\n", pInfo->dwVersion);
    {
        DWORD cb;
        BYTE *pb;
        printf("SerialNumber::");
        for (cb = pInfo->SerialNumber.cbData,
             pb = pInfo->SerialNumber.pbData + (cb - 1);
                                                cb > 0; cb--, pb--) {
            printf(" %02X", *pb);
        }
        printf("\n");
    }

    pszObjId = pInfo->SignatureAlgorithm.pszObjId;
    if (pszObjId == NULL)
        pszObjId = "<NULL OBJID>";
    printf("SignatureAlgorithm:: %s\n", pszObjId);
    if (pInfo->SignatureAlgorithm.Parameters.cbData) {
        printf("SignatureAlgorithm.Parameters::\n");
        PrintBytes("    ", pInfo->SignatureAlgorithm.Parameters.pbData,
            pInfo->SignatureAlgorithm.Parameters.cbData);
    }

    printf("Issuer::\n");
    DecodeName(pInfo->Issuer.pbData, pInfo->Issuer.cbData);

    printf("NotBefore:: %s\n", FileTimeText(&pInfo->NotBefore));
    printf("NotAfter:: %s\n", FileTimeText(&pInfo->NotAfter));

    printf("Subject::\n");
    DecodeName(pInfo->Subject.pbData, pInfo->Subject.cbData);

    pszObjId = pInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;
    if (pszObjId == NULL)
        pszObjId = "<NULL OBJID>";
    printf("SubjectPublicKeyInfo.Algorithm:: %s\n", pszObjId);
    if (pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData) {
        printf("SubjectPublicKeyInfo.Algorithm.Parameters::\n");
        PrintBytes("    ",
            pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
            pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData);
    }
    printf("SubjectPublicKeyInfo.PublicKey");
    if (pInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits)
        printf(" (UnusedBits: %d)",
            pInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits);
    printf("::\n");
    if (pInfo->SubjectPublicKeyInfo.PublicKey.cbData) {
        PrintBytes("    ", pInfo->SubjectPublicKeyInfo.PublicKey.pbData,
            pInfo->SubjectPublicKeyInfo.PublicKey.cbData);
    } else
        printf("  No public key\n");

    if (pszPublicKeyFilename) {
        if (fWritePublicKeyInfo)
            WritePublicKeyInfoToFile(pszPublicKeyFilename, pInfo);
        else
            WritePublicKeyToFile(pszPublicKeyFilename,
                pInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                pInfo->SubjectPublicKeyInfo.PublicKey.cbData
                );
    }
            

    if (pszReadFilename == NULL) {
        // Verify that the public key was properly encoded/decoded
        CERT_PUBLIC_KEY_INFO PublicKeyInfo;

        memset(&PublicKeyInfo, 0, sizeof(PublicKeyInfo));
        PublicKeyInfo.Algorithm.pszObjId = "1.3.4.5.911";
        PublicKeyInfo.PublicKey.pbData = (BYTE *) &SubjectPublicKey;
        PublicKeyInfo.PublicKey.cbData = sizeof(SubjectPublicKey);
        if (!CertComparePublicKeyInfo(
                dwCertEncodingType,
                &PublicKeyInfo,
                &pInfo->SubjectPublicKeyInfo))
            PrintLastError("CertComparePublicKeyInfo");
    }

    if (pInfo->IssuerUniqueId.cbData) {
        printf("IssuerUniqueId");
        if (pInfo->IssuerUniqueId.cUnusedBits)
            printf(" (UnusedBits: %d)", pInfo->IssuerUniqueId.cUnusedBits);
        printf("::\n");
        PrintBytes("    ", pInfo->IssuerUniqueId.pbData,
            pInfo->IssuerUniqueId.cbData);
    }

    if (pInfo->SubjectUniqueId.cbData) {
        printf("SubjectUniqueId");
        if (pInfo->SubjectUniqueId.cUnusedBits)
            printf(" (UnusedBits: %d)", pInfo->SubjectUniqueId.cUnusedBits);
        printf("::\n");
        PrintBytes("    ", pInfo->SubjectUniqueId.pbData,
            pInfo->SubjectUniqueId.cbData);
    }

    if (pInfo->cExtension == 0)
        printf("Extensions:: NONE\n");
    else {
        printf("Extensions::\n");
        PrintExtensions(pInfo->cExtension, pInfo->rgExtension);
    }

    DecodeSignedContent(pbEncoded, cbEncoded, X509_CERT_TO_BE_SIGNED,
        cbInfo);

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}


static BOOL DecodeCertReq(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult;
    PCERT_REQUEST_INFO pInfo = NULL;
    DWORD cbInfo;
    LPSTR pszObjId;
    
    if (NULL == (pInfo = (PCERT_REQUEST_INFO) TestDecodeObject(
            X509_CERT_REQUEST_TO_BE_SIGNED,
            pbEncoded,
            cbEncoded,
            &cbInfo
            ))) goto ErrorReturn;

    printf("Version:: %d\n", pInfo->dwVersion);
    printf("Subject::\n");
    DecodeName(pInfo->Subject.pbData, pInfo->Subject.cbData);

    pszObjId = pInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;
    if (pszObjId == NULL)
        pszObjId = "<NULL OBJID>";
    printf("SubjectPublicKeyInfo.Algorithm:: %s\n", pszObjId);
    if (pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData) {
        printf("SubjectPublicKeyInfo.Algorithm.Parameters::\n");
        PrintBytes("    ",
            pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
            pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData);
    }
    printf("SubjectPublicKeyInfo.PublicKey");
    if (pInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits)
        printf(" (UnusedBits: %d)",
            pInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits);
    printf("::\n");
    if (pInfo->SubjectPublicKeyInfo.PublicKey.cbData) {
        PrintBytes("    ", pInfo->SubjectPublicKeyInfo.PublicKey.pbData,
            pInfo->SubjectPublicKeyInfo.PublicKey.cbData);
    } else
        printf("  No public key\n");


    if (pInfo->cAttribute == 0)
        printf("Attributes:: NONE\n");
    else {
        printf("Attributes::\n");
        PrintAttributes(pInfo->cAttribute, pInfo->rgAttribute);
    }

    DecodeSignedContent(pbEncoded, cbEncoded, X509_CERT_REQUEST_TO_BE_SIGNED,
        cbInfo);

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static BOOL DecodeKeygenReq(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult;
    PCERT_KEYGEN_REQUEST_INFO pInfo = NULL;
    DWORD cbInfo;
    LPSTR pszObjId;
    
    if (NULL == (pInfo = (PCERT_KEYGEN_REQUEST_INFO) TestDecodeObject(
            X509_KEYGEN_REQUEST_TO_BE_SIGNED,
            pbEncoded,
            cbEncoded,
            &cbInfo
            ))) goto ErrorReturn;

    printf("Version:: %d\n", pInfo->dwVersion);

    pszObjId = pInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;
    if (pszObjId == NULL)
        pszObjId = "<NULL OBJID>";
    printf("SubjectPublicKeyInfo.Algorithm:: %s\n", pszObjId);
    if (pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData) {
        printf("SubjectPublicKeyInfo.Algorithm.Parameters::\n");
        PrintBytes("    ",
            pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
            pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData);
    }
    printf("SubjectPublicKeyInfo.PublicKey");
    if (pInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits)
        printf(" (UnusedBits: %d)",
            pInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits);
    printf("::\n");
    if (pInfo->SubjectPublicKeyInfo.PublicKey.cbData) {
        PrintBytes("    ", pInfo->SubjectPublicKeyInfo.PublicKey.pbData,
            pInfo->SubjectPublicKeyInfo.PublicKey.cbData);
    } else
        printf("  No public key\n");

    printf("ChallengeString:: %S\n", pInfo->pwszChallengeString);

    DecodeSignedContent(pbEncoded, cbEncoded, X509_KEYGEN_REQUEST_TO_BE_SIGNED,
        cbInfo);

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static BOOL DecodeContentInfo(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult;
    PCRYPT_CONTENT_INFO pInfo = NULL;
    LPSTR pszObjId;
    
    if (NULL == (pInfo = (PCRYPT_CONTENT_INFO) TestDecodeObject(
            PKCS_CONTENT_INFO,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    pszObjId = pInfo->pszObjId;
    if (pszObjId == NULL)
        pszObjId = "<NULL OBJID>";
    printf("ContentType:: %s\n", pszObjId);
    if (pInfo->Content.cbData) {
        printf("Content::\n");
        PrintBytes("    ", pInfo->Content.pbData, pInfo->Content.cbData);
    } else
        printf("NO Content\n");

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static void TestCompareIntegerBlob()
{
    BYTE bZero = 0;
    BYTE bFF = 0xFF;
    
    BYTE rgbLeadZero1[] = {0x12, 0x34, 0x56, 0x87, 0, 0};
    BYTE rgbLeadZero2[] = {0x12, 0x34, 0x56, 0x87, 0, 0, 0, 0};

    BYTE rgbLeadFF1[] = {0x12, 0x34, 0x56, 0x87, 0xFF, 0xFF};
    BYTE rgbLeadFF2[] = {0x12, 0x34, 0x56, 0x87};

    CRYPT_INTEGER_BLOB Int1;
    CRYPT_INTEGER_BLOB Int2;

    Int1.pbData = &bZero;
    Int1.cbData = sizeof(bZero);
    Int2 = Int1;
    if (!CertCompareIntegerBlob(&Int1, &Int2))
        printf("Failed => Compare of Zero == Zero\n");

    Int1.pbData = &bFF;
    Int1.cbData = sizeof(bFF);
    Int2 = Int1;
    if (!CertCompareIntegerBlob(&Int1, &Int2))
        printf("Failed => Compare of FF == FF\n");

    Int1.pbData = &bZero;
    Int1.cbData = sizeof(bZero);
    if (CertCompareIntegerBlob(&Int1, &Int2))
        printf("Failed => Compare of Zero != FF\n");

    Int1.pbData = rgbLeadZero1;
    Int1.cbData = sizeof(rgbLeadZero1);
    Int2.pbData = rgbLeadZero2;
    Int2.cbData = sizeof(rgbLeadZero2);
    if (!CertCompareIntegerBlob(&Int1, &Int2))
        printf("Failed => Compare of Leading Zeroes\n");

    Int1.pbData = rgbLeadFF1;
    Int1.cbData = sizeof(rgbLeadFF1);
    Int2.pbData = rgbLeadFF2;
    Int2.cbData = sizeof(rgbLeadFF2);
    if (!CertCompareIntegerBlob(&Int1, &Int2))
        printf("Failed => Compare of Leading FFs\n");

    Int1.pbData = rgbLeadZero1;
    Int1.cbData = sizeof(rgbLeadZero1);
    if (CertCompareIntegerBlob(&Int1, &Int2))
        printf("Failed => Compare of Leading Zeroes != Leading FFs\n");
}

static BOOL EncodeCrl(BYTE **ppbEncoded, DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;
    BYTE *pbCrlEncoded = NULL;
    DWORD cbCrlEncoded;

    DWORD SerialNumber0[2] = {0x12345678, 0x33445566};
    DWORD SerialNumber1[1] = {0x12345678};
    SYSTEMTIME SystemTime;


#define CRL_ATTR_0_0 "attr 0_0 printable"
#define CRL_ATTR_0_1 "attr 0_1 IA5"
#define CRL_ATTR_1_0 "attr 1_0 numeric"
#define CRL_ATTR_1_1 "attr 1_1 octet"

    CERT_RDN_ATTR rgAttr0[] = {
        "1.2.3.4.5.0.0.0", CERT_RDN_PRINTABLE_STRING,
            strlen(CRL_ATTR_0_0), (BYTE *) CRL_ATTR_0_0,
        "1.2.3.4.5.0.1.1.1", CERT_RDN_IA5_STRING,
            strlen(CRL_ATTR_0_1), (BYTE *) CRL_ATTR_0_1
    };
    CERT_RDN_ATTR rgAttr1[] = {
        "1.2.3.4.5.1.0", CERT_RDN_NUMERIC_STRING,
            strlen(CRL_ATTR_1_0), (BYTE *) CRL_ATTR_1_0,
        "1.2.3.4.5.1.1", CERT_RDN_OCTET_STRING,
            strlen(CRL_ATTR_1_1), (BYTE *) CRL_ATTR_1_1,
        "1.2.3.4.5.2", CERT_RDN_PRINTABLE_STRING,
            0, NULL
    };
    CERT_RDN rgRDN[] = {
        2, rgAttr0,
        3, rgAttr1,
    };
    CERT_NAME_INFO Name = {2, rgRDN};

#define CRL_EXT_0 "extension 0 ."
#define CRL_EXT_1 "extension 1 .."
#define CRL_EXT_2 "extension 2 ..."
#define CRL_EXT_3 "extension 3 ...."
    CERT_EXTENSION rgExt[] = {
        "1.14.89990", FALSE, strlen(CRL_EXT_0), (BYTE *) CRL_EXT_0,
        "1.14.89991", TRUE, strlen(CRL_EXT_1), (BYTE *) CRL_EXT_1,
        "1.14.89992", FALSE, strlen(CRL_EXT_2), (BYTE *) CRL_EXT_2,
        "1.14.89993", FALSE, strlen(CRL_EXT_3), (BYTE *) CRL_EXT_3
    };
    CRL_INFO Crl;
    BYTE *pbExt = NULL;

    if (dwExtLen) {
        DWORD i;
        if (NULL == (pbExt = (BYTE *) TestAlloc(dwExtLen)))
            goto ErrorReturn;

        for (i = 0; i < dwExtLen; i++)
            pbExt[i] = (BYTE) i;

        rgExt[3].Value.cbData = dwExtLen;
        rgExt[3].Value.pbData = pbExt;
    }

    CRL_ENTRY rgCrlEntry[2];

    TestCompareIntegerBlob();

    cbNameEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            NULL,               // pbEncoded
            &cbNameEncoded
            );
    if (cbNameEncoded == 0) {
        PrintLastError("EncodeCrl::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbNameEncoded = (BYTE *) TestAlloc(cbNameEncoded);
    if (pbNameEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            pbNameEncoded,
            &cbNameEncoded
            )) {
        PrintLastError("EncodeCrl::CryptEncodeObject");
        goto ErrorReturn;
    }

    GetSystemTime(&SystemTime);

    memset(rgCrlEntry, 0, sizeof(rgCrlEntry));
    rgCrlEntry[0].SerialNumber.pbData = (BYTE *) &SerialNumber0[0];
    rgCrlEntry[0].SerialNumber.cbData = sizeof(SerialNumber0);
    SystemTime.wYear--;
    SystemTimeToFileTime(&SystemTime, &rgCrlEntry[0].RevocationDate);
    rgCrlEntry[0].cExtension = 0;
    rgCrlEntry[0].rgExtension = NULL;

    rgCrlEntry[1].SerialNumber.pbData = (BYTE *) &SerialNumber1[0];
    rgCrlEntry[1].SerialNumber.cbData = sizeof(SerialNumber1);
    SystemTime.wYear--;
    SystemTimeToFileTime(&SystemTime, &rgCrlEntry[1].RevocationDate);
    rgCrlEntry[1].cExtension = 2;
    rgCrlEntry[1].rgExtension = &rgExt[1];

    memset(&Crl, 0, sizeof(Crl));
    Crl.dwVersion = CRL_V2;
    Crl.SignatureAlgorithm.pszObjId = "1.2.4.5.898";
    Crl.Issuer.pbData = pbNameEncoded;
    Crl.Issuer.cbData = cbNameEncoded;
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &Crl.ThisUpdate);
    SystemTime.wYear++;
    SystemTimeToFileTime(&SystemTime, &Crl.NextUpdate);
    Crl.cCRLEntry = sizeof(rgCrlEntry) / sizeof(rgCrlEntry[0]);
    Crl.rgCRLEntry = rgCrlEntry;
    Crl.cExtension = sizeof(rgExt) / sizeof(rgExt[0]);
    Crl.rgExtension = rgExt;

    cbCrlEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT_CRL_TO_BE_SIGNED,
            &Crl,
            NULL,               // pbEncoded
            &cbCrlEncoded
            );
    if (cbCrlEncoded == 0) {
        PrintLastError("EncodeCrl::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbCrlEncoded = (BYTE *) TestAlloc(cbCrlEncoded);
    if (pbCrlEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT_CRL_TO_BE_SIGNED,
            &Crl,
            pbCrlEncoded,
            &cbCrlEncoded
            )) {
        PrintLastError("EncodeCrl::CryptEncodeObject");
        goto ErrorReturn;
    }

    if (!EncodeSignedContent(
            pbCrlEncoded,
            cbCrlEncoded,
            ppbEncoded,
            pcbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbNameEncoded)
        TestFree(pbNameEncoded);
    if (pbExt)
        TestFree(pbExt);
    if (pbCrlEncoded)
        TestFree(pbCrlEncoded);

    return fResult;
}

static void PrintCrlEntries(DWORD cEntry, PCRL_ENTRY pEntry)
{
    DWORD i; 

    for (i = 0; i < cEntry; i++, pEntry++) {
        {
            DWORD cb;
            BYTE *pb;
            printf(" [%d] SerialNumber::", i);
            for (cb = pEntry->SerialNumber.cbData,
                 pb = pEntry->SerialNumber.pbData + (cb - 1);
                                                    cb > 0; cb--, pb--) {
                printf(" %02X", *pb);
            }
            printf("\n");
        }

        printf(" [%d] RevocationDate:: %s\n", i,
            FileTimeText(&pEntry->RevocationDate));

        if (pEntry->cExtension == 0)
            printf(" [%d] Extensions:: NONE\n", i);
        else {
            printf(" [%d] Extensions::\n", i);
            PrintExtensions(pEntry->cExtension, pEntry->rgExtension);
        }
    }
}

static BOOL DecodeCrl(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult;
    PCRL_INFO pInfo = NULL;
    DWORD cbInfo;
    LPSTR pszObjId;
    
    if (NULL == (pInfo = (PCRL_INFO) TestDecodeObject(
            X509_CERT_CRL_TO_BE_SIGNED,
            pbEncoded,
            cbEncoded,
            &cbInfo
            ))) goto ErrorReturn;

    printf("Version:: %d\n", pInfo->dwVersion);

    pszObjId = pInfo->SignatureAlgorithm.pszObjId;
    if (pszObjId == NULL)
        pszObjId = "<NULL OBJID>";
    printf("SignatureAlgorithm:: %s\n", pszObjId);
    if (pInfo->SignatureAlgorithm.Parameters.cbData) {
        printf("SignatureAlgorithm.Parameters::\n");
        PrintBytes("    ", pInfo->SignatureAlgorithm.Parameters.pbData,
            pInfo->SignatureAlgorithm.Parameters.cbData);
    }

    printf("Issuer::\n");
    DecodeName(pInfo->Issuer.pbData, pInfo->Issuer.cbData);

    printf("ThisUpdate:: %s\n", FileTimeText(&pInfo->ThisUpdate));
    printf("NextUpdate:: %s\n", FileTimeText(&pInfo->NextUpdate));

    if (pInfo->cExtension == 0)
        printf("Extensions:: NONE\n");
    else {
        printf("Extensions::\n");
        PrintExtensions(pInfo->cExtension, pInfo->rgExtension);
    }

    if (pInfo->cCRLEntry == 0)
        printf("Entries:: NONE\n");
    else {
        printf("Entries::\n");
        PrintCrlEntries(pInfo->cCRLEntry, pInfo->rgCRLEntry);
    }

    DecodeSignedContent(pbEncoded, cbEncoded, X509_CERT_CRL_TO_BE_SIGNED,
        cbInfo);

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static BOOL EncodeCertPair(BYTE **ppbEncoded, DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    CERT_PAIR CertPair;

    memset(&CertPair, 0, sizeof(CertPair));
    if (pszForwardCertFilename)
        ReadDERFromFile(pszForwardCertFilename,
            &CertPair.Forward.pbData, &CertPair.Forward.cbData);
    if (pszReverseCertFilename)
        ReadDERFromFile(pszReverseCertFilename,
            &CertPair.Reverse.pbData, &CertPair.Reverse.cbData);

    cbEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT_PAIR,
            &CertPair,
            NULL,               // pbEncoded
            &cbEncoded
            );
    if (cbEncoded == 0) {
        PrintLastError("EncodeCertPair::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbEncoded = (BYTE *) TestAlloc(cbEncoded);
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT_PAIR,
            &CertPair,
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError("EncodeCertPair::CryptEncodeObject");
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;

CommonReturn:
    TestFree(CertPair.Forward.pbData);
    TestFree(CertPair.Reverse.pbData);
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;

    return fResult;
}

static BOOL DecodeCertPair(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult;
    PCERT_PAIR pInfo = NULL;
    
    if (NULL == (pInfo = (PCERT_PAIR) TestDecodeObject(
            X509_CERT_PAIR,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    if (pInfo->Forward.cbData) {
        printf("Forward Certificate::\n");
        PrintBytes("    ", pInfo->Forward.pbData, pInfo->Forward.cbData);
    } else
        printf("NO Forward Certificate\n");

    if (pInfo->Reverse.cbData) {
        printf("Reverse Certificate::\n");
        PrintBytes("    ", pInfo->Reverse.pbData, pInfo->Reverse.cbData);
    } else
        printf("NO Reverse Certificate\n");

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    TestFree(pInfo);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tcertpro\tcertpro.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tcertpro.cpp
//
//  Contents:   Cert Protection Tests
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    30-Nov-97   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"
#include "unicode.h"
#include "certprot.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static void PrintLastError(LPCSTR pszMsg, LONG lErr)
{
    printf("  %s failed => 0x%x (%d) \n", pszMsg, lErr, lErr);
}

static void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("  %s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

static
BOOL
SetPrivilege(
    HANDLE hToken,          // token handle
    LPCSTR Privilege,       // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);

    if(!LookupPrivilegeValueA( NULL, Privilege, &luid )) return FALSE;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    //
    // second pass.  set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;

    if(bEnablePrivilege) {
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    }
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    return TRUE;
}

static
BOOL
SetCurrentPrivilege(
    LPCSTR Privilege,       // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    BOOL bSuccess=FALSE; // assume failure
    HANDLE hToken;

    if(OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            ))
    {

        if(SetPrivilege(hToken, Privilege, bEnablePrivilege)) bSuccess=TRUE;

        CloseHandle(hToken);
    }

    return bSuccess;
}


static void Usage(void)
{
    printf("Usage: tcertpro [options] <TestName> <RegPath>\n");
    printf("Options are:\n");
    printf("  -h                - This message\n");
//    printf("  -r                - Recurse subkeys\n");
    printf("  -lCU              - CurrentUser (default)\n");
    printf("  -lLM              - LocalMachine\n");
    printf("TestNames (case insensitive):\n");
    printf("  GetKey            - Get Registry Key Security Information\n");
    printf("  SetKey            - Set Registry Key Security Information\n");
    printf("  PurgeLMRoots      - Purge LocalMachine Roots From CurrentUser\n");
    printf("  DeleteUnknownRoots- Delete Unknown Roots From Protected List\n");
    printf("  ServiceUI         - Cert protect service UI\n");
    printf("  ServiceTokenInfo  - Get Cert protect service token info\n");
    printf("  ServiceInvalid    - Invalid Cert protect function\n");
    printf("\n");
}

#if 0
#define OWNER_SECURITY_INFORMATION       (0X00000001L)
#define GROUP_SECURITY_INFORMATION       (0X00000002L)
#define DACL_SECURITY_INFORMATION        (0X00000004L)
#define SACL_SECURITY_INFORMATION        (0X00000008L)
#endif


static PSECURITY_DESCRIPTOR AllocAndGetSecurityDescriptor(
    IN HKEY hKey,
    SECURITY_INFORMATION SecInf
    )
{
    LONG err;
    PSECURITY_DESCRIPTOR psd = NULL;
    DWORD cbsd = 0;

    err = RegGetKeySecurity(
            hKey,
            SecInf,
            NULL,                   // psd
            &cbsd
            );
    if (!(ERROR_SUCCESS == err || ERROR_INSUFFICIENT_BUFFER == err)) {
        PrintLastError("RegGetKeySecurity", err);
        return NULL;
    }
    if (0 == cbsd)
        return NULL;

    if (NULL == (psd = (PSECURITY_DESCRIPTOR) TestAlloc(cbsd)))
        return NULL;

    if (ERROR_SUCCESS != (err = RegGetKeySecurity(
            hKey,
            SecInf,
            psd,
            &cbsd
            ))) {
        PrintLastError("RegGetKeySecurity", err);
        TestFree(psd);
    }
    return psd;
}

#if 0
#define SE_OWNER_DEFAULTED               (0x0001)
#define SE_GROUP_DEFAULTED               (0x0002)
#define SE_DACL_PRESENT                  (0x0004)
#define SE_DACL_DEFAULTED                (0x0008)
#define SE_SACL_PRESENT                  (0x0010)
#define SE_SACL_DEFAULTED                (0x0020)
#define SE_DACL_AUTO_INHERIT_REQ         (0x0100)
#define SE_SACL_AUTO_INHERIT_REQ         (0x0200)
#define SE_DACL_AUTO_INHERITED           (0x0400)
#define SE_SACL_AUTO_INHERITED           (0x0800)
#define SE_DACL_PROTECTED                (0x1000)
#define SE_SACL_PROTECTED                (0x2000)
#define SE_SELF_RELATIVE                 (0x8000)
#endif

//
//  Where:
//
//      SE_OWNER_DEFAULTED - This boolean flag, when set, indicates that the
//          SID pointed to by the Owner field was provided by a
//          defaulting mechanism rather than explicitly provided by the
//          original provider of the security descriptor.  This may
//          affect the treatment of the SID with respect to inheritence
//          of an owner.
//
//      SE_GROUP_DEFAULTED - This boolean flag, when set, indicates that the
//          SID in the Group field was provided by a defaulting mechanism
//          rather than explicitly provided by the original provider of
//          the security descriptor.  This may affect the treatment of
//          the SID with respect to inheritence of a primary group.
//
//      SE_DACL_PRESENT - This boolean flag, when set, indicates that the
//          security descriptor contains a discretionary ACL.  If this
//          flag is set and the Dacl field of the SECURITY_DESCRIPTOR is
//          null, then a null ACL is explicitly being specified.
//
//      SE_DACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Dacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the DaclPresent flag is not set.
//
//      SE_SACL_PRESENT - This boolean flag, when set,  indicates that the
//          security descriptor contains a system ACL pointed to by the
//          Sacl field.  If this flag is set and the Sacl field of the
//          SECURITY_DESCRIPTOR is null, then an empty (but present)
//          ACL is being specified.
//
//      SE_SACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Sacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the SaclPresent flag is not set.
//
//      SE_SELF_RELATIVE - This boolean flag, when set, indicates that the
//          security descriptor is in self-relative form.  In this form,
//          all fields of the security descriptor are contiguous in memory
//          and all pointer fields are expressed as offsets from the
//          beginning of the security descriptor.  This form is useful
//          for treating security descriptors as opaque data structures
//          for transmission in communication protocol or for storage on
//          secondary media.
//

#if 0
typedef enum _SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown
} SID_NAME_USE, *PSID_NAME_USE;
#endif

static void DisplayControl(
    PSECURITY_DESCRIPTOR psd
    )
{
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD dwRevision;

    if (!GetSecurityDescriptorControl(psd, &sdc, &dwRevision))
        PrintLastError("GetSecurityDescriptorControl");
    else {
        printf("  Control: 0x%x", sdc);
        if (sdc & SE_OWNER_DEFAULTED)
            printf(" OWNER_DEFAULTED");
        if (sdc & SE_GROUP_DEFAULTED)
            printf(" GROUP_DEFAULTED");
        if (sdc & SE_DACL_PRESENT)
            printf(" DACL_PRESENT");
        if (sdc & SE_DACL_DEFAULTED)
            printf(" DACL_DEFAULTED");
        if (sdc & SE_SACL_PRESENT)
            printf(" SACL_PRESENT");
        if (sdc & SE_SACL_DEFAULTED)
            printf(" SACL_DEFAULTED");
        if (sdc & SE_DACL_AUTO_INHERIT_REQ)
            printf(" DACL_AUTO_INHERIT_REQ");
        if (sdc & SE_SACL_AUTO_INHERIT_REQ)
            printf(" SACL_AUTO_INHERIT_REQ");
        if (sdc & SE_DACL_AUTO_INHERITED)
            printf(" DACL_AUTO_INHERITED");
        if (sdc & SE_SACL_AUTO_INHERITED)
            printf(" SACL_AUTO_INHERITED");
        if (sdc & SE_DACL_PROTECTED)
            printf(" DACL_PROTECTED");
        if (sdc & SE_SACL_PROTECTED)
            printf(" SACL_PROTECTED");
        if (sdc & SE_SELF_RELATIVE)
            printf(" SELF_RELATIVE");
        printf("\n");
        printf("  Revision: %d\n", dwRevision);
    }
}

static void DisplaySid(
    PSID pSid
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;

    char szAccount[_MAX_PATH];
    DWORD cchAccount;
    char szDomain[_MAX_PATH];
    DWORD cchDomain;
    SID_NAME_USE snu;

    if (!IsValidSid(pSid)) {
        printf("Invalid SID\n");
        return;
    }

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // prepare S-SID_REVISION-
    //
    printf("S-%lu-", SID_REVISION);

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) ) {
        printf("0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    } else {
        printf("%lu",
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for (dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++) {
        printf("-%lu", *GetSidSubAuthority(pSid, dwCounter) );
    }


    cchAccount = sizeof(szAccount) - 1;
    memset(szAccount, 0, sizeof(szAccount));
    cchDomain = sizeof(szDomain) - 1;
    memset(szDomain, 0, sizeof(szDomain));
    snu = (SID_NAME_USE) 0;
    if (LookupAccountSidA(
            NULL,               // lpSystemName
            pSid,
            szAccount,
            &cchAccount,
            szDomain,
            &cchDomain,
            &snu
            ))
        printf("  Account: %s Domain: %s SNU: %d", szAccount, szDomain, snu);
    printf("\n");

}

static void DisplayOwnerSecurityInfo(
    IN PSECURITY_DESCRIPTOR psd
    )
{
    PSID pSid = NULL;
    BOOL fOwnerDefaulted;

    if (!GetSecurityDescriptorOwner(psd, &pSid, &fOwnerDefaulted)) {
        PrintLastError("GetSecurityDescriptorOwner");
        return;
    }

    if (NULL == pSid)
        printf("  NO OWNER\n");
    else {
        printf("  Owner: ");
        DisplaySid(pSid);
        if (fOwnerDefaulted)
            printf("  Owner Defaulted\n");
    }
}

static void DisplayGroupSecurityInfo(
    IN PSECURITY_DESCRIPTOR psd
    )
{
    PSID pSid = NULL;
    BOOL fGroupDefaulted;

    if (!GetSecurityDescriptorGroup(psd, &pSid, &fGroupDefaulted)) {
        PrintLastError("GetSecurityDescriptorGroup");
        return;
    }

    if (NULL == pSid)
        printf("  NO Group\n");
    else {
        printf("  Group: ");
        DisplaySid(pSid);
        if (fGroupDefaulted)
            printf("  Group Defaulted\n");
    }

}

            

static LPCSTR GetAceTypeString(
    IN BYTE AceType
    )
{
    switch (AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:
            return "ACCESS_ALLOWED";
            break;
        case ACCESS_DENIED_ACE_TYPE:
            return "ACCESS_DENIED_ACE_TYPE";
            break;
        case SYSTEM_AUDIT_ACE_TYPE:
            return "SYSTEM_AUDIT_ACE_TYPE";
            break;
        case SYSTEM_ALARM_ACE_TYPE:
            return "SYSTEM_ALARM_ACE_TYPE";
            break;
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
            return "ACCESS_ALLOWED_COMPOUND_ACE_TYPE";
            break;
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            return "ACCESS_ALLOWED_OBJECT_ACE_TYPE";
            break;
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
            return "ACCESS_DENIED_OBJECT_ACE_TYPE";
            break;
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
            return "SYSTEM_AUDIT_OBJECT_ACE_TYPE";
            break;
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:
            return "SYSTEM_ALARM_OBJECT_ACE_TYPE";
            break;
        default:
            return "???";
    }
    
}

static void DisplayAceFlags(
    IN BYTE AceFlags
    )
{
    if (AceFlags & OBJECT_INHERIT_ACE)
        printf(" OBJECT_INHERIT");
    if (AceFlags & CONTAINER_INHERIT_ACE)
        printf(" CONTAINER_INHERIT");
    if (AceFlags & NO_PROPAGATE_INHERIT_ACE)
        printf(" NO_PROPAGATE_INHERIT");
    if (AceFlags & INHERIT_ONLY_ACE)
        printf(" INHERIT_ONLY");
    if (AceFlags & INHERITED_ACE)
        printf(" INHERITED");
    if (AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG)
        printf(" SUCCESSFUL_ACCESS");
    if (AceFlags & FAILED_ACCESS_ACE_FLAG)
        printf(" FAILED_ACCESS");
}

static void DisplayAccessMask(
    IN ACCESS_MASK Mask
    )
{
    if (Mask & SYNCHRONIZE)
        printf(" SYNCHRONIZE");
    if (Mask & ACCESS_SYSTEM_SECURITY)
        printf(" ACCESS_SYSTEM_SECURITY");
    if (Mask & MAXIMUM_ALLOWED)
        printf(" MAXIMUM_ALLOWED");
    if (Mask & GENERIC_READ)
        printf(" GENERIC_READ");
    if (Mask & GENERIC_WRITE)
        printf(" GENERIC_WRITE");
    if (Mask & GENERIC_EXECUTE)
        printf(" GENERIC_EXECUTE");
    if (Mask & GENERIC_ALL)
        printf(" GENERIC_ALL");

    if (KEY_ALL_ACCESS == (Mask & KEY_ALL_ACCESS)) {
        printf(" KEY_ALL_ACCESS");
        return;
    }

    if (KEY_READ == (Mask & KEY_READ))
        printf(" KEY_READ");
    if (KEY_WRITE == (Mask & KEY_WRITE))
        printf(" KEY_WRITE");
    if (KEY_EXECUTE == (Mask & KEY_EXECUTE))
        printf(" KEY_EXECUTE");

    if (Mask & DELETE)
        printf(" DELETE");
    if (Mask & READ_CONTROL)
        printf(" READ_CONTROL");
    if (Mask & WRITE_DAC)
        printf(" WRITE_DAC");
    if (Mask & WRITE_OWNER)
        printf(" WRITE_OWNER");


    if (Mask & KEY_QUERY_VALUE)
        printf(" KEY_QUERY_VALUE");
    if (Mask & KEY_SET_VALUE)
        printf(" KEY_SET_VALUE");
    if (Mask & KEY_CREATE_SUB_KEY)
        printf(" KEY_CREATE_SUB_KEY");
    if (Mask & KEY_ENUMERATE_SUB_KEYS)
        printf(" KEY_ENUMERATE_SUB_KEYS");
    if (Mask & KEY_NOTIFY)
        printf(" KEY_NOTIFY");
    if (Mask & KEY_CREATE_LINK)
        printf(" KEY_CREATE_LINK");
}

static void DisplayAcl(
    IN BOOL fDaclPresent,
    IN PACL pAcl,
    IN BOOL fDaclDefaulted
    )
{
    DWORD dwAceIndex;

    if (!fDaclPresent) {
        printf("  NO ACL\n");
        return;
    }

    if (NULL == pAcl) {
        printf("  NULL ACL\n");
        return;
    }

    printf("  AclRevision: %d", pAcl->AclRevision);
    if (fDaclDefaulted)
        printf(" Defaulted ACL");
    printf("\n");

    for (dwAceIndex = 0; dwAceIndex < pAcl->AceCount; dwAceIndex++) {
        PACE_HEADER pAceHdr;
        PACCESS_ALLOWED_ACE pAce;
        if (!GetAce(pAcl, dwAceIndex, (void **) &pAceHdr)) {
            PrintLastError("GetAce");
            return;
        }

        printf("  Ace[%d]\n", dwAceIndex);
        printf("   Type: 0x%x %s\n", pAceHdr->AceType,
            GetAceTypeString(pAceHdr->AceType));
        printf("   Flags: 0x%x ", pAceHdr->AceFlags);
        DisplayAceFlags(pAceHdr->AceFlags);
        printf("\n");
        switch (pAceHdr->AceType) {
            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_DENIED_ACE_TYPE:
            case SYSTEM_AUDIT_ACE_TYPE:
            case SYSTEM_ALARM_ACE_TYPE:
                pAce = (PACCESS_ALLOWED_ACE) pAceHdr;
                printf("   Mask: 0x%x", pAce->Mask);
                DisplayAccessMask(pAce->Mask);
                printf("\n");
                printf("   SID: ");
                DisplaySid((PSID) &pAce->SidStart);
                break;
            default:
                break;
        }
    }
}

static void DisplayDaclSecurityInfo(
    IN PSECURITY_DESCRIPTOR psd
    )
{
    BOOL fDaclPresent;
    PACL pAcl;
    BOOL fDaclDefaulted;
    DWORD dwAceIndex;

    printf("  ---  DACLs  ---\n");
    if (!GetSecurityDescriptorDacl(psd, &fDaclPresent, &pAcl,
            &fDaclDefaulted)) {
        PrintLastError("GetSecurityDescriptorDacl");
        return;
    }
    DisplayAcl(fDaclPresent, pAcl, fDaclDefaulted);
}

static void DisplaySaclSecurityInfo(
    IN PSECURITY_DESCRIPTOR psd
    )
{
    BOOL fSaclPresent;
    PACL pAcl;
    BOOL fSaclDefaulted;
    DWORD dwAceIndex;

    printf("  ---  SACLs  ---\n");
    if (!GetSecurityDescriptorSacl(psd, &fSaclPresent, &pAcl,
            &fSaclDefaulted)) {
        PrintLastError("GetSecurityDescriptorSacl");
        return;
    }
    DisplayAcl(fSaclPresent, pAcl, fSaclDefaulted);
}

static void DisplayRegQueryInfo(
    IN HKEY hKey
    )
{
    FILETIME ftLastWriteTime;
    LONG err;

    memset(&ftLastWriteTime, 0, sizeof(ftLastWriteTime));
    if (ERROR_SUCCESS == (err = RegQueryInfoKeyA(
            hKey,
            NULL,       // lpszClass
            NULL,       // lpcchClass
            NULL,       // lpdwReserved
            NULL,       // lpcSubKeys
            NULL,       // lpcchMaxSubKey
            NULL,       // lpcchMaxClass
            NULL,       // lpcValues
            NULL,       // lpcchMaxValuesName
            NULL,       // lpcbMaxValueData
            NULL,       // lpcbSecurityDescriptor
            &ftLastWriteTime
            ))) {
        printf("LastWriteTime:: %s\n", FileTimeText(&ftLastWriteTime));
    }
}

static void DisplayRegSecurityInfo(
    IN HKEY hKey,
    IN LPCSTR pszKeyBase,
    IN LPCSTR pszRegPath,
    SECURITY_INFORMATION SecInf,
    IN BOOL fRecurse
    )
{
    PSECURITY_DESCRIPTOR psd = NULL;

    printf("%s\\%s\n", pszKeyBase, pszRegPath);

    if (NULL == (psd = AllocAndGetSecurityDescriptor(
            hKey, SecInf)))
        return;

    DisplayRegQueryInfo(hKey);

    DisplayControl(psd);

    DisplayOwnerSecurityInfo(psd);
    DisplayGroupSecurityInfo(psd);
    DisplayDaclSecurityInfo(psd);
    if (SecInf & SACL_SECURITY_INFORMATION)
        DisplaySaclSecurityInfo(psd);

    TestFree(psd);
    if (fRecurse) {
    }
}

static void * AllocAndGetTokenInfo(
    IN HANDLE hToken,
    IN TOKEN_INFORMATION_CLASS tic
    )
{
    void *pvInfo = NULL;
    DWORD cbInfo = 0;
    DWORD cbInfo2;

    if (!GetTokenInformation(
            hToken,
            tic,
            pvInfo,
            0,              // cbInfo
            &cbInfo
            )) {
        if (ERROR_INSUFFICIENT_BUFFER != GetLastError()) {
            PrintLastError("GetTokenInformation");
            return NULL;
        }
    }

    if (0 == cbInfo) {
        printf("No Information\n");
        return NULL;
    }
    if (NULL == (pvInfo = TestAlloc(cbInfo)))
        return NULL;

    cbInfo2 = cbInfo;
    if (!GetTokenInformation(
            hToken,
            tic,
            pvInfo,
            cbInfo,
            &cbInfo2
            )) {
        PrintLastError("GetTokenInformation");
        TestFree(pvInfo);
        return NULL;
    }

    return pvInfo;
}


static void GetProcessTokenInfo()
{
    HANDLE hToken = NULL;
    void *pvInfo = NULL;

    printf("Get Process Token Information\n\n");
    if (!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY,
            &hToken
            )) {
        PrintLastError("OpenProcessToken");
        goto ErrorReturn;
    }

    printf("TokenUser: ");
    if (pvInfo = AllocAndGetTokenInfo(hToken, TokenUser)) {
        PTOKEN_USER pTokenUser = (PTOKEN_USER) pvInfo;
        if (pTokenUser->User.Attributes)
            printf("Attributes(0x%x) ", pTokenUser->User.Attributes);

        DisplaySid(pTokenUser->User.Sid);
        TestFree(pvInfo);
        pvInfo = NULL;
    }

    printf("TokenOwner: ");
    if (pvInfo = AllocAndGetTokenInfo(hToken, TokenOwner)) {
        PTOKEN_OWNER pTokenOwner = (PTOKEN_OWNER) pvInfo;

        DisplaySid(pTokenOwner->Owner);
        TestFree(pvInfo);
        pvInfo = NULL;
    }

    printf("TokenPrimaryGroup: ");
    if (pvInfo = AllocAndGetTokenInfo(hToken, TokenPrimaryGroup)) {
        PTOKEN_PRIMARY_GROUP pTokenPrimaryGroup = (PTOKEN_PRIMARY_GROUP) pvInfo;

        DisplaySid(pTokenPrimaryGroup->PrimaryGroup);
        TestFree(pvInfo);
        pvInfo = NULL;
    }

    printf("TokenGroups\n");
    if (pvInfo = AllocAndGetTokenInfo(hToken, TokenGroups)) {
        PTOKEN_GROUPS pTokenGroups = (PTOKEN_GROUPS) pvInfo;
        DWORD GroupCount = pTokenGroups->GroupCount;
        if (0 == GroupCount)
            printf("  No Groups\n");
        else {
            DWORD i;
            for (i = 0; i < GroupCount; i++) {
                printf("  Group[%d]: ", i);
                if (pTokenGroups->Groups[i].Attributes)
                    printf("Attributes(0x%x) ",
                        pTokenGroups->Groups[i].Attributes);

                DisplaySid(pTokenGroups->Groups[i].Sid);
            }
        }
        TestFree(pvInfo);
        pvInfo = NULL;
    }

    printf("TokenPrivileges\n");
    if (pvInfo = AllocAndGetTokenInfo(hToken, TokenPrivileges)) {
        PTOKEN_PRIVILEGES pTokenPrivileges = (PTOKEN_PRIVILEGES) pvInfo;
        DWORD PrivilegeCount = pTokenPrivileges->PrivilegeCount;
        if (0 == PrivilegeCount)
            printf("  No Privileges\n");
        else {
            DWORD i;
            for (i = 0; i < PrivilegeCount; i++) {
                char szName[_MAX_PATH];
                DWORD cchName;
                printf("  Privilege[%d]: ", i);
                if (pTokenPrivileges->Privileges[i].Attributes)
                    printf("Attributes(0x%x) ",
                        pTokenPrivileges->Privileges[i].Attributes);

                cchName = sizeof(szName);
                if (LookupPrivilegeName(
                        NULL,                           // pszSystemName
                        &pTokenPrivileges->Privileges[i].Luid,
                        szName,
                        &cchName
                        ))
                    printf("%s\n", szName);
                else
                    PrintLastError("LookupPrivlegeName");
            }
        }
        TestFree(pvInfo);
        pvInfo = NULL;
    }

    printf("TokenDefaultDacl\n");
    if (pvInfo = AllocAndGetTokenInfo(hToken, TokenDefaultDacl)) {
        PTOKEN_DEFAULT_DACL pTokenDacl = (PTOKEN_DEFAULT_DACL) pvInfo;

        DisplayAcl(TRUE, pTokenDacl->DefaultDacl, FALSE);
        TestFree(pvInfo);
        pvInfo = NULL;
    }

ErrorReturn:
    if (hToken)
        CloseHandle(hToken);
    TestFree(pvInfo);
}


static void SetOwner(
    IN HKEY hKeyBase,
    IN LPCSTR pszRegPath
    )
{
    LONG err;
    HKEY hKey = NULL;
    HANDLE hToken = NULL;
    void *pvInfo = NULL;

    SECURITY_DESCRIPTOR sd;
    PSID pSid;              // not allocated

    printf("SetOwner\n");

    if (!SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE))
        PrintLastError("SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME)");

    if (ERROR_SUCCESS != (err = RegOpenKeyExA(
            hKeyBase,
            pszRegPath,
            0,                      // dwReserved
            WRITE_OWNER,
            &hKey))) {
        if (ERROR_FILE_NOT_FOUND == err) {
            DWORD dwDisposition;
            if (ERROR_SUCCESS == (err = RegCreateKeyExA(
                    hKeyBase,
                    pszRegPath,
                    0,                      // dwReserved
                    NULL,                   // lpClass
                    REG_OPTION_NON_VOLATILE,
                    WRITE_OWNER,
                    NULL,                   // lpSecurityAttributes
                    &hKey,
                    &dwDisposition)))
                printf("Created Subkey\n");
        }
    }

    if (ERROR_SUCCESS != err) {
        PrintLastError("RegOpenKeyExA(WRITE_OWNER)", err);
        hKey = NULL;
        goto ErrorReturn;
    }

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        PrintLastError("InitializeSecurityDescriptor");
        goto ErrorReturn;
    }

    if (!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY,
            &hToken
            )) {
        PrintLastError("OpenProcessToken");
        goto ErrorReturn;
    }

    if (NULL == (pvInfo = AllocAndGetTokenInfo(hToken, TokenUser)))
        goto ErrorReturn;
    else {
        PTOKEN_USER pTokenUser = (PTOKEN_USER) pvInfo;
        pSid = pTokenUser->User.Sid;
    }

    if (!SetSecurityDescriptorOwner(&sd, pSid, FALSE)) {
        PrintLastError("SetSecurityDescriptorOwner");
        goto ErrorReturn;
    }

    if (ERROR_SUCCESS != (err = RegSetKeySecurity(
            hKey,
            OWNER_SECURITY_INFORMATION,
            &sd
            ))) {
        PrintLastError("RegSetKeySecurity(OWNER)", err);
        goto ErrorReturn;
    }

ErrorReturn:
    if (hKey)
        RegCloseKey(hKey);
    if (hToken)
        CloseHandle(hToken);
    TestFree(pvInfo);
}

static void SetGroupDaclSacl(
    IN HKEY hKeyBase,
    IN LPCSTR pszRegPath
    )
{
    LONG err;
    HKEY hKey = NULL;
    HANDLE hToken = NULL;
    void *pvGroupInfo = NULL;
    void *pvUserInfo = NULL;

    SECURITY_DESCRIPTOR sd;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaWorldSidAuthority =
        SECURITY_WORLD_SID_AUTHORITY;
    PSID psidLocalSystem = NULL;
    PSID psidAdministrators = NULL;
    PSID psidEveryone = NULL;
    PSID psidUser;                      // Not allocated

    PACL pDacl = NULL;
    PACCESS_ALLOWED_ACE pAce;
    DWORD dwAclSize;
    DWORD i;

    SECURITY_INFORMATION SecInf = DACL_SECURITY_INFORMATION |
            GROUP_SECURITY_INFORMATION;
    REGSAM samDesired = WRITE_OWNER | WRITE_DAC;

    printf("SetGroupDaclSacl\n");

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        PrintLastError("InitializeSecurityDescriptor");
        goto ErrorReturn;
    }

    if (!SetCurrentPrivilege(SE_SECURITY_NAME, TRUE))
        PrintLastError("SetCurrentPrivilege(SE_SECURITY_NAME)");
    else {
        SecInf |= SACL_SECURITY_INFORMATION;
        samDesired |= ACCESS_SYSTEM_SECURITY;
        if (!SetSecurityDescriptorSacl(&sd, FALSE, NULL, FALSE)) {
            PrintLastError("SetSecurityDescriptorSacl");
            goto ErrorReturn;
        }
    }

    if (ERROR_SUCCESS != (err = RegOpenKeyExA(
            hKeyBase,
            pszRegPath,
            0,                      // dwReserved
            samDesired,
            &hKey))) {
        PrintLastError("RegOpenKeyExA(WRITE_OWNER | WRITE_DAC)", err);
        hKey = NULL;
        goto ErrorReturn;
    }

    if (!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY,
            &hToken
            )) {
        PrintLastError("OpenProcessToken");
        goto ErrorReturn;
    }

    if (NULL == (pvGroupInfo = AllocAndGetTokenInfo(hToken, TokenPrimaryGroup)))
        goto ErrorReturn;
    else {
        PTOKEN_PRIMARY_GROUP pTokenPrimaryGroup =
            (PTOKEN_PRIMARY_GROUP) pvGroupInfo;
        PSID pSid = pTokenPrimaryGroup->PrimaryGroup;

        if (!SetSecurityDescriptorGroup(&sd, pSid, FALSE)) {
            PrintLastError("SetSecurityDescriptorGroup");
            goto ErrorReturn;
        }
    }

    if (NULL == (pvUserInfo = AllocAndGetTokenInfo(hToken, TokenUser)))
        goto ErrorReturn;
    else {
        PTOKEN_USER pTokenUser = (PTOKEN_USER) pvUserInfo;
        psidUser = pTokenUser->User.Sid;
    }


    //
    // prepare the SIDS for LocalSystem, Administrators and Everyone
    //
    if (!AllocateAndInitializeSid(
            &siaNtAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidLocalSystem
            )) {
        PrintLastError("AllocateAndInitializeSid(LocalSystem)");
        goto ErrorReturn;
    }

    if (!AllocateAndInitializeSid(
            &siaNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators
            )) {
        PrintLastError("AllocateAndInitializeSid(Administrators)");
        goto ErrorReturn;
    }

    if (!AllocateAndInitializeSid(
            &siaWorldSidAuthority,
            1,
            SECURITY_WORLD_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidEveryone
            )) {
        PrintLastError("AllocateAndInitializeSid(Everyone)");
        goto ErrorReturn;
    }

    //
    // compute size of new acl
    //

    dwAclSize = sizeof(ACL) +
        4 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(psidLocalSystem) +
        GetLengthSid(psidAdministrators) +
        GetLengthSid(psidEveryone) +
        GetLengthSid(psidUser)
        ;

    //
    // allocate storage for Acl
    //
    if (NULL == (pDacl = (PACL) TestAlloc(dwAclSize)))
        goto ErrorReturn;

    if (!InitializeAcl(pDacl, dwAclSize, ACL_REVISION)) {
        PrintLastError("InitializeAcl");
        goto ErrorReturn;
    }

    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            KEY_ALL_ACCESS,
            psidLocalSystem
            )) {
        PrintLastError("AddAccessAllowedAce(LocalSystem)");
        goto ErrorReturn;
    }

    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            KEY_ALL_ACCESS,
            psidAdministrators
            )) {
        PrintLastError("AddAccessAllowedAce(Administrators)");
        goto ErrorReturn;
    }

    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            KEY_READ,
            psidEveryone
            )) {
        PrintLastError("AddAccessAllowedAce(Everyone)");
        goto ErrorReturn;
    }

    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            KEY_ALL_ACCESS,
            psidUser
            )) {
        PrintLastError("AddAccessAllowedAce(User)");
        goto ErrorReturn;
    }

    //
    // make containers inherit.
    //

    for (i = 0; i < 4; i++) {
        if(!GetAce(pDacl, i, (void **) &pAce)) {
            PrintLastError("GetAce");
            goto ErrorReturn;
        }
        pAce->Header.AceFlags = CONTAINER_INHERIT_ACE;
    }

    if (!SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE)) {
        PrintLastError("SetSecurityDescriptorDacl");
        goto ErrorReturn;
    }

    if (ERROR_SUCCESS != (err = RegSetKeySecurity(
            hKey,
            SecInf,
            &sd
            ))) {
        PrintLastError("RegSetKeySecurity(Group, DACL, SACL)", err);
        goto ErrorReturn;
    }

ErrorReturn:
    if (hKey)
        RegCloseKey(hKey);
    if (hToken)
        CloseHandle(hToken);
    TestFree(pvGroupInfo);
    TestFree(pvUserInfo);

    if (psidLocalSystem)
        FreeSid(psidLocalSystem);
    if (psidAdministrators)
        FreeSid(psidAdministrators);
    if (psidEveryone)
        FreeSid(psidEveryone);
    TestFree(pDacl);
}


int _cdecl main(int argc, char * argv[]) 
{
    int status;

#define TEST_NAME_INDEX     0
#define PATH_NAME_INDEX     1
#define MAX_NAME_CNT        2
    DWORD dwNameCnt = 0;
    LPCSTR rgpszName[MAX_NAME_CNT];
    LPCSTR pszTestName;                 // not allocated
    LPCSTR pszRegPath;                  // not allocated

    HKEY hKeyBase = HKEY_CURRENT_USER;
    LPCSTR pszKeyBase = "HKEY_CURRENT_USER";
    BOOL fRecurse = FALSE;
    HKEY hKey = NULL;

    while (--argc>0) {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'l':
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "CU")) {
                        hKeyBase = HKEY_CURRENT_USER;
                        pszKeyBase = "HKEY_CURRENT_USER";
                    } else if (0 == _stricmp(argv[0]+2, "LM")) {
                        hKeyBase = HKEY_LOCAL_MACHINE;
                        pszKeyBase = "HKEY_LOCAL_MACHINE";
                    } else {
                        printf("Need to specify -lCU or -lLM\n");
                        goto BadUsage;
                    }
                } else {
                    printf("Need to specify -lCU or -lLM\n");
                    goto BadUsage;
                }
                break;
            case 'r':
                fRecurse = TRUE;
                break;

            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (MAX_NAME_CNT <= dwNameCnt) {
                printf("Too many names starting with:: %s\n", argv[0]);
                goto BadUsage;
            }
            rgpszName[dwNameCnt++] = argv[0];
        }
    }


    printf("command line: %s\n", GetCommandLine());

    if (0 == dwNameCnt) {
        printf("Missing <TestName>\n");
        goto BadUsage;
    } else
        pszTestName = rgpszName[TEST_NAME_INDEX];

    if (0 == _stricmp("PurgeLMRoots", pszTestName)) {
        printf("Purge LocalMachine Duplicate Roots from CurrentUser\n");
        if (!I_CertProtectFunction(
                CERT_PROT_PURGE_LM_ROOTS_FUNC_ID,
                0,                                  // dwFlags
                NULL,                               // pwszIn
                NULL,                               // pbIn
                0,                                  // cbIn
                NULL,                               // ppbOut
                NULL                                // pcbOut
                ))
            PrintLastError(
                "I_CertProtectFunction(CERT_PROT_PURGE_LM_ROOTS_FUNC_ID)");
        goto SuccessReturn;
    } else if (0 == _stricmp("DeleteUnknownRoots", pszTestName)) {
        printf("Delete unknown CurrentUser roots from Protected List\n");
        if (!I_CertProtectFunction(
                CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID,
                0,                                  // dwFlags
                NULL,                               // pwszIn
                NULL,                               // pbIn
                0,                                  // cbIn
                NULL,                               // ppbOut
                NULL                                // pcbOut
                ))
            PrintLastError(
                "I_CertProtectFunction(CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID)");
        goto SuccessReturn;
    } else if (0 == _stricmp("ServiceUI", pszTestName)) {
        BYTE *pbOut = NULL;
        DWORD cbOut = 0;

        printf("Certificate Protect Service UI\n");
        if (!I_CertProtectFunction(
                1000,
                0,                  // dwFlags
                L"Root test",       // pwszIn
                NULL,               // pbIn
                0,                  // cbIn
                &pbOut,
                &cbOut
                ))
            PrintLastError("I_CertProtectFunction(UI)");
        else if (pbOut) {
            PrintBytes("DataOut", pbOut, cbOut);
            CryptMemFree(pbOut);
        }
        goto SuccessReturn;
    } else if (0 == _stricmp("ServiceTokenInfo", pszTestName)) {
        BYTE *pbOut = NULL;
        DWORD cbOut = 0;

        printf("Certificate Protect Service's Token Info\n");
        if (!I_CertProtectFunction(
                1001,
                0,                  // dwFlags
                NULL,               // pwszIn
                NULL,               // pbIn
                0,                  // cbIn
                &pbOut,
                &cbOut
                ))
            PrintLastError("I_CertProtectFunction(GetTokenInfo)");
        else if (pbOut) {
            if (cbOut)
                puts((LPCSTR) pbOut);
            CryptMemFree(pbOut);
        }
        goto SuccessReturn;
    } else if (0 == _stricmp("ServiceInvalid", pszTestName)) {
        printf("Calling Invalid Certificate Protect Function\n");
        if (!I_CertProtectFunction(
                1002,
                0,                  // dwFlags
                NULL,               // pwszIn
                NULL,               // pbIn
                0,                  // cbIn
                NULL,               // ppbOut
                NULL                // pcbOut
                ))
            PrintLastError("I_CertProtectFunction(1002)");
        goto SuccessReturn;
    } else if (1 == dwNameCnt) {
        printf("Missing <RegPath>\n");
        goto BadUsage;
    } else
        pszRegPath = rgpszName[PATH_NAME_INDEX];

    printf("\n");
    if (0 == _stricmp("GetKey", pszTestName)) {
        LONG err;
        REGSAM samDesired = READ_CONTROL | ACCESS_SYSTEM_SECURITY;
        SECURITY_INFORMATION SecInf = OWNER_SECURITY_INFORMATION |
            GROUP_SECURITY_INFORMATION |
            DACL_SECURITY_INFORMATION |
            SACL_SECURITY_INFORMATION;

        if (!SetCurrentPrivilege(SE_SECURITY_NAME, TRUE)) {
            PrintLastError("SetCurrentPrivilege(SE_SECURITY_NAME)");
            samDesired = READ_CONTROL;
            SecInf &= ~SACL_SECURITY_INFORMATION;
        }

        if (!SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE))
            PrintLastError("SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME)");

        GetProcessTokenInfo();

        printf("\n\nGet Registry Key Security Information\n\n");
        if (ERROR_SUCCESS != (err = RegOpenKeyExA(
                hKeyBase,
                pszRegPath,
                0,                      // dwReserved
                KEY_READ | samDesired,
                &hKey))) {
            if (ERROR_ACCESS_DENIED == err) {
                if (ERROR_SUCCESS == (err = RegOpenKeyExA(
                        hKeyBase,
                        pszRegPath,
                        0,                      // dwReserved
                        samDesired,
                        &hKey))) {
                    printf("No Read Access\n");
                    fRecurse = FALSE;
                }
            }
        }

        
        if (ERROR_SUCCESS != err) {
            printf("RegOpenKeyExA(%s\\%s) failed => 0x%x (%d)\n",
                pszKeyBase, pszRegPath, err, err);
            hKey = NULL;
        } else
            DisplayRegSecurityInfo(
                hKey,
                pszKeyBase,
                pszRegPath,
                SecInf,
                fRecurse
                );
    } else if (0 == _stricmp("SetKey", pszTestName)) {
        printf("Set Registry Key Security Information\n\n");

        SetOwner(hKeyBase, pszRegPath);
        SetGroupDaclSacl(hKeyBase, pszRegPath);

    } else {
        printf("Invalid TestName: %s\n", pszTestName);
        goto BadUsage;
    }

SuccessReturn:
    status = 0;
CommonReturn:
    if (hKey)
        RegCloseKey(hKey);
    return status;
BadUsage:
    Usage();
    status = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tcertper\tcertper.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tcertper.cpp
//
//  Contents:   Cert Performance Tests
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    30-Nov-97   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "wintrust.h"
#include "softpub.h"
#include "mscat.h"
#include "certtest.h"
#include "unicode.h"
#include "certprot.h"

#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


static void Usage(void)
{
    printf("Usage: tcertper [options] <TestName> [<Para1> <Para2>]\n");
    printf("\n");
    printf("  -UseIE4Trust\n");
    printf("  -NoIE4Chain\n");
    printf("  -CacheEndCert\n");
    printf("\n");
    printf("  -NoEntry\n");
    printf("  -NoMsg\n");
    printf("\n");
    printf("  -AuthPolicy\n");
    printf("  -TSPolicy\n");
    printf("\n");
    printf("  -Pause\n");
    printf("\n");
    printf("Options are:\n");
    printf("  -u<OID String>    - Usage OID string -u1.3.6.1.5.5.7.3.3\n");
    printf("  -h                - This message\n");
    printf("  -i<number>        - Iterations (default to 1000)\n");
    printf("TestNames (case insensitive):\n");
    printf("  NULL\n");
    printf("  CreateCertContext <cert filename>\n");
    printf("  VerifyCertSignature <cert filename> [<issuer filename>]\n");
    printf("  CreateCRLContext <CRL filename>\n");
    printf("  CreateCTLContext <CTL filename>\n");
    printf("  CreateSortedCTLContext <CTL filename>\n");
    printf("  CreateFastCTLContext <CTL filename>\n");
    printf("  DecodePKCS7 <CTL filename>\n");
    printf("  StreamDecodePKCS7 <CTL filename>\n");
    printf("  GetCertProperty <cert filename>\n");
    printf("  DecodeOID <OID>\n");
    printf("  FindExtension <cert filename> <OID>\n");
    printf("  DecodeExtension <cert filename> <OID>\n");
    printf("  WVTCert <cert filename> [<AdditionalFileStore>]\n");
    printf("  WVTFile <filename>\n");
    printf("  WVTCat <cat filename> <member filename>\n");
    printf("  CertChain <cert filename> [<AdditionalFileStore>]\n");
    printf("\n");
}

#define NULL_TEST_ID                        1
#define CREATE_CERT_CONTEXT_TEST_ID         2
#define VERIFY_CERT_SIGNATURE_TEST_ID       3
#define CREATE_CTL_CONTEXT_TEST_ID          4
#define GET_CERT_PROPERTY_TEST_ID           5
#define DECODE_OID_TEST_ID                  6
#define FIND_EXTENSION_TEST_ID              7
#define DECODE_EXTENSION_TEST_ID            8
#define CREATE_SORTED_CTL_CONTEXT_TEST_ID   9
#define DECODE_PKCS7_TEST_ID                10
#define STREAM_DECODE_PKCS7_TEST_ID         11
#define WVT_CERT_TEST_ID                    12
#define WVT_FILE_TEST_ID                    13
#define CERT_CHAIN_TEST_ID                  14
#define CREATE_CRL_CONTEXT_TEST_ID          15
#define WVT_CAT_TEST_ID                     16
#define CREATE_FAST_CTL_CONTEXT_TEST_ID     17
static struct
{
    LPCSTR      pszName;
    DWORD       dwID;
} Tests[] = {
    "NULL",                 NULL_TEST_ID,
    "CreateCertContext",    CREATE_CERT_CONTEXT_TEST_ID,
    "VerifyCertSignature",  VERIFY_CERT_SIGNATURE_TEST_ID,
    "CreateCRLContext",     CREATE_CRL_CONTEXT_TEST_ID,
    "CreateCTLContext",     CREATE_CTL_CONTEXT_TEST_ID,
    "GetCertProperty",      GET_CERT_PROPERTY_TEST_ID,
    "DecodeOID",            DECODE_OID_TEST_ID,
    "FindExtension",        FIND_EXTENSION_TEST_ID,
    "DecodeExtension",      DECODE_EXTENSION_TEST_ID,
    "CreateSortedCTLContext", CREATE_SORTED_CTL_CONTEXT_TEST_ID,
    "CreateFastCTLContext", CREATE_FAST_CTL_CONTEXT_TEST_ID,
    "DecodePKCS7",          DECODE_PKCS7_TEST_ID,
    "StreamDecodePKCS7",    STREAM_DECODE_PKCS7_TEST_ID,
    "WVTCert",              WVT_CERT_TEST_ID,
    "WVTFile",              WVT_FILE_TEST_ID,
    "WVTCat",               WVT_CAT_TEST_ID,
    "CertChain",            CERT_CHAIN_TEST_ID,
};
#define NTESTS (sizeof(Tests)/sizeof(Tests[0]))

static BOOL WINAPI StreamOutputCallback(
        IN const void *pvArg,
        IN BYTE *pbData,
        IN DWORD cbData,
        IN BOOL fFinal
        )
{
#if 0
    printf("StreamOutputCallback:: pbData: 0x%x cbData: 0x%x fFinal: 0x%x\n",
        pbData, cbData, fFinal);
#endif
    return TRUE;
}


static PCCERT_CONTEXT ReadCert(
    IN LPCSTR pszCert
    )
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    PCCERT_CONTEXT pCert;

    if (!ReadDERFromFile(pszCert, &pbEncoded, &cbEncoded)) {
        PrintLastError("ReadCert");
        return NULL;
    }

    pCert = CertCreateCertificateContext(
        dwCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    if (pCert == NULL)
        PrintLastError("CertCreateCertificateContext");

    TestFree(pbEncoded);
    return pCert;
}


int _cdecl main(int argc, char * argv[]) 
{
    int status;

#define TEST_NAME_INDEX         0
#define CERT_FILENAME_INDEX     1
#define CTL_FILENAME_INDEX      1
#define CRL_FILENAME_INDEX      1
#define PKCS7_FILENAME_INDEX    1
#define OID_INDEX               1
#define WVT_FILENAME_INDEX      1
#define ISSUER_FILENAME_INDEX   2
#define CERT_OID_INDEX          2
#define STORE_FILENAME_INDEX    2
#define WVT_CAT_FILENAME_INDEX  1
#define WVT_MEMBER_FILENAME_INDEX 2
#define MAX_NAME_CNT            3
    DWORD dwNameCnt = 0;
    LPCSTR rgpszName[MAX_NAME_CNT];
    LPCSTR pszTestName;                 // not allocated

    
    DWORD dwIterations = 1000;
    DWORD i;
    DWORD dwTestID;
    BOOL fPause = FALSE;


    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbEncodedCert = NULL;
    DWORD cbEncodedCert;
    PCCERT_CONTEXT pCert = NULL;
    PCCERT_CONTEXT pIssuer = NULL;
    PCCTL_CONTEXT pCtl = NULL;
    PCCRL_CONTEXT pCrl = NULL;
    HCRYPTMSG hMsg = NULL;
    CMSG_STREAM_INFO StreamInfo;

    LPCSTR pszOID;
    BYTE rgbEncodedAttr[512];
    DWORD cbEncodedAttr;

    BYTE rgbAttr[512];
    DWORD cbAttr;
    PCRYPT_ATTRIBUTE pAttr = (PCRYPT_ATTRIBUTE) rgbAttr;
    

    DWORD dwProp;
    DWORD cbData;

    PCERT_EXTENSION pExt;
    DWORD cbExt;
    BYTE rgbExt[8192];

    SYSTEMTIME stFirst, stStart, stEnd;
    FILETIME ftFirst, ftStart, ftEnd;

    _int64 DeltaTime;
    int Microseconds;
    int Milliseconds;
    int Seconds;

    DWORD dwCreateChainFlags = 0;
    DWORD dwError;
    DWORD dwFirstError;
    LONG lStatus;
    LONG lFirstStatus;
    LPSTR pszUsageOID = NULL;           // not allocated
    LPSTR pszSignerUsage = szOID_KP_CTL_USAGE_SIGNING;

    GUID wvtFileActionID = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    GUID wvtCertActionID = WINTRUST_ACTION_GENERIC_CERT_VERIFY;
    GUID wvtDriverActionID = DRIVER_ACTION_VERIFY;
    GUID *pwvtActionID;

    WINTRUST_FILE_INFO wvtFileInfo;
    memset(&wvtFileInfo, 0, sizeof(wvtFileInfo));
    wvtFileInfo.cbStruct = sizeof(wvtFileInfo);
    wvtFileInfo.pcwszFilePath = NULL;

    HCERTSTORE hAdditionalStore = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;

    WINTRUST_CERT_INFO wvtCertInfo;
    memset(&wvtCertInfo, 0, sizeof(wvtCertInfo));
    wvtCertInfo.cbStruct = sizeof(wvtCertInfo);
    wvtCertInfo.psCertContext = NULL;
    wvtCertInfo.chStores = 0;
    wvtCertInfo.pahStores = &hAdditionalStore;
    wvtCertInfo.dwFlags = 0;
    wvtCertInfo.pcwszDisplayName = L"Cert Display Name";

    WINTRUST_DATA wvtData;
    memset(&wvtData, 0, sizeof(wvtData));
    wvtData.cbStruct = sizeof(wvtData);
    wvtData.pPolicyCallbackData = NULL;
    wvtData.dwUIChoice = WTD_UI_NONE;
    wvtData.fdwRevocationChecks = WTD_REVOKE_NONE;
    wvtData.dwUnionChoice = WTD_CHOICE_CERT;
    wvtData.pCert = &wvtCertInfo;
    wvtData.dwStateAction = WTD_STATEACTION_IGNORE;
    wvtData.hWVTStateData = NULL;
    wvtData.dwProvFlags = 0;

    WINTRUST_CATALOG_INFO wvtCat;
    memset(&wvtCat, 0, sizeof(wvtCat));
    wvtCat.cbStruct = sizeof(WINTRUST_CATALOG_INFO);

    DWORD cbCatHash;
    BYTE rgbCatHash[40];

    CERT_CHAIN_PARA ChainPara;
    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

    CERT_CHAIN_POLICY_PARA ChainPolicyPara;
    memset(&ChainPolicyPara, 0, sizeof(ChainPolicyPara));
    ChainPolicyPara.cbSize = sizeof(ChainPolicyPara);

    CERT_CHAIN_POLICY_STATUS ChainPolicyStatus;
    memset(&ChainPolicyStatus, 0, sizeof(ChainPolicyStatus));
    ChainPolicyStatus.cbSize = sizeof(ChainPolicyStatus);

    LPCSTR pszChainPolicyOID = CERT_CHAIN_POLICY_BASE;

    DWORD dwFastCtlFlags = 0;

    while (--argc>0) {
        if (**++argv == '-')
        {
            if (0 == _stricmp(argv[0]+1, "UseIE4Trust")) {
                wvtData.dwProvFlags |= WTD_USE_IE4_TRUST_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "NoIE4Chain")) {
                wvtData.dwProvFlags |= WTD_NO_IE4_CHAIN_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "CacheEndCert")) {
                dwCreateChainFlags |= CERT_CHAIN_CACHE_END_CERT;

            } else if (0 == _stricmp(argv[0]+1, "AuthPolicy")) {
                pszChainPolicyOID = CERT_CHAIN_POLICY_AUTHENTICODE;
            } else if (0 == _stricmp(argv[0]+1, "TSPolicy")) {
                pszChainPolicyOID = CERT_CHAIN_POLICY_AUTHENTICODE_TS;

            } else if (0 == _stricmp(argv[0]+1, "NoMsg")) {
                dwFastCtlFlags |= CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "NoEntry")) {
                dwFastCtlFlags |= CERT_CREATE_CONTEXT_NO_ENTRY_FLAG;

            } else if (0 == _stricmp(argv[0]+1, "Pause")) {
                fPause = TRUE;

            } else {
                switch(argv[0][1])
                {
                case 'u':
                    pszUsageOID = argv[0]+2;
                    break;
                case 'i':
                    dwIterations = strtoul(argv[0]+2, NULL, 0);
                    break;

                case 'h':
                default:
                    goto BadUsage;
                }
            }
        } else {
            if (MAX_NAME_CNT <= dwNameCnt) {
                printf("Too many names starting with:: %s\n", argv[0]);
                goto BadUsage;
            }
            rgpszName[dwNameCnt++] = argv[0];
        }
    }


    printf("command line: %s\n", GetCommandLine());

    if (0 == dwNameCnt) {
        printf("Missing <TestName>\n");
        goto BadUsage;
    } else
        pszTestName = rgpszName[TEST_NAME_INDEX];

    dwTestID = 0;
    for (i = 0; i < NTESTS; i++) {
        if (_stricmp(pszTestName, Tests[i].pszName) == 0) {
            dwTestID = Tests[i].dwID;
            break;
        }
    }
    if (0 == dwTestID) {
        printf("Bad TestName: %s\n", pszTestName);
        Usage();
        goto BadUsage;
    }

    if (0 == dwIterations) {
        printf("0 iterations\n");
        goto BadUsage;
    } else
        printf("%d iterations\n", dwIterations);

    if (fPause) {
        int c;
        fputs("Waiting to start ->", stdout);
        fflush(stdin);
        fflush(stdout);
        c = getchar();
    }

    GetSystemTime(&stFirst);
    for (i = 0; i <= dwIterations; i++) {
        if (1 == i)
            GetSystemTime(&stStart);

        switch (dwTestID) {
            case NULL_TEST_ID:
                break;

            case CREATE_CERT_CONTEXT_TEST_ID:
                if (0 == i) {
                    if (CERT_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing cert filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CERT_FILENAME_INDEX],
                            &pbEncodedCert,
                            &cbEncodedCert
                            )) {
                        printf("Unable to read cert file\n");
                        goto ErrorReturn;
                    }
                }

                if (NULL == (pCert = CertCreateCertificateContext(
                        X509_ASN_ENCODING,
                        pbEncodedCert,
                        cbEncodedCert
                        ))) {
                    PrintLastError("CertCreateCertificateContext");
                    goto ErrorReturn;
                }
                CertFreeCertificateContext(pCert);
                pCert = NULL;
                break;

            case VERIFY_CERT_SIGNATURE_TEST_ID:
                if (0 == i) {
                    if (CERT_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing cert filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CERT_FILENAME_INDEX],
                            &pbEncodedCert,
                            &cbEncodedCert
                            )) {
                        printf("Unable to read cert file\n");
                        goto ErrorReturn;
                    }

                    if (NULL == (pCert = CertCreateCertificateContext(
                            X509_ASN_ENCODING,
                            pbEncodedCert,
                            cbEncodedCert
                            ))) {
                        PrintLastError("CertCreateCertificateContext(cert)");
                        goto ErrorReturn;
                    }

                    TestFree(pbEncodedCert);
                    pbEncodedCert = NULL;

                    if (ISSUER_FILENAME_INDEX >= dwNameCnt)
                        pIssuer = CertDuplicateCertificateContext(pCert);
                    else {
                        if (!ReadDERFromFile(
                                rgpszName[ISSUER_FILENAME_INDEX],
                                &pbEncodedCert,
                                &cbEncodedCert
                                )) {
                            printf("Unable to read issuer file\n");
                            goto ErrorReturn;
                        }

                        if (NULL == (pIssuer = CertCreateCertificateContext(
                                X509_ASN_ENCODING,
                                pbEncodedCert,
                                cbEncodedCert
                                ))) {
                            PrintLastError(
                                "CertCreateCertificateContext(issuer)");
                            goto ErrorReturn;
                        }
                    }
                }

                if (!CryptVerifyCertificateSignature(
                        0,              // hCryptProv
                        pCert->dwCertEncodingType,
                        pCert->pbCertEncoded,
                        pCert->cbCertEncoded,
                        &pIssuer->pCertInfo->SubjectPublicKeyInfo
                        )) {
                    PrintLastError("CryptVerifyCertificateSignature");
                    goto ErrorReturn;
                }
                break;

            case CREATE_CRL_CONTEXT_TEST_ID:
                if (0 == i) {
                    if (CRL_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing CRL filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CRL_FILENAME_INDEX],
                            &pbEncoded,
                            &cbEncoded
                            )) {
                        printf("Unable to read CRL file\n");
                        goto ErrorReturn;
                    }
                }

                if (NULL == (pCrl = CertCreateCRLContext(
                        X509_ASN_ENCODING,
                        pbEncoded,
                        cbEncoded
                        ))) {
                    PrintLastError("CertCreateCRLContext");
                    goto ErrorReturn;
                }
                CertFreeCRLContext(pCrl);
                pCrl = NULL;
                break;


            case CREATE_CTL_CONTEXT_TEST_ID:
                if (0 == i) {
                    if (CTL_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing CTL filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CTL_FILENAME_INDEX],
                            &pbEncoded,
                            &cbEncoded
                            )) {
                        printf("Unable to read CTL file\n");
                        goto ErrorReturn;
                    }
                }

                if (NULL == (pCtl = CertCreateCTLContext(
                        X509_ASN_ENCODING,
                        pbEncoded,
                        cbEncoded
                        ))) {
                    PrintLastError("CertCreateCTLContext");
                    goto ErrorReturn;
                }
                CertFreeCTLContext(pCtl);
                pCtl = NULL;
                break;

            case CREATE_SORTED_CTL_CONTEXT_TEST_ID:
                if (0 == i) {
                    if (CTL_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing CTL filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CTL_FILENAME_INDEX],
                            &pbEncoded,
                            &cbEncoded
                            )) {
                        printf("Unable to read CTL file\n");
                        goto ErrorReturn;
                    }
                }

                if (NULL == (pCtl = (PCCTL_CONTEXT) CertCreateContext(
                        CERT_STORE_CTL_CONTEXT,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        pbEncoded,
                        cbEncoded,
                        CERT_CREATE_CONTEXT_NOCOPY_FLAG |
                            CERT_CREATE_CONTEXT_SORTED_FLAG,
                        NULL                                // pCreatePara
                        ))) {
                    PrintLastError("CertCreateContext(Sorted CTL)");
                    goto ErrorReturn;
                }
                CertFreeCTLContext(pCtl);
                pCtl = NULL;
                break;

            case CREATE_FAST_CTL_CONTEXT_TEST_ID:
                if (0 == i) {
                    dwFastCtlFlags |= CERT_CREATE_CONTEXT_NOCOPY_FLAG;

                    if (CTL_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing CTL filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CTL_FILENAME_INDEX],
                            &pbEncoded,
                            &cbEncoded
                            )) {
                        printf("Unable to read CTL file\n");
                        goto ErrorReturn;
                    }
                }

                if (NULL == (pCtl = (PCCTL_CONTEXT) CertCreateContext(
                        CERT_STORE_CTL_CONTEXT,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        pbEncoded,
                        cbEncoded,
                        dwFastCtlFlags,
                        NULL                                // pCreatePara
                        ))) {
                    PrintLastError("CertCreateContext(Fast CTL)");
                    goto ErrorReturn;
                }
                CertFreeCTLContext(pCtl);
                pCtl = NULL;
                break;

            case DECODE_PKCS7_TEST_ID:
                if (0 == i) {
                    if (PKCS7_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing PKCS7 filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[PKCS7_FILENAME_INDEX],
                            &pbEncoded,
                            &cbEncoded
                            )) {
                        printf("Unable to read PKCS7 file\n");
                        goto ErrorReturn;
                    }
                }
                if (NULL == (hMsg = CryptMsgOpenToDecode(
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        0,                          // dwFlags
                        0,                          // dwMsgType
                        NULL,                       // hProv
                        NULL,                       // pRecipientInfo
                        NULL                        // pStreamInfo
                        ))) {
                    PrintLastError("CryptMsgOpenToDecode");
                    goto ErrorReturn;
                }
                if (!CryptMsgUpdate(
                        hMsg,
                        pbEncoded,
                        cbEncoded,
                        TRUE                    // fFinal
                        )) {
                    PrintLastError("CryptMsgUpdate");
                    goto ErrorReturn;
                }
                CryptMsgClose(hMsg);
                hMsg = NULL;
                break;

            case STREAM_DECODE_PKCS7_TEST_ID:
                if (0 == i) {
                    if (PKCS7_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing PKCS7 filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[PKCS7_FILENAME_INDEX],
                            &pbEncoded,
                            &cbEncoded
                            )) {
                        printf("Unable to read PKCS7 file\n");
                        goto ErrorReturn;
                    }
                }
                memset(&StreamInfo, 0, sizeof(StreamInfo));
                StreamInfo.pfnStreamOutput = StreamOutputCallback;
                if (NULL == (hMsg = CryptMsgOpenToDecode(
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        0,                          // dwFlags
                        0,                          // dwMsgType
                        NULL,                       // hProv
                        NULL,                       // pRecipientInfo
                        &StreamInfo
                        ))) {
                    PrintLastError("CryptMsgOpenToDecode(STREAM)");
                    goto ErrorReturn;
                }
                if (!CryptMsgUpdate(
                        hMsg,
                        pbEncoded,
                        cbEncoded,
                        TRUE                    // fFinal
                        )) {
                    PrintLastError("CryptMsgUpdate");
                    goto ErrorReturn;
                }
                CryptMsgClose(hMsg);
                hMsg = NULL;
                break;

            case GET_CERT_PROPERTY_TEST_ID:
                if (0 == i) {
                    CRYPT_DATA_BLOB DataBlob;

                    if (CERT_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing cert filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CERT_FILENAME_INDEX],
                            &pbEncodedCert,
                            &cbEncodedCert
                            )) {
                        printf("Unable to read cert file\n");
                        goto ErrorReturn;
                    }

                    if (NULL == (pCert = CertCreateCertificateContext(
                            X509_ASN_ENCODING,
                            pbEncodedCert,
                            cbEncodedCert
                            ))) {
                        PrintLastError("CertCreateCertificateContext");
                        goto ErrorReturn;
                    }

                    DataBlob.pbData = (BYTE *) &dwProp;
                    DataBlob.cbData = sizeof(dwProp);
                    dwProp = 0x12345678;

                    if (!CertSetCertificateContextProperty(
                            pCert,
                            CERT_FIRST_USER_PROP_ID,
                            0,                          // dwFlags
                            &DataBlob
                            )) {
                        PrintLastError("CertSetCertificateContextProperty");
                        goto ErrorReturn;
                    }
                }

                dwProp = 0;
                cbData = sizeof(dwProp);
                if (!CertGetCertificateContextProperty(
                        pCert,
                        CERT_FIRST_USER_PROP_ID,
                        &dwProp,
                        &cbData
                        )) {
                    PrintLastError("CertGetCertificateContextProperty");
                    goto ErrorReturn;
                }

                if (0x12345678 != dwProp || sizeof(dwProp) != cbData) {
                    printf("failed => invalid get property\n");
                    goto ErrorReturn;
                }
                break;

            case DECODE_OID_TEST_ID:
                if (0 == i) {
                    CRYPT_ATTRIBUTE Attribute;

                    if (OID_INDEX >= dwNameCnt) {
                        printf("missing OID\n");
                        goto BadUsage;
                    } else
                        pszOID = rgpszName[OID_INDEX];

                    Attribute.pszObjId = (LPSTR) pszOID;
                    Attribute.cValue = 0;
                    Attribute.rgValue = NULL;

                    cbEncodedAttr = sizeof(rgbEncodedAttr);
                    if (!CryptEncodeObject(
                            X509_ASN_ENCODING,
                            PKCS_ATTRIBUTE,
                            &Attribute,
                            rgbEncodedAttr,
                            &cbEncodedAttr
                            )) {
                        PrintLastError("CryptEncodeObject(PKCS_ATTRIBUTE)");
                        goto ErrorReturn;
                    }
                }

                pAttr->pszObjId = NULL;
                cbAttr = sizeof(rgbAttr);
                if (!CryptDecodeObject(
                        X509_ASN_ENCODING,
                        PKCS_ATTRIBUTE,
                        rgbEncodedAttr,
                        cbEncodedAttr,
                        CRYPT_DECODE_NOCOPY_FLAG,
                        pAttr,
                        &cbAttr
                        )) {
                    PrintLastError("CryptDecodeObject(PKCS_ATTRIBUTE)");
                    goto ErrorReturn;
                }

                if (0 != strcmp(pszOID, pAttr->pszObjId)) {
                    printf("failed => invalid decoded OID\n");
                    goto ErrorReturn;
                }
                break;

            case FIND_EXTENSION_TEST_ID:
                if (0 == i) {
                    CRYPT_DATA_BLOB DataBlob;

                    if (CERT_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing cert filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CERT_FILENAME_INDEX],
                            &pbEncodedCert,
                            &cbEncodedCert
                            )) {
                        printf("Unable to read cert file\n");
                        goto ErrorReturn;
                    }

                    if (NULL == (pCert = CertCreateCertificateContext(
                            X509_ASN_ENCODING,
                            pbEncodedCert,
                            cbEncodedCert
                            ))) {
                        PrintLastError("CertCreateCertificateContext");
                        goto ErrorReturn;
                    }

                    if (CERT_OID_INDEX >= dwNameCnt) {
                        printf("missing OID\n");
                        goto BadUsage;
                    } else
                        pszOID = rgpszName[CERT_OID_INDEX];

                }

                if (NULL == (pExt = CertFindExtension(
                        pszOID,
                        pCert->pCertInfo->cExtension,
                        pCert->pCertInfo->rgExtension
                        ))) {
                    PrintLastError("CertFindExtension");
                    goto ErrorReturn;
                }

                break;

            case DECODE_EXTENSION_TEST_ID:
                if (0 == i) {
                    CRYPT_DATA_BLOB DataBlob;

                    if (CERT_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing cert filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CERT_FILENAME_INDEX],
                            &pbEncodedCert,
                            &cbEncodedCert
                            )) {
                        printf("Unable to read cert file\n");
                        goto ErrorReturn;
                    }

                    if (NULL == (pCert = CertCreateCertificateContext(
                            X509_ASN_ENCODING,
                            pbEncodedCert,
                            cbEncodedCert
                            ))) {
                        PrintLastError("CertCreateCertificateContext");
                        goto ErrorReturn;
                    }

                    if (CERT_OID_INDEX >= dwNameCnt) {
                        printf("missing OID\n");
                        goto BadUsage;
                    } else
                        pszOID = rgpszName[CERT_OID_INDEX];

                    if (NULL == (pExt = CertFindExtension(
                            pszOID,
                            pCert->pCertInfo->cExtension,
                            pCert->pCertInfo->rgExtension
                            ))) {
                        PrintLastError("CertFindExtension");
                        goto ErrorReturn;
                    }

                }

#if 0
                cbExt = sizeof(rgbExt);
                if (!CryptDecodeObject(
                        X509_ASN_ENCODING,
                        pExt->pszObjId,
                        pExt->Value.pbData,
                        pExt->Value.cbData,
                        CRYPT_DECODE_NOCOPY_FLAG,
                        rgbExt,
                        &cbExt
                        )) {
                    PrintLastError("CryptDecodeObject(Extension)");
                    goto ErrorReturn;
                }
#else
                {
                    void *pvExt;
                    if (!CryptDecodeObjectEx(
                            X509_ASN_ENCODING,
                            pExt->pszObjId,
                            pExt->Value.pbData,
                            pExt->Value.cbData,
                            CRYPT_DECODE_ALLOC_FLAG |
                                CRYPT_DECODE_NOCOPY_FLAG |
                                CRYPT_DECODE_SHARE_OID_STRING_FLAG,
                            NULL,
                            (void *) &pvExt,
                            &cbExt
                            )) {
                        PrintLastError("CryptDecodeObjectEx(Extension)");
                        goto ErrorReturn;
                    } else
                        LocalFree(pvExt);
                }
#endif


                break;

            case WVT_CERT_TEST_ID:
                if (0 == i) {
                    if (CERT_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing cert filename\n");
                        goto BadUsage;
                    }
                    pwvtActionID = &wvtCertActionID;
                    wvtData.dwUnionChoice = WTD_CHOICE_CERT;
                    wvtData.pCert = &wvtCertInfo;
                    wvtData.pPolicyCallbackData = (void *) pszUsageOID;
                    if (NULL == (wvtCertInfo.psCertContext = (CERT_CONTEXT *)
                            ReadCert(rgpszName[CERT_FILENAME_INDEX])))
                        goto ErrorReturn;

                    if (STORE_FILENAME_INDEX < dwNameCnt) {
                        if (NULL == (hAdditionalStore =
                            OpenSystemStoreOrFile(
                                FALSE,              // fSystemStore
                                rgpszName[STORE_FILENAME_INDEX],
                                0                   // dwFlags
                                )))
                            goto BadUsage;
                        wvtCertInfo.chStores = 1;
                    }
                }

                lStatus = WinVerifyTrust(
                    NULL,               // hwnd
                    pwvtActionID,
                    &wvtData
                    );
                if (0 == i) {
                    lFirstStatus = lStatus;
                    printf("WinVerifyTrust returned => 0x%x\n", lStatus);
                } else {
                    if (lStatus != lFirstStatus) {
                        printf("WinVerifyTrust failed => 0x%x\n", lStatus);
                        goto ErrorReturn;
                    }
                }
                break;

            case WVT_FILE_TEST_ID:
                if (0 == i) {
                    if (WVT_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing WVT filename\n");
                        goto BadUsage;
                    }
                    pwvtActionID = &wvtFileActionID;
                    wvtData.dwUnionChoice = WTD_CHOICE_FILE;
                    wvtData.pFile = &wvtFileInfo;
                    wvtFileInfo.pcwszFilePath = AllocAndSzToWsz(
                        rgpszName[WVT_FILENAME_INDEX]);
                }

                lStatus = WinVerifyTrust(
                    NULL,               // hwnd
                    pwvtActionID,
                    &wvtData
                    );
                if (0 == i) {
                    lFirstStatus = lStatus;
                    printf("WinVerifyTrust returned => 0x%x\n", lStatus);
                } else {
                    if (lStatus != lFirstStatus) {
                        printf("WinVerifyTrust failed => 0x%x\n", lStatus);
                        goto ErrorReturn;
                    }
                }
                break;

            case WVT_CAT_TEST_ID:
                if (0 == i) {
                    if (WVT_MEMBER_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing WVT member filename\n");
                        goto BadUsage;
                    }
                    pwvtActionID = &wvtDriverActionID;

                    wvtData.dwUnionChoice = WTD_CHOICE_CATALOG;
                    wvtData.pCatalog = &wvtCat;

                    wvtCat.pcwszCatalogFilePath = AllocAndSzToWsz(
                        rgpszName[WVT_CAT_FILENAME_INDEX]);
                    wvtCat.pcwszMemberTag = L"foo";
                    wvtCat.pcwszMemberFilePath = AllocAndSzToWsz(
                        rgpszName[WVT_MEMBER_FILENAME_INDEX]);
                    wvtCat.hMemberFile = CreateFileU(
                        wvtCat.pcwszMemberFilePath,
                        GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, NULL);

                    cbCatHash  = sizeof(rgbCatHash);
                    if (!(CryptCATAdminCalcHashFromFileHandle(
                            wvtCat.hMemberFile, &cbCatHash, rgbCatHash, 0))) {
                        PrintLastError("CryptCATAdminCalcHashFromFileHandle");
                        goto ErrorReturn;
                    }

                    wvtCat.pbCalculatedFileHash = rgbCatHash;
                    wvtCat.cbCalculatedFileHash = cbCatHash;
                }

                lStatus = WinVerifyTrust(
                    NULL,               // hwnd
                    pwvtActionID,
                    &wvtData
                    );
                if (0 == i) {
                    lFirstStatus = lStatus;
                    printf("WinVerifyTrust returned => 0x%x\n", lStatus);
                } else {
                    if (lStatus != lFirstStatus) {
                        printf("WinVerifyTrust failed => 0x%x\n", lStatus);
                        goto ErrorReturn;
                    }
                }
                break;

            case CERT_CHAIN_TEST_ID:
                if (0 == i) {
                    if (CERT_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing cert filename\n");
                        goto BadUsage;
                    }
                    if (NULL == (pCert =
                            ReadCert(rgpszName[CERT_FILENAME_INDEX])))
                        goto ErrorReturn;

                    if (STORE_FILENAME_INDEX < dwNameCnt) {
                        if (NULL == (hAdditionalStore =
                            OpenSystemStoreOrFile(
                                FALSE,              // fSystemStore
                                rgpszName[STORE_FILENAME_INDEX],
                                0                   // dwFlags
                                )))
                            goto BadUsage;
                    }

                    if (pszUsageOID) {
                        ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
                        ChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
                        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier =
                            &pszUsageOID;
                    }
                }

                if (!CertGetCertificateChain(
                        NULL,                   // hChainEngine
                        pCert,
                        NULL,                   // pTime
                        hAdditionalStore,
                        &ChainPara,
                        dwCreateChainFlags,
                        NULL,                   // pvReserved
                        &pChainContext
                        )) {
                    PrintLastError("CertGetCertificateChain");
                    goto ErrorReturn;
                }
                if (!CertVerifyCertificateChainPolicy(
                        pszChainPolicyOID,
                        pChainContext,
                        &ChainPolicyPara,
                        &ChainPolicyStatus
                        )) {
                    PrintLastError("CertVerifyCertificateChainPolicy");
                    goto ErrorReturn;
                }

                if (0 == i) {
                    dwFirstError = ChainPolicyStatus.dwError;
                    printf("Chain Policy returned => 0x%x\n", dwFirstError);
                    if (dwFirstError)
                        printf("Chain Index: %d Element Index: %d\n",
                            ChainPolicyStatus.lChainIndex,
                            ChainPolicyStatus.lElementIndex
                            );
                } else {
                    dwError = ChainPolicyStatus.dwError;
                    if (dwError != dwFirstError) {
                        printf("Chain Policy failed => 0x%x\n", dwError);
                        goto ErrorReturn;
                    }
                }

                if (pChainContext) {
                    CertFreeCertificateChain(pChainContext);
                    pChainContext = NULL;
                }
                break;

            default:
                printf("unknown test name\n");
                goto BadUsage;
        }
    }

    GetSystemTime(&stEnd);
    SystemTimeToFileTime(&stFirst, &ftFirst);
    SystemTimeToFileTime(&stStart, &ftStart);
    SystemTimeToFileTime(&stEnd, &ftEnd);

    DeltaTime = *((_int64 *) &ftStart) - *((_int64 *) &ftFirst);
    Microseconds = (int) (DeltaTime / 10);
    Milliseconds = (int) (DeltaTime / 10000);
    Seconds = (int) (DeltaTime / 10000000);
    printf("First Micro: %d Milli: %d Seconds: %d\n",
        Microseconds, Milliseconds, Seconds);

    DeltaTime = *((_int64 *) &ftEnd) - *((_int64 *) &ftStart);
    Microseconds = (int) (DeltaTime / 10);
    Milliseconds = (int) (DeltaTime / 10000);
    Seconds = (int) (DeltaTime / 10000000);
    printf("Total Micro: %d Milli: %d Seconds: %d\n",
        Microseconds, Milliseconds, Seconds);

    DeltaTime = DeltaTime / dwIterations;
    Microseconds = (int) (DeltaTime / 10);
    Milliseconds = (int) (DeltaTime / 10000);
    Seconds = (int) (DeltaTime / 10000000);
    printf("Average Micro: %d Milli: %d Seconds: %d\n",
        Microseconds, Milliseconds, Seconds);

    


    status = 0;
CommonReturn:
    CertFreeCertificateContext(pCert);
    CertFreeCertificateContext(pIssuer);
    CertFreeCTLContext(pCtl);
    CertFreeCRLContext(pCrl);
    CryptMsgClose(hMsg);
    TestFree(pbEncodedCert);
    TestFree(pbEncoded);

    CertFreeCertificateContext(wvtCertInfo.psCertContext);
    TestFree((LPWSTR) wvtFileInfo.pcwszFilePath);
    if (hAdditionalStore) {
        if (!CertCloseStore(hAdditionalStore, CERT_CLOSE_STORE_CHECK_FLAG))
            PrintLastError("CertCloseStore(AdditionalStore)");
    }

    if (pChainContext)
        CertFreeCertificateChain(pChainContext);

    TestFree(const_cast<LPWSTR>(wvtCat.pcwszCatalogFilePath));
    TestFree(const_cast<LPWSTR>(wvtCat.pcwszMemberFilePath));
    if (!(NULL == wvtCat.hMemberFile ||
            INVALID_HANDLE_VALUE == wvtCat.hMemberFile))
        CloseHandle(wvtCat.hMemberFile);

    if (fPause) {
        int c;
        fputs("Waiting to exit ->", stdout);
        fflush(stdin);
        fflush(stdout);
        c = getchar();
    }

    return status;

ErrorReturn:
    status = -1;
    goto CommonReturn;

BadUsage:
    Usage();
    status = -1;
    goto CommonReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tcopycer\tcopycer.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tcopycer.cpp
//
//  Contents:   Cert Store Copy Cert/CRL/CTL context API Tests
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    11-Apr-96   philh   created
//				07-Jun-96   HelleS	Added printing the command line
//									and Failed or Passed at the end.
//              20-Aug-96   jeffspel name changes
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


static void Usage(void)
{
    printf("Usage: tcopycer [options] <Src StoreName> <Dst StoreName>\n");
    printf("Options are:\n");
    printf("  -h                - This message\n");
    printf("  -s                - Dst \"StoreName\" System store\n");
    printf("  -7                - PKCS# 7 save for Dst if filename\n");
    printf("  -S                - Src \"StoreName\" System store\n");
    printf("  -R                - Replace certs that exist\n");
    printf("  -I                - Replace certs with property inheritance\n");
    printf("  -A                - Always add a new cert\n");
    printf("  -b<number>        - Add Base CRL having specified number\n");
    printf("  -f<number>        - Add Freshest CRL having specified number\n");
    printf("  -a[<ValueString>] - Only certs matching name attribute value\n");
    printf("\n");
    printf("-b and/or -f only copy the CRL having the specified number\n");
    printf("-b and/or -f delete all CRLs unless -A is also specified\n");
    printf("\n");
}

static void DisplayFindAttr(DWORD cRDNAttr, CERT_RDN_ATTR rgRDNAttr[])
{
    DWORD i;

    for (i = 0; i < cRDNAttr; i++) {
        LPSTR pszObjId = rgRDNAttr[i].pszObjId;
        LPSTR pszValue = (LPSTR) rgRDNAttr[i].Value.pbData;
        printf("  [%d] ", i);
        if (pszObjId)
            printf("%s ", pszObjId);
        if (rgRDNAttr[i].dwValueType)
            printf("ValueType: %d ", rgRDNAttr[i].dwValueType);
        if (pszValue == NULL)
            pszValue = "<NONE>";
        printf("Value: %s\n", pszValue);
    }
}

int _cdecl main(int argc, char * argv[])
{
    int ReturnStatus = 0;
    BOOL fSrcSystemStore = FALSE;
    BOOL fDstSystemStore = FALSE;
    LPSTR pszSrcStoreFilename = NULL;
    LPSTR pszDstStoreFilename = NULL;

    BOOL fPKCS7Save = FALSE;
    DWORD dwAddDisposition = CERT_STORE_ADD_USE_EXISTING;

    HANDLE hSrcStore = NULL;
    HANDLE hDstStore = NULL;

#define MAX_RDN_ATTR 20
    DWORD cRDNAttr = 0;
    CERT_RDN_ATTR rgRDNAttr[MAX_RDN_ATTR + 1];
    memset (rgRDNAttr, 0, sizeof(rgRDNAttr));
    CERT_RDN NameRDN;

    BOOL fBaseOrFreshestCrl = FALSE;
    int iBaseCrl = -1;
    int iFreshestCrl = -1;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 's':
                fDstSystemStore = TRUE;
                break;
            case '7':
                fPKCS7Save = TRUE;
                break;
            case 'S':
                fSrcSystemStore = TRUE;
                break;
            case 'R':
                dwAddDisposition = CERT_STORE_ADD_REPLACE_EXISTING;
                break;
            case 'A':
                dwAddDisposition = CERT_STORE_ADD_ALWAYS;
                break;
            case 'I':
                dwAddDisposition =
                    CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES;
                break;
            case 'a':
                if (cRDNAttr >= MAX_RDN_ATTR) {
                    printf("Maximum number of attributes: %d\n", MAX_RDN_ATTR);
                    Usage();
                    return -1;
                }
                rgRDNAttr[cRDNAttr].Value.cbData = strlen(argv[0] + 2);
                if (rgRDNAttr[cRDNAttr].Value.cbData == 0)
                    rgRDNAttr[cRDNAttr].Value.pbData = NULL;
                else
                    rgRDNAttr[cRDNAttr].Value.pbData = (BYTE *) (argv[0] + 2);
                cRDNAttr++;
                break;
            case 'b':
                iBaseCrl = atoi(argv[0]+2);
                fBaseOrFreshestCrl = TRUE;
                break;
            case 'f':
                iFreshestCrl = atoi(argv[0]+2);
                fBaseOrFreshestCrl = TRUE;
                break;
            case 'h':
            default:
            	goto BadUsage;

            }
        } else {
            if (pszSrcStoreFilename == NULL)
                pszSrcStoreFilename = argv[0];
            else if (pszDstStoreFilename == NULL)
                pszDstStoreFilename = argv[0];
            else {
                printf("too many store filenames\n");
            	goto BadUsage;
            }
        }
    }


    if (pszDstStoreFilename == NULL) {
        printf("missing store filename\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    // Attempt to open the source and destination stores
    hSrcStore = OpenStore(fSrcSystemStore, pszSrcStoreFilename);
    if (hSrcStore == NULL)
        goto ErrorReturn;
    hDstStore = OpenStore(fDstSystemStore, pszDstStoreFilename);
    if (hDstStore == NULL) {
        if (!CertCloseStore(hSrcStore, 0))
            PrintLastError("CertCloseStore");
        goto ErrorReturn;
    }

    if (cRDNAttr) {
        printf("Copy certs matching attribute values::\n");
        DisplayFindAttr(cRDNAttr, rgRDNAttr);
        NameRDN.cRDNAttr = cRDNAttr;
        NameRDN.rgRDNAttr = rgRDNAttr;
    }

    if (!fBaseOrFreshestCrl)
    {
        DWORD dwCopyCnt = 0;
        PCCERT_CONTEXT pCert = NULL;
        int i = 0;

        while (TRUE) {
            BOOL fResult;

            if (cRDNAttr) {
                pCert = CertFindCertificateInStore(
                    hSrcStore,
                    dwCertEncodingType,
                    0,                          // dwFindFlags,
                    CERT_FIND_SUBJECT_ATTR,
                    &NameRDN,
                    pCert
                    );
                if (pCert) {
                    printf("=====  Copy Cert %d  =====\n", i++);
                    DisplayCert(pCert, DISPLAY_BRIEF_FLAG);
                }
            } else
                pCert = CertEnumCertificatesInStore(
                    hSrcStore,
                    pCert
                    );
            if (pCert == NULL)
                break;
            if (!(fResult = CertAddCertificateContextToStore(
                    hDstStore,
                    pCert,
                    CERT_STORE_ADD_NEW,
                    NULL))) {
                if (GetLastError() == CRYPT_E_EXISTS) {
                    printf("Cert %d already exists in store\n", dwCopyCnt);

                    DWORD dwNewer;

                    if (dwAddDisposition == CERT_STORE_ADD_REPLACE_EXISTING)
                        dwNewer = CERT_STORE_ADD_NEWER;
                    else if (dwAddDisposition ==
                            CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES)
                        dwNewer = CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES;
                    else
                        dwNewer = 0;

                    fResult = FALSE;
                    if (dwNewer) {
                        fResult = CertAddCertificateContextToStore(
                            hDstStore,
                            pCert,
                            dwNewer,
                            NULL);
                        if (fResult)
                            printf("Added newer cert\n");
                        else {
                            DWORD dwErr = GetLastError();
                            if (dwErr == CRYPT_E_EXISTS)
                                printf("Didn't add older cert\n");
                            else
                                PrintLastError("Cert: CERT_ADD_NEWER");
                        }
                    }


                    if (!fResult)
                        fResult = CertAddCertificateContextToStore(
                            hDstStore,
                            pCert,
                            dwAddDisposition,
                            NULL);
                }
            }
            if (!fResult) {
                PrintLastError("CertAddCertificateContextToStore");
                ReturnStatus = -1;
                CertFreeCertificateContext(pCert);
                break;
            } else {
                dwCopyCnt++;

            }

        }
        printf("Copied %d certificates\n", dwCopyCnt);

    }

    if (fBaseOrFreshestCrl) {
        DWORD fCopyCrl = FALSE;
        PCCRL_CONTEXT pCrl;

        if (dwAddDisposition != CERT_STORE_ADD_ALWAYS) {
            // Delete all existing CRLs from the destination store

            pCrl = NULL;
            while (pCrl = CertEnumCRLsInStore(hDstStore, pCrl)) {
                PCCRL_CONTEXT pDeleteCrl = CertDuplicateCRLContext(pCrl);
                if (!CertDeleteCRLFromStore(pDeleteCrl))
                    PrintLastError("CertDeleteCRLFromStore");
            }
        }

        pCrl = NULL;
        while (pCrl = CertEnumCRLsInStore(hSrcStore, pCrl)) {
            PCERT_EXTENSION pDeltaExt;
            PCERT_EXTENSION pBaseExt;
            DWORD cbInt;
            int iNum;

            pDeltaExt = CertFindExtension(
                szOID_DELTA_CRL_INDICATOR,
                pCrl->pCrlInfo->cExtension,
                pCrl->pCrlInfo->rgExtension
                );
            pBaseExt = CertFindExtension(
                szOID_CRL_NUMBER,
                pCrl->pCrlInfo->cExtension,
                pCrl->pCrlInfo->rgExtension
                );
            if (pDeltaExt) {
                // Freshest, delta CRL
                if (0 <= iFreshestCrl) {
                    cbInt = sizeof(iNum);
                    if (!CryptDecodeObject(
                            pCrl->dwCertEncodingType,
                            X509_INTEGER,
                            pDeltaExt->Value.pbData,
                            pDeltaExt->Value.cbData,
                            0,                      // dwFlags
                            &iNum,
                            &cbInt
                            ))
                        PrintLastError("CryptDecodeObject(DeltaCrlNumber)");
                    else if (iFreshestCrl == iNum) {
                        if (CertAddCRLContextToStore(
                                hDstStore,
                                pCrl,
                                CERT_STORE_ADD_ALWAYS,
                                NULL
                                )) {
                            printf("Added freshest CRL %d\n", iNum);
                            fCopyCrl = TRUE;
                        } else
                            PrintLastError("CertAddCRLContextToStore(Freshest)");
                    }
                }
            } else if (pBaseExt) {
                // Base CRL
                if (0 <= iBaseCrl) {
                    cbInt = sizeof(iNum);
                    if (!CryptDecodeObject(
                            pCrl->dwCertEncodingType,
                            X509_INTEGER,
                            pBaseExt->Value.pbData,
                            pBaseExt->Value.cbData,
                            0,                      // dwFlags
                            &iNum,
                            &cbInt
                            ))
                        PrintLastError("CryptDecodeObject(BaseCrlNumber)");
                    else if (iBaseCrl == iNum) {
                        if (CertAddCRLContextToStore(
                                hDstStore,
                                pCrl,
                                CERT_STORE_ADD_ALWAYS,
                                NULL
                                )) {
                            printf("Added base CRL %d\n", iNum);
                            fCopyCrl = TRUE;
                        } else
                            PrintLastError("CertAddCRLContextToStore(Base)");
                    }
                }
            }
        }

        if (!fCopyCrl)
            printf("failed => no base or freshest, delta CRLs copied\n");

    } else if (cRDNAttr == 0) {
        DWORD dwCopyCnt;
        PCCRL_CONTEXT pCrl = NULL;
        PCCTL_CONTEXT pCtl = NULL;
        DWORD dwFlags;

        dwCopyCnt = 0;
        while (TRUE) {
            BOOL fResult;

            dwFlags = 0;
            pCrl = CertGetCRLFromStore(
                hSrcStore,
                NULL,   // pIssuerContext
                pCrl,
                &dwFlags);
            if (pCrl == NULL)
                break;
            if (!(fResult = CertAddCRLContextToStore(
                    hDstStore,
                    pCrl,
                    CERT_STORE_ADD_NEW,
                    NULL))) {
                if (GetLastError() == CRYPT_E_EXISTS) {
                    printf("CRL %d already exists in store\n", dwCopyCnt);

                    DWORD dwNewer;

                    if (dwAddDisposition == CERT_STORE_ADD_REPLACE_EXISTING)
                        dwNewer = CERT_STORE_ADD_NEWER;
                    else if (dwAddDisposition ==
                            CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES)
                        dwNewer = CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES;
                    else
                        dwNewer = 0;

                    fResult = FALSE;
                    if (dwNewer) {
                        fResult = CertAddCRLContextToStore(
                            hDstStore,
                            pCrl,
                            dwNewer,
                            NULL);
                        if (fResult)
                            printf("Added newer CRL\n");
                        else {
                            DWORD dwErr = GetLastError();
                            if (dwErr == CRYPT_E_EXISTS)
                                printf("Didn't add older CRL\n");
                            else
                                PrintLastError("CRL: CERT_ADD_NEWER");
                        }
                    }

                    if (!fResult)
                        fResult = CertAddCRLContextToStore(
                            hDstStore,
                            pCrl,
                            dwAddDisposition,
                            NULL);
                }
            }
            if (!fResult) {
                PrintLastError("CertAddCRLContextToStore");
                ReturnStatus = -1;
                CertFreeCRLContext(pCrl);
                break;
            } else
                dwCopyCnt++;

        }
        printf("Copied %d CRLs\n", dwCopyCnt);

        dwCopyCnt = 0;
        while (TRUE) {
            BOOL fResult;

            dwFlags = 0;
            pCtl = CertEnumCTLsInStore(
                hSrcStore,
                pCtl
                );
            if (pCtl == NULL)
                break;
            if (!(fResult = CertAddCTLContextToStore(
                    hDstStore,
                    pCtl,
                    CERT_STORE_ADD_NEW,
                    NULL))) {
                if (GetLastError() == CRYPT_E_EXISTS) {
                    printf("CTL %d already exists in store\n", dwCopyCnt);

                    DWORD dwNewer;

                    if (dwAddDisposition == CERT_STORE_ADD_REPLACE_EXISTING)
                        dwNewer = CERT_STORE_ADD_NEWER;
                    else if (dwAddDisposition ==
                            CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES)
                        dwNewer = CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES;
                    else
                        dwNewer = 0;

                    fResult = FALSE;
                    if (dwNewer) {
                        fResult = CertAddCTLContextToStore(
                            hDstStore,
                            pCtl,
                            dwNewer,
                            NULL);
                        if (fResult)
                            printf("Added newer CTL\n");
                        else {
                            DWORD dwErr = GetLastError();
                            if (dwErr == CRYPT_E_EXISTS)
                                printf("Didn't add older CTL\n");
                            else
                                PrintLastError("CTL: CERT_ADD_NEWER");
                        }
                    }

                    if (!fResult)
                        fResult = CertAddCTLContextToStore(
                            hDstStore,
                            pCtl,
                            dwAddDisposition,
                            NULL);
                }
            }
            if (!fResult) {
                PrintLastError("CertAddCTLContextToStore");
                ReturnStatus = -1;
                CertFreeCTLContext(pCtl);
                break;
            } else
                dwCopyCnt++;

        }
        printf("Copied %d CTLs\n", dwCopyCnt);

    }

    if (!fDstSystemStore)
        SaveStoreEx(hDstStore, fPKCS7Save, pszDstStoreFilename);

    if (!CertCloseStore(hSrcStore, 0))
    {
        PrintLastError("CertCloseStore(hSrcStore)");
        ReturnStatus = -1;
	}
    if (!CertCloseStore(hDstStore, 0))
    {
    
        PrintLastError("CertCloseStore(hDstStore)");
        ReturnStatus = -1;
	}
	if (-1 == ReturnStatus)
		goto ErrorReturn;
    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
CommonReturn:
    if (!ReturnStatus)
            printf("Passed\n");
    else
            printf("Failed\n");
    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tchain\tchain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tchain.cpp
//
//  Contents:   Chain threading tests
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    28-Mar-00   philh   created
//--------------------------------------------------------------------------

#define CERT_CHAIN_PARA_HAS_EXTRA_FIELDS    1

#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


#define CTRL_THR_CNT                3
#define RESYNC_THR_IDX              0
#define DELETE_THR_IDX              1
#define REPLACE_THR_IDX             2

HANDLE rghCtrlThread[CTRL_THR_CNT];
DWORD rgdwCtrlIterations[CTRL_THR_CNT];
DWORD rgdwCtrlSleepMilliSeconds[CTRL_THR_CNT];

#define MAX_CHAIN_THR_CNT           16
HANDLE rghChainThread[MAX_CHAIN_THR_CNT];
DWORD rgdwChainIterations[MAX_CHAIN_THR_CNT];

LONG lIterations = -1;
BOOL fCreateEndCert = FALSE;

HCERTSTORE hStore = NULL;
HCERTSTORE hCaStore = NULL;
HCERTSTORE hAdditionalChainStore = NULL;
PCCERT_CONTEXT pReplaceCertContext = NULL;
PCCERT_CONTEXT pDeleteCertContext = NULL;
HCERTCHAINENGINE hChainEngine = NULL;

#define MAX_USAGE_CNT               16
LPSTR rgpszUsageOID[MAX_USAGE_CNT];
DWORD cUsageOID = 0;
CERT_CHAIN_PARA ChainPara;

DWORD dwChainFlags = 0;
BOOL fDone = FALSE;


static void Usage(void)
{
    printf("Usage: tchain [options] <StoreName>\n");
    printf("\n");
    printf("  -CreateEndCert    - Create new end cert for each chain\n");
    printf("  -LocalMachine     - Defaults to CurrentUser\n");
    printf("  -Pause\n");
    printf("\n");
    printf("Options are:\n");
    printf("  -u<OID String>    - Usage OID string -u1.3.6.1.5.5.7.3.3\n");
    printf("  -t<number>        - Threads (defaults to 4)\n");
    printf("  -i<number>        - Iterations (defaults to -1, infinite)\n");
    printf("  -l<number>        - Lru cache count, enable end cert caching\n");
    printf("  -f<Number>        - Chain Flags\n");
    printf("  -T<number>        - Url Timeout (milliseconds)\n");
    printf("  -F<number>        - Revocation Freshness (seconds)\n");
    printf("  -r[<number>]      - Resync engine, defaults to 2K millisecs\n");
    printf("  -d[<num>] <cert>  - Delete cert from CA store\n");
    printf("  -R[<num>] <cert>  - Replace cert in CA store\n");
    printf("  -s                - Open the \"StoreName\" System store\n");
    printf("  -a<filename>      - Additional chain store filename\n");
    printf("  -A<filename>      - Additional engine store filename\n");
    printf("  -h                - This message\n");
    printf("\n");
}


DWORD WINAPI ChainThreadProc(
    LPVOID lpThreadParameter
    )
{
    DWORD dwThrIdx = (DWORD) ((DWORD_PTR) lpThreadParameter);

    if (dwThrIdx >= MAX_CHAIN_THR_CNT) {
        printf("Invalid dwThrIdx\n");
        return 0;
    }

    while (TRUE) {
        PCCERT_CONTEXT pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
            PCCERT_CONTEXT pCreateCert = NULL;
            PCCERT_CHAIN_CONTEXT pChainContext = NULL;

            if (fCreateEndCert) {
                pCreateCert = CertCreateCertificateContext(
                    pCert->dwCertEncodingType,
                    pCert->pbCertEncoded,
                    pCert->cbCertEncoded
                    );
                if (NULL == pCreateCert) {
                    PrintLastError("CertCreateCertificateContext");
                    return 0;
                }
            }


            if (!CertGetCertificateChain(
                    hChainEngine,
                    fCreateEndCert ? pCreateCert : pCert,
                    NULL,                                   // pTime
                    hAdditionalChainStore,
                    &ChainPara,
                    dwChainFlags,
                    NULL,                                   // pvReserved
                    &pChainContext
                    )) {
                PrintLastError("CertGetCertificateChain");
                return 0;
            }

            CertFreeCertificateChain(pChainContext);
            if (pCreateCert)
                CertFreeCertificateContext(pCreateCert);
        }

        rgdwChainIterations[dwThrIdx]++;
        if (lIterations > 0 &&
                rgdwChainIterations[dwThrIdx] >= (DWORD) lIterations)
            break;
    }

    return 0;
}

DWORD WINAPI ResyncThreadProc(
    LPVOID lpThreadParameter
    )
{
    while (TRUE) {
        if (fDone)
            break;

        if (!CertResyncCertificateChainEngine(hChainEngine)) {
            PrintLastError("CertResyncCertificateChainEngine");
            return 0;
        }

        rgdwCtrlIterations[RESYNC_THR_IDX]++;
        Sleep(rgdwCtrlSleepMilliSeconds[RESYNC_THR_IDX]);
    }

    return 0;
}

DWORD WINAPI DeleteThreadProc(
    LPVOID lpThreadParameter
    )
{
    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_HASH_BLOB HashBlob;

    HashBlob.cbData = MAX_HASH_LEN;
    HashBlob.pbData = rgbHash;

    if (!CertGetCertificateContextProperty(
            pDeleteCertContext,
            CERT_MD5_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            )) {
        PrintLastError("CertGetCertificateContextProperty");
        return 0;
    }

    while (TRUE) {
        PCCERT_CONTEXT pFound = NULL;

        if (fDone)
            break;

        pFound = CertFindCertificateInStore(
            hCaStore,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            0,
            CERT_FIND_MD5_HASH,
            &HashBlob,
            NULL
            );

        if (pFound) {
            CertDeleteCertificateFromStore(pFound);
            rgdwCtrlIterations[DELETE_THR_IDX]++;
        }

        Sleep(rgdwCtrlSleepMilliSeconds[DELETE_THR_IDX]);
    }

    return 0;
}

DWORD WINAPI ReplaceThreadProc(
    LPVOID lpThreadParameter
    )
{
    while (TRUE) {
        if (fDone)
            break;

        if (!CertAddCertificateContextToStore(
                hCaStore,
                pReplaceCertContext,
                CERT_STORE_ADD_REPLACE_EXISTING,
                NULL                                // ppStoreContext
                )) {
            PrintLastError("CertAddCertificateContextToStore");
            return 0;
        }

        rgdwCtrlIterations[REPLACE_THR_IDX]++;
        Sleep(rgdwCtrlSleepMilliSeconds[REPLACE_THR_IDX]);
    }

    return 0;
}



PCCERT_CONTEXT ReadCert(
    IN LPSTR pszCert
    )
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    PCCERT_CONTEXT pCert;

    if (!ReadDERFromFile(pszCert, &pbEncoded, &cbEncoded)) {
        PrintLastError("ReadCert");
        return NULL;
    }

    pCert = CertCreateCertificateContext(
        dwCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    if (pCert == NULL)
        PrintLastError("CertCreateCertificateContext");

    TestFree(pbEncoded);
    return pCert;
}

int _cdecl main(int argc, char * argv[]) 
{
    int status;

    LPSTR pszAdditionalChainStore = NULL;
    LPSTR pszAdditionalEngineStore = NULL;
    BOOL fResync = FALSE;
    DWORD dwLruCnt = 0;
    LPSTR pszDeleteCert = NULL;
    LPSTR pszReplaceCert = NULL;
    BOOL fSystemStore = FALSE;
    LPSTR pszStoreFilename = NULL;
    BOOL fPause = FALSE;
    DWORD dwThrCnt = 4;

    HCERTSTORE hAdditionalEngineStore = NULL;

    DWORD dwThreadId;
    DWORD dwIterations;
    DWORD i;

    for (i = 0; i < CTRL_THR_CNT; i ++)
        rgdwCtrlSleepMilliSeconds[i] = 2000;    // 2 second

    // Initialize the chain parameters
    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

    while (--argc>0) {
        if (**++argv == '-')
        {
            if (0 == _stricmp(argv[0]+1, "CreateEndCert")) {
                fCreateEndCert = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "LocalMachine")) {
                hChainEngine = HCCE_LOCAL_MACHINE;
            } else if (0 == _stricmp(argv[0]+1, "Pause")) {
                fPause = TRUE;

            } else {
                switch(argv[0][1])
                {
                case 'u':
                    if (MAX_USAGE_CNT <= cUsageOID) {
                        printf("Too many usages\n");
                        goto BadUsage;
                    }

                    rgpszUsageOID[cUsageOID++] = argv[0]+2;
                    break;
                case 'i':
                    lIterations = strtol(argv[0]+2, NULL, 0);
                    break;
                case 't':
                    dwThrCnt = (DWORD) strtoul(argv[0]+2, NULL, 0);
                    if (dwThrCnt > MAX_CHAIN_THR_CNT) {
                        printf("exceeded max thread count of %d\n",
                            MAX_CHAIN_THR_CNT);
                        goto BadUsage;
                    }
                    break;
                case 'l':
                    dwLruCnt = (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'r':
                    fResync = TRUE;
                    if (argv[0][2]) {
                        rgdwCtrlSleepMilliSeconds[RESYNC_THR_IDX] =
                            (DWORD) strtoul(argv[0]+2, NULL, 0);
                    }
                    break;
                case 'd':
                    if (argv[0][2]) {
                        rgdwCtrlSleepMilliSeconds[DELETE_THR_IDX] =
                            (DWORD) strtoul(argv[0]+2, NULL, 0);
                    }

                    ++argv;
                    if (--argc <= 0 || argv[0][0] == '-') {
                        printf("Missing Delete cert\n");
                        goto BadUsage;
                    }
                    pszDeleteCert = argv[0];
                    break;
                case 'R':
                    if (argv[0][2]) {
                        rgdwCtrlSleepMilliSeconds[REPLACE_THR_IDX] =
                            (DWORD) strtoul(argv[0]+2, NULL, 0);
                    }

                    ++argv;
                    if (--argc <= 0 || argv[0][0] == '-') {
                        printf("Missing Replace cert\n");
                        goto BadUsage;
                    }
                    pszReplaceCert = argv[0];
                    break;
                case 'f':
                    dwChainFlags = (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 's':
                    fSystemStore = TRUE;
                    break;
                case 'a':
                    pszAdditionalChainStore = argv[0]+2;
                    if (*pszAdditionalChainStore == '\0') {
                        printf("Need to specify filename\n");
                        goto BadUsage;
                    }
                    break;
                case 'A':
                    pszAdditionalEngineStore = argv[0]+2;
                    if (*pszAdditionalEngineStore == '\0') {
                        printf("Need to specify filename\n");
                        goto BadUsage;
                    }
                    break;
                case 'T':
                    ChainPara.dwUrlRetrievalTimeout =
                        (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'F':
                    ChainPara.fCheckRevocationFreshnessTime = TRUE;
                    ChainPara.dwRevocationFreshnessTime =
                        (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'h':
                default:
                    goto BadUsage;
                }
            }
        } else {
            if (pszStoreFilename) {
                printf("Multiple StoreNames\n");
                goto BadUsage;
            }
            pszStoreFilename = argv[0];
        }
    }


    printf("command line: %s\n", GetCommandLine());

    if (pszStoreFilename == NULL) {
        printf("missing store filename\n");
        goto BadUsage;
    }

    // Attempt to open the store
    printf("Store :: %s\n", pszStoreFilename);
    hStore = OpenSystemStoreOrFile(fSystemStore, pszStoreFilename, 0);
    if (hStore == NULL) {
        printf("failed to open the store\n");
        goto ErrorReturn;
    }

    // Attempt to open the 'CA' store
    hCaStore = OpenSystemStoreOrFile(TRUE, "Ca", 0);
    if (hCaStore == NULL) {
        printf("failed to open the CA store\n");
        goto ErrorReturn;
    }

    if (!CertControlStore(
            hCaStore,
            0,              // dwFlags
            CERT_STORE_CTRL_AUTO_RESYNC,
            NULL            // pvCtrlPara
            )) {
        PrintLastError("CertControlStore(AUTO_RESYNC)");
        goto ErrorReturn;
    }

    if (pszAdditionalChainStore) {
        printf("AdditionalChainStore :: %s\n", pszAdditionalChainStore);
        hAdditionalChainStore =
            OpenSystemStoreOrFile(FALSE, pszAdditionalChainStore, 0);
        if (hAdditionalChainStore == NULL) {
            printf("failed to open the AdditionalChainStore\n");
            goto ErrorReturn;
        }
    }

    if (pszAdditionalEngineStore) {
        printf("AdditionalEngineStore :: %s\n", pszAdditionalEngineStore);
        hAdditionalEngineStore =
            OpenSystemStoreOrFile(FALSE, pszAdditionalEngineStore, 0);
        if (hAdditionalEngineStore == NULL) {
            printf("failed to open the AdditionalEngineStore\n");
            goto ErrorReturn;
        }
    }

    if (fResync) {
        printf("Resync :: Sleep: %d (milliseconds)\n",
            rgdwCtrlSleepMilliSeconds[RESYNC_THR_IDX]);
    }

    if (pszDeleteCert) {
        printf("Delete :: Sleep: %d (milliseconds) Cert: %s\n",
            rgdwCtrlSleepMilliSeconds[DELETE_THR_IDX],
            pszDeleteCert);
        pDeleteCertContext = ReadCert(pszDeleteCert);
        if (NULL == pDeleteCertContext) {
            printf("failed to read the DeleteCert\n");
            goto ErrorReturn;
        }
    }

    if (pszReplaceCert) {
        printf("Replace :: Sleep: %d (milliseconds) Cert: %s\n",
            rgdwCtrlSleepMilliSeconds[REPLACE_THR_IDX],
            pszReplaceCert);
        pReplaceCertContext = ReadCert(pszReplaceCert);
        if (NULL == pReplaceCertContext) {
            printf("failed to read the ReplaceCert\n");
            goto ErrorReturn;
        }
    }

    // Determine if we need to create our own engine

    if (dwLruCnt != 0 || hAdditionalEngineStore != NULL) {
        CERT_CHAIN_ENGINE_CONFIG ChainEngineConfig;

        printf("Create chain engine ::");
        if (hAdditionalEngineStore)
            printf(" AdditionalStore : %s", pszAdditionalEngineStore);
        if (dwLruCnt != 0)
            printf(" Lru Count : %d", dwLruCnt);
        printf("\n");

        memset(&ChainEngineConfig, 0, sizeof(ChainEngineConfig));
        ChainEngineConfig.cbSize = sizeof(ChainEngineConfig);
        if (hAdditionalEngineStore) {
            ChainEngineConfig.cAdditionalStore = 1;
            ChainEngineConfig.rghAdditionalStore = &hAdditionalEngineStore;
        }

        ChainEngineConfig.dwFlags =
            CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE |
            CERT_CHAIN_ENABLE_SHARE_STORE;

        if (dwLruCnt != 0) {
            ChainEngineConfig.MaximumCachedCertificates = dwLruCnt;
            ChainEngineConfig.dwFlags |= CERT_CHAIN_CACHE_END_CERT;
        }

        if (!CertCreateCertificateChainEngine(
                &ChainEngineConfig, &hChainEngine)) {
            PrintLastError("CertCreateCertificateChainEngine");
            goto ErrorReturn;
        }
    } else if (HCCE_LOCAL_MACHINE == hChainEngine) {
        printf("Using LocalMachine chain engine\n");
    }


    // Update the chain usage parameters
    ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainPara.RequestedUsage.Usage.cUsageIdentifier = cUsageOID;
    ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier =
        rgpszUsageOID;

    for (i = 0; i < cUsageOID; i++) {
        printf("Usage[%d] : %s\n", i, rgpszUsageOID[i]);
    }

    if (0 >= lIterations) {
        lIterations = -1;
        printf("Infinite iterations\n");
    } else
        printf("%d iterations\n", lIterations);

    if (fPause) {
        int c;
        fputs("Waiting to start ->", stdout);
        fflush(stdin);
        fflush(stdout);
        c = getchar();
    }


    // Create the control threads
    if (fResync) {
        if (NULL == (rghCtrlThread[RESYNC_THR_IDX] = CreateThread(
                NULL,           // lpThreadAttributes
                0,              // dwStackSize
                ResyncThreadProc,
                NULL,           // lpParameters
                0,              // dwCreationFlags
                &dwThreadId
                ))) {
            PrintLastError("CreateThread(Resync)");
        }
    }

    if (pDeleteCertContext) {
        if (NULL == (rghCtrlThread[DELETE_THR_IDX] = CreateThread(
                NULL,           // lpThreadAttributes
                0,              // dwStackSize
                DeleteThreadProc,
                NULL,           // lpParameters
                0,              // dwCreationFlags
                &dwThreadId
                ))) {
            PrintLastError("CreateThread(Delete)");
        }
    }

    if (pReplaceCertContext) {
        if (NULL == (rghCtrlThread[REPLACE_THR_IDX] = CreateThread(
                NULL,           // lpThreadAttributes
                0,              // dwStackSize
                ReplaceThreadProc,
                NULL,           // lpParameters
                0,              // dwCreationFlags
                &dwThreadId
                ))) {
            PrintLastError("CreateThread(Replace)");
        }
    }

    // Create the chain threads
    for (i = 0; i < dwThrCnt; i++) {
        if (NULL == (rghChainThread[i] = CreateThread(
                NULL,           // lpThreadAttributes
                0,              // dwStackSize
                ChainThreadProc,
                (LPVOID) ((DWORD_PTR) i),  // lpParameters
                0,              // dwCreationFlags
                &dwThreadId
                ))) {
            PrintLastError("CreateThread(Chain)");
            dwThrCnt = i;
            break;
        }
    }

    dwIterations = 0;
    while(TRUE) {
        dwIterations++;

        printf("%d - ", dwIterations);

        for (i = 0; i < dwThrCnt; i++)
            printf("%d ", rgdwChainIterations[i]);

        if (rghCtrlThread[RESYNC_THR_IDX])
            printf("r:%d ", rgdwCtrlIterations[RESYNC_THR_IDX]);
        if (rghCtrlThread[DELETE_THR_IDX])
            printf("d:%d ", rgdwCtrlIterations[DELETE_THR_IDX]);
        if (rghCtrlThread[REPLACE_THR_IDX])
            printf("R:%d ", rgdwCtrlIterations[REPLACE_THR_IDX]);

        printf("\n");

        if (0 == dwThrCnt)
            break;

        // Check if all the chain threads have completed
        if (WAIT_OBJECT_0 == WaitForMultipleObjects(
                dwThrCnt,
                rghChainThread,
                TRUE,               // bWaitAll
                0                   // dwMilliseconds
                ))
            break;

        if (dwThrCnt <= 5)
            Sleep(1000);
        else
            Sleep(5000);
    }

    // Signal the control threads to exit
    fDone = TRUE;

    // Close all the chain thread handles
    for (i = 0; i < dwThrCnt; i++)
        CloseHandle(rghChainThread[i]);

    // Wait for the control threads to exit
    for (i = 0; i < CTRL_THR_CNT; i++) {
        if (rghCtrlThread[i]) {
            WaitForSingleObject(rghCtrlThread[i], INFINITE);
            CloseHandle(rghCtrlThread[i]);
        }
    }


    status = 0;
CommonReturn:
    // This does a flush for CurrentUser or LocalMachine
    CertFreeCertificateChainEngine(hChainEngine);

    if (pReplaceCertContext)
        CertFreeCertificateContext(pReplaceCertContext);
    if (pDeleteCertContext)
        CertFreeCertificateContext(pDeleteCertContext);
    if (hAdditionalChainStore)
        CertCloseStore(hAdditionalChainStore, 0);
    if (hAdditionalEngineStore)
        CertCloseStore(hAdditionalEngineStore, 0);

    if (hCaStore)
        CertCloseStore(hCaStore, 0);
    if (hStore)
        CertCloseStore(hStore, 0);

    if (fPause) {
        int c;
        fputs("Waiting to exit ->", stdout);
        fflush(stdin);
        fflush(stdout);
        c = getchar();
    }

    return status;

ErrorReturn:
    status = -1;
    goto CommonReturn;

BadUsage:
    Usage();
    status = -1;
    goto CommonReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tcrmsg\tcrmsg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       tcrmsg.cpp
//
//  Contents:   Cryptographic Message API Tests
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    26-Feb-96   philh   created
//
//--------------------------------------------------------------------------

#include "global.hxx"

#define SAVE_STREAM_FILES   1

#define MAX_HASH_LEN  20

#define ZEROSTRUCT(arg) (memset( &arg, 0, sizeof(arg)))

//+-------------------------------------------------------------------------
// Parameters, data used to encode the messages.
//--------------------------------------------------------------------------
HCRYPTPROV hCryptProv = 0;
DWORD dwProvType = PROV_RSA_FULL;

#ifdef CMS_PKCS7
HCRYPTPROV hMultiSignerCryptProv = 0;
DWORD dwMultiSignerProvType = PROV_RSA_FULL;
BOOL fMultiSigner = FALSE;
BOOL fHashEncryptionAlgorithm = FALSE;
BOOL fAlgorithmParameters = FALSE;
BOOL fNoSignature = FALSE;

BYTE rgbOctets[] = {4, 8, 1,2,3,4,5,6,7,8};
BYTE rgbInvalidAsn[] = {0xFF, 0xFF};
#endif  // CMS_PKCS7

LPSTR pszCertNameFindStr = NULL;
HCERTSTORE hSignerStore = NULL;
PCCERT_CONTEXT pNamedSigner = NULL;
HCRYPTPROV hNamedSignerCryptProv = 0;

LPSTR pszFilename = NULL;
BOOL fVerbose = FALSE;
BOOL fNoSigners = FALSE;
BOOL fAddSigner = FALSE;
BOOL fDetached = FALSE;
BOOL fAuthAttr = FALSE;
BOOL fInnerContent = FALSE;
BOOL fCountersign = FALSE;
BOOL fStream = FALSE;
BOOL fIndefinite = FALSE;
BOOL fBare = FALSE;
BOOL fMD5 = FALSE;
BOOL fNoRecipients = FALSE;
DWORD dwMsgEncodingType = PKCS_7_ASN_ENCODING;
DWORD dwCertEncodingType = X509_ASN_ENCODING;


LPCSTR pszContainer = NULL;
LPCSTR pszProvider = NULL;
BOOL fDefaultVerifyProv = FALSE;
HCRYPTPROV hDefaultVerifyProv = 0;
BOOL fEnhanced = FALSE;
LPCSTR pszEncryptName = "rc2";
LPCSTR pszEncryptOID = NULL;
DWORD dwEncryptBitLen = 0;
BOOL fEncryptIV = FALSE;

#ifdef CMS_PKCS7
BOOL fOriginatorInfo = FALSE;
#endif  // CMS_PKCS7

typedef struct _PUBLIC_KEY_DATA {
    BYTE    Data[1024];
} PUBLIC_KEY_DATA;

#define DEFAULT_MSG_CONTENT_SIZE 49
DWORD   cbMsgContent = DEFAULT_MSG_CONTENT_SIZE;
BYTE    rgbMsgContentFill[7] = {'C','o','n','t','e','n','t'};
#define cbMsgContentFill sizeof(rgbMsgContentFill)
DWORD   iMsgContentOffset = 0;
PBYTE   pbInnerContent = NULL;
DWORD   cbInnerContent;

// rsaEncryption
CRYPT_ALGORITHM_IDENTIFIER PublicKeyAlgorithm =
    {szOID_RSA_RSA, {0,0}};

// DES or RC4
CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm[] = {
    {szOID_OIWSEC_desCBC,   {0,0}},
    {szOID_RSA_RC4,         {0,0}},
    {szOID_RSA_RC2CBC,      {0,0}},
};
#define CONTENT_ALG_DES     0
#define CONTENT_ALG_RC4     1
#define CONTENT_ALG_RC2     2

// MD5 or SHA1
CRYPT_ALGORITHM_IDENTIFIER DigestAlgorithms[] = {
    {szOID_RSA_MD5,     {0,0}},
    {szOID_OIWSEC_sha1, {0,0}},
};
#define DIGEST_ALG_MD5      0
#define DIGEST_ALG_SHA      1

// MD5 or SHA
CRYPT_ALGORITHM_IDENTIFIER SignDigestAlgorithms[] = {
    {szOID_RSA_MD5,     {0,0}},
    {szOID_OIWSEC_sha1, {0,0}},
};
#define SIGNDIGEST_ALG_MD5  0
#define SIGNDIGEST_ALG_SHA  1

LPSTR pszSignerSerialNumberFileName = "name.der";
DWORD dwSignerSerialNumber  = 0x01010101;
DWORD dwSignerSerialNumber1 = 0x02020202;
DWORD dwSignerSerialNumber2 = 0x03030303;
PUBLIC_KEY_DATA SignerPublicKeyData;

#define SIGNED_CERT_COUNT   3
DWORD cSignedCert = 1;
LPCSTR rgpszSignedCertFileName[SIGNED_CERT_COUNT] = {
    "cert1.der",
    "cert2.der",
    "cert3.der"
};
CERT_BLOB rgSignedCertBlob[3];

#ifdef CMS_PKCS7
#define ATTR_CERT_COUNT   2
DWORD cAttrCert = 0;
BOOL fEncapsulatedContent = FALSE;

LPCSTR rgpszAttrCertFileName[ATTR_CERT_COUNT] = {
    "cert2.der",
    "cert3.der"
};
CERT_BLOB rgAttrCertBlob[ATTR_CERT_COUNT];
#endif  // CMS_PKCS7

#ifdef CMS_PKCS7
#define SIGNED_CRL_COUNT    1
DWORD cSignedCrl = 0;
LPCSTR rgpszSignedCrlFileName[SIGNED_CRL_COUNT] = {
    "crl1.der"
};
CRL_BLOB rgSignedCrlBlob[SIGNED_CRL_COUNT];
#else
#define SIGNED_CRL_COUNT    0
#endif

#define RECIPIENT_COUNT     2
DWORD PkcsRecipientCount = RECIPIENT_COUNT;
LPCSTR rgpszRecipientIssuerFileName[RECIPIENT_COUNT] = {
    "recip1.der",
    "recip2.der"
};
DWORD rgdwRecipientSerialNumber[RECIPIENT_COUNT] = {
    0x02020202,
    0x03030303
};
PUBLIC_KEY_DATA RecipientPublicKeyData;
CERT_INFO rgRecipientCertInfo[RECIPIENT_COUNT];
PCERT_INFO rgpRecipientCertInfo[RECIPIENT_COUNT];

#ifdef CMS_PKCS7
BOOL fRecipientProv = FALSE;
BOOL fKeyTrans = FALSE;
BOOL fKeyAgree = FALSE;
BOOL fMailList = FALSE;
BOOL fCmsRecipient = FALSE;
BOOL fRecipientKeyId = FALSE;
BOOL fCertInfoKeyId = FALSE;
BOOL fSignerId = FALSE;

BOOL fNoSalt = FALSE;
#define MAX_SALT_LEN    11
BYTE rgbSalt[MAX_SALT_LEN];
CMSG_RC4_AUX_INFO RC4AuxInfo;

CMSG_RECIPIENT_ENCODE_INFO rgCmsRecipient[RECIPIENT_COUNT * 4];
CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO rgKeyTrans[RECIPIENT_COUNT * 4];

HCRYPTPROV hKeyAgreeProv = 0;
PUBLIC_KEY_DATA KeyAgreePublicKeyData;
CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO rgKeyAgree[RECIPIENT_COUNT * 4];
CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO rgEncryptedKey[RECIPIENT_COUNT];
PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO rgpEncryptedKey[RECIPIENT_COUNT];
CMSG_RC2_AUX_INFO KeyAgreeRC2AuxInfo;

BYTE rgbKeyAgreeOtherAttr[] = {0x04, 3, 3, 2, 1};
CRYPT_ATTRIBUTE_TYPE_VALUE KeyAgreeOtherAttr = {
    "1.2.10.11.12",
    sizeof(rgbKeyAgreeOtherAttr), rgbKeyAgreeOtherAttr
};

LPCSTR pszUserKeyingMaterial = "UserKeyingMaterial";


CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO rgMailList[RECIPIENT_COUNT * 4];
CMSG_RC2_AUX_INFO MailListRC2AuxInfo;

BYTE rgbMailListOtherAttr[] = {0x04, 2, 1, 2};
CRYPT_ATTRIBUTE_TYPE_VALUE MailListOtherAttr = {
    "1.2.3.4.5.6.7.8.9",
    sizeof(rgbMailListOtherAttr), rgbMailListOtherAttr
};

DWORD cCmsRecipients = 0;
#endif  // CMS_PKCS7

#define AUTH_ATTR_COUNT     2
BYTE    attr1[] = {0x04, 0x0c, 'A','t','t','r','i','b','u','t','e',' ','1',0};
BYTE    attr2[] = {0x04, 0x0c, 'A','t','t','r','i','b','u','t','e',' ','2',0};
BYTE    attr3[] = {0x04, 0x0c, 'A','t','t','r','i','b','u','t','e',' ','3',0};
CRYPT_ATTR_BLOB rgatrblob1[] = {
    { sizeof( attr1), attr1}
};
CRYPT_ATTR_BLOB rgatrblob2[] = {
    { sizeof( attr2), attr2},
    { sizeof( attr3), attr3}
};
CRYPT_ATTRIBUTE rgAuthAttr[AUTH_ATTR_COUNT] = {
    {"1.2.3.5.7",  1, rgatrblob1},
    {"1.2.3.5.11", 2, rgatrblob2}
};

#define UNAUTH_ATTR_COUNT     1
BYTE    unattr1[] = {0x04, 0x0c, 'A','T','T','R','I','B','U','T','E',' ','1',0};
CRYPT_ATTR_BLOB rgunatrblob1[] = {
    { sizeof( unattr1), unattr1}
};
CRYPT_ATTRIBUTE rgUnauthAttr[UNAUTH_ATTR_COUNT] = {
    {"1.2.3.5.13.23",  1, rgunatrblob1},
};

LPSTR pszInnerContentObjId     = szOID_RSA_digestedData;
LPCSTR pszInnerContentFileName = "content.der";
//CRYPT_DER_BLOB    derInnerContent = {NULL,0};

CERT_INFO rgSignerCertInfo[2];
#ifdef CMS_PKCS7
CERT_ID rgSignerId[2];
#endif  // CMS_PKCS7
CMSG_SIGNER_ENCODE_INFO rgSignerEncodeInfo[2];
CMSG_SIGNED_ENCODE_INFO SignedMsgEncodeInfo;
CMSG_ENVELOPED_ENCODE_INFO EnvelopedMsgEncodeInfo;
CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO SignedAndEnvelopedMsgEncodeInfo;
CMSG_HASHED_ENCODE_INFO HashedMsgEncodeInfo;

#ifdef CMS_PKCS7
PUBLIC_KEY_DATA MultiSignerPublicKeyData;

BYTE rgbEncodedSignerHash[2][MAX_HASH_LEN];
DWORD rgcbEncodedSignerHash[2];

#endif  // CMS_PKCS7

static inline IsDSSProv(
    IN DWORD dwProvType
    )
{
    return (PROV_DSS == dwProvType || PROV_DSS_DH == dwProvType);
}

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
#define PRINT_ERROR(function,label)                                     \
label##:                                                                \
    PrintError( #function "::" #label);                                 \
    goto ErrorReturn;

void PrintError(LPCSTR pszMsg)
{
    printf("failed => %s\n", pszMsg);
}
void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

//+-------------------------------------------------------------------------
//  Test allocation and free routines
//--------------------------------------------------------------------------
void *TestAlloc(
    IN size_t cb
    )
{
    void *pv;
//    pv = LocalAlloc(LMEM_FIXED, cb);
    pv = malloc(cb);
    if (pv == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("TestAlloc");
    }
    return pv;
}

void *TestAllocZero(
    IN size_t cb
    )
{
    void *pv;
//    pv = LocalAlloc(LMEM_FIXED, cb);
    pv = malloc(cb);
    if (pv == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("TestAlloc");
    } else {
        memset( pv, 0, cb);
    }
    return pv;
}

void TestFree(
    IN void *pv
    )
{
//        LocalFree((HLOCAL) pv);
    if (pv)
        free(pv);
}


static BOOL AllocAndEncodeObject(
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    fResult = CryptEncodeObject(
            PKCS_7_ASN_ENCODING,
            lpszStructType,
            pvStructInfo,
            NULL,           // pbEncoded
            &cbEncoded);
    if (!fResult || cbEncoded == 0) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptEncodeObject(StructType: %d, cbEncoded == 0)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptEncodeObject(StructType: %s, cbEncoded == 0)",
                lpszStructType);
        PrintLastError("");
        goto ErrorReturn;
    }

    if (NULL == (pbEncoded = (BYTE *) TestAlloc(cbEncoded)))
        goto ErrorReturn;
    if (!CryptEncodeObject(
            PKCS_7_ASN_ENCODING,
            lpszStructType,
            pvStructInfo,
            pbEncoded,
            &cbEncoded
            )) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptEncodeObject(StructType: %d)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptEncodeObject(StructType: %s)",
                lpszStructType);
        PrintLastError("");
        goto ErrorReturn;
    }
    fResult = TRUE;

CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL AllocAndDecodeObject(
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    OUT void        **ppvStructInfo,
    IN OUT DWORD    *pcbStructInfo
    )
{
    BOOL fResult;
    void *pvStructInfo = NULL;
    DWORD cbStructInfo = 0;

    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            0,                          // dwFlags
            NULL,
            &cbStructInfo
            )) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptDecodeObject(StructType: %d, cbStructInfo == 0)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptDecodeObject(StructType: %s, cbStructInfo == 0)",
                lpszStructType);
        PrintLastError("");
        goto ErrorReturn;
    }
    if (NULL == (pvStructInfo = TestAlloc(cbStructInfo)))
        goto ErrorReturn;
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            0,                          // dwFlags
            pvStructInfo,
            &cbStructInfo
            )) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptDecodeObject(StructType: %d)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptDecodeObject(StructType: %s)",
                lpszStructType);
        PrintLastError("");
        goto ErrorReturn;
    }

    fResult = TRUE;

CommonReturn:
    *ppvStructInfo = pvStructInfo;
    *pcbStructInfo = cbStructInfo;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    TestFree(pvStructInfo);
    pvStructInfo = NULL;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Stream support
//--------------------------------------------------------------------------
typedef struct _TEST_STREAM_DATA {
    DWORD               dwEncodingType;
    DWORD               dwEncodeFlags;
    DWORD               dwDecodeFlags;
    DWORD               dwMsgTypeEncoding;
    DWORD               dwMsgTypeDecoding;
    PVOID               pvMsgEncodeInfo;
    LPSTR               pszInnerContentType;
    PCMSG_STREAM_INFO   pStreamInfo;
    HCRYPTMSG           hMsg;
    BOOL                fEncoding;
    BOOL                fReady;
#ifdef CMS_PKCS7
    DWORD               rgcbComputedHash[2];
    BYTE                rgbComputedHash[2][MAX_HASH_LEN];
#endif  // CMS_PKCS7
} TEST_STREAM_DATA, *PTEST_STREAM_DATA;

DEFINE_LIST_AND_NODE_CLASS( CStreamList, CStreamNode, TEST_STREAM_DATA);
CStreamNode::~CStreamNode()
{
    TestFree( m_data.pStreamInfo);
};

CStreamList     *plistStream = NULL;


DEFINE_LIST_AND_NODE_CLASS( CBlobList, CBlobNode, CRYPT_DATA_BLOB);
CBlobNode::~CBlobNode()
{
    TestFree( m_data.pbData);
};


LPSTR           pszStreamMsgTypes = "S";
#define pszStreamFileName "stream.msg"
#define pszFilenameDecode "decode.dat"
HANDLE          hFileStream       = INVALID_HANDLE_VALUE;
HANDLE          hFileStreamDecode = INVALID_HANDLE_VALUE;
DWORD           cbFileDecode;
#if DBG
#define cbStreamDataDeltaEncode 17
#else
#define cbStreamDataDeltaEncode 1024
#endif
BYTE abStreamDataDeltaEncode[cbStreamDataDeltaEncode];
#if DBG
DWORD cbStreamDataDeltaDecode = 1;
//DWORD cbStreamDataDeltaDecode = 19;
#else
DWORD cbStreamDataDeltaDecode = 1024;
#endif

//+-------------------------------------------------------------------------
//  Check that a CryptMsgGetParam to a buffer fails with the right error
//  because the buffer is too small.
//--------------------------------------------------------------------------
BOOL
WINAPI
TCM_CheckGetParam(
    IN HCRYPTMSG    hCryptMsg,
    IN DWORD        dwParamType,
    IN DWORD        dwIndex,
    IN PVOID        pv,
    IN DWORD        cbData)
{
    BOOL    fRet;
    DWORD   cbSmall;

    if (cbData < 1)
        goto SuccessReturn;

    cbSmall = cbData - 1;
    if (CryptMsgGetParam(
            hCryptMsg,
            dwParamType,
            dwIndex,
            pv,
            &cbSmall))
        goto GetSmallBufferRetError;

    if (ERROR_MORE_DATA != GetLastError())
        goto GetSmallBufferLastErrorError;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
PRINT_ERROR(TCM_CheckGetParam,GetSmallBufferRetError)
PRINT_ERROR(TCM_CheckGetParam,GetSmallBufferLastErrorError)
}


//+-------------------------------------------------------------------------
//  Do a CryptMsgGetParam to a buffer alloc'd by TestAlloc
//--------------------------------------------------------------------------
BOOL
WINAPI
TCM_AllocGetParam(
    IN HCRYPTMSG    hCryptMsg,
    IN DWORD        dwParamType,
    IN DWORD        dwIndex,
    OUT PBYTE       *ppbData,
    OUT DWORD       *pcbData)
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    fRet;
    DWORD   cb;
    PBYTE   pb = NULL;
    
    cb = 0;
    CryptMsgGetParam(
            hCryptMsg,
            dwParamType,
            dwIndex,
            NULL,
            &cb);
    if (cb == 0)
        goto GetEncodedSizeError;
    if (NULL == (pb = (PBYTE)TestAlloc(cb)))
        goto AllocEncodedError;
    if (!TCM_CheckGetParam(
            hCryptMsg,
            dwParamType,
            dwIndex,
            pb,
            cb))
        goto CheckGetEncodedError;
    if (!CryptMsgGetParam(
            hCryptMsg,
            dwParamType,
            dwIndex,
            pb,
            &cb))
        goto GetEncodedError;

    fRet = TRUE;
CommonReturn:
    *ppbData = pb;
    *pcbData = cb;
    if (dwError != ERROR_SUCCESS)
        SetLastError(dwError);
	return fRet;

ErrorReturn:
    dwError = GetLastError();
    TestFree(pb);
    pb = NULL;
    cb = 0;
	fRet = FALSE;
	goto CommonReturn;
PRINT_ERROR(TCM_AllocGetParam,GetEncodedSizeError)
PRINT_ERROR(TCM_AllocGetParam,AllocEncodedError)
PRINT_ERROR(TCM_AllocGetParam,CheckGetEncodedError)
PRINT_ERROR(TCM_AllocGetParam,GetEncodedError)
}


//+-------------------------------------------------------------------------
//  Compare 2 CRYPT_ALGORITHM_IDENTIFIER structs.
//
//  Returns: FALSE iff differ
//--------------------------------------------------------------------------
BOOL
WINAPI
EqualAlgorithm(
    IN PCRYPT_ALGORITHM_IDENTIFIER    pai1,
    IN PCRYPT_ALGORITHM_IDENTIFIER    pai2)
{
    BOOL    fRet;

    fRet  = (0 == strcmp( pai1->pszObjId, pai2->pszObjId));
    fRet &= (pai1->Parameters.cbData == pai2->Parameters.cbData);
    if (fRet) {
        fRet &= (0 == memcmp(   pai1->Parameters.pbData,
                                pai2->Parameters.pbData,
                                pai1->Parameters.cbData));
    }

	return fRet;
}


//+-------------------------------------------------------------------------
//  Compare 2 CRYPT_ATTRIBUTE structs.
//
//  Returns: FALSE iff differ
//--------------------------------------------------------------------------
BOOL
WINAPI
EqualAttribute(
    IN PCRYPT_ATTRIBUTE    patr1,
    IN PCRYPT_ATTRIBUTE    patr2)
{
    BOOL        fRet;
    DWORD       i;
    PCRYPT_ATTR_BLOB  pabl1;
    PCRYPT_ATTR_BLOB  pabl2;

    fRet  = (0 == strcmp( patr1->pszObjId, patr2->pszObjId));
    fRet &= (patr1->cValue == patr2->cValue);
    if (fRet) {
        for (i=patr1->cValue, pabl1=patr1->rgValue, pabl2=patr2->rgValue;
                i>0;
                i--, pabl1++, pabl2++) {
            fRet &= (pabl1->cbData == pabl2->cbData);
            if (fRet) {
                fRet &= (0 == memcmp( pabl1->pbData, 
                                      pabl2->pbData,
                                      pabl1->cbData));
            }
        }
    }

	return fRet;
}

void XORAttributeBytes()
{
    DWORD cb;
    BYTE *pb;

    cb = sizeof(attr1) / sizeof(attr1[0]);
    pb = attr1;
    while(cb--)
        *pb++ ^= 0xFF;

    cb = sizeof(attr2) / sizeof(attr2[0]);
    pb = attr2;
    while(cb--)
        *pb++ ^= 0xFF;

    cb = sizeof(attr3) / sizeof(attr3[0]);
    pb = attr3;
    while(cb--)
        *pb++ ^= 0xFF;

    cb = sizeof(unattr1) / sizeof(unattr1[0]);
    pb = unattr1;
    while(cb--)
        *pb++ ^= 0xFF;
}

void XORBlob(
    IN PCRYPT_DATA_BLOB pBlob
    )
{
    DWORD cb;
    BYTE *pb;

    cb = pBlob->cbData;
    pb = pBlob->pbData;
    while(cb--)
        *pb++ ^= 0xFF;
}

void XORBitBlob(
    IN PCRYPT_BIT_BLOB pBlob
    )
{
    CRYPT_DATA_BLOB Blob;
    Blob.pbData = pBlob->pbData;
    Blob.cbData = pBlob->cbData;

    XORBlob(&Blob);
}


//+-------------------------------------------------------------------------
//  Read an encoded DER blob from a file
//--------------------------------------------------------------------------
BOOL
GetDERFromFile(
	LPCSTR	pszFileName,
	PBYTE	*ppbDER,
	PDWORD	pcbDER
	)
{
	BOOL		fRet;
    HANDLE      hFile;
	PBYTE		pbDER;
    DWORD       cbDER;
    DWORD       cbRead;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile( pszFileName, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        printf( "can't open %s\n", pszFileName);
        goto ErrorReturn;
    }

    cbDER = GetFileSize( hFile, NULL);
    if (NULL == (pbDER = (PBYTE)TestAlloc( cbDER))) {
        printf( "can't alloc %d bytes\n", cbDER);
        goto ErrorReturn;
    }
    if (!ReadFile( hFile, pbDER, cbDER, &cbRead, NULL) ||
            (cbRead != cbDER)) {
        printf( "can't read %s\n", pszFileName);
        goto ErrorReturn;
    }

	CloseHandle( hFile);
	*ppbDER = pbDER;
	*pcbDER = cbDER;
	fRet = TRUE;
CommonReturn:
	return fRet;
ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Write a buffer to a file
//--------------------------------------------------------------------------
BOOL
WINAPI
TCM_WriteBufToFile(
    LPCSTR      pszFile,
    PBYTE       pbData,
    DWORD       cbData)
{
    BOOL        fRet;
    HANDLE      hFile;
    DWORD       cbWritten;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile( pszFile, GENERIC_WRITE,
            0, NULL, CREATE_ALWAYS, 0, NULL)))
        goto CreateFileError;

    if (!WriteFile( hFile, pbData, cbData, &cbWritten, NULL) ||
            (cbWritten != cbData))
        goto WriteFileError;

    CloseHandle( hFile);
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
PRINT_ERROR(TCM_WriteBufToFile,CreateFileError)
PRINT_ERROR(TCM_WriteBufToFile,WriteFileError)
}


//+-------------------------------------------------------------------------
//  Get the number of contents octets in a DER encoding.
//
//  Parameters:
//          pcbContent - receives the number of contents octets
//          pbLength   - points to the first length octet
//          cbDER      - number of bytes remaining in the DER encoding
//
//  Returns:
//          success - the number of bytes in the length field, >=0
//          failure - <0
//--------------------------------------------------------------------------
LONG
WINAPI
TCM_DecodeLength(
    OUT DWORD   *pcbContent,
    IN  PBYTE   pbLength,
    IN  DWORD   cbDER)
{
    long    i;
    BYTE    cbLength;
    PBYTE   pb;

    if (cbDER < 1)
        goto EncodeOverflowError;

    if (0x80 == *pbLength)
        goto IsBERError;

    // determine the number of length octets and contents octets
    if ((cbLength = *pbLength) & 0x80) {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        if (cbLength > 4)
            goto LengthTooLargeError;
        if (cbLength >= cbDER)
            goto EncodeOverflowError2;
        *pcbContent = 0;
        for (i=cbLength, pb=pbLength+1; i>0; i--, pb++)
            *pcbContent = (*pcbContent << 8) + (DWORD)*pb;
        i = cbLength + 1;
    } else {
        *pcbContent = (DWORD)cbLength;
        i = 1;
    }

CommonReturn:
    return i;   // how many bytes there were in the length field

EncodeOverflowError:
IsBERError:
LengthTooLargeError:
EncodeOverflowError2:
    i = -1;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Point to the content octets in a DER-encoded blob.
//
//  Returns:
//          success - the number of bytes skipped, >=0
//          failure - <0
//
//  Assume pbData points to a definite-length BER-encoded blob.
//--------------------------------------------------------------------------
LONG
WINAPI
TCM_ExtractContent(
    IN PBYTE pbDER,
    IN DWORD cbDER,
    OUT DWORD *pcbContent,
    OUT OPTIONAL PBYTE *ppbContent)
{
#define TAG_MASK 0x1f
    DWORD   cbIdentifier;
    DWORD   cbContent;
    LONG    cbLength;
    PBYTE   pb = pbDER;

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK)) {
        // high-tag-number form
        for (cbIdentifier=2; *pb++ & 0x80; cbIdentifier++)
            ;
    } else {
        // low-tag-number form
        cbIdentifier = 1;
    }

    if (0 > (cbLength = TCM_DecodeLength( &cbContent, pb, cbDER-cbIdentifier)))
        goto DecodeLengthError;

    pb += cbLength;

    *pcbContent = cbContent;
    if (ppbContent)
        *ppbContent = pb;

    return cbLength + cbIdentifier;

DecodeLengthError:
    return -1;
}



//+-------------------------------------------------------------------------
//  Functions for initializing message encode information
//--------------------------------------------------------------------------
void InitSignedMsgEncodeInfo(
    OUT PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    );
void InitEnvelopedMsgEncodeInfo(
    OUT PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    );

//+-------------------------------------------------------------------------
//  Functions for cleaning up message encode information
//--------------------------------------------------------------------------
void CleanupSignedMsgEncodeInfo(
    OUT PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    );
void CleanupEnvelopedMsgEncodeInfo(
    OUT PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    );

//+-------------------------------------------------------------------------
//  Message encode and decode routines
//--------------------------------------------------------------------------
BOOL EncodeAndDecodeMsg(
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo
    );
BOOL EncodeMsg(
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo,
    OUT BYTE **ppbEncodedBlob,
    OUT DWORD *pcbEncodedBlob
    );
BOOL DecodeMsg(
    IN DWORD dwExpectedMsgType,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob
    );
BOOL StreamEncodeAndDecodeMsg();
BOOL StreamEncodeMsg();
BOOL StreamDecodeMsg();

//+-------------------------------------------------------------------------
//  Get signer info and verify the signed message
//--------------------------------------------------------------------------
BOOL GetSignerInfoAndVerify(IN HCRYPTMSG hMsg, IN BOOL fInnerNonData);

BOOL GetSignerInfoAndVerify(
    IN HCRYPTMSG hMsg,
    IN BOOL fInnerNonData,
    IN DWORD dwSignerIndex,
    OUT DWORD *pdwSrcIndex
    );

//+-------------------------------------------------------------------------
// Get recipient info and decrypt the message.
//--------------------------------------------------------------------------
BOOL GetRecipientInfoAndDecrypt(IN HCRYPTMSG hMsg);

//+-------------------------------------------------------------------------
// Allocate and get the CMSG_SIGNER_CERT_INFO_PARAM or CMSG_RECIPIENT_INFO_PARAM
// from the message
//--------------------------------------------------------------------------
PCERT_INFO GetCertIdFromMsg(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex
    );

//+-------------------------------------------------------------------------
// Allocate and get the CMSG_SIGNER_INFO_PARAM from the message
//--------------------------------------------------------------------------
PCMSG_SIGNER_INFO GetSignerInfoFromMsg(
    IN HCRYPTMSG hMsg,
    IN DWORD dwIndex
    );

//+-------------------------------------------------------------------------
// Get computed digest and digest data from a decoded CMSG_HASHED
//--------------------------------------------------------------------------
BOOL Undigest(IN HCRYPTMSG hMsg);

//+-------------------------------------------------------------------------
// Countersign test functions
//--------------------------------------------------------------------------
BOOL CountersignAndVerify(IN HCRYPTMSG hCryptMsg);

//+-------------------------------------------------------------------------
// Add signer test functions
//--------------------------------------------------------------------------
BOOL AddSignerAndVerify(IN HCRYPTMSG hCryptMsg);

//+-------------------------------------------------------------------------
//  Top Level Test Functions
//--------------------------------------------------------------------------
BOOL TestSign()
{
    BOOL    fRet;

    InitSignedMsgEncodeInfo(&SignedMsgEncodeInfo);
    fRet = EncodeAndDecodeMsg(CMSG_SIGNED, &SignedMsgEncodeInfo);
    CleanupSignedMsgEncodeInfo(&SignedMsgEncodeInfo);
    return fRet;
}

BOOL TestEnvelope()
{
    BOOL    fRet;

    InitEnvelopedMsgEncodeInfo(&EnvelopedMsgEncodeInfo);
    fRet = EncodeAndDecodeMsg(CMSG_ENVELOPED, &EnvelopedMsgEncodeInfo);
    CleanupEnvelopedMsgEncodeInfo(&EnvelopedMsgEncodeInfo);
    return fRet;
}

BOOL TestSignAndEnvelope()
{
    BOOL    fRet;

    return FALSE;
    SignedAndEnvelopedMsgEncodeInfo.cbSize =
        sizeof(CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO);
    InitSignedMsgEncodeInfo(&SignedAndEnvelopedMsgEncodeInfo.SignedInfo);
    InitEnvelopedMsgEncodeInfo(&SignedAndEnvelopedMsgEncodeInfo.EnvelopedInfo);
    fRet = EncodeAndDecodeMsg(CMSG_SIGNED_AND_ENVELOPED,
        &SignedAndEnvelopedMsgEncodeInfo);
    CleanupSignedMsgEncodeInfo(&SignedAndEnvelopedMsgEncodeInfo.SignedInfo);
    CleanupEnvelopedMsgEncodeInfo(&SignedAndEnvelopedMsgEncodeInfo.EnvelopedInfo);
    return fRet;
}

BOOL TestDigest()
{
    HashedMsgEncodeInfo.cbSize = sizeof(CMSG_HASHED_ENCODE_INFO);
    HashedMsgEncodeInfo.hCryptProv = hDefaultVerifyProv;
    HashedMsgEncodeInfo.HashAlgorithm =
        DigestAlgorithms[ fMD5 ? DIGEST_ALG_MD5 : DIGEST_ALG_SHA];
    HashedMsgEncodeInfo.pvHashAuxInfo = NULL;

    return EncodeAndDecodeMsg(CMSG_HASHED, &HashedMsgEncodeInfo);
}

BOOL TestCountersign()
{
    BOOL    fRet;

    fCountersign = TRUE;
    InitSignedMsgEncodeInfo(&SignedMsgEncodeInfo);
    fRet = EncodeAndDecodeMsg(CMSG_SIGNED, &SignedMsgEncodeInfo);
    CleanupSignedMsgEncodeInfo(&SignedMsgEncodeInfo);
    return fRet;
}

BOOL TestStream()
{
    BOOL    fRet;

    if (NULL == (plistStream = new CStreamList))
        return FALSE;
    fStream = TRUE;

    InitSignedMsgEncodeInfo(&SignedMsgEncodeInfo);
    InitEnvelopedMsgEncodeInfo(&EnvelopedMsgEncodeInfo);
    fRet = StreamEncodeAndDecodeMsg();
    CleanupEnvelopedMsgEncodeInfo(&EnvelopedMsgEncodeInfo);
    CleanupSignedMsgEncodeInfo(&SignedMsgEncodeInfo);

    delete plistStream;
    plistStream = NULL;
    return fRet;
}


typedef BOOL (*PFN_TEST)(void);
struct
{
    LPCSTR      pszName;
    PFN_TEST    pfn;
} Tests[] = {
    "Sign",             TestSign,
    "Envelope",         TestEnvelope,
    "SignAndEnvelope",  TestSignAndEnvelope,
    "Digest",           TestDigest,
    "Countersign",      TestCountersign,
    "Stream",           TestStream
};
#define NTESTS (sizeof(Tests)/sizeof(Tests[0]))

void Usage(void)
{
    int i;

    printf("Usage: tcrmsg [options] [<TestName>] [<StoreFilename>][<CertNameString>]\n");
    printf("Options are:\n");
#ifdef CMS_PKCS7
    printf("  -AttrCert             - Add CMS attribute certificates\n");
    printf("  -Crl                  - Add CRLs\n");
    printf("  -EncapsulatedContent  - CMS encapsulated content\n");
    printf("  -OriginatorInfo       - CMS EnvelopedData OriginatorInfo\n");
    printf("  -KeyTrans             - CMS KeyTrans recipients\n");
    printf("  -KeyAgree             - CMS KeyAgree recipients\n");
    printf("  -MailList             - CMS MailList recipients\n");
    printf("  -RecipientKeyId       - Use KeyId for recipients\n");
    printf("  -CertInfoKeyId        - Use KeyId for encode CertInfo\n");
    printf("  -SignerId             - Use SignerId instead of CertInfo\n");
    printf("  -HashEncryptionAlgorithm - Use for first signer info\n");
    printf("  -NoSignature          - Use NO_SIGNATURE OID \n");
    printf("  -NoRecipients         - No Envelope Recipients\n");
    printf("  -AlgorithmParameters  - Algorithms have dummy parameters\n");
    printf("  -NoSalt               - NoSalt for RC4\n");
#endif  // CMS_PKCS7
    printf("  -h                    - This message\n");
    printf("  -A                    - Authenticated Attributes\n");
    printf("  -B                    - Bare content (no outer ContentInfo)\n");
    printf("  -c                    - no Certs\n");
    printf("  -C                    - non-data inner Content\n");
    printf("  -D                    - Detached Signature/Digest\n");
    printf("  -i                    - indefinite-length encoding\n");
    printf("  -l                    - print command Line\n");
    printf("  -M                    - MD5 hash algorithm\n");
    printf("  -n<size>              - Number of bytes in content\n");
    printf("  -N                    - No signers\n");
#ifdef CMS_PKCS7
    printf("  -NMultiple            - Multiple signers\n");
#endif  // CMS_PKCS7
    printf("  -p<provider#>         - Crypto Provider\n");
    printf("  -PEnhanced            - Use enhanced crypto provider\n");
    printf("  -PDefault             - Use default crypto provider\n");
#ifdef CMS_PKCS7
    printf("  -PRecipient           - Each recipient has a crypto provider\n");
    printf("  -PDSS                 - Use DSS provider for second signer\n");
    printf("  -PDSS_DH              - Use DSS_DH provider for second signer\n");
#endif  // CMS_PKCS7
    printf("  -P<ProviderName>      - Crypto provider Name\n");
    printf("  -K<ContainerName>     - Provider key container Name\n");
    printf("  -E<name>              - Encrypt algorithm, default of \"rc2\"\n");
    printf("  -e<EncryptBitLen>     - Encrypt key bit length\n");
    printf("  -I                    - Include IV in encrypt parameters\n");
    printf("  -s[ES]+               - list of stream message types\n");
    printf("  -S                    - add signer\n");
    printf("  -t                    - tiny streaming decode buffer\n");
    printf("  -v                    - verbose\n");
    printf("  -f<filename>          - Write encoded message to file\n");
    printf("\n");
    printf("Tests are (case insensitive name):\n");
    for (i = 0; i < NTESTS; i++)
        printf("  %s\n", Tests[i].pszName);
    printf("\n");
    printf("Default: ALL Tests\n");
}

HCRYPTPROV GetCryptProv(
    DWORD dwMyProvType = dwProvType,
    LPCSTR pszMyProvider = pszProvider
    )
{
    HCRYPTPROV hProv = 0;
    BOOL fResult;

    if (NULL == pszMyProvider) {
        if (fEnhanced) {
            if (PROV_RSA_FULL == dwMyProvType)
                pszMyProvider = MS_ENHANCED_PROV_A;
        }
    }

    fResult = CryptAcquireContextA(
                &hProv,
                pszContainer,
                pszMyProvider,
                dwMyProvType,
                fNoSignature ? CRYPT_VERIFYCONTEXT : 0  // dwFlags
                );
    if (fResult) {
        printf("Using default sign and xchg keys for provider type: %d",
            dwMyProvType);
        if (pszMyProvider && *pszMyProvider)
            printf(" provider: %s", pszMyProvider);
        if (pszContainer && *pszContainer)
            printf(" container: %s", pszContainer);
        printf("\n");
    } else {
        DWORD dwErr = GetLastError();
        if (dwErr == NTE_BAD_KEYSET) {

            // Need to create the keys
            printf("Generating SIGNATURE and EXCHANGE private keys\n");

            hProv = 0;
            fResult = CryptAcquireContextA(
                    &hProv,
                    pszContainer,
                    pszMyProvider,
                    dwMyProvType,
                    CRYPT_NEWKEYSET
                    );
            if (!fResult || hProv == 0) {
                PrintLastError("CryptAcquireContext");
                return 0;
            }

            HCRYPTKEY hKey = 0;
            fResult = CryptGenKey(
                    hProv,
                    AT_SIGNATURE,
                    CRYPT_EXPORTABLE,
                    &hKey
                    );
            if (!fResult || hKey == 0)
                PrintLastError("CryptGenKey(AT_SIGNATURE)");
            else
                CryptDestroyKey(hKey);

            hKey = 0;
            fResult = CryptGenKey(
                    hProv,
                    AT_KEYEXCHANGE,
                    CRYPT_EXPORTABLE,
                    &hKey
                    );
            if (!fResult || hKey == 0)
                PrintLastError("CryptGenKey(AT_KEYEXCHANGE)");
            else
                CryptDestroyKey(hKey);

        } else {
            PrintLastError("CryptAcquireContext");
            return 0;
        }
    }
    return hProv;
}


BOOL
GetNonStreamedMsgContent(
    IN  DWORD   cbContent,
    OUT PBYTE   *ppbContent,
    OUT DWORD   *pcbContent)
{
    BOOL    fRet;
    PBYTE   pbContent;
    PBYTE   pb;
    DWORD   cb;

    if (fInnerContent) {
    	if (!GetDERFromFile(
                pszInnerContentFileName,
                ppbContent,
                pcbContent))
            goto GetDERFromFileError;
    } else {
        if (NULL == (pbContent = (PBYTE)TestAlloc( cbContent)))
            goto AllocContentError;

        for (pb=pbContent, cb=0; cb < cbContent; pb++, cb++)
            *pb = rgbMsgContentFill[ cb%cbMsgContentFill];
        *ppbContent = pbContent;
        *pcbContent = cbContent;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    *ppbContent = NULL;
    *pcbContent = 0;
    fRet = FALSE;
    goto CommonReturn;
PRINT_ERROR(GetNonStreamedMsgContent,GetDERFromFileError)
PRINT_ERROR(GetNonStreamedMsgContent,AllocContentError)
}

PCCRYPT_OID_INFO GetOIDInfo(LPCSTR pszName, DWORD dwGroupId = 0)
{
    WCHAR wszName[256];
    PCCRYPT_OID_INFO pInfo;

    MultiByteToWideChar(
        CP_ACP,
        0,                      // dwFlags
        pszName,
        -1,                     // null terminated
        wszName,
        sizeof(wszName) / sizeof(wszName[0]));

    return CryptFindOIDInfo(
        CRYPT_OID_INFO_NAME_KEY,
        (void *) wszName,
        dwGroupId
        );
}

LPCSTR GetOID(LPCSTR pszName, DWORD dwGroupId = 0)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = GetOIDInfo(pszName, dwGroupId))
        return pInfo->pszOID;
    else
        return NULL;
}

ALG_ID GetAlgid(LPCSTR pszName, DWORD dwGroupId = 0)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = GetOIDInfo(pszName, dwGroupId))
        return pInfo->Algid;
    else
        return 0;
}

static HCERTSTORE OpenStore(LPCSTR pszStoreFilename)
{
    HCERTSTORE hStore;
    HANDLE hFile = 0;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile(pszStoreFilename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        printf( "can't open %s\n", pszStoreFilename);

        hStore = NULL;
    } else {
        hStore = CertOpenStore(
            CERT_STORE_PROV_FILE,
            dwCertEncodingType,
            0,                      // hProv
            0,                      // dwFlags
            hFile
            );
        CloseHandle(hFile);
    }

    if (hStore == NULL)
        PrintLastError("CertOpenStore");
    return hStore;
}

int _cdecl main(int argc, char * argv[])
{
    BOOL fResult;
    LPSTR pszTestName = NULL;
    int TestIdx = 0;
    LPSTR pszStoreFilename = NULL;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
#ifdef CMS_PKCS7
            if (0 == _stricmp(argv[0]+1, "AttrCert")) {
                cAttrCert = ATTR_CERT_COUNT;
            } else if (0 == _stricmp(argv[0]+1, "Crl")) {
                cSignedCrl = SIGNED_CRL_COUNT;
            } else if (0 == _stricmp(argv[0]+1, "EncapsulatedContent")) {
                fEncapsulatedContent = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "OriginatorInfo")) {
                fOriginatorInfo = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "KeyTrans")) {
                fKeyTrans = TRUE;
                fCmsRecipient = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "KeyAgree")) {
                fKeyAgree = TRUE;
                fCmsRecipient = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "MailList")) {
                fMailList = TRUE;
                fCmsRecipient = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "RecipientKeyId")) {
                fRecipientKeyId = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "CertInfoKeyId")) {
                fCertInfoKeyId = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "SignerId")) {
                fSignerId = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "HashEncryptionAlgorithm")) {
                fHashEncryptionAlgorithm = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "NoSignature")) {
                fNoSignature = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "NoRecipients")) {
                fNoRecipients = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "AlgorithmParameters")) {
                fAlgorithmParameters = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "NoSalt")) {
                fNoSalt = TRUE;
            } else {
#endif  // CMS_PKCS7
                switch(argv[0][1])
                {
                case 'A':
                    fAuthAttr = TRUE;
                    break;
                case 'B':
                    fBare = TRUE;
                    break;
                case 'c':
                    cSignedCert = 0;
                    break;
                case 'C':
                    fInnerContent = TRUE;
                    break;
                case 'D':
                    fDetached = TRUE;
                    break;
                case 'i':
                    fIndefinite = TRUE;
                    break;
                case 'l':
                    printf("command line: %s\n", GetCommandLine());
                    break;
                case 'M':
                    fMD5 = TRUE;
                    break;
                case 'n':
                    cbMsgContent = strtoul( argv[0]+2, NULL, 0);
                    break;
                case 'N':
#ifdef CMS_PKCS7
                    if (0 == _stricmp(argv[0]+2, "Multiple"))
                        fMultiSigner = TRUE;
                    else
#endif  // CMS_PKCS7
                        fNoSigners = TRUE;
                    break;
                case 'p':
                    dwProvType = strtoul( argv[0]+2, NULL, 0);
                    break;
                case 'P':
                    if (0 == _stricmp(argv[0]+2, "Enhanced"))
                        fEnhanced = TRUE;
                    else if (0 == _stricmp(argv[0]+2, "Default"))
                        fDefaultVerifyProv = TRUE;
#ifdef CMS_PKCS7
                    else if (0 == _stricmp(argv[0]+2, "Recipient"))
                        fRecipientProv = TRUE;
                    else if (0 == _stricmp(argv[0]+2, "DSS"))
                        dwMultiSignerProvType = PROV_DSS;
                    else if (0 == _stricmp(argv[0]+2, "DSS_DH"))
                        dwMultiSignerProvType = PROV_DSS_DH;
#endif  // CMS_PKCS7
                    else
                        pszProvider = argv[0]+2;
                    break;
                case 'K':
                    pszContainer = argv[0]+2;
                    break;
                case 'E':
                    pszEncryptName = argv[0]+2;
                    break;
                case 'e':
                    dwEncryptBitLen = strtoul( argv[0]+2, NULL, 0);
                    break;
                case 'I':
                    fEncryptIV = TRUE;
                    break;
                case 'R':
                    pszEncryptName = "rc4";
                    break;
                case 's':
                    pszStreamMsgTypes = argv[0]+2;
                    break;
                case 'S':
                    fAddSigner = TRUE;
                    break;
                case 't':
                    cbStreamDataDeltaDecode = 1;
                    break;
                case 'v':
                    fVerbose = TRUE;
                    break;
                case 'f':
                    pszFilename = argv[0]+2;
                    if (*pszFilename == '\0') {
                        printf("Need to specify filename\n");
                        Usage();
                        return -1;
                    }
                    break;
                case 'h':
                default:
                    Usage();
                    return -1;
                }
#ifdef CMS_PKCS7
            }
#endif  // CMS_PKCS7
        } else {
            if(pszTestName == NULL)
                pszTestName = argv[0];
            else if (pszStoreFilename == NULL)
                pszStoreFilename = argv[0];
            else if (pszCertNameFindStr == NULL)
                pszCertNameFindStr = argv[0];
            else {
                printf("Too many arguments\n");
                Usage();
                return -1;
            }
        }
    }

    if (fInnerContent && (cbMsgContent != DEFAULT_MSG_CONTENT_SIZE)) {
        printf( "-n and -C not compatible\n");
        return -1;
    }

    if (pszTestName) {
        for (TestIdx = 0; TestIdx < NTESTS; TestIdx++) {
            if (_stricmp(pszTestName, Tests[TestIdx].pszName) == 0)
                break;
        }
        if (TestIdx >= NTESTS) {
            printf("Bad TestName: %s\n", pszTestName);
            Usage();
            return -1;
        }

    } else
        TestIdx = 0;

    if (NULL == (pszEncryptOID = (LPSTR) GetOID(
            pszEncryptName, CRYPT_ENCRYPT_ALG_OID_GROUP_ID))) {
        printf("Failed => unknown encrypt name (%s)\n", pszEncryptName);
        return -1;
    }

    if (fDetached)      printf("Enabled: DetachedDigest/Signature\n");
    if (fNoSigners)     printf("Enabled: NoSigners\n");
    if (fAuthAttr)      printf("Enabled: Authenticated attributes\n");
    if (fInnerContent)  printf("Enabled: non-data Content\n");
    if (0 != _stricmp("rc2", pszEncryptName))
        printf("Enabled: %s\n", pszEncryptName);
    if (0 != dwEncryptBitLen)
        printf("Enabled: Encrypt bit length: %d\n", dwEncryptBitLen);
    if (fEncryptIV)     printf("Enabled: IV\n");
    if (fMD5)           printf("Enabled: MD5\n");
    if (pszFilename)    printf("Enabled: Writing encoded to file: %s\n", pszFilename);

    // Get crypto provider having both signature and exchange private keys
    hCryptProv = GetCryptProv();
    if (hCryptProv == 0)
        return -1;

    // Attempt to open the store
    if (pszStoreFilename) {
        hSignerStore = OpenStore(pszStoreFilename);
        if (NULL == hSignerStore)
            return -1;
    }

#ifdef CMS_PKCS7
    if (fKeyAgree) {
        hKeyAgreeProv = GetCryptProv(PROV_DSS_DH, NULL);

        if (hKeyAgreeProv == 0)
            return -1;
    }

    if (fMultiSigner) {
        hMultiSignerCryptProv = GetCryptProv(dwMultiSignerProvType, NULL);
        if (hMultiSignerCryptProv == 0)
            return -1;
    }
#endif  // CMS_PKCS7

    if (fDefaultVerifyProv) {
        printf("Using default hCryptProv for encrypting and verifying\n");
        hDefaultVerifyProv = 0;
    } else
        hDefaultVerifyProv = hCryptProv;

    for ( ; TestIdx < NTESTS; TestIdx++) {
        printf("Starting %s Test\n", Tests[TestIdx].pszName);
        fResult = Tests[TestIdx].pfn();
        if (fResult)
            printf("Passed\n");
        else
            printf("Failed\n");
        printf("\n");
        if (pszTestName)
            break;
    }

    TestFree( pbInnerContent);
    if (pNamedSigner)
        CertFreeCertificateContext(pNamedSigner);
    if (hSignerStore)
        CertCloseStore(hSignerStore, 0);

    return 0;
}



//+-------------------------------------------------------------------------
//  Functions for initializing message encode information
//--------------------------------------------------------------------------

static PCCERT_CONTEXT FindCertWithKey(
    IN HCERTSTORE hCertStore,
    IN DWORD dwKeySpec
    )
{
    PCCERT_CONTEXT pCert;
    void *pvFindPara;
    DWORD dwFindType;

    if (pszCertNameFindStr) {
        dwFindType = CERT_FIND_SUBJECT_STR_A;
        pvFindPara = (void *) pszCertNameFindStr;
    } else {
        dwFindType = CERT_FIND_ANY;
        pvFindPara = NULL;
    }

    // Find the first certificate in the store with a CRYPT_KEY_PROV_INFO
    // property matching the specified dwSignKeySpec, dwCryptProvType and
    // dwPubKeyBitLen
    pCert = NULL;
    while (TRUE) {
        pCert = CertFindCertificateInStore(
            hCertStore,
            dwCertEncodingType,
            0,                      // dwFindFlags,
            dwFindType,
            pvFindPara,
            pCert
            );
        if (pCert == NULL)
            break;

        PCRYPT_KEY_PROV_INFO pInfo = NULL;
        DWORD cbInfo = 0;
        CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,
            &cbInfo
            );
        if (cbInfo >= sizeof(CRYPT_KEY_PROV_INFO) &&
                (pInfo = (PCRYPT_KEY_PROV_INFO) TestAlloc(cbInfo))) {
            BOOL fMatch = FALSE;
            if (CertGetCertificateContextProperty(
                        pCert,
                        CERT_KEY_PROV_INFO_PROP_ID,
                        pInfo,
                        &cbInfo) && 
                    dwKeySpec == pInfo->dwKeySpec)
                fMatch = TRUE;
            TestFree(pInfo);
            if (fMatch)
                break;
        }
    }
    return pCert;
}


#ifdef CMS_PKCS7

static BYTE bZeroSerialNumber = 0;

//+-------------------------------------------------------------------------
//  Create a Special Issuer and SerialNumber from a KeyId.
//--------------------------------------------------------------------------
void CreateIssuerAndSerialNumberFromKeyId(
    IN const BYTE *pbKeyId,
    IN DWORD cbKeyId,
    IN OUT PCERT_INFO pCertInfo
    )
{
    CERT_RDN_ATTR KeyIdAttr;
    CERT_RDN KeyIdRDN;
    CERT_NAME_INFO IssuerInfo;

    KeyIdAttr.pszObjId = szOID_KEYID_RDN;
    KeyIdAttr.dwValueType = CERT_RDN_OCTET_STRING;
    KeyIdAttr.Value.pbData = (BYTE *) pbKeyId;
    KeyIdAttr.Value.cbData = cbKeyId;
    KeyIdRDN.cRDNAttr = 1;
    KeyIdRDN.rgRDNAttr = &KeyIdAttr;
    IssuerInfo.cRDN = 1;
    IssuerInfo.rgRDN = &KeyIdRDN;

    // Encode the special Issuer Name containing the KeyId
    AllocAndEncodeObject(
            X509_NAME,
            &IssuerInfo,
            &pCertInfo->Issuer.pbData,
            &pCertInfo->Issuer.cbData
            );

    pCertInfo->SerialNumber.cbData = 1;
    pCertInfo->SerialNumber.pbData = &bZeroSerialNumber;
}
#endif


void InitSignerEncodeInfo()
{
    DWORD cbSignerPublicKeyData;

    // Update the Issuer, SerialNumber and PublicKeyAlgorithm in
    // the signer's CERT_INFO
    memset(&rgSignerCertInfo[0], 0, sizeof(CERT_INFO));

#ifdef CMS_PKCS7
    if (fCertInfoKeyId) {
        CreateIssuerAndSerialNumberFromKeyId(
            (const BYTE *)"Signer 0",
            strlen("Signer 0"),
			&rgSignerCertInfo[0]
            );

        rgSignerId[0].dwIdChoice = CERT_ID_KEY_IDENTIFIER;
        rgSignerId[0].KeyId.pbData = (BYTE *)"Signer 0";
        rgSignerId[0].KeyId.cbData = strlen("Signer 0");
    } else {
#endif

	GetDERFromFile(
			pszSignerSerialNumberFileName,
			&rgSignerCertInfo[0].Issuer.pbData,
			&rgSignerCertInfo[0].Issuer.cbData);
    rgSignerCertInfo[0].SerialNumber.cbData = sizeof(DWORD);
    rgSignerCertInfo[0].SerialNumber.pbData = (BYTE *) &dwSignerSerialNumber;
#ifdef CMS_PKCS7
    rgSignerId[0].dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
    rgSignerId[0].IssuerSerialNumber.Issuer = rgSignerCertInfo[0].Issuer;
    rgSignerId[0].IssuerSerialNumber.SerialNumber =
        rgSignerCertInfo[0].SerialNumber;
    }
#endif

    if (!fNoSignature) {
        // Get crypt provider's public signature key. It will be used as the
        // signer's public key algorithm
        cbSignerPublicKeyData = sizeof(SignerPublicKeyData.Data);
        memset(SignerPublicKeyData.Data, 0, cbSignerPublicKeyData);
        CryptExportPublicKeyInfo(
            hCryptProv,
            AT_SIGNATURE,
            X509_ASN_ENCODING,
            (PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data,
            &cbSignerPublicKeyData);
        rgSignerCertInfo[0].SubjectPublicKeyInfo.Algorithm =
            ((PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data)->Algorithm;
    }

    // Update the rgSignerEncodeInfo[0]
    memset(&rgSignerEncodeInfo[0], 0, sizeof(CMSG_SIGNER_ENCODE_INFO));
    rgSignerEncodeInfo[0].cbSize = sizeof(CMSG_SIGNER_ENCODE_INFO);
    rgSignerEncodeInfo[0].pCertInfo = &rgSignerCertInfo[0];
    rgSignerEncodeInfo[0].hCryptProv = hCryptProv;
    rgSignerEncodeInfo[0].HashAlgorithm =
        SignDigestAlgorithms[ fMD5 ? SIGNDIGEST_ALG_MD5 : SIGNDIGEST_ALG_SHA];
    rgSignerEncodeInfo[0].pvHashAuxInfo = NULL;
#ifdef CMS_PKCS7
    if (fAlgorithmParameters) {
        rgSignerEncodeInfo[0].HashAlgorithm.Parameters.pbData = rgbOctets;
        rgSignerEncodeInfo[0].HashAlgorithm.Parameters.cbData =
            sizeof(rgbOctets);
    }
#endif  // CMS_PKCS7

    if (fAuthAttr) {
        rgSignerEncodeInfo[0].cAuthAttr = AUTH_ATTR_COUNT;
        rgSignerEncodeInfo[0].rgAuthAttr = rgAuthAttr;

        if (!fCountersign) {
            rgSignerEncodeInfo[0].cUnauthAttr = UNAUTH_ATTR_COUNT;
            rgSignerEncodeInfo[0].rgUnauthAttr = rgUnauthAttr;
        }
    }

    if (hSignerStore) {
        pNamedSigner = FindCertWithKey(hSignerStore, AT_SIGNATURE);
        if (NULL == pNamedSigner) {
            PrintLastError("FindCertWithKey(AT_SIGNATURE)");
        } else {
            if (!CryptAcquireCertificatePrivateKey(
                    pNamedSigner,
                    0,                      // dwFlags
                    NULL,                   // pvReserved
                    &hNamedSignerCryptProv,
                    NULL,                   // pdwKeySpec,
                    NULL                    // pfCallerFreeProv
                    )) {
                PrintLastError("CryptAcquireCertificatePrivateKey");
                CertFreeCertificateContext(pNamedSigner);
                pNamedSigner = NULL;
            } else {
                rgSignerEncodeInfo[0].pCertInfo = pNamedSigner->pCertInfo;
                rgSignerEncodeInfo[0].hCryptProv = hNamedSignerCryptProv;
#ifdef CMS_PKCS7
                rgSignerId[0].dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
                rgSignerId[0].IssuerSerialNumber.Issuer =
                    rgSignerEncodeInfo[0].pCertInfo->Issuer;
                rgSignerId[0].IssuerSerialNumber.SerialNumber =
                    rgSignerEncodeInfo[0].pCertInfo->SerialNumber;
#endif  // CMS_PKCS7
            }
        }
    }

#ifdef CMS_PKCS7
    if (fNoSignature) {
        rgSignerEncodeInfo[0].HashEncryptionAlgorithm.pszObjId =
            szOID_PKIX_NO_SIGNATURE;
    } else if (fHashEncryptionAlgorithm) {
        if (pNamedSigner)
            rgSignerEncodeInfo[0].HashEncryptionAlgorithm =
                pNamedSigner->pCertInfo->SignatureAlgorithm;
        else
            rgSignerEncodeInfo[0].HashEncryptionAlgorithm =
                rgSignerCertInfo[0].SubjectPublicKeyInfo.Algorithm;

        if (fAlgorithmParameters &&
                0 == rgSignerEncodeInfo[0].HashEncryptionAlgorithm.Parameters.cbData)
        {
            rgSignerEncodeInfo[0].HashEncryptionAlgorithm.Parameters.pbData =
                rgbOctets;
            rgSignerEncodeInfo[0].HashEncryptionAlgorithm.Parameters.cbData =
                sizeof(rgbOctets);
        }
    }

    if (fMultiSigner) {
        // Update the Issuer, SerialNumber and PublicKeyAlgorithm in
        // the signer's CERT_INFO
        memset(&rgSignerCertInfo[1], 0, sizeof(CERT_INFO));

        if (fCertInfoKeyId) {
            CreateIssuerAndSerialNumberFromKeyId(
                (const BYTE *)"Signer 1",
                strlen("Signer 1"),
                &rgSignerCertInfo[1]
                );

            rgSignerId[1].dwIdChoice = CERT_ID_KEY_IDENTIFIER;
            rgSignerId[1].KeyId.pbData = (BYTE *)"Signer 1";
            rgSignerId[1].KeyId.cbData = strlen("Signer 1");
        } else {
            GetDERFromFile(
                    pszSignerSerialNumberFileName,
                    &rgSignerCertInfo[1].Issuer.pbData,
                    &rgSignerCertInfo[1].Issuer.cbData);
            rgSignerCertInfo[1].SerialNumber.cbData = sizeof(DWORD);
            rgSignerCertInfo[1].SerialNumber.pbData =
                (BYTE *) &dwSignerSerialNumber1;

            rgSignerId[1].dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
            rgSignerId[1].IssuerSerialNumber.Issuer =
                rgSignerCertInfo[1].Issuer;
            rgSignerId[1].IssuerSerialNumber.SerialNumber =
                rgSignerCertInfo[1].SerialNumber;
        }


        if (!fNoSignature) {
            // Get crypt provider's public signature key. It will be used as the
            // signer's public key algorithm
            cbSignerPublicKeyData = sizeof(MultiSignerPublicKeyData.Data);
            memset(MultiSignerPublicKeyData.Data, 0, cbSignerPublicKeyData);
            CryptExportPublicKeyInfo(
                hMultiSignerCryptProv,
                AT_SIGNATURE,
                X509_ASN_ENCODING,
                (PCERT_PUBLIC_KEY_INFO) MultiSignerPublicKeyData.Data,
                &cbSignerPublicKeyData);
            rgSignerCertInfo[1].SubjectPublicKeyInfo.Algorithm =
                ((PCERT_PUBLIC_KEY_INFO) MultiSignerPublicKeyData.Data)->Algorithm;
        }

        // Update the rgSignerEncodeInfo[1]
        memset(&rgSignerEncodeInfo[1], 0, sizeof(CMSG_SIGNER_ENCODE_INFO));
        rgSignerEncodeInfo[1].cbSize = sizeof(CMSG_SIGNER_ENCODE_INFO);
        rgSignerEncodeInfo[1].pCertInfo = &rgSignerCertInfo[1];
        rgSignerEncodeInfo[1].hCryptProv = hMultiSignerCryptProv;
        rgSignerEncodeInfo[1].HashAlgorithm =
            SignDigestAlgorithms[SIGNDIGEST_ALG_SHA];
        rgSignerEncodeInfo[1].pvHashAuxInfo = NULL;

        if (fNoSignature) {
            rgSignerEncodeInfo[1].HashEncryptionAlgorithm.pszObjId =
                szOID_PKIX_NO_SIGNATURE;
        }

        if (fAuthAttr) {
            rgSignerEncodeInfo[1].cAuthAttr = AUTH_ATTR_COUNT;
            rgSignerEncodeInfo[1].rgAuthAttr = rgAuthAttr;

            if (!fCountersign) {
                rgSignerEncodeInfo[1].cUnauthAttr = UNAUTH_ATTR_COUNT;
                rgSignerEncodeInfo[1].rgUnauthAttr = rgUnauthAttr;
            }
        }

        if (fSignerId)
            rgSignerEncodeInfo[1].SignerId = rgSignerId[1];
    }

    if (fSignerId) {
        rgSignerEncodeInfo[0].SignerId = rgSignerId[0];
        if (fHashEncryptionAlgorithm)
            rgSignerEncodeInfo[0].pCertInfo = NULL;
    }
#endif  // CMS_PKCS7

}

void CleanupSignerEncodeInfo()
{
	free( rgSignerCertInfo[0].Issuer.pbData);
#ifdef CMS_PKCS7
    if (fMultiSigner)
        free( rgSignerCertInfo[1].Issuer.pbData);
#endif  // CMS_PKCS7
}

void InitSignedCertAndCrl()
{
    DWORD i;

#ifdef CMS_PKCS7
    if (rgSignedCertBlob[0].pbData)
        return;
#endif  // CMS_PKCS7

    for (i = 0; i < SIGNED_CERT_COUNT; i++) {
    	GetDERFromFile(
            rgpszSignedCertFileName[i],
            &rgSignedCertBlob[i].pbData,
            &rgSignedCertBlob[i].cbData);
    }
#ifdef CMS_PKCS7
    for (i = 0; i < SIGNED_CRL_COUNT; i++) {
    	GetDERFromFile(
            rgpszSignedCrlFileName[i],
            &rgSignedCrlBlob[i].pbData,
            &rgSignedCrlBlob[i].cbData);
    }

    for (i = 0; i < ATTR_CERT_COUNT; i++) {
    	GetDERFromFile(
            rgpszAttrCertFileName[i],
            &rgAttrCertBlob[i].pbData,
            &rgAttrCertBlob[i].cbData);
    }
#endif  // CMS_PKCS7
}

void CleanupSignedCertAndCrl()
{
    DWORD i;

    for (i = 0; i < SIGNED_CERT_COUNT; i++) {
        if (rgSignedCertBlob[i].pbData) {
            free( rgSignedCertBlob[i].pbData);
            rgSignedCertBlob[i].pbData = NULL;
        }
    }

#ifdef CMS_PKCS7
    for (i = 0; i < SIGNED_CRL_COUNT; i++) {
        if (rgSignedCrlBlob[i].pbData) {
            free( rgSignedCrlBlob[i].pbData);
            rgSignedCrlBlob[i].pbData = NULL;
        }
    }

    for (i = 0; i < ATTR_CERT_COUNT; i++) {
        if (rgAttrCertBlob[i].pbData) {
            free( rgAttrCertBlob[i].pbData);
            rgAttrCertBlob[i].pbData = NULL;
        }
    }
#endif  // CMS_PKCS7
}

void InitSignedMsgEncodeInfo(
    OUT PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    )
{
    InitSignerEncodeInfo();
    pSignedMsgEncodeInfo->cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);
    pSignedMsgEncodeInfo->cSigners = fNoSigners ? 0 : 1;
#ifdef CMS_PKCS7
    if (fMultiSigner)
        pSignedMsgEncodeInfo->cSigners = 2;
#endif  // CMS_PKCS7
    pSignedMsgEncodeInfo->rgSigners = &rgSignerEncodeInfo[0];
    InitSignedCertAndCrl();
    pSignedMsgEncodeInfo->cCertEncoded = cSignedCert;
    pSignedMsgEncodeInfo->rgCertEncoded = rgSignedCertBlob;
#ifdef CMS_PKCS7
    pSignedMsgEncodeInfo->cCrlEncoded = cSignedCrl;
    pSignedMsgEncodeInfo->rgCrlEncoded = rgSignedCrlBlob;
#else
    pSignedMsgEncodeInfo->cCrlEncoded = 0;
    pSignedMsgEncodeInfo->rgCrlEncoded = NULL;
#endif
#ifdef CMS_PKCS7
    pSignedMsgEncodeInfo->cAttrCertEncoded = cAttrCert;
    pSignedMsgEncodeInfo->rgAttrCertEncoded = rgAttrCertBlob;
#endif  // CMS_PKCS7
}

void CleanupSignedMsgEncodeInfo(
    IN PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    )
{
    CleanupSignerEncodeInfo();
    CleanupSignedCertAndCrl();
}

void InitRecipientEncodeInfo()
{
    DWORD cbRecipientPublicKeyData;
    int i;

    // Get crypt provider's public exchange key. It will be used as the
    // recipient's public key
    cbRecipientPublicKeyData = sizeof(RecipientPublicKeyData.Data);
    memset(RecipientPublicKeyData.Data, 0, cbRecipientPublicKeyData);
    CryptExportPublicKeyInfo(
        hCryptProv,
        AT_KEYEXCHANGE,
        X509_ASN_ENCODING,
        (PCERT_PUBLIC_KEY_INFO) RecipientPublicKeyData.Data,
        &cbRecipientPublicKeyData);

    // Update the Issuer, SerialNumber, PublicKey and PublicKeyAlgorithm
    // for each recipient. Update the rgpRecipientCertInfo[].
    for (i = 0; i < RECIPIENT_COUNT; i++) {
        memset(&rgRecipientCertInfo[i], 0, sizeof(CERT_INFO));

#ifdef CMS_PKCS7
        if (fCertInfoKeyId) {
            CreateIssuerAndSerialNumberFromKeyId(
                (const BYTE *)rgpszRecipientIssuerFileName[i],
                strlen(rgpszRecipientIssuerFileName[i]),
                &rgRecipientCertInfo[i]
                );
        } else {
#endif
	    GetDERFromFile(
            rgpszRecipientIssuerFileName[i],
            &rgRecipientCertInfo[i].Issuer.pbData,
            &rgRecipientCertInfo[i].Issuer.cbData);
        rgRecipientCertInfo[i].SerialNumber.cbData = sizeof(DWORD);
        rgRecipientCertInfo[i].SerialNumber.pbData =
            (BYTE *) &rgdwRecipientSerialNumber[i];

#ifdef CMS_PKCS7
        }
#endif

        rgRecipientCertInfo[i].SubjectPublicKeyInfo = 
            *((PCERT_PUBLIC_KEY_INFO) RecipientPublicKeyData.Data);

        if (0 == i)
            rgRecipientCertInfo[i].SubjectPublicKeyInfo.Algorithm.pszObjId =
                szOID_OIWSEC_rsaXchg;

        rgpRecipientCertInfo[i] = &rgRecipientCertInfo[i];
    }
}

void CleanupRecipientEncodeInfo()
{
    int i;

    for (i = 0; i < RECIPIENT_COUNT; i++)
        free( rgRecipientCertInfo[i].Issuer.pbData);
}

#ifdef CMS_PKCS7

HCRYPTKEY
WINAPI
GenerateMailListKey(
    IN HCRYPTPROV hProv,
    IN PCRYPT_DATA_BLOB pKeyId
    )
{
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hDeriveKey = 0;
    ALG_ID AlgId;

    // Generate derive key to use to encrypt and export the content encrypt key
    if (!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash)) {
        PrintLastError("CryptCreateHash");
        goto ErrorReturn;
    }
    if (!CryptHashData(hHash, pKeyId->pbData, pKeyId->cbData, 0)) {
        PrintLastError("CryptHashData");
        goto ErrorReturn;
    }

    if (0 == _stricmp(pszEncryptName, "rc2"))
        AlgId = CALG_RC2;
    else
        AlgId = CALG_3DES;
    if (!CryptDeriveKey(hProv, AlgId, hHash, 0, &hDeriveKey)) {
        PrintLastError("CryptDeriveKey");
        goto ErrorReturn;
    }

CommonReturn:
    if (hHash)
        CryptDestroyHash(hHash);
    return hDeriveKey;
ErrorReturn:
    goto CommonReturn;
}

void InitCmsRecipientEncodeInfo(
    OUT PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    )
{
    PCERT_PUBLIC_KEY_INFO pPublicKeyInfo;
    DWORD cbRecipientPublicKeyData;
    DWORD i;
    DWORD cRecipients = 0;

    // Get crypt provider's public exchange key. It will be used as the
    // recipient's public key
    cbRecipientPublicKeyData = sizeof(RecipientPublicKeyData.Data);
    memset(RecipientPublicKeyData.Data, 0, cbRecipientPublicKeyData);
    CryptExportPublicKeyInfo(
        hCryptProv,
        AT_KEYEXCHANGE,
        X509_ASN_ENCODING,
        (PCERT_PUBLIC_KEY_INFO) RecipientPublicKeyData.Data,
        &cbRecipientPublicKeyData);
    pPublicKeyInfo = (PCERT_PUBLIC_KEY_INFO) RecipientPublicKeyData.Data;

    if (fKeyTrans && fRecipientKeyId) {
        PkcsRecipientCount = RECIPIENT_COUNT * 2;

        for (i = 0; i < RECIPIENT_COUNT; i++) {
            PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTrans =
                &rgKeyTrans[cRecipients];

            rgCmsRecipient[cRecipients].dwRecipientChoice =
                CMSG_KEY_TRANS_RECIPIENT;
            rgCmsRecipient[cRecipients].pKeyTrans = pKeyTrans;

            memset(pKeyTrans, 0, sizeof(*pKeyTrans));
            pKeyTrans->cbSize = sizeof(*pKeyTrans);
            pKeyTrans->KeyEncryptionAlgorithm = pPublicKeyInfo->Algorithm;
            // pKeyTrans->pvKeyEncryptionAuxInfo =
            // pKeyTrans->hCryptProv =
            pKeyTrans->RecipientPublicKey = pPublicKeyInfo->PublicKey;
            pKeyTrans->RecipientId.dwIdChoice = CERT_ID_KEY_IDENTIFIER;
            pKeyTrans->RecipientId.KeyId.pbData = 
                (PBYTE) rgpszRecipientIssuerFileName[i];
            pKeyTrans->RecipientId.KeyId.cbData = 
                strlen(rgpszRecipientIssuerFileName[i]);

            cRecipients++;
        }
    }

    if (fKeyTrans) {
        for (i = 0; i < RECIPIENT_COUNT; i++) {
            PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTrans =
                &rgKeyTrans[cRecipients];

            rgCmsRecipient[cRecipients].dwRecipientChoice =
                CMSG_KEY_TRANS_RECIPIENT;
            rgCmsRecipient[cRecipients].pKeyTrans = pKeyTrans;

            memset(pKeyTrans, 0, sizeof(*pKeyTrans));
            pKeyTrans->cbSize = sizeof(*pKeyTrans);
            pKeyTrans->KeyEncryptionAlgorithm = pPublicKeyInfo->Algorithm;
            // pKeyTrans->pvKeyEncryptionAuxInfo =
            // pKeyTrans->hCryptProv =
            pKeyTrans->RecipientPublicKey = pPublicKeyInfo->PublicKey;
            pKeyTrans->RecipientId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
            GetDERFromFile(
                rgpszRecipientIssuerFileName[i],
                &pKeyTrans->RecipientId.IssuerSerialNumber.Issuer.pbData,
                &pKeyTrans->RecipientId.IssuerSerialNumber.Issuer.cbData
                );
            pKeyTrans->RecipientId.IssuerSerialNumber.SerialNumber.cbData =
                sizeof(DWORD);
            pKeyTrans->RecipientId.IssuerSerialNumber.SerialNumber.pbData =
                (BYTE *) &rgdwRecipientSerialNumber[i];

            if (fRecipientProv)
                pKeyTrans->hCryptProv = GetCryptProv();

            cRecipients++;
        }
    }

    if (fKeyAgree) {
        void *pvStructInfo;
        DWORD cbStructInfo;

        cbRecipientPublicKeyData = sizeof(KeyAgreePublicKeyData.Data);
        memset(KeyAgreePublicKeyData.Data, 0, cbRecipientPublicKeyData);
        CryptExportPublicKeyInfo(
            hKeyAgreeProv,
            AT_KEYEXCHANGE,
            X509_ASN_ENCODING,
            (PCERT_PUBLIC_KEY_INFO) KeyAgreePublicKeyData.Data,
            &cbRecipientPublicKeyData);
        pPublicKeyInfo = (PCERT_PUBLIC_KEY_INFO) KeyAgreePublicKeyData.Data;

        // Check that we can decode both as X509_DH_PARAMETERS and
        // X942_DH_PARAMETERS
        AllocAndDecodeObject(
            X509_DH_PARAMETERS,
            pPublicKeyInfo->Algorithm.Parameters.pbData,
            pPublicKeyInfo->Algorithm.Parameters.cbData,
            &pvStructInfo,
            &cbStructInfo
            );
        TestFree(pvStructInfo);
        AllocAndDecodeObject(
            X942_DH_PARAMETERS,
            pPublicKeyInfo->Algorithm.Parameters.pbData,
            pPublicKeyInfo->Algorithm.Parameters.cbData,
            &pvStructInfo,
            &cbStructInfo
            );
        TestFree(pvStructInfo);

        for (i = 0; i < RECIPIENT_COUNT; i++) {
            PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgree =
                &rgKeyAgree[cRecipients];
            PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO pEncryptedKey =
                &rgEncryptedKey[i];

            rgCmsRecipient[cRecipients].dwRecipientChoice =
                CMSG_KEY_AGREE_RECIPIENT;
            rgCmsRecipient[cRecipients].pKeyAgree = pKeyAgree;

            memset(pKeyAgree, 0, sizeof(*pKeyAgree));
            pKeyAgree->cbSize = sizeof(*pKeyAgree);

            pKeyAgree->KeyEncryptionAlgorithm.pszObjId =
                szOID_RSA_SMIMEalgESDH;

            if (0 == _stricmp(pszEncryptName, "rc2")) {
                pKeyAgree->KeyWrapAlgorithm.pszObjId =
                    szOID_RSA_SMIMEalgCMSRC2wrap;

                // Update pvKeyWrapAuxInfo or KeyWrapAlgorithm
                // Parameters
                if (0 != dwEncryptBitLen) {
                    if (0 == i) {
                        int iVersion;

                        switch (dwEncryptBitLen) {
                            case 40:
                                iVersion = CRYPT_RC2_40BIT_VERSION;
                                break;
                            case 56:
                                iVersion = CRYPT_RC2_56BIT_VERSION;
                                break;
                            case 64:
                                iVersion = CRYPT_RC2_64BIT_VERSION;
                                break;
                            case 128:
                                iVersion = CRYPT_RC2_128BIT_VERSION;
                                break;
                            default:
                                printf("Failed => unknown RC2 length (%d)\n", dwEncryptBitLen);
                                iVersion = 0;
                        }

                        AllocAndEncodeObject(
                            X509_INTEGER,
                            &iVersion,
                            &pKeyAgree->KeyWrapAlgorithm.Parameters.pbData,
                            &pKeyAgree->KeyWrapAlgorithm.Parameters.cbData);
                    } else {
                        KeyAgreeRC2AuxInfo.cbSize = sizeof(KeyAgreeRC2AuxInfo);
                        KeyAgreeRC2AuxInfo.dwBitLen = dwEncryptBitLen;
                        pKeyAgree->pvKeyWrapAuxInfo =
                            &KeyAgreeRC2AuxInfo;
                    }
                }
            } else {
                pKeyAgree->KeyWrapAlgorithm.pszObjId =
                    szOID_RSA_SMIMEalgCMS3DESwrap;
            }

            if (fRecipientProv)
                pKeyAgree->hCryptProv = GetCryptProv(PROV_DSS_DH, NULL);


            pKeyAgree->dwKeyChoice = CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE;
            pKeyAgree->pEphemeralAlgorithm = &pPublicKeyInfo->Algorithm;

            if (1 == i) {
                pKeyAgree->UserKeyingMaterial.cbData =
                    strlen(pszUserKeyingMaterial);
                pKeyAgree->UserKeyingMaterial.pbData =
                    (BYTE *) pszUserKeyingMaterial;
            }

            pKeyAgree->cRecipientEncryptedKeys = i + 1;
            pKeyAgree->rgpRecipientEncryptedKeys = rgpEncryptedKey;

            rgpEncryptedKey[i] = pEncryptedKey;
            memset(pEncryptedKey, 0, sizeof(*pEncryptedKey));
            pEncryptedKey->cbSize = sizeof(*pEncryptedKey);
            pEncryptedKey->RecipientPublicKey = pPublicKeyInfo->PublicKey;

            if (fRecipientKeyId) {
                pEncryptedKey->RecipientId.dwIdChoice = CERT_ID_KEY_IDENTIFIER;
                pEncryptedKey->RecipientId.KeyId.pbData = 
                    (PBYTE) rgpszRecipientIssuerFileName[i];
                pEncryptedKey->RecipientId.KeyId.cbData = 
                    strlen(rgpszRecipientIssuerFileName[i]);

                if (1 == i) {
                    SYSTEMTIME st;

                    GetSystemTime(&st);
                    SystemTimeToFileTime(&st, &pEncryptedKey->Date);
                    pEncryptedKey->pOtherAttr = &KeyAgreeOtherAttr;
                }
            } else {
                pEncryptedKey->RecipientId.dwIdChoice =
                    CERT_ID_ISSUER_SERIAL_NUMBER;
                GetDERFromFile(
                    rgpszRecipientIssuerFileName[i],
                    &pEncryptedKey->RecipientId.IssuerSerialNumber.Issuer.pbData,
                    &pEncryptedKey->RecipientId.IssuerSerialNumber.Issuer.cbData
                    );
                pEncryptedKey->RecipientId.IssuerSerialNumber.SerialNumber.cbData =
                    sizeof(DWORD);
                pEncryptedKey->RecipientId.IssuerSerialNumber.SerialNumber.pbData =
                    (BYTE *) &rgdwRecipientSerialNumber[i];
            }

            cRecipients++;
        }
    }

    if (fMailList) {
        for (i = 0; i < RECIPIENT_COUNT; i++) {
            PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailList =
                &rgMailList[cRecipients];

            rgCmsRecipient[cRecipients].dwRecipientChoice =
                CMSG_MAIL_LIST_RECIPIENT;
            rgCmsRecipient[cRecipients].pMailList = pMailList;

            memset(pMailList, 0, sizeof(*pMailList));
            pMailList->cbSize = sizeof(*pMailList);

            if (0 == _stricmp(pszEncryptName, "rc2")) {
                pMailList->KeyEncryptionAlgorithm.pszObjId =
                    szOID_RSA_SMIMEalgCMSRC2wrap;

                // Update pvKeyEncryptionAuxInfo or KeyEncryptionAlgorithm
                // Parameters
                if (0 != dwEncryptBitLen) {
                    if (0 == i) {
                        int iVersion;

                        switch (dwEncryptBitLen) {
                            case 40:
                                iVersion = CRYPT_RC2_40BIT_VERSION;
                                break;
                            case 56:
                                iVersion = CRYPT_RC2_56BIT_VERSION;
                                break;
                            case 64:
                                iVersion = CRYPT_RC2_64BIT_VERSION;
                                break;
                            case 128:
                                iVersion = CRYPT_RC2_128BIT_VERSION;
                                break;
                            default:
                                printf("Failed => unknown RC2 length (%d)\n", dwEncryptBitLen);
                                iVersion = 0;
                        }

                        AllocAndEncodeObject(
                            X509_INTEGER,
                            &iVersion,
                            &pMailList->KeyEncryptionAlgorithm.Parameters.pbData,
                            &pMailList->KeyEncryptionAlgorithm.Parameters.cbData);
                    } else {
                        MailListRC2AuxInfo.cbSize = sizeof(MailListRC2AuxInfo);
                        MailListRC2AuxInfo.dwBitLen = dwEncryptBitLen;
                        pMailList->pvKeyEncryptionAuxInfo =
                            &MailListRC2AuxInfo;
                    }
                }
            } else {
                pMailList->KeyEncryptionAlgorithm.pszObjId =
                    szOID_RSA_SMIMEalgCMS3DESwrap;
            }

            pMailList->KeyId.pbData = 
                (PBYTE) rgpszRecipientIssuerFileName[i];
            pMailList->KeyId.cbData = 
                strlen(rgpszRecipientIssuerFileName[i]);

            if (fRecipientProv)
                pMailList->hCryptProv = GetCryptProv();
            else
                pMailList->hCryptProv = hCryptProv;
            pMailList->dwKeyChoice = CMSG_MAIL_LIST_HANDLE_KEY_CHOICE;
            pMailList->hKeyEncryptionKey = GenerateMailListKey(
                pMailList->hCryptProv,
                &pMailList->KeyId
                );

            if (0 != i) {
                SYSTEMTIME st;
                GetSystemTime(&st);
                SystemTimeToFileTime(&st, &pMailList->Date);

                pMailList->pOtherAttr = &MailListOtherAttr;
            }

            cRecipients++;
        }
    }

    pEnvelopedMsgEncodeInfo->cRecipients = cRecipients;
    cCmsRecipients = cRecipients;
    pEnvelopedMsgEncodeInfo->rgpRecipients = NULL;
    pEnvelopedMsgEncodeInfo->rgCmsRecipients = rgCmsRecipient;
    fNoRecipients = FALSE;
}

void CleanupCmsRecipientEncodeInfo()
{
    DWORD i;

    for (i = 0; i < cCmsRecipients; i++) {
        switch (rgCmsRecipient[i].dwRecipientChoice) {
            case CMSG_KEY_TRANS_RECIPIENT:
                {
                    PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTrans =
                        &rgKeyTrans[i];
                    if (CERT_ID_ISSUER_SERIAL_NUMBER ==
                            pKeyTrans->RecipientId.dwIdChoice)
                        free(pKeyTrans->RecipientId.IssuerSerialNumber.Issuer.pbData);
                    if (pKeyTrans->hCryptProv)
                        CryptReleaseContext(pKeyTrans->hCryptProv, 0);
                }
                break;
            case CMSG_KEY_AGREE_RECIPIENT:
                {
                    PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgree =
                        &rgKeyAgree[i];

                    TestFree(
                        pKeyAgree->KeyEncryptionAlgorithm.Parameters.pbData);
                    TestFree(pKeyAgree->KeyWrapAlgorithm.Parameters.pbData);

                    if (pKeyAgree->hCryptProv)
                        CryptReleaseContext(pKeyAgree->hCryptProv, 0);
                }
                break;
            case CMSG_MAIL_LIST_RECIPIENT:
                {
                    PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailList =
                        &rgMailList[i];
                    TestFree(
                        pMailList->KeyEncryptionAlgorithm.Parameters.pbData);
                    if (pMailList->hCryptProv &&
                            pMailList->hCryptProv != hCryptProv)
                        CryptReleaseContext(pMailList->hCryptProv, 0);
                    if (pMailList->hKeyEncryptionKey)
                        CryptDestroyKey(pMailList->hKeyEncryptionKey);
                }
                break;
        }
    }

    if (fKeyAgree) {
        for (i = 0; i < RECIPIENT_COUNT; i++) {
            PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO pEncryptedKey =
                &rgEncryptedKey[i];

            if (CERT_ID_ISSUER_SERIAL_NUMBER ==
                    pEncryptedKey->RecipientId.dwIdChoice)
                free(pEncryptedKey->RecipientId.IssuerSerialNumber.Issuer.pbData);
        }
    }
}

#endif  // CMS_PKCS7

#define IV_LENGTH 8
static BOOL GetIV(BYTE rgbIV[IV_LENGTH])
{

    SYSTEMTIME st;
    GetSystemTime(&st);
    assert(IV_LENGTH == sizeof(FILETIME));
    SystemTimeToFileTime(&st, (LPFILETIME) rgbIV);
    return TRUE;
}

void InitEnvelopedMsgEncodeInfo(
    OUT PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    )
{
    PCRYPT_OBJID_BLOB pAlgPara;

    InitRecipientEncodeInfo();

    pEnvelopedMsgEncodeInfo->cbSize = sizeof(CMSG_ENVELOPED_ENCODE_INFO);
    pEnvelopedMsgEncodeInfo->hCryptProv = hDefaultVerifyProv;
    pEnvelopedMsgEncodeInfo->pvEncryptionAuxInfo = NULL;
    pEnvelopedMsgEncodeInfo->cRecipients = fNoRecipients ? 0 : RECIPIENT_COUNT;
    pEnvelopedMsgEncodeInfo->rgpRecipients = rgpRecipientCertInfo;
#ifdef CMS_PKCS7
    if (fCmsRecipient)
        InitCmsRecipientEncodeInfo(pEnvelopedMsgEncodeInfo);

    if (fOriginatorInfo) {
        InitSignedCertAndCrl();
        pEnvelopedMsgEncodeInfo->cCertEncoded = cSignedCert;
        pEnvelopedMsgEncodeInfo->rgCertEncoded = rgSignedCertBlob;
        pEnvelopedMsgEncodeInfo->cCrlEncoded = cSignedCrl;
        pEnvelopedMsgEncodeInfo->rgCrlEncoded = rgSignedCrlBlob;
        pEnvelopedMsgEncodeInfo->cAttrCertEncoded = cAttrCert;
        pEnvelopedMsgEncodeInfo->rgAttrCertEncoded = rgAttrCertBlob;
    }

    if (fAuthAttr) {
        pEnvelopedMsgEncodeInfo->cUnprotectedAttr = AUTH_ATTR_COUNT;
        pEnvelopedMsgEncodeInfo->rgUnprotectedAttr = rgAuthAttr;
    }
#endif  // CMS_PKCS7

    pEnvelopedMsgEncodeInfo->ContentEncryptionAlgorithm.pszObjId =
        (LPSTR) pszEncryptOID;
    pAlgPara = &pEnvelopedMsgEncodeInfo->ContentEncryptionAlgorithm.Parameters;
    memset(pAlgPara, 0, sizeof(*pAlgPara));

    if (0 != dwEncryptBitLen && 0 == _stricmp(pszEncryptName, "rc2")) {
        CRYPT_RC2_CBC_PARAMETERS RC2Parameters;

        switch (dwEncryptBitLen) {
            case 40:
                RC2Parameters.dwVersion = CRYPT_RC2_40BIT_VERSION;
                break;
            case 56:
                RC2Parameters.dwVersion = CRYPT_RC2_56BIT_VERSION;
                break;
            case 64:
                RC2Parameters.dwVersion = CRYPT_RC2_64BIT_VERSION;
                break;
            case 128:
                RC2Parameters.dwVersion = CRYPT_RC2_128BIT_VERSION;
                break;
            default:
                printf("Failed => unknown RC2 length (%d)\n", dwEncryptBitLen);
                return;
        }
        RC2Parameters.fIV = fEncryptIV;
        if (fEncryptIV) {
            if (!GetIV(RC2Parameters.rgbIV))
                return;
        }

        if (!AllocAndEncodeObject(
                PKCS_RC2_CBC_PARAMETERS,
                &RC2Parameters,
                &pAlgPara->pbData,
                &pAlgPara->cbData))
            return;
    } else if (0 == _stricmp(pszEncryptName, "rc4")) {
        if (fEncryptIV) {
            CRYPT_DATA_BLOB Salt;
            DWORD i;

            for (i = 0; i < MAX_SALT_LEN; i++)
                rgbSalt[i] = (BYTE) i;

            Salt.cbData = MAX_SALT_LEN;
            Salt.pbData = rgbSalt;

            AllocAndEncodeObject(
                X509_OCTET_STRING,
                &Salt,
                &pAlgPara->pbData,
                &pAlgPara->cbData
                );
        } else if (0 != dwEncryptBitLen) {
            memset(&RC4AuxInfo, 0, sizeof(RC4AuxInfo));
            RC4AuxInfo.cbSize = sizeof(RC4AuxInfo);
            RC4AuxInfo.dwBitLen = dwEncryptBitLen;
            if (fNoSalt)
                RC4AuxInfo.dwBitLen |= CMSG_RC4_NO_SALT_FLAG;
            pEnvelopedMsgEncodeInfo->pvEncryptionAuxInfo = &RC4AuxInfo;
        }
    } else if (fEncryptIV) {
        BYTE rgbIV[IV_LENGTH];
        CRYPT_DATA_BLOB Data;

        Data.pbData = rgbIV;
        Data.cbData = sizeof(rgbIV);

        if (!GetIV(rgbIV))
            return;
        if (!AllocAndEncodeObject(
                X509_OCTET_STRING,
                &Data,
                &pAlgPara->pbData,
                &pAlgPara->cbData))
            return;
    }
}


void CleanupEnvelopedMsgEncodeInfo(
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    )
{
    TestFree(
        pEnvelopedMsgEncodeInfo->ContentEncryptionAlgorithm.Parameters.pbData);
    CleanupRecipientEncodeInfo();
#ifdef CMS_PKCS7
    if (fCmsRecipient)
        CleanupCmsRecipientEncodeInfo();
    if (fOriginatorInfo)
        CleanupSignedCertAndCrl();
#endif  // CMS_PKCS7
}


//+-------------------------------------------------------------------------
//  Add and delete items
//--------------------------------------------------------------------------
BOOL AddDelItems(
        IN HCRYPTMSG    hCryptMsg,
        IN DWORD        dwCountType,
        IN DWORD        dwAddAction,
        IN DWORD        dwDelAction,
        IN void const  *pvCtrlPara)
{
    BOOL    fRet;
    DWORD   cb;
    DWORD   cOrg;
    DWORD   cCurr;

    // Get the original count of items
    cb = sizeof(cOrg);
    if (!CryptMsgGetParam(
            hCryptMsg,
            dwCountType,
            0,                              // dwIndex
            &cOrg,
            &cb))
        goto GetItemCountError;
    // Add an item
    if (!CryptMsgControl(
            hCryptMsg,
            0,                              // dwFlags
            dwAddAction,
            pvCtrlPara))
        goto AddItemError;
    // Check that the count of items has increased by 1
    if (!CryptMsgGetParam(
            hCryptMsg,
            dwCountType,
            0,                              // dwIndex
            &cCurr,
            &cb))
        goto GetItemCountAddError;
    if (cCurr != (cOrg + 1))
        goto AddCountError;

    // Delete the item we just added.
    // Since new items get added to the tail, we use the count of items
    // prior to the add as the index of the new item.
    if (!CryptMsgControl(
            hCryptMsg,
            0,                              // dwFlags
            dwDelAction,
            &cOrg))
        goto DelItemError;
    // Check that the count of items is back to what it was
    if (!CryptMsgGetParam(
            hCryptMsg,
            dwCountType,
            0,                              // dwIndex
            &cCurr,
            &cb))
        goto GetItemCountDelError;
    if (cCurr != cOrg)
        goto DelCountError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
PRINT_ERROR(AddDelItems,GetItemCountError)
PRINT_ERROR(AddDelItems,AddItemError)
PRINT_ERROR(AddDelItems,GetItemCountAddError)
PRINT_ERROR(AddDelItems,AddCountError)
PRINT_ERROR(AddDelItems,DelItemError)
PRINT_ERROR(AddDelItems,GetItemCountDelError)
PRINT_ERROR(AddDelItems,DelCountError)
}


//+-------------------------------------------------------------------------
//  Insert blob at the tail of a blob list
//--------------------------------------------------------------------------
BOOL
WINAPI
TCM_InsertTailBlob(
    IN OUT CBlobList    *pBlobList,
    IN PBYTE            pbIn,
    IN DWORD            cbIn)
{
    BOOL                    fRet;
    CBlobNode               *pnBlob = NULL;
    PBYTE                   pb = NULL;
    CRYPT_DATA_BLOB         blob;

    if (NULL == (pnBlob = new CBlobNode))
        goto NewCBlobNodeError;
    if (NULL == (pb = (PBYTE)TestAlloc( cbIn)))
        goto AllocError;
    memcpy( pb, pbIn, cbIn);
    blob.cbData = cbIn;
    blob.pbData = pb;
    pnBlob->SetData( &blob);
    pBlobList->InsertTail( pnBlob);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    TestFree( pb);
    goto CommonReturn;
PRINT_ERROR(TCM_InsertTailBlob,NewCBlobNodeError)
PRINT_ERROR(TCM_InsertTailBlob,AllocError)
}

#ifdef CMS_PKCS7
BOOL VerifyCerts(IN HCRYPTMSG hMsg);
BOOL VerifyUnprotectedAttr(IN HCRYPTMSG hMsg);
BOOL GetCmsRecipientInfoAndDecrypt(IN HCRYPTMSG hMsg);
#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
// Get message type, recipient info, and set the hProv needed to decrypt
// the message.
//--------------------------------------------------------------------------
BOOL StreamGetRecipientInfoAndSetHProv(
    IN HCRYPTMSG    hMsg,
    OUT PDWORD      pdwMsgType,
    OUT BOOL        *pfReady)
{
    BOOL                    fRet;
    PCERT_INFO              pRecipientInfo = NULL;
    DWORD                   cRecipient;
    DWORD                   cbData;
    DWORD                   dwIndex;
    CMSG_CTRL_DECRYPT_PARA  DecryptPara;        ZEROSTRUCT(DecryptPara);
    DWORD                   cbEnvelopeAlgorithm;
    DWORD                   cKeyIdRecipient;

    // Get the message type.
    cbData = sizeof(DWORD);
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_TYPE_PARAM,
            0,                      // dwIndex
            pdwMsgType,
            &cbData)) {
        if (GetLastError() != CRYPT_E_STREAM_MSG_NOT_READY)
            goto GetMessageTypeError;
        *pfReady = FALSE;
        goto SuccessReturn;
    }
    if (CMSG_ENVELOPED != *pdwMsgType) {
        *pfReady = TRUE;
        goto SuccessReturn;
    }

    // Get content encryption algorithm.
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_ENVELOPE_ALGORITHM_PARAM,
            0,                      // dwIndex
            NULL,
            &cbEnvelopeAlgorithm)) {
        if (GetLastError() != CRYPT_E_STREAM_MSG_NOT_READY)
            goto GetEnvelopeAlgorithmError;
        *pfReady = FALSE;
        goto SuccessReturn;
    }
    *pfReady = TRUE;

    // Get # of recipients in the message.
    cbData = sizeof(cRecipient);
    cRecipient = 0;
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_RECIPIENT_COUNT_PARAM,
            0,                      // dwIndex
            &cRecipient,
            &cbData))
        goto GetRecipientCountError;
    if (!TCM_CheckGetParam(
            hMsg,
            CMSG_RECIPIENT_COUNT_PARAM,
            0,                      // dwIndex
            &cRecipient,
            cbData))
        goto CheckGetRecipientCountError;
    if (fNoRecipients) {
        if (cRecipient != 0)
            goto WrongRecipientCountError;
    } else {
        if (cRecipient != PkcsRecipientCount)
            goto WrongRecipientCountError;
    }

#ifdef CMS_PKCS7
    if (fKeyTrans && fRecipientKeyId && !fNoRecipients) {
        // The first RECIPIENT_COUNT recipients should be KeyId recipients
        cKeyIdRecipient = RECIPIENT_COUNT;

        // Get all the KeyId recipients and verify
        for (dwIndex = 0; dwIndex < RECIPIENT_COUNT; dwIndex++) {
            // Allocate and get the CERT_INFO containing the Special
            // KeyId RecipientId
            PCERT_NAME_INFO pKeyIdName = NULL;
            DWORD cbKeyIdName;

            pRecipientInfo = GetCertIdFromMsg(
                hMsg,
                CMSG_RECIPIENT_INFO_PARAM,
                dwIndex
                );

            if (pRecipientInfo == NULL)
                goto GetRecipientInfoError;

            if (pRecipientInfo->SerialNumber.cbData != 1 ||
                    *pRecipientInfo->SerialNumber.pbData != 0)
                PrintError("StreamGetRecipientInfoAndSetHProv::Bad KeyId SerialNumber");

            // Decode the Issuer Name. It should contain the special KeyId
            // RDN

            if (AllocAndDecodeObject(
                    X509_NAME,
                    pRecipientInfo->Issuer.pbData,
                    pRecipientInfo->Issuer.cbData,
                    (void **) &pKeyIdName,
                    &cbKeyIdName
                    )) {

                    if (pKeyIdName->cRDN != 1 ||
                            pKeyIdName->rgRDN[0].cRDNAttr != 1)
                        PrintError("StreamGetRecipientInfoAndSetHProv::Bad KeyId Issuer");
                    else {
                        PCERT_RDN_ATTR pAttr = pKeyIdName->rgRDN[0].rgRDNAttr;

                        if (0 != strcmp(pAttr->pszObjId, szOID_KEYID_RDN) ||
                                pAttr->dwValueType != CERT_RDN_OCTET_STRING ||
                                pAttr->Value.cbData !=
                                    strlen(rgpszRecipientIssuerFileName[dwIndex]) ||
                                0 != memcmp(pAttr->Value.pbData,
                                    rgpszRecipientIssuerFileName[dwIndex],
                                    pAttr->Value.cbData))
                            PrintError("StreamGetRecipientInfoAndSetHProv::Bad KeyId Issuer");
                    }

                TestFree(pKeyIdName);
            }

            TestFree(pRecipientInfo);
            pRecipientInfo = NULL;
        }
    } else
#endif  // CMS_PKCS7
        cKeyIdRecipient = 0;

    // Get all the non KeyId recipients and verify
    for (dwIndex = 0; dwIndex < cRecipient - cKeyIdRecipient; dwIndex++) {
        // Allocate and get the CERT_INFO containing the RecipientId
        // (Issuer and SerialNumber)
        if (NULL == (pRecipientInfo = GetCertIdFromMsg(
                                    hMsg,
                                    CMSG_RECIPIENT_INFO_PARAM,
                                    cKeyIdRecipient + dwIndex)))
            goto GetRecipientInfoError;
        if (pRecipientInfo->Issuer.cbData !=
                    rgRecipientCertInfo[dwIndex].Issuer.cbData ||
                memcmp(pRecipientInfo->Issuer.pbData,
                    rgRecipientCertInfo[dwIndex].Issuer.pbData,
                    pRecipientInfo->Issuer.cbData) != 0 ||
                pRecipientInfo->SerialNumber.cbData !=
                    rgRecipientCertInfo[dwIndex].SerialNumber.cbData ||
                memcmp(pRecipientInfo->SerialNumber.pbData,
                    rgRecipientCertInfo[dwIndex].SerialNumber.pbData,
                    pRecipientInfo->SerialNumber.cbData) != 0)
            goto BadRecipientInfoError;
        TestFree(pRecipientInfo);
        pRecipientInfo = NULL;
    }

#ifdef CMS_PKCS7
    if (fOriginatorInfo)
        VerifyCerts(hMsg);
    if (fCmsRecipient) {
        fRet = GetCmsRecipientInfoAndDecrypt(hMsg);
        goto CommonReturn;
    }
#endif  // CMS_PKCS7

    if (fNoRecipients)
        goto SuccessReturn;

    DecryptPara.cbSize = sizeof(DecryptPara);
    DecryptPara.hCryptProv = hCryptProv;
    DecryptPara.dwKeySpec = 0;
    DecryptPara.dwRecipientIndex = RECIPIENT_COUNT - 1;
    if (!CryptMsgControl(
            hMsg,
            0,                  // dwFlags
            CMSG_CTRL_DECRYPT,
            &DecryptPara))
        goto SetDecryptParamError;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    TestFree(pRecipientInfo);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
PRINT_ERROR(StreamGetRecipientInfoAndSetHProv,GetEnvelopeAlgorithmError)
PRINT_ERROR(StreamGetRecipientInfoAndSetHProv,GetRecipientCountError)
PRINT_ERROR(StreamGetRecipientInfoAndSetHProv,CheckGetRecipientCountError)
PRINT_ERROR(StreamGetRecipientInfoAndSetHProv,WrongRecipientCountError)
PRINT_ERROR(StreamGetRecipientInfoAndSetHProv,GetRecipientInfoError)
PRINT_ERROR(StreamGetRecipientInfoAndSetHProv,BadRecipientInfoError)
PRINT_ERROR(StreamGetRecipientInfoAndSetHProv,SetDecryptParamError)
PRINT_ERROR(StreamGetRecipientInfoAndSetHProv,GetMessageTypeError)
}


//+-------------------------------------------------------------------------
//  Fill a buffer with content.
//--------------------------------------------------------------------------
BOOL
WINAPI
FillBufferWithContent(
        OUT PBYTE   pbData,
        IN DWORD    cbData)
{
    BOOL    fRet;
    PBYTE   pb;
    DWORD   cb;
    DWORD   i;

    if (fInnerContent) {
        if (!pbInnerContent) {
        	if (!GetDERFromFile(
                    pszInnerContentFileName,
                    &pbInnerContent,
                    &cbInnerContent))
                goto GetDERFromFileError;
        }
        if (iMsgContentOffset + cbData > cbInnerContent)
            goto RequestForTooMuchDataError;
        for (pb=pbData, cb=iMsgContentOffset, i=cbData; i>0; pb++, cb++, i--)
            *pb = pbInnerContent[ cb];
        iMsgContentOffset = cb;
    } else {
        for (pb=pbData, cb=iMsgContentOffset, i=cbData; i>0; pb++, cb++, i--)
            *pb = rgbMsgContentFill[ cb%cbMsgContentFill];
        iMsgContentOffset = cb%cbMsgContentFill;
    }

    fRet = TRUE;
CommonReturn:
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
PRINT_ERROR(FillBufferWithContent,GetDERFromFileError)
PRINT_ERROR(FillBufferWithContent,RequestForTooMuchDataError)
}


//+-------------------------------------------------------------------------
//  Compare a buffer with content.
//--------------------------------------------------------------------------
BOOL
WINAPI
BufferEqualsContent(
        IN PBYTE    pbData,
        IN DWORD    cbData)
{
    BOOL    fRet;
    PBYTE   pb;
    DWORD   cb;
    DWORD   i;

    if (fInnerContent) {
        if (iMsgContentOffset + cbData > cbInnerContent)
            goto RequestForTooMuchDataError;
        for (pb=pbData, cb=iMsgContentOffset, i=cbData; i>0; pb++, cb++, i--)
            if (*pb != pbInnerContent[ cb])
                goto InnerContentNotEqualError;
        iMsgContentOffset = cb;
    } else {
        for (pb=pbData, cb=iMsgContentOffset, i=cbData; i>0; pb++, cb++, i--)
            if (*pb != rgbMsgContentFill[ cb%cbMsgContentFill])
                goto ContentNotEqualError;
        iMsgContentOffset = cb%cbMsgContentFill;
    }

    fRet = TRUE;
CommonReturn:
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
PRINT_ERROR(BufferEqualsContent,RequestForTooMuchDataError)
PRINT_ERROR(BufferEqualsContent,InnerContentNotEqualError)
PRINT_ERROR(BufferEqualsContent,ContentNotEqualError)
}


//+-------------------------------------------------------------------------
//  Callback for streaming messages.
//--------------------------------------------------------------------------
BOOL
WINAPI
StreamCallback(
        IN const void *pvArg,
        IN BYTE *pbData,
        IN DWORD cbData,
        IN BOOL fFinal)
{
    BOOL            fRet;
    CStreamNode     *pnStream = (CStreamNode *)pvArg;
    BOOL            fEncoding = pnStream->Data()->fEncoding;
    CStreamNode     *pnStreamNbr;
    DWORD           cbWritten;

    pnStreamNbr = fEncoding ? pnStream->Prev() : pnStream->Next();
    if (pnStreamNbr) {
        if (!CryptMsgUpdate(
                pnStreamNbr->Data()->hMsg,
                pbData,
                cbData,
                fFinal))
            goto MsgUpdateError;
    } else {
        if (fEncoding) {
            if (!WriteFile(
                        hFileStream,
                        pbData,
                        cbData,
                        &cbWritten,
                        NULL) ||
                    (cbWritten != cbData))
                goto WriteFileError;
        } else {
            if (!WriteFile(
                        hFileStreamDecode,
                        pbData,
                        cbData,
                        &cbWritten,
                        NULL) ||
                    (cbWritten != cbData))
                goto WriteFileDecodeError;
        }
    }

    fRet = TRUE;
CommonReturn:
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
PRINT_ERROR(StreamCallback,MsgUpdateError)
PRINT_ERROR(StreamCallback,WriteFileError)
PRINT_ERROR(StreamCallback,WriteFileDecodeError)
}


//+-------------------------------------------------------------------------
//  Encodes and decodes the streamed message.
//--------------------------------------------------------------------------
BOOL StreamEncodeAndDecodeMsg()
{
    BOOL                fRet;
    CStreamNode         *pnStream = NULL;
    TEST_STREAM_DATA    tsd;                ZEROSTRUCT(tsd);
    PCMSG_STREAM_INFO   pstrmi = NULL;
    PBYTE               pb;
    DWORD               cb;
    LPSTR               psz;
    CHAR                ch;
    DWORD               dwMsgTypeEncodingPrev;
    LPSTR               pszFilenameEncoded = pszFilename ? pszFilename : pszStreamFileName;

    if (INVALID_HANDLE_VALUE == (hFileStream = CreateFile(
            pszFilenameEncoded,
            GENERIC_WRITE,
            0, 
            NULL, 
            CREATE_ALWAYS, 
            0, 
            NULL)))
        goto CreateFileError;

    for (psz=pszStreamMsgTypes, dwMsgTypeEncodingPrev=0; ch=*psz; psz++) {
        switch (ch) {
        case 'd':
        case 'D':
            tsd.dwMsgTypeEncoding   = CMSG_DATA;
            tsd.pvMsgEncodeInfo     = NULL;
            break;
        case 'e':
        case 'E':
            tsd.dwMsgTypeEncoding   = CMSG_ENVELOPED;
            tsd.pvMsgEncodeInfo     = &EnvelopedMsgEncodeInfo;
            break;
        case 's':
        case 'S':
            tsd.dwMsgTypeEncoding   = CMSG_SIGNED;
            tsd.pvMsgEncodeInfo     = &SignedMsgEncodeInfo;
            break;
        default:
            goto InvalidMsgTypeError;
        }
        tsd.dwEncodingType          = dwMsgEncodingType;

        tsd.dwEncodeFlags = 0;
        if ((psz != pszStreamMsgTypes) && (dwMsgTypeEncodingPrev != CMSG_DATA))
            tsd.dwEncodeFlags |= CMSG_BARE_CONTENT_FLAG;
        if (dwMsgTypeEncodingPrev == CMSG_ENVELOPED)
            tsd.dwEncodeFlags |= CMSG_CONTENTS_OCTETS_FLAG;
        if (fBare && (psz == pszStreamMsgTypes))
            tsd.dwEncodeFlags |= CMSG_BARE_CONTENT_FLAG;
#ifdef CMS_PKCS7
        if (fEncapsulatedContent)
            tsd.dwEncodeFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
#endif  // CMS_PKCS7

        tsd.dwDecodeFlags = 0;
        if (fBare && (psz == pszStreamMsgTypes))
            tsd.dwDecodeFlags |= CMSG_BARE_CONTENT_FLAG;

        if (NULL == (pstrmi = (PCMSG_STREAM_INFO)TestAllocZero(
                                        sizeof(CMSG_STREAM_INFO))))
            goto AllocTestStreamInfoError;
        tsd.pStreamInfo         = pstrmi;
        if (NULL == (pnStream = new CStreamNode))
            goto NewNodeError;
        pstrmi->cbContent       = CMSG_INDEFINITE_LENGTH;
        pstrmi->pfnStreamOutput = StreamCallback;
        pstrmi->pvArg           = pnStream;
        pnStream->SetData( &tsd);
        plistStream->InsertTail( pnStream);
        dwMsgTypeEncodingPrev = tsd.dwMsgTypeEncoding;
    }
    pstrmi = NULL;

    if (!StreamEncodeMsg())
        goto EncodeError;

    if (hFileStream != INVALID_HANDLE_VALUE) {
        CloseHandle( hFileStream);
        hFileStream = INVALID_HANDLE_VALUE;
    }

    if (!StreamDecodeMsg())
        goto DecodeError;

    fRet = TRUE;
CommonReturn:
    if (hFileStream != INVALID_HANDLE_VALUE)
        CloseHandle( hFileStream);
#ifndef SAVE_STREAM_FILES
    if (!pszFilename)
        DeleteFile( pszStreamFileName);
#endif // SAVE_STREAM_FILES
    TestFree( pstrmi);
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
PRINT_ERROR(StreamEncodeAndDecodeMsg,CreateFileError)
PRINT_ERROR(StreamEncodeAndDecodeMsg,NewNodeError)
PRINT_ERROR(StreamEncodeAndDecodeMsg,EncodeError)
PRINT_ERROR(StreamEncodeAndDecodeMsg,DecodeError)
PRINT_ERROR(StreamEncodeAndDecodeMsg,InvalidMsgTypeError)
PRINT_ERROR(StreamEncodeAndDecodeMsg,AllocTestStreamInfoError)
}


#ifdef CMS_PKCS7

BOOL VerifyEncodedSignerComputedHash(
    IN LPCSTR pszHdr,
    IN HCRYPTMSG hMsg,
    IN DWORD dwSignerIndex,
    IN PBYTE pbExpectedHash,
    IN DWORD cbExpectedHash
    )
{
    BOOL fResult;
    DWORD cbHash;
    BYTE rgbHash[MAX_HASH_LEN];
    DWORD dwSrcIndex;

    if (fVerbose)
        printf("%s VerifyEncodedSignerComputedHash(Signer[%d])\n",
            pszHdr, dwSignerIndex);

    cbHash = sizeof(rgbHash);
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_COMPUTED_HASH_PARAM,
        dwSignerIndex,
        rgbHash,
        &cbHash
        );
    if (!fResult) {
        printf("%s VerifyEncodedSignerComputedHash::CryptMsgGetParam(Signer[%d])",
            pszHdr, dwSignerIndex);
        PrintLastError("");
    } else if (cbHash != cbExpectedHash ||
            0 != memcmp(rgbHash, pbExpectedHash, cbHash)) {
        fResult = FALSE;
        printf("%s VerifyEncodedSignerComputedHash:: failed => bad hash for Signer[%d]\n",
            pszHdr, dwSignerIndex);
    } else {
        TCM_CheckGetParam(
            hMsg,
            CMSG_COMPUTED_HASH_PARAM,
            dwSignerIndex,
            rgbHash,
            cbHash
            );
    }

    return fResult;
}

BOOL VerifyDecodedSignerComputedHash(
    IN LPCSTR pszHdr,
    IN HCRYPTMSG hMsg,
    IN BOOL fInnerNonData,
    IN DWORD dwSignerIndex,
    IN BYTE rgbExpectedHash[2][MAX_HASH_LEN],
    IN DWORD rgcbExpectedHash[2]
    )
{
    DWORD cbHash;
    BYTE rgbHash[MAX_HASH_LEN];
    DWORD dwSrcIndex;

    if (fVerbose)
        printf("%s VerifyDecodedSignerComputedHash(Signer[%d])\n",
            pszHdr, dwSignerIndex);

    cbHash = sizeof(rgbHash);
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_COMPUTED_HASH_PARAM,
            dwSignerIndex,
            rgbHash,
            &cbHash
            )) {
        printf("%s VerifyDecodedSignerComputedHash(before verify signature)::CryptMsgGetParam(Signer[%d])",
            pszHdr, dwSignerIndex);
        PrintLastError("");
        return FALSE;
    }

    if (pNamedSigner)
        dwSrcIndex = dwSignerIndex;
    else if (!GetSignerInfoAndVerify(
            hMsg,
            fInnerNonData,
            dwSignerIndex,
            &dwSrcIndex
            )) {
        printf("%s VerifyDecodedSignerComputedHash GetSignerInfoAndVerify(Signer[%d]):: failed\n",
            pszHdr, dwSignerIndex);
        return FALSE;
    }

    if (cbHash != rgcbExpectedHash[dwSrcIndex] ||
            0 != memcmp(rgbHash, rgbExpectedHash[dwSrcIndex], cbHash)) {
        printf("%s VerifyDecodedSignerComputedHash(before verify signature):: failed => unexpected hash for Signer[%d]\n",
            pszHdr, dwSignerIndex);
        return FALSE;
    }

    cbHash = sizeof(rgbHash);
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_COMPUTED_HASH_PARAM,
            dwSignerIndex,
            rgbHash,
            &cbHash
            )) {
        printf("%s VerifyDecodedSignerComputedHash(after verify signature)::CryptMsgGetParam(Signer[%d])",
            pszHdr, dwSignerIndex);
        PrintLastError("");
        return FALSE;
    }

    if (cbHash != rgcbExpectedHash[dwSrcIndex] ||
            0 != memcmp(rgbHash, rgbExpectedHash[dwSrcIndex], cbHash)) {
        printf("%s VerifyDecodedSignerComputedHash(after verify signature):: failed => unexpected hash for Signer[%d]\n",
            pszHdr, dwSignerIndex);
        return FALSE;
    } else {
        TCM_CheckGetParam(
            hMsg,
            CMSG_COMPUTED_HASH_PARAM,
            dwSignerIndex,
            rgbHash,
            cbHash
            );
    }

    return TRUE;
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Encodes the streamed message.
//--------------------------------------------------------------------------
BOOL StreamEncodeMsg()
{
    BOOL                fRet;
    CStreamNode         *pnStream;
    PTEST_STREAM_DATA   ptsd;
    HCRYPTMSG           hMsg;
    PBYTE               pb;
    DWORD               cb;
    DWORD               cbRemain;
    BOOL                fFinal;
    DWORD               cbData;
    DWORD               cbDataInner;
    LPSTR               pszInnerContentType;

    if (fVerbose)
        printf( "Beginning stream encode\n");

    if (fInnerContent && !FillBufferWithContent( NULL, 0))  // load inner content
        goto NullFillBufferWithContentError;

    cbDataInner = fInnerContent ? cbInnerContent : cbMsgContent;

    if (fInnerContent &&
#ifdef CMS_PKCS7
            !fEncapsulatedContent &&
#endif  // CMS_PKCS7
            (plistStream->Tail()->Data()->dwMsgTypeEncoding == CMSG_ENVELOPED)) {
        if (!TCM_ExtractContent(
                pbInnerContent,
                cbInnerContent,
                &cbDataInner,
                NULL))                  // ppbContent
            goto ExtractContentError;
    }

    for (pnStream = plistStream->Tail(),
                cbData=cbDataInner,
                pszInnerContentType =
                                fInnerContent ? pszInnerContentObjId : NULL;
            pnStream;
            pnStream = pnStream->Prev()) {
        ptsd = pnStream->Data();
        ptsd->fEncoding = TRUE;
        ptsd->pStreamInfo->cbContent = fIndefinite ? CMSG_INDEFINITE_LENGTH : cbData;
        ptsd->pszInnerContentType = pszInnerContentType;
        if (NULL == (ptsd->hMsg = CryptMsgOpenToEncode(
                ptsd->dwEncodingType,
                ptsd->dwEncodeFlags,
                ptsd->dwMsgTypeEncoding,
                ptsd->pvMsgEncodeInfo,
                pszInnerContentType,
                ptsd->pStreamInfo)))
            goto OpenToEncodeError;
        // NB- from PKCS#7, sec.10.3:
        // An enveloped message encrypts only "the contents octets of a
        // definite-length BER encoding of the content field of the ContentInfo"
        // ie. The identifier and length octets are not included.
        // Ergo, we must ask for the size of the contents octets if the outer
        // message is enveloped.
        if (0 == (cbData = CryptMsgCalculateEncodedLength(
                ptsd->dwEncodingType,
                ptsd->dwEncodeFlags,
                ptsd->dwMsgTypeEncoding,
                ptsd->pvMsgEncodeInfo,
                pszInnerContentType,
                cbData)))
            goto CalculateEncodedLengthError;
        switch(ptsd->dwMsgTypeEncoding) {
        case CMSG_DATA:
            pszInnerContentType = szOID_RSA_data;
            break;
        case CMSG_ENVELOPED:
            pszInnerContentType = szOID_RSA_envelopedData;
            break;
        case CMSG_SIGNED:
            pszInnerContentType = szOID_RSA_signedData;
            break;
        default:
            goto InvalidMsgTypeError;
        }

#ifdef CMS_PKCS7
        if (ptsd->dwMsgTypeEncoding != CMSG_DATA &&
                (fVerbose || fEncapsulatedContent || cAttrCert ||
                    fOriginatorInfo || fCmsRecipient)) {
            BOOL fResult;
            DWORD dwVersion;
            DWORD cbData = sizeof(dwVersion);
            fResult = CryptMsgGetParam(
                ptsd->hMsg,
                CMSG_VERSION_PARAM,
                0,                      // dwIndex
                (PBYTE) &dwVersion,
                &cbData
                );
            if (!fResult)
                PrintLastError("StreamEncodeMsg::CryptMsgGetParam(CMSG_VERSION_PARAM)");
            else
                printf("StreamEncodeMsg(%d - %s) Version:: %d\n",
                    ptsd->dwMsgTypeEncoding, pszInnerContentType, dwVersion);
        }
#endif  // CMS_PKCS7
    }

    hMsg = plistStream->Tail()->Data()->hMsg;
    iMsgContentOffset = 0;
    cbRemain = fInnerContent ? cbInnerContent : cbMsgContent;
    if (0 == cbRemain) {
        if (!CryptMsgUpdate(
                hMsg,
                NULL,
                0,
                TRUE))
            goto UpdateError;
    } else {
        for ( ; cbRemain; cbRemain -= cb) {
            fFinal = (cbRemain <= cbStreamDataDeltaEncode);
            cb = fFinal ? cbRemain : cbStreamDataDeltaEncode;
            FillBufferWithContent( abStreamDataDeltaEncode, cb);
            if (!CryptMsgUpdate(
                    hMsg,
                    (PBYTE)abStreamDataDeltaEncode,
                    cb,
                    fFinal))
                goto UpdateError;
        }
    }

    for (pnStream = plistStream->Head();
            pnStream;
            pnStream = pnStream->Next()) {
        ptsd = pnStream->Data();

        cbData = 0;
        if (CryptMsgGetParam(
                ptsd->hMsg,
                CMSG_CONTENT_PARAM,
                0,                      // dwIndex
                NULL,                   // pvData
                &cbData
                ))
            PrintError("CryptMsgGetParam(CMSG_CONTENT_PARAM) succeeded for streaming");

#ifdef CMS_PKCS7
        if (CMSG_SIGNED == ptsd->dwMsgTypeEncoding && !fNoSigners) {
            DWORD i;
            DWORD c;

            if (fMultiSigner)
                c = 2;
            else
                c = 1;

            for (i = 0; i < c; i++) {
                ptsd->rgcbComputedHash[i] = sizeof(ptsd->rgbComputedHash[i]);
                if (!CryptMsgGetParam(
                        ptsd->hMsg,
                        CMSG_COMPUTED_HASH_PARAM,
                        i,                      // dwSignerIndex
                        ptsd->rgbComputedHash[i],
                        &ptsd->rgcbComputedHash[i]
                        )) {
                    printf("StreamEncodeMsg::CryptMsgGetParam(Signer[%d] CMSG_COMPUTED_HASH_PARAM)",
                        i);
                    PrintLastError("");
                } else
                    VerifyEncodedSignerComputedHash(
                        "StreamEncodeMsg", ptsd->hMsg, i,
                        ptsd->rgbComputedHash[i], ptsd->rgcbComputedHash[i]);
            }
        }
#endif  // CMS_PKCS7

        if (!CryptMsgClose(ptsd->hMsg))
            goto CloseError;
    }

    fRet = TRUE;
CommonReturn:
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
PRINT_ERROR(StreamEncodeMsg,NullFillBufferWithContentError)
PRINT_ERROR(StreamEncodeMsg,ExtractContentError)
PRINT_ERROR(StreamEncodeMsg,InvalidMsgTypeError)
PRINT_ERROR(StreamEncodeMsg,OpenToEncodeError)
PRINT_ERROR(StreamEncodeMsg,CalculateEncodedLengthError)
PRINT_ERROR(StreamEncodeMsg,UpdateError)
PRINT_ERROR(StreamEncodeMsg,CloseError)
}


//+-------------------------------------------------------------------------
//  Decodes the streamed message.
//--------------------------------------------------------------------------
BOOL StreamDecodeMsg()
{
    BOOL fRet;
    CStreamNode         *pnStream;
    PTEST_STREAM_DATA   ptsd;
    HCRYPTMSG           hMsg;
    PBYTE               pb;
    DWORD               cb;
    PBYTE               pbRemain;
    DWORD               cbRemain;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    PBYTE               pbRead = NULL;
    DWORD               cbRead;
    BOOL                fFinal;
    BOOL                fFirst;
    DWORD               cbFile;
    CBlobNode           *pnBlob;
    PCRYPT_DATA_BLOB    pblob;
    BOOL                fInnerNonData;
    DWORD               dwMsgTypeInner;
    LPSTR               pszFilenameEncoded = pszFilename ? pszFilename : pszStreamFileName;

    if (fVerbose)
        printf( "Beginning stream decode\n");

    if (NULL == (pbRead = (PBYTE)TestAlloc(cbStreamDataDeltaDecode)))
        goto AllocDecodeBufferError;

    // Open the messages
    for (pnStream = plistStream->Head();
            pnStream;
            pnStream = pnStream->Next()) {
        ptsd = pnStream->Data();
        ptsd->fEncoding = FALSE;
        fFirst = (NULL == pnStream->Prev());
        if (NULL == (ptsd->hMsg = CryptMsgOpenToDecode(
                ptsd->dwEncodingType,
                ptsd->dwDecodeFlags,
                ((fFirst && fBare) ||
                    (!fFirst && (CMSG_DATA != pnStream->Prev()->Data()->dwMsgTypeEncoding)))
                    ? ptsd->dwMsgTypeEncoding : 0,
                hDefaultVerifyProv,
                NULL,                   // pRecipientInfo
                ptsd->pStreamInfo)))
            goto OpenToDecodeError;
    }

    // Open the file containing the nested messages to decode
    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(
            pszFilenameEncoded,
            GENERIC_READ,
            0, 
            NULL, 
            OPEN_EXISTING, 
            0, 
            NULL)))
        goto CreateFileError;
    if (INVALID_FILE_SIZE == (cbFile = GetFileSize( hFile, NULL)))
        goto GetFileSizeError;

    // Create the file to hold the decoded data
    if (INVALID_HANDLE_VALUE == (hFileStreamDecode = CreateFile(
            pszFilenameDecode,
            GENERIC_WRITE,
            0, 
            NULL, 
            CREATE_ALWAYS, 
            0, 
            NULL)))
        goto CreateFileDecodeError;

    // Feed in the encoded nested messages in chunks
    hMsg = plistStream->Head()->Data()->hMsg;
    for (cbRemain=cbFile; cbRemain; cbRemain-=cbRead) {
        if (!ReadFile(
                hFile,
                pbRead,
                cbStreamDataDeltaDecode,
                &cbRead,
                NULL))              // lpOverlapped
            goto ReadFileError;
        fFinal = (cbRead == cbRemain);
        if (!CryptMsgUpdate(
                hMsg,
                pbRead,
                cbRead,
                fFinal))
            goto UpdateError;
        for (pnStream = plistStream->Head();
                pnStream;
                pnStream = pnStream->Next()) {
            ptsd = pnStream->Data();
            if (((0 == ptsd->dwMsgTypeDecoding) ||
                        (CMSG_ENVELOPED == ptsd->dwMsgTypeDecoding)) &&
                    !ptsd->fReady) {
                if (!StreamGetRecipientInfoAndSetHProv(
                        ptsd->hMsg,
                        &ptsd->dwMsgTypeDecoding,
                        &ptsd->fReady))
                    goto StreamGetRecipientInfoAndSetHProvError;
            }
        }
    }


    // Validate the message types
    for (pnStream = plistStream->Head();
            pnStream;
            pnStream = pnStream->Next()) {
        ptsd = pnStream->Data();
        if (ptsd->dwMsgTypeEncoding != ptsd->dwMsgTypeDecoding)
            goto MsgTypeMismatchError;
    }

    // Check signatures
    if (fVerbose)
        printf( "Verify signatures\n");
    for (pnStream = plistStream->Tail(), dwMsgTypeInner=CMSG_DATA;
            pnStream;
            pnStream = pnStream->Prev()) {
        ptsd = pnStream->Data();
        fInnerNonData = ((pnStream == plistStream->Tail()) && fInnerContent) ||
                        (dwMsgTypeInner != CMSG_DATA);

#ifdef CMS_PKCS7
        if (ptsd->dwMsgTypeDecoding != CMSG_DATA &&
                (fVerbose || fEncapsulatedContent || cAttrCert ||
                    fOriginatorInfo || fCmsRecipient)) {
            BOOL fResult;
            DWORD dwVersion;
            DWORD cbData = sizeof(dwVersion);
            fResult = CryptMsgGetParam(
                ptsd->hMsg,
                CMSG_VERSION_PARAM,
                0,                      // dwIndex
                (PBYTE) &dwVersion,
                &cbData
                );
            if (!fResult)
                PrintLastError("StreamDecodeMsg::CryptMsgGetParam(CMSG_VERSION_PARAM)");
            else
                printf("StreamDecodeMsg(%d) Version:: %d\n",
                    ptsd->dwMsgTypeDecoding, dwVersion);
        }

        if (fAuthAttr && CMSG_ENVELOPED == ptsd->dwMsgTypeDecoding)
            VerifyUnprotectedAttr(hMsg);

        if (CMSG_SIGNED == ptsd->dwMsgTypeDecoding && !fNoSigners) {
            DWORD i;
            DWORD c;

            if (fMultiSigner)
                c = 2;
            else
                c = 1;

            for (i = 0; i < c; i++) {
                VerifyDecodedSignerComputedHash(
                    "StreamDecodeMsg",
                    ptsd->hMsg,
                    fInnerNonData,
                    i,
                    ptsd->rgbComputedHash,
                    ptsd->rgcbComputedHash
                    );
            }
        }
#endif  // CMS_PKCS7

        if ((CMSG_SIGNED == ptsd->dwMsgTypeDecoding) &&
                !GetSignerInfoAndVerify( ptsd->hMsg, fInnerNonData))
            goto GetSignerInfoAndVerifyError;
        dwMsgTypeInner = ptsd->dwMsgTypeEncoding;
    }

    // Verify the data
    if (fVerbose)
        printf( "Verify data\n");
    if (INVALID_FILE_SIZE ==
            (cbFileDecode = GetFileSize( hFileStreamDecode, NULL)))
        goto GetFileSizeDecodeError;
    if (cbFileDecode != (fInnerContent ? cbInnerContent : cbMsgContent)) {
        if (fNoRecipients && 0 == cbFileDecode)
            ;
        else
            goto WrongDataSizeError;
    }
    CloseHandle( hFileStreamDecode);
    if (INVALID_HANDLE_VALUE == (hFileStreamDecode = CreateFile(
            pszFilenameDecode,
            GENERIC_READ,
            0, 
            NULL, 
            OPEN_EXISTING, 
            0, 
            NULL)))
        goto CreateFileDecodeReadError;
    iMsgContentOffset = 0;
    for (cbRemain=cbFileDecode; cbRemain; cbRemain-=cbRead) {
        if (!ReadFile(
                hFileStreamDecode,
                pbRead,
                cbStreamDataDeltaDecode,
                &cbRead,
                NULL))              // lpOverlapped
            goto ReadFileDecodeError;
        if (!BufferEqualsContent( pbRead, cbRead))
            goto WrongDataError;
    }

    // Close the messages
    if (fVerbose)
        printf( "Close messages\n");
    for (pnStream = plistStream->Head();
            pnStream;
            pnStream = pnStream->Next()) {

        DWORD cbData = 0;
        if (CryptMsgGetParam(
                pnStream->Data()->hMsg,
                CMSG_CONTENT_PARAM,
                0,                      // dwIndex
                NULL,                   // pvData
                &cbData
                ))
            PrintError("CryptMsgGetParam(CMSG_CONTENT_PARAM) succeeded for streaming");

        if (!CryptMsgClose( pnStream->Data()->hMsg))
            goto CloseError;
    }

    fRet = TRUE;
CommonReturn:
    TestFree( pbRead);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle( hFile);
    if (hFileStreamDecode != INVALID_HANDLE_VALUE)
        CloseHandle( hFileStreamDecode);
#ifndef SAVE_STREAM_FILES
    DeleteFile( pszFilenameDecode);
#endif // SAVE_STREAM_FILES
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
PRINT_ERROR(StreamDecodeMsg,AllocDecodeBufferError)
PRINT_ERROR(StreamDecodeMsg,UpdateError)
PRINT_ERROR(StreamDecodeMsg,GetFileSizeError)
PRINT_ERROR(StreamDecodeMsg,CreateFileError)
PRINT_ERROR(StreamDecodeMsg,ReadFileError)
PRINT_ERROR(StreamDecodeMsg,ReadFileDecodeError)
PRINT_ERROR(StreamDecodeMsg,OpenToDecodeError)
PRINT_ERROR(StreamDecodeMsg,StreamGetRecipientInfoAndSetHProvError)
PRINT_ERROR(StreamDecodeMsg,MsgTypeMismatchError)
PRINT_ERROR(StreamDecodeMsg,GetSignerInfoAndVerifyError)
PRINT_ERROR(StreamDecodeMsg,WrongDataSizeError)
PRINT_ERROR(StreamDecodeMsg,WrongDataError)
PRINT_ERROR(StreamDecodeMsg,CloseError)
PRINT_ERROR(StreamDecodeMsg,CreateFileDecodeError)
PRINT_ERROR(StreamDecodeMsg,GetFileSizeDecodeError)
PRINT_ERROR(StreamDecodeMsg,CreateFileDecodeReadError)
}


//+-------------------------------------------------------------------------
//  Encodes and decodes the message.
//--------------------------------------------------------------------------
BOOL EncodeAndDecodeMsg(
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo
    )
{
    BOOL fResult;

    BYTE *pbEncodedBlob;
    DWORD cbEncodedBlob;

    fResult = EncodeMsg(
        dwMsgType,
        pvMsgEncodeInfo,
        &pbEncodedBlob,
        &cbEncodedBlob
        );

    if (fResult) {
        if (pszFilename)
            TCM_WriteBufToFile( pszFilename, pbEncodedBlob, cbEncodedBlob);

        fResult = DecodeMsg(
            dwMsgType,
            pbEncodedBlob,
            cbEncodedBlob
            );

        TestFree(pbEncodedBlob);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Allocates and encodes the message.
//--------------------------------------------------------------------------
BOOL EncodeMsg(
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo,
    OUT BYTE **ppbEncodedBlob,
    OUT DWORD *pcbEncodedBlob
    )
{
    BOOL    fResult;
    PBYTE   pbToBeEncoded;
    DWORD   cbToBeEncoded;
    PBYTE   pbInnerEncoded;
    DWORD   cbInnerEncoded;
    HCRYPTMSG hMsg = NULL;
    BYTE *pbEncodedBlob = NULL;
    DWORD cbEncodedBlobOrg;
    DWORD cbEncodedBlob;
    DWORD dwFlags = fBare ? CMSG_BARE_CONTENT_FLAG : 0;

    if (!GetNonStreamedMsgContent(
            cbMsgContent,
            &pbToBeEncoded,
            &cbToBeEncoded))
        goto GetNonStreamedMsgContentError;

    if (fInnerContent) {
        if (dwMsgType == CMSG_ENVELOPED
#ifdef CMS_PKCS7
                && !fEncapsulatedContent
#endif  // CMS_PKCS7
                ) {
            if (0 > TCM_ExtractContent(
                        pbToBeEncoded,
                        cbToBeEncoded,
                        &cbInnerEncoded,
                        &pbInnerEncoded))
                goto ExtractContentError;
        } else {
            pbInnerEncoded = pbToBeEncoded;
            cbInnerEncoded = cbToBeEncoded;
        }
    }

    switch (dwMsgType) {
    case CMSG_HASHED:
    case CMSG_SIGNED:
        dwFlags |= fDetached ? CMSG_DETACHED_FLAG : 0;
        break;
    default:
        break;
    }

#ifdef CMS_PKCS7
    if (fEncapsulatedContent)
        dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
#endif  // CMS_PKCS7

    if (0 == (cbEncodedBlobOrg = CryptMsgCalculateEncodedLength(
                    dwMsgEncodingType,
                    dwFlags,
                    dwMsgType,
                    pvMsgEncodeInfo,
                    fInnerContent ? pszInnerContentObjId : NULL,
                    fInnerContent ? cbInnerEncoded : cbToBeEncoded))) {
        PrintLastError("EncodeMsg::CryptMsgCalculateEncodedLength == 0");
        goto ErrorReturn;
    }
    cbEncodedBlob = cbEncodedBlobOrg + 1024;        // A wee bit of padding
    pbEncodedBlob = (BYTE *) TestAlloc( cbEncodedBlob);
    if (pbEncodedBlob == NULL) goto ErrorReturn;

    hMsg = CryptMsgOpenToEncode(
        dwMsgEncodingType,
        dwFlags,
        dwMsgType,
        pvMsgEncodeInfo,
        fInnerContent ? pszInnerContentObjId : NULL,
        NULL                    // pStreamInfo
        );
    if (hMsg == NULL) {
        PrintLastError("EncodeMsg::CryptMsgOpenToEncode");
        goto ErrorReturn;
    }

#ifdef CMS_PKCS7
    if (fAlgorithmParameters) {
        rgSignerEncodeInfo[0].HashEncryptionAlgorithm.Parameters.pbData =
            rgbInvalidAsn;
        rgSignerEncodeInfo[0].HashEncryptionAlgorithm.Parameters.cbData =
            sizeof(rgbInvalidAsn);

        rgSignerEncodeInfo[0].HashAlgorithm.Parameters.pbData =
            rgbInvalidAsn;
        rgSignerEncodeInfo[0].HashAlgorithm.Parameters.cbData =
            sizeof(rgbInvalidAsn);
    }
#endif  // CMS_PKCS7

    fResult = CryptMsgUpdate(
        hMsg,
        pbToBeEncoded,
        cbToBeEncoded,
        TRUE                    // fFinal
        );
    if (!fResult) {
        PrintLastError("EncodeMsg::CryptMsgUpdate");
        goto ErrorReturn;
    }

#ifdef CMS_PKCS7
    if (fAuthAttr)
        XORAttributeBytes();

    if (fVerbose || fEncapsulatedContent || cAttrCert ||
            fOriginatorInfo || fCmsRecipient) {
        DWORD dwVersion;
        DWORD cbData = sizeof(dwVersion);
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_VERSION_PARAM,
            0,                      // dwIndex
            (PBYTE) &dwVersion,
            &cbData
            );
        if (!fResult)
            PrintLastError("EncodeMsg::CryptMsgGetParam(CMSG_VERSION_PARAM)");
        else
            printf("EncodeMsg Version:: %d\n", dwVersion);
    }
#endif  // CMS_PKCS7

    fResult = CryptMsgGetParam(
        hMsg,
        fBare ? CMSG_BARE_CONTENT_PARAM : CMSG_CONTENT_PARAM,
        0,                      // dwIndex
        pbEncodedBlob,
        &cbEncodedBlob
        );
    if (!fResult) {
        PrintLastError("EncodeMsg::CryptMsgGetParam(MSG_(BARE_)CONTENT_PARAM)");
        goto ErrorReturn;
    }
#ifdef CMS_PKCS7
    if (IsDSSProv(dwProvType) || fKeyAgree ||
            (fMultiSigner && PROV_RSA_FULL != dwMultiSignerProvType)
#else
    if (IsDSSProv(dwProvType)
#endif  // CMS_PKCS7
                || hNamedSignerCryptProv) {
        // For DSS the length of the encoded output may be less than
        // the length returned by CryptMsgCalculateEncodedLength

        // Also Key Agreement recipients containing generated ephemeral
        // public keys may have an encoded length less than
        // the length returned by CryptMsgCalculateEncodedLength
        if (cbEncodedBlobOrg < cbEncodedBlob)
            printf( "Fail: encoding size mismatch: expect=%x >= actual=%x\n",
                    cbEncodedBlobOrg,
                    cbEncodedBlob);
    } else {
        if (cbEncodedBlobOrg != cbEncodedBlob)
            printf( "Fail: encoding size mismatch: expect=%x    actual=%x\n",
                    cbEncodedBlobOrg,
                    cbEncodedBlob);
    }
    // NB- We depart from the usual practice here since cbEncodedBlob can be
    // somewhat larger than required. A buffer size of 1 will always be too
    // small.
    if (!TCM_CheckGetParam(
            hMsg,
            fBare ? CMSG_BARE_CONTENT_PARAM : CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbEncodedBlob,
            2))
        goto CheckGetEncodedError;

    if (dwMsgType == CMSG_HASHED) {
        BYTE *pbComputedDigest = NULL;
        DWORD cbComputedDigest = 0;

        if (!TCM_AllocGetParam(
                hMsg,
                CMSG_COMPUTED_HASH_PARAM,
                0,                      // dwIndex
                &pbComputedDigest,
                &cbComputedDigest))
            goto GetComputedHashError;

        TCM_CheckGetParam(
            hMsg,
            CMSG_COMPUTED_HASH_PARAM,
            0,                      // dwIndex
            pbComputedDigest,
            cbComputedDigest
            );

        TestFree(pbComputedDigest);
    }

#ifdef CMS_PKCS7
    if (dwMsgType == CMSG_SIGNED && !fNoSigners) {
        DWORD i;
        DWORD c;

        if (fMultiSigner)
            c = 2;
        else
            c = 1;

        for (i = 0; i < c; i++) {
            rgcbEncodedSignerHash[i] = sizeof(rgbEncodedSignerHash[i]);
            if (!CryptMsgGetParam(
                    hMsg,
                    CMSG_COMPUTED_HASH_PARAM,
                    i,                      // dwSignerIndex
                    rgbEncodedSignerHash[i],
                    &rgcbEncodedSignerHash[i]
                    )) {
                printf("EncodeMsg::CryptMsgGetParam(Signer[%d] CMSG_COMPUTED_HASH_PARAM)",
                    i);
                PrintLastError("");
            } else
                VerifyEncodedSignerComputedHash(
                    "EncodeMsg", hMsg, i,
                    rgbEncodedSignerHash[i],
                    rgcbEncodedSignerHash[i]);
        }
    }

    if (fAuthAttr)
        XORAttributeBytes();
#endif  // CMS_PKCS7

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    TestFree(pbEncodedBlob);
    pbEncodedBlob = NULL;
    cbEncodedBlob = 0;
CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    TestFree(pbToBeEncoded);
    *ppbEncodedBlob = pbEncodedBlob;
    *pcbEncodedBlob = cbEncodedBlob;

    return fResult;
//PRINT_ERROR(EncodeMsg,CalculateEncodedLengthWrongSizeError)
PRINT_ERROR(EncodeMsg,GetNonStreamedMsgContentError)
PRINT_ERROR(EncodeMsg,ExtractContentError)
PRINT_ERROR(EncodeMsg,CheckGetEncodedError)
PRINT_ERROR(EncodeMsg,GetComputedHashError)
}


//+-------------------------------------------------------------------------
//  Decodes the message types:
//      CMSG_SIGNED
//      CMSG_ENVELOPED
//      CMSG_SIGNED_AND_ENVELOPED
//      CMSG_HASHED
//--------------------------------------------------------------------------
BOOL DecodeMsg(
    IN DWORD dwExpectedMsgType,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob
    )
{
    BOOL        fResult;
    HCRYPTMSG   hMsg = NULL;
    PBYTE       pbContent;
    DWORD       cbContent;
    PBYTE       pbDecoded = NULL;
    DWORD       cbDecoded;
    DWORD       cbData;
    DWORD       dwMsgType;
    DWORD       dwFlags = CMSG_LENGTH_ONLY_FLAG;

    if (!GetNonStreamedMsgContent(
            cbMsgContent,
            &pbContent,
            &cbContent))
        goto GetNonStreamedMsgContentError;

    switch (dwExpectedMsgType) {
    case CMSG_HASHED:
    case CMSG_SIGNED:
        dwFlags |= fDetached ? CMSG_DETACHED_FLAG : 0;
        break;
    default:
        break;
    }

    // Open to decode to get the message type and content length
    hMsg = CryptMsgOpenToDecode(
        dwMsgEncodingType,
        dwFlags,
        fBare ? dwExpectedMsgType : 0,
        hDefaultVerifyProv,
        NULL,                       // pRecipientInfo
        NULL                        // pStreamInfo
        );
    if (hMsg == NULL) {
        PrintLastError("DecodeMsg::CryptMsgOpenToDecode(CMSG_LENGTH_ONLY_FLAG)");
        goto ErrorReturn;
    }

    fResult = CryptMsgUpdate(
        hMsg,
        pbEncodedBlob,
        cbEncodedBlob,
        TRUE                    // fFinal
        );
    if (!fResult) {
        PrintLastError("DecodeMsg::CryptMsgUpdate");
        goto ErrorReturn;
    }

#ifdef CMS_PKCS7
    if (fVerbose || fEncapsulatedContent || cAttrCert ||
            fOriginatorInfo || fCmsRecipient) {
        DWORD dwVersion;
        DWORD cbData = sizeof(dwVersion);
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_VERSION_PARAM,
            0,                      // dwIndex
            (PBYTE) &dwVersion,
            &cbData
            );
        if (!fResult)
            PrintLastError("DecodeMsg::CryptMsgGetParam(CMSG_VERSION_PARAM)");
        else
            printf("DecodeMsg Version:: %d\n", dwVersion);
    }
#endif  // CMS_PKCS7

    if (fDetached) {
        fResult = CryptMsgUpdate(
            hMsg,
            pbContent,
            cbContent,
            TRUE                    // fFinal
            );
        if (!fResult) {
            PrintLastError("DecodeMsg::CryptMsgUpdate");
            goto ErrorReturn;
        }
    } else if (!fNoSigners) {
        cbData = sizeof(dwMsgType);
        dwMsgType = 0;
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_TYPE_PARAM,
            0,                  // dwIndex
            &dwMsgType,
            &cbData
            );
        if (!fResult) {
            PrintLastError("DecodeMsg::CryptMsgGetParam(CMSG_TYPE_PARAM)");
            goto ErrorReturn;
        }
        if ((dwMsgType != dwExpectedMsgType) &&
                (CMSG_SIGNED != dwExpectedMsgType)) {
            PrintError("DecodeMsg::Unexpected message type");
        }
        if (!TCM_CheckGetParam(
                hMsg,
                CMSG_TYPE_PARAM,
                0,                  // dwIndex
                &dwMsgType,
                cbData))
            goto CheckGetTypeError;

    	cbDecoded = 0;
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            NULL,                   // pvData
            &cbDecoded
            );
        if (cbDecoded == 0) {
            PrintError("DecodeMsg::message content length == 0");
            goto ErrorReturn;
        }

        if ((cbDecoded < cbContent) && !fInnerContent)
            PrintError(
                "DecodeMsg::Ciphertext Length Less Than Plaintext Length");

        pbDecoded = (BYTE *) TestAlloc(cbDecoded);
        if (pbDecoded == NULL) goto ErrorReturn;
    }
    CryptMsgClose(hMsg);
    hMsg = NULL;

    // Re-open message to get its decoded content.
    hMsg = CryptMsgOpenToDecode(
        dwMsgEncodingType,
        dwFlags,
        fBare ? dwExpectedMsgType : 0,
        hDefaultVerifyProv,
        NULL,                       // pRecipientInfo
        NULL                        // pStreamInfo
        );
    if (hMsg == NULL) {
        PrintLastError("DecodeMsg::CryptMsgOpenToDecode");
        goto ErrorReturn;
    }

    // Check that duplicate works
    hMsg = CryptMsgDuplicate(hMsg);
    CryptMsgClose(hMsg);

    fResult = CryptMsgUpdate(
        hMsg,
        pbEncodedBlob,
        cbEncodedBlob,
        TRUE                    // fFinal
        );
    if (!fResult) {
        PrintLastError("DecodeMsg::CryptMsgUpdate");
        goto ErrorReturn;
    }

    if (fDetached) {
        fResult = CryptMsgUpdate(
            hMsg,
            pbContent,
            cbContent,
            TRUE                    // fFinal
            );
        if (!fResult) {
            PrintLastError("DecodeMsg::CryptMsgUpdate");
            goto ErrorReturn;
        }
    }

    if (fInnerContent) {
        DWORD   cbInnerContentObjId;
        PBYTE   pbInnerContentObjId;

        if (!TCM_AllocGetParam(
                hMsg,
                CMSG_INNER_CONTENT_TYPE_PARAM,
                0,                      // dwIndex
                &pbInnerContentObjId,
                &cbInnerContentObjId))
            goto GetInnerContentTypeError;

        if ((cbInnerContentObjId != (strlen(pszInnerContentObjId) + 1)) ||
                (0 != memcmp(
                        pszInnerContentObjId,
                        pbInnerContentObjId,
                        cbInnerContentObjId))) {
            PrintError(
                "DecodeMsg::Decoded Content Object ID incorrect");
        }
        TestFree(pbInnerContentObjId);
    }

    if (dwExpectedMsgType == CMSG_ENVELOPED ||
        dwExpectedMsgType == CMSG_SIGNED_AND_ENVELOPED) {
        fResult = GetRecipientInfoAndDecrypt(hMsg);
        if (!fResult) goto ErrorReturn;
    }

    if (!fNoSigners &&
            (dwExpectedMsgType == CMSG_SIGNED ||
            dwExpectedMsgType == CMSG_SIGNED_AND_ENVELOPED)) {
        if (fAuthAttr) {
            DWORD   cbAuthAttrs;
            PBYTE   pbAuthAttrs;

            if (!TCM_AllocGetParam(
                    hMsg,
                    CMSG_SIGNER_AUTH_ATTR_PARAM,
                    0,                      // dwIndex
                    &pbAuthAttrs,
                    &cbAuthAttrs)) {
                TestFree(pbAuthAttrs);
                goto GetAuthAttrError;
            }
            TestFree(pbAuthAttrs);

            if (!fCountersign) {
                if (!TCM_AllocGetParam(
                        hMsg,
                        CMSG_SIGNER_UNAUTH_ATTR_PARAM,
                        0,                      // dwIndex
                        &pbAuthAttrs,
                        &cbAuthAttrs)) {
                    TestFree(pbAuthAttrs);
                    goto GetAuthAttrError;
                }
                TestFree(pbAuthAttrs);
            }
        }

#ifdef CMS_PKCS7
        VerifyDecodedSignerComputedHash(
            "DecodeMsg", hMsg, fInnerContent, 0,
            rgbEncodedSignerHash,
            rgcbEncodedSignerHash);
        if (fMultiSigner) {
            VerifyDecodedSignerComputedHash(
                "DecodeMsg", hMsg, fInnerContent, 1,
                rgbEncodedSignerHash,
                rgcbEncodedSignerHash);
        }
#endif  // CMS_PKCS7

        fResult = GetSignerInfoAndVerify(hMsg, fInnerContent);
        if (!fResult) goto ErrorReturn;

        if (fCountersign && !CountersignAndVerify( hMsg)) {
            PrintError( "DecodeMsg::CountersignAndVerify");
            goto ErrorReturn;
        }

        if (fAddSigner && !AddSignerAndVerify( hMsg)) {
            PrintError( "DecodeMsg::AddSignerAndVerify");
            goto ErrorReturn;
        }

        if (!AddDelItems(
                hMsg,
                CMSG_CERT_COUNT_PARAM,
                CMSG_CTRL_ADD_CERT,
                CMSG_CTRL_DEL_CERT,
                rgSignedCertBlob))
            goto AddDelCertsError;

        if (!AddDelItems(
                hMsg,
                CMSG_CRL_COUNT_PARAM,
                CMSG_CTRL_ADD_CRL,
                CMSG_CTRL_DEL_CRL,
                rgSignedCertBlob))  // This is not a cert
            goto AddDelCrlsError;
#ifdef CMS_PKCS7
        if (cAttrCert || (fEncapsulatedContent && fInnerContent)) {
            if (!AddDelItems(
                    hMsg,
                    CMSG_ATTR_CERT_COUNT_PARAM,
                    CMSG_CTRL_ADD_ATTR_CERT,
                    CMSG_CTRL_DEL_ATTR_CERT,
                    rgSignedCertBlob))
                goto AddDelAttrCertsError;
        }
#endif  // CMS_PKCS7
    }

    if (!fDetached && !fNoSigners
#ifdef CMS_PKCS7
            && !fNoRecipients
#endif  // CMS_PKCS7
            ) {
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbDecoded,
            &cbDecoded
            );
        if (!fResult) {
            PrintLastError("DecodeMsg::CryptMsgGetParam(CMSG_CONTENT_PARAM)");
            goto ErrorReturn;
        }
        if (!TCM_CheckGetParam(
                hMsg,
                CMSG_CONTENT_PARAM,
                0,                      // dwIndex
                pbDecoded,
                cbDecoded))
            goto CheckGetContentError;

        if (cbDecoded != cbContent ||
                memcmp(pbContent, pbDecoded, cbContent) != 0) {
            PrintError(
                "DecodeMsg::Decoded Content doesn't match ToBeEncoded Content");
        }
    }

    if (dwExpectedMsgType == CMSG_HASHED) {
        fResult = Undigest(hMsg);
        if (!fResult) goto ErrorReturn;
    }


    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    TestFree(pbDecoded);
    TestFree(pbContent);
    return fResult;
PRINT_ERROR(DecodeMsg,GetNonStreamedMsgContentError)
PRINT_ERROR(DecodeMsg,CheckGetTypeError)
PRINT_ERROR(DecodeMsg,GetInnerContentTypeError)
PRINT_ERROR(DecodeMsg,GetAuthAttrError)
PRINT_ERROR(DecodeMsg,CheckGetContentError)
PRINT_ERROR(DecodeMsg,AddDelCrlsError)
PRINT_ERROR(DecodeMsg,AddDelCertsError)
#ifdef CMS_PKCS7
PRINT_ERROR(DecodeMsg,AddDelAttrCertsError)
#endif  // CMS_PKCS7
}


//+-------------------------------------------------------------------------
//  Decode and encode a SignerInfo, and check that the input matches the output
//--------------------------------------------------------------------------
BOOL VerifyEncodedSigner(
    IN PBYTE    pbEncodedSigner,
    IN DWORD    cbEncodedSigner)
{
    BOOL                fRet;
    PCMSG_SIGNER_INFO   psi = NULL;
#ifdef CMS_PKCS7
    PCMSG_CMS_SIGNER_INFO pCMSsi = NULL;
#endif  // CMS_PKCS7
    DWORD               cbsi;
    PBYTE               pbEncodedSignerNew = NULL;
    DWORD               cbEncodedSignerNew;

    cbsi = 0;
    if (!CryptDecodeObject(
            PKCS_7_ASN_ENCODING,
            PKCS7_SIGNER_INFO,
            pbEncodedSigner,
            cbEncodedSigner,
            0,                              // dwFlags
            NULL,
            &cbsi))
        goto DecodeSizeError;
    if (NULL == (psi = (PCMSG_SIGNER_INFO)TestAlloc( cbsi)))
        goto AllocDecodeError;
    if (!CryptDecodeObject(
            PKCS_7_ASN_ENCODING,
            PKCS7_SIGNER_INFO,
            pbEncodedSigner,
            cbEncodedSigner,
            0,                              // dwFlags
            psi,
            &cbsi))
        goto DecodeError;

    cbEncodedSignerNew = 0;
    if (!CryptEncodeObject(
            PKCS_7_ASN_ENCODING,
            PKCS7_SIGNER_INFO,
            psi,
            NULL,
            &cbEncodedSignerNew))
        goto EncodeSizeError;
    if (NULL == (pbEncodedSignerNew = (PBYTE)TestAlloc( cbEncodedSignerNew)))
        goto AllocEncodeError;
    if (!CryptEncodeObject(
            PKCS_7_ASN_ENCODING,
            PKCS7_SIGNER_INFO,
            psi,
            pbEncodedSignerNew,
            &cbEncodedSignerNew))
        goto EncodeError;

    if (cbEncodedSigner != cbEncodedSignerNew)
        goto UnequalEncodedSignerSizeError;
    if (0 != memcmp( pbEncodedSigner, pbEncodedSignerNew, cbEncodedSigner))
        goto UnequalEncodedSignerError;

#ifdef CMS_PKCS7
    TestFree(pbEncodedSignerNew);
    pbEncodedSignerNew = NULL;

    cbsi = 0;
    if (!CryptDecodeObject(
            PKCS_7_ASN_ENCODING,
            CMS_SIGNER_INFO,
            pbEncodedSigner,
            cbEncodedSigner,
            0,                              // dwFlags
            NULL,
            &cbsi))
        goto CMSDecodeSizeError;
    if (NULL == (pCMSsi = (PCMSG_CMS_SIGNER_INFO)TestAlloc( cbsi)))
        goto CMSAllocDecodeError;
    if (!CryptDecodeObject(
            PKCS_7_ASN_ENCODING,
            CMS_SIGNER_INFO,
            pbEncodedSigner,
            cbEncodedSigner,
            0,                              // dwFlags
            pCMSsi,
            &cbsi))
        goto CMSDecodeError;

    cbEncodedSignerNew = 0;
    if (!CryptEncodeObject(
            PKCS_7_ASN_ENCODING,
            CMS_SIGNER_INFO,
            pCMSsi,
            NULL,
            &cbEncodedSignerNew))
        goto CMSEncodeSizeError;
    if (NULL == (pbEncodedSignerNew = (PBYTE)TestAlloc( cbEncodedSignerNew)))
        goto CMSAllocEncodeError;
    if (!CryptEncodeObject(
            PKCS_7_ASN_ENCODING,
            CMS_SIGNER_INFO,
            pCMSsi,
            pbEncodedSignerNew,
            &cbEncodedSignerNew))
        goto CMSEncodeError;

    if (cbEncodedSigner != cbEncodedSignerNew)
        goto CMSUnequalEncodedSignerSizeError;
    if (0 != memcmp( pbEncodedSigner, pbEncodedSignerNew, cbEncodedSigner))
        goto CMSUnequalEncodedSignerError;
#endif  // CMS_PKCS7

    fRet = TRUE;
CommonReturn:
    TestFree(psi);
#ifdef CMS_PKCS7
    TestFree(pCMSsi);
#endif  // CMS_PKCS7
    TestFree(pbEncodedSignerNew);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
PRINT_ERROR(VerifyEncodedSigner,DecodeSizeError)
PRINT_ERROR(VerifyEncodedSigner,AllocDecodeError)
PRINT_ERROR(VerifyEncodedSigner,DecodeError)
PRINT_ERROR(VerifyEncodedSigner,EncodeSizeError)
PRINT_ERROR(VerifyEncodedSigner,AllocEncodeError)
PRINT_ERROR(VerifyEncodedSigner,EncodeError)
PRINT_ERROR(VerifyEncodedSigner,UnequalEncodedSignerSizeError)
PRINT_ERROR(VerifyEncodedSigner,UnequalEncodedSignerError)
#ifdef CMS_PKCS7
PRINT_ERROR(VerifyEncodedSigner,CMSDecodeSizeError)
PRINT_ERROR(VerifyEncodedSigner,CMSAllocDecodeError)
PRINT_ERROR(VerifyEncodedSigner,CMSDecodeError)
PRINT_ERROR(VerifyEncodedSigner,CMSEncodeSizeError)
PRINT_ERROR(VerifyEncodedSigner,CMSAllocEncodeError)
PRINT_ERROR(VerifyEncodedSigner,CMSEncodeError)
PRINT_ERROR(VerifyEncodedSigner,CMSUnequalEncodedSignerSizeError)
PRINT_ERROR(VerifyEncodedSigner,CMSUnequalEncodedSignerError)
#endif  // CMS_PKCS7
}


//+-------------------------------------------------------------------------
//  Countersign the signed message and verify the countersignature
//--------------------------------------------------------------------------
BOOL CountersignAndVerify(IN HCRYPTMSG hCryptMsg)
{
    BOOL                fRet;
    HCRYPTMSG           hMsgNew = NULL;
    PBYTE               pbEncodedMessage = NULL;
    DWORD               cbEncodedMessage;
    PBYTE               pbSignerInfo = NULL;
    DWORD               cbSignerInfo;
    PCRYPT_ATTRIBUTES   patrs = NULL;
    DWORD               cbatrs;
    PCERT_INFO          pciCountersigner = NULL;
    DWORD               cbSignerPublicKeyData;

    // Allocate and get the CERT_INFO containing the SignerId
    // (Issuer and SerialNumber) of the countersigner.
    // NB: For this particular test, the signer and countersigner are the same.
    if (NULL == (pciCountersigner = GetCertIdFromMsg(
            hCryptMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            0)))                    // dwIndex
        goto GetCertIdFromMsgError;

    // countersign
    if (!CryptMsgCountersign(
            hCryptMsg,
            0,                      // dwIndex
            1,                      // cCountersigners
            &rgSignerEncodeInfo[0]))
        goto CountersignError;

    if (!TCM_AllocGetParam(
            hCryptMsg,
            CMSG_ENCODED_MESSAGE,
            0,                      // dwIndex
            &pbEncodedMessage,
            &cbEncodedMessage))
        goto GetEncodedMessageError;

    if (pszFilename)
        TCM_WriteBufToFile( pszFilename, pbEncodedMessage, cbEncodedMessage);

    // Re-open message to get its decoded content.
    if (NULL == (hMsgNew = CryptMsgOpenToDecode(
            dwMsgEncodingType,
            0,                          // dwFlags
            0,                          // dwMsgType
            hDefaultVerifyProv,
            NULL,                       // pRecipientInfo
            NULL)))                     // pStreamInfo
        goto CryptMsgOpenToDecodeError;
    if (!CryptMsgUpdate(
            hMsgNew,
            pbEncodedMessage,
            cbEncodedMessage,
            TRUE))                  // fFinal
        goto CryptMsgUpdateError;

    // Get the SignerInfo which was countersigned
    if (!TCM_AllocGetParam(
            hMsgNew,
            CMSG_ENCODED_SIGNER,
            0,                      // dwIndex
            &pbSignerInfo,
            &cbSignerInfo))
        goto GetEncodedSignerInfoError;

    if (!VerifyEncodedSigner( pbSignerInfo, cbSignerInfo))
        goto VerifyEncodedSignerError;

    // Get the unauth attrs, and find the countersignature
    if (!TCM_AllocGetParam(
            hMsgNew,
            CMSG_SIGNER_UNAUTH_ATTR_PARAM,
            0,                      // dwIndex
            (PBYTE *)&patrs,
            &cbatrs))
        goto GetUnauthAttrsError;

    // Do some consistency checks
    if (patrs->cAttr != 1)
        goto AttrCountError;
    if (strcmp( patrs->rgAttr->pszObjId, szOID_RSA_counterSign))
        goto AttrOidNotCountersignError;
    if (patrs->rgAttr->cValue != 1)
        goto CountersignCountError;

    // Get the signer's public key
    cbSignerPublicKeyData = sizeof(SignerPublicKeyData.Data);
    memset(SignerPublicKeyData.Data, 0, cbSignerPublicKeyData);
    if (!CryptExportPublicKeyInfo(
            hCryptProv,
            AT_SIGNATURE,
            X509_ASN_ENCODING,
            (PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data,
            &cbSignerPublicKeyData))
        goto ExportPublicKeyInfoError;

    pciCountersigner->SubjectPublicKeyInfo =
        *((PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data);

    // Verify the countersignature
    if (!CryptMsgVerifyCountersignatureEncoded(
            hDefaultVerifyProv,
            PKCS_7_ASN_ENCODING,
            pbSignerInfo,
            cbSignerInfo,
            patrs->rgAttr->rgValue->pbData,
            patrs->rgAttr->rgValue->cbData,
            pciCountersigner))
        goto VerifyCountersignatureEncodedError;

    fRet = TRUE;
CommonReturn:
    if (hMsgNew)
        CryptMsgClose(hMsgNew);
    TestFree(pciCountersigner);
    TestFree(pbEncodedMessage);
    TestFree(pbSignerInfo);
    TestFree(patrs);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
PRINT_ERROR(CountersignAndVerify,GetEncodedMessageError)
PRINT_ERROR(CountersignAndVerify,CryptMsgOpenToDecodeError)
PRINT_ERROR(CountersignAndVerify,CryptMsgUpdateError)
PRINT_ERROR(CountersignAndVerify,GetCertIdFromMsgError)
PRINT_ERROR(CountersignAndVerify,CountersignError)
PRINT_ERROR(CountersignAndVerify,GetEncodedSignerInfoError)
PRINT_ERROR(CountersignAndVerify,VerifyEncodedSignerError)
PRINT_ERROR(CountersignAndVerify,GetUnauthAttrsError)
PRINT_ERROR(CountersignAndVerify,AttrCountError)
PRINT_ERROR(CountersignAndVerify,AttrOidNotCountersignError)
PRINT_ERROR(CountersignAndVerify,CountersignCountError)
PRINT_ERROR(CountersignAndVerify,ExportPublicKeyInfoError)
PRINT_ERROR(CountersignAndVerify,VerifyCountersignatureEncodedError)
}


//+-------------------------------------------------------------------------
//  Add signers to the signed message and verify the new signatures
//--------------------------------------------------------------------------
BOOL AddSignerAndVerify(IN HCRYPTMSG hCryptMsg)
{
    BOOL                fRet;
    HCRYPTMSG           hMsgNew = NULL;
    PBYTE               pbEncodedMessage = NULL;
    DWORD               cbEncodedMessage;
    CMSG_SIGNER_ENCODE_INFO SignerEncodeInfo1 = rgSignerEncodeInfo[0];
    CMSG_SIGNER_ENCODE_INFO SignerEncodeInfo2 = rgSignerEncodeInfo[0];
    PCERT_INFO          pciSigner0 = NULL;
    PCERT_INFO          pciSigner1 = NULL;
    PCERT_INFO          pciSigner2 = NULL;

    if (NULL == (pciSigner0 = GetCertIdFromMsg(
            hCryptMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            0)))                        // dwIndex
        goto GetCertId0Error;
    if (NULL == (pciSigner1 = GetCertIdFromMsg(
            hCryptMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            0)))                        // dwIndex
        goto GetCertId1Error;
    if (NULL == (pciSigner2 = GetCertIdFromMsg(
            hCryptMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            0)))                        // dwIndex
        goto GetCertId2Error;

    // Give the new signers different serial numbers
    pciSigner1->SerialNumber.pbData = (PBYTE)&dwSignerSerialNumber1;
    pciSigner2->SerialNumber.pbData = (PBYTE)&dwSignerSerialNumber2;

    // Fill in the public key info
    // NB- We are relying on this already having been filled in by GetSignerInfoAndVerify
    pciSigner0->SubjectPublicKeyInfo =
        *((PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data);
    pciSigner1->SubjectPublicKeyInfo =
        *((PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data);
    pciSigner2->SubjectPublicKeyInfo =
        *((PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data);

    SignerEncodeInfo1.pCertInfo = pciSigner1;
    SignerEncodeInfo2.pCertInfo = pciSigner2;

    if (IsDSSProv(dwProvType))
        // DSS only supports signing of sha1
        SignerEncodeInfo2.HashAlgorithm =
            SignDigestAlgorithms[fMD5 ? SIGNDIGEST_ALG_MD5 : SIGNDIGEST_ALG_SHA];
    else
        // Use a different hash algorithm to force adding a hash node and
        // hashing the content again.
        SignerEncodeInfo2.HashAlgorithm =
            SignDigestAlgorithms[ !fMD5 ? SIGNDIGEST_ALG_MD5 : SIGNDIGEST_ALG_SHA];

    // Add the signers
    if (!CryptMsgControl(
            hCryptMsg,
            0,                      // dwFlags
            CMSG_CTRL_ADD_SIGNER,
            &SignerEncodeInfo1))
        goto AddSigner1Error;
    if (!CryptMsgControl(
            hCryptMsg,
            0,                      // dwFlags
            CMSG_CTRL_ADD_SIGNER,
            &SignerEncodeInfo2))
        goto AddSigner2Error;

    if (!AddDelItems(
            hCryptMsg,
            CMSG_SIGNER_COUNT_PARAM,
            CMSG_CTRL_ADD_SIGNER,
            CMSG_CTRL_DEL_SIGNER,
            &SignerEncodeInfo2))
        goto AddDelSignersError;

    // Verify all the signatures
    if (!CryptMsgControl(
            hCryptMsg,
            0,                      // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pciSigner0))
        goto VerifySigner0Error;
    if (!CryptMsgControl(
            hCryptMsg,
            0,                      // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pciSigner1))
        goto VerifySigner1Error;
    if (!CryptMsgControl(
            hCryptMsg,
            0,                      // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pciSigner2))
        goto VerifySigner2Error;

    // Re-encode the message, with the new signers
    if (!TCM_AllocGetParam(
            hCryptMsg,
            CMSG_ENCODED_MESSAGE,
            0,                      // dwIndex
            &pbEncodedMessage,
            &cbEncodedMessage))
        goto GetEncodedMessageError;

    if (pszFilename)
        TCM_WriteBufToFile( pszFilename, pbEncodedMessage, cbEncodedMessage);

    // Re-open message to get its decoded content.
    if (NULL == (hMsgNew = CryptMsgOpenToDecode(
            dwMsgEncodingType,
            0,                          // dwFlags
            0,                          // dwMsgType
            hDefaultVerifyProv,
            NULL,                       // pRecipientInfo
            NULL)))                     // pStreamInfo
        goto CryptMsgOpenToDecodeError;
    if (!CryptMsgUpdate(
            hMsgNew,
            pbEncodedMessage,
            cbEncodedMessage,
            TRUE))                  // fFinal
        goto CryptMsgUpdateError;

    // Verify all the signatures, again
    if (!CryptMsgControl(
            hMsgNew,
            0,                      // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pciSigner0))
        goto ReVerifySigner0Error;
    if (!CryptMsgControl(
            hMsgNew,
            0,                      // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pciSigner1))
        goto ReVerifySigner1Error;
    if (!CryptMsgControl(
            hMsgNew,
            0,                      // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pciSigner2))
        goto ReVerifySigner2Error;

    fRet = TRUE;
CommonReturn:
    if (hMsgNew)
        CryptMsgClose(hMsgNew);
    TestFree(pciSigner0);
    TestFree(pciSigner1);
    TestFree(pciSigner2);
    TestFree(pbEncodedMessage);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
PRINT_ERROR(AddSignerAndVerify,GetCertId0Error)
PRINT_ERROR(AddSignerAndVerify,GetCertId1Error)
PRINT_ERROR(AddSignerAndVerify,GetCertId2Error)
PRINT_ERROR(AddSignerAndVerify,AddSigner1Error)
PRINT_ERROR(AddSignerAndVerify,AddSigner2Error)
PRINT_ERROR(AddSignerAndVerify,VerifySigner0Error)
PRINT_ERROR(AddSignerAndVerify,VerifySigner1Error)
PRINT_ERROR(AddSignerAndVerify,VerifySigner2Error)
PRINT_ERROR(AddSignerAndVerify,GetEncodedMessageError)
PRINT_ERROR(AddSignerAndVerify,CryptMsgOpenToDecodeError)
PRINT_ERROR(AddSignerAndVerify,CryptMsgUpdateError)
PRINT_ERROR(AddSignerAndVerify,ReVerifySigner0Error)
PRINT_ERROR(AddSignerAndVerify,ReVerifySigner1Error)
PRINT_ERROR(AddSignerAndVerify,ReVerifySigner2Error)
PRINT_ERROR(AddSignerAndVerify,AddDelSignersError)
}

//+-------------------------------------------------------------------------
//  Verify certificates and CRLs in a signed or enveloped message.
//--------------------------------------------------------------------------
BOOL VerifyCerts(IN HCRYPTMSG hMsg)
{
    BOOL fResult;
    BYTE *pbCertEncoded = NULL;
    DWORD cCert;
#ifdef CMS_PKCS7
    BYTE *pbCrlEncoded = NULL;
    DWORD cCrl;
#endif  // CMS_PKCS7
    DWORD cbData;
    DWORD dwIndex;

//--------------------------------------------------------------
    // Get count of certificates in the message
    cCert = 0;
    cbData = sizeof(cCert);
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_CERT_COUNT_PARAM,
        0,                      // dwIndex
        &cCert,
        &cbData
        );
    if (!fResult) {
        PrintLastError(
            "VerifyCerts::CryptMsgGetParam(CMSG_CERT_COUNT_PARAM)");
        goto ErrorReturn;
    }
    if (cCert != cSignedCert) {
        PrintError("VerifyCerts::cCert != cSignedCert");
        goto ErrorReturn;
    }
    if (!TCM_CheckGetParam(
            hMsg,
            CMSG_CERT_COUNT_PARAM,
            0,                      // dwIndex
            &cCert,
            cbData))
        goto CheckGetCertCountError;


    // Get certs from the message and verify
    for (dwIndex = 0; dwIndex < cCert; dwIndex++) {
        if (!TCM_AllocGetParam(
                hMsg,
                CMSG_CERT_PARAM,
                dwIndex,
                &pbCertEncoded,
                &cbData))
            goto GetCertError;

        if (cbData != rgSignedCertBlob[dwIndex].cbData ||
            memcmp(pbCertEncoded, rgSignedCertBlob[dwIndex].pbData,
                cbData) != 0) {
            PrintError("VerifyCerts::Bad Cert content");
        }

        TestFree(pbCertEncoded);
        pbCertEncoded = NULL;
    }

#ifdef CMS_PKCS7
//--------------------------------------------------------------
    // Get count of attribute certificates in the message
    cCert = 0;
    cbData = sizeof(cCert);
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_ATTR_CERT_COUNT_PARAM,
        0,                      // dwIndex
        &cCert,
        &cbData
        );
    if (!fResult) {
        PrintLastError(
            "VerifyCerts::CryptMsgGetParam(CMSG_ATTR_CERT_COUNT_PARAM)");
        goto ErrorReturn;
    }
    if (cCert != cAttrCert) {
        PrintError("VerifyCerts::cAttrCert != cAttrCert");
        goto ErrorReturn;
    }
    if (!TCM_CheckGetParam(
            hMsg,
            CMSG_ATTR_CERT_COUNT_PARAM,
            0,                      // dwIndex
            &cCert,
            cbData))
        goto CheckGetCertCountError;


    // Get attribute certs from the message and verify
    for (dwIndex = 0; dwIndex < cCert; dwIndex++) {
        if (!TCM_AllocGetParam(
                hMsg,
                CMSG_ATTR_CERT_PARAM,
                dwIndex,
                &pbCertEncoded,
                &cbData))
            goto GetCertError;

        if (cbData != rgAttrCertBlob[dwIndex].cbData ||
            memcmp(pbCertEncoded, rgAttrCertBlob[dwIndex].pbData,
                cbData) != 0) {
            PrintError("VerifyCerts::Bad Attribute Cert content");
        }

        TestFree(pbCertEncoded);
        pbCertEncoded = NULL;
    }

//--------------------------------------------------------------
    // Get count of CRLs in the message
    cCrl = 0;
    cbData = sizeof(cCrl);
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_CRL_COUNT_PARAM,
        0,                      // dwIndex
        &cCrl,
        &cbData
        );
    if (!fResult) {
        PrintLastError(
            "VerifyCrls::CryptMsgGetParam(CMSG_CRL_COUNT_PARAM)");
        goto ErrorReturn;
    }
    if (cCrl != cSignedCrl) {
        PrintError("VerifyCrls::cCrl != cSignedCrl");
        goto ErrorReturn;
    }
    if (!TCM_CheckGetParam(
            hMsg,
            CMSG_CRL_COUNT_PARAM,
            0,                      // dwIndex
            &cCrl,
            cbData))
        goto CheckGetCrlCountError;


    // Get CRLs from the message and verify
    for (dwIndex = 0; dwIndex < cCrl; dwIndex++) {
        if (!TCM_AllocGetParam(
                hMsg,
                CMSG_CRL_PARAM,
                dwIndex,
                &pbCrlEncoded,
                &cbData))
            goto GetCrlError;

        if (cbData != rgSignedCrlBlob[dwIndex].cbData ||
            memcmp(pbCrlEncoded, rgSignedCrlBlob[dwIndex].pbData,
                cbData) != 0) {
            PrintError("VerifyCrls::Bad Crl content");
        }

        TestFree(pbCrlEncoded);
        pbCrlEncoded = NULL;
    }
#endif  // CMS_PKCS7

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;

CommonReturn:
    TestFree(pbCertEncoded);
#ifdef CMS_PKCS7
    TestFree(pbCrlEncoded);
#endif  // CMS_PKCS7
    return fResult;
PRINT_ERROR(VerifyCerts,CheckGetCertCountError)
PRINT_ERROR(VerifyCerts,GetCertError)
#ifdef CMS_PKCS7
PRINT_ERROR(VerifyCerts,CheckGetCrlCountError)
PRINT_ERROR(VerifyCerts,GetCrlError)
#endif  // CMS_PKCS7
}

//+-------------------------------------------------------------------------
//  Get signer info and verify the signed message
//--------------------------------------------------------------------------
BOOL GetSignerInfoAndVerify(
    IN HCRYPTMSG hMsg,
    IN BOOL fInnerNonData,
    IN DWORD dwSignerIndex,
    OUT DWORD *pdwSrcIndex
    )
{
    BOOL fResult;
    PCERT_INFO pSignerCertInfo = NULL;
    PCMSG_SIGNER_INFO pSignerInfo = NULL;
    DWORD cbData;
    BOOL  fEqual;
    DWORD i;
    PCRYPT_ATTRIBUTE patr1;
    PCRYPT_ATTRIBUTE patr2;

    DWORD cbSignerPublicKeyData;
    DWORD dwSrcIndex = 0;
    HCRYPTPROV hVerifyProv;

#ifdef CMS_PKCS7
    if (fMultiSigner) {
        DWORD cSigner = 0;
        cbData = sizeof(cSigner);

        if (!CryptMsgGetParam(
                hMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                           // dwIndex
                &cSigner,
                &cbData) || cSigner != 2) {
            PrintLastError(
                "GetSignerInfoAndVerify:: Invalid multisigner count");
        }
    }
#endif  // CMS_PKCS7

    // Allocate and get the CERT_INFO containing the SignerId
    // (Issuer and SerialNumber)
    pSignerCertInfo = GetCertIdFromMsg(
        hMsg,
        CMSG_SIGNER_CERT_INFO_PARAM,
        dwSignerIndex
        );
    if (pSignerCertInfo == NULL) {
        PrintLastError(
            "GetSignerInfoAndVerify::CryptMsgGetParam(CMSG_SIGNER_CERT_INFO_PARAM)");
        goto ErrorReturn;
    }
#ifdef CMS_PKCS7
    if (!(fCertInfoKeyId && fMultiSigner)) {
#endif  // CMS_PKCS7

    if (pSignerCertInfo->Issuer.cbData != rgSignerCertInfo[0].Issuer.cbData ||
        memcmp(pSignerCertInfo->Issuer.pbData, rgSignerCertInfo[0].Issuer.pbData,
            pSignerCertInfo->Issuer.cbData) != 0) {
        PrintError("GetSignerInfoAndVerify::Bad SignerIssuerName");
    }

#ifdef CMS_PKCS7
    }
#endif  // CMS_PKCS7

#ifdef CMS_PKCS7
    if (fMultiSigner) {

        if (pSignerCertInfo->SerialNumber.cbData ==
                rgSignerCertInfo[0].SerialNumber.cbData &&
            memcmp(pSignerCertInfo->SerialNumber.pbData,
                rgSignerCertInfo[0].SerialNumber.pbData,
                pSignerCertInfo->SerialNumber.cbData) == 0) {
            dwSrcIndex = 0;
        } else if (pSignerCertInfo->SerialNumber.cbData ==
                rgSignerCertInfo[1].SerialNumber.cbData &&
            memcmp(pSignerCertInfo->SerialNumber.pbData,
                rgSignerCertInfo[1].SerialNumber.pbData,
                pSignerCertInfo->SerialNumber.cbData) == 0) {
            dwSrcIndex = 1;
        } else {
            PrintError("GetSignerInfoAndVerify::Bad SignerSerialNumber");
        }

        if (fCertInfoKeyId) {
            if (pSignerCertInfo->Issuer.cbData ==
                    rgSignerCertInfo[0].Issuer.cbData &&
                memcmp(pSignerCertInfo->Issuer.pbData,
                    rgSignerCertInfo[0].Issuer.pbData,
                    pSignerCertInfo->Issuer.cbData) == 0) {
                dwSrcIndex = 0;
            } else if (pSignerCertInfo->Issuer.cbData ==
                    rgSignerCertInfo[1].Issuer.cbData &&
                memcmp(pSignerCertInfo->Issuer.pbData,
                    rgSignerCertInfo[1].Issuer.pbData,
                    pSignerCertInfo->Issuer.cbData) == 0) {
                dwSrcIndex = 1;
            } else {
                PrintError("GetSignerInfoAndVerify::Bad CertInfoKeyId");
            }
        }
    } else
#endif  // CMS_PKCS7
    if (pSignerCertInfo->SerialNumber.cbData !=
            rgSignerCertInfo[0].SerialNumber.cbData ||
        memcmp(pSignerCertInfo->SerialNumber.pbData,
            rgSignerCertInfo[0].SerialNumber.pbData,
            pSignerCertInfo->SerialNumber.cbData) != 0) {
        PrintError("GetSignerInfoAndVerify::Bad SignerSerialNumber");
    }


//--------------------------------------------------------------
    // Allocate and get the CMSG_SIGNER_INFO for the signer
    if (NULL == (pSignerInfo = GetSignerInfoFromMsg(
                                        hMsg,
                                        dwSignerIndex))) {
        PrintLastError(
            "GetSignerInfoAndVerify::CryptMsgGetParam(CMSG_SIGNER_INFO_PARAM)");
        goto ErrorReturn;
    }
    fEqual  = (pSignerInfo->Issuer.cbData ==
        rgSignerCertInfo[dwSrcIndex].Issuer.cbData);
    if (fEqual) {
        fEqual &= (memcmp(  pSignerInfo->Issuer.pbData,
                            rgSignerCertInfo[dwSrcIndex].Issuer.pbData,
                            pSignerInfo->Issuer.cbData) == 0);
    }
    fEqual &= (pSignerInfo->SerialNumber.cbData ==
               rgSignerCertInfo[dwSrcIndex].SerialNumber.cbData);
    if (fEqual) {
        fEqual &= (memcmp(  pSignerInfo->SerialNumber.pbData,
                            rgSignerCertInfo[dwSrcIndex].SerialNumber.pbData,
                            pSignerInfo->SerialNumber.cbData) == 0);
    }
    if (fAuthAttr) {
        fEqual &= EqualAlgorithm(  &rgSignerEncodeInfo[dwSrcIndex].HashAlgorithm,
                                   &pSignerInfo->HashAlgorithm);
        // Allow for the 2 auth attrs which get added automatically
        fEqual &= ((rgSignerEncodeInfo[dwSrcIndex].cAuthAttr + 2) ==
            pSignerInfo->AuthAttrs.cAttr);
        if (fEqual) {
            for (i=pSignerInfo->AuthAttrs.cAttr,
                        patr1=rgSignerEncodeInfo[dwSrcIndex].rgAuthAttr,
                        patr2=pSignerInfo->AuthAttrs.rgAttr;
                    i>0;
                    i--, patr2++) {
                // NB: We skip over the 2 auth attrs added by the system.
                if (    (0 == strcmp( szOID_RSA_contentType,   patr2->pszObjId)) ||
                        (0 == strcmp( szOID_RSA_messageDigest, patr2->pszObjId)))
                    continue;
                fEqual &= EqualAttribute( patr1++, patr2);
            }
        }

        if (!fCountersign) {
            fEqual &= (rgSignerEncodeInfo[dwSrcIndex].cUnauthAttr ==
                pSignerInfo->UnauthAttrs.cAttr);
            if (fEqual) {
                for (i=pSignerInfo->UnauthAttrs.cAttr,
                            patr1=rgSignerEncodeInfo[dwSrcIndex].rgUnauthAttr,
                            patr2=pSignerInfo->UnauthAttrs.rgAttr;
                        i>0;
                        i--, patr1++, patr2++) {
                    fEqual &= EqualAttribute( patr1, patr2);
                }
            }
        }
    } else {
        // It would be more thorough to check the message digest and
        // content type auth attrs are present in the fInnerContent case.
        if (fInnerNonData)
        {
            fEqual &= (pSignerInfo->AuthAttrs.cAttr == 2) ? 1 : 0;
        }
        else
        {
            fEqual &= (pSignerInfo->AuthAttrs.cAttr == 0) ? 1 : 0;
        }

//        fEqual &= fInnerNonData
//                        ? (2 == pSignerInfo->AuthAttrs.cAttr)
//                        : (0 == pSignerInfo->AuthAttrs.cAttr);
    }
    if (!fAuthAttr || fCountersign)
        fEqual &= (0 == pSignerInfo->UnauthAttrs.cAttr);
    if (!fEqual) {
        PrintError("GetSignerInfoAndVerify::Bad SignerInfo");
        goto ErrorReturn;
    }

    VerifyCerts(hMsg);

    // Get crypt provider's public signature key. It will be used as the
    // signer's public key
    cbSignerPublicKeyData = sizeof(SignerPublicKeyData.Data);
    memset(SignerPublicKeyData.Data, 0, cbSignerPublicKeyData);
    hVerifyProv = hCryptProv;
#ifdef CMS_PKCS7
    if (fMultiSigner) {
        if (dwSrcIndex != 0)
            hVerifyProv = hMultiSignerCryptProv;
    }
#endif  // CMS_PKCS7

    if (fNoSignature) {
        CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA Para;

        memset(&Para, 0, sizeof(Para));
        Para.cbSize = sizeof(Para);
        // Para.hCryptProv = 
        Para.dwSignerIndex = dwSignerIndex;
        Para.dwSignerType = CMSG_VERIFY_SIGNER_NULL;
        // Para.pvSigner =

        fResult = CryptMsgControl(
            hMsg,
            0,                  // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE_EX,
            &Para
            );
        if (!fResult) {
            PrintLastError(
                "GetSignerInfoAndVerify::CryptMsgControl(CMSG_VERIFY_SIGNER_NULL)");
            goto ErrorReturn;
        }

        goto CommonReturn;
    }

    CryptExportPublicKeyInfo(
        hVerifyProv,
        AT_SIGNATURE,
        X509_ASN_ENCODING,
        (PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data,
        &cbSignerPublicKeyData);

    pSignerCertInfo->SubjectPublicKeyInfo =
        *((PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data);

    fResult = CryptMsgControl(
        hMsg,
        0,                  // dwFlags
        CMSG_CTRL_VERIFY_SIGNATURE,
        pSignerCertInfo
        );
    if (!fResult) {
        PrintLastError(
            "GetSignerInfoAndVerify::CryptMsgControl(CMSG_CTRL_VERIFY_SIGNATURE)");
        goto ErrorReturn;
    }

#ifdef CMS_PKCS7
    // Modify public key. Verify should fail.
    XORBitBlob(&pSignerCertInfo->SubjectPublicKeyInfo.PublicKey);
    fResult = CryptMsgControl(
        hMsg,
        0,                  // dwFlags
        CMSG_CTRL_VERIFY_SIGNATURE,
        pSignerCertInfo
        );
    if (fResult)
        printf("GetSignerInfoAndVerify::CryptMsgControl(CMSG_CTRL_VERIFY_SIGNATURE) failed => verified with bad public key");
    XORBitBlob(&pSignerCertInfo->SubjectPublicKeyInfo.PublicKey);

    if (!fCertInfoKeyId) {
        // Modify serial number. Verify should fail.
        XORBlob(&pSignerCertInfo->SerialNumber);
        fResult = CryptMsgControl(
            hMsg,
            0,                  // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pSignerCertInfo
            );
        if (fResult)
            printf("GetSignerInfoAndVerify::CryptMsgControl(CMSG_CTRL_VERIFY_SIGNATURE) failed => verified with bad serial number");
        XORBlob(&pSignerCertInfo->SerialNumber);

        // Modify issuer. Verify should fail.
        XORBlob(&pSignerCertInfo->Issuer);
        fResult = CryptMsgControl(
            hMsg,
            0,                  // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pSignerCertInfo
            );
        if (fResult)
            printf("GetSignerInfoAndVerify::CryptMsgControl(CMSG_CTRL_VERIFY_SIGNATURE) failed => verified with bad issuer");
        XORBlob(&pSignerCertInfo->Issuer);
    }
    fResult = TRUE;
#endif  // CMS_PKCS7

    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;

CommonReturn:
    TestFree(pSignerCertInfo);
    TestFree(pSignerInfo);
    *pdwSrcIndex = dwSrcIndex;
    return fResult;
}

BOOL NamedSignerVerify(IN HCRYPTMSG hMsg, IN BOOL fInnerNonData)
{
    BOOL fResult;

#ifdef CMS_PKCS7
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    CERT_CHAIN_PARA ChainPara;
    CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;

    // Build a chain. This is necessary for DSA with public key algorithm
    // parameter inheritance.

    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    if (!CertGetCertificateChain(
            NULL,                   // hChainEngine
            pNamedSigner,
            NULL,                   // pTime
            hSignerStore,
            &ChainPara,
            CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
            NULL,                   // pvReserved
            &pChainContext
            )) {
        PrintLastError(
            "NamedSignerVerify::CertGetCertificateChain");
        return FALSE;
    }

    // Test that we can verify a certificate signature using a chain
    if (2 <= pChainContext->rgpChain[0]->cElement) {
        PCCERT_CONTEXT pIssuer =
            pChainContext->rgpChain[0]->rgpElement[1]->pCertContext;
        PCCERT_CHAIN_CONTEXT pIssuerChainContext = NULL;

        if (!CertGetCertificateChain(
                NULL,                   // hChainEngine
                pIssuer,
                NULL,                   // pTime
                hSignerStore,
                &ChainPara,
                CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
                NULL,                   // pvReserved
                &pIssuerChainContext
                )) {
            PrintLastError(
                "NamedSignerVerify::CertGetCertificateChain(Issuer)");
        } else {
            if (!CryptVerifyCertificateSignatureEx(
                    0,                                  // hCryptProv
                    dwCertEncodingType,
                    CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT,
                    (void *) pNamedSigner,
                    CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN,
                    (void *) pIssuerChainContext,
                    0,                                  // dwFlags
                    NULL                                // pvReserved
                    )) {
                PrintLastError(
                    "NamedSignerVerify::CryptVerifyCertificateSignatureEx(Chain)");
            }
            CertFreeCertificateChain(pIssuerChainContext);
        }
    }

    memset(&CtrlPara, 0, sizeof(CtrlPara));
    CtrlPara.cbSize = sizeof(CtrlPara);
    CtrlPara.hCryptProv = hNamedSignerCryptProv;
    CtrlPara.dwSignerIndex = 0;
    CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CHAIN;
    CtrlPara.pvSigner = (void *) pChainContext;

    fResult = CryptMsgControl(
        hMsg,
        0,
        CMSG_CTRL_VERIFY_SIGNATURE_EX,
        &CtrlPara
        );
    if (!fResult) {
        PrintLastError(
            "NamedSignerVerify::CryptMsgControl(CMSG_CTRL_VERIFY_SIGNATURE_EX)");
    }

    CertFreeCertificateChain(pChainContext);

    return fResult;
#else
    fResult = CryptMsgControl(
        hMsg,
        0,                  // dwFlags
        CMSG_CTRL_VERIFY_SIGNATURE,
        pNamedSigner->pCertInfo
        );
    if (!fResult) {
        PrintLastError(
            "NamedSignerVerify::CryptMsgControl(CMSG_CTRL_VERIFY_SIGNATURE)");
    }
    return fResult;
#endif  // CMS_PKCS7
}

//+-------------------------------------------------------------------------
//  Get signer info and verify the signed message
//--------------------------------------------------------------------------
BOOL GetSignerInfoAndVerify(IN HCRYPTMSG hMsg, IN BOOL fInnerNonData)
{
    BOOL fResult;
    DWORD dwSrcIndex;

    if (pNamedSigner)
        fResult = NamedSignerVerify(hMsg, fInnerNonData);
    else
        fResult = GetSignerInfoAndVerify(hMsg, fInnerNonData, 0, &dwSrcIndex);

#ifdef CMS_PKCS7
    if (fMultiSigner) {
        DWORD dwSrcIndex1;

        fResult &= GetSignerInfoAndVerify(hMsg, fInnerNonData, 1, &dwSrcIndex1);
        if (fResult && dwSrcIndex == dwSrcIndex1)
            PrintError("Multiple signer:: Didn't get different signers");
    }
#endif  // CMS_PKCS7
    return fResult;
}


#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
// Allocate and get the CMSG_CMS_RECIPIENT_INFO_PARAM 
// from the message
//--------------------------------------------------------------------------
PCMSG_CMS_RECIPIENT_INFO GetCmsRecipientFromMsg(
    IN HCRYPTMSG hMsg,
    IN DWORD dwIndex
    )
{
    PCMSG_CMS_RECIPIENT_INFO pRecipientInfo;
    DWORD cbData;

    if (!TCM_AllocGetParam(
            hMsg,
            CMSG_CMS_RECIPIENT_INFO_PARAM,
            dwIndex,
            (PBYTE *)&pRecipientInfo,
            &cbData))
        return NULL;

    return pRecipientInfo;
}

BOOL blobcmp(
    IN PCRYPT_DATA_BLOB pBlob1,
    IN PCRYPT_DATA_BLOB pBlob2
    )
{
    if (pBlob1->cbData != pBlob2->cbData)
        return FALSE;
    else if (0 == pBlob1->cbData)
        return TRUE;
    else if (0 == memcmp(pBlob1->pbData, pBlob2->pbData, pBlob1->cbData))
        return TRUE;
    else
        return FALSE;
}

BOOL bitblobcmp(
    IN PCRYPT_BIT_BLOB pBlob1,
    IN PCRYPT_BIT_BLOB pBlob2
    )
{
    if (pBlob1->cbData != pBlob2->cbData)
        return FALSE;
    else if (0 == pBlob1->cbData)
        return TRUE;
    else if (0 == memcmp(pBlob1->pbData, pBlob2->pbData, pBlob1->cbData))
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
// Get CMS Recipient info and decrypt the message.
//--------------------------------------------------------------------------
BOOL GetCmsRecipientInfoAndDecrypt(IN HCRYPTMSG hMsg)
{
    BOOL                    fResult;
    PCMSG_CMS_RECIPIENT_INFO pRecipientInfo = NULL;
    DWORD                   cRecipient;
    DWORD                   cbData;
    DWORD                   dwIndex;

    // Get # of CMS recipients in the message.
    cbData = sizeof(cRecipient);
    cRecipient = 0;
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_CMS_RECIPIENT_COUNT_PARAM,
        0,                      // dwIndex
        &cRecipient,
        &cbData
        );
    if (!fResult) {
        PrintLastError(
            "GetCmsRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_CMS_RECIPIENT_COUNT_PARAM)");
        goto ErrorReturn;
    }
    if (!TCM_CheckGetParam(
            hMsg,
            CMSG_CMS_RECIPIENT_COUNT_PARAM,
            0,                      // dwIndex
            &cRecipient,
            cbData))
        goto CheckGetCmsRecipientCountError;
    if (cRecipient != cCmsRecipients) {
        PrintError("GetCmsRecipientInfoAndDecrypt::cRecipient != cCmsRecipients");
        goto ErrorReturn;
    }

    // Get all the recipients and verify
    for (dwIndex = 0; dwIndex < cRecipient; dwIndex++) {
        pRecipientInfo = GetCmsRecipientFromMsg(
            hMsg,
            dwIndex
            );

        if (pRecipientInfo == NULL) {
            PrintLastError(
                "GetCmsRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_CMS_RECIPIENT_INFO_PARAM)");
            goto ErrorReturn;
        }

        if (pRecipientInfo->dwRecipientChoice  !=
                rgCmsRecipient[dwIndex].dwRecipientChoice) {
            PrintError("GetCmsRecipientInfoAndDecrypt::Bad RecipientChoice");
            goto ErrorReturn;
        }

        switch (pRecipientInfo->dwRecipientChoice) {
        case CMSG_KEY_TRANS_RECIPIENT:
            {
                PCMSG_KEY_TRANS_RECIPIENT_INFO pDecode =
                    pRecipientInfo->pKeyTrans;
                PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pEncode =
                    &rgKeyTrans[dwIndex];

                if (0 != strcmp(pDecode->KeyEncryptionAlgorithm.pszObjId,
                        pEncode->KeyEncryptionAlgorithm.pszObjId))
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyEncryptionAlgorithm");
                if (pDecode->RecipientId.dwIdChoice != 
                        pEncode->RecipientId.dwIdChoice)
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad dwIdChoice");
                else {
                    switch (pDecode->RecipientId.dwIdChoice) {
                    case CERT_ID_ISSUER_SERIAL_NUMBER:
                        {
                            PCERT_ISSUER_SERIAL_NUMBER pDecodeRid =
                                &pDecode->RecipientId.IssuerSerialNumber;
                            PCERT_ISSUER_SERIAL_NUMBER pEncodeRid =
                                &pEncode->RecipientId.IssuerSerialNumber;
                        
                            if (CMSG_KEY_TRANS_PKCS_1_5_VERSION !=
                                    pDecode->dwVersion)
                                PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyTransPkcsVersion");
                            if (!blobcmp(&pDecodeRid->Issuer,
                                    &pEncodeRid->Issuer) ||
                                !blobcmp(&pDecodeRid->SerialNumber,
                                    &pEncodeRid->SerialNumber))
                                PrintError("GetCmsRecipientInfoAndDecrypt::Bad IssuerSerialNumber");
                        }
                        break;
                    case CERT_ID_KEY_IDENTIFIER:
                        {
                            PCRYPT_HASH_BLOB pDecodeRid =
                                &pDecode->RecipientId.KeyId;
                            PCRYPT_HASH_BLOB pEncodeRid =
                                &pEncode->RecipientId.KeyId;
                        
                            if (CMSG_KEY_TRANS_CMS_VERSION !=
                                    pDecode->dwVersion)
                                PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyTransCmsVersion");
                            if (!blobcmp(pDecodeRid, pEncodeRid))
                                PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyId");
                        }
                        break;
                    default:
                        PrintError("GetCmsRecipientInfoAndDecrypt::Bad dwIdChoice");
                    }
                }
            }
            break;
        case CMSG_KEY_AGREE_RECIPIENT:
            {
                PCMSG_KEY_AGREE_RECIPIENT_INFO pDecode =
                    pRecipientInfo->pKeyAgree;
                PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pEncode =
                    &rgKeyAgree[dwIndex];

                if (CMSG_KEY_AGREE_VERSION != pDecode->dwVersion)
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyAgreePkcsVersion");

                if (!blobcmp(&pEncode->UserKeyingMaterial,
                        &pDecode->UserKeyingMaterial))
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad UserKeyingMaterial");

                if (0 != strcmp(pDecode->KeyEncryptionAlgorithm.pszObjId,
                        pEncode->KeyEncryptionAlgorithm.pszObjId))
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyEncryptionAlgorithm");

#if 0
                if (0 == _stricmp(pszEncryptName, "rc2")) {
                    if (0 == pDecode->KeyEncryptionAlgorithm.Parameters.cbData)
                        PrintError("GetCmsRecipientInfoAndDecrypt::Missing rc2 KeyEncryptionAlgorithm Parameters");
                    else {
                        int iVersion;
                        DWORD cbData;

                        cbData = sizeof(iVersion);
                        if (!CryptDecodeObject(
                                PKCS_7_ASN_ENCODING,
                                X509_INTEGER,
                                pDecode->KeyEncryptionAlgorithm.Parameters.pbData,
                                pDecode->KeyEncryptionAlgorithm.Parameters.cbData,
                                0,                              // dwFlags
                                &iVersion,
                                &cbData))
                            PrintLastError("GetCmsRecipientInfoAndDecrypt::CryptDecodeObject(rc2 KeyEncryptionAlgorithm Parameters)");
                        else {
                            DWORD dwEncodeBitLen;
                            DWORD dwDecodeBitLen;

                            dwEncodeBitLen = dwEncryptBitLen;
                            if (0 == dwEncodeBitLen)
                                dwEncodeBitLen = 40;

                            switch (iVersion) {
                                case CRYPT_RC2_40BIT_VERSION:
                                    dwDecodeBitLen = 40;
                                    break;
                                case CRYPT_RC2_56BIT_VERSION:
                                    dwDecodeBitLen = 56;
                                    break;
                                case CRYPT_RC2_64BIT_VERSION:
                                    dwDecodeBitLen = 64;
                                    break;
                                case CRYPT_RC2_128BIT_VERSION:
                                    dwDecodeBitLen = 128;
                                    break;
                                default:
                                    dwDecodeBitLen = 0;
                                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad Decode BitLen");
                            }
                            if (dwDecodeBitLen != dwEncodeBitLen)
                                    PrintError("GetCmsRecipientInfoAndDecrypt::Decode != Encode BitLen");
                        }
                    }
                } else {
                    BYTE rgbNull[] = {0x5, 0x0};
                    CRYPT_DATA_BLOB NullBlob = {sizeof(rgbNull), rgbNull};

                    if (!blobcmp(&NullBlob,
                            &pDecode->KeyEncryptionAlgorithm.Parameters))
                        PrintError("GetCmsRecipientInfoAndDecrypt::Expected NULL KeyEncryptionAlgorithm Parameters");
                }
#endif

                if (CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY !=
                        pDecode->dwOriginatorChoice)
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad dwOriginatorChoice");
                else {
                    if (0 != strcmp(
                            pDecode->OriginatorPublicKeyInfo.Algorithm.pszObjId,
                            pEncode->pEphemeralAlgorithm->pszObjId))
                        PrintError("GetCmsRecipientInfoAndDecrypt::Bad Originator public key Algorithm");
                    if (0 != pDecode->OriginatorPublicKeyInfo.Algorithm.Parameters.cbData)
                        PrintError("GetCmsRecipientInfoAndDecrypt::Not NO Originator public key Parameters");
                }

                if (pEncode->cRecipientEncryptedKeys !=
                        pDecode->cRecipientEncryptedKeys)
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad Encrypted Key Agree Count");
                else {
                    DWORD i;
                    for (i = 0; i < pEncode->cRecipientEncryptedKeys; i++) {
                        PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO pEncodeKey =
                            pEncode->rgpRecipientEncryptedKeys[i];

                        PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO pDecodeKey =
                            pDecode->rgpRecipientEncryptedKeys[i];

                        if (pDecodeKey->RecipientId.dwIdChoice != 
                                pEncodeKey->RecipientId.dwIdChoice)
                            PrintError("GetCmsRecipientInfoAndDecrypt::Bad dwIdChoice");
                        else {
                            switch (pDecodeKey->RecipientId.dwIdChoice) {
                            case CERT_ID_ISSUER_SERIAL_NUMBER:
                                {
                                    PCERT_ISSUER_SERIAL_NUMBER pDecodeRid =
                                        &pDecodeKey->RecipientId.IssuerSerialNumber;
                                    PCERT_ISSUER_SERIAL_NUMBER pEncodeRid =
                                        &pEncodeKey->RecipientId.IssuerSerialNumber;
                                
                                    if (!blobcmp(&pDecodeRid->Issuer,
                                            &pEncodeRid->Issuer) ||
                                        !blobcmp(&pDecodeRid->SerialNumber,
                                            &pEncodeRid->SerialNumber))
                                        PrintError("GetCmsRecipientInfoAndDecrypt::Bad IssuerSerialNumber");
                                }
                                break;
                            case CERT_ID_KEY_IDENTIFIER:
                                {
                                    PCRYPT_HASH_BLOB pDecodeRid =
                                        &pDecodeKey->RecipientId.KeyId;
                                    PCRYPT_HASH_BLOB pEncodeRid =
                                        &pEncodeKey->RecipientId.KeyId;
                                
                                    if (!blobcmp(pDecodeRid, pEncodeRid))
                                        PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyId");

                                    if (0 != CompareFileTime(&pDecodeKey->Date,
                                            &pEncodeKey->Date))
                                        PrintError("GetCmsRecipientInfoAndDecrypt::Bad Date");

                                    if (NULL == pEncodeKey->pOtherAttr) {
                                        if (NULL != pDecodeKey->pOtherAttr)
                                            PrintError("GetCmsRecipientInfoAndDecrypt::Unexpected OtherAttr");
                                    } else if (NULL == pDecodeKey->pOtherAttr) {
                                        PrintError("GetCmsRecipientInfoAndDecrypt::Missing OtherAttr");
                                    } else {
                                        PCRYPT_ATTRIBUTE_TYPE_VALUE
                                            pDecodeOther =
                                                pDecodeKey->pOtherAttr;
                                        PCRYPT_ATTRIBUTE_TYPE_VALUE
                                            pEncodeOther =
                                                pEncodeKey->pOtherAttr;

                                        if (0 != strcmp(pDecodeOther->pszObjId,
                                                pEncodeOther->pszObjId))
                                            PrintError("GetCmsRecipientInfoAndDecrypt::Bad OtherAttr OID");
                                        if (!blobcmp(&pDecodeOther->Value, &pEncodeOther->Value))
                                            PrintError("GetCmsRecipientInfoAndDecrypt::Bad OtherAttr Value");
                                    }
                                }
                                break;
                            default:
                                PrintError("GetCmsRecipientInfoAndDecrypt::Bad dwIdChoice");
                            }
                        }
                    }
                }
            }
            break;
        case CMSG_MAIL_LIST_RECIPIENT:
            {
                PCMSG_MAIL_LIST_RECIPIENT_INFO pDecode =
                    pRecipientInfo->pMailList;
                PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pEncode =
                    &rgMailList[dwIndex];

                if (CMSG_MAIL_LIST_VERSION != pDecode->dwVersion)
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad MailListVersion");
                {
                    PCRYPT_HASH_BLOB pDecodeKeyId =
                        &pDecode->KeyId;
                    PCRYPT_HASH_BLOB pEncodeKeyId =
                        &pEncode->KeyId;
                
                    if (!blobcmp(pDecodeKeyId, pEncodeKeyId))
                        PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyId");
                }
                if (0 != strcmp(pDecode->KeyEncryptionAlgorithm.pszObjId,
                        pEncode->KeyEncryptionAlgorithm.pszObjId))
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyEncryptionAlgorithm");
                if (0 == _stricmp(pszEncryptName, "rc2")) {
                    if (0 == pDecode->KeyEncryptionAlgorithm.Parameters.cbData)
                        PrintError("GetCmsRecipientInfoAndDecrypt::Missing rc2 KeyEncryptionAlgorithm Parameters");
                    else {
                        int iVersion;
                        DWORD cbData;

                        cbData = sizeof(iVersion);
                        if (!CryptDecodeObject(
                                PKCS_7_ASN_ENCODING,
                                X509_INTEGER,
                                pDecode->KeyEncryptionAlgorithm.Parameters.pbData,
                                pDecode->KeyEncryptionAlgorithm.Parameters.cbData,
                                0,                              // dwFlags
                                &iVersion,
                                &cbData))
                            PrintLastError("GetCmsRecipientInfoAndDecrypt::CryptDecodeObject(rc2 KeyEncryptionAlgorithm Parameters)");
                        else {
                            DWORD dwEncodeBitLen;
                            DWORD dwDecodeBitLen;

                            dwEncodeBitLen = dwEncryptBitLen;
                            if (0 == dwEncodeBitLen)
                                dwEncodeBitLen = 40;

                            switch (iVersion) {
                                case CRYPT_RC2_40BIT_VERSION:
                                    dwDecodeBitLen = 40;
                                    break;
                                case CRYPT_RC2_56BIT_VERSION:
                                    dwDecodeBitLen = 56;
                                    break;
                                case CRYPT_RC2_64BIT_VERSION:
                                    dwDecodeBitLen = 64;
                                    break;
                                case CRYPT_RC2_128BIT_VERSION:
                                    dwDecodeBitLen = 128;
                                    break;
                                default:
                                    dwDecodeBitLen = 0;
                                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad Decode BitLen");
                            }
                            if (dwDecodeBitLen != dwEncodeBitLen)
                                    PrintError("GetCmsRecipientInfoAndDecrypt::Decode != Encode BitLen");
                        }
                    }
                } else {
                    if (0 != pDecode->KeyEncryptionAlgorithm.Parameters.cbData)
                        PrintError("GetCmsRecipientInfoAndDecrypt::Expected NO, NULL KeyEncryptionAlgorithm Parameters");
                }

                if (0 != CompareFileTime(&pDecode->Date, &pEncode->Date))
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad Date");

                if (NULL == pEncode->pOtherAttr) {
                    if (NULL != pDecode->pOtherAttr)
                        PrintError("GetCmsRecipientInfoAndDecrypt::Unexpected OtherAttr");
                } else if (NULL == pDecode->pOtherAttr) {
                    PrintError("GetCmsRecipientInfoAndDecrypt::Missing OtherAttr");
                } else {
                    PCRYPT_ATTRIBUTE_TYPE_VALUE pDecodeOther =
                        pDecode->pOtherAttr;
                    PCRYPT_ATTRIBUTE_TYPE_VALUE pEncodeOther =
                        pEncode->pOtherAttr;

                    if (0 != strcmp(pDecodeOther->pszObjId,
                            pEncodeOther->pszObjId))
                        PrintError("GetCmsRecipientInfoAndDecrypt::Bad OtherAttr OID");
                    if (!blobcmp(&pDecodeOther->Value, &pEncodeOther->Value))
                        PrintError("GetCmsRecipientInfoAndDecrypt::Bad OtherAttr Value");
                }
            }
            break;
        default:
            PrintError( "GetCmsRecipientInfoAndDecrypt::Bad RecipientChoice");
            goto ErrorReturn;

        }

        TestFree(pRecipientInfo);
        pRecipientInfo = NULL;
    }

    pRecipientInfo = GetCmsRecipientFromMsg(hMsg, cRecipient -1);
    if (pRecipientInfo == NULL) {
        PrintLastError(
            "GetCmsRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_CMS_RECIPIENT_INFO_PARAM)");
        goto ErrorReturn;
    }

    switch (pRecipientInfo->dwRecipientChoice) {
    case CMSG_KEY_TRANS_RECIPIENT:
        {
            CMSG_CTRL_KEY_TRANS_DECRYPT_PARA  DecryptPara;
            DWORD dwDecryptIndex;

            DecryptPara.cbSize = sizeof(DecryptPara);
            DecryptPara.hCryptProv = hCryptProv;
            DecryptPara.dwKeySpec = 0;
            DecryptPara.pKeyTrans = pRecipientInfo->pKeyTrans;
            DecryptPara.dwRecipientIndex = cRecipient -1;
            fResult = CryptMsgControl(
                hMsg,
                0,                  // dwFlags
                CMSG_CTRL_KEY_TRANS_DECRYPT,
                &DecryptPara
                );
            if (!fResult) {
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::CryptMsgControl(CMSG_CTRL_KEY_TRANS_DECRYPT)");
                goto ErrorReturn;
            }

            cbData = sizeof(dwDecryptIndex);
            dwDecryptIndex = 0;
            fResult = CryptMsgGetParam(
                hMsg,
                CMSG_CMS_RECIPIENT_INDEX_PARAM,
                0,                      // dwIndex
                &dwDecryptIndex,
                &cbData
                );
            if (!fResult)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_CMS_RECIPIENT_INDEX_PARAM)");
            else if (dwDecryptIndex != cRecipient -1)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::Bad CMS decrypt Index");

            cbData = sizeof(dwDecryptIndex);
            dwDecryptIndex = 0;
            fResult = CryptMsgGetParam(
                hMsg,
                CMSG_RECIPIENT_INDEX_PARAM,
                0,                      // dwIndex
                &dwDecryptIndex,
                &cbData
                );
            if (!fResult)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_RECIPIENT_INDEX_PARAM)");
            else if (dwDecryptIndex != PkcsRecipientCount -1)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::Bad PKCS decrypt Index");
        }
        break;
    case CMSG_KEY_AGREE_RECIPIENT:
        {
            CMSG_CTRL_KEY_AGREE_DECRYPT_PARA  DecryptPara;
            DWORD dwDecryptIndex;

            DecryptPara.cbSize = sizeof(DecryptPara);
            DecryptPara.hCryptProv = hKeyAgreeProv;
            DecryptPara.dwKeySpec = AT_KEYEXCHANGE;
            DecryptPara.pKeyAgree = pRecipientInfo->pKeyAgree;
            DecryptPara.dwRecipientIndex = cRecipient -1;
            DecryptPara.dwRecipientEncryptedKeyIndex =
                pRecipientInfo->pKeyAgree->cRecipientEncryptedKeys -1;
            DecryptPara.OriginatorPublicKey =
                pRecipientInfo->pKeyAgree->OriginatorPublicKeyInfo.PublicKey;
            fResult = CryptMsgControl(
                hMsg,
                0,                  // dwFlags
                CMSG_CTRL_KEY_AGREE_DECRYPT,
                &DecryptPara
                );
            if (!fResult) {
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::CryptMsgControl(CMSG_CTRL_KEY_AGREE_DECRYPT)");
                goto ErrorReturn;
            }

            cbData = sizeof(dwDecryptIndex);
            dwDecryptIndex = 0;
            fResult = CryptMsgGetParam(
                hMsg,
                CMSG_CMS_RECIPIENT_INDEX_PARAM,
                0,                      // dwIndex
                &dwDecryptIndex,
                &cbData
                );
            if (!fResult)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_CMS_RECIPIENT_INDEX_PARAM)");
            else if (dwDecryptIndex != cRecipient -1)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::Bad CMS decrypt Index");

            cbData = sizeof(dwDecryptIndex);
            dwDecryptIndex = 0;
            fResult = CryptMsgGetParam(
                hMsg,
                CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM,
                0,                      // dwIndex
                &dwDecryptIndex,
                &cbData
                );
            if (!fResult)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM)");
            else if (dwDecryptIndex !=  DecryptPara.dwRecipientEncryptedKeyIndex)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::Bad CMS encrypted key Index");
        }
        break;
    case CMSG_MAIL_LIST_RECIPIENT:
        {
            CMSG_CTRL_MAIL_LIST_DECRYPT_PARA  DecryptPara;
            DWORD dwDecryptIndex;

            DecryptPara.cbSize = sizeof(DecryptPara);
            DecryptPara.pMailList = pRecipientInfo->pMailList;
            DecryptPara.dwRecipientIndex = cRecipient -1;
            DecryptPara.dwKeyChoice = CMSG_MAIL_LIST_HANDLE_KEY_CHOICE;
            if (fRecipientProv)
                DecryptPara.hCryptProv = GetCryptProv();
            else
                DecryptPara.hCryptProv = hCryptProv;

            DecryptPara.hKeyEncryptionKey = GenerateMailListKey(
                DecryptPara.hCryptProv,
                &DecryptPara.pMailList->KeyId
                );

            printf("Decrypting using MailList recipient\n");
            fResult = CryptMsgControl(
                hMsg,
                fRecipientProv ? CMSG_CRYPT_RELEASE_CONTEXT_FLAG : 0,
                CMSG_CTRL_MAIL_LIST_DECRYPT,
                &DecryptPara
                );
            if (DecryptPara.hKeyEncryptionKey) {
                DWORD dwErr = GetLastError();
                CryptDestroyKey(DecryptPara.hKeyEncryptionKey); 
                SetLastError(dwErr);
            }
            if (!fResult) {
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::CryptMsgControl(CMSG_CTRL_MAIL_LIST_DECRYPT)");
                goto ErrorReturn;
            }

            cbData = sizeof(dwDecryptIndex);
            dwDecryptIndex = 0;
            fResult = CryptMsgGetParam(
                hMsg,
                CMSG_CMS_RECIPIENT_INDEX_PARAM,
                0,                      // dwIndex
                &dwDecryptIndex,
                &cbData
                );
            if (!fResult)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_CMS_RECIPIENT_INDEX_PARAM)");
            else if (dwDecryptIndex != cRecipient -1)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::Bad CMS decrypt Index");
        }
        break;
    default:
        PrintError("GetCmsRecipientInfoAndDecrypt::Bad RecipientChoice");
        goto ErrorReturn;

    }

CommonReturn:
    TestFree(pRecipientInfo);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
PRINT_ERROR(GetCmsRecipientInfoAndDecrypt,CheckGetCmsRecipientCountError)
}

BOOL VerifyUnprotectedAttr(IN HCRYPTMSG hMsg)
{
    BOOL    fResult;
    DWORD   cbAttrs;
    DWORD   i;
    PCRYPT_ATTRIBUTES pAttrs = NULL;
    PCRYPT_ATTRIBUTE patr1;
    PCRYPT_ATTRIBUTE patr2;

    if (!TCM_AllocGetParam(
            hMsg,
            CMSG_UNPROTECTED_ATTR_PARAM,
            0,                      // dwIndex
            (PBYTE *) &pAttrs,
            &cbAttrs)) {
        goto GetAttrError;
    }

    if (pAttrs->cAttr != EnvelopedMsgEncodeInfo.cUnprotectedAttr)
        goto AttrCountError; 


    for (i=pAttrs->cAttr,
            patr1=EnvelopedMsgEncodeInfo.rgUnprotectedAttr,
            patr2=pAttrs->rgAttr;
                i>0;
                i--, patr1++, patr2++) {
        if (!EqualAttribute( patr1, patr2))
            goto AttrValueError;
    }

    fResult = TRUE;
CommonReturn:
    TestFree(pAttrs);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

PRINT_ERROR(VerifyUnprotectedAttr,GetAttrError)
PRINT_ERROR(VerifyUnprotectedAttr,AttrCountError)
PRINT_ERROR(VerifyUnprotectedAttr,AttrValueError)
}

#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
// Get recipient info and decrypt the message.
//--------------------------------------------------------------------------
BOOL GetRecipientInfoAndDecrypt(IN HCRYPTMSG hMsg)
{
    BOOL                    fResult;
    PCERT_INFO              pRecipientInfo = NULL;
    DWORD                   cRecipient;
    DWORD                   cbData;
    DWORD                   dwIndex;
    CMSG_CTRL_DECRYPT_PARA  DecryptPara;
#ifdef CMS_PKCS7
    BYTE                    *pbCiphertext = NULL;
    DWORD                   cbCiphertext;
#endif  // CMS_PKCS7
    DWORD                   cKeyIdRecipient;

    // Get # of recipients in the message.
    cbData = sizeof(cRecipient);
    cRecipient = 0;
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_RECIPIENT_COUNT_PARAM,
        0,                      // dwIndex
        &cRecipient,
        &cbData
        );
    if (!fResult) {
        PrintLastError(
            "GetRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_RECIPIENT_COUNT_PARAM)");
        goto ErrorReturn;
    }
    if (!TCM_CheckGetParam(
            hMsg,
            CMSG_RECIPIENT_COUNT_PARAM,
            0,                      // dwIndex
            &cRecipient,
            cbData))
        goto CheckGetRecipientCountError;
    if (fNoRecipients
#ifdef CMS_PKCS7
            || ((fMailList || fKeyAgree) && !fKeyTrans)
#endif  // CMS_PKCS7
            ) {
        if (cRecipient != 0) {
            PrintError("GetRecipientInfoAndDecrypt::cRecipient != 0");
            goto ErrorReturn;
        }
    } else {
        if (cRecipient != PkcsRecipientCount) {
            PrintError("GetRecipientInfoAndDecrypt::cRecipient != PkcsRecipientCount");
            goto ErrorReturn;
        }
    }

#ifdef CMS_PKCS7
    if (fKeyTrans && fRecipientKeyId && !fNoRecipients) {
        // The first RECIPIENT_COUNT recipients should be KeyId recipients
        cKeyIdRecipient = RECIPIENT_COUNT;

        // Get all the KeyId recipients and verify
        for (dwIndex = 0; dwIndex < RECIPIENT_COUNT; dwIndex++) {
            // Allocate and get the CERT_INFO containing the Special
            // KeyId RecipientId
            PCERT_NAME_INFO pKeyIdName = NULL;
            DWORD cbKeyIdName;
            CRYPT_HASH_BLOB KeyId;

            pRecipientInfo = GetCertIdFromMsg(
                hMsg,
                CMSG_RECIPIENT_INFO_PARAM,
                dwIndex
                );

            if (pRecipientInfo == NULL) {
                PrintLastError(
                    "GetRecipientInfoAndDecrypt::CryptMsgGetParam(KEYID CMSG_RECIPIENT_INFO_PARAM)");
                goto ErrorReturn;
            }

            if (pRecipientInfo->SerialNumber.cbData != 1 ||
                    *pRecipientInfo->SerialNumber.pbData != 0)
                PrintError("GetRecipientInfoAndDecrypt::Bad KeyId SerialNumber");

            // Decode the Issuer Name. It should contain the special KeyId
            // RDN

            if (AllocAndDecodeObject(
                    X509_NAME,
                    pRecipientInfo->Issuer.pbData,
                    pRecipientInfo->Issuer.cbData,
                    (void **) &pKeyIdName,
                    &cbKeyIdName
                    )) {

                    if (pKeyIdName->cRDN != 1 ||
                            pKeyIdName->rgRDN[0].cRDNAttr != 1)
                        PrintError("GetRecipientInfoAndDecrypt::Bad KeyId Issuer");
                    else {
                        PCERT_RDN_ATTR pAttr = pKeyIdName->rgRDN[0].rgRDNAttr;

                        if (0 != strcmp(pAttr->pszObjId, szOID_KEYID_RDN) ||
                                pAttr->dwValueType != CERT_RDN_OCTET_STRING ||
                                pAttr->Value.cbData !=
                                    strlen(rgpszRecipientIssuerFileName[dwIndex]) ||
                                0 != memcmp(pAttr->Value.pbData,
                                    rgpszRecipientIssuerFileName[dwIndex],
                                    pAttr->Value.cbData))
                            PrintError("GetRecipientInfoAndDecrypt::Bad KeyId Issuer");
                    }

                TestFree(pKeyIdName);
            }

            if (!Asn1UtilExtractKeyIdFromCertInfo(
                    pRecipientInfo,
                    &KeyId))
                PrintError("GetRecipientInfoAndDecrypt::Asn1UtilExtractKeyIdFromCertInfo failed");
            else if (KeyId.cbData !=
                        strlen(rgpszRecipientIssuerFileName[dwIndex]) ||
                    0 != memcmp(KeyId.pbData,
                        rgpszRecipientIssuerFileName[dwIndex], KeyId.cbData))
                PrintError("GetRecipientInfoAndDecrypt::Asn1UtilExtractKeyIdFromCertInfo compare failed");

            TestFree(pRecipientInfo);
            pRecipientInfo = NULL;
        }
    } else
#endif  // CMS_PKCS7
        cKeyIdRecipient = 0;

    // Get all the non KeyId recipients and verify
    for (dwIndex = 0; dwIndex < cRecipient - cKeyIdRecipient; dwIndex++) {
        // Allocate and get the CERT_INFO containing the RecipientId
        // (Issuer and SerialNumber)

#ifdef CMS_PKCS7
        CRYPT_HASH_BLOB KeyId;
        BOOL fExtractKeyId;
#endif  // CMS_PKCS7

        pRecipientInfo = GetCertIdFromMsg(
            hMsg,
            CMSG_RECIPIENT_INFO_PARAM,
            cKeyIdRecipient + dwIndex
            );

        if (pRecipientInfo == NULL) {
            PrintLastError(
                "GetRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_RECIPIENT_INFO_PARAM)");
            goto ErrorReturn;
        }
        if (pRecipientInfo->Issuer.cbData !=
                rgRecipientCertInfo[dwIndex].Issuer.cbData ||
            memcmp(pRecipientInfo->Issuer.pbData,
                rgRecipientCertInfo[dwIndex].Issuer.pbData,
                pRecipientInfo->Issuer.cbData) != 0 ||
            pRecipientInfo->SerialNumber.cbData !=
                rgRecipientCertInfo[dwIndex].SerialNumber.cbData ||
            memcmp(pRecipientInfo->SerialNumber.pbData,
                rgRecipientCertInfo[dwIndex].SerialNumber.pbData,
                pRecipientInfo->SerialNumber.cbData) != 0) {
            PrintError("GetRecipientInfoAndDecrypt::Bad RecipientInfo");
        }

#ifdef CMS_PKCS7
        fExtractKeyId = Asn1UtilExtractKeyIdFromCertInfo(
                pRecipientInfo,
                &KeyId);
        if (fCertInfoKeyId) {
            if (!fExtractKeyId)
                PrintError("GetRecipientInfoAndDecrypt::Asn1UtilExtractKeyIdFromCertInfo failed for CertInfoKeyId");
        } else if (fExtractKeyId)
            PrintError("GetRecipientInfoAndDecrypt::Asn1UtilExtractKeyIdFromCertInfo should have failed for nonKeyId");
#endif  // CMS_PKCS7

        TestFree(pRecipientInfo);
        pRecipientInfo = NULL;
    }

#ifdef CMS_PKCS7
    if (fOriginatorInfo)
        VerifyCerts(hMsg);

    if (fAuthAttr)
        VerifyUnprotectedAttr(hMsg);

    // Get ciphertext
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_CONTENT_PARAM,
        0,                      // dwIndex
        NULL,                   // pvData
        &cbCiphertext
        );
    if (!fResult)
        PrintLastError("GetRecipientInfoAndDecrypt::CryptMsgGetParam(ciphertext length)");
    else {
        if (pbCiphertext = (BYTE *) TestAlloc(cbCiphertext)) {
            fResult = CryptMsgGetParam(
                hMsg,
                CMSG_CONTENT_PARAM,
                0,                      // dwIndex
                pbCiphertext,
                &cbCiphertext
                );
            if (!fResult)
                PrintLastError("GetRecipientInfoAndDecrypt::CryptMsgGetParam(ciphertext content)");
            TestFree(pbCiphertext);
            pbCiphertext = NULL;
        }
    }

    if (fCmsRecipient) {
        fResult = GetCmsRecipientInfoAndDecrypt(hMsg);
        goto CommonReturn;
    }
#endif  // CMS_PKCS7

    if (fNoRecipients) {
        fResult = TRUE;
        goto CommonReturn;
    }

    DecryptPara.cbSize = sizeof(DecryptPara);
    DecryptPara.hCryptProv = hCryptProv;
    DecryptPara.dwKeySpec = 0;
    DecryptPara.dwRecipientIndex = RECIPIENT_COUNT -1;
    fResult = CryptMsgControl(
        hMsg,
        0,                  // dwFlags
        CMSG_CTRL_DECRYPT,
        &DecryptPara
        );
    if (!fResult) {
        PrintLastError(
            "GetRecipientInfoAndDecrypt::CryptMsgControl(CMSG_CTRL_DECRYPT)");
        goto ErrorReturn;
    }

    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;

CommonReturn:
    TestFree(pRecipientInfo);

    return fResult;
PRINT_ERROR(GetRecipientInfoAndDecrypt,CheckGetRecipientCountError)
}

void CompareCertIdWithCertInfo(
    IN PCERT_ID pCertId,
    IN PCERT_INFO pCertInfo
    )
{
    BOOL fKeyId;
    CRYPT_HASH_BLOB KeyId;
    
    fKeyId = Asn1UtilExtractKeyIdFromCertInfo(pCertInfo, &KeyId);
    switch(pCertId->dwIdChoice) {
        case CERT_ID_ISSUER_SERIAL_NUMBER:
            if (fKeyId)
                printf("CompareCertIdWithCertInfo:: failed => bad IssuerSerialNumber choice\n");
            else if (pCertInfo->Issuer.cbData !=
                pCertId->IssuerSerialNumber.Issuer.cbData ||
                    0 != memcmp(pCertInfo->Issuer.pbData,
                        pCertId->IssuerSerialNumber.Issuer.pbData,
                        pCertInfo->Issuer.cbData) ||
                pCertInfo->SerialNumber.cbData !=
                    pCertId->IssuerSerialNumber.SerialNumber.cbData ||
                        0 != memcmp(pCertInfo->SerialNumber.pbData,
                            pCertId->IssuerSerialNumber.SerialNumber.pbData,
                            pCertInfo->SerialNumber.cbData))
                printf("CompareCertIdWithCertInfo:: failed => bad IssuerSerialNumber comparison\n");
            break;
        case CERT_ID_KEY_IDENTIFIER:
            if (!fKeyId)
                printf("CompareCertIdWithCertInfo:: failed => bad KeyId choice\n");
            else if (KeyId.cbData != pCertId->KeyId.cbData ||
                    0 != memcmp(KeyId.pbData,
                        pCertId->KeyId.pbData,
                        KeyId.cbData))
                printf("CompareCertIdWithCertInfo:: failed => bad KeyId comparison\n");
            break;
        default:
            printf("CompareCertIdWithCertInfo:: failed => invalid dwIdChoice\n");
            break;
    }
}

//+-------------------------------------------------------------------------
// Allocate and get the CMSG_SIGNER_INFO_PARAM from the message
//--------------------------------------------------------------------------
PCMSG_SIGNER_INFO GetSignerInfoFromMsg(
    IN HCRYPTMSG hMsg,
    IN DWORD dwIndex
    )
{
    PCMSG_SIGNER_INFO    psi;
    DWORD           cbData;

    if (!TCM_AllocGetParam(
            hMsg,
            CMSG_SIGNER_INFO_PARAM,
            dwIndex,
            (PBYTE *)&psi,
            &cbData))
        return NULL;

#ifdef CMS_PKCS7
    PCMSG_CMS_SIGNER_INFO    pCMSsi;

    if (TCM_AllocGetParam(
            hMsg,
            CMSG_CMS_SIGNER_INFO_PARAM,
            dwIndex,
            (PBYTE *)&pCMSsi,
            &cbData)) {
        CERT_INFO CertInfo;
        CertInfo.Issuer = psi->Issuer;
        CertInfo.SerialNumber = psi->SerialNumber;
        CompareCertIdWithCertInfo(&pCMSsi->SignerId, &CertInfo);
        TestFree(pCMSsi);
    }
#endif  // CMS_PKCS7

    return psi;
}

//+-------------------------------------------------------------------------
// Allocate and get the CMSG_SIGNER_CERT_INFO_PARAM or CMSG_RECIPIENT_INFO_PARAM
// from the message
//--------------------------------------------------------------------------
PCERT_INFO GetCertIdFromMsg(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex
    )
{
    PCERT_INFO pCertId;
    DWORD cbData;

    if (!TCM_AllocGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            (PBYTE *)&pCertId,
            &cbData))
        return NULL;

#ifdef CMS_PKCS7
    if (CMSG_SIGNER_CERT_INFO_PARAM == dwParamType) {
        PCERT_ID pSignerId;

        if (TCM_AllocGetParam(
                hMsg,
                CMSG_SIGNER_CERT_ID_PARAM,
                dwIndex,
                (PBYTE *)&pSignerId,
                &cbData)) {
            CompareCertIdWithCertInfo(pSignerId, pCertId);
            TestFree(pSignerId);
        }
    }
#endif  // CMS_PKCS7

    return pCertId;
}


//+-------------------------------------------------------------------------
// Get computed digest and digest data from a decoded CMSG_HASHED
//--------------------------------------------------------------------------
BOOL Undigest(IN HCRYPTMSG hMsg)
{
    return CryptMsgControl( hMsg, 0, CMSG_CTRL_VERIFY_HASH, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tcrobu\tcrobu.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       tcrobu.cpp
//
//  Contents:   CryptRetrieveObjectByUrl tests
//
//  History:    27-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#include <wininet.h>
#include <md5.h>

#include <cryptnet.h>
typedef BYTE CRYPT_ORIGIN_IDENTIFIER[MD5DIGESTLEN];
BYTE Foo[300];
BYTE Bar[300];

DWORD	g_dwCount = 0;
//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   prints the usage statement
//
//----------------------------------------------------------------------------
static void Usage(void)
{
    printf("Usage: tcrobu URL [ObjectOid] [-m] [-c] [-s] [-w] [-l]\n");
    printf("              URL, locator to retrieve from\n");
    printf("              ObjectOid, a cert, crl, or ctl, if omitted, retrieve bits\n");
    printf("              -m, retrieve multiple objects\n");
    printf("              -c, cache only retrieval\n");
    printf("              -d, do not cache the result\n");
    printf("              -w, wire only retrieval\n");
    printf("              -u, CryptGetObjectUrl on the result context\n");
    printf("              -l, logon user credentials <user> <password>\n");
    printf("              -t, timeout\n");
	printf("              -f, install cancel function\n");
	printf("              -n, install and uninstall cancel function\n");
	printf("              -r, the # of times the cancel function should be called\n");
	printf("              -v, verbose display\n");
	printf("              -q, quiet display\n");
	printf("              -s, save to serialized store file\n");
	printf("              -7, save to PKCS7 store file\n");
	printf("              -a, get AuxInfo\n");
	printf("              -p, sticky persist\n");
	printf("              -e, prepend LDAP entry and attribute\n");
	printf("              -k, Kerberos Signing for LDAP\n");
}

//+---------------------------------------------------------------------------
//
//  Function:   CertGetOriginIdentifier
//
//  Synopsis:   get the origin identifier for a certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertGetOriginIdentifier (
                IN PCCERT_CONTEXT pCertContext,
                IN PCCERT_CONTEXT pIssuer,
                IN DWORD dwFlags,
                OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                )
{
    MD5_CTX    md5ctx;
    PCERT_INFO pCertInfo = pCertContext->pCertInfo;
    PCERT_INFO pIssuerCertInfo = pIssuer->pCertInfo;

    MD5Init( &md5ctx );

    MD5Update( &md5ctx, pCertInfo->Issuer.pbData, pCertInfo->Issuer.cbData );
    MD5Update( &md5ctx, pCertInfo->Subject.pbData, pCertInfo->Subject.cbData );

    MD5Update(
       &md5ctx,
       (LPBYTE)pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId,
       strlen( pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId )
       );

    MD5Update(
       &md5ctx,
       pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
       pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData
       );

    // We assume that the unused public key bits are zero
    MD5Update(
       &md5ctx,
       pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
       pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData
       );

    MD5Update(
       &md5ctx,
       pIssuerCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
       pIssuerCertInfo->SubjectPublicKeyInfo.PublicKey.cbData
       );

    MD5Final( &md5ctx );

    memcpy( OriginIdentifier, md5ctx.digest, MD5DIGESTLEN );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   MyCancelFunction
//
//  Synopsis:   The call back function to cancel the object retrieval.
//				The cancellation happens when it is called for the 3rd time.
//
//----------------------------------------------------------------------------
BOOL WINAPI MyCancelFunction(DWORD dwFlags, void *pvArg)
{
	DWORD *pCount=NULL;

	pCount=(DWORD *)pvArg;
							   
	if(*pCount == g_dwCount)
		return TRUE;

	(*pCount)++;  

	return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   main program entry point
//
//----------------------------------------------------------------------------
int _cdecl main(int argc, char * argv[])
{
#if 0
    BOOL      fResult;
    HINTERNET hInetSession;

    hInetSession = InternetOpen(
                           "foo",
                           INTERNET_OPEN_TYPE_PRECONFIG,
                           NULL,
                           NULL,
                           0
                           );

    if ( hInetSession == NULL )
    {
        printf("Error opening internet session %lx\n", GetLastError());
        return( 1 );
    }

    fResult = InternetSetOption(
                      hInetSession,
                      INTERNET_OPTION_USERNAME,
                      "foo",
                      strlen( "foo" ) + 1
                      );

    if ( fResult == TRUE )
    {
        fResult = InternetSetOption(
                          hInetSession,
                          INTERNET_OPTION_PROXY_USERNAME,
                          "bar",
                          strlen( "bar" ) + 1
                          );
    }

    if ( fResult == TRUE )
    {
        fResult = InternetSetOption(
                          hInetSession,
                          INTERNET_OPTION_PASSWORD,
                          "gamma",
                          strlen( "gamma" ) + 1
                          );

        if ( fResult == TRUE )
        {
            fResult = InternetSetOption(
                              hInetSession,
                              INTERNET_OPTION_PROXY_PASSWORD,
                              "beta",
                              strlen( "beta" ) + 1
                              );
        }
    }

    InternetCloseHandle( hInetSession );

    return( 0 );
#endif

#if 0

    LPWSTR pwszUrl = NULL;

    if ( I_CryptNetGetUserDsStoreUrl( L"X509Certificate", &pwszUrl ) == TRUE )
    {
        wprintf(L"User DS Store URL = <%s>\n", pwszUrl);
        CryptMemFree( pwszUrl );
    }
    else
    {
        printf("I_CryptNetGetUserDsStoreUrl failed <%lx>\n", GetLastError());
    }

    return( 0 );

#endif

#if 1
    ULONG                       cCount;
    PCRYPT_BLOB_ARRAY           pcba;
    LPVOID                      pv;
    LPSTR                       pszObjectOid = NULL;
    LPSTR                       pszUrl = NULL;
    LPSTR                       pszUsername = NULL;
    LPSTR                       pszPassword = NULL;
    LPSTR                       pszDomain = NULL;
    DWORD                       dwRetrievalFlags = 0;
    BOOL                        fGetObjectUrl = FALSE;
    PCRYPT_CREDENTIALS          pCredentials = NULL;
    CRYPT_CREDENTIALS           Credentials;
    CRYPT_PASSWORD_CREDENTIALSA PasswordCredentials;
    DWORD                       dwTimeout = 0;
	BOOL						fCancel = FALSE;
	BOOL						fUninstall = FALSE;
	DWORD						dwCount = 0;
    BOOL                        fQuiet = FALSE;
    DWORD                       dwDisplayFlags = 0;
    BOOL                        fSave = FALSE;
    BOOL                        fPKCS7Save = FALSE;
    LPSTR                       pszSaveFilename = NULL;

    PCRYPT_RETRIEVE_AUX_INFO    pAuxInfo = NULL;
    FILETIME                    LastSyncTime = { 0, 0 };
    CRYPT_RETRIEVE_AUX_INFO     AuxInfo;

    if ( argc < 2 )
    {
        Usage();
        return( 1 );
    }

    argv++;
    argc--;

    printf( "command line: %s\n", GetCommandLineA() );

    pszUrl = argv[0];

    while ( --argc > 0 )
    {
        if ( **++argv == '-' )
        {
            switch( argv[0][1] )
            {
            case 'm':
            case 'M':
                dwRetrievalFlags |= CRYPT_RETRIEVE_MULTIPLE_OBJECTS;
                break;
            case 'c':
            case 'C':
                dwRetrievalFlags |= CRYPT_CACHE_ONLY_RETRIEVAL;
                break;
            case 'w':
            case 'W':
                dwRetrievalFlags |= CRYPT_WIRE_ONLY_RETRIEVAL;
                break;
            case 'f':
            case 'F':
                fCancel = TRUE;
                break;
            case 'n':
            case 'N':
                fUninstall = TRUE;
                break;
            case 'd':
            case 'D':
                dwRetrievalFlags |= CRYPT_DONT_CACHE_RESULT;
                break;
            case 'u':
            case 'U':
                fGetObjectUrl = TRUE;
                break;
            case 't':
            case 'T':

                if ( argc < 2 )
                {
                    Usage();
                    return( 1 );
                }

                dwTimeout = atol( argv[1] );
                argc -= 1;
                argv++;
                break;
            case 'r':
            case 'R':

                if ( argc < 2 )
                {
                    Usage();
                    return( 1 );
                }

                g_dwCount = atol( argv[1] );
                argc -= 1;
                argv++;
                break;
            case 'l':
            case 'L':

                if ( argc < 2 )
                {
                    Usage();
                    return( 1 );
                }

                pszUsername = argv[1];

                if ( argc > 2 )
                {
                    pszPassword = argv[2];
                    argc--;
                    argv++;
                }

                argc -= 1;
                argv++;
                break;
            case 'q':
            case 'Q':
                fQuiet = TRUE;
                break;
            case 'v':
            case 'V':
                dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                break;
            case '7':
                fPKCS7Save = TRUE;
            case 's':
            case 'S':
                fSave = TRUE;
                if ( argc < 2 )
                {
                    Usage();
                    return( 1 );
                }

                pszSaveFilename = argv[1];
                argc -= 1;
                argv++;
                break;
            case 'a':
            case 'A':
                pAuxInfo = &AuxInfo;
                memset(&AuxInfo, 0, sizeof(AuxInfo));
                AuxInfo.cbSize = sizeof(AuxInfo);
                AuxInfo.pLastSyncTime = &LastSyncTime;
                break;
            case 'p':
            case 'P':
                dwRetrievalFlags |= CRYPT_STICKY_CACHE_RETRIEVAL;
                break;
            case 'e':
            case 'E':
                dwRetrievalFlags |= CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE;
                break;
            case 'k':
            case 'K':
                dwRetrievalFlags |= CRYPT_LDAP_SIGN_RETRIEVAL;
                break;
            default:
                Usage();
                return -1;
            }
        }
        else
        {
            if ( _stricmp( argv[0], "cert" ) == 0 )
            {
                pszObjectOid = (LPSTR)CONTEXT_OID_CERTIFICATE;
            }
            else if ( _stricmp( argv[0], "ctl" ) == 0 )
            {
                pszObjectOid = (LPSTR)CONTEXT_OID_CTL;
            }
            else if ( _stricmp( argv[0], "crl" ) == 0 )
            {
                pszObjectOid = (LPSTR)CONTEXT_OID_CRL;
            }
            else if ( _stricmp( argv[0], "pkcs7" ) == 0 )
            {
                pszObjectOid = (LPSTR)CONTEXT_OID_PKCS7;
            }
            else if ( _stricmp( argv[0], "any" ) == 0 )
            {
                pszObjectOid = (LPSTR)CONTEXT_OID_CAPI2_ANY;
            }
            else
            {
                Usage();
                return( -1 );
            }
        }
    }

    if ( pszUsername != NULL )
    {
        PasswordCredentials.cbSize = sizeof( PasswordCredentials );
        PasswordCredentials.pszUsername = pszUsername;
        PasswordCredentials.pszPassword = pszPassword;

        Credentials.cbSize = sizeof( Credentials );
        Credentials.pszCredentialsOid = CREDENTIAL_OID_PASSWORD_CREDENTIALS_A;
        Credentials.pvCredentials = (LPVOID)&PasswordCredentials;

        pCredentials = &Credentials;

        printf("Using credentials %s <%s>\n", pszUsername, pszPassword);
    }

	if(fCancel)
	{
		if(!CryptInstallCancelRetrieval(
						MyCancelFunction,
						&dwCount,
						0,
						NULL))
			printf("Install cancel function failed!\n");


		if(fUninstall)
		{
			if(!CryptUninstallCancelRetrieval(
							0,
							NULL))
				printf("Uninstall cancel function failed!\n");
		}
	}

    if ( CryptRetrieveObjectByUrlA(
              pszUrl,
              pszObjectOid,
              dwRetrievalFlags,
              dwTimeout,
              &pv,
              NULL,
              pCredentials,
              NULL,
              pAuxInfo
              ) == FALSE )
    {
        printf( "CryptRetrieveObjectByUrl FAILED! <%lx>\n", GetLastError() );

		if(fCancel)
		{
			if(!fUninstall)
			{
				if(!CryptUninstallCancelRetrieval(
								0,
								NULL))
					printf("Uninstall cancel function failed!\n");
			}
		}

        return( -1 );
    }

    printf( "CryptRetrieveObjectByUrl SUCCEEDED!\n" );

    if (pAuxInfo)
    {
        printf("  LastSyncTime:: %s\n",
            FileTimeText(&LastSyncTime));
    }

	if(fCancel)
	{
		if(!fUninstall)
		{
			if(!CryptUninstallCancelRetrieval(
							0,
							NULL))
				printf("Uninstall cancel function failed!\n");
		}
	}

    if ( pszObjectOid == NULL )
    {
        pcba = (PCRYPT_BLOB_ARRAY)pv;

        for ( cCount = 0; cCount < pcba->cBlob; cCount++ )
        {
            PBYTE pb = pcba->rgBlob[cCount].pbData;
            DWORD cb = pcba->rgBlob[cCount].cbData;

            printf( "\nObject#%d ", cCount+1);
            if (dwRetrievalFlags & CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE)
            {
                DWORD cbPrefix;
                LPCSTR pszIndex;
                LPCSTR pszAttr;

                pszIndex = (LPCSTR) pb;
                cbPrefix = strlen(pszIndex) + 1;
                pb += cbPrefix;
                cb -= cbPrefix;

                pszAttr = (LPCSTR) pb;
                cbPrefix = strlen(pszAttr) + 1;
                pb += cbPrefix;
                cb -= cbPrefix;

                printf("[%s, %s] ", pszIndex, pszAttr);
            }

            printf( "- Length=0x%lx\n", cb );
            PrintBytes(
                 "",
                 pb,
                 cb
                 );
        }

        CryptMemFree( pv );
    }
    else if ( pszObjectOid == CONTEXT_OID_CERTIFICATE )
    {
        if ( !( dwRetrievalFlags & CRYPT_RETRIEVE_MULTIPLE_OBJECTS ) )
        {
            DisplayCert( (PCCERT_CONTEXT)pv, dwDisplayFlags );

            if ( fGetObjectUrl == TRUE )
            {
#if 1
                DWORD cbUrlArray;

                if ( CryptGetObjectUrl(
                          URL_OID_CERTIFICATE_CRL_DIST_POINT,
                          pv,
                          0,
                          NULL,
                          &cbUrlArray,
                          NULL,
                          NULL,
                          NULL
                          ) == FALSE )
                {
                    printf("GetObjectUrl failed %lx\n", GetLastError());
                }
                else
                {
                    printf("cbUrlArray = %ld\n", cbUrlArray);
                }
#else
                DWORD                   cCount;
                LARGE_INTEGER           TickCount1;
                LARGE_INTEGER           TickCount2;
                LARGE_INTEGER           TickCount;
                CRYPT_ORIGIN_IDENTIFIER OriginIdentifier;

                #define NUM_ITER 1000000

                GetSystemTimeAsFileTime( (LPFILETIME)&TickCount1 );
                for ( cCount = 0; cCount < NUM_ITER; cCount++ )
                {
                    if ( memcmp( Foo, Bar, 100 ) != 0 )
                    {
                        Foo[0] = 1;
                        Bar[0] = 1;
                    }
                    if ( memcmp( Foo, Bar, 200 ) != 0 )
                    {
                        Foo[0] = 1;
                        Bar[0] = 1;
                    }
                    if ( memcmp( Foo, Bar, 64 ) != 0 )
                    {
                        Foo[0] = 1;
                        Bar[0] = 1;
                    }
                    if ( memcmp( Foo, Bar, 128 ) != 0 )
                    {
                        Foo[0] = 1;
                        Bar[0] = 1;
                    }

                    //CertGetOriginIdentifier(
                    //    (PCCERT_CONTEXT)pv,
                    //   (PCCERT_CONTEXT)pv,
                    //    0,
                    //    OriginIdentifier
                    //    );
                }
                GetSystemTimeAsFileTime( (LPFILETIME)&TickCount2 );
                TickCount.QuadPart = ( TickCount2.QuadPart - TickCount1.QuadPart );
                printf("PerIter = %ld ns. Total = %ld s.\n", (((LPFILETIME)&TickCount)->dwLowDateTime / NUM_ITER) * 100, ((LPFILETIME)&TickCount)->dwLowDateTime / 10000000);
#endif
            }

            CertFreeCertificateContext( (PCCERT_CONTEXT)pv );
        }
        else
        {
            if (!fQuiet)
                DisplayStore( (HCERTSTORE)pv, dwDisplayFlags );
            if (fSave && pszSaveFilename)
                SaveStoreEx( (HCERTSTORE)pv, fPKCS7Save, pszSaveFilename);
            CertCloseStore( (HCERTSTORE)pv, 0 );
        }
    }
    else if ( pszObjectOid == CONTEXT_OID_CTL )
    {
        if ( !( dwRetrievalFlags & CRYPT_RETRIEVE_MULTIPLE_OBJECTS ) )
        {
            DisplayCtl( (PCCTL_CONTEXT)pv, dwDisplayFlags );
            CertFreeCTLContext( (PCCTL_CONTEXT)pv );
        }
        else
        {
            if (!fQuiet)
                DisplayStore( (HCERTSTORE)pv, dwDisplayFlags );
            if (fSave && pszSaveFilename)
                SaveStoreEx( (HCERTSTORE)pv, fPKCS7Save, pszSaveFilename);
            CertCloseStore( (HCERTSTORE)pv, 0 );
        }
    }
    else if ( pszObjectOid == CONTEXT_OID_CRL )
    {
        if ( !( dwRetrievalFlags & CRYPT_RETRIEVE_MULTIPLE_OBJECTS ) )
        {
            DisplayCrl( (PCCRL_CONTEXT)pv, dwDisplayFlags );
            CertFreeCRLContext( (PCCRL_CONTEXT)pv );
        }
        else
        {
            if (!fQuiet)
                DisplayStore( (HCERTSTORE)pv,  dwDisplayFlags );
            if (fSave && pszSaveFilename)
                SaveStoreEx( (HCERTSTORE)pv, fPKCS7Save, pszSaveFilename);
            CertCloseStore( (HCERTSTORE)pv, 0 );
        }
    }
    else if ( ( pszObjectOid == CONTEXT_OID_CAPI2_ANY ) ||
              ( pszObjectOid == CONTEXT_OID_PKCS7 ) )
    {
        if (!fQuiet)
            DisplayStore( (HCERTSTORE)pv,  dwDisplayFlags );
        if (fSave && pszSaveFilename)
            SaveStoreEx( (HCERTSTORE)pv, fPKCS7Save, pszSaveFilename);
        CertCloseStore( (HCERTSTORE)pv, 0 );
    }

    return( 0 );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\test\capi20\tdecode\tdecode.cpp ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       tdecode.cpp
//
//  Contents:   API testing of CryptEncodeObject/CryptDecodeObject.  
//
//  History:    22-January-97   xiaohs   created
//              
//--------------------------------------------------------------------------


#include "tdecode.h"

//--------------------------------------------------------------------------
//	 Globals
//--------------------------------------------------------------------------

//the count of errors in the program
DWORD				g_dwErrCnt=0; 	

HCRYPTPROV			g_hProv=NULL;


//--------------------------------------------------------------------------
//	The utility function to display the parameters for the input.
//--------------------------------------------------------------------------
static void Usage(void)
{
	printf("\n");
    printf("Usage: tdecode [options] <FileTypes><Filename>\n");
	printf("\n");
	printf("FileTypes are(case sensitive):\n");
	printf("  C                -This is a certificate file\n");
	printf("  R                -This is a certificate request blob file\n");
	printf("  S                -This is a signed message file\n");
	printf("\n");
    printf("Options are(case sensitive):\n");
    printf("  -i               - A complete test on cbEncoded in CryptDecodeObject\n");
	printf("                     Default does not do the check\n");
    printf("  -o               - A complete test on *pcbStructInfo on CryptDecodeObject\n");
	printf("                     Default does not do the check\n");
	printf("  -b               - A complete test on *pcbStructInfo and cbEncoded\n");
	printf("                     Default does not do the check\n");
    printf("\n");

	return;
}

//--------------------------------------------------------------------------
//	The utility function to display a message that the test is not exeucted
//--------------------------------------------------------------------------
static void NotExecuted(void)
{	
	printf("*****************************************************\n");
	printf("  Summary information for TDecode Test	\n");
	printf("*****************************************************\n"); \
	printf("\n");
	printf("The test is not executed!\n");

	return;
}

//--------------------------------------------------------------------------
//	 The main program that Decode/Encode Certifitcate, Certificate Request,
//	 and CRL.
//--------------------------------------------------------------------------
void _cdecl main(int argc, char * argv[])
{		  
	BOOL				fStructLengthCheck=FALSE;
	BOOL				fBLOBLengthCheck=FALSE;
	DWORD				dwFileType=0;
	LPSTR				pszFilename=NULL;
	BYTE				pbByte[100]=
						{0x00, 0xa1, 0x23, 0x45, 0x56, 0x78, 0x9a, 0xbc,0xdf,0xee, 
						 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0XFF, 0xA6, 0x8f,0xe4, 0x0f,
						 0x00, 0xa1, 0x23, 0x45, 0x56, 0x78, 0x9a, 0xbc,0xdf,0xee, 
						 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0XFF, 0xA6, 0x8f,0xe4, 0x0f,
						 0x00, 0xa1, 0x23, 0x45, 0x56, 0x78, 0x9a, 0xbc,0xdf,0xee, 
						 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0XFF, 0xA6, 0x8f,0xe4, 0x0f,
					     0x00, 0xa1, 0x23, 0x45, 0x56, 0x78, 0x9a, 0xbc,0xdf,0xee, 
						 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0XFF, 0xA6, 0x8f,0xe4, 0x0f,
						 0x00, 0xa1, 0x23, 0x45, 0x56, 0x78, 0x9a, 0xbc,0xdf,0xee, 
						 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0XFF, 0xA6, 0x8f,0xe4, 0x0f};



    //parsing through the command line input parameters
	while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
				case 'i':
						fBLOBLengthCheck=TRUE;
					break;

				case 'o':
						fStructLengthCheck=TRUE;
					break;

				case 'b':
						fBLOBLengthCheck=TRUE;
						fStructLengthCheck=TRUE;
					break;

				default:
					Usage();
					NotExecuted();
					return;
            }
        } 
		else
		{
			//parsing through the file name
            switch(**argv)
            {
				case 'C':
						dwFileType=CERT_CRL_FILE;
					break;

				case 'R':
						dwFileType=CERT_REQUEST_FILE;
					break;

				case 'S':
						dwFileType=SIGNED_MSG_FILE;
					break;

				default:
					Usage();
					NotExecuted();
					return;
            }

			//make sure there is a file name specified
			if(argv[0][1]=='\0')
			{
				Usage();
				NotExecuted();
				return;
			}

			//get the file name
            pszFilename = &(argv[0][1]);
		}
    }


	//if the file name is NULL, something is wrong in the input parameter
	if(!pszFilename)
	{
		Usage();
		NotExecuted();
		return;
	}

   	
	//acquireContext
	TESTC(CryptAcquireContext(&g_hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT),TRUE)

	//test PKCS_UTC_TIME
	TESTC(VerifyPKCS_UTC_TIME(fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//test PKCS_TIME_REQUEST
	TESTC(VerifyPKCS_TIME_REQUEST(fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//decode the corresponding file types.
	switch(dwFileType)
	{
		case CERT_CRL_FILE:
				TESTC(DecodeCertFile(pszFilename,fStructLengthCheck,
					fBLOBLengthCheck),TRUE)
			break;

		case CERT_REQUEST_FILE:
				TESTC(DecodeCertReqFile(pszFilename,fStructLengthCheck,
					fBLOBLengthCheck),TRUE)
			break;

		case SIGNED_MSG_FILE:
				TESTC(DecodeSignedMsgFile(pszFilename,fStructLengthCheck,
					fBLOBLengthCheck),TRUE)
			break;

		default:
			break;
	}


TCLEANUP: 
	
	//release the CSP
	if(g_hProv)
		TCHECK(CryptReleaseContext(g_hProv,0),TRUE);

	//print out the test result
	DisplayTestResult(g_dwErrCnt);
}

//--------------------------------------------------------------------------
//	 Local Functions
//--------------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////////// 
//Error Manipulations
//--------------------------------------------------------------------------
//	 DisplayTestResult
//--------------------------------------------------------------------------

void	DisplayTestResult(DWORD	dwErrCnt)
{	   

		printf("*****************************************************\n");
		printf("  Summary information for TDecode Test	\n");
		printf("*****************************************************\n");
		printf("\n");

		if(!dwErrCnt)
			printf("This test succeeded!\n");
		else
			printf("This test failed with total %d errors!\n",dwErrCnt);

		return;
}

//--------------------------------------------------------------------------
//	Validate the return code is the same as expected.  If they are not the 
//  same, increment the error count and print out the file name and the line
//  number.
//--------------------------------------------------------------------------
BOOL	Validate(DWORD dwErr, BOOL	fSame, char *szFile, DWORD	dwLine)
{

	if(fSame)
		return TRUE;
	printf("*****************************************************\n");
	printf("Error: %d 0x%x occurred at file %s line %d\n\n",
        dwErr, dwErr, szFile, dwLine);
	g_dwErrCnt++;
	return FALSE;
}


//--------------------------------------------------------------------------
//	Output the two BLOBs.  One is the original one, the other is the
// BLOB encoded by pvStructInfo.
//--------------------------------------------------------------------------
void	OutputError(LPCSTR	lpszStructType, DWORD cbSecondEncoded, DWORD cbEncoded,
					BYTE *pbSecondEncoded, BYTE *pbEncoded)
{		
		DWORD	cbMin=0;

		printf("------------------------------------------------------\n");
		printf("An inconsistency in BLOBs has been found!\n");

		//print out the lpszStructType
		if(((DWORD_PTR)lpszStructType)>>8 == 0)
			printf("The lpszStructType is %d.\n",(DWORD)(DWORD_PTR)lpszStructType);
		else
			printf("The lpszStructType is %s.\n",lpszStructType);

		printf("\n");

		//print out the size of BLOBs
		printf("The original cbEncoded is %d.\n",cbEncoded);
		printf("The new cbEncoded is %d.\n",cbSecondEncoded);
		printf("\n");

		//see if the min of cbEncoded and cbSecondEncoded is the same
		if(cbSecondEncoded>cbEncoded)
			cbMin=cbEncoded;
		else
			cbMin=cbSecondEncoded;

		if(memcmp(pbSecondEncoded,pbEncoded,cbMin)==0)
			printf("The two blobs are the same up to %dth byte.\n",cbMin);

		//print out all the bytes in the BLOBs
		printf("The original BLOB is:\n");

		PrintBytes("    ", pbEncoded, cbEncoded);
		
		printf("\n");

		printf("The new BLOB is:\n");

		PrintBytes("   ",pbSecondEncoded, cbSecondEncoded);

		return;
}

//--------------------------------------------------------------------------
//	Print out the Byte in 16 bytes per row and their corresponding HEX.
//--------------------------------------------------------------------------
void PrintBytes(LPCSTR pszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;

    while (cbSize > 0)
    {
        printf("%s", pszHdr);
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            printf(" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        pb += cb;
        printf("'\n");
    }
}


///////////////////////////////////////////////////////////////////////////
//General Testing routings

//--------------------------------------------------------------------------
//	Validate CryptEncodeObject/CryptDecodeObject handle the NULL or invalid 
//	parameters correctly.
//--------------------------------------------------------------------------
BOOL	ParameterTest(LPCSTR lpszStructType, DWORD cbEncoded, BYTE *pbEncoded)
{
	BOOL		fSucceeded=FALSE;
	DWORD		cbStructInfo=0;
	void		*pvStructInfo=NULL;	 
	DWORD		cbCorrectSize=0;
	DWORD		cbLengthOnly=0;
	DWORD		cbSecondEncoded=0;
	BYTE		*pbSecondEncoded=NULL;
	DWORD		dwReturn=0;
	DWORD		dwEncodingType=CRYPT_ENCODE_TYPE;


	//init
	assert(cbEncoded);
	assert(pbEncoded);
	assert(lpszStructType);

	//We have different decoding type for PKCS7_SIGNER_INFO
	if((DWORD_PTR)(lpszStructType)==(DWORD_PTR)(PKCS7_SIGNER_INFO))
		dwEncodingType=MSG_ENCODING_TYPE;


	cbSecondEncoded=cbEncoded;
	pbSecondEncoded=(BYTE *)SAFE_ALLOC(cbEncoded);
	CHECK_POINTER(pbSecondEncoded)

	//Decode the BLOB correctly

	cbStructInfo=1000;

	TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,
		cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,NULL,&cbStructInfo),TRUE)

	cbLengthOnly=cbStructInfo;

	//allocate the memory
	pvStructInfo=SAFE_ALLOC(cbStructInfo);
	CHECK_POINTER(pvStructInfo);

	TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,
		cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),TRUE)

	cbCorrectSize=cbStructInfo;

	//Test incorrect ENCODING type
	//pass X509_NDR_ENCODING
	TESTC(CryptDecodeObject(X509_NDR_ENCODING,lpszStructType,pbEncoded,
		cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),FALSE)

	//	Since we do not know the correct return code, make sure at least
	//S_OK is not returned.

	TCHECK(GetLastError()!=S_OK, TRUE);

	TESTC(CryptEncodeObject(X509_NDR_ENCODING, lpszStructType,pvStructInfo,
		pbSecondEncoded,&cbSecondEncoded),FALSE)

	TCHECK(GetLastError()!=S_OK, TRUE);

	//pass X509_NDR_ENCODING|X509_ASN_ENCODING
	TESTC(CryptDecodeObject(X509_NDR_ENCODING|X509_ASN_ENCODING,lpszStructType,pbEncoded,
		cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),FALSE)

	TCHECK(GetLastError()!=S_OK, TRUE);

	TESTC(CryptEncodeObject(X509_NDR_ENCODING|X509_ASN_ENCODING, lpszStructType,pvStructInfo,
		pbSecondEncoded,&cbSecondEncoded),FALSE)

	TCHECK(GetLastError()!=S_OK, TRUE);

	//Test invalid/unsupported lpszStructType
	//passing NULL for lpszStructType
	TESTC(CryptDecodeObject(dwEncodingType,CRYPT_ENCODE_DECODE_NONE,pbEncoded,
		cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),FALSE)

	TCHECK(GetLastError()!=S_OK, TRUE);

	TESTC(CryptEncodeObject(dwEncodingType, CRYPT_ENCODE_DECODE_NONE,pvStructInfo,
		pbSecondEncoded,&cbSecondEncoded),FALSE)

	TCHECK(GetLastError()!=S_OK, TRUE);

	//passing invalid lpszStructType
	TESTC(CryptDecodeObject(dwEncodingType,INVALID_LPSZSTRUCTTYPE,pbEncoded,
		cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),FALSE)

	TCHECK(GetLastError()!=S_OK, TRUE);

	TESTC(CryptEncodeObject(dwEncodingType, INVALID_LPSZSTRUCTTYPE,pvStructInfo,
		pbSecondEncoded,&cbSecondEncoded),FALSE)

	TCHECK(GetLastError()!=S_OK, TRUE);

	// CryptEncodeObject:	pbEncoded is not NULL while cbEncoded is 0.
	cbSecondEncoded=0;
	TESTC(CryptEncodeObject(dwEncodingType, lpszStructType,pvStructInfo,
		pbSecondEncoded,&cbSecondEncoded),FALSE)

	TCHECK(GetLastError(),ERROR_MORE_DATA);

	//CryptDecodeObject:	pvStructInfo is not NULL while pcbStructInfo is 0
	 cbStructInfo=0;
	 TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,
		cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),FALSE)

	TCHECK(cbStructInfo,cbCorrectSize);

	TCHECK(GetLastError(),ERROR_MORE_DATA);


	//CryptDecodeObject: Pass invalid blobs
	cbSecondEncoded=(DWORD)(cbEncoded/2);

	TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,
		cbEncoded-cbSecondEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),FALSE)

	dwReturn=GetLastError();
    // Ignore ASN1_ERR_EOD
    if (dwReturn != 0x80093102) {
        TCHECKALL(dwReturn,CRYPT_E_BAD_ENCODE, CRYPT_E_OSS_ERROR+DATA_ERROR);
    }

	//CryptDecodeObject: Pass cbEncoded=0
	TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,
		0,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),FALSE)

	dwReturn=GetLastError();
    if (dwReturn != 0x80093102) {
        TCHECKALL(dwReturn,CRYPT_E_BAD_ENCODE, CRYPT_E_OSS_ERROR+MORE_INPUT);
    }


	//CryptDecodeObject: lpszStructType mismatches pbEncoded
	TESTC(MismatchTest(lpszStructType, cbEncoded, pbEncoded,cbLengthOnly),TRUE)

	fSucceeded=TRUE;


TCLEANUP:
	//release memory
	SAFE_FREE(pbSecondEncoded)

	SAFE_FREE(pvStructInfo)

	return fSucceeded;
}




//--------------------------------------------------------------------------
//	The routine to test CryptDecodeObject() handles the mismatch between
//	lpszStructType and pbEncoded  
//
//	PreCondition:	This routine assumes that lpszStructType's high-order
//					word is 0 and the low order word specifies the integer
//					identifier for the type of the given structure.
//
//	cbCorrectStructInfo is the correct size for pvStructInfo in CryptDecodeObject
//--------------------------------------------------------------------------

BOOL	MismatchTest(LPCSTR lpszStructType, DWORD cbEncoded, BYTE *pbEncoded,
					 	DWORD	cbCorrectStructInfo)
{
	BOOL		fSucceeded=FALSE;
	DWORD		dwrgSize=0;
	DWORD		dwError=0;
	ULONG		iIndex=0;
	void		*pvStructInfo=NULL;
	DWORD		cbStructInfo=cbCorrectStructInfo;
	DWORD		dwEncodingType=CRYPT_ENCODE_TYPE;
	LPCSTR		rglpszStructType[]={X509_CERT_TO_BE_SIGNED,
									X509_CERT_CRL_TO_BE_SIGNED,      
									X509_CERT_REQUEST_TO_BE_SIGNED,  
									X509_EXTENSIONS,
									X509_NAME_VALUE,
									X509_NAME,                       
									X509_PUBLIC_KEY_INFO,            
									X509_AUTHORITY_KEY_ID,        
									X509_KEY_ATTRIBUTES,          
									X509_KEY_USAGE_RESTRICTION,   
									X509_ALTERNATE_NAME,          
									X509_BASIC_CONSTRAINTS,       
									X509_KEY_USAGE,               
									X509_BASIC_CONSTRAINTS2,      
									X509_CERT_POLICIES,           
									PKCS_UTC_TIME,        
									PKCS_TIME_REQUEST,    
									RSA_CSP_PUBLICKEYBLOB,
									PKCS7_SIGNER_INFO};



	//init	
	dwrgSize=sizeof(rglpszStructType)/sizeof(rglpszStructType[0]);

	//We have different decoding type for PKCS7_SIGNER_INFO
	if((DWORD_PTR)(lpszStructType)==(DWORD_PTR)(PKCS7_SIGNER_INFO))
		dwEncodingType=MSG_ENCODING_TYPE;

	pvStructInfo=SAFE_ALLOC(cbCorrectStructInfo);
	CHECK_POINTER(pvStructInfo);

	//start to decode the BLOB.  Should fail when lpszStructType mismatches pbEncoded
	for(iIndex=0; iIndex<dwrgSize; iIndex++)
	{
		cbStructInfo=cbCorrectStructInfo;

		//skip the test if lpszStructType==X509_NAME_VALUE since the X509_NAME_VALUE 
		//allows any encoded type. It has the dwValueType CERT_RDN_ENCODED_BLOB.
	    if((DWORD_PTR)(rglpszStructType[iIndex])==(DWORD_PTR)X509_NAME_VALUE)
			continue;

		//if lpszStructType is the correct type, TRUE should be returned.
		if((DWORD_PTR)lpszStructType==(DWORD_PTR)(rglpszStructType[iIndex]))
		{
		   	TESTC(CryptDecodeObject(dwEncodingType, rglpszStructType[iIndex],
				pbEncoded,cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),TRUE)

		}
		else
		{
			//error should occur
			TESTC(CryptDecodeObject(dwEncodingType, rglpszStructType[iIndex],
				pbEncoded,cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),FALSE)

			//test the return code 
			dwError=GetLastError();

			//we are not sure that should be expected here.  The following error has 
			//occurred:
			//E_INVALIDARG, CRYPT_E_OSS_ERROR+PDU_MISMATCH, +DATA_ERROR, or
			//+MORE_INPUT
			
			//make sure at lease S_OK is not returned
			TCHECK(dwError!=S_OK, TRUE);
		}
	}


	fSucceeded=TRUE;

TCLEANUP:

	//release the memory
	SAFE_FREE(pvStructInfo)

	return	fSucceeded;

}
///////////////////////////////////////////////////////////////////////////////
//General Decode/Encode Testing routines

//--------------------------------------------------------------------------
//	Get a BLOB based on an input file.  
//
//--------------------------------------------------------------------------
BOOL	RetrieveBLOBfromFile(LPSTR	pszFileName,DWORD *pcbEncoded,BYTE **ppbEncoded)
{
	BOOL	fSucceeded=FALSE;
	DWORD	cCount=0;
	HANDLE	hFile=NULL;

	assert(pszFileName);
	assert(pcbEncoded);
	assert(ppbEncoded);


	if((hFile = CreateFile(pszFileName,
            GENERIC_READ,
            0, NULL, OPEN_EXISTING, 0, NULL))==INVALID_HANDLE_VALUE)
	   PROCESS_ERR_GOTO("Can not open the file!\n");


	//Get the size of the file
	cCount=GetFileSize(hFile, NULL);

	//make sure the file is not empty
	TESTC(cCount!=0, TRUE)				   
	 	 
	//allocate memory
	*ppbEncoded=(BYTE *)SAFE_ALLOC(cCount);
	*pcbEncoded=cCount;

	//fill the buffer
	TESTC(ReadFile( hFile,*ppbEncoded, *pcbEncoded,&cCount,NULL),TRUE)

	//make sure that we have the right number of bytes
	TESTC(cCount,*pcbEncoded) 
	
	fSucceeded=TRUE;

TCLEANUP:
	
	if(hFile)
		CloseHandle(hFile);

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	A general routine to encode the singer info struct and 
//  add Attributes to the structur if there was none
//
//--------------------------------------------------------------------------
BOOL	EncodeSignerInfoWAttr(PCMSG_SIGNER_INFO pSignerInfo,DWORD *pbSignerEncoded,
								BYTE **ppbSignerEncoded)
{

	BOOL	fSucceeded=FALSE;
	//add attribute to the CMSG_SINGER_INFO struct if necessary
	//make up the attributes
	BYTE							rgAttribValue1[]={0x02, 0x02, 0x11, 0x11};
	BYTE							rgAttribValue2[]={0x02, 0x02, 0x11, 0x11};

	//make 3 CRYPT_ATTRIBUTE
	CRYPT_ATTRIBUTE					rgCryptAttribute[3];
	CRYPT_ATTR_BLOB					rgAttribBlob[3];
	
	rgAttribBlob[0].cbData=sizeof(rgAttribValue2);
	rgAttribBlob[0].pbData=rgAttribValue2;

	rgAttribBlob[1].cbData=sizeof(rgAttribValue2);
	rgAttribBlob[1].pbData=rgAttribValue2;

	rgAttribBlob[2].cbData=sizeof(rgAttribValue1);
	rgAttribBlob[2].pbData=rgAttribValue1;


	rgCryptAttribute[0].pszObjId="1.2.3.4";
	rgCryptAttribute[0].cValue=0;
	rgCryptAttribute[0].rgValue=NULL;

	rgCryptAttribute[1].pszObjId="1.2.3.4";
	rgCryptAttribute[1].cValue=1;
	rgCryptAttribute[1].rgValue=rgAttribBlob;

	rgCryptAttribute[2].pszObjId="1.2.3.4";
	rgCryptAttribute[2].cValue=3;
	rgCryptAttribute[2].rgValue=rgAttribBlob;

	//if pSingerInfo does not include any attributes, add attributes
	//to the struct
	if(pSignerInfo->AuthAttrs.cAttr==0)
	{
		pSignerInfo->AuthAttrs.cAttr=1;
		pSignerInfo->AuthAttrs.rgAttr=rgCryptAttribute;
	}

	if(pSignerInfo->UnauthAttrs.cAttr==0)
	{
		pSignerInfo->AuthAttrs.cAttr=3;
		pSignerInfo->AuthAttrs.rgAttr=rgCryptAttribute;
	}	

	//encode the struct
	TESTC(CryptEncodeObject(MSG_ENCODING_TYPE,PKCS7_SIGNER_INFO,
			pSignerInfo,NULL,pbSignerEncoded),TRUE)
			
	//allocate memory
	*ppbSignerEncoded=(BYTE *)SAFE_ALLOC(*pbSignerEncoded);
	CHECK_POINTER(*ppbSignerEncoded);

	//encode
	TESTC(CryptEncodeObject(MSG_ENCODING_TYPE,PKCS7_SIGNER_INFO,
			pSignerInfo,*ppbSignerEncoded,pbSignerEncoded),TRUE)



	fSucceeded=TRUE;

TCLEANUP:

	return fSucceeded;

}


//--------------------------------------------------------------------------
//	A general routine compare two time stamp request
//
//--------------------------------------------------------------------------
BOOL	CompareTimeStampRequest(CRYPT_TIME_STAMP_REQUEST_INFO *pReqNew,
								CRYPT_TIME_STAMP_REQUEST_INFO *pReqOld)
{

	BOOL	fSucceeded=FALSE;
	DWORD	iIndex=0;
	DWORD	iValue=0;


    TESTC(_stricmp(pReqNew->pszTimeStampAlgorithm, 
		pReqOld->pszTimeStampAlgorithm),0)
		
	TESTC(_stricmp(pReqNew->pszContentType, pReqOld->pszContentType),0)
	
    TESTC(pReqNew->Content.cbData, pReqOld->Content.cbData)
	
	
	TESTC(memcmp(pReqNew->Content.pbData,pReqOld->Content.pbData,
				 pReqNew->Content.cbData),0)

	TESTC(pReqNew->cAttribute, pReqOld->cAttribute)


	for(iIndex=0; iIndex<pReqNew->cAttribute;iIndex++)
	{
		TESTC(_stricmp(pReqNew->rgAttribute[iIndex].pszObjId,
			   pReqOld->rgAttribute[iIndex].pszObjId),0)

		TESTC(pReqNew->rgAttribute[iIndex].cValue,
			   pReqOld->rgAttribute[iIndex].cValue)


		for(iValue=0;iValue<pReqNew->rgAttribute[iIndex].cValue;iValue++)
		{
			TESTC(pReqNew->rgAttribute[iIndex].rgValue[iValue].cbData,
			pReqOld->rgAttribute[iIndex].rgValue[iValue].cbData)

			TESTC(memcmp(pReqNew->rgAttribute[iIndex].rgValue[iValue].pbData,
			pReqOld->rgAttribute[iIndex].rgValue[iValue].pbData,
			pReqOld->rgAttribute[iIndex].rgValue[iValue].cbData),0)

		}

	}

	fSucceeded=TRUE;

TCLEANUP:
   return fSucceeded;

}

//--------------------------------------------------------------------------
//	A general routine to verify the algorithm parameters is NULL.
//
//	cbData==2 and pbData=0x05 0x00 
//--------------------------------------------------------------------------
BOOL	VerifyAlgorithParam(PCRYPT_ALGORITHM_IDENTIFIER pAlgorithm)
{
	BOOL	fSucceeded=FALSE;				   

	TESTC((pAlgorithm->Parameters).cbData, 2);

	TESTC((BYTE)((pAlgorithm->Parameters).pbData[0])==(BYTE)5,TRUE);

	TESTC((BYTE)((pAlgorithm->Parameters).pbData[1])==(BYTE)0,TRUE);


	fSucceeded=TRUE;

TCLEANUP:
	return fSucceeded;

}

//--------------------------------------------------------------------------
//	A general routine to verify the PKCS_UTC_TIME
//
//--------------------------------------------------------------------------
BOOL	VerifyPKCS_UTC_TIME(BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL		fSucceeded=FALSE;
	DWORD		cbEncoded=0;
	BYTE		*pbEncoded=NULL;
	DWORD		dwError;

	FILETIME	FileTime;

	//setup the struct
	FileTime.dwLowDateTime=0;
	FileTime.dwHighDateTime=31457160;

	//encode the struct into a BLOB
	TESTC(CryptEncodeObject(CRYPT_ENCODE_TYPE,PKCS_UTC_TIME,
		&FileTime,NULL,&cbEncoded),TRUE)



	pbEncoded=(BYTE *)SAFE_ALLOC(cbEncoded);
	CHECK_POINTER(pbEncoded)

	TESTC(CryptEncodeObject(CRYPT_ENCODE_TYPE,PKCS_UTC_TIME,
		&FileTime,pbEncoded,&cbEncoded),TRUE)

   //decode the struct with COPY and NOCOPY options
	TESTC(DecodeGenericBLOB(PKCS_UTC_TIME,cbEncoded, pbEncoded, CRYPT_DECODE_COPY_FLAG, 
						TRUE,fStructLengthCheck, fBLOBLengthCheck),TRUE)


	TESTC(DecodeGenericBLOB(PKCS_UTC_TIME,cbEncoded, pbEncoded, CRYPT_DECODE_NOCOPY_FLAG, 
						TRUE,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	fSucceeded=TRUE;


TCLEANUP:

	//print out the errors
	if(!fSucceeded)
	{
		dwError=GetLastError();
		printf("********The last error is %d\n",dwError);

		//print out the pbEnco