ATE(hTBSB, TRUE, SW_SHOW);
}



VOID
InitLBCB(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    UINT        idLBCB,
    UINT        SetCurSelID,
    POPTTYPE    pOptType,
    WORD        InitItemIdx,
    LONG        NewSel,
    WORD        InitFlags,
    UINT        cyLBCBMax
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Aug-1995 Fri 14:32:19 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hLBCB;
    DWORD       dw;
    LONG        Ret;
    LONG        CurSel;
    BOOL        IsLB = (BOOL)(SetCurSelID == LB_SETCURSEL);
    GSBUF_DEF(pItem, MAX_RES_STR_CHARS);


    if ((!idLBCB) || (!(hLBCB = GetDlgItem(hDlg, idLBCB)))) {

        return;
    }

    if ((!IsLB)                     &&
        (InitFlags & INITCF_INIT)   &&
        (SendMessage(hLBCB, CB_GETDROPPEDSTATE, 0, 0))) {

        InitFlags &= ~INITCF_INIT;
    }

    if (InitFlags & INITCF_INIT) {

        HWND        hCtrl;
        HDC         hDC;
        HGDIOBJ     hOld;
        POPTPARAM   pOP;
        TEXTMETRIC  tm;
        RECT        rc;
        RECT        rcC;
        INT         InsertID;
        INT         SetItemDataID;
        UINT        i;
        LONG        cxCBEdit = 0;
        LONG        cyCBEdit;
        LONG        cMaxLB = 0;
        LONG        cShow;
        UINT        cyLBCB;
        UINT        cyFrame;
        SIZEL       szlText;


        //
        // Figure we need to draw icon
        //

        _OT_FLAGS(pOptType) &= ~OTINTF_ITEM_HAS_ICON16;

        if (!(pOptType->Style & OTS_LBCB_NO_ICON16_IN_ITEM)) {

            ULONG_PTR   IconID;


            i   = (UINT)pOptType->Count;
            pOP = pOptType->pOptParam;

            if (((DWORD)NewSel >= (DWORD)pOptType->Count)   ||
                (pOptType->Style & OTS_LBCB_INCL_ITEM_NONE)) {

                IconID = pTVWnd->OptParamNone.IconID;

            } else {

                IconID = pOP->IconID;
            }

            while (i--) {

                if (!(pOP->Flags & OPTPF_HIDE)) {

                    if (// (IconID)                ||
                        (IconID != pOP->IconID) ||
                        (pOP->Flags & (OPTPF_OVERLAY_WARNING_ICON   |
                                       OPTPF_OVERLAY_STOP_ICON      |
                                       OPTPF_OVERLAY_NO_ICON))) {

                        _OT_FLAGS(pOptType) |= OTINTF_ITEM_HAS_ICON16;
                        break;
                    }
                }

                pOP++;
            }
        }

        hOld = SelectObject(hDC = GetWindowDC(hLBCB),
                            (HANDLE)SendMessage(hLBCB, WM_GETFONT, 0, 0L));
        GetTextMetrics(hDC, &tm);

        CPSUIINT(("InitLBCB: Font Height=%ld, cyEdge=%ld",
                    tm.tmHeight, GetSystemMetrics(SM_CYEDGE)));

        if ((_OT_FLAGS(pOptType) & OTINTF_ITEM_HAS_ICON16)  &&
            (tm.tmHeight < (LONG)pTVWnd->cyImage)) {

            cyLBCB = (UINT)pTVWnd->cyImage;

        } else {

            cyLBCB = (UINT)tm.tmHeight + 2;
        }

        CPSUIDBG(DBG_TMP, ("CB: cyImage=%ld, cyicon=%ld, tmHeight=%ld",
                pTVWnd->cyImage, CYICON, tm.tmHeight));

#if DO_IN_PLACE
        //
        // If it is in Treeview then we need to have exact tmHeight, otherwise
        // we need to add 2 for focus rect and another two to compensate the
        // cyImage, 16+2+2=20=CYICON, at dialog box template we need to add
        // one dialog box unit for the spacing.
        //

        cyCBEdit = tm.tmHeight + ((IS_TVDLG) ? 0 : 4);
#else
        cyCBEdit = (LONG)cyLBCB;
#endif

        tm.tmHeight = (LONG)cyLBCB;

        CPSUIDBG(DBG_CB_CY, ("cyCBEdit=%ld, ItemHeight=%ld",
                                            cyCBEdit, tm.tmHeight));

        SendMessage(hLBCB, WM_SETREDRAW, (WPARAM)FALSE, 0L);

        if (IsLB) {

            //
            // Resize the listbox based on the height
            //

            hCtrlrcWnd(hDlg, hLBCB, &rc);
            GetClientRect(hLBCB, &rcC);

            cyLBCB  = (UINT)(rc.bottom - rc.top);
            cyFrame = (UINT)(cyLBCB - rcC.bottom);
            i       = (UINT)((cyLBCBMax - cyFrame) % tm.tmHeight);

            CPSUIRECT(0, "  rcLBCB", &rc, cyLBCB, cyFrame);
            CPSUIRECT(0, "rcClient", &rcC, i,
                                (UINT)((cyLBCBMax - cyFrame) / tm.tmHeight));

            if ((IS_TVDLG) || (!(InitFlags & INITCF_ENABLE))) {

                cMaxLB  = -(LONG)((cyLBCBMax - cyFrame) / tm.tmHeight);
            }

            cyLBCB = cyLBCBMax - i;

            if (IS_TVDLG) {

                rc.top = pTVWnd->tLB;
            }

            SetWindowPos(hLBCB, NULL,
                         rc.left, rc.top += (i / 2),
                         rc.right - rc.left, cyLBCB,
                         SWP_NOZORDER | SWP_FRAMECHANGED | SWP_DRAWFRAME);

            CPSUIINT(("LB: Frame=%ld, cyLBCB=%ld, Count=%ld, %ld less pels",
                        cyFrame, cyLBCB, cMaxLB, tm.tmHeight - i));


            InsertID = (pOptType->Style & OTS_LBCB_SORT) ? LB_ADDSTRING :
                                                           LB_INSERTSTRING;
            SendMessage(hLBCB, LB_SETITEMHEIGHT, 0, MAKELPARAM(tm.tmHeight,0));
            SendMessage(hLBCB, LB_RESETCONTENT, 0, 0L);

            SetItemDataID = LB_SETITEMDATA;

            HCTRL_SETCTRLDATA(hLBCB, CTRLS_LISTBOX, pOptType->Type);

        } else {

            InsertID = (pOptType->Style & OTS_LBCB_SORT) ? CB_ADDSTRING :
                                                           CB_INSERTSTRING;

            SendMessage(hLBCB,
                        CB_SETITEMHEIGHT,
                        (WPARAM)-1,
                        MAKELPARAM(cyCBEdit, 0));

            //
            // Aligned the static text with new combox edit field when this
            // combo box is not in treeview page
            //

            if ((!IS_TVDLG)                             &&
                (hCtrl = GetDlgItem(hDlg, idLBCB - 1))  &&
                (hCtrlrcWnd(hDlg, hCtrl, &rcC))         &&
                (hCtrlrcWnd(hDlg, hLBCB, &rc))) {

                SetWindowPos(hCtrl,
                             NULL,
                             rcC.left,
                             rc.top + ((rc.bottom - rc.top) -
                                       (rcC.bottom - rcC.top)) / 2,
                             0, 0,
                             SWP_NOZORDER | SWP_NOSIZE);
            }

            SendMessage(hLBCB,
                        CB_SETITEMHEIGHT,
                        (WPARAM)0,
                        MAKELPARAM(tm.tmHeight, 0));

            SendMessage(hLBCB, CB_RESETCONTENT, 0, 0L);

            SetItemDataID = CB_SETITEMDATA;

            HCTRL_SETCTRLDATA(hLBCB, CTRLS_COMBOBOX, pOptType->Type);
        }

        for (i = 0, cShow = 0, pOP = pOptType->pOptParam;
             i < (UINT)pOptType->Count;
             i++, pOP++) {

            if (!(pOP->Flags & OPTPF_HIDE)) {

                GSBUF_RESET;
                GSBUF_GETSTR(pOP->pData);

                CurSel = (LONG)SendMessage(hLBCB,
                                           InsertID,
                                           (WPARAM)-1,
                                           (LPARAM)GSBUF_BUF);
#if DO_IN_PLACE
                GetTextExtentPoint(hDC, GSBUF_BUF, GSBUF_COUNT,  &szlText);

                if (szlText.cx > cxCBEdit) {

                    cxCBEdit = szlText.cx;
                }
#endif
                dw = (DWORD)i;

                if (pOP->Flags & OPTPF_DISABLED) {

                    dw |= LBCBID_DISABLED;

                } else {

                    ++cShow;
                }

                SendMessage(hLBCB, SetItemDataID, (WPARAM)CurSel, (LPARAM)dw);

                ++cMaxLB;
            }
        }

        if ((!cShow)                                    ||
            ((DWORD)NewSel >= (DWORD)pOptType->Count)   ||
            (pOptType->Style & OTS_LBCB_INCL_ITEM_NONE)) {

            //
            // Always add it to the begnining
            //

            GSBUF_RESET;
            GSBUF_GETSTR(pTVWnd->OptParamNone.pData);

            CurSel = (LONG)SendMessage(hLBCB,
                                       (IsLB) ? LB_INSERTSTRING :
                                                CB_INSERTSTRING,
                                       (WPARAM)0,
                                       (LPARAM)GSBUF_BUF);

#if DO_IN_PLACE
            GetTextExtentPoint(hDC, GSBUF_BUF, GSBUF_COUNT,  &szlText);

            if (szlText.cx > cxCBEdit) {

                cxCBEdit = szlText.cx;
            }
#endif
            SendMessage(hLBCB,
                        SetItemDataID,
                        (WPARAM)CurSel,
                        (LPARAM)LBCBID_NONE);

            ++cShow;
            ++cMaxLB;
        }

        if ((IsLB) && (IS_TVDLG)) {

            if (cMaxLB < 0) {

                //
                // We got some items which is blank, then re-size the LISTBOX
                //

                CPSUIINT(("Resize LB: cMaxLB=%ld, cyLBCB=%ld [%ld]",
                                    cMaxLB, cyLBCB, -cMaxLB * tm.tmHeight));

                cMaxLB = -cMaxLB * tm.tmHeight;

                SetWindowPos(hLBCB, NULL,
                             rc.left, rc.top + (cMaxLB / 2),
                             rc.right - rc.left, cyLBCB - (UINT)cMaxLB,
                             SWP_NOZORDER | SWP_FRAMECHANGED | SWP_DRAWFRAME);
            }

            cMaxLB = 0;
        }

        while (cMaxLB++ < 0) {

            CurSel = (LONG)SendMessage(hLBCB,
                                       (IsLB) ? LB_INSERTSTRING :
                                                CB_INSERTSTRING,
                                       (WPARAM)-1,
                                       (LPARAM)L"");

            SendMessage(hLBCB,
                        SetItemDataID,
                        (WPARAM)CurSel,
                        (LPARAM)LBCBID_FILL);
        }

        HCTRL_STATE(hLBCB, TRUE, SW_SHOW);
#if DO_IN_PLACE
        if ((!IsLB)                     &&
            (IS_TVDLG)                  &&
            (pTVWnd->hWndTV)            &&
            (TreeView_GetItemRect(pTVWnd->hWndTV,
                                  _OI_HITEM(pItem),
                                  &rc,
                                  TRUE))) {

            LONG    cxReal;
            LONG    OrgL;
            RECT    rcWnd;

            pTVWnd->ptCur.x = rc.left;
            pTVWnd->ptCur.y = rc.top;

            OrgL           = rc.right;
            rc.left        = rc.right + pTVWnd->cxSelAdd;

            if (_OT_FLAGS(pOptType) & OTINTF_ITEM_HAS_ICON16) {

                cxCBEdit += (CXIMAGE + LBCB_ICON_TEXT_X_SEP);
            }

            cxCBEdit += (LBCB_ICON_X_OFF + pTVWnd->cxCBAdd);
            cxReal    = cxCBEdit;

            GetClientRect(pTVWnd->hWndTV, &rcWnd);
            rcWnd.right -= pTVWnd->cxSelAdd;

            if (pTVWnd->hWndEdit[1]) {

                rcWnd.right -= (pTVWnd->cxExtAdd + _OI_CXEXT(pItem));
            }

            if ((cxCBEdit + rc.left) > rcWnd.right && cxCBEdit > (LONG)(pTVWnd->cxAveChar * 20)) {

                cxCBEdit = rcWnd.right - rc.left;

                if (cxCBEdit < (LONG)(pTVWnd->cxAveChar * 20)) {

                    cxCBEdit = (LONG)(pTVWnd->cxAveChar * 20);
                } 
            }

            rc.right = rc.left + cxCBEdit;

            SetWindowPos(pTVWnd->hWndEdit[0] = hLBCB,
                         NULL,
                         rc.left,
                         rc.top,
                         rc.right - rc.left,
                         tm.tmHeight * 14,
                         SWP_NOZORDER | SWP_FRAMECHANGED | SWP_DRAWFRAME);

            CPSUIINT(("LBCB Combo = (%ld, %ld): %ld x %ld",
                    rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top));

            SendMessage(hLBCB, CB_SETDROPPEDWIDTH, (WPARAM)cxReal, 0);

            //
            // Following code is only for exposing combo box name in MSAA
            //
            {
                TVITEM      tvi;
                HWND        hCtrl;
                GSBUF_DEF(pItem, MAX_RES_STR_CHARS);

                tvi.hItem       = _OI_HITEM(pItem);
                tvi.mask        = TVIF_TEXT;
                tvi.pszText     = GSBUF_BUF;
                tvi.cchTextMax  = MAX_RES_STR_CHARS;

                if (TreeView_GetItem(pTVWnd->hWndTV, &tvi) && (hCtrl = GetDlgItem(pTVWnd->hWndTV, IDD_TV_MSAA_NAME)))
                {
                    SetWindowText(hCtrl, tvi.pszText);

                    //
                    // Insert the invisible label ahead of the combo box.
                    //
                    SetWindowPos(hCtrl, hLBCB, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);
                    SetWindowPos(hLBCB, hCtrl, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);
                }
            }

            if (pTVWnd->hWndEdit[1]) {

                pTVWnd->chWndEdit = 2;

                rc.left  = rc.right + pTVWnd->cxExtAdd;
                rc.right = rc.left + (LONG)_OI_CXEXT(pItem);

                SetWindowPos(pTVWnd->hWndEdit[1],
                             hLBCB,
                             rc.left,
                             rc.top,
                             rc.right - rc.left,
                             rc.bottom - rc.top + 1,    // (LONG)_OI_CYEXTADD(pItem),
                             SWP_FRAMECHANGED | SWP_DRAWFRAME);

            } else {

                pTVWnd->chWndEdit = 1;
            }

            pTVWnd->cxEdit = (WORD)(rc.right - OrgL);
            pTVWnd->cxItem = (WORD)(rc.right - pTVWnd->ptCur.x);

            CPSUIINT(("!! cxEdit=%ld, cxItem=%ld, cxMaxItem==%ld",
                        pTVWnd->cxEdit, pTVWnd->cxItem, pTVWnd->cxMaxItem));
        }
#endif
        SelectObject(hDC, hOld);
        ReleaseDC(hLBCB, hDC);

        SendMessage(hLBCB, WM_SETREDRAW, (WPARAM)TRUE, 0L);
        InvalidateRect(hLBCB, NULL, FALSE);
    }

    GSBUF_RESET;

    if ((DWORD)NewSel >= (DWORD)pOptType->Count) {

        GSBUF_GETSTR(pTVWnd->OptParamNone.pData);

    } else {

        GSBUF_GETSTR(pOptType->pOptParam[NewSel].pData);
    }

    if (IsLB) {

        if ((CurSel = (LONG)SendMessage(hLBCB,
                                        LB_FINDSTRINGEXACT,
                                        (WPARAM)-1,
                                        (LPARAM)GSBUF_BUF)) == LB_ERR) {

            CurSel = 0;
        }

    } else {

        if ((CurSel = (LONG)SendMessage(hLBCB,
                                        CB_FINDSTRINGEXACT,
                                        (WPARAM)-1,
                                        (LPARAM)GSBUF_BUF)) == CB_ERR) {

            CurSel = 0;
        }
    }

    _OI_LBCBSELIDX(pItem) = (WORD)CurSel;

    if ((InitFlags & INITCF_INIT) && (!IsLB)) {

        CPSUIDBG(DBG_CBWNDPROC, ("CBPreSel=%ld", CurSel));

        SetProp(hLBCB, CPSUIPROP_CBPRESEL, LongToHandle(CurSel + 1));
    }

    if (((Ret = (LONG)SendMessage(hLBCB,
                                  (IsLB) ? LB_GETCURSEL : CB_GETCURSEL,
                                  0,
                                  0)) == LB_ERR)    ||
        (Ret != CurSel)) {

        SendMessage(hLBCB, SetCurSelID, (WPARAM)CurSel, 0);
    }

}




VOID
InitEditBox(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    POPTPARAM   pOptParam,
    UINT        EditBoxID,
    UINT        PostfixID,
    UINT        HelpID,
    WORD        InitItemIdx,
    LPTSTR      pCurText,
    WORD        InitFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Aug-1995 Fri 14:44:59 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hCtrl;


    hCtrl = GetDlgItem(hDlg, EditBoxID);

    HCTRL_SETCTRLDATA(hCtrl, CTRLS_EDITBOX, (BYTE)pOptParam[1].IconID);
    HCTRL_STATE(hCtrl, TRUE, SW_SHOW);

    if (InitFlags & INITCF_INIT) {

        RECT    rc;
        GSBUF_DEF(pItem, MAX_RES_STR_CHARS);


        GSBUF_FLAGS |= GBF_PREFIX_OK;

        if (hCtrl) {

            SendMessageW(hCtrl,
                         EM_SETLIMITTEXT,
                         (WPARAM)pOptParam[1].IconID - 1,
                         0L);

            GSBUF_GETSTR(pCurText);
            SetWindowText(hCtrl, GSBUF_BUF);
        }
#if DO_IN_PLACE
        PostfixID =
        HelpID    = 0;
#endif

#if DO_IN_PLACE
        if ((IS_TVDLG)  &&
            (TreeView_GetItemRect(pTVWnd->hWndTV,
                                  _OI_HITEM(pItem),
                                  &rc,
                                  TRUE))) {

            LONG    cxEdit;
            LONG    OrgL;
            RECT    rcWnd;

            pTVWnd->ptCur.x = rc.left;
            pTVWnd->ptCur.y = rc.top;

            OrgL    = rc.right;
            rc.left = rc.right + pTVWnd->cxSelAdd;

            cxEdit  = (LONG)(pOptParam[1].IconID - 1) * (LONG)pTVWnd->cxAveChar;

            GetClientRect(pTVWnd->hWndTV, &rcWnd);
            rcWnd.right -= pTVWnd->cxSelAdd;

            if (pTVWnd->hWndEdit[1]) {

                rcWnd.right -= (pTVWnd->cxExtAdd + _OI_CXEXT(pItem));
            }

            if ((cxEdit + rc.left) > rcWnd.right) {

                cxEdit = rcWnd.right - rc.left;

                if (cxEdit < (LONG)(pTVWnd->cxAveChar * 16)) {

                    cxEdit = (LONG)(pTVWnd->cxAveChar * 16);
                }
            }

            rc.right = rc.left + cxEdit;

            SetWindowPos(pTVWnd->hWndEdit[0] = hCtrl,
                         NULL,
                         rc.left,
                         rc.top,
                         rc.right - rc.left,
                         rc.bottom - rc.top + 1,
                         SWP_NOZORDER | SWP_FRAMECHANGED | SWP_DRAWFRAME);

            if (pTVWnd->hWndEdit[1]) {

                pTVWnd->chWndEdit = 2;

                rc.left  = rc.right + pTVWnd->cxExtAdd;
                rc.right = rc.left + _OI_CXEXT(pItem);

                SetWindowPos(pTVWnd->hWndEdit[1],
                             hCtrl,
                             rc.left,
                             rc.top,
                             rc.right - rc.left,
                             rc.bottom - rc.top + (LONG)_OI_CYEXTADD(pItem),
                             SWP_FRAMECHANGED | SWP_DRAWFRAME);

            } else {

                pTVWnd->chWndEdit = 1;
            }

            pTVWnd->cxEdit = (WORD)(rc.right - OrgL);
            pTVWnd->cxItem = (WORD)(rc.right - pTVWnd->ptCur.x);
        }
#endif
        ID_TEXTSTATE(PostfixID, pOptParam[0].pData, TRUE, SW_SHOW);
        ID_TEXTSTATE(HelpID,    pOptParam[1].pData, TRUE, SW_SHOW);
    }
}




VOID
InitPushButton(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    WORD        PushID,
    WORD        InitItemIdx,
    WORD        InitFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Aug-1995 Fri 15:36:54 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hPush;
    RECT    rc;


    if (hPush = CtrlIDrcWnd(hDlg, PushID, &rc)) {

        SETCTRLDATA(hPush, CTRLS_PUSHBUTTON, 0);

        if (InitFlags & INITCF_INIT) {

            POPTTYPE    pOptType;
            GSBUF_DEF(pItem, MAX_RES_STR_CHARS + 40);

#if (DO_IN_PLACE == 0)
            GSBUF_FLAGS |= GBF_PREFIX_OK;
#endif
            if ((IS_HDR_PUSH(pOptType = GET_POPTTYPE(pItem))) &&
                (IS_TVDLG)) {
#if DO_IN_PLACE
                GSBUF_GETSTR(IDS_CPSUI_REVERT);
#else
                GSBUF_GETINTSTR((pTVWnd->Flags & TWF_ONE_REVERT_ITEM) ?
                                    IDS_INT_CPSUI_UNDO_OPT :
                                    IDS_INT_CPSUI_UNDO_OPTS);
#endif
            } else {
#if DO_IN_PLACE
                GSBUF_GETSTR((pOptType->Style & OTS_PUSH_INCL_SETUP_TITLE) ?
                                IDS_CPSUI_SETUP : IDS_CPSUI_PROPERTIES);

                GSBUF_GETSTR(IDS_CPSUI_MORE);
#else
                if (pOptType->Style & OTS_PUSH_INCL_SETUP_TITLE) {

                    GSBUF_COMPOSE(IDS_INT_CPSUI_SETUP, pItem->pName, 0, 0);

                } else {

                    GSBUF_GETSTR(pItem->pName);
                }
#endif
            }

#if (DO_IN_PLACE == 0)
            if (!(pOptType->Style & OTS_PUSH_NO_DOT_DOT_DOT)) {

                GSBUF_GETSTR(IDS_CPSUI_MORE);
            }

            if (IS_TVDLG) {

                //
                // Adjust the size of push button
                //

                SetPushSize(pTVWnd,
                            hPush,
                            GSBUF_BUF,
                            GSBUF_COUNT,
                            SPSF_USE_BUTTON_CY |
                            ((InitFlags & INITCF_HAS_EXT) ?
                                                    SPSF_ALIGN_EXTPUSH : 0));
            }
#endif
            SetWindowText(hPush, GSBUF_BUF);

#if DO_IN_PLACE
            if ((IS_TVDLG)  &&
                (TreeView_GetItemRect(pTVWnd->hWndTV,
                                      _OI_HITEM(pItem),
                                      &rc,
                                      TRUE))) {

                SIZEL   szlText;
                LONG    OrgL;

                pTVWnd->ptCur.x = rc.left;
                pTVWnd->ptCur.y = rc.top;


                OrgL           = rc.right;
                rc.left        = rc.right + pTVWnd->cxSelAdd + 1;

                GetTextExtentPoint(pTVWnd->hDCTVWnd,
                                   GSBUF_BUF,
                                   GSBUF_COUNT,
                                   &szlText);

                rc.right = rc.left + szlText.cx + (LONG)(pTVWnd->cxSpace * 4);

                SetWindowPos(pTVWnd->hWndEdit[0] = hPush,
                             NULL,
                             rc.left,
                             rc.top,
                             rc.right - rc.left,
                             rc.bottom - rc.top,
                             SWP_NOZORDER | SWP_DRAWFRAME | SWP_FRAMECHANGED);

                if (pTVWnd->hWndEdit[1]) {

                    pTVWnd->chWndEdit = 2;
                    rc.left           = rc.right + pTVWnd->cxExtAdd;
                    rc.right          = rc.left + (LONG)_OI_CXEXT(pItem);

                    SetWindowPos(pTVWnd->hWndEdit[1],
                                 hPush,
                                 rc.left,
                                 rc.top,
                                 rc.right - rc.left,
                                 rc.bottom - rc.top + (LONG)_OI_CYEXTADD(pItem),
                                 SWP_FRAMECHANGED | SWP_DRAWFRAME);

                } else {

                    pTVWnd->chWndEdit = 1;
                }

                pTVWnd->cxEdit = (WORD)(rc.right - OrgL);
                pTVWnd->cxItem = (WORD)(rc.right - pTVWnd->ptCur.x);
            }
#endif
        }

        SHOWCTRL(hPush, TRUE, SW_SHOW);
    }
}



VOID
InitChkBox(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    UINT        ChkBoxID,
    LPTSTR      pTitle,
    WORD        InitItemIdx,
    BOOL        Checked,
    WORD        InitFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Aug-1995 Fri 15:41:15 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hCtrl;
    RECT    rc;


    hCtrl = GetDlgItem(hDlg, ChkBoxID);

    HCTRL_SETCTRLDATA(hCtrl, CTRLS_CHKBOX, 0);

    if (InitFlags & INITCF_INIT) {

        GSBUF_DEF(pItem, MAX_RES_STR_CHARS);

        GSBUF_FLAGS |= GBF_PREFIX_OK;

        HCTRL_TEXT(hCtrl, pTitle);

#if DO_IN_PLACE
        if ((IS_TVDLG)  &&
            (TreeView_GetItemRect(pTVWnd->hWndTV,
                                  _OI_HITEM(pItem),
                                  &rc,
                                  TRUE))) {

            TV_ITEM     tvi;
            TVLP        tvlp;
            LONG        cxChkBox;

            pTVWnd->ptCur.x = rc.left;
            pTVWnd->ptCur.y = rc.top;

            tvi.mask       = TVIF_PARAM | TVIF_TEXT;
            tvi.hItem      = _OI_HITEM(pItem);
            tvi.pszText    = GSBUF_BUF;
            tvi.cchTextMax = MAX_RES_STR_CHARS;

            if (TreeView_GetItem(pTVWnd->hWndTV, &tvi)) {

                HDC     hDC;
                HGDIOBJ hOld;
                SIZEL   szlText;

                hDC = GetWindowDC(pTVWnd->hWndTV);

                if (hDC) {

                    hOld = SelectObject(hDC, (HANDLE)SendMessage(pTVWnd->hWndTV,
                                                                 WM_GETFONT,
                                                                 0,
                                                                 0L));
                    if (hOld) {

                        tvlp  = GET_TVLP(tvi.lParam);

                        GetTextExtentPoint(hDC, tvi.pszText, tvlp.cName,  &szlText);

                        rc.left += szlText.cx;

                        GetTextExtentPoint(hDC, GSBUF_BUF, GSBUF_COUNT, &szlText);
                        cxChkBox = szlText.cx;

                        GetTextExtentPoint(hDC, L"M", 1, &szlText);
                        cxChkBox += szlText.cx;

                        SelectObject(hDC, hOld);
                    }

                    ReleaseDC(pTVWnd->hWndTV, hDC);
                }

            } else {

                cxChkBox = rc.right - rc.left;
            }

            cxChkBox += pTVWnd->cxChkBoxAdd;

            if ((rc.left + cxChkBox) < rc.right) {

                cxChkBox = rc.right - rc.left;
            }

            SetWindowText(hCtrl, L" ");

            SetWindowPos(pTVWnd->hWndEdit[0] = hCtrl,
                         NULL,
                         rc.left,
                         rc.top,
                         cxChkBox,
                         rc.bottom - rc.top,
                         SWP_NOZORDER | SWP_FRAMECHANGED | SWP_DRAWFRAME);

            if (pTVWnd->hWndEdit[1]) {

                pTVWnd->chWndEdit = 2;

                SetWindowPos(pTVWnd->hWndEdit[1],
                             hCtrl,
                             rc.left + cxChkBox + pTVWnd->cxExtAdd,
                             rc.top,
                             (LONG)_OI_CXEXT(pItem),
                             rc.bottom - rc.top + (LONG)_OI_CYEXTADD(pItem),
                             SWP_FRAMECHANGED | SWP_DRAWFRAME);

            } else {

                pTVWnd->chWndEdit = 1;
            }
        }
#endif
    }

    HCTRL_STATE(hCtrl, TRUE, SW_SHOW);
    CheckDlgButton(hDlg, ChkBoxID, (Checked) ? BST_CHECKED : BST_UNCHECKED);
}



BOOL
IsItemChangeOnce(
    PTVWND      pTVWnd,
    POPTITEM    pItem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    18-Sep-1995 Mon 17:43:35 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    POPTTYPE        pOptType;
    POPTPARAM       pOptParam;
    PDEVHTADJDATA   pDevHTAdjData;


    if (IS_HDR_PUSH(pOptType = GET_POPTTYPE(pItem))) {

        pItem->Flags &= ~OPTIF_CHANGEONCE;
        return(FALSE);

    } else {

        DWORD       FlagsAnd = OPTIF_CHANGEONCE;
        DWORD       FlagsOr  = 0;


        CPSUIINT(("Sel=%08lx, DefSel=%08lx",
                                    pItem->Sel, _OI_PDEFSEL(pItem)));

        switch (pOptType->Type) {

        case TVOT_EDITBOX:

            if (pTVWnd->Flags & TWF_ANSI_CALL) {

                CPSUIINT(("pEdit=%hs, pDefEdit=%hs",
                                pItem->pSel, _OI_PDEFSEL(pItem)));

                if (lstrcmpA((LPSTR)pItem->pSel, (LPSTR)_OI_PDEFSEL(pItem))) {

                    FlagsOr = OPTIF_CHANGEONCE;
                }

            } else {

                CPSUIINT(("pEdit=%s, pDefEdit=%s",
                            pItem->pSel, (LPTSTR)_OI_PDEFSEL(pItem)));

                if (lstrcmp(pItem->pSel, (LPTSTR)_OI_PDEFSEL(pItem))) {

                    FlagsOr = OPTIF_CHANGEONCE;
                }
            }

            break;

        case TVOT_PUSHBUTTON:

            //
            // The push button never changed
            //

            pOptParam = pOptType->pOptParam;

            switch (pOptParam->Style) {

            case PUSHBUTTON_TYPE_HTSETUP:

                pDevHTAdjData = (PDEVHTADJDATA)(pOptParam->pData);

                if (memcmp(_OI_PDEFSEL(pItem),
                           pDevHTAdjData->pAdjHTInfo,
                           sizeof(DEVHTINFO))) {

                    FlagsOr = OPTIF_CHANGEONCE;
                }

                break;

            case PUSHBUTTON_TYPE_HTCLRADJ:

                if (memcmp(_OI_PDEFSEL(pItem),
                           pOptParam->pData,
                           sizeof(COLORADJUSTMENT))) {

                    FlagsOr = OPTIF_CHANGEONCE;
                }

                break;

            default:

                FlagsAnd = 0;
                break;
            }

            break;

        default:

            if (pItem->pSel != (LPVOID)_OI_PDEFSEL(pItem)) {

                FlagsOr = OPTIF_CHANGEONCE;
            }

            break;
        }

        //
        // Now check the extended check box
        //

        if ((pItem->pExtChkBox)                         &&
            (!(pItem->Flags & OPTIF_EXT_IS_EXTPUSH))    &&
            ((pItem->Flags & OPTIF_ECB_MASK) !=
                                (_OI_DEF_OPTIF(pItem) & OPTIF_ECB_MASK))) {

            FlagsOr = OPTIF_CHANGEONCE;
        }

        pItem->Flags &= ~FlagsAnd;
        pItem->Flags |= FlagsOr;

        return((BOOL)FlagsOr);
    }
}




UINT
InternalDMPUB_COPIES_COLLATE(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    18-Sep-1995 Mon 15:11:07 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hCtrl;
    LONG    Sel;
    UINT    CtrlID;
    BOOL    IsTVDlg;


    Sel = pItem->Sel;

    //
    // Now check the copies or copy end text
    //

    if (IsTVDlg = (BOOL)(pTVWnd->Flags & TWF_IN_TVPAGE)) {

        CtrlID = IDD_TV_UDARROW_ENDTEXT;

    } else {

        CtrlID = (UINT)(pItem->pOptType->BegCtrlID + 4);
    }

    if (hCtrl = GetDlgItem(hDlg, CtrlID)) {

        LPTSTR  pData;

        pData = (LPTSTR)((ULONG_PTR)((Sel > 1) ? IDS_CPSUI_COPIES : IDS_CPSUI_COPY));

        if (pData != pItem->pOptType->pOptParam[0].pData) {

            GSBUF_DEF(pItem, MAX_RES_STR_CHARS);

            GSBUF_FLAGS |= GBF_PREFIX_OK;
            GSBUF_GETSTR(pData);

            SetWindowText(hCtrl, GSBUF_BUF);

            //
            // We also have set the ID here
            //

            pItem->pOptType->pOptParam[0].pData = pData;
        }
    }

    //
    // ONLY DO THIS IF THE ITEM IS CHANGABLE
    //

    if ((pTVWnd->Flags & TWF_CAN_UPDATE)        &&
        (!(pItem->Flags & (OPTIF_EXT_HIDE   |
#if DO_IN_PLACE
                            OPTIF_HIDE      |
#else
                            OPTIF_ITEM_HIDE |
#endif
                            OPTIF_DISABLED)))   &&
        (pItem->pExtChkBox)) {

        DWORD   dw;


        dw = (Sel <= 1) ? OPTIF_EXT_DISABLED : 0;

        if ((pItem->Flags & OPTIF_EXT_DISABLED) != dw) {

            pItem->Flags ^= OPTIF_EXT_DISABLED;
            pItem->Flags |= OPTIF_CHANGED;

            CtrlID = (UINT)((IsTVDlg) ? IDD_TV_EXTCHKBOX :
                                        pItem->pOptType->BegCtrlID + 7);

            if (hCtrl = GetDlgItem(hDlg, CtrlID)) {

                EnableWindow(hCtrl, !(BOOL)(pItem->Flags & OPTIF_EXT_DISABLED));
            }

            CPSUIINT(("InternalDMPUB_COPIES_COLLATE(Enable=%u)", (dw) ? 1 : 0));

            return(INTDMPUB_CHANGED);
        }
    }

    CPSUIINT(("InternalDMPUB_COPIES_COLLATE(), NO Changes"));

    return(0);
}




UINT
InternalDMPUB_QUALITY(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pQuality
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    18-Sep-1995 Mon 16:03:45 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    UINT Result = 0;


    if (pTVWnd->Flags & TWF_CAN_UPDATE) {

        POPTPARAM pParam = pQuality->pOptType->pOptParam;
        INT Count = pQuality->pOptType->Count;
        BOOL bChecked = (pQuality->Flags & OPTIF_ECB_CHECKED) ? TRUE: FALSE;

        while (Count--) {

            if (bChecked){

                pParam->Flags |= OPTPF_DISABLED;

            } else {

                if (pParam->dwReserved[0] == FALSE)
                    pParam->Flags &=~OPTPF_DISABLED;

            }

            pParam++;
        }

        pQuality->Flags |= OPTIF_CHANGED;

        Result |= INTDMPUB_CHANGED;

    }

    CPSUIINT(("InternalDMPUB_QUALITY(), Result=%04lx", Result));

    return(Result);

}


UINT
InternalDMPUB_COLOR(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItemColor
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    18-Sep-1995 Mon 16:03:45 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    UINT    Result = 0;


    if (pTVWnd->Flags & TWF_CAN_UPDATE) {

        POPTITEM    pICMItem;
        UINT        DMPubID;
        DWORD       dw;
        UINT        Idx;
        UINT        i;


        dw      = (pItemColor->Sel >= 1) ? 0 : OPTIF_DISABLED;
        i       = 2;
        DMPubID = DMPUB_ICMINTENT;

        while (i--) {

            if (pICMItem = GET_PITEMDMPUB(pTVWnd, DMPubID, Idx)) {

                if ((pICMItem->Flags & OPTIF_DISABLED) != dw) {

                    pICMItem->Flags ^= OPTIF_DISABLED;
                    pICMItem->Flags |= OPTIF_CHANGED;
                    Result          |= INTDMPUB_CHANGED;
                }
            }

            DMPubID = DMPUB_ICMMETHOD;
        }
    }

    CPSUIINT(("InternalDMPUB_COLOR(), Result=%04lx", Result));

    return(Result);
}




UINT
InternalDMPUB_ORIENTATION(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    07-Nov-1995 Tue 12:49:59 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    POPTITEM    pOIDuplex;
    UINT        Idx;
    UINT        Result = 0;
    DWORD       DuplexIcon[] = { IDI_CPSUI_DUPLEX_NONE,
                                 IDI_CPSUI_DUPLEX_HORZ,
                                 IDI_CPSUI_DUPLEX_VERT,
                                 IDI_CPSUI_DUPLEX_NONE_L,
                                 IDI_CPSUI_DUPLEX_HORZ_L,
                                 IDI_CPSUI_DUPLEX_VERT_L };

    if ((pTVWnd->Flags & TWF_CAN_UPDATE) &&
        (pOIDuplex = GET_PITEMDMPUB(pTVWnd, DMPUB_DUPLEX, Idx))) {

        LPDWORD     pdwID1;
        LPDWORD     pdwID2;
        POPTPARAM   pOPDuplex;
        UINT        Count;


        if ((pItem->pOptType->pOptParam + pItem->Sel)->IconID ==
                                                        IDI_CPSUI_PORTRAIT) {
            //
            // Portrait;
            //

            pdwID1 = &DuplexIcon[3];
            pdwID2 = DuplexIcon;

        } else {

            //
            // Landscape;
            //

            pdwID1 = DuplexIcon;
            pdwID2 = &DuplexIcon[3];
        }

        pOPDuplex = pOIDuplex->pOptType->pOptParam;
        Count     = pOIDuplex->pOptType->Count;

        while (Count--) {

            DWORD    IconIDOld;
            DWORD    IconIDCur;

            IconIDOld =
            IconIDCur = (DWORD)pOPDuplex->IconID;

            if (IconIDOld == pdwID1[0]) {

                IconIDCur = pdwID2[0];

            } else if (IconIDOld == pdwID1[1]) {

                IconIDCur = pdwID2[1];

            } else if (IconIDOld == pdwID1[2]) {

                IconIDCur = pdwID2[2];
            }

            if (IconIDCur != IconIDOld) {

                pOPDuplex->IconID  = IconIDCur;
                Result            |= INTDMPUB_REINIT;
            }

            pOPDuplex++;
        }

        if (Result) {

            pOIDuplex->Flags |= OPTIF_CHANGED;
        }
    }

    CPSUIINT(("InternalDMPUB_ORIENTATION(), Result=%04lx", Result));

    return(Result);
}




UINT
UpdateInternalDMPUB(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    18-Sep-1995 Mon 15:52:09 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hParent;


    hParent = (pTVWnd->Flags & TWF_IN_TVPAGE) ? pTVWnd->hWndTV : hDlg;

    switch (pItem->DMPubID) {

    case DMPUB_COPIES_COLLATE:

        return(InternalDMPUB_COPIES_COLLATE(hParent, pTVWnd, pItem));

    case DMPUB_COLOR:

        return(InternalDMPUB_COLOR(hParent, pTVWnd, pItem));

    case DMPUB_ORIENTATION:

        return(InternalDMPUB_ORIENTATION(hParent, pTVWnd, pItem));

    case DMPUB_QUALITY:

        return (InternalDMPUB_QUALITY(hParent, pTVWnd, pItem));

    default:

        return(0);
    }
}




LONG
UpdateCallBackChanges(
    HWND    hDlg,
    PTVWND  pTVWnd,
    BOOL    ReInit
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    23-Aug-1995 Wed 19:05:53 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PMYDLGPAGE  pMyDP;
    PMYDLGPAGE  pCurMyDP;
    POPTITEM    pItem;
    WORD        MyDPFlags;
    UINT        cItem;
    UINT        DlgPageIdx;
    UINT        TVPageIdx;
    INT         cUpdated = 0;


    pCurMyDP  = GET_PMYDLGPAGE(hDlg);
    pMyDP     = pTVWnd->pMyDlgPage;
    TVPageIdx = (UINT)pTVWnd->TVPageIdx;
    pItem     = pTVWnd->ComPropSheetUI.pOptItem;
    cItem     = (UINT)pTVWnd->ComPropSheetUI.cOptItem;

    while (cItem--) {

        BYTE    DMPubID;


        if (((DMPubID = pItem->DMPubID) >= DMPUB_FIRST) &&
            (DMPubID <= DMPUB_LAST)) {

            if (UpdateInternalDMPUB(hDlg, pTVWnd, pItem) & INTDMPUB_REINIT) {

                ReInit = TRUE;
            }
        }

        pItem++;
    }

    pItem     = pTVWnd->ComPropSheetUI.pOptItem;
    cItem     = (UINT)pTVWnd->ComPropSheetUI.cOptItem;
    MyDPFlags = MYDPF_CHANGED | MYDPF_CHANGEONCE | ((ReInit) ? MYDPF_REINIT :
                                                               0);

    while (cItem--) {

        if (pItem->Flags & OPTIF_CHANGED) {
#if 0
        if ((pItem->Flags & (OPTIF_CHANGED | OPTIF_INT_HIDE)) ==
                                                        OPTIF_CHANGED) {
#endif

            DlgPageIdx               = (UINT)pItem->DlgPageIdx;
            pMyDP[DlgPageIdx].Flags |= MyDPFlags;

            //
            // turn off the CHANGEONCE flags if it change back
            //

            IsItemChangeOnce(pTVWnd, pItem);

            pItem->Flags |= OPTIF_INT_TV_CHANGED;

            if (DlgPageIdx != TVPageIdx) {

                pItem->Flags |= OPTIF_INT_CHANGED;
            }

            pItem->Flags &= ~OPTIF_CHANGED;

            ++cUpdated;
        }

        pItem++;
    }

    if ((cUpdated) && (TVPageIdx != PAGEIDX_NONE)) {

        pMyDP[TVPageIdx].Flags |= MyDPFlags;
    }

    //
    // Now if this page is need to change, then change it now
    //

    if (pCurMyDP->Flags & MYDPF_CHANGED) {

        if (pCurMyDP->PageIdx == TVPageIdx) {

            UpdateTreeView(hDlg, pCurMyDP);

        } else {

            UpdatePropPage(hDlg, pCurMyDP);
        }
    }

    CPSUIDBG(DBG_UCBC, ("CallBack cUpdated=%ld", (DWORD)cUpdated));

    SET_APPLY_BUTTON(pTVWnd, hDlg);

    return((LONG)cUpdated);
}



LRESULT
CALLBACK
AboutPosDlgProc(
    HWND    hDlg,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PABOUTPOS   pAP;
    RECT        rc;


    switch(Msg) {

    case WM_INITDIALOG:

        SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);

        pAP = (PABOUTPOS)lParam;

        GetWindowRect(hDlg, &rc);

        rc.left = (LONG)LOWORD(pAP->Pos) - ((rc.right - rc.left) / 2);
        rc.top  = (LONG)HIWORD(pAP->Pos) - ((rc.bottom - rc.top) / 2);

        SetWindowPos(hDlg,
                     NULL,
                     rc.left,
                     rc.top,
                     0, 0,
                     SWP_NOSIZE | SWP_NOZORDER);

        pAP->pCBParam->hDlg = hDlg;
        pAP->pfnCallBack(pAP->pCBParam);

        EndDialog(hDlg, 0);
        return(TRUE);
    }

    return(FALSE);
}




LONG
DoCallBack(
    HWND                hDlg,
    PTVWND              pTVWnd,
    POPTITEM            pItem,
    LPVOID              pOldSel,
    _CPSUICALLBACK      pfnCallBack,
    HANDLE              hDlgTemplate,
    WORD                DlgTemplateID,
    WORD                Reason
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Aug-1995 Fri 21:09:08 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PMYDLGPAGE  pCurMyDP;
    PPSPINFO    pPSPInfo;
    LONG        Ret = CPSUICB_ACTION_NONE;
    ULONG_PTR   Result;
    BOOL        DoSetResult = FALSE;


    if (!(pCurMyDP = GET_PMYDLGPAGE(hDlg))) {

        CPSUIERR(("hDlg=%08lx, pCurMyDP=NULL", hDlg));

        return(CPSUICB_ACTION_NONE);
    }

    if (!(pPSPInfo = pCurMyDP->pPSPInfo)) {

        CPSUIERR(("hDlg=%08lx, pCurMyDP->pPSPInfo=NULL", hDlg));

        return(CPSUICB_ACTION_NONE);
    }

    if ((!hDlgTemplate) && (!DlgTemplateID)) {

        if (!pfnCallBack) {

            pfnCallBack = pTVWnd->ComPropSheetUI.pfnCallBack;
        }
    }

    if (pfnCallBack) {

        HWND            hFocus;
        POPTTYPE        pOptType;
        CPSUICBPARAM    CBParam;
        BOOL            SetNewDef;


        if (Reason == CPSUICB_REASON_APPLYNOW) {

            SetNewDef = (pItem) ? TRUE : FALSE;
            pItem     = pTVWnd->ComPropSheetUI.pOptItem;
        }

        CPSUIOPTITEM(DBGITEM_CB, pTVWnd, "CallBack Item", 2, pItem);
        CPSUIDBG(DBG_DOCB, ("pfnCallBack=%08lx, CALLBACK READSON=%ld",
                                    pfnCallBack, Reason));

        if (Reason == CPSUICB_REASON_ABOUT) {

            DlgTemplateID = DLGABOUT;
        }

        if (!(hFocus = GetFocus())) {

            hFocus = hDlg;
        }

        pOptType         = GET_POPTTYPE(pItem);
        CBParam.cbSize   = sizeof(CPSUICBPARAM);
        CBParam.Reason   = Reason;
        CBParam.hDlg     = hDlg;
        CBParam.pOptItem = pTVWnd->ComPropSheetUI.pOptItem;
        CBParam.cOptItem = pTVWnd->ComPropSheetUI.cOptItem;
        CBParam.Flags    = pTVWnd->ComPropSheetUI.Flags;
        CBParam.pCurItem = pItem;
        CBParam.pOldSel  = pOldSel;
        CBParam.UserData = pTVWnd->ComPropSheetUI.UserData;
        CBParam.Result   = CPSUI_OK;

        if ((hDlgTemplate)  ||
            (DlgTemplateID)) {

            if (hDlgTemplate) {

                try {

                    DialogBoxIndirectParam(_OI_HINST(pItem),
                                           (LPDLGTEMPLATE)hDlgTemplate,
                                           hDlg,
                                           (DLGPROC)pfnCallBack,
                                           (LPARAM)&CBParam);

                } except (FilterException(pPSPInfo->hComPropSheet,
                                          GetExceptionInformation())) {

                    CPSUIERR(("DialogBoxIndirectParam(%08lx), Exception", pfnCallBack));
                }

            } else {

                if (Reason == CPSUICB_REASON_ABOUT) {

                    ABOUTPOS    AP;

                    AP.pfnCallBack = pfnCallBack;
                    AP.pCBParam    = &CBParam;
                    AP.hFocus      = hFocus;
                    AP.Pos         = pTVWnd->MousePos;

                    CPSUIINT(("AboutPosDlg: Pos=(%ld, %ld), hDlg=%08lx (%ld), hFocus=%08lx (%ld)",
                                (LONG)LOWORD(pTVWnd->MousePos),
                                (LONG)HIWORD(pTVWnd->MousePos),
                                hDlg, GetWindowLongPtr(hDlg, GWLP_ID),
                                hFocus, GetWindowLongPtr(hFocus, GWLP_ID)));

                    try {

                        DialogBoxParam(hInstDLL,
                                       MAKEINTRESOURCE(DLGABOUT),
                                       hDlg,
                                       (DLGPROC)AboutPosDlgProc,
                                       (LPARAM)&AP);

                    } except (FilterException(pPSPInfo->hComPropSheet,
                                              GetExceptionInformation())) {

                        CPSUIERR(("DialogBoxParam(ABOUTPOS: %08lx), Exception", pfnCallBack));
                    }

                } else {

                    try {

                        DialogBoxParam(_OI_HINST(pItem),
                                       (LPCTSTR)MAKEINTRESOURCE(DlgTemplateID),
                                       hDlg,
                                       (DLGPROC)pfnCallBack,
                                       (LPARAM)&CBParam);

                    } except (FilterException(pPSPInfo->hComPropSheet,
                                              GetExceptionInformation())) {

                        CPSUIERR(("DialogBoxParam(%08lx), Exception", pfnCallBack));
                    }
                }
            }

        } else {

            HCURSOR hCursor;

            if (Reason == CPSUICB_REASON_APPLYNOW) {

                hCursor = SetCursor(LoadCursor(NULL,
                                               (LPCTSTR)(ULONG_PTR)IDC_WAIT));
            }

            try {

                Ret = pfnCallBack(&CBParam);

            } except (FilterException(pPSPInfo->hComPropSheet,
                                      GetExceptionInformation())) {

                CPSUIERR(("pfnCallBack 1=%08lx, Exception", pfnCallBack));
                Ret = CPSUICB_ACTION_NONE;
            }

            if (Reason == CPSUICB_REASON_APPLYNOW) {

                SetCursor(hCursor);

                if (Ret != CPSUICB_ACTION_NO_APPLY_EXIT) {

                    DoSetResult = TRUE;
                    Result      = CBParam.Result;

                    //
                    // Save the new setting to as current default and also call
                    // common UI to set the result to the original caller
                    //

                    if (SetNewDef) {

                        CPSUIDBG(DBG_DOCB,
                                 ("*APPLYNOW=%ld, SET NEW DEFAULT", Ret));

                        SetOptItemNewDef(hDlg, pTVWnd, FALSE);
                    }
                }
            }
        }

        if ((pTVWnd->Flags & TWF_CAN_UPDATE) &&
            ((Ret == CPSUICB_ACTION_OPTIF_CHANGED)  ||
             (Ret == CPSUICB_ACTION_REINIT_ITEMS))) {

            CPSUIDBG(DBG_DOCB, ("CallBack()=OPTIF_CHANGED=%ld", Ret));

            if (((IS_HDR_PUSH(pOptType))    ||
                 (Reason == CPSUICB_REASON_ITEMS_REVERTED)) &&
                (pfnCallBack = pTVWnd->ComPropSheetUI.pfnCallBack)) {

                CPSUIINT(("CPSUICB_REASON_ITEMS_REVERTED CallBack"));

                CBParam.cbSize   = sizeof(CPSUICBPARAM);
                CBParam.Reason   = CPSUICB_REASON_ITEMS_REVERTED;
                CBParam.hDlg     = hDlg;
                CBParam.pOptItem = pTVWnd->ComPropSheetUI.pOptItem;
                CBParam.cOptItem = pTVWnd->ComPropSheetUI.cOptItem;
                CBParam.Flags    = pTVWnd->ComPropSheetUI.Flags;
                CBParam.pCurItem = CBParam.pOptItem;
                CBParam.OldSel   = pTVWnd->ComPropSheetUI.cOptItem;
                CBParam.UserData = pTVWnd->ComPropSheetUI.UserData;
                CBParam.Result   = CPSUI_OK;

                //
                // This is the header push callback, so let the caller know
                //

                try {

                    pfnCallBack(&CBParam);

                } except (FilterException(pPSPInfo->hComPropSheet,
                                          GetExceptionInformation())) {

                    CPSUIERR(("pfnCallBack 2=%08lx, Exception", pfnCallBack));
                    Ret = CPSUICB_ACTION_NONE;
                }

                Ret = CPSUICB_ACTION_REINIT_ITEMS;
            }

            UpdateCallBackChanges(hDlg,
                                  pTVWnd,
                                  Ret == CPSUICB_ACTION_REINIT_ITEMS);
        }

    } else if (Reason == CPSUICB_REASON_APPLYNOW) {

        //
        // If the caller does not hook this, then we will call to set it
        // to its owner's parent ourself
        //

        DoSetResult = TRUE;
        Result      = CPSUI_OK;
    }

    //
    // Now propage the result to the owner
    //

    if (DoSetResult) {

        pPSPInfo->pfnComPropSheet(pPSPInfo->hComPropSheet,
                                  CPSFUNC_SET_RESULT,
                                  (LPARAM)pPSPInfo->hCPSUIPage,
                                  Result);
    }

    return(Ret);
}



LRESULT
CALLBACK
AboutDlgProc(
    HWND    hDlg,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    ABOUTINFO           AI;
    PTVWND              pTVWnd;
    HICON               hIcon;
    LPVOID              pvAlloc = NULL;
    LPWSTR              pwsz;
    VS_FIXEDFILEINFO    *pvsf;
    WCHAR               wBuf[MAX_RES_STR_CHARS * 2];
    DWORD               dw;
    WORD                Version;
    UINT                cChar;



    switch(Msg) {

    case WM_INITDIALOG:

        AI     =  *(PABOUTINFO)lParam;
        pTVWnd = AI.pTVWnd;
        hIcon  = AI.hIcon;

        GetModuleFileName(pTVWnd->hInstCaller, wBuf, COUNT_ARRAY(wBuf));

        if ((dw = GetFileVersionInfoSize(wBuf, &dw))   &&
            (pvAlloc = (LPVOID)LocalAlloc(LPTR, dw))) {

            GetFileVersionInfo(wBuf, 0, dw, pvAlloc);
        }

        //
        // Compose Caller Name / Version
        //

        cChar         = GetWindowText(hDlg, wBuf, COUNT_ARRAY(wBuf));
        wBuf[cChar++] = L' ';

        cChar += GetStringBuffer(pTVWnd->hInstCaller,
                                 (WORD)(GBF_PREFIX_OK        |
                                        GBF_INT_NO_PREFIX    |
                                        ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                            GBF_ANSI_CALL : 0)),
                                 L'\0',
                                 pTVWnd->ComPropSheetUI.pCallerName,
                                 &wBuf[cChar],
                                 COUNT_ARRAY(wBuf) - cChar - 1);

        SetWindowText(hDlg, wBuf);

        Version = pTVWnd->ComPropSheetUI.CallerVersion;

        cChar = ComposeStrData(pTVWnd->hInstCaller,
                               (WORD)(GBF_PREFIX_OK        |
                                      GBF_INT_NO_PREFIX    |
                                      ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                        GBF_ANSI_CALL : 0)),
                               wBuf,
                               COUNT_ARRAY(wBuf),
                               (Version) ? IDS_INT_CPSUI_VERSION : 0,
                               pTVWnd->ComPropSheetUI.pCallerName,
                               HIBYTE(Version),
                               LOBYTE(Version));

        SetDlgItemText(hDlg, IDS_ABOUT_CALLER, wBuf);

        GetModuleFileName(pTVWnd->hInstCaller, wBuf, COUNT_ARRAY(wBuf));

        if (pvAlloc) {

            VerQueryValue(pvAlloc, L"\\", &pvsf, &dw);

            pwsz = NULL;
            VerQueryValue(pvAlloc,
                          L"\\StringFileInfo\\040904B0\\ProductName",
                          &pwsz,
                          &dw);

            if (pwsz) {
                SetDlgItemText(hDlg, IDS_ABOUT_PRODUCT, pwsz);
            }

            cChar = GetDlgItemText(hDlg,
                                   IDS_ABOUT_CALLER,
                                   wBuf,
                                   COUNT_ARRAY(wBuf));

            wsprintf(&wBuf[cChar], L"  (%u.%u:%u.%u)",
                    HIWORD(pvsf->dwProductVersionMS),
                    LOWORD(pvsf->dwProductVersionMS),
                    HIWORD(pvsf->dwProductVersionLS),
                    LOWORD(pvsf->dwProductVersionLS));

            SetDlgItemText(hDlg, IDS_ABOUT_CALLER, wBuf);

            pwsz = NULL;
            VerQueryValue(pvAlloc,
                          L"\\StringFileInfo\\040904B0\\LegalCopyright",
                          &pwsz,
                          &dw);
            if (pwsz) {
                SetDlgItemText(hDlg, IDS_ABOUT_COPYRIGHT, pwsz);
            }
        }

        //
        // OPTITEM NAME VERSION
        //

        Version  = pTVWnd->ComPropSheetUI.OptItemVersion;

        ComposeStrData(pTVWnd->hInstCaller,
                       (WORD)(GBF_PREFIX_OK        |
                              GBF_INT_NO_PREFIX    |
                              ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                   GBF_ANSI_CALL : 0)),
                       wBuf,
                       COUNT_ARRAY(wBuf),
                       (Version) ? IDS_INT_CPSUI_VERSION : 0,
                       pTVWnd->ComPropSheetUI.pOptItemName,
                       HIBYTE(Version),
                       LOBYTE(Version));

        SetDlgItemText(hDlg, IDS_ABOUT_OPTITEM, wBuf);

        SendMessage(GetDlgItem(hDlg, IDI_ABOUT_ICON),
                    STM_SETIMAGE,
                    (WPARAM)IMAGE_ICON,
                    (LPARAM)hIcon);

        if (pvAlloc) {

            LocalFree(pvAlloc);
        }

        if (AI.Pos) {

            RECT    rc;

            GetWindowRect(hDlg, &rc);

            rc.left = (LONG)LOWORD(AI.Pos) - ((rc.right - rc.left) / 2);
            rc.top  = (LONG)HIWORD(AI.Pos) - ((rc.bottom - rc.top) / 2);

            SetWindowPos(hDlg,
                         NULL,
                         rc.left,
                         rc.top,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER);
        }

        return(TRUE);

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:
        case IDCANCEL:

            EndDialog(hDlg, 0);
            return(TRUE);

        }

        break;

    }

    return(FALSE);
}




BOOL
DoAbout(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItemRoot
    )

/*++

Routine Description:

    This function pop up the about dialog box


Arguments:




Return Value:




Author:

    09-Oct-1995 Mon 13:10:41 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HICON       hIcon;
    HICON       hIconLoad = NULL;
    ABOUTINFO   AI;
    ULONG_PTR   IconID;
    BOOL        bRet;



    if (pTVWnd->ComPropSheetUI.Flags & CPSUIF_ABOUT_CALLBACK) {

        DoCallBack(hDlg,
                   pTVWnd,
                   pTVWnd->ComPropSheetUI.pOptItem,
                   (LPVOID)pTVWnd->pCPSUI,
                   NULL,
                   NULL,
                   0,
                   CPSUICB_REASON_ABOUT);

        return(TRUE);
    }

    IconID = GETSELICONID(pItemRoot);

    if (VALID_PTR(IconID)) {

        hIcon = GET_HICON(IconID);

    } else {

        hIconLoad =
        hIcon     = GETICON(_OI_HINST(pItemRoot), LODWORD(IconID));
    }

    AI.pTVWnd = pTVWnd;
    AI.hIcon  = hIcon;
    AI.Pos    = pTVWnd->MousePos;

    bRet = DialogBoxParam(hInstDLL,
                          MAKEINTRESOURCE(DLGABOUT),
                          hDlg,
                          (DLGPROC)AboutDlgProc,
                          (LPARAM)&AI) ? TRUE : FALSE;

    if (hIconLoad) {

        DestroyIcon(hIconLoad);
    }

    return(bRet);
}





LONG
DoPushButton(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Aug-1995 Fri 20:57:42 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    ULONG_PTR       ulCookie = 0;
    PMYDLGPAGE      pCurMyDP;
    PPSPINFO        pPSPInfo;
    HINSTANCE       hInst = NULL;
    FARPROC         farproc;
    POPTTYPE        pOptType;
    POPTPARAM       pOptParam;
    DEVHTADJDATA    DevHTAdjData;
    LONG            Ret;
    UINT            Idx;
    BOOL            IsColor;
    GSBUF_DEF(pItem, MAX_RES_STR_CHARS);


    if (!(pCurMyDP = GET_PMYDLGPAGE(hDlg))) {

        CPSUIERR(("hDlg=%08lx, pCurMyDP=NULL", hDlg));

        return(0);
    }

    if (!(pPSPInfo = pCurMyDP->pPSPInfo)) {

        CPSUIERR(("hDlg=%08lx, pCurMyDP->pPSPInfo=NULL", hDlg));

        return(0);
    }

    pOptType  = GET_POPTTYPE(pItem);
    pOptParam = pOptType->pOptParam;
    Ret       = pItem->Sel;

    switch(pOptParam[0].Style) {

    case PUSHBUTTON_TYPE_DLGPROC:

        if (pOptParam[0].pData) {

            Ret = DoCallBack(hDlg,
                             pTVWnd,
                             pItem,
                             pItem->pSel,
                             (_CPSUICALLBACK)pOptParam[0].pData,
                             (pOptParam[0].Flags & OPTPF_USE_HDLGTEMPLATE) ?
                                        (HANDLE)pOptParam[0].lParam : NULL,
                             (WORD)pOptParam[0].lParam,
                             CPSUICB_REASON_DLGPROC);
        }

        break;

    case PUSHBUTTON_TYPE_CALLBACK:

        DoCallBack(hDlg,
                   pTVWnd,
                   pItem,
                   pItem->pSel,
                   (_CPSUICALLBACK)pOptParam[0].pData,
                   NULL,
                   0,
                   CPSUICB_REASON_PUSHBUTTON);

        break;

    case PUSHBUTTON_TYPE_HTCLRADJ:

        //
        // HTUI.DLL is part of the OS, so we need to make sure 
        // it always gets loaded into V6 context.
        //
        ulCookie = 0;
        if (SHActivateContext(&ulCookie)) {

            __try {

                IsColor = (BOOL)((pItem = GET_PITEMDMPUB(pTVWnd, DMPUB_COLOR, Idx)) &&
                                 (pItem->Sel >= 1));

                CPSUIDBG(DBG_DOPB, ("ColorAdj: IsColor=%ld, Update=%ld",
                            (DWORD)IsColor, (DWORD)pTVWnd->Flags & TWF_CAN_UPDATE));

                GSBUF_RESET;
                GSBUF_FLAGS |= GBF_PREFIX_OK;
                GSBUF_GETSTR(pTVWnd->ComPropSheetUI.pOptItemName);

                if ((hInst = LoadLibrary(TEXT("htui"))) &&
                    (farproc = GetProcAddress(hInst, (LPCSTR)szHTUIClrAdj))) {

                    try {

                        Ret = (LONG)(*farproc)((LPWSTR)GSBUF_BUF,
                                               NULL,
                                               NULL,
                                               (PCOLORADJUSTMENT)pOptParam[0].pData,
                                               !IsColor,
                                               pTVWnd->Flags & TWF_CAN_UPDATE);

                    } except (FilterException(pPSPInfo->hComPropSheet,
                                              GetExceptionInformation())) {

                        CPSUIERR(("Halftone Proc=%hs, Exception", szHTUIClrAdj));
                        Ret = 0;
                    }
                }
            }
            __finally {

                //
                // we need to deactivate the context, no matter what!
                //
                SHDeactivateContext(ulCookie);
            }
        }

        break;

    case PUSHBUTTON_TYPE_HTSETUP:

        //
        // HTUI.DLL is part of the OS, so we need to make sure 
        // it always gets loaded into V6 context.
        //
        ulCookie = 0;
        if (SHActivateContext(&ulCookie)) {

            __try {

                DevHTAdjData = *(PDEVHTADJDATA)(pOptParam[0].pData);

                if (!(pTVWnd->Flags & TWF_CAN_UPDATE)) {

                    DevHTAdjData.pDefHTInfo = DevHTAdjData.pAdjHTInfo;
                }

                GSBUF_RESET;
                GSBUF_FLAGS |= GBF_PREFIX_OK;
                GSBUF_GETSTR(pTVWnd->ComPropSheetUI.pOptItemName);

                if ((hInst = LoadLibrary(TEXT("htui"))) &&
                    (farproc = GetProcAddress(hInst, (LPCSTR)szHTUIDevClrAdj))) {

                    try {

                        Ret = (LONG)(*farproc)((LPWSTR)GSBUF_BUF, &DevHTAdjData);

                    } except (FilterException(pPSPInfo->hComPropSheet,
                                              GetExceptionInformation())) {

                        CPSUIERR(("Halftone Proc=%hs, Exception", szHTUIDevClrAdj));

                        Ret = 0;
                    }
                }
            }
            __finally {

                //
                // we need to deactivate the context, no matter what!
                //
                SHDeactivateContext(ulCookie);
            }
        }

        break;
    }

    if (hInst) {

        FreeLibrary(hInst);
    }

    CPSUIOPTITEM(DBGITEM_PUSH, pTVWnd, "PUSHBUTTON:", 0, pItem);

    return(Ret);
}






POPTITEM
pItemFromhWnd(
    HWND    hDlg,
    PTVWND  pTVWnd,
    HWND    hCtrl,
    LONG    MousePos
    )

/*++

Routine Description:

    This function take a hWnd and return a pItem associate with it



Arguments:

    hDlg        - Handle to the dialog box page

    pTVWnd      - Our instance handle

    hCtrl       - the handle to the focus window

    MousePos    - MAKELONG(x, y) of current mouse position


Return Value:

    POPTITEM, null if failed


Author:

    26-Sep-1995 Tue 12:24:36 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    DWORD   dw;


    if ((!hCtrl) || (hCtrl == hDlg)) {

        POINT   pt;

        pt.x = LOWORD(MousePos);
        pt.y = HIWORD(MousePos);

        ScreenToClient(hDlg, (LPPOINT)&pt);

        if ((MousePos == -1)                                                   ||
            (!(hCtrl = ChildWindowFromPointEx(hDlg, pt, CWP_SKIPINVISIBLE)))   ||
            (hCtrl == hDlg)) {

            CPSUIDBG(DBG_IFW, ("hDlg=%08lx, No hWnd From  from Mouse Pos=(%ld, %ld)",
                                    hDlg, pt.x, pt.y));

            return(NULL);
        }
    }

    CPSUIDBG(DBG_IFW, ("!! Find The hCtrl=%08lx", hCtrl));

    if (dw = (DWORD)GetWindowLongPtr(hCtrl, GWLP_USERDATA)) {

        WORD    ItemIdx;


        if (pTVWnd->Flags & TWF_IN_TVPAGE) {

            return(pTVWnd->pCurTVItem);
        }

        ItemIdx = (WORD)GETCTRLITEMIDX(dw);

        CPSUIDBG(DBG_IFW, ("ID=%ld, Idx=%ld, dw=%08lx",
                (DWORD)GetDlgCtrlID(hCtrl), (DWORD)ItemIdx, dw));

        //
        // Validate what we got
        //

        if (ItemIdx >= INTIDX_FIRST) {

            return(PIDX_INTOPTITEM(pTVWnd, ItemIdx));

        } else if (ItemIdx < pTVWnd->ComPropSheetUI.cOptItem) {

            return(pTVWnd->ComPropSheetUI.pOptItem + ItemIdx);
        }

    } else {

        CPSUIINT(("pItemFromhWnd: hCtrl=%08lx, GWLP_USERDATA=%08lx", hCtrl, dw));
    }

    CPSUIINT(("pItemFromhWnd: NONE"));

    return(NULL);
}




VOID
DoContextMenu(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    LPARAM      Pos
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    17-Feb-1998 Tue 17:59:20 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HMENU   hMenu;
    UINT    cMenu = 0;
    UINT    cChar;
    WCHAR   wBuf[MAX_RES_STR_CHARS + 40];

    if (hMenu = CreatePopupMenu()) {

        pTVWnd->pMouseItem = pItem;
        pTVWnd->MousePos   = Pos;

        CPSUIINT(("Create PopUpMenu=%08lx, pItem=%08lx, hFocus=%08lx (%ld)",
                hMenu, pItem, GetFocus(), GetWindowLongPtr(GetFocus(), GWLP_ID)));

        if ((pItem) &&
            (cChar = CountRevertOptItem(pTVWnd, pItem, _OI_HITEM(pItem), 0))) {

            if (cMenu++) {

                AppendMenu(hMenu,
                           MF_SEPARATOR,
                           0,
                           NULL);
            }

            ComposeStrData(pTVWnd->hInstCaller,
                           (WORD)(GBF_PREFIX_OK        |
                                  ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                    GBF_ANSI_CALL : 0)),
                           wBuf,
                           COUNT_ARRAY(wBuf),
                           (UINT)(cChar > 1) ? IDS_INT_CPSUI_UNDO_OPTS :
                                               IDS_INT_CPSUI_UNDO_OPT,
                           pItem->pName,
                           cChar,
                           0);

            AppendMenu(hMenu,
                       MF_ENABLED | MF_STRING,
                       ID_CMD_UNDO,
                       wBuf);
        }

        if (pItem) {

            if (cMenu++) {

                AppendMenu(hMenu,
                           MF_SEPARATOR,
                           0,
                           NULL);
            }

            GetStringBuffer(pTVWnd->hInstCaller,
                            (WORD)(GBF_PREFIX_OK        |
                                   GBF_IDS_INT_CPSUI    |
                                   ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                       GBF_ANSI_CALL : 0)),
                            L'\0',
                            (LPTSTR)IDS_INT_CPSUI_WHATISTHIS,
                            wBuf,
                            COUNT_ARRAY(wBuf) - 1);

            AppendMenu(hMenu,
                       MF_ENABLED | MF_STRING,
                       ID_CMD_HELP,
                       wBuf);
        }

        if (cMenu++) {

            AppendMenu(hMenu,
                       MF_SEPARATOR,
                       0,
                       NULL);
        }

        cChar = ComposeStrData(pTVWnd->hInstCaller,
                               (WORD)(GBF_PREFIX_OK        |
                                      ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                        GBF_ANSI_CALL : 0)),
                               wBuf,
                               COUNT_ARRAY(wBuf),
                               (UINT)IDS_INT_CPSUI_ABOUT,
                               pTVWnd->ComPropSheetUI.pCallerName,
                               0,
                               0);

        GetStringBuffer(pTVWnd->hInstCaller,
                        (WORD)(GBF_PREFIX_OK        |
                               ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                   GBF_ANSI_CALL : 0)),
                        L'\0',
                        (LPTSTR)IDS_CPSUI_MORE,
                        &wBuf[cChar],
                        COUNT_ARRAY(wBuf) - cChar - 1);

        AppendMenu(hMenu,
                   MF_ENABLED | MF_STRING,
                   ID_CMD_ABOUT,
                   wBuf);

        if (!pItem) {

            pTVWnd->pMouseItem = PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT);
        }

        TrackPopupMenu(hMenu,
                       TPM_LEFTALIGN | TPM_LEFTBUTTON,
                       LOWORD(Pos),
                       HIWORD(Pos),
                       0,
                       hDlg,
                       NULL);

        CPSUIINT(("DESTROY PopUpMenu=%08lx, cMenu=%08lx", hMenu, cMenu));

        DestroyMenu(hMenu);
    }
}




LONG
FindNextLBCBSel(
    HWND        hLBCB,
    LONG        SelLast,
    LONG        SelNow,
    UINT        IDGetItemData,
    LPDWORD     pItemData
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    10-Sep-1995 Sun 23:58:44 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LONG    Count;
    LONG    SelAdd;
    DWORD   ItemData;


    Count  = (LONG)SendMessage(hLBCB,
                               (IDGetItemData == LB_GETITEMDATA) ?
                                               LB_GETCOUNT : CB_GETCOUNT,
                               0,
                               0L);
    SelAdd = (SelNow >= SelLast) ? 1 : -1;

    while (((SelNow += SelAdd) >= 0) && (SelNow < Count)) {

        ItemData = (DWORD)SendMessage(hLBCB, IDGetItemData, SelNow, 0L);

        if (!(ItemData & LBCBID_DISABLED)) {

            *pItemData = ItemData;
            return(SelNow);
        }
    }

    //
    // We could not find the one which is enabled, so go back to the old one
    //

    *pItemData = (DWORD)SendMessage(hLBCB, IDGetItemData, SelLast, 0L);
    return(SelLast);
}




BOOL
DrawLBCBItem(
    PTVWND              pTVWnd,
    LPDRAWITEMSTRUCT    pdis
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Sep-1995 Mon 18:44:05 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HDC         hDC;
    PLAYOUTBMP  pData;
    POPTITEM    pItem;
    POPTTYPE    pOptType;
    WORD        OPIdx;
    INT         y;
    UINT        ItemState;
    BYTE        CtrlStyle;
    BYTE        CtrlData;
    WORD        ItemIdx;
    WORD        Count;
    WORD        OTFlags;
    DWORD       dw;
    ULONG_PTR   ItemData;
    RECT        rc;
    POINT       TextOff;
    DWORD       OldBkMode;
    COLORREF    OldClr;
    COLORREF    OldBkClr;
    INT         FillIdx;
    INT         TextIdx;
    HBRUSH      hbr;
    BOOL        IsLB = TRUE;
    TEXTMETRIC  tm;
    LRESULT     uLen;
    LPTSTR      pszItem = NULL;

    if (pdis->itemID == -1) {

        return(FALSE);
    }

    switch (pdis->CtlType) {

    case ODT_COMBOBOX:

        IsLB = FALSE;

    case ODT_LISTBOX:

        break;

    case ODT_BUTTON:

        if ((pdis->CtlID == IDD_LAYOUT_PICTURE)     &&
            (pdis->itemAction & (ODA_DRAWENTIRE ))  &&
            (pData = (PLAYOUTBMP)GetProp(pdis->hwndItem,
                                         CPSUIPROP_LAYOUTPUSH))) {

            UpdateLayoutBmp(pdis->hDC, pData);

        }

        return TRUE;

    default:

        return(FALSE);
    }

    if (!(dw = (DWORD)GetWindowLongPtr(pdis->hwndItem, GWLP_USERDATA))) {

        CPSUIDBG(DBG_CS, ("DrawLBCBItem: dw=0, hCtrl=%08lx, CtlID=%08lx",
                                            pdis->hwndItem, pdis->CtlID));
        return(FALSE);
    }

    GETCTRLDATA(dw, ItemIdx, CtrlStyle, CtrlData);


    if ((!(pItem = GetOptions(pTVWnd, MAKELPARAM(ItemIdx, 0)))) ||
        (!(pOptType = GET_POPTTYPE(pItem)))                     ||
        (pItem->Flags & OPTIF_ITEM_HIDE)) {

        CPSUIERR(("DrawLBCB: Invalid Ctrl or ItemIdx=%ld", ItemIdx));
        return(FALSE);
    }

#if (DO_IN_PLACE == 0)
    CPSUIASSERT(0, "DrawLBCB: The type is not LB or CB but [%u]",
                    (pOptType->Type == TVOT_LISTBOX) ||
                    (pOptType->Type == TVOT_COMBOBOX), (UINT)pOptType->Type);
#endif

    OTFlags  = _OT_FLAGS(pOptType);
    hDC      = pdis->hDC;
    rc       = pdis->rcItem;
    ItemData = pdis->itemData;

    //
    // Get the length of this item's text
    //
    uLen = (IsLB) ? LB_ERR : CB_ERR;
    uLen = SendMessage(pdis->hwndItem,
                (IsLB) ? LB_GETTEXTLEN : CB_GETLBTEXTLEN,
                (WPARAM)pdis->itemID,
                (LPARAM)0);
        
    if (uLen > 0)
    {
        //
        // Allocate a buffer for the string
        //
        pszItem = (LPTSTR)LocalAlloc( LPTR,(uLen + 1) * sizeof(TCHAR));
        if (pszItem)
        {
            //
            // Get the string
            //
            SendMessage(pdis->hwndItem,
                (IsLB) ? LB_GETTEXT : CB_GETLBTEXT,
                (WPARAM)pdis->itemID,
                (LPARAM)pszItem);
        }
    }

    switch (pdis->itemAction) {

    case ODA_SELECT:
    case ODA_DRAWENTIRE:

        GetTextMetrics(hDC, &tm);

        ItemState = pdis->itemState;

#if DO_IN_PLACE
        CPSUIINT(("hwndItem=%08lx", pdis->hwndItem));

        if ((ItemState & ODS_COMBOBOXEDIT)          &&
            (pTVWnd->Flags & TWF_IN_TVPAGE)) {

            OTFlags &= ~OTINTF_ITEM_HAS_ICON16;
        }
#endif
        TextOff.x = (OTFlags & OTINTF_ITEM_HAS_ICON16) ?
                        (LBCB_ICON_X_OFF + CXIMAGE + LBCB_ICON_TEXT_X_SEP) :
                        (LBCB_ICON_X_OFF);
        TextOff.y = (rc.bottom + rc.top - tm.tmHeight) / 2;

        //
        // Fill the selection rectangle from the location, this is only
        // happpened if we wre not disabled
        //

        if (ItemState & ODS_DISABLED) {

            if ((ItemState & ODS_SELECTED) && (IsLB)) {

                FillIdx = COLOR_3DSHADOW;
                TextIdx = COLOR_3DFACE;

            } else {

                FillIdx = COLOR_3DFACE;
                TextIdx = COLOR_GRAYTEXT;
            }

        } else {

            if (ItemState & ODS_SELECTED) {

                FillIdx  = COLOR_HIGHLIGHT;
                dw       = COLOR_HIGHLIGHTTEXT;

            } else {

                FillIdx = COLOR_WINDOW;
                dw      = COLOR_WINDOWTEXT;
            }

            if (ItemData & LBCBID_DISABLED) {

                TextIdx = COLOR_GRAYTEXT;

            } else {

                TextIdx = (INT)dw;
            }
        }

        //
        // Fill the background frist
        //

        hbr = CreateSolidBrush(GetSysColor(FillIdx));

        if (hbr) {
            FillRect(hDC, &rc, hbr);
            DeleteObject(hbr);
        }

        if (ItemData & LBCBID_FILL) {

            break;
        }

        //
        // Draw the text using transparent mode
        //

        OldClr    = SetTextColor(hDC, GetSysColor(TextIdx));
        OldBkMode = SetBkMode(hDC, TRANSPARENT);
        TextOut(hDC,
                rc.left + TextOff.x,
                TextOff.y,
                pszItem,
                lstrlen(pszItem));
        SetTextColor(hDC, OldClr);
        SetBkMode(hDC, OldBkMode);

        //
        // Setting any icon if available
        //

        if (OTFlags & OTINTF_ITEM_HAS_ICON16) {

            LPWORD      *pIcon16Idx;
            POPTPARAM   pOptParam;
            HINSTANCE   hInst;


            pOptParam = (ItemData & LBCBID_NONE) ? &pTVWnd->OptParamNone :
                                                   pOptType->pOptParam +
                                                            LOWORD(ItemData);
            hInst = _OI_HINST(pItem);

#if DO_IN_PLACE
            if (dw = GetIcon16Idx(pTVWnd,
                                  hInst,
                                  GET_ICONID(pOptParam,
                                             OPTPF_ICONID_AS_HICON),
                                  IDI_CPSUI_GENERIC_ITEM)) {

                ImageList_Draw(pTVWnd->himi,
                               dw,
                               hDC,
                               rc.left + LBCB_ICON_X_OFF,
                               rc.top,
                               ILD_TRANSPARENT);
            }
#else
            ImageList_Draw(pTVWnd->himi,
                           GetIcon16Idx(pTVWnd,
                                        hInst,
                                        GET_ICONID(pOptParam,
                                                   OPTPF_ICONID_AS_HICON),
                                        IDI_CPSUI_GENERIC_ITEM),
                           hDC,
                           rc.left + LBCB_ICON_X_OFF,
                           rc.top,
                           ILD_TRANSPARENT);
#endif

            //
            // Draw The No/Stop/Warning icon on to it
            //

            if (pOptParam->Flags & OPTPF_OVERLAY_STOP_ICON) {

                ImageList_Draw(pTVWnd->himi,
                               GetIcon16Idx(pTVWnd,
                                            hInst,
                                            0,
                                            IDI_CPSUI_STOP),
                               hDC,
                               rc.left + LBCB_ICON_X_OFF,
                               rc.top,
                               ILD_TRANSPARENT);
            }

            if (pOptParam->Flags & OPTPF_OVERLAY_NO_ICON) {

                ImageList_Draw(pTVWnd->himi,
                               GetIcon16Idx(pTVWnd,
                                            hInst,
                                            0,
                                            IDI_CPSUI_NO),
                               hDC,
                               rc.left + LBCB_ICON_X_OFF,
                               rc.top,
                               ILD_TRANSPARENT);
            }

            if (pOptParam->Flags & OPTPF_OVERLAY_WARNING_ICON) {

                ImageList_Draw(pTVWnd->himi,
                               GetIcon16Idx(pTVWnd,
                                            hInst,
                                            0,
                                            IDI_CPSUI_WARNING_OVERLAY),
                               hDC,
                               rc.left + LBCB_ICON_X_OFF,
                               rc.top,
                               ILD_TRANSPARENT);
            }
        }

        if ((ItemState & (ODS_COMBOBOXEDIT | ODS_SELECTED | ODS_FOCUS))
                            == (ODS_COMBOBOXEDIT | ODS_SELECTED | ODS_FOCUS)) {

            DrawFocusRect(hDC, &pdis->rcItem);
        }

        break;

    case ODA_FOCUS:

        if (!IsLB) {

            DrawFocusRect(hDC, &pdis->rcItem);
            break;
        }

        return(FALSE);
    }

    LocalFree(pszItem);
    return(TRUE);
}



BOOL
ValidateUDArrow(
    HWND    hDlg,
    HWND    hEdit,
    BYTE    CtrlData,
    LONG    *pSel,
    LONG    Min,
    LONG    Max
    )

/*++

Routine Description:

    This function validate current updown arrow edit box selection (numerical)
    and reset the text if invalid, it also has handy cursor selection scheme.


Arguments:

    hDlg        - Handle to the property sheet dialog box

    hEdit       - Handle to the edit control (the NEXTCTRL should be UPDOWN
                  ARROW)

    CtrlData    - CtrlData for the Edit Control, it has EDF_xxxx flags

    pSel        - Pointer to a LONG for the previous selected number

    Min         - Min number for this edit control

    Max         - max number for this edit control



Return Value:

    BOOL    - TRUE if selection number changed, FALSE otherwise


Author:

    19-Sep-1995 Tue 12:35:33 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPWSTR  pSelBuf;
    LONG    OldSel;
    LONG    Sel;
    LONG    SelBegIdx;
    LONG    SelEndIdx;
    BOOL    ResetText;
    BOOL    bSign;
    BOOL    bDifSel;
    UINT    Len;
    UINT    cDigit;
    WCHAR   SelBuf[MAX_UDARROW_TEXT_LEN+1];
    WCHAR   ch;


    SelBuf[0] = 0;
    cDigit    = 0;
    bSign     = FALSE;
    Sel       = 0;
    SelBegIdx =
    SelEndIdx = 9999;
    pSelBuf   = SelBuf;
    OldSel    = *pSel;

    if (!(Len = (UINT)GetWindowText(hEdit, pSelBuf, ARRAYSIZE(SelBuf)))) {

        SelBegIdx = 0;
        ResetText = TRUE;

    } else {

        ResetText = FALSE;
    }

    CPSUIDBG(DBG_VALIDATE_UD, ("---------- Validate UDArrow -----------"));
    CPSUIDBG(DBG_VALIDATE_UD, ("UDArrow: CUR Text='%ws' (%ld), OldSel=%ld",
                                                        SelBuf, Len, OldSel));

    while (ch = *pSelBuf++) {

        switch (ch) {

        case L'-':

            if ((bSign)     ||
                (cDigit)    ||
                ((Min >= 0) && (Max >= 0))) {

                ResetText = TRUE;

            } else {

                bSign = TRUE;
            }

            break;

        default:

            if ((ch >= L'0') && (ch <= L'9')) {

                cDigit++;

                Sel = (Sel * 10) + (LONG)(ch - L'0');

            } else {

                ResetText = TRUE;
            }

            break;
        }
    }

    if (bSign) {

        //
        // If we got '-' or '-0' then make it to Min, and not selecting the
        // minus sign
        //

        if (!(Sel = -Sel)) {

            Sel       = Min;
            SelBegIdx = 1;
            ResetText = TRUE;
        }

    } else if (!Sel) {

        SelBegIdx = 0;
    }

    cDigit = wsprintf(SelBuf, L"%ld", Sel);

    if (Sel < Min) {

        ResetText = TRUE;

        if (Sel) {

            SelBegIdx = cDigit;

            if ((SelBegIdx)                 &&
                (CtrlData & EDF_BACKSPACE)  &&
                ((CtrlData & EDF_BEGIDXMASK) <= SelBegIdx)) {

                SelBegIdx--;
            }

            while (Sel < Min) {

                Sel *= 10;
            }

            if (Sel > Max) {

                Sel = 0;
            }
        }

        if (!Sel) {

            Sel       = Min;
            SelBegIdx = 0;
        }

    } else if (Sel > Max) {

        ResetText = TRUE;
        Sel       = Max;
        SelBegIdx = 0;
    }

    *pSel = Sel;

    if ((cDigit = wsprintf(SelBuf, L"%ld", Sel)) != Len) {

        ResetText = TRUE;

        if (SelBegIdx == 9999) {

            SelBegIdx =
            SelEndIdx = (LONG)(CtrlData & EDF_BEGIDXMASK);
        }
    }

    if (ResetText) {

        CPSUIDBG(DBG_VALIDATE_UD,
                ("UDArrow: NEW Text='%ws' (%ld)", SelBuf, cDigit));

        SendMessage(hEdit, WM_SETTEXT, (WPARAM)0, (LPARAM)SelBuf);

        // SetDlgItemInt(hDlg, GetDlgCtrlID(hEdit), Sel, TRUE);
    }

    if (SelBegIdx != 9999) {

        CPSUIDBG(DBG_VALIDATE_UD, ("UDArrow: NEW SelIdx=(%ld, %ld)",
                        SelBegIdx, SelEndIdx));

        SendMessage(hEdit, EM_SETSEL, SelBegIdx, SelEndIdx);
    }

    CPSUIDBG(DBG_VALIDATE_UD, ("UDArrow: Sel=%ld -> %ld, Change=%hs\n",
                OldSel, Sel, (OldSel == Sel) ? "FALSE" : "TRUE"));

    return(OldSel != Sel);
}




HWND
FindItemFirstFocus(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    05-Mar-1998 Thu 14:39:17 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hFocus;
    POPTITEM    pItemBeg;
    POPTITEM    pItemEnd;
    BYTE        PageIdx;
    BOOL        HasFocus = FALSE;


    PageIdx  = (BYTE)(GET_PMYDLGPAGE(hDlg))->PageIdx;
    pItemBeg = pItem;
    pItemEnd = pTVWnd->pLastItem + 1;

    while ((pItem) && (!HasFocus)) {

        if (pItem->DlgPageIdx == PageIdx) {

            POPTTYPE    pOptType;
            UINT        CtrlID;
            UINT        cCtrls;

            if (pOptType = pItem->pOptType) {

                CtrlID = (UINT)pOptType->BegCtrlID;
                cCtrls = (UINT)cTVOTCtrls[pOptType->Type];

                CPSUIOPTITEM(DBG_FOCUS, pTVWnd, "Find Focus", 1, pItem);

                while ((!HasFocus) && (cCtrls--)) {

                    if ((hFocus = GetDlgItem(hDlg, CtrlID++))    &&
                        ((GetWindowLongPtr(hFocus, GWL_STYLE) &
                                (WS_VISIBLE | WS_DISABLED | WS_TABSTOP)) ==
                                                (WS_VISIBLE | WS_TABSTOP))) {

                        SetFocus(hFocus);

                        if (GetFocus() == hFocus) {

                            CPSUIDBG(DBG_FOCUS,
                                     ("pItem=%08lx (Page=%ld) has Focus=%08lx (%ld), Style=%08lx",
                                        pItem, PageIdx, hFocus,
                                            GetWindowLongPtr(hFocus, GWLP_ID),
                                            GetWindowLongPtr(hFocus, GWL_STYLE)));

                            HasFocus = TRUE;
                        }
                    }
                }

            }
        }

        if (++pItem >= pItemEnd) {

            if (pItemEnd == pItemBeg) {

                pItem = NULL;

            } else {

                pItem    = pTVWnd->ComPropSheetUI.pOptItem;
                pItemEnd = pItemBeg;
            }
        }
    }

    if ((HasFocus) && (hFocus)) {

        return(hFocus);

    } else {

        return(NULL);
    }
}





POPTITEM
DlgHScrollCommand(
    HWND    hDlg,
    PTVWND  pTVWnd,
    HWND    hCtrl,
    WPARAM  wParam
    )

/*++

Routine Description:

    This is a general function to process all WM_COMMAND and WM_HSCROLL
    for the common UI


Arguments:

    hDlg    - Handle to the dialog box

    pTVWnd  - Our instance data

    hCtrl   - The handle to the control

    wParam  - message/data insterested



Return Value:

    POPTITEM    NULL if nothing changed


Author:

    01-Sep-1995 Fri 02:25:18 updated  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hFocus;
    POPTTYPE    pOptType;
    POPTPARAM   pOptParam;
    POPTITEM    pItem;
    LPTSTR      pSel;
    DWORD       dw;
    BOOL        HasSel = FALSE;
    BYTE        CtrlStyle;
    BYTE        CtrlData;
    BYTE        Type;
    WORD        ItemIdx;
    LONG        NewSel;
    INT_PTR     SelIdx;
    INT         Count;
    UINT        Len;
    WORD        LoW;
    WORD        HiW;
    INT         SelAdd;
    INT         CurSel;
    UINT        IDGetItemData;
    BOOL        IsLB;
    DWORD       BegSel;
    DWORD       EndSel;


    HiW = HIWORD(wParam);
    LoW = LOWORD(wParam);

    if (pItem = pTVWnd->pMouseItem) {

        pTVWnd->pMouseItem = NULL;

        switch (LoW) {

        case ID_CMD_HELP:

            CPSUIINT(("=== GET MENU message = HELP, hFocus=%08lx, hWndTV=%08lx ====",
                    (hDlg == pTVWnd->hDlgTV) ? pTVWnd->hWndTV : GetFocus(),
                        pTVWnd->hWndTV));

            CommonPropSheetUIHelp(hDlg,
                                  pTVWnd,
                                  (hDlg == pTVWnd->hDlgTV) ?
                                        pTVWnd->hWndTV : GetFocus(),
                                  (DWORD)pTVWnd->MousePos,
                                  pItem,
                                  HELP_WM_HELP);

            pTVWnd->MousePos = 0;

            return(NULL);

        case ID_CMD_UNDO:

            hFocus = GetFocus();

            //
            // Revert
            //

            DoCallBack(hDlg,
                       pTVWnd,
                       pItem,
                       pItem->pSel,
                       (_CPSUICALLBACK)InternalRevertOptItem,
                       NULL,
                       0,
                       CPSUICB_REASON_ITEMS_REVERTED);

            if ((hFocus) && (!GetFocus())) {

                dw = (DWORD)GetWindowLongPtr(hFocus, GWL_STYLE);

                CPSUIDBG(DBG_FOCUS,
                         ("\n!!! Original hFocus=%08lx (%ld), Style=%08lx",
                            hFocus, GetWindowLongPtr(hFocus, GWLP_ID), dw));

                //
                // We has a focus, and lost the keyboard focus now
                //

                if ((dw & (WS_VISIBLE | WS_DISABLED)) == WS_VISIBLE) {

                    //
                    // If this window still enable/visble then set to it
                    //

                    CPSUIDBG(DBG_FOCUS,
                             ("  Focus=%08lx (%ld) still ok, set to it",
                                hFocus, GetWindowLongPtr(hFocus, GWLP_ID)));

                    SetFocus(hFocus);

                } else if (hDlg != pTVWnd->hDlgTV) {

                    if (!(hFocus = FindItemFirstFocus(hDlg, pTVWnd, pItem))) {

                        CPSUIDBG(DBG_FOCUS,
                                ("=== Cannot find any more focus goto WM_NEXTDLGCTL ==="));

                        SendMessage(hDlg, WM_NEXTDLGCTL, 1, (LPARAM)FALSE);
                    }
                }
            }

            pTVWnd->MousePos = 0;

            return(pItem);

        case ID_CMD_ABOUT:

            CPSUIINT(("=== GET MENU message = ABOUT ======"));

            if (pItem = PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT)) {

                DoAbout(hDlg, pTVWnd, pItem);
            }

            pTVWnd->MousePos = 0;

            return(NULL);

        default:

            break;
        }
    }


    if (!(dw = (DWORD)GetWindowLongPtr(hCtrl, GWLP_USERDATA))) {

        CPSUIDBG(DBG_CS,
                ("DoDlgCmd: dw=0, wParam=%08lx, lParam=%08lx", wParam, hCtrl));

        return(NULL);
    }

    GETCTRLDATA(dw, ItemIdx, CtrlStyle, CtrlData);

    CPSUIDBG(DBG_CS, ("ID=%ld, LoW=%ld, HiW=%ld, Idx=%ld, Style=0x%02lx, Data=%ld",
            (DWORD)GetDlgCtrlID(hCtrl), (LONG)((SHORT)LoW),
            (LONG)((SHORT)HiW), (DWORD)ItemIdx, (DWORD)CtrlStyle, (DWORD)CtrlData));

    //
    // Validate what we got
    //

    if ((!(pItem = GetOptions(pTVWnd, MAKELPARAM(ItemIdx, 0)))) ||
        (!(pOptType = GET_POPTTYPE(pItem)))                     ||
        ((Type = pOptType->Type) > TVOT_LAST)                   ||
        (pItem->Flags & (OPTIF_DISABLED | OPTIF_ITEM_HIDE))) {

        CPSUIINT(("COMMAND: Invalid hCtrl or disable/hide Idx=%ld", ItemIdx));
        CPSUIINT(("ID=%ld, LoW=%ld, HiW=%ld, CtrlStyle=0x%02lx, CtrlData=%ld",
            (DWORD)GetDlgCtrlID(hCtrl), (LONG)((SHORT)LoW),
            (LONG)((SHORT)HiW), (DWORD)CtrlStyle, (DWORD)CtrlData));

        return(NULL);
    }

    if (!(pTVWnd->Flags & TWF_CAN_UPDATE)) {

        if ((pItem == PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT))   ||
            ((CtrlStyle == CTRLS_PUSHBUTTON) &&
             (pOptType->Flags & OTS_PUSH_ENABLE_ALWAYS))) {

            NULL;

        } else {

            CPSUIINT(("ID=%ld, CtrlStyle=0x%02lx, ENABLE_EVEN_NO_UPDATE=0",
                    (DWORD)GetDlgCtrlID(hCtrl), (DWORD)CtrlStyle));
            return(NULL);
        }
    }

    pOptParam     = pOptType->pOptParam;
    pSel          = pItem->pSel;
    Type          = pOptType->Type;
    IsLB          = TRUE;
    IDGetItemData = LB_GETITEMDATA;

    switch (CtrlStyle) {

    case CTRLS_PROPPAGE_ICON:

        switch (HiW) {

        case STN_CLICKED:
        case STN_DBLCLK:

            CPSUIASSERT(0, "CTRLS_PROPAGE_ICON but TVOT=%ld",
                        (Type == TVOT_2STATES) ||
                        (Type == TVOT_3STATES) ||
                        (Type == TVOT_CHKBOX), Type);

            SetFocus(GetDlgItem(hDlg, LoW - 1));

            if (Type == TVOT_CHKBOX) {

                CtrlStyle = CTRLS_CHKBOX;
                NewSel    = (pItem->Sel) ? 0 : 1;

                CheckDlgButton(hDlg,
                               LoW - 1,
                               (NewSel) ? BST_CHECKED : BST_UNCHECKED);
            } else {

                BegSel    = (DWORD)(pOptType->BegCtrlID + 2);
                EndSel    = BegSel + (DWORD)(((Type - TVOT_2STATES) + 1) << 1);
                CtrlStyle = CTRLS_RADIO;
                NewSel    = (LONG)CtrlData;

                CheckRadioButton(hDlg, BegSel, EndSel, LoW - 1);
            }

            HasSel = TRUE;
        }

        break;

    case CTRLS_ECBICON:

        switch (HiW) {

        case STN_CLICKED:
        case STN_DBLCLK:

            CPSUIASSERT(0, "CTRLS_ECBICON but NO pExtChkBox",
                                                pItem->pExtChkBox, 0);

            //
            // Flip the selection
            //

            NewSel = (pItem->Flags & OPTIF_ECB_CHECKED) ? 0 : 1;

            SetFocus(GetDlgItem(hDlg, LoW - 1));
            CheckDlgButton(hDlg,
                           LoW - 1,
                           (NewSel) ? BST_CHECKED : BST_UNCHECKED);

            CtrlStyle = CTRLS_EXTCHKBOX;
            HasSel    = TRUE;
        }

        break;

    case CTRLS_RADIO:

        CPSUIASSERT(0, "CTRLS_RADIO but TVOT=%ld",
                   (Type == TVOT_2STATES) || (Type == TVOT_3STATES), Type);

        if (HiW == BN_CLICKED) {

            HasSel = TRUE;
            NewSel = CtrlData;
        }

        break;

    case CTRLS_UDARROW_EDIT:
#if (DO_IN_PLACE == 0)
        CPSUIASSERT(0, "CTRLS_UDARROW_EDIT but TVOT=%ld",
                                    (Type == TVOT_UDARROW), Type);
#endif
        CPSUIDBG(DBG_UDARROW, ("UDArrow, hEdit=%08lx (%ld), hUDArrow=%08lx (%ld), CtrlData=0x%02lx",
                hCtrl, GetDlgCtrlID(hCtrl), GetWindow(hCtrl, GW_HWNDNEXT),
                GetDlgCtrlID(GetWindow(hCtrl, GW_HWNDNEXT)), CtrlData));

        switch (HiW) {

        case EN_UPDATE:

            if (_OI_INTFLAGS(pItem) & OIDF_IN_EN_UPDATE) {

                return(NULL);

            } else {

                _OI_INTFLAGS(pItem) |= OIDF_IN_EN_UPDATE;

                NewSel = pItem->Sel;

                if (HasSel = ValidateUDArrow(hDlg,
                                             hCtrl,
                                             CtrlData,
                                             &(pItem->Sel),
                                             (LONG)pOptParam[1].IconID,
                                             (LONG)pOptParam[1].lParam)) {

                    CPSUIINT(("UDARROW: EN_UPDATE: OldSel=%ld, NewSel=%ld",
                                NewSel, pItem->Sel));

                    NewSel     = pItem->Sel;
                    pItem->Sel = ~(DWORD)NewSel;
                }

                _OI_INTFLAGS(pItem) &= ~OIDF_IN_EN_UPDATE;
            }

            break;

        case EN_SETFOCUS:

            PostMessage(hCtrl, EM_SETSEL, 0, -1L);

            break;
        }

        break;

    case CTRLS_TRACKBAR:

        CPSUIASSERT(0, "CTRLS_TRACKBAR but TVOT=%ld",
                                    (Type == TVOT_TRACKBAR), Type);

        switch (LoW) {

        case TB_TOP:
        case TB_BOTTOM:
        case TB_ENDTRACK:
        case TB_LINEDOWN:
        case TB_LINEUP:
        case TB_PAGEDOWN:
        case TB_PAGEUP:

            NewSel = (DWORD)SendMessage(hCtrl, TBM_GETPOS, 0, 0L);
            break;

        case TB_THUMBPOSITION:
        case TB_THUMBTRACK:

            NewSel = (LONG)((SHORT)HiW);
            break;

        default:

            return(NULL);
        }

        HasSel = TRUE;

        break;

    case CTRLS_HSCROLL:

        CPSUIASSERT(0, "CTRLS_HSCROLL but TVOT=%ld",
                                    (Type == TVOT_SCROLLBAR), Type);

        NewSel = (LONG)LODWORD(pSel);

        switch (LoW) {

        case SB_PAGEUP:

            NewSel -= (LONG)(SHORT)pOptParam[2].lParam;
            break;

        case SB_PAGEDOWN:

            NewSel += (LONG)(SHORT)pOptParam[2].lParam;
            break;

        case SB_LINEUP:

            --NewSel;
            break;

        case SB_LINEDOWN:

            ++NewSel;
            break;

        case SB_TOP:

            NewSel = (LONG)pOptParam[1].IconID;
            break;

        case SB_BOTTOM:

            NewSel = (LONG)pOptParam[1].lParam;
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:

            NewSel = (LONG)((SHORT)HiW);
            break;

        default:

            return(NULL);
        }

        if (NewSel < (LONG)pOptParam[1].IconID) {

            NewSel = (LONG)pOptParam[1].IconID;

        } else if (NewSel > (LONG)pOptParam[1].lParam) {

            NewSel = (LONG)pOptParam[1].lParam;
        }

        SendMessage(hCtrl, SBM_SETPOS, (WPARAM)NewSel, (LPARAM)TRUE);
        HasSel = TRUE;

        break;

    case CTRLS_COMBOBOX:

        IsLB = FALSE;

        if (HiW == CBN_SELCHANGE) {

            //
            // make CBN_SELCHANGE to LBN_SELCHANGE
            //

            IDGetItemData = CB_GETITEMDATA;
            HiW           = LBN_SELCHANGE;

        } else {

            switch (HiW) {

            case CBN_CLOSEUP:

                //
                // When close up the drop down box, we post another selection
                // message if selection really changed, and then process the
                // CBN_SELCHANGE because the drop down box is closed
                //

                CurSel = (INT)SendMessage(hCtrl, CB_GETCURSEL, 0, 0);
                SelIdx = (INT_PTR)GetProp(hCtrl, CPSUIPROP_CBPRESEL) - 1;

                if (CurSel != SelIdx) {

                    PostMessage(hDlg,
                                WM_COMMAND,
                                MAKEWPARAM(GetDlgCtrlID(hCtrl), CBN_SELCHANGE),
                                (LPARAM)hCtrl);
                }

                break;

            case CBN_DROPDOWN:

                //
                // When combo box is selected, remember what selection we
                // start with
                //

                SelIdx = (INT)SendMessage(hCtrl, CB_GETCURSEL, 0, 0);
                SetProp(hCtrl, CPSUIPROP_CBPRESEL, (HANDLE)(SelIdx + 1));

                CPSUIDBG(DBG_CBWNDPROC, ("CBN_DROPDOWN: SelIdx=%ld", SelIdx));

                break;
            }

            break;
        }

        //
        // Fall through
        //

    case CTRLS_LISTBOX:
#if (DO_IN_PLACE == 0)
        CPSUIASSERT(0, "CTRLS_LISTBOX/CTRLS_COMBOBOX but TVOT=%ld",
                   (Type == TVOT_COMBOBOX) ||
                   (Type == TVOT_LISTBOX)  || (Type == CtrlData), Type);
#endif
        switch (HiW) {

        case LBN_SELCHANGE:

            SelIdx = (INT)SendMessage(hCtrl,
                                      (IsLB) ? LB_GETCURSEL : CB_GETCURSEL,
                                      0,
                                      0);
            dw     = (DWORD)SendMessage(hCtrl, IDGetItemData, SelIdx, 0L);

            if (dw & LBCBID_DISABLED) {

                SelIdx = (INT)FindNextLBCBSel(hCtrl,
                                              (LONG)_OI_LBCBSELIDX(pItem),
                                              (LONG)SelIdx,
                                              IDGetItemData,
                                              &dw);

                PostMessage(hCtrl,
                            (IsLB) ? LB_SETCURSEL : CB_SETCURSEL,
                            (WPARAM)SelIdx,
                            0L);
            }

            if (dw & (LBCBID_NONE | LBCBID_FILL)) {

                NewSel = -1;

            } else if (dw & LBCBID_DISABLED) {

                CPSUIERR(("LBCB: Could not find not disable item"));

            } else {

                NewSel = (LONG)LOWORD(dw);
            }

            _OI_LBCBSELIDX(pItem) = (WORD)SelIdx;

            if (!(HasSel = IsLB)) {

                //
                // If it is a CBN_SELCHANGE then we only really do SELCHAGE
                // when the drop down box is closed, noticed, in compstui when
                // a combobox is selected we always open the drop down box
                //

                if (!SendMessage(hCtrl, CB_GETDROPPEDSTATE, 0, 0)) {

                    HasSel = TRUE;

                    CPSUIDBG(DBG_CBWNDPROC, ("CBN_SELCHANGE: The DropDown Closed, SelIdx=%ld",
                                                SelIdx));
                }
            }

            CPSUIDBG(DBG_CS, ("LBCB Select Changed: SelIdx=%ld, NewSel=%ld",
                                                        SelIdx, NewSel));
            break;

        default:

            return(NULL);
        }

        break;

    case CTRLS_EDITBOX:

        CPSUIASSERT(0, "CTRLS_EDITBOX but TVOT=%ld",
                                    (Type == TVOT_EDITBOX), Type);

        switch (HiW) {

        case EN_CHANGE:

            Len = (UINT)pOptParam[1].IconID;

            if (pTVWnd->Flags & TWF_ANSI_CALL) {

                GetWindowTextA(hCtrl, (LPSTR)pSel, Len);

            } else {

                GetWindowText(hCtrl, (LPTSTR)pSel, Len);
            }

            HasSel      = TRUE;
            NewSel      = 0;

            break;

        case EN_SETFOCUS:

            PostMessage(hCtrl, EM_SETSEL, 0, -1L);
            break;
        }

        break;

    case CTRLS_EXTPUSH:

        CPSUIASSERT(0, "CTRLS_EXTPUSH but is not OPTIF_EXT_IS_EXTPUSH = %ld",
                    pItem->Flags & OPTIF_EXT_IS_EXTPUSH, ULongToPtr(pItem->Flags));

        if (HiW == BN_CLICKED) {

            PEXTPUSH    pEP = pItem->pExtPush;

            if (pItem == PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT)) {

                DoAbout(hDlg, pTVWnd, pItem);

            } else {

                HANDLE  hDlgTemplate = NULL;
                WORD    DlgTemplateID = 0;

                if (pEP->Flags & EPF_PUSH_TYPE_DLGPROC) {

                    if (pEP->Flags & EPF_USE_HDLGTEMPLATE) {

                        hDlgTemplate = pEP->hDlgTemplate;

                    } else {

                        DlgTemplateID = pEP->DlgTemplateID;
                    }
                }

                DoCallBack(hDlg,
                           pTVWnd,
                           pItem,
                           pItem->pSel,
                           (_CPSUICALLBACK)pEP->pfnCallBack,
                           hDlgTemplate,
                           DlgTemplateID,
                           CPSUICB_REASON_EXTPUSH);
            }
        }

        break;

    case CTRLS_PUSHBUTTON:

        CPSUIASSERT(0, "CTRLS_PUSHBUTTON but TVOT=%ld",
                                    (Type == TVOT_PUSHBUTTON), Type);

        if (HiW == BN_CLICKED) {

            NewSel = DoPushButton(hDlg, pTVWnd, pItem);

            if ((pOptParam[0].Style != PUSHBUTTON_TYPE_CALLBACK) &&
                (pTVWnd->Flags & TWF_CAN_UPDATE)) {

                HasSel     = TRUE;
                pItem->Sel = (DWORD)~(DWORD)NewSel;
            }
        }

        break;

    case CTRLS_CHKBOX:
    case CTRLS_EXTCHKBOX:

        if (CtrlStyle == CTRLS_CHKBOX) {

            CPSUIASSERT(0, "CTRLS_CHKBOX but TVOT=%ld",
                                        (Type == TVOT_CHKBOX), Type);

        } else {

            CPSUIASSERT(0, "CTRLS_EXTCHKBOX but pExtChkBox=%ld",
                            (pItem->pExtChkBox != NULL), pItem->pExtChkBox);
        }

        if (HiW == BN_CLICKED) {

            HasSel = TRUE;
            NewSel = (LONG)SendMessage(hCtrl, BM_GETCHECK, 0, 0L);
        }

        break;

    case CTRLS_UDARROW:
    case CTRLS_TV_WND:
    case CTRLS_TV_STATIC:
    case CTRLS_PROPPAGE_STATIC:
    case CTRLS_NOINPUT:

        CPSUIINT(("Static CTRLS_xxx = %ld", CtrlStyle));

        return(NULL);

    default:

        CPSUIERR(("\nInternal ERROR: Invalid CTRLS_xxx=%02lx\n", CtrlStyle));
        return(NULL);
    }

    if (HasSel) {

        if (CtrlStyle == CTRLS_EXTCHKBOX) {

            HasSel = (BOOL)((DWORD)(pItem->Flags & OPTIF_ECB_CHECKED) !=
                            (DWORD)((NewSel) ? OPTIF_ECB_CHECKED : 0));

        } else {

            HasSel = (BOOL)(pItem->Sel != NewSel);
        }

        if (HasSel) {

            PMYDLGPAGE  pCurMyDP;
            PMYDLGPAGE  pMyDP;
            BYTE        CurPageIdx;
            BYTE        DlgPageIdx;
            BYTE        TVPageIdx;
            WORD        Reason;


            pCurMyDP   = GET_PMYDLGPAGE(hDlg);
            pMyDP      = pTVWnd->pMyDlgPage;
            CurPageIdx = pCurMyDP->PageIdx;
            DlgPageIdx = pItem->DlgPageIdx;
            TVPageIdx  = pTVWnd->TVPageIdx;

            CPSUIDBG(DBG_CS, ("Item Changed: CurPage=%ld, DlgPage=%ld, TVPageIdx=%ld",
                    (DWORD)CurPageIdx, (DWORD)DlgPageIdx, (DWORD)TVPageIdx));

            //
            // firstable mark current page to changed once.
            //

            pCurMyDP->Flags |= MYDPF_CHANGEONCE;

            //
            // If we are in the treeview page, then set the dirty flag if it
            // belong to the other page
            //

            if (CurPageIdx == TVPageIdx) {

                if (DlgPageIdx != CurPageIdx) {

                    pMyDP[DlgPageIdx].Flags |= (MYDPF_CHANGED |
                                                MYDPF_CHANGEONCE);
                    pItem->Flags            |=  OPTIF_INT_CHANGED;
                }

            } else if (TVPageIdx != PAGEIDX_NONE) {

                //
                // Not in treeview page, so set the dirty bit for treeview
                //

                pMyDP[TVPageIdx].Flags |= (MYDPF_CHANGED | MYDPF_CHANGEONCE);
                pItem->Flags           |= OPTIF_INT_TV_CHANGED;
            }

            if (CtrlStyle == CTRLS_EXTCHKBOX) {

                Reason        = CPSUICB_REASON_ECB_CHANGED;
                pItem->Flags ^= OPTIF_ECB_CHECKED;

            } else {
                
                Reason        = CPSUICB_REASON_SEL_CHANGED;
                if (CtrlStyle != CTRLS_EDITBOX) {

                    //
                    // In the case of CTRLS_EDITBOX, pItem->pSel is already the new value
                    //
                    pItem->Sel    = NewSel;
                }                
            }

            pItem->Flags |= OPTIF_CHANGEONCE;

            //
            // Doing the internal DMPub first,
            //

            if (Len = UpdateInternalDMPUB(hDlg, pTVWnd, pItem)) {

                UpdateCallBackChanges(hDlg, pTVWnd, Len & INTDMPUB_REINIT);
            }

            if ((pItem->Flags & OPTIF_CALLBACK)             &&
                (ItemIdx < pTVWnd->ComPropSheetUI.cOptItem)) {

                DoCallBack(hDlg, pTVWnd, pItem, pSel, NULL, NULL, 0, Reason);
            }

            CPSUIOPTITEM(DBGITEM_CS, pTVWnd, "!! ChangeSelection !!", 1, pItem);

            IsItemChangeOnce(pTVWnd, pItem);

            SET_APPLY_BUTTON(pTVWnd, hDlg);

            return(pItem);
        }
    }

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\debug.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    debug.h


Abstract:

    This module contains all debugger definitions


Author:

    30-Aug-1995 Wed 19:02:36 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/



#if DBG

VOID
cdecl
CPSUIDbgPrint(
    LPSTR   pszFormat,
    ...
    );

VOID
CPSUIDbgType(
    INT    Type
    );

VOID
_CPSUIAssert(
    LPSTR   pMsg,
    LPSTR   pFalseExp,
    LPSTR   pFilename,
    UINT    LineNo,
    LPVOID  Exp,
    BOOL    Stop
    );

VOID
CPSUIDbgShowItem(
    PTVWND      pTVWnd,
    LPSTR       pTitle,
    UINT        Level,
    POPTITEM    pItem
    );


extern BOOL DoCPSUIWarn;
extern BOOL DoDbgMsg;
extern BOOL DoIntMsg;

#define _ISDBG(x)               (((DoIntMsg) && (!(x)))     ||             \
                                 ((DoDbgMsg) && ((x)&DBG_CPSUIFILENAME)))

#define _DBGP(x)                (CPSUIDbgPrint x)
#define DBGP(x)                 if (DoDbgMsg) { _DBGP(x); }

#if 1

#define DEFINE_DBGVAR(x)        DWORD DBG_CPSUIFILENAME=(x)
#else

#define DEFINE_DBGVAR(x)
#endif  // if 1

#define CPSUIDBG(x,y)           if ((DoDbgMsg)&&((x)&DBG_CPSUIFILENAME)){  \
                                    CPSUIDbgType(0);_DBGP(y);}
#define CPSUIDBGBLK(x)          x;
#define CPSUIRECT(x,ps,prc,i,j)                                             \
    if (_ISDBG(x)) { CPSUIDbgType(0);                                       \
        _DBGP(("RECT *%hs* [%ld:%ld]: (%ld, %ld) - (%ld, %ld) = %ld x %ld", \
                (ps), (LONG)(i),(LONG)(j), (prc)->left, (prc)->top,         \
                (prc)->right, (prc)->bottom, (prc)->right - (prc)->left,    \
                (prc)->bottom - (prc)->top)); }
#define CPSUIOPTITEM(x,p,t,l,i) if(_ISDBG(x)) {CPSUIDbgShowItem(p,t,l,i);}
#define CPSUIWARN(x)            if(DoCPSUIWarn) { CPSUIDbgType(1);_DBGP(x); }
#define CPSUIINT(x)             if(DoIntMsg){ CPSUIDbgType(0);_DBGP(x); }
#define CPSUIERR(x)             CPSUIDbgType(-1);_DBGP(x)
#define CPSUIRIP(x)             CPSUIERR(x); DebugBreak()
#define CPSUIASSERT(b,x,e,i)     \
        if (!(e)) { _CPSUIAssert(x,#e,__FILE__,(UINT)__LINE__,(LPVOID)(i),b); }

#else   // DBG

#define CPSUIDBGBLK(x)
#define DEFINE_DBGVAR(x)
#define CPSUIDBG(x,y)
#define CPSUIRECT(x,ps,prc,i,j)
#define CPSUIOPTITEM(x,p,l,t,i)
#define CPSUIWARN(x)
#define CPSUIINT(x)
#define CPSUIERR(x)
#define CPSUIRIP(x)
#define CPSUIASSERT(b,x,e,i)

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\dlgctrl.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    dlgctrl.h


Abstract:

    This module contains predefines and prototypes for the dialog box control
    for the commoon UI


Author:

    28-Aug-1995 Mon 12:14:51 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/


#define CTRLS_FIRST             0x80
#define CTRLS_RADIO             0x80
#define CTRLS_UDARROW           0x81
#define CTRLS_UDARROW_EDIT      0x82
#define CTRLS_TRACKBAR          0x83
#define CTRLS_HSCROLL           0x84
#define CTRLS_VSCROLL           0x85
#define CTRLS_LISTBOX           0x86
#define CTRLS_COMBOBOX          0x87
#define CTRLS_EDITBOX           0x88
#define CTRLS_PUSHBUTTON        0x89
#define CTRLS_CHKBOX            0x8a
#define CTRLS_EXTCHKBOX         0x8b
#define CTRLS_EXTPUSH           0x8c
#define CTRLS_TV_WND            0x8d
#define CTRLS_TV_STATIC         0x8e
#define CTRLS_PROPPAGE_STATIC   0x8f
#define CTRLS_PROPPAGE_ICON     0x90
#define CTRLS_ECBICON           0x91
#define CTRLS_NOINPUT           0x92
#define CTRLS_LAST              0x92


#define INITCF_ENABLE           0x0001
#define INITCF_INIT             0x0002
#define INITCF_SETCTRLDATA      0x0004
#define INITCF_ADDSELPOSTFIX    0x0008
#define INITCF_ICON_NOTIFY      0x0010
#define INITCF_HAS_EXT          0x0020
#define INITCF_TVDLG            0x0040

#define CTRLDATA_ITEMIDX_ADD    11

#define SETCTRLDATA(hCtrl, CtrlStyle, CtrlData)                             \
{                                                                           \
    SetWindowLongPtr((hCtrl),                                               \
                     GWLP_USERDATA,                                         \
                     (LPARAM)MAKELONG(MAKEWORD((CtrlData),(CtrlStyle)),     \
                                      (InitItemIdx+CTRLDATA_ITEMIDX_ADD))); \
}

#define HCTRL_SETCTRLDATA(hCtrl, CtrlStyle, CtrlData)                       \
{                                                                           \
    if ((hCtrl) && (InitFlags & INITCF_SETCTRLDATA)) {                      \
                                                                            \
        SETCTRLDATA(hCtrl, CtrlStyle, CtrlData);                            \
    }                                                                       \
}

#define GETCTRLITEMIDX(dw)      (HIWORD(dw)-CTRLDATA_ITEMIDX_ADD)
#define GETCTRLDATA(dw,i,s,d)   (i)=GETCTRLITEMIDX(dw);                     \
                                (d)=LOBYTE(LOWORD(dw));(s)=HIBYTE(LOWORD(dw))

#define REAL_ECB_CHECKED(pItem, pECB)                                       \
    (BOOL)(((pECB) = (pItem)->pExtChkBox)               &&                  \
           (((pItem)->Flags & (OPTIF_EXT_HIDE | OPTIF_EXT_IS_EXTPUSH |      \
                                OPTIF_ECB_CHECKED)) == OPTIF_ECB_CHECKED))


#define INIT_EXTENDED(pTVWnd,hDlg,pItem,ecbID,epID,IconID,Idx,InitFlags)    \
    ((pItem->Flags & OPTIF_EXT_IS_EXTPUSH) ?                                \
        InitExtPush(pTVWnd,hDlg,pItem,ecbID,epID,IconID,Idx,InitFlags) :    \
        InitExtChkBox(pTVWnd,hDlg,pItem,ecbID,epID,IconID,Idx,InitFlags))


typedef struct _DLGIDINFO {
    HWND        hDlg;
    DWORD       CurID;
    } DLGIDINFO, *PDLGIDINFO;

//
// Prototypes
//

VOID
SetUniqChildID(
    HWND    hDlg
    );

BOOL
hCtrlrcWnd(
    HWND    hDlg,
    HWND    hCtrl,
    RECT    *prc
    );

HWND
CtrlIDrcWnd(
    HWND    hDlg,
    UINT    CtrlID,
    RECT    *prc
    );

BOOL
ChkEditKEYDOWN(
    HWND    hWnd,
    WPARAM  VKey
    );

BOOL
ChkhWndEdit0KEYDOWN(
    HWND    hWnd,
    WPARAM  VKey
    );

DWORD
ReCreateLBCB(
    HWND    hDlg,
    UINT    CtrlID,
    BOOL    IsLB
    );

HWND
CreateTrackBar(
    HWND    hDlg,
    UINT    TrackBarID
    );

HWND
CreateUDArrow(
    HWND    hDlg,
    UINT    EditBoxID,
    UINT    UDArrowID,
    LONG    RangeL,
    LONG    RangeH,
    LONG    Pos
    );

BOOL
SetDlgPageItemName(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem,
    UINT        InitFlags,
    UINT        UDArrowHelpID
    );

BOOL
InitExtPush(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    UINT        ExtChkBoxID,
    UINT        ExtPushID,
    UINT        ExtIconID,
    WORD        InitItemIdx,
    WORD        InitFlags
    );

BOOL
InitExtChkBox(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    UINT        ExtChkBoxID,
    UINT        ExtPushID,
    UINT        ExtIconID,
    WORD        InitItemIdx,
    WORD        InitFlags
    );

UINT
InitStates(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    POPTTYPE    pOptType,
    UINT        IDState1,
    WORD        InitItemIdx,
    LONG        NewSel,
    WORD        InitFlags
    );

LONG
InitUDArrow(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    POPTPARAM   pOptParam,
    UINT        UDArrowID,
    UINT        EditBoxID,
    UINT        PostfixID,
    UINT        HelpID,
    WORD        InitItemIdx,
    LONG        NewPos,
    WORD        InitFlags
    );

VOID
InitTBSB(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    HWND        hTBSB,
    POPTTYPE    pOptType,
    UINT        PostfixID,
    UINT        RangeLID,
    UINT        RangeHID,
    WORD        InitItemIdx,
    LONG        NewPos,
    WORD        InitFlags
    );

VOID
InitLBCB(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    UINT        idLBCB,
    UINT        SetCurSelID,
    POPTTYPE    pOptType,
    WORD        InitItemIdx,
    LONG        NewSel,
    WORD        InitFlags,
    UINT        cyLBCBMax
    );

VOID
InitEditBox(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    POPTPARAM   pOptParam,
    UINT        EditBoxID,
    UINT        PostfixID,
    UINT        HelpID,
    WORD        InitItemIdx,
    LPTSTR      pCurText,
    WORD        InitFlags
    );

VOID
InitPushButton(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    WORD        PushID,
    WORD        InitItemIdx,
    WORD        InitFlags
    );

VOID
InitChkBox(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    UINT        ChkBoxID,
    LPTSTR      pTitle,
    WORD        InitItemIdx,
    BOOL        Checked,
    WORD        InitFlags
    );

LONG
DoCallBack(
    HWND                hDlg,
    PTVWND              pTVWnd,
    POPTITEM            pItem,
    LPVOID              pOldSel,
    _CPSUICALLBACK      pfnCallBack,
    HANDLE              hDlgTemplate,
    WORD                DlgTemplateID,
    WORD                Reason
    );

POPTITEM
pItemFromhWnd(
    HWND    hDlg,
    PTVWND  pTVWnd,
    HWND    hCtrl,
    LONG    MousePos
    );

VOID
DoContextMenu(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    LPARAM      Pos
    );

UINT
UpdateInternalDMPUB(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem
    );

VOID
UpdateOptTypeIcon16(
    POPTTYPE    pOptType
    );

BOOL
DrawLBCBItem(
    PTVWND              pTVWnd,
    LPDRAWITEMSTRUCT    pdis
    );

POPTITEM
DlgHScrollCommand(
    HWND    hDlg,
    PTVWND  pTVWnd,
    HWND    hCtrl,
    WPARAM  wParam
    );


LONG
UpdateCallBackChanges(
    HWND    hDlg,
    PTVWND  pTVWnd,
    BOOL    ReInit
    );

BOOL
DoAbout(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItemRoot
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\debug.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    debug.c


Abstract:

    This module contains all debugging routines


Author:

    30-Aug-1995 Wed 19:01:07 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#if DBG


BOOL    DoCPSUIWarn = TRUE;
BOOL    DoDbgMsg = TRUE;
BOOL    DoIntMsg = FALSE;


LPSTR   pTVOTName[] = {  "TVOT_2STATES",
                         "TVOT_3STATES",
                         "TVOT_UDARROW",
                         "TVOT_TRACKBAR",
                         "TVOT_SCROLLBAR",
                         "TVOT_LISTBOX",
                         "TVOT_COMBOBOX",
                         "TVOT_EDITBOX",
                         "TVOT_PUSHBUTTON",
                         "TVOT_CHKBOX" };

LPSTR   pDMPubName[] = {  "DMPUB_NONE",
                          "DMPUB_ORIENTATION",
                          "DMPUB_SCALE",
                          "DMPUB_COPIES_COLLATE",
                          "DMPUB_DEFSOURCE",
                          "DMPUB_PRINTQUALITY",
                          "DMPUB_COLOR",
                          "DMPUB_DUPLEX",
                          "DMPUB_TTOPTION",
                          "DMPUB_FORMNAME",
                          "DMPUB_ICMMETHOD",
                          "DMPUB_ICMINTENT",
                          "DMPUB_MEDIATYPE",
                          "DMPUB_DITHERTYPE",
                          "DMPUB_OUTPUTBIN",
                          "DMPUB_QUALITY",
                          "DMPUB_NUP",
                          "DMPUB_PAGEORDER",
                          "<DMPUB_USER>"
                       };



VOID
cdecl
CPSUIDbgPrint(
    LPSTR   pszFormat,
    ...
    )

/*++

Routine Description:

    This fucntion output the debug informat to the debugger


Arguments:

    pszFormat   - format string

    ...         - variable data


Return Value:


    VOID

Author:

    30-Aug-1995 Wed 19:10:34 updated  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    va_list         vaList;
    static WCHAR    OutBuf[768];
    static WCHAR    FormatBuf[256];

    //
    // We assume that UNICODE flag is turn on for the compilation, bug the
    // format string passed to here is ASCII version, so we need to convert
    // it to LPWSTR before the wvsprintf()
    //

    va_start(vaList, pszFormat);

    MultiByteToWideChar(CP_ACP, 0, pszFormat, -1, FormatBuf, ARRAYSIZE(FormatBuf));

    wvnsprintf(OutBuf, ARRAYSIZE(OutBuf) - 1, FormatBuf, vaList);
    va_end(vaList);

    OutputDebugString((LPTSTR)OutBuf);
    OutputDebugString(L"\n");
}




VOID
CPSUIDbgType(
    INT    Type
    )

/*++

Routine Description:

    this function output the ERROR/WARNING message


Arguments:

    Type

Return Value:


Author:

    30-Aug-1995 Wed 19:10:42 updated  -by-  Daniel Chou (danielc)

Revision History:


--*/

{
    static WCHAR    DebugDLLName[] = L"ComPstUI";


    if (Type) {

        OutputDebugString((Type < 0) ? L"ERROR: " : L"WARNING: ");
    }

    OutputDebugString(DebugDLLName);
    OutputDebugString(L": ");
}




VOID
_CPSUIAssert(
    LPSTR   pMsg,
    LPSTR   pFalseExp,
    LPSTR   pFilename,
    UINT    LineNo,
    LPVOID  Exp,
    BOOL    Stop
    )

/*++

Routine Description:

    This function output assertion message and false expression to the debugger
    then break into the debugger


Arguments:

    pMsg        - Message to displayed

    pFlaseExp   - false expression

    pFilename   - source filename

    LineNo      - line number of the flase expression

Return Value:

    VOID


Author:

    30-Aug-1995 Wed 19:10:49 updated  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    OutputDebugString(L"\n");

    if ((pMsg) && (*pMsg)) {

        CPSUIDbgPrint(pMsg, Exp);
    }

    CPSUIDbgPrint("Assertion failed (%hs) in %hs line %u",
                                        pFalseExp, pFilename, LineNo);

    if (Stop) {

        DebugBreak();
    }
}


VOID
CPSUIDbgShowItem(
    PTVWND      pTVWnd,
    LPSTR       pTitle,
    UINT        Level,
    POPTITEM    pItem
    )
{
    if (pItem) {

        POPTTYPE    pOptType;
        POPTPARAM   pOptParam;
        PEXTCHKBOX  pECB = pItem->pExtChkBox;
        UINT        i;
        GSBUF_DEF(pItem, MAX_RES_STR_CHARS);


        if (pOptType = pItem->pOptType) {

            pOptParam = pOptType->pOptParam;

        } else {

            pOptParam = NULL;
        }

        CPSUIDbgPrint("\n---- %hs OPTITEM = %08lx -----", pTitle, pItem);
        CPSUIDbgPrint("cbSize     = %ld",         (DWORD)pItem->cbSize);
        CPSUIDbgPrint("pOptType   = %08lx",       pItem->pOptType);

        GSBUF_GETSTR(pItem->pName);

        CPSUIDbgPrint("pName      = %ws", GSBUF_BUF);

        GSBUF_RESET;

        if ((pOptType) && (pOptParam)) {

            switch (pOptType->Type) {

            case TVOT_LISTBOX:
            case TVOT_2STATES:
            case TVOT_3STATES:
            case TVOT_COMBOBOX:

                if ((pItem->Sel < 0) || (pItem->Sel > pOptType->Count)) {

                    GSBUF_GETSTR(pTVWnd->OptParamNone.pData);

                } else {

                    GSBUF_GETSTR(pOptParam[pItem->Sel].pData);
                }

                break;

            case TVOT_EDITBOX:

                GSBUF_GETSTR(pItem->pSel);
                break;

            case TVOT_UDARROW:
            case TVOT_TRACKBAR:
            case TVOT_SCROLLBAR:
            case TVOT_PUSHBUTTON:
            case TVOT_CHKBOX:

                break;
            }
        }

        CPSUIDbgPrint("pSel       = %ld, Name:<%ws> [%08lx]", pItem->pSel,
                                                    GSBUF_BUF, pItem->pSel);
        CPSUIDbgPrint("UserData   = %08lx",   pItem->UserData);
        CPSUIDbgPrint("pExtChkBox = %08lx",   pECB);

        if ((Level > 0) && (pECB)) {

            if (pItem->Flags & OPTIF_EXT_IS_EXTPUSH) {

                PEXTPUSH    pEP = (PEXTPUSH)pECB;


                CPSUIDbgPrint("    ---- PEXTPUSH ----");
                CPSUIDbgPrint("    cbSize              = %ld",   (DWORD)pEP->cbSize);
                CPSUIDbgPrint("    Flags               = %02lx", (DWORD)pEP->Flags);

                GSBUF_RESET;
                GSBUF_GETSTR(pEP->pTitle);
                CPSUIDbgPrint("    pTitle              = %ws", GSBUF_BUF);
                CPSUIDbgPrint("    DlgProc/pfnCallBack = %08lx", pEP->DlgProc);
                CPSUIDbgPrint("    IconID              = %0ld", pEP->IconID);
                CPSUIDbgPrint("    DlgTemplateID       = %0ld", pEP->DlgTemplateID);
                CPSUIDbgPrint("    ~~~~~~~~~~~~~~~~~~~~");

            } else {

                CPSUIDbgPrint("    ---- PEXTCHKBOX ----");
                CPSUIDbgPrint("    cbSize        = %ld",   (DWORD)pECB->cbSize);
                CPSUIDbgPrint("    Flags         = %02lx", (DWORD)pECB->Flags);

                GSBUF_RESET;
                GSBUF_GETSTR(pECB->pTitle);
                CPSUIDbgPrint("    pTitle        = %ws", GSBUF_BUF);

                GSBUF_RESET;
                GSBUF_GETSTR(pECB->pSeparator);
                CPSUIDbgPrint("    pSeparator    = %ws", GSBUF_BUF);

                GSBUF_RESET;
                GSBUF_GETSTR(pECB->pCheckedName);
                CPSUIDbgPrint("    pCheckBoxName = %ws", GSBUF_BUF);
                CPSUIDbgPrint("    IconID        = %0ld", pECB->IconID);
                CPSUIDbgPrint("    ~~~~~~~~~~~~~~~~~~~~");
            }
        }

        if ((i = pItem->DMPubID) > DMPUB_LAST) {

            i = DMPUB_LAST + 1;
        }

        CPSUIDbgPrint("Flags      = 0x%08lx", (DWORD)pItem->Flags);
        CPSUIDbgPrint("HelpIndex  = %ld",     (DWORD)pItem->HelpIndex);
        CPSUIDbgPrint("Level      = %ld",     (DWORD)pItem->Level);
        CPSUIDbgPrint("DMPubID    = %hs (%ld)", pDMPubName[i], (DWORD)pItem->DMPubID);
        CPSUIDbgPrint("DlgPageIdx = %ld", (DWORD)pItem->DlgPageIdx);

        CPSUIDbgPrint("HTREEITEM  = %08lx", _OI_HITEM(pItem));
        CPSUIDbgPrint("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");


        if ((Level > 0) && (pOptType)) {

            CPSUIDbgPrint("    ------- OPTTYPE --------");
            CPSUIDbgPrint("    cbSize    = %ld",   (DWORD)pOptType->cbSize);
            CPSUIDbgPrint("    Type      = %hs",   pTVOTName[pOptType->Type]);
            CPSUIDbgPrint("    Flags     = %02lx", (DWORD)pOptType->Flags);
            CPSUIDbgPrint("    Count     = %ld",   (DWORD)pOptType->Count);
            CPSUIDbgPrint("    BegCtrlID = %ld",   (DWORD)pOptType->BegCtrlID);
            CPSUIDbgPrint("    pOptParam = %08lx", pOptParam);
            CPSUIDbgPrint("    Style     = %04lx", (DWORD)pOptType->Style);
            CPSUIDbgPrint("    ~~~~~~~~~~~~~~~~~~~~~~~~");

            if ((Level > 1) && (pOptParam)) {

                i = pOptType->Count;

                for (i = 0; i < (UINT)pOptType->Count; i++, pOptParam++) {

                    GSBUF_RESET;
                    GSBUF_GETSTR(pOptParam->pData);

                    CPSUIDbgPrint("        ------- OPTPARAM %ld -------", (DWORD)i);
                    CPSUIDbgPrint("        cbSize   = %ld ", (DWORD)pOptParam->cbSize);
                    CPSUIDbgPrint("        Flags    = %02lx", (DWORD)pOptParam->Flags);
                    CPSUIDbgPrint("        Style    = %ld",   (DWORD)pOptParam->Style);
                    CPSUIDbgPrint("        pData    = %ws (%08lx)", GSBUF_BUF, pOptParam->pData);
                    CPSUIDbgPrint("        IconID   = %ld", (DWORD)pOptParam->IconID);
                    CPSUIDbgPrint("        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
                }
            }
        }

        CPSUIDbgPrint("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

    } else {

        CPSUIDbgPrint("\n\n---- %hs OPTITEM = %08lx -----", pTitle, pItem);
    }
}



#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\handle.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    handle.c


Abstract:

    This module contains all function which deal with handle table for the
    common UI


Author:

    30-Jan-1996 Tue 16:28:56 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/



#include "precomp.h"
#pragma  hdrstop


#define DBG_CPSUIFILENAME   DbgHandle


#define DBG_CPSUI_HTABLE    0x00000001
#define DBG_FINDHANDLE      0x00000002
#define DBG_ADD_DATA        0x00000004
#define DBG_HANDLE_DESTROY  0x00000008
#define DBG_GET_HPSPINFO    0x00000010
#define DBG_SEM             0x00000020

DEFINE_DBGVAR(0);


HANDLE              hCPSUIMutex = NULL;
CPSUIHANDLETABLE    CPSUIHandleTable = { NULL, 0, 0, 0, 0 };
extern DWORD        TlsIndex;




BOOL
LOCK_CPSUI_HANDLETABLE(
    VOID
    )

/*++

Routine Description:

    This function get the lock the object


Arguments:

    VOID

Return Value:

    BOOL


Author:

    27-Mar-1996 Wed 11:27:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BOOL    Ok = FALSE;


    if (hCPSUIMutex) {

        WORD    Idx;

        switch (WaitForSingleObject(hCPSUIMutex, MAX_SEM_WAIT)) {

        case WAIT_OBJECT_0:

            //
            // Signaled, and own it now
            //

            if (!CPSUIHandleTable.cWait++) {

                CPSUIHandleTable.ThreadID = GetCurrentThreadId();
            }

            Idx = TLSVALUE_2_IDX(TlsGetValue(TlsIndex));

            TlsSetValue(TlsIndex,
                        ULongToPtr(MK_TLSVALUE(CPSUIHandleTable.cWait, Idx)));

            CPSUIDBG(DBG_SEM, ("LOCK_CPSUI_HANDLETABLE: ThreadID=%ld, cWait=%ld",
                        GetCurrentThreadId(), CPSUIHandleTable.cWait));

            Ok = TRUE;

            break;

        case WAIT_ABANDONED:

            CPSUIERR(("LockCPSUIObject()= WAIT_ABANDONED"));
            break;

        case WAIT_TIMEOUT:

            CPSUIERR(("LockCPSUIObject()= WAIT_TIMEOUT"));
            break;

        default:

            CPSUIERR(("LockCPSUIObject()= UNKNOWN"));
            break;
        }
    }

    return(Ok);
}



BOOL
UNLOCK_CPSUI_HANDLETABLE(
    VOID
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    27-Mar-1996 Wed 11:39:37 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BOOL    Ok = FALSE;


    if (hCPSUIMutex) {

        DWORD   ThreadID = GetCurrentThreadId();
        WORD    Idx;


        CPSUIDBG(DBG_SEM, ("UNLOCK_CPSUI_HANDLETABLE: ThreadID=%ld, cWait=%ld",
                    ThreadID, CPSUIHandleTable.cWait));

        if (ThreadID == CPSUIHandleTable.ThreadID) {

            if (CPSUIHandleTable.cWait) {

                if (--CPSUIHandleTable.cWait == 0) {

                    CPSUIHandleTable.ThreadID = NO_THREADID;
                }


                Idx = TLSVALUE_2_IDX(TlsGetValue(TlsIndex));

                TlsSetValue(TlsIndex,
                            ULongToPtr(MK_TLSVALUE(CPSUIHandleTable.cWait, Idx)));

                ReleaseMutex(hCPSUIMutex);
                Ok = TRUE;

            } else {

                CPSUIERR(("The Thread ID does not match=%ld",
                            CPSUIHandleTable.ThreadID));
            }

        } else {

            CPSUIERR(("The ThreadID=%ld does not own the mutex", ThreadID));
        }
    }

    return(Ok);
}




PCPSUIPAGE
HANDLETABLE_GetCPSUIPage(
    HANDLE      hTable
    )

/*++

Routine Description:

    This function take a handle table and return the pData assoicated with it,
    the pData must already added by HANDLETABLE_AddCPSUIPage()


Arguments:




Return Value:

    pCPSUIPage, NULL if FAILED


Author:

    28-Dec-1995 Thu 17:05:11 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDATATABLE  pDataTable;
    PCPSUIPAGE  pFoundPage = NULL;
    PCPSUIPAGE  pCPSUIPage;
    WORD        Idx;


    LOCK_CPSUI_HANDLETABLE();

    if ((hTable)                                                    &&
        (pDataTable = CPSUIHandleTable.pDataTable)                  &&
        (HANDLE_2_PREFIX(hTable) == HANDLE_TABLE_PREFIX)            &&
        ((Idx = HANDLE_2_IDX(hTable)) < CPSUIHandleTable.MaxCount)  &&
        (pCPSUIPage = pDataTable[Idx].pCPSUIPage)) {

        if (pCPSUIPage->ID != CPSUIPAGE_ID) {

            CPSUIERR(("HANDLETABLE_FindpCPSUIPage(%08lx), pCPSUIPage=%08lx INVALID Internal ID",
                        hTable, pCPSUIPage));

        } else if (pCPSUIPage->hCPSUIPage != hTable) {

            CPSUIERR(("HANDLETABLE_FIndpCPSUIPage(%08lx), pCPSUIPagePage=%08lx, HANDLE not matched",
                    hTable, pCPSUIPage));

        } else {

            pCPSUIPage->cLock++;
            pFoundPage = pCPSUIPage;
        }
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(pFoundPage);
}



DWORD
HANDLETABLE_LockCPSUIPage(
    PCPSUIPAGE  pCPSUIPage
    )

/*++

Routine Description:

    This function decrement the cLock for the Page currently in USE


Arguments:

    pCPSUIPage  - Pointer to the CPSUIPAGE


Return Value:

    BOOL, true if decrment successfully


Author:

    05-Apr-1996 Fri 16:41:46 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    DWORD   cLock = 0;


    if (pCPSUIPage) {

        LOCK_CPSUI_HANDLETABLE();

        cLock = ++(pCPSUIPage->cLock);

        UNLOCK_CPSUI_HANDLETABLE();
    }

    return(cLock);
}



BOOL
HANDLETABLE_UnGetCPSUIPage(
    PCPSUIPAGE  pCPSUIPage
    )

/*++

Routine Description:

    This function decrement the cLock for the Page currently in USE


Arguments:

    pCPSUIPage  - Pointer to the CPSUIPAGE


Return Value:

    BOOL, true if decrment successfully


Author:

    05-Apr-1996 Fri 16:41:46 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BOOL    Ok;


    if (pCPSUIPage) {

        LOCK_CPSUI_HANDLETABLE();

        if (Ok = (BOOL)pCPSUIPage->cLock) {

            --(pCPSUIPage->cLock);

        } else {

            CPSUIERR(("HANDLETABLE_UnlockpCPSUIPage(%08lx), cLock is ZERO",
                            pCPSUIPage));
        }

        UNLOCK_CPSUI_HANDLETABLE();

    } else {

        Ok = FALSE;
    }

    return(Ok);
}



BOOL
HANDLETABLE_IsChildPage(
    PCPSUIPAGE  pChildPage,
    PCPSUIPAGE  pParentPage
    )

/*++

Routine Description:

    This function check if pChildPage is one of the pParentPage's child or
    its decedent child


Arguments:

    pChildPage  - Pointer to the CPSUIPAGE for child

    pParentPage - Pointer to the CPSUIPAGE for parent to be checked

Return Value:

    TRUE, if this is child, otherwise FALSE


Author:

    08-Apr-1996 Mon 12:52:51 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BOOL    Ok = FALSE;


    LOCK_CPSUI_HANDLETABLE();


    if (pChildPage) {

        while (pChildPage->pParent) {

            if (pChildPage->pParent == pParentPage) {

                Ok = TRUE;
                break;

            } else {

                pChildPage = pChildPage->pParent;
            }
        }
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(Ok);
}






PCPSUIPAGE
HANDLETABLE_GetRootPage(
    PCPSUIPAGE  pCPSUIPage
    )

/*++

Routine Description:

    This function find the root page for pCPSUIPage

Arguments:

    pCPSUIPage  - Pointer to the CPSUIPAGE who's root page to be searched


Return Value:

    PCPSUIPAGE  - Pointer to root page, NULL if failed


Author:

    08-Apr-1996 Mon 12:49:42 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCPSUIPAGE  pPage;
    PCPSUIPAGE  pRootPage = NULL;


    LOCK_CPSUI_HANDLETABLE();


    pPage = pCPSUIPage;

    //
    // If we need to search for the root page, then try it now
    //

    while ((pPage) && (pPage->pParent)) {

        pPage = pPage->pParent;
    }

    if ((pPage) && (pPage->Flags & CPF_ROOT)) {

        pPage->cLock++;
        pRootPage = pPage;

    } else {

        CPSUIERR(("HANDLETABLE_FindpRootPage(%08lx): No ROOT Page found",
                    pCPSUIPage));
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(pRootPage);
}




HANDLE
HANDLETABLE_AddCPSUIPage(
    PCPSUIPAGE  pCPSUIPage
    )

/*++

Routine Description:

    This function add pData to the handle table, if new


Arguments:

    pCPSUIPage  - Pointer to the CPSUIPAGE to be add to the handle table


Return Value:

    HANDLE, if NULL then it failed, the handle already exists


Author:

    28-Dec-1995 Thu 16:03:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HANDLE      hTable;
    PDATATABLE  pDataTable;


    LOCK_CPSUI_HANDLETABLE();

    if ((!CPSUIHandleTable.pDataTable) ||
        (CPSUIHandleTable.CurCount >= CPSUIHandleTable.MaxCount)) {

        if (!CPSUIHandleTable.pDataTable) {

            CPSUIHandleTable.CurCount =
            CPSUIHandleTable.MaxCount = 0;
        }

        CPSUIDBG(DBG_ADD_DATA,
                ("HANDLETABLE_AddCPSUIPage(%08lx): Table reach LIMIT, Expanded=%ld->%ld",
                CPSUIHandleTable.pDataTable,
                CPSUIHandleTable.CurCount,
                CPSUIHandleTable.CurCount + DATATABLE_BLK_COUNT));

        //
        // Reallocate Table
        //

        if ((CPSUIHandleTable.MaxCount <= DATATABLE_MAX_COUNT)  &&
            (pDataTable = LocalAlloc(LPTR,
                                    (CPSUIHandleTable.MaxCount +
                                                DATATABLE_BLK_COUNT) *
                                                        sizeof(DATATABLE)))) {

            if (CPSUIHandleTable.pDataTable) {

                CopyMemory(pDataTable,
                           CPSUIHandleTable.pDataTable,
                           CPSUIHandleTable.MaxCount * sizeof(DATATABLE));

                LocalFree((HLOCAL)CPSUIHandleTable.pDataTable);
            }

            CPSUIHandleTable.pDataTable  = pDataTable;
            CPSUIHandleTable.MaxCount   += DATATABLE_BLK_COUNT;

        } else {

            CPSUIERR(("HANDLETABLE_AddCPSUIPage(): Expand TABLE failed"));
        }
    }

    hTable = NULL;

    if (pDataTable = CPSUIHandleTable.pDataTable) {

        WORD    Idx;

        for (Idx = 0; Idx < CPSUIHandleTable.MaxCount; Idx++, pDataTable++) {

            if (!pDataTable->pCPSUIPage) {

                hTable                 = WORD_2_HANDLE(Idx);
                pDataTable->pCPSUIPage = pCPSUIPage;
                pCPSUIPage->cLock      = 1;

                CPSUIHandleTable.CurCount++;

                CPSUIDBG(DBG_ADD_DATA, ("HANDLETABLE_AddCPSUIPage(%08lx): Idx=%ld, Cur=%ld, Max=%ld",
                            pCPSUIPage, Idx,
                            CPSUIHandleTable.CurCount,
                            CPSUIHandleTable.MaxCount));

                break;

            } else if (pDataTable->pCPSUIPage == pCPSUIPage) {

                CPSUIERR(("HANDLETABLE_AddCPSUIPage(%08lx): pCPSUIPage exists, Idx=%ld",
                            pCPSUIPage, Idx));
            }
        }
    }

    if (!hTable) {

        CPSUIERR(("HANDLETABLE_AddCPSUIPage(%08lx:%ld) Cannot find empty entry",
                CPSUIHandleTable.pDataTable,
                CPSUIHandleTable.MaxCount));
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(hTable);
}




BOOL
HANDLETABLE_DeleteHandle(
    HANDLE  hTable
    )

/*++

Routine Description:

    This function delete a handle from the handle table


Arguments:

    hTable  - Handle to the handle table to be deleted


Return Value:

    BOOL


Author:

    28-Dec-1995 Thu 17:42:42 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDATATABLE  pDataTable;
    PCPSUIPAGE  pCPSUIPage;
    WORD        Idx;
    BOOL        Ok = FALSE;


    LOCK_CPSUI_HANDLETABLE();

    if ((pDataTable = CPSUIHandleTable.pDataTable)                  &&
        (HANDLE_2_PREFIX(hTable) == HANDLE_TABLE_PREFIX)            &&
        (CPSUIHandleTable.CurCount)                                 &&
        ((Idx = HANDLE_2_IDX(hTable)) < CPSUIHandleTable.MaxCount)  &&
        (pCPSUIPage = (pDataTable += Idx)->pCPSUIPage)) {

        if (pCPSUIPage->cLock) {

            CPSUIERR(("HANDLETABLE_DeleteHandle(%08lx), pCPSUIPage=%08lx, cLock=%ld",
                        hTable, pCPSUIPage, pCPSUIPage->cLock));

        } else {

            // check to release the activation context (if any)
            if (pCPSUIPage->hActCtx && pCPSUIPage->hActCtx != INVALID_HANDLE_VALUE) {

                ReleaseActCtx(pCPSUIPage->hActCtx);
                pCPSUIPage->hActCtx = INVALID_HANDLE_VALUE;
            }

            pDataTable->pCPSUIPage = NULL;
            Ok                     = TRUE;

            //
            // Reduce current count and free the memory
            //

            CPSUIHandleTable.CurCount--;

            LocalFree((HLOCAL)pCPSUIPage);
        }

    } else {

        CPSUIERR(("HANDLETABLE_DeleteHandle(%08lx) not found, Idx=%ld, pDataTable=%08lx",
                        hTable, Idx, pDataTable));
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(Ok);
}




BOOL
HANDLETABLE_Create(
    VOID
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    28-Dec-1995 Thu 16:46:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    CPSUIHandleTable.pDataTable = NULL;
    CPSUIHandleTable.MaxCount   =
    CPSUIHandleTable.CurCount   = 0;
    CPSUIHandleTable.ThreadID   = NO_THREADID;
    CPSUIHandleTable.cWait      = 0;

    if (hCPSUIMutex = CreateMutex(NULL, FALSE, NULL)) {

        CPSUIDBG(DBG_CPSUI_HTABLE, ("CREATE: CreateMutex=%08lx", hCPSUIMutex));

        return(TRUE);

    } else {

        CPSUIERR(("CreateMutex() FAILED, Exit"));
        return(FALSE);
    }
}



VOID
HANDLETABLE_Destroy(
    VOID
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    28-Dec-1995 Thu 16:48:32 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDATATABLE  pDataTable;
    WORD        Idx;

    LOCK_CPSUI_HANDLETABLE();

    if (hCPSUIMutex) {

        if (pDataTable = CPSUIHandleTable.pDataTable) {

            for (Idx = 0;
                 Idx < CPSUIHandleTable.MaxCount;
                 Idx++, pDataTable++) {

                if (pDataTable->pCPSUIPage) {

                    CPSUIERR(("HANDLETABLE_Destroy: Idx=%ld, pPage=%08lx, cLock=%ld is not delete yet",
                                    Idx, pDataTable->pCPSUIPage, pDataTable->pCPSUIPage->cLock));

                    LocalFree((HLOCAL)pDataTable->pCPSUIPage);

                    pDataTable->pCPSUIPage = NULL;

                    if (CPSUIHandleTable.CurCount) {

                        --(CPSUIHandleTable.CurCount);

                    } else {

                        CPSUIERR(("HANDLETABLE_Destroy(): Unmatched CurCount"));
                    }
                }
            }

            LocalFree((HLOCAL)CPSUIHandleTable.pDataTable);

            CPSUIHandleTable.pDataTable = NULL;
            CPSUIHandleTable.MaxCount   =
            CPSUIHandleTable.CurCount   = 0;
        }
    }

    UNLOCK_CPSUI_HANDLETABLE();

    CloseHandle(hCPSUIMutex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\handle.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    handle.h


Abstract:

    This module contains all definitions for the handle table


Author:

    30-Jan-1996 Tue 16:30:15 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/


#ifndef CPSUI_HANDLE
#define CPSUI_HANDLE



#define HANDLE_TABLE_ID         (DWORD)0x436e6144
#define HANDLE_TABLE_PREFIX     (WORD)0x4344
#define MAX_HANDLE_TABLE_IDX    0xFFFF
#define HANDLE_2_IDX(h)         LOWORD((DWORD)((ULONG_PTR)(h) & 0xFFFFFFFF))
#define HANDLE_2_PREFIX(h)      HIWORD((DWORD)((ULONG_PTR)(h) & 0xFFFFFFFF))
#define WORD_2_HANDLE(w)        LongToHandle(MAKELONG((w), HANDLE_TABLE_PREFIX))

#define DATATABLE_BLK_COUNT     64
#define DATATABLE_MAX_COUNT     (MAX_HANDLE_TABLE_IDX - DATATABLE_BLK_COUNT)
#define NO_THREADID             0xFFFFFFFF
#define MAX_SEM_WAIT            60000

typedef struct _DATATABLE {
    PCPSUIPAGE  pCPSUIPage;
    } DATATABLE, *PDATATABLE;

typedef struct _CPSUIHANDLETABLE {
    PDATATABLE  pDataTable;
    WORD        MaxCount;
    WORD        CurCount;
    DWORD       ThreadID;
    DWORD       cWait;
    } CPSUIHANDLETABLE, *PCPSUIHANDLETABLE;

#define MK_TLSVALUE(cWait, Idx) (DWORD)MAKELONG(cWait, Idx)
#define TLSVALUE_2_IDX(v)       HIWORD(LODWORD(v))
#define TLSVALUE_2_CWAIT(v)     LOWORD(LODWORD(v))

//
// Function Prototypes
//

BOOL
LOCK_CPSUI_HANDLETABLE(
    VOID
    );

BOOL
UNLOCK_CPSUI_HANDLETABLE(
    VOID
    );

PCPSUIPAGE
HANDLETABLE_GetCPSUIPage(
    HANDLE      hTable
    );

BOOL
HANDLETABLE_UnGetCPSUIPage(
    PCPSUIPAGE  pCPSUIPage
    );

DWORD
HANDLETABLE_LockCPSUIPage(
    PCPSUIPAGE  pCPSUIPage
    );

#define HANDLETABLE_UnLockCPSUIPage     HANDLETABLE_UnGetCPSUIPage

BOOL
HANDLETABLE_IsChildPage(
    PCPSUIPAGE  pChildPage,
    PCPSUIPAGE  pParentPage
    );

PCPSUIPAGE
HANDLETABLE_GetRootPage(
    PCPSUIPAGE  pCPSUIPage
    );

HANDLE
HANDLETABLE_AddCPSUIPage(
    PCPSUIPAGE  pCPSUIPage
    );

BOOL
HANDLETABLE_DeleteHandle(
    HANDLE  hTable
    );

BOOL
HANDLETABLE_Create(
    VOID
    );

VOID
HANDLETABLE_Destroy(
    VOID
    );


#endif  // CPSUI_HANDLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\help.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    help.h


Abstract:

    This module contains the prototype for the help.c


Author:

    28-Aug-1995 Mon 15:31:32 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/


#define IDH_STD_TVROOT          10000
#define IDH_DOCPROP_TVROOT      10010
#define IDH_ADVDOCPROP_TVROOT   10020
#define IDH_DEVPROP_TVROOT      10030
#define IDH_PAPEROUTPUT         10040
#define IDH_GRAPHIC             10050
#define IDH_OPTIONS             10060
#define IDH_ICMHDR              10070
#define IDH_ADVANCED_PUSH       10080


#define IDH_ORIENTATION         11000
#define IDH_SCALING             11010
#define IDH_NUM_OF_COPIES       11020
#define IDH_SOURCE              11030
#define IDH_RESOLUTION          11040
#define IDH_COLOR_APPERANCE     11050
#define IDH_DUPLEX              11060
#define IDH_TTOPTION            11070
#define IDH_FORMNAME            11080
#define IDH_ICMMETHOD           11090
#define IDH_ICMINTENT           11100
#define IDH_MEDIA               11110
#define IDH_DITHERING           11120
#define IDH_HT_SETUP            11130
#define IDH_HT_CLRADJ           11140
#define IDH_PAGEORDER           11150
#define IDH_NUP                 11160
#define IDH_OUTPUTBIN           11170
#define IDH_QUALITY             11180


BOOL
CommonPropSheetUIHelp(
    HWND        hDlg,
    PTVWND      pTVWnd,
    HWND        hWndHelp,
    DWORD       MousePos,
    POPTITEM    pItem,
    UINT        HelpCmd
    );

VOID
CommonPropSheetUIHelpSetup(
    HWND    hDlg,
    PTVWND  pTVWnd
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\help.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    help.c


Abstract:

    This module contains function when user hit help button or F1


Author:

    28-Aug-1995 Mon 14:55:07 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop



#define DBG_CPSUIFILENAME   DbgHelp


#define DBG_HELP_MSGBOX     0x00000001


DEFINE_DBGVAR(0);


extern  HINSTANCE   hInstDLL;

WCHAR   CPSUIHelpFile[] = L"compstui.hlp";

#define MAX_HELPFILE_SIZE       300
#define TMP_HELP_WND_ID         0x7fff


#if DBG


INT
HelpMsgBox(
    HWND        hDlg,
    PTVWND      pTVWnd,
    LPTSTR      pHelpFile,
    POPTITEM    pItem,
    UINT        HelpIdx
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    26-Sep-1995 Tue 13:20:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    UINT    Count;
    UINT    Style;
    GSBUF_DEF(pItem, 360);


    if (DbgHelp & DBG_HELP_MSGBOX) {

        if (pHelpFile) {

            Style = MB_ICONINFORMATION | MB_OKCANCEL;
            GSBUF_GETSTR(L"HelpFile=");
            GSBUF_GETSTR(pHelpFile);
            GSBUF_GETSTR(L"\nOption=");

        } else {

            GSBUF_GETSTR(L"HelpFile= -None-\nOption=");
            Style = MB_ICONSTOP | MB_OK;
        }

        if ((pItem) && (HelpIdx)) {

            GSBUF_GETSTR(pItem->pName);
            GSBUF_GETSTR(L"HelpIdx=");
            GSBUF_ADDNUM(HelpIdx, FALSE);

        } else {

            GSBUF_GETSTR(L"<NONE, General Help>");
        }

        return(MessageBox(hDlg,
                          GSBUF_BUF,
                          TEXT("DBG: Common Property Sheet UI"),
                          Style));

    } else {

        return(TRUE);
    }
}

#endif




BOOL
CommonPropSheetUIHelp(
    HWND        hDlg,
    PTVWND      pTVWnd,
    HWND        hWndHelp,
    DWORD       MousePos,
    POPTITEM    pItem,
    UINT        HelpCmd
    )

/*++

Routine Description:

    This function initialize/display/end the plotter help system


Arguments:

    hDlg        - Handle to the dialog box need help

    pTVWnd      - Our instance data

    hWndHelp    - the window cause the context help

    MousePos    - Mouse position where the right click happened
                  x=LOWORD(MousePos), y=HIWORD(MousePos)

    pItem       - Pointer to the OPTITEM for the context help

    HelpCmd     - Help type


Return Value:

    VOID


Author:

    28-Aug-1995 Mon 15:24:27 updated  -by-  Daniel Chou (danielc)w


Revision History:


--*/

{
    LPWSTR      pHelpFile = NULL;
    DWORD       HelpIdx;
    BOOL        Ok = FALSE;
    GSBUF_DEF(pItem, MAX_HELPFILE_SIZE);



    if (pItem) {

        if (HelpIdx = (DWORD)_OI_HELPIDX(pItem)) {

            if (!LoadString(hInstDLL,
                            IDS_INT_CPSUI_HELPFILE,
                            pHelpFile = GSBUF_BUF,
                            MAX_HELPFILE_SIZE)) {

                pHelpFile = CPSUIHelpFile;
            }

        } else if (GSBUF_GETSTR(_OI_PHELPFILE(pItem))) {

            pHelpFile = GSBUF_BUF;
            HelpIdx   = pItem->HelpIndex;
        }
    }

    if ((!pHelpFile) &&
        (GSBUF_GETSTR(pTVWnd->ComPropSheetUI.pHelpFile))) {

        pHelpFile = GSBUF_BUF;
        HelpIdx   = 0;
    }

    /*
     *   Quite easy - simply call the WinHelp function with the parameters
     * supplied to us.  If this fails,  then put up a stock dialog box.
     *   BUT the first time we figure out what the file name is.  We know
     * the actual name,  but we don't know where it is located, so we
     * need to call the spooler for that information.
     */

    if (pHelpFile) {

        HWND        hWndTmp;
        POINT       pt;
        DWORD       HelpID[4];
        ULONG_PTR   Data;


        CPSUIDBGBLK(
        {
            if (HelpMsgBox(hDlg,
                           pTVWnd,
                           pHelpFile,
                           pItem,
                           HelpIdx) == IDCANCEL) {

                return(TRUE);
            }
        })

        //
        // Try to pop-up help on the right click position, where we will create
        // a temp button window and do the help, this way we can do context
        // sensitive help on any type of window (static, icon) and even it is
        // disabled.  We need to destroy this temp window before we exit from
        // this fucntion
        //

        pt.x = LOWORD(MousePos);
        pt.y = HIWORD(MousePos);

        ScreenToClient(hDlg, &pt);

        if (hWndTmp = CreateWindowEx(WS_EX_NOPARENTNOTIFY | WS_EX_CONTEXTHELP,
                                     L"button",
                                     L"",
                                     WS_CHILD | BS_CHECKBOX,
                                     pt.x,
                                     pt.y,
                                     1,
                                     1,
                                     hDlg,
                                     (HMENU)TMP_HELP_WND_ID,
                                     hInstDLL,
                                     0)) {

            hWndHelp = hWndTmp;

        } else {

            CPSUIERR(("CommonPropSheetUIHelp: Create temp. help window failed"));
        }

        HelpID[0] = (hWndHelp) ? (DWORD)GetWindowLongPtr(hWndHelp, GWLP_ID) : 0;
        HelpID[1] = HelpIdx;
        HelpID[2] =
        HelpID[3] = 0;

        switch (HelpCmd) {

        case HELP_WM_HELP:

            if ((!HelpID[0]) || (!HelpID[1])) {

                HelpCmd  = HELP_CONTENTS;
                hWndHelp = hDlg;
                Data     = 0;
                break;
            }

        case HELP_CONTEXTMENU:

            SetWindowContextHelpId(hWndHelp, HelpID[1]);
            Data = (ULONG_PTR)&HelpID[0];
            break;

        case HELP_CONTEXT:
        case HELP_CONTEXTPOPUP:

            Data = (ULONG_PTR)HelpID[1];
            break;

        default:

            Data = 0;
            break;
        }

        CPSUIINT(("Help: hWnd=%08lx, Cmd=%ld, ID=[%ld, %ld]",
                        hWndHelp, HelpCmd, HelpID[0], HelpID[1]));

        Ok = WinHelp(hWndHelp, pHelpFile, HelpCmd, Data);

        if (hWndTmp) {

            DestroyWindow(hWndTmp);
        }

    } else {

        CPSUIDBGBLK({ HelpMsgBox(hDlg, pTVWnd, NULL, pItem, HelpIdx); })
    }

    return(Ok);
}




VOID
CommonPropSheetUIHelpSetup(
    HWND    hDlg,
    PTVWND  pTVWnd
    )

/*++

Routine Description:

    This function will setup or remove the plotter UI help system


Arguments:

    hDlg    - Handle to the dialog interested, if hDlg != NULL then it will
              quit the help

    pTVWnd  - Pointer to the instance data for the common UI


Return Value:

    VOID


Author:

    28-Aug-1995 Mon 15:21:20 updated  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#if 0
    GSBUF_DEF(MAX_HELPFILE_SIZE);


    if ((hDlg) &&
        (GSBUF_GETSTR(pTVWnd->ComPropSheetUI.pHelpFile))) {

        WinHelp(hDlg, GSBUF_BUF, HELP_QUIT, 0);
    }
#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\image.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    image.c


Abstract:

    This module contains all the function to manuplate the image list


Author:

    06-Jul-1995 Thu 17:10:40 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop


#define DBG_CPSUIFILENAME   DbgImage


#define DBG_CTVICON         0x00000001
#define DBG_SETTVICON       0x00000002
#define DBG_CIL             0x00000004
#define DBG_GETICON16IDX    0x00000008
#define DBG_REALLOC         0x00000010
#define DBG_MTVICON         0x00000020
#define DBG_SAVEICON        0x00000040
#define DBG_ICONCHKSUM      0x00000080
#define DBG_FIRST_ICON      0x00000100
#define DBG_CREATEIL        0x00000200
#define DBG_CYICON          0x00000400

DEFINE_DBGVAR(0);


#define BFT_ICON            0x4349   /* 'IC' */
#define BFT_BITMAP          0x4d42   /* 'BM' */
#define BFT_CURSOR          0x5450   /* 'PT' */

#define ISDIB(bft)          ((bft) == BFT_BITMAP)


extern HINSTANCE    hInstDLL;
extern OPTTYPE      OptTypeNone;

#if 0

typedef struct _BMIGRAY {
    BITMAPINFOHEADER    bmh;
    RGBQUAD             rgbq[2];
    DWORD               Bits[8];
    } BMIGRAY, *PBMIGRAY;


static BMIGRAY  bmiGray = {

        { sizeof(BITMAPINFOHEADER), 32, 8, 1, 1, BI_RGB, 0, 0, 0, 2, 2 },

        {
            { 0x00, 0x00, 0x00, 0 },
            { 0xFF, 0xFF, 0xFF, 0 }
        },

        { 0x55555555, 0xaaaaaaaa, 0x55555555, 0xaaaaaaaa,
          0x55555555, 0xaaaaaaaa, 0x55555555, 0xaaaaaaaa }
    };

#endif

#if DBG
#define DBG_SAVE_ICON_BMP   0
#else
#define DBG_SAVE_ICON_BMP   0
#endif


#if DBG_SAVE_ICON_BMP

#define SBTF_NAME       0
#define SBTF_MASK       -1
#define SBTF_CLR        -2


HANDLE
BMPToDIB(
    HBITMAP     hBitmap
    )
{
    HANDLE          hDIB = NULL;
    LPBITMAPINFO    pbi;
    HDC             hDC;
    BITMAP          Bmp;
    DWORD           BIMode;
    DWORD           Colors;
    DWORD           SizeH;
    DWORD           SizeI;


    GetObject(hBitmap, sizeof(BITMAP), &Bmp);

    if (Bmp.bmPlanes == 1) {

        switch(Bmp.bmBitsPixel) {

        case 1:
        case 4:
        case 8:

            BIMode = BI_RGB;
            Colors = (DWORD)(1L << Bmp.bmBitsPixel);
            break;

        case 16:

            BIMode = BI_BITFIELDS;
            Colors = 3;
            break;

        case 24:

            BIMode = BI_RGB;
            Colors = 0;
            break;

        default:

            return(NULL);
        }

        SizeH  = (DWORD)sizeof(BITMAPINFOHEADER) +
                 (DWORD)(Colors * sizeof(RGBQUAD));
        SizeI  = (DWORD)ALIGN_DW(Bmp.bmWidth, Bmp.bmBitsPixel) *
                 (DWORD)Bmp.bmHeight;

        if (hDIB = GlobalAlloc(GHND, (SizeH + SizeI))) {

            pbi = GlobalLock(hDIB);

            pbi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
            pbi->bmiHeader.biWidth         = Bmp.bmWidth;
            pbi->bmiHeader.biHeight        = Bmp.bmHeight;
            pbi->bmiHeader.biPlanes        = 1;
            pbi->bmiHeader.biBitCount      = Bmp.bmBitsPixel;
            pbi->bmiHeader.biCompression   = BIMode;
            pbi->bmiHeader.biSizeImage     = SizeI;
            pbi->bmiHeader.biXPelsPerMeter = 0;
            pbi->bmiHeader.biYPelsPerMeter = 0;

            hDC = GetDC(NULL);

            GetDIBits(hDC,
                      hBitmap,
                      0,
                      Bmp.bmHeight,
                      (LPBYTE)pbi + SizeH,
                      pbi,
                      DIB_RGB_COLORS);

            pbi->bmiHeader.biClrUsed       =
            pbi->bmiHeader.biClrImportant  = Colors;

            GlobalUnlock(hDIB);
            ReleaseDC(NULL, hDC);
        }
    }

    return(hDIB);

}



BOOL
SaveBmpToFile(
    HBITMAP hBmp,
    LPVOID  pIconID,
    INT     Mode
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    20-Sep-1995 Wed 22:58:10 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HANDLE              hDIB;
    HANDLE              hFile;
    BITMAPFILEHEADER    bfh;
    DWORD               cbWritten;
    BOOL                Ok = FALSE;
    WCHAR               Buf[80];
    UINT                Count;


    if (!(DBG_CPSUIFILENAME & DBG_SAVEICON)) {

        return(TRUE);
    }

    Count = wsprintf(Buf, L"d:/IconDIB/");

    switch(Mode) {

    case SBTF_NAME:

        wnsprintf(&Buf[Count], ARRAYSIZE(Buf) - Count - 1, L"%hs.dib", (LPTSTR)pIconID);
        break;

    case SBTF_MASK:
    case SBTF_CLR:

        wsprintf(&Buf[Count], L"%lu%s.dib",
                (DWORD)pIconID, (Mode == SBTF_MASK) ? L"Msk" : L"Clr");
        break;

    default:

        wsprintf(&Buf[Count], L"_%lu.dib", (DWORD)Mode);
        break;
    }

    if ((hDIB = BMPToDIB(hBmp)) &&
        ((hFile = CreateFile(Buf,
                             GENERIC_WRITE,
                             0,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_FLAG_WRITE_THROUGH,
                             NULL)) != INVALID_HANDLE_VALUE)) {

        LPBITMAPINFOHEADER  pbih;
        DWORD               HeaderSize;


        pbih       = (LPBITMAPINFOHEADER)GlobalLock(hDIB);
        HeaderSize = PBIH_HDR_SIZE(pbih);

        bfh.bfType      = (WORD)BFT_BITMAP;
        bfh.bfOffBits   = (DWORD)sizeof(bfh) + HeaderSize;
        bfh.bfSize      = bfh.bfOffBits + pbih->biSizeImage;
        bfh.bfReserved1 =
        bfh.bfReserved2 = (WORD)0;

        WriteFile(hFile,
                  &bfh,
                  sizeof(bfh),
                  &cbWritten,
                  NULL);

        WriteFile(hFile,
                  pbih,
                  pbih->biSizeImage + HeaderSize,
                  &cbWritten,
                  NULL);

        CloseHandle(hFile);

        GlobalUnlock(hDIB);
        Ok = TRUE;
    }

    if (hDIB) {

        hDIB = GlobalFree(hDIB);
    }

    return(Ok);
}

VOID
SaveIconToFile(
    HICON   hIcon,
    DWORD   IconID
    )
{

    if (hIcon) {

        ICONINFO    IconInfo;


        GetIconInfo(hIcon, &IconInfo);

        SaveBmpToFile(IconInfo.hbmMask,  (LPVOID)IconID, SBTF_MASK);
        SaveBmpToFile(IconInfo.hbmColor, (LPVOID)IconID, SBTF_CLR);

        DeleteObject(IconInfo.hbmMask);
        DeleteObject(IconInfo.hbmColor);
    }
}

#endif  // DBG_SAVE_ICON_BMP

#if 0


HBRUSH
CreateGrayBrush(
    COLORREF    Color
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-Oct-1995 Fri 12:58:15 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HBRUSH      hBrush = NULL;
    HGLOBAL     hGlobal;


    if (hGlobal = GlobalAlloc(GMEM_FIXED, sizeof(BMIGRAY))) {

        PBMIGRAY    pbmiGray;


        CopyMemory(pbmiGray = (PBMIGRAY)GlobalLock(hGlobal),
                   &bmiGray,
                   sizeof(BMIGRAY));

        pbmiGray->rgbq[1].rgbRed   = GetRValue(Color);
        pbmiGray->rgbq[1].rgbGreen = GetGValue(Color);
        pbmiGray->rgbq[1].rgbBlue  = GetBValue(Color);

        GlobalUnlock(hGlobal);

        if (!(hBrush = CreateDIBPatternBrush(hGlobal, DIB_RGB_COLORS))) {

            GlobalFree(hGlobal);
        }
    }

    return(hBrush);
}




VOID
DestroyGrayBrush(
    HBRUSH  hBrush
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-Oct-1995 Fri 13:21:40 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LOGBRUSH    LogBrush;


    if (hBrush) {

        if ((GetObject(hBrush, sizeof(LOGBRUSH), &LogBrush))    &&
            (LogBrush.lbStyle == BS_DIBPATTERN)) {

            GlobalFree((HGLOBAL)LogBrush.lbHatch);
        }

        DeleteObject(hBrush);
    }
}

#endif


HICON
MergeIcon(
    HINSTANCE   hInst,
    ULONG_PTR    IconResID,
    DWORD       IntIconID,
    UINT        cxIcon,
    UINT        cyIcon
    )

/*++

Routine Description:

    This function load the IconResID and stretch it to the cxIcon/cyIcon size
    and optional merge the HIWORD(IntIconID) (32x32) in the position of
    IconRes1D's (0, 0)


Arguments:

    hInst       - Instance handle for the IconResID

    IconResID   - Icon ID for the first Icon

    IntIconID   - LOWORD(IntIconID) = the internal icon id if IconID is not
                                      avaliable
                  HIWORD(IntIconID) = MIM_xxxx merge icon mode ID

    cxIcon      - cx size of the icon want to create

    cyIcon      - cy size of the icon want to create


Return Value:

    HICON,  the newly created and/or merged icon handle, NULL if failed, the
    caller must do DestroyIcon() after using it if it is not NULL.


Author:

    15-Aug-1995 Tue 13:27:34 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HICON       hIcon1;
    HICON       hIcon2;
    HICON       hIconMerge;
    HICON       hIcon1Caller;
    HDC         hDCScreen;
    HDC         hDCDst;
    HGDIOBJ     hOldDst = NULL;
    BITMAP      Bitmap;
    WORD        MergeIconMode;
    WORD        IconID;
    WORD        IconIDSet[MIM_MAX_OVERLAY + 2];
    UINT        IdxIconID;
    ICONINFO    IconInfo1;


    hIcon1Caller = NULL;

    if (VALID_PTR(IconResID)) {

        if ((hIcon1 = GET_HICON(IconResID)) &&
            (GetIconInfo(hIcon1, &IconInfo1))) {

            hIcon1Caller = hIcon1;
            IconID       = 0xFFFF;
            IconResID    = 0xFFFF;

        } else {

            CPSUIERR(("MergeIcon: Passed Invalid hIcon=%08lx,", hIcon1));

            hIcon1 = NULL;
        }

    } else {

        hIcon1 = NULL;
    }

    if (!hIcon1) {

        IconIDSet[0] = GET_INTICONID(IntIconID);
        IconIDSet[1] = LOWORD(IconResID);
        IdxIconID    = 2;

        while ((!hIcon1) && (IdxIconID--)) {

            if (IconID = IconIDSet[IdxIconID]) {

                hIcon1 = GETICON_SIZE(hInst, IconID, cxIcon, cyIcon);
            }
        }
    }

    if ((hIcon1) &&
        ((hIcon1Caller) || (GetIconInfo(hIcon1, &IconInfo1)))) {

        GetObject(IconInfo1.hbmMask, sizeof(BITMAP), &Bitmap);

        if ((hIcon1 == hIcon1Caller)            ||
            (Bitmap.bmWidth != (LONG)cxIcon)    ||
            (Bitmap.bmHeight != (LONG)cyIcon)) {

            CPSUIINT(("MergeIcon: hIcon1=%ld x %ld, Change to %u x %u",
                        Bitmap.bmWidth, Bitmap.bmHeight, cxIcon, cyIcon));

            hIcon1 = CopyImage(hIcon2 = hIcon1, IMAGE_ICON, cxIcon, cyIcon, 0);

            //
            // Destroy Original Icon only if hIcon1 is not from the caller
            //

            if (hIcon1Caller != hIcon2) {

                DestroyIcon(hIcon2);
            }
        }

    } else {

        CPSUIERR(("MergeIcon: FAILED hIcon1=%08lx,", hIcon1));
    }

#if DBG_SAVE_ICON_BMP
    SaveIconToFile(hIcon1, IconID);
#endif

    if (!(MergeIconMode = GET_MERGEICONID(IntIconID))) {

        //
        // Nothing to be merged so just return the hIcon1, we do not need the
        // IconInfo1 information, so destroy the object before return
        //

        if (IconInfo1.hbmMask)
        {
            DeleteObject(IconInfo1.hbmMask);
        }

        if (IconInfo1.hbmColor)
        {
            DeleteObject(IconInfo1.hbmColor);
        }

        return(hIcon1);
    }


    IconIDSet[0] = (MergeIconMode & MIM_WARNING_OVERLAY) ?
                                                IDI_CPSUI_WARNING_OVERLAY : 0;
    IconIDSet[1] = (MergeIconMode & MIM_NO_OVERLAY) ? IDI_CPSUI_NO : 0;
    IconIDSet[2] = (MergeIconMode & MIM_STOP_OVERLAY) ? IDI_CPSUI_STOP : 0;
    IdxIconID    = 3;

    //
    // Start creating the new icon, the IconInfo1 is the cx/cy Icon size
    // padded in and the IconInfo2 is the standard 32x32 icon
    //

    hDCDst  = CreateCompatibleDC(hDCScreen = GetDC(NULL));

    if (hIcon1) {

        hOldDst = SelectObject(hDCDst, IconInfo1.hbmMask);
    }

    SetStretchBltMode(hDCDst, BLACKONWHITE);

    while (IdxIconID--) {

        if ((IconID = IconIDSet[IdxIconID]) &&
            (hIcon2 = GETICON_SIZE(hInst, IconID, cxIcon, cyIcon))) {

#if DBG_SAVE_ICON_BMP
            SaveIconToFile(hIcon2, IconID);
#endif
            if (hIcon1) {

                HDC         hDCSrc;
                HGDIOBJ     hOldSrc;
                ICONINFO    IconInfo2;

                hDCSrc = CreateCompatibleDC(hDCScreen);
                GetIconInfo(hIcon2, &IconInfo2);

                hOldSrc = SelectObject(hDCSrc, IconInfo2.hbmMask);
                SelectObject(hDCDst, IconInfo1.hbmMask);

                StretchBlt(hDCDst,
                           0,
                           0,
                           cxIcon,
                           cyIcon,
                           hDCSrc,
                           0,
                           0,
                           cxIcon,
                           cyIcon,
                           SRCAND);

                //
                // clear the hIcon1's XOR color to leave room for the hIcon2
                //

                SelectObject(hDCDst, IconInfo1.hbmColor);
                StretchBlt(hDCDst,
                           0,
                           0,
                           cxIcon,
                           cyIcon,
                           hDCSrc,
                           0,
                           0,
                           cxIcon,
                           cyIcon,
                           SRCAND);

                //
                // Now add in the hIcon2's XOR color to the the hIcon1
                //

                SelectObject(hDCSrc, IconInfo2.hbmColor);
                StretchBlt(hDCDst,
                           0,
                           0,
                           cxIcon,
                           cyIcon,
                           hDCSrc,
                           0,
                           0,
                           cxIcon,
                           cyIcon,
                           SRCPAINT);

                //
                // de-select everything from the DC before the create/delete
                //

                SelectObject(hDCSrc, hOldSrc);
                DeleteDC(hDCSrc);
                DeleteObject(IconInfo2.hbmMask);
                DeleteObject(IconInfo2.hbmColor);
                DestroyIcon(hIcon2);

            } else {

                GetIconInfo(hIcon2, &IconInfo1);
                GetObject(IconInfo1.hbmMask, sizeof(BITMAP), &Bitmap);

                if ((Bitmap.bmWidth != (LONG)cxIcon) ||
                    (Bitmap.bmHeight != (LONG)cyIcon)) {

                    CPSUIINT(("MergeIcon: hIcon1=%ld x %ld, Change to %u x %u",
                                Bitmap.bmWidth, Bitmap.bmHeight, cxIcon, cyIcon));

                    hIcon1 = CopyImage(hIcon2, IMAGE_ICON, cxIcon, cyIcon, 0);

                    DeleteObject(IconInfo1.hbmMask);
                    DeleteObject(IconInfo1.hbmColor);
                    DestroyIcon(hIcon2);
                    GetIconInfo(hIcon1, &IconInfo1);

                } else {

                    hIcon1 = hIcon2;
                }

                hOldDst = SelectObject(hDCDst, IconInfo1.hbmMask);
            }
        }
    }

    if (hOldDst) {

        SelectObject(hDCDst, hOldDst);
    }

    //
    // Create New Icon
    //

    if (hIcon1) {

        hIconMerge = CreateIconIndirect(&IconInfo1);

#if DBG_SAVE_ICON_BMP
        SaveBmpToFile(IconInfo1.hbmMask,  (LPVOID)"FinalMsk", SBTF_NAME);
        SaveBmpToFile(IconInfo1.hbmColor, (LPVOID)"FinalClr", SBTF_NAME);
        SaveIconToFile(hIconMerge, 0);
#endif
        //
        // Now Delete what we created
        //

        DeleteObject(IconInfo1.hbmMask);
        DeleteObject(IconInfo1.hbmColor);
        DestroyIcon(hIcon1);

    } else {

        hIconMerge = NULL;
    }

    DeleteDC(hDCDst);
    ReleaseDC(NULL, hDCScreen);

    return(hIconMerge);
}




DWORD
GethIconChecksum(
    HICON   hIcon
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    15-Aug-1995 Tue 13:27:34 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    ICONINFO    IconInfo;
    HBITMAP     *phBitmap;
    UINT        chBitmap;
    DWORD       Checksum = 0xFFFFFFFF;

    memset(&IconInfo, 0, sizeof(IconInfo));
    if (GetIconInfo(hIcon, &IconInfo)) {

        phBitmap = &(IconInfo.hbmMask);
        Checksum = 0xDC00DCFF;
        chBitmap = 2;

        while (chBitmap--) {

            LPDWORD pdw;
            LPBYTE  pAllocMem;
            BITMAP  BmpInfo;
            DWORD   Count;

            GetObject(*phBitmap, sizeof(BITMAP), &BmpInfo);

            CPSUIDBG(DBG_ICONCHKSUM, ("hBitmap=%ld x %ld, Plane=%ld, bpp=%ld",
                        BmpInfo.bmWidth,  BmpInfo.bmHeight,
                        BmpInfo.bmPlanes, BmpInfo.bmBitsPixel));

            pdw   = (LPDWORD)&BmpInfo;
            Count = (DWORD)(sizeof(BITMAP) >> 2);

            while (Count--) {

                Checksum += *pdw++;
            }

            Count = (DWORD)(BmpInfo.bmWidthBytes * BmpInfo.bmHeight);

            if (pAllocMem = (LPBYTE)LocalAlloc(LPTR, Count)) {

                CPSUIDBG(DBG_ICONCHKSUM, ("hBitmap: Alloc(pBitmap)=%ld bytes", Count));

                pdw = (LPDWORD)pAllocMem;

                if (Count = (DWORD)GetBitmapBits(*phBitmap, Count, pAllocMem)) {

                    Count >>= 2;

                    while (Count--) {

                        Checksum += *pdw++;
                    }
                }

                LocalFree((HLOCAL)pAllocMem);
            }

            phBitmap++;
        }

        if (!HIWORD(Checksum)) {

            Checksum = MAKELONG(Checksum, 0xFFFF);
        }

        CPSUIDBG(DBG_ICONCHKSUM, ("GethIconChecksum(%08lx)=%08lx", hIcon, Checksum));

    } else {

        CPSUIERR(("GethIconChecksum(%08lx): Passed invalid hIcon", hIcon));
    }

    if (IconInfo.hbmMask)
    {
        DeleteObject(IconInfo.hbmMask);
    }

    if (IconInfo.hbmColor)
    {
        DeleteObject(IconInfo.hbmColor);
    }

    return(Checksum);
}



HICON
CreateTVIcon(
    PTVWND  pTVWnd,
    HICON   hIcon,
    UINT    IconYOff
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    15-Aug-1995 Tue 13:27:34 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HICON       hIconNew = NULL;
    HDC         hDCScr;
    HDC         hDCSrc;
    HDC         hDCDst;
    HBITMAP     hOldSrc;
    HBITMAP     hOldDst;
    ICONINFO    IconInfo;
    ICONINFO    IconNew;
    BITMAP      BmpInfo;
    UINT        cyImage;

    hDCScr   = GetDC(NULL);
    if (hDCScr)
    {
        hDCSrc   = CreateCompatibleDC(hDCScr);
        hDCDst   = CreateCompatibleDC(hDCScr);
        ReleaseDC(NULL, hDCScr);

        if (hDCSrc && hDCDst)
        {
            cyImage  = (UINT)pTVWnd->cyImage;

            if (!IconYOff) {

                IconYOff = (UINT)((cyImage - CYICON) >> 1);
            }

            GetIconInfo(hIcon, &IconInfo);
            GetObject(IconInfo.hbmMask, sizeof(BITMAP), &BmpInfo);

            CPSUIDBG(DBG_CYICON | DBG_CTVICON, ("Mask=%ld x %ld, Plane=%ld, bpp=%ld",
                        BmpInfo.bmWidth, BmpInfo.bmHeight,
                        BmpInfo.bmPlanes, BmpInfo.bmBitsPixel));

            IconNew.fIcon    = TRUE;
            IconNew.xHotspot = IconInfo.xHotspot + 1;
            IconNew.yHotspot = IconInfo.yHotspot + 1;
            IconNew.hbmMask  = CreateBitmap(CXIMAGE,
                                            cyImage,
                                            BmpInfo.bmPlanes,
                                            BmpInfo.bmBitsPixel,
                                            NULL);

            GetObject(IconInfo.hbmColor, sizeof(BITMAP), &BmpInfo);

            CPSUIDBG(DBG_CTVICON, ("Color=%ld x %ld, Plane=%ld, bpp=%ld",
                        BmpInfo.bmWidth, BmpInfo.bmHeight,
                        BmpInfo.bmPlanes, BmpInfo.bmBitsPixel));

            IconNew.hbmColor = CreateBitmap(CXIMAGE,
                                            cyImage,
                                            BmpInfo.bmPlanes,
                                            BmpInfo.bmBitsPixel,
                                            NULL);

            SetStretchBltMode(hDCDst, BLACKONWHITE);

            //
            // Stretch the Mask bitmap
            //

            hOldSrc = SelectObject(hDCSrc, IconInfo.hbmMask);
            hOldDst = SelectObject(hDCDst, IconNew.hbmMask);

            CPSUIDBG(DBG_CYICON, ("bm=%ldx%ld, cyImage=%ld, IconYOff=%ld",
                            BmpInfo.bmWidth,  BmpInfo.bmHeight, cyImage, IconYOff));

            BitBlt(hDCDst, 0, 0, CXIMAGE, cyImage, NULL, 0, 0, WHITENESS);

            StretchBlt(hDCDst,
                       ICON_X_OFF,
                       IconYOff,
                       CXICON,
                       CYICON,
                       hDCSrc,
                       0,
                       0,
                       BmpInfo.bmWidth,
                       BmpInfo.bmHeight,
                       SRCCOPY);

            //
            // Stretch the color bitmap
            //

            SelectObject(hDCSrc, IconInfo.hbmColor);
            SelectObject(hDCDst, IconNew.hbmColor);

            BitBlt(hDCDst, 0, 0, CXIMAGE, cyImage, NULL, 0, 0, BLACKNESS);

            StretchBlt(hDCDst,
                       ICON_X_OFF,
                       IconYOff,
                       CXICON,
                       CYICON,
                       hDCSrc,
                       0,
                       0,
                       BmpInfo.bmWidth,
                       BmpInfo.bmHeight,
                       SRCCOPY);

            //
            // Deleselect everything from the DC
            //

            SelectObject(hDCSrc, hOldSrc);
            SelectObject(hDCDst, hOldDst);

            //
            // Create New Icon
            //

            hIconNew = CreateIconIndirect(&IconNew);

            //
            // Now Delete what we created
            //

            DeleteObject(IconInfo.hbmMask);
            DeleteObject(IconInfo.hbmColor);
            DeleteObject(IconNew.hbmMask);
            DeleteObject(IconNew.hbmColor);
        }

        if (hDCSrc)
        {
            DeleteDC(hDCSrc);
        }

        if (hDCDst)
        {
            DeleteDC(hDCDst);
        }
    }

    return(hIconNew);
}



HICON
SetIcon(
    HINSTANCE   hInst,
    HWND        hCtrl,
    ULONG_PTR    IconResID,
    DWORD       IntIconID,
    UINT        cxcyIcon
    )

/*++

Routine Description:

    This function set the large icon on the bottom of the treeview change
    window


Arguments:

    hInst       - Handle to the instance which load the IconResID

    hCtrl       - Handle to the Icon control window to set the icon

    IconResID   - Caller's IconResID, it the high word is not zero then it
                  it assume it is a Icon handle, and if high word is 0xffff
                  then it assume the low word is the icon handle

    IntIconID   - LOWORD(IntIconID) = compstui Internal icon ID to be used if
                                      the IconResID is not available

                  HIWORD(IntIconID) = compstui Internal icon ID to be use to
                                      overlay on top of the IconResID


    cxcyIcon    - Icon cx, cy size


Return Value:

    HICON handle to the icon which set to the bottom of the change window


Author:

    01-Aug-1995 Tue 11:12:13 created  -by-  Daniel Chou (danielc)

    05-Oct-1995 Thu 13:53:21 updated  -by-  Daniel Chou (danielc)
        Updated to accomdate the 32-bit icon handle

    11-Oct-1995 Wed 19:45:23 updated  -by-  Daniel Chou (danielc)
        Make it generic icon setter


Revision History:


--*/

{
    HICON   hIcon;
    HICON   hIconOld;

    CPSUIINT(("SetIcon: IconResID=%08lx, IntIconID=%u:%u, cyxyIcon=%u",
            IconResID, LOWORD(IntIconID), HIWORD(IntIconID), cxcyIcon));

    hIcon = MergeIcon(hInst, IconResID, IntIconID, cxcyIcon, cxcyIcon);

    if (hIconOld = (HICON)SendMessage(hCtrl,
                                      STM_SETIMAGE,
                                      (WPARAM)IMAGE_ICON,
                                      (LPARAM)hIcon)) {

        DestroyIcon(hIconOld);
    }

    CPSUIDBG(DBG_SETTVICON, ("hIcon=%08lx, hIconOld=%08lx", hIcon, hIconOld));

    return(hIcon);
}




LONG
CreateImageList(
    HWND    hDlg,
    PTVWND  pTVWnd
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    06-Jul-1995 Thu 17:34:14 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HDC         hDC;
    TEXTMETRIC  tm;
    UINT        cyImage;
    UINT        uFlags;

    if (pTVWnd->himi) {

        return(0);
    }

    if (hDC = GetWindowDC(hDlg)) {

        GetTextMetrics(hDC, &tm);
        ReleaseDC(hDlg, hDC);

        cyImage = (UINT)((tm.tmHeight >= 18) ? 20 : 18);

        CPSUIDBG(DBG_CREATEIL,
                 ("CreateImageList: cyFont =%ld, cyImage=%ld",
                            tm.tmHeight, cyImage));

    } else {

        cyImage = 20;

        CPSUIDBG(DBG_CREATEIL,
                 ("CreateImageList: GetWindowDC Failed, use cyImage=20"));
    }

    pTVWnd->cyImage  = (BYTE)cyImage;

#if 0
    if (!pTVWnd->hbrGray) {

        pTVWnd->hbmGray = CreateBitmap(bmiGray.bmh.biWidth,
                                       bmiGray.bmh.biHeight,
                                       bmiGray.bmh.biBitCount,
                                       bmiGray.bmh.biPlanes,
                                       (LPBYTE)bmiGray.Bits);

        pTVWnd->hbrGray = CreatePatternBrush(pTVWnd->hbmGray);
    }
#endif

    uFlags = ILC_COLOR4 | ILC_MASK;
    if (GetWindowLongPtr(hDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {

        //
        // If the layout is right-to-left(RTL), we create the image list
        // by setting ILC_MIRROR, so the actual images will be the same
        // as US build
        //
        uFlags |= ILC_MIRROR;
    }

    if (pTVWnd->himi = ImageList_Create(CXIMAGE,
                                        cyImage,
                                        uFlags,
                                        COUNT_GROW_IMAGES,
                                        COUNT_GROW_IMAGES)) {

        GetIcon16Idx(pTVWnd, hInstDLL, IDI_CPSUI_EMPTY, IDI_CPSUI_EMPTY);

        pTVWnd->yLinesOff = (cyImage == 20) ? 0 : 1;

        return(0);

    } else {

        CPSUIERR(("\n!! AddOptionIcon16() FAILED !!\n"));
        CPSUIERR(("Count=%ld, pTVWnd->himi=%08lx",
                    COUNT_GROW_IMAGES, pTVWnd->himi));

        return(ERR_CPSUI_CREATE_IMAGELIST_FAILED);
    }
}



WORD
GetIcon16Idx(
    PTVWND      pTVWnd,
    HINSTANCE   hInst,
    ULONG_PTR    IconResID,
    DWORD       IntIconID
    )

/*++

Routine Description:

    This function return a WORD index of Imagelist which the icon should be
    used in the treeview


Arguments:


    pTVWnd      - Our instance handle

    hInst       - The instance handle for the IconResID

    IconResID   - Caller's IconResID, it the high word is not zero then it
                  it assume it is a Icon handle, and if high word is 0xffff
                  then it assume the low word is the icon handle

    IntIconID   - compstui Internal icon ID to be used if the IconResID is
                  not available


Return Value:

    WORD, index to the image list, 0xFFFF if failed


Author:

    06-Jul-1995 Thu 17:49:06 created  -by-  Daniel Chou (danielc)


Revision History:

    01-Jul-1996 Mon 13:27:25 updated  -by-  Daniel Chou (danielc)
        Fix bug that we will first only search the IconResID and if not found
        then we try to find the IntIconID


--*/

{
    HICON   hIconTV;
    HICON   hIconToDestroy = NULL;
    HICON   hIcon;
    LPDWORD pIcon16ID;
    LONG    IntIconIdx = -1;
    DWORD   IconID;
    DWORD   IconChksum;
    WORD    Index;
    WORD    AddIdx;

    //
    // Find out if we have this 16x16 icon added already
    //

    if (VALID_PTR(IconResID)) {

        hIcon      = GET_HICON(IconResID);
        IntIconID  = 0;
        IconChksum = GethIconChecksum(hIcon);

        CPSUIDBG(DBG_GETICON16IDX,
                 ("GetIcon16Index: User hIcon=%08lx, Chksum=%08lx",
                    hIcon, IconChksum));

    } else {
#if DO_IN_PLACE
        if ((IconResID == IDI_CPSUI_GENERIC_OPTION) ||
            (IconResID == IDI_CPSUI_GENERIC_ITEM)) {

            IconResID = IDI_CPSUI_EMPTY;
        }
#endif
        hIcon      = NULL;
        IconChksum = LODWORD(IconResID);
    }

    if (pIcon16ID = pTVWnd->pIcon16ID) {

        LPDWORD     pIcon16IDEnd = pIcon16ID + pTVWnd->Icon16Added;

        //
        // Try to find the IconChksum first, and remember the IntIconID
        //

        while (pIcon16ID < pIcon16IDEnd) {

            if (IconID = *pIcon16ID++) {

                if ((IconID == IconChksum) || (IconID == IntIconID)) {

                    Index = (WORD)(pIcon16ID - pTVWnd->pIcon16ID - 1);

                    if (IconID == IconChksum) {

                        //
                        // Find the wanted IconChksum, return it now
                        //

                        CPSUIDBG(DBG_GETICON16IDX,
                                ("GetIcon16Idx: hIcon=%08lx IconChksum=%08lx already exists in Index=%ld",
                                    hIcon, IconID, Index));

                        return(Index);

                    } else {

                        //
                        // We found the IntIconID now, save it for later if we
                        // cannot find the IconChksum
                        //

                        IntIconIdx = (LONG)Index;
                    }
                }
            }
        }
    }

    if (hIcon) {

        IconID = IconChksum;

    } else {

        if (!hInst) {

            hInst = pTVWnd->hInstCaller;
        }

        if (IconID = IconChksum) {

            hIcon = GETICON16(hInst, IconID);
        }

        if ((!hIcon) && (IconID = IntIconID)) {

            //
            // If we cannot load the IconChksum, and we have IntIconID plus the
            // IntIconIdx then return it now
            //

            if (IntIconIdx != -1) {

                CPSUIDBG(DBG_GETICON16IDX,
                        ("GetIcon16Idx: hIcon=%08lx IconIntID=%08lx exists in Index=%ld",
                            hIcon, IntIconID, IntIconIdx));

                return((WORD)IntIconIdx);
            }
#if DO_IN_PLACE
            if ((IconID == IDI_CPSUI_GENERIC_OPTION) ||
                (IconID == IDI_CPSUI_GENERIC_ITEM)) {

                IconID = IDI_CPSUI_EMPTY;
            }
#endif
            hIcon = GETICON16(hInst, IconID);
        }

        if (!hIcon) {

            CPSUIDBG(DBG_GETICON16IDX, ("GETICON16(%ld) FALIED", (DWORD)IconID));

            return(ICONIDX_NONE);
        }

        hIconToDestroy = hIcon;
    }

    //
    // Now Create TV Icon and added to the end of the list
    //

    if (hIconTV = CreateTVIcon(pTVWnd, hIcon, (pIcon16ID) ? 0 : 2)) {

        Index   = (WORD)pTVWnd->Icon16Added;
        AddIdx  = (WORD)ImageList_AddIcon(pTVWnd->himi, hIconTV);

        CPSUIDBG(DBG_FIRST_ICON,
                 ("Add Icon Index=%ld, Add=%ld, ResID=%ld, IntID=%ld",
                    Index, AddIdx, IconResID, IntIconID));

        CPSUIASSERT(0, "ImageList_AddIcon: Index mismatch (%ld)",
                            Index == AddIdx, Index);

        if (AddIdx != 0xFFFF) {

            if (Index >= pTVWnd->Icon16Count) {

                LPDWORD pdwNew;
                DWORD   OldSize;
                DWORD   NewSize;

                //
                // The thing got full, let's realloc the memory object to
                // be bigger
                //

                OldSize = (DWORD)(pTVWnd->Icon16Count * sizeof(DWORD));
                NewSize = (DWORD)(OldSize +
                                  (COUNT_GROW_IMAGES + 2) * sizeof(DWORD));

                if (pdwNew = (LPDWORD)LocalAlloc(LPTR, NewSize)) {

                    if (pTVWnd->pIcon16ID) {

                        CopyMemory(pdwNew, pTVWnd->pIcon16ID, OldSize);
                        LocalFree((HLOCAL)pTVWnd->pIcon16ID);
                    }

                    pTVWnd->pIcon16ID    = pdwNew;
                    pTVWnd->Icon16Count += COUNT_GROW_IMAGES;

                    CPSUIDBG(DBG_REALLOC,
                             ("LocalAlloc(%ld): pNew=%08lx", NewSize, pdwNew));

                } else {

                    CPSUIERR(("ImageList_AddIcon: LocalReAlloc(%ld) FAILED",
                                NewSize));
                }
            }

            *(pTVWnd->pIcon16ID + Index) = IconID;
            pTVWnd->Icon16Added++;

            CPSUIDBG(DBG_GETICON16IDX,
                     ("Add Icon16: IconID=%ld, IconChksum=%ld, Index=%ld",
                        (DWORD)IconID, (DWORD)IconChksum, (DWORD)Index));

        } else {

            Index = ICONIDX_NONE;

            CPSUIERR(("ImageList_AddIcon FAILED"));
        }

        //
        // Do not needed any more delete it
        //

        DestroyIcon(hIconTV);

    } else {

        Index = ICONIDX_NONE;

        CPSUIERR(("CreateTVIcon() FAILED"));
    }

    if (hIconToDestroy) {

        DestroyIcon(hIconToDestroy);
    }

    return(Index);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#include <stddef.h>
#include <stdarg.h>
#include <stdio.h>

#include <search.h>
#include <windows.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <commctrl.h>
#include <compstui.h>

// shell is defining STYPE_DEVICE which is screwing up winddi.h,
// so we just undef STYPE_DEVICE here
#undef STYPE_DEVICE
#include <winddi.h>

// FUSION
#include <shfusion.h>
#include "fusutils.h"

#include "treeview.h"
#include "debug.h"
#include "dialogs.h"
#include "dlgctrl.h"
#include "help.h"
#include "image.h"
#include "proppage.h"
#include "resource.h"
#include "stdpage.h"
#include "validate.h"
#include "convert.h"
#include "tvctrl.h"
#include "apilayer.h"
#include "handle.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\image.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    image.h


Abstract:

    This module contains global definitions for the image.c


Author:

    06-Jul-1995 Thu 18:39:58 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/




//
// Internal OPTITEMs
//



#define CXICON                  16
#define CYICON                  16
#define CXIMAGE                 16
#define ICON_X_OFF              ((CXIMAGE - CXICON) >> 1)

#define X_WARNOVLY_ADD          3
#define Y_WARNOVLY_ADD          -3

#define LBCB_ICON_X_OFF         3
#define LBCB_ICON_TEXT_X_SEP    4

#define COUNT_GROW_IMAGES       16


#define ROP_DPa                 0x00A000C9
#define ROP_DPo                 0x00FA0089
#define ROP_DPna                0x000A0329

#define MIM_STOP_OVERLAY        0x0001
#define MIM_WARNING_OVERLAY     0x0002
#define MIM_NO_OVERLAY          0x0004
#define MIM_MASK                0x0007
#define MIM_MAX_OVERLAY         3


#define MK_INTICONID(i,m)       (DWORD)MAKELONG((i),(m))
#define GET_INTICONID(x)        (WORD)LOWORD(LODWORD(x))
#define GET_MERGEICONID(x)      (WORD)(HIWORD(LOWORD(x)) & MIM_MASK)

#define ALIGN_DW(cx, bpp)   (((((DWORD)cx * (DWORD)bpp) + 31L) & ~31) >> 3)

#define PBIH_HDR_SIZE(pbih) (UINT)(((pbih)->biSize) +                         \
                                   (((pbih)->biCompression == BI_BITFIELDS) ? \
                                    12 : (pbih)->biClrUsed * sizeof(RGBQUAD)))
#define BIH_HDR_SIZE(bih)   (UINT)(((bih).biSize) +                           \
                                   (((bih).biCompression == BI_BITFIELDS) ?   \
                                    12 : (bih).biClrUsed * sizeof(RGBQUAD)))

HBRUSH
CreateGrayBrush(
    COLORREF    Color
    );

VOID
DestroyGrayBrush(
    HBRUSH  hBrush
    );

HICON
SetIcon(
    HINSTANCE   hInst,
    HWND        hCtrl,
    ULONG_PTR    IconResID,
    DWORD       IntIconID,
    UINT        cxcyIcon
    );

LONG
CreateImageList(
    HWND    hDlg,
    PTVWND  pTVWnd
    );

WORD
GetIcon16Idx(
    PTVWND      pTVWnd,
    HINSTANCE   hInst,
    ULONG_PTR    IconResID,
    DWORD       IntIconID
    );

HICON
MergeIcon(
    HINSTANCE   hInst,
    ULONG_PTR    IconResID,
    DWORD       IntIconID,
    UINT        cxIcon,
    UINT        cyIcon
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\resource.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    resource.c


Abstract:

    This module contains functions to load resources


Author:

    29-Aug-1995 Tue 12:29:27 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop


#define DBG_CPSUIFILENAME   DbgResource



#define DBG_GETSTR0         0x00000001
#define DBG_GETSTR1         0x00000002
#define DBG_GETICON         0x00000004
#define DBG_COMPOSESTR      0x00000008
#define DBG_ADD_SPACE       0x00000010
#define DBG_ADD_WCHAR       0x00000020
#define DBG_AMPERCENT       0x00000040


DEFINE_DBGVAR(0);



extern HINSTANCE    hInstDLL;


//
// Remove Ampercent will remove a '&' sign, if two '&' signs (ie. '&&') then
// only one is removed, ALSO if a '(&X)'  (ie. SPACE + & + Left Parenthesis +
// Single Character + Right Parenthesis) then it consider to be a Localization
// hot key indicator, then the whole ' (&X)' will be removed
//


#define REMOVE_AMPERCENT(CHTYPE)                                            \
{                                                                           \
    CHTYPE  *pOrg;                                                          \
    CHTYPE  *pCopy;                                                         \
    UINT    cRemoved;                                                       \
    CHTYPE  ch;                                                             \
                                                                            \
                                                                            \
    cRemoved = 0;                                                           \
    pOrg     =                                                              \
    pCopy    = pStr;                                                        \
                                                                            \
    CPSUIDBG(DBG_AMPERCENT, ("RemoveAmpercent (ORG)='%ws'", pOrg));         \
                                                                            \
    do {                                                                    \
                                                                            \
        while ((ch = *pStr++) && (ch != (CHTYPE)'&')) {                     \
                                                                            \
            if (cRemoved) {                                                 \
                                                                            \
                *pCopy = ch;                                                \
            }                                                               \
                                                                            \
            ++pCopy;                                                        \
        }                                                                   \
                                                                            \
        if (ch) {                                                           \
                                                                            \
            ++cRemoved;                                                     \
                                                                            \
            if (*pStr == (CHTYPE)'&') {                                     \
                                                                            \
                *pCopy++ = *pStr++;                                         \
                                                                            \
            } else if ((*(pCopy - 1) == (CHTYPE)'(')    &&                  \
                       (*(pStr + 1) == (CHTYPE)')')) {                      \
                                                                            \
                cRemoved += 3;                                              \
                ch        = (CHTYPE)')';                                    \
                pCopy    -= 1;                                              \
                pStr     += 2;                                              \
                                                                            \
                if ((*pStr == (CHTYPE)' ')      &&                          \
                    ((pCopy == pOrg)        ||                              \
                     ((pCopy > pOrg) &&                                     \
                      (*(pCopy - 1) == (CHTYPE)' ')))) {                    \
                                                                            \
                    CPSUIDBG(DBG_AMPERCENT, ("Extra SPACE"));               \
                                                                            \
                    if (pCopy == pOrg) {                                    \
                                                                            \
                        ++pStr;                                             \
                                                                            \
                    } else {                                                \
                                                                            \
                        --pCopy;                                            \
                    }                                                       \
                                                                            \
                    ++cRemoved;                                             \
                }                                                           \
            }                                                               \
        }                                                                   \
                                                                            \
    } while (ch);                                                           \
                                                                            \
    if (cRemoved) {                                                         \
                                                                            \
        *pCopy = (CHTYPE)'\0';                                              \
                                                                            \
        CPSUIDBG(DBG_AMPERCENT, ("   RemoveAmpercent (%3ld)='%ws'",         \
                                        cRemoved, pOrg));                   \
    }                                                                       \
                                                                            \
    return(cRemoved);                                                       \
}





UINT
RemoveAmpersandA(
    LPSTR   pStr
    )

/*++

Routine Description:

    This function remove ampersand from a string, the string must be writable


Arguments:

    pStr   - string to be serarch and remove the ampersand if found


Return Value:

    UINT, count of ampersands removed


Author:

    19-Sep-1995 Tue 21:55:19 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    REMOVE_AMPERCENT(CHAR);
}




UINT
RemoveAmpersandW(
    LPWSTR  pStr
    )

/*++

Routine Description:

    This function remove ampersand from a string, the string must be writable


Arguments:

    pwStr   - string to be serarch and remove the ampersand if found


Return Value:

    UINT, count of ampersands removed


Author:

    19-Sep-1995 Tue 21:55:19 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    REMOVE_AMPERCENT(WCHAR);
}




UINT
DupAmpersandW(
    LPWSTR  pwStr,
    INT     cChar,
    INT     cMaxChar
    )

/*++

Routine Description:

    This function remove ampersand from a string, the string must be writable


Arguments:

    pwStr   - string to be serarch and remove the ampersand if found


Return Value:

    UINT, count of ampersands removed


Author:

    19-Sep-1995 Tue 21:55:19 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPWSTR  pw;
    LPWSTR  pwCopy;
    INT     i;
    INT     cAdd = 0;


    if (((i = cChar) > 0) && ((cMaxChar -= cChar) > 0)) {

        pw = pwStr;

        while ((i--) && (cAdd < cMaxChar)) {

            if (*pw++ == L'&') {

                ++cAdd;
            }
        }

        if (cAdd) {

            pw     = pwStr + cChar;
            pwCopy = pw + cAdd;

            CPSUIASSERT(0, "DupAmpersandW(): pwStr[%u] is not NULL",
                            *pw == L'\0', IntToPtr(cChar));

            while (pwCopy >= pwStr) {

                if ((*pwCopy-- = *pw--) == L'&') {

                    *pwCopy-- = L'&';
                }
            }
        }
    }

    return((UINT)cAdd);
}




UINT
GetString(
    PGSBUF  pGSBuf,
    LPTSTR  pStr
    )

/*++

Routine Description:

    This function load the string either from caller (ANSI or UNICODE) or
    from common UI DLL, if the pStr is valid then it will just it, after
    getting the correct string, it will convert it to UNICODE as needed

Arguments:

    pGSBuf  - Pointer to GSBUF structure and following structure must set

                pTVWnd  - Pointer to the TVWND which has all then information
                          needed.

                pBuf    - Pointer to the begining of the buffer (LPWSTR)

                pEndBuf - Pointer to the end of the buffer


    pStr    - Pointer to the string to be converted


Return Value:

    UINT    - Count of character stored in the pBuf not include the NULL
              terminator, if the pBuf only has one character left then it
              always store a NULL and return 0


Author:

    29-Aug-1995 Tue 12:30:49 created  -by-  Daniel Chou (danielc)
        First version

    31-Aug-1995 Thu 10:58:04 updated  -by-  Daniel Chou (danielc)
        Re-write to do UNICODE conversion and ANSI call checking

    05-Feb-1996 Mon 12:20:28 updated  -by-  Daniel Chou (danielc)
        Fix the bug when UNICODE we do lstrcpy without checking the buffer
        size.

Revision History:


--*/

{
    LPWSTR  pBuf;
    WORD    Flags;
    GSBUF   GSBuf = *pGSBuf;
    UINT    RemoveAmpersandOff = 0;
    INT     cChar;
    INT     Len = 0;


    //
    // Make pBuf pointed to the first available character
    //

    pBuf  = pGSBuf->pBuf;
    Flags = pGSBuf->Flags;


    CPSUIASSERT(0, "GetString(pBuf=NULL)", pBuf, 0);

    if (pGSBuf->pEndBuf) {

        cChar = (INT)(pGSBuf->pEndBuf - pBuf);

    } else {

        cChar = MAX_RES_STR_CHARS;
    }

    //
    // Check if we have room to convert the string, make sure we reduced the
    // cChar by one for the NULL terminator
    //

    if ((pStr == NULL) || (cChar < 2)) {

        if (pStr) {

            CPSUIWARN(("GetString: pStr=%08lx, Buffer cChar=%ld too smaller",
                            pStr, cChar));
        }

        *pBuf = L'\0';
        return(0);
    }

    if (pGSBuf->chPreAdd != L'\0') {

        CPSUIDBG(DBG_GETSTR0, ("GetString(): Pre-Add Char = '%wc'",
                                                        pGSBuf->chPreAdd));

        //
        // If we pre-add character first then do it now
        //

        if ((*pBuf++ = pGSBuf->chPreAdd) == L'&') {

            RemoveAmpersandOff = 1;
        }

        cChar--;
        pGSBuf->chPreAdd = L'\0';
    }

    if (--cChar < 1) {

        CPSUIDBG(DBG_GETSTR1, ("GetString()=Only has one character for SPACE"));
        NULL;

    } else if (!VALID_PTR(pStr)) {

        HINSTANCE   hInst;
        WORD        ResID;


        //
        // Apperantly this is the resource ID, the LoadString() will not
        // write exceed the cChar included the NULL terminator according to
        // the Win32 help file.   At here we know we either have to convert
        // the ASCII string to UNICODE or we load the UNICODE string to the
        // buffer already
        //

        ResID = LOWORD(LODWORD(pStr));

        CPSUIDBGBLK({

            if ((ResID >= IDI_CPSUI_ICONID_FIRST) &&
                (ResID <= IDI_CPSUI_ICONID_LAST)) {

                CPSUIERR(("ResID=%ld is in icon ID range, change it", ResID));

                ResID = ResID - IDI_CPSUI_ICONID_FIRST + IDS_CPSUI_STRID_FIRST;
            }
        })

        if ((ResID >= IDS_CPSUI_STRID_FIRST)    &&
            (ResID <= IDS_CPSUI_STRID_LAST)) {

            hInst = hInstDLL;

            if (Flags & GBF_INT_NO_PREFIX) {

                Flags &= ~GBF_PREFIX_OK;
            }

        } else {

            hInst = (Flags & GBF_IDS_INT_CPSUI) ? hInstDLL : pGSBuf->hInst;

            CPSUIASSERT(0, "GetString(hInst=NULL, %08lx)", pStr, 0);
        }

        //
        // Now loaded from common UI DLL directly to the user buffer
        //

        if (Len = LoadString(hInst, ResID, pBuf, cChar)) {

            pBuf += Len;

        } else {

            pBuf = pGSBuf->pBuf;

            CPSUIERR(("LoadString(ID=%ld) FAILED", ResID));
        }

    } else if ((Flags & GBF_COPYWSTR) ||
               (!(Flags & GBF_ANSI_CALL))) {

        //
        // We have UNICODE string but may need to put into the buffer
        //

        if (Len = lstrlen(pStr)) {

            if (Len > cChar) {

                Len = cChar;
            }

            CopyMemory(pBuf, pStr, sizeof(WCHAR) * Len);

            pBuf += Len;
        }

    } else {

        //
        // We are loading the ANSI string
        //

        if (Len = lstrlenA((LPSTR)pStr)) {

            if (Len = MultiByteToWideChar(CP_ACP,
                                          0,
                                          (LPCSTR)pStr,
                                          Len,
                                          pBuf,
                                          cChar)) {
                pBuf += Len;

            } else {

                //
                // Conversion is not complete so make sure it NULL terminated
                //

                pBuf = pGSBuf->pBuf;

                CPSUIWARN(("GetString: pstr='%hs', Buffer reach limit=%ld, Len=%ld",
                                pStr, cChar, Len));
            }

            CPSUIDBG(DBG_GETSTR0, ("Convert to UNICODE, Len=%d, cChar=%d",
                                                Len, cChar));
        }
    }

    //
    // Save the new index back and return the len to the caller
    //

    *pBuf = L'\0';
    Len   = (INT)(pBuf - pGSBuf->pBuf);

    if (!(Flags & GBF_PREFIX_OK)) {

        Len -= RemoveAmpersandW(pGSBuf->pBuf + RemoveAmpersandOff);
    }

    if (Flags & GBF_DUP_PREFIX) {

        Len += DupAmpersandW(pGSBuf->pBuf,
                             Len,
                             (INT)(UINT)(pGSBuf->pEndBuf - pGSBuf->pBuf));
    }

    CPSUIDBG(DBG_GETSTR1, ("GetString()=%ws (%d/%d)", pGSBuf->pBuf, Len, cChar));

    CPSUIASSERT(0, "GetString() : Len != Real Len (%ld)",
                    Len == lstrlen(pGSBuf->pBuf), IntToPtr(lstrlen(pGSBuf->pBuf)));

    pGSBuf->pBuf += Len;

    return((UINT)Len);
}




UINT
GSBufAddNumber(
    PGSBUF  pGSBuf,
    DWORD   Number,
    BOOL    Sign
    )

/*++

Routine Description:

    Convert a number to a string with the limitation of GSBUF


Arguments:

    pGSBuf  - Pointer to GSBUF structure and following structure must set

                pTVWnd  - Pointer to the TVWND which has all then information
                          needed.

                pBuf    - Pointer to the begining of the buffer (LPWSTR)

                pEndBuf - Pointer to the end of the buffer


    Number  - LONG number to be converted

    Sign    - if TRUE then Number is a sign long number else it is a unsigned
              DWORD

Return Value:

    UINT    total bytes converted to the string


Author:

    21-Feb-1996 Wed 12:17:00 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    WCHAR   wBuf[16];
    UINT    cChar;
    UINT    Len = 0;

    if (((cChar = (INT)(pGSBuf->pEndBuf - pGSBuf->pBuf - 1)) > 0)   &&
        (Len = wsprintf(wBuf, (Sign) ? L"%ld" : L"%lu", Number))) {

        if (Len > cChar) {

            Len = cChar;
        }

        CopyMemory(pGSBuf->pBuf, wBuf, sizeof(WCHAR) * Len);

        pGSBuf->pBuf    += Len;
        *(pGSBuf->pBuf)  = L'\0';
    }

    return(Len);
}



UINT
GSBufAddWChar(
    PGSBUF  pGSBuf,
    UINT    IntCharStrID,
    UINT    Count
    )

/*++

Routine Description:

    Add a single character to the GSBuf


Arguments:

    pGSBuf  - Pointer to GSBUF structure and following structure must set

                pTVWnd  - Pointer to the TVWND which has all then information
                          needed.

                pBuf    - Pointer to the begining of the buffer (LPWSTR)

                pEndBuf - Pointer to the end of the buffer


    wch     - a single character to be added


Return Value:

    BOOLEAN, true if succeed else false


Author:

    21-Feb-1996 Wed 12:00:24 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    WCHAR   wCh[2];
    UINT    cAvai;


    if ((Count)                                                 &&
        ((cAvai = (UINT)(pGSBuf->pEndBuf - pGSBuf->pBuf)) > 1)  &&
        (LoadString(hInstDLL, IntCharStrID, wCh, COUNT_ARRAY(wCh)))) {

        CPSUIDBG(DBG_ADD_WCHAR, ("GSBufAddWChar(%08lx, %u, %u)=%u of '%wc'",
                    pGSBuf, IntCharStrID, Count,
                    (Count > (cAvai - 1)) ? cAvai - 1 : Count, wCh[0]));

        if (Count > (cAvai -= 1)) {

            Count = cAvai;
        }

        cAvai = Count;

        while (cAvai--) {

            *(pGSBuf->pBuf)++ = wCh[0];
        }

        *(pGSBuf->pBuf) = L'\0';

        return(Count);

    } else {

        CPSUIERR(("GSBufAddWChar(%08lx, %u, %u) FAILED",
                    pGSBuf, IntCharStrID, Count));

        return(0);
    }
}



UINT
GSBufAddSpace(
    PGSBUF  pGSBuf,
    UINT    Count
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    20-Jul-1996 Sat 00:59:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    static  WCHAR   wSpace[2] = { 0, 0 };
    UINT            cAvai;


    if (wSpace[0] == L'\0') {

        LoadString(hInstDLL,
                   IDS_INT_CPSUI_SPACE_CHAR,
                   wSpace,
                   COUNT_ARRAY(wSpace));
    }

    if ((wSpace[0] != L'\0')                                    &&
        (Count)                                                 &&
        ((cAvai = (UINT)(pGSBuf->pEndBuf - pGSBuf->pBuf)) > 1)) {

        CPSUIDBG(DBG_ADD_SPACE, ("GSBufAddSpace(%08lx, %u)=%u of '%wc'",
                    pGSBuf, Count,
                    (Count > (cAvai - 1)) ? cAvai - 1 : Count, wSpace[0]));

        if (Count > (cAvai -= 1)) {

            Count = cAvai;
        }

        cAvai = Count;

        while (cAvai--) {

            *(pGSBuf->pBuf)++ = wSpace[0];
        }

        *(pGSBuf->pBuf) = L'\0';

        return(Count);

    } else {

        CPSUIERR(("GSBufAddSpace(%08lx, %u) FAILED", pGSBuf, Count));

        return(0);
    }
}




UINT
GetStringBuffer(
    HINSTANCE   hInst,
    WORD        GBFlags,
    WCHAR       chPreAdd,
    LPTSTR      pStr,
    LPWSTR      pBuf,
    UINT        cwBuf
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    07-Sep-1995 Thu 10:45:09 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    GSBUF   GSBuf;

    GSBuf.hInst    = hInst;
    GSBuf.Flags    = GBFlags;
    GSBuf.pBuf     = (LPWSTR)pBuf;
    GSBuf.pEndBuf  = (LPWSTR)pBuf + cwBuf;
    GSBuf.chPreAdd = chPreAdd;

    return(GetString(&GSBuf, pStr));
}




LONG
LoadCPSUIString(
    LPTSTR  pStr,
    UINT    cStr,
    UINT    StrResID,
    BOOL    AnsiCall
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    08-Feb-1996 Thu 13:36:12 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    if ((pStr) && (cStr)) {

        UINT    Len = 0;

        if ((StrResID  >= IDS_CPSUI_STRID_FIRST) &&
            (StrResID  <= IDS_CPSUI_STRID_LAST)) {

            if (AnsiCall) {

                if (Len = LoadStringA(hInstDLL, StrResID, (LPSTR)pStr, cStr)) {

                    Len -= RemoveAmpersandA((LPSTR)pStr);
                }

            } else {

                if (Len = LoadString(hInstDLL, StrResID, (LPWSTR)pStr, cStr)) {

                    Len -= RemoveAmpersandW((LPWSTR)pStr);
                }
            }
        }

        return((LONG)Len);

    } else {

        return(-1);
    }
}



UINT
ComposeStrData(
    HINSTANCE   hInst,
    WORD        GBFlags,
    LPWSTR      pBuf,
    UINT        cwBuf,
    UINT        IntFormatStrID,
    LPTSTR      pStr,
    DWORD       dw1,
    DWORD       dw2
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    19-Jul-1996 Fri 17:11:19 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    TCHAR   szFormat[MAX_RES_STR_CHARS * 3];
    LPTSTR  pData;
    LPTSTR  pFinal;
    UINT    Count;
    UINT    i;
    UINT    cb;


    ZeroMemory(szFormat, sizeof(szFormat));
    if ((IntFormatStrID)                                                     &&
        (i = LoadString(hInstDLL,
                        IntFormatStrID,
                        (LPTSTR)szFormat,
                        MAX_RES_STR_CHARS))) {

        cb = ARRAYSIZE(szFormat) - i - 1;
        pData = szFormat + i + 1;

        if (!pStr) {

            //
            // Skip the pStr if it passed as NULL
            //

            Count = wnsprintf(pFinal = pData, cb, szFormat, dw1, dw2);

        } else {

            i = GetStringBuffer(hInst,
                                (WORD)(GBFlags | GBF_INT_NO_PREFIX),
                                (WCHAR)0,
                                pStr,
                                pData,
                                MAX_RES_STR_CHARS);

            cb = cb - i - 1;
            pFinal = pData + i + 1;

            Count = wnsprintf(pFinal, cb, szFormat, pData, dw1, dw2);
        }

        if (Count > (cwBuf - 1)) {

            Count = cwBuf - 1;
            szFormat[Count] = '\0';
        }

        CopyMemory(pBuf, pFinal, (Count + 1) * sizeof(TCHAR));


        CPSUIDBG(DBG_COMPOSESTR, ("ComposeString('%ws', '%ws', %lu, %lu)='%ws' [%u]",
                            szFormat, pData, dw1, dw2, pBuf, Count));

    } else {

        Count = GetStringBuffer(hInst, GBFlags, (WCHAR)0, pStr, pBuf, cwBuf);

        CPSUIDBG(DBG_COMPOSESTR, ("ComposeString(%08lx, %lu, %lu)=FAILED, '%ws' [%u]",
                            pStr, dw1, dw2, pBuf, Count));
    }

    return(Count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\proppage.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    proppage.h


Abstract:

    This module contains all definition for the proppage.c


Author:

    03-Sep-1995 Sun 06:31:29 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/

typedef struct _MYBMP {
    LPBITMAPINFOHEADER  lpbmi;
    LPBYTE              lpBits;
    HANDLE              hBitmap;
    } MYBMP;

typedef struct _DUPLEXID {
    BYTE                SimplexIdx;
    BYTE                LongSideIdx;
    BYTE                ShortSideIdx;
    BYTE                Reserved[1];
    } DUPLEXID;

typedef struct _ORIENTID {
    BYTE                PortraitIdx;
    BYTE                LandscapeIdx;
    BYTE                RotateIdx;
    } ORIENTID;

typedef struct _DUPLEX{
    WORD                Start;
    WORD                End;
    } DUPLEX;

typedef struct _LAYOUTBMP {
    MYBMP               Portrait;
    MYBMP               BookletL;
    MYBMP               BookletP;
    MYBMP               ArrowL;
    MYBMP               ArrowS;
    HANDLE              hWnd;
    DUPLEXID            Duplex;
    ORIENTID            Orientation;
    BYTE                OrientIdx;
    BYTE                DuplexIdx;
    BYTE                NupIdx;
    BYTE                Reserved;
    } LAYOUTBMP, *PLAYOUTBMP;

#define ORIENT_PORTRAIT     0
#define ORIENT_LANDSCAPE    1
#define ORIENT_ROTATED      2

#define DUPLEX_LONGSIDE     0
#define DUPLEX_SHORTSIDE    1
#define DUPLEX_SIMPLEX      2

#define NUP_ONEUP           0
#define NUP_TWOUP           1
#define NUP_FOURUP          2
#define NUP_SIXUP           3
#define NUP_NINEUP          4
#define NUP_SIXTEENUP       5
#define NUP_BOOKLET         6

#define MAX_DUPLEX_OPTION   3
#define MAX_BORDER          2

#define FRAME_BORDER        1
#define SHADOW_SIZE         5

typedef struct _PAGEBORDER {
    INT left;
    INT top;
    INT right;
    INT bottom;
    } PAGEBORDER;

#define ADDOFFSET(size, div) (div > 0 ? size/div : 0)

typedef struct _NUP {
    INT row;
    INT columm;
    } NUP;

VOID
UpdateData(
    PLAYOUTBMP  pData,
    PTVWND      pTVWnd
    );

VOID
InitData(
    PLAYOUTBMP  pData,
    PTVWND      pTVWnd
    );


VOID
InvalidateBMP(
    HWND     hDlg,
    PTVWND   pTVWnd
    );

VOID
DrawBorder(
    HDC     hDC,
    BOOL    bDrawShadow,
    BOOL    bDrawBorder,
    PRECT   pRectIn,
    PRECT   pRectOut,
    PAGEBORDER * pPageBorder
);

BOOL
LoadLayoutBmp(
    HWND    hDlg,
    MYBMP * pMyBmpData,
    DWORD   dwBitmapID
    );

PLAYOUTBMP
InitLayoutBmp(
    HWND    hDlg,
    HANDLE  hBitmap,
    PTVWND  pTVWnd

);

VOID
FreeLayoutBmp(
    PLAYOUTBMP  pData
);


VOID
UpdateLayoutBmp(
    HDC     hDC,
    PLAYOUTBMP pData
    );

LONG
UpdatePropPageItem(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem,
    BOOL        DoInit
    );

LONG
UpdatePropPage(
    HWND        hDlg,
    PMYDLGPAGE  pMyDP
    );

LONG
CountPropPageItems(
    PTVWND  pTVWnd,
    BYTE    CurPageIdx
    );

INT_PTR
CALLBACK
PropPageProc(
    HWND    hDlg,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\stdpage.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    stdpage.h


Abstract:

    This module contains definitions of stdpage.c


Author:

    29-Aug-1995 Tue 17:08:18 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/

#define STDPAGEID_0     0
#define STDPAGEID_1     1
#define STDPAGEID_NONE  0xFF


typedef struct _STDPAGEINFO {
    WORD    BegCtrlID;
    BYTE    iStdTVOT;
    BYTE    cStdTVOT;
    WORD    StdNameID;
    WORD    HelpIdx;
    WORD    StdPageID;
    WORD    wReserved[1];
    } STDPAGEINFO, *PSTDPAGEINFO;


LONG
AddIntOptItem(
    PTVWND  pTVWnd
    );

LONG
SetStdPropPageID(
    PTVWND  pTVWnd
    );

LONG
SetpMyDlgPage(
    PTVWND      pTVWnd,
    UINT        cCurPages
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\stdpage.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    stdpage.c


Abstract:

    This module contains standard page procs


Author:

    18-Aug-1995 Fri 18:57:12 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


#define DBG_CPSUIFILENAME   DbgStdPage


#define DBG_STDPAGE1ID      0x00000001
#define DBGITEM_SDP         0x00000002
#define DBGITEM_STDPAGEID   0x00000004


DEFINE_DBGVAR(0);


extern HINSTANCE    hInstDLL;


#define DOCPROP_PDLGPAGE_START          0
#define DOCPROP_CDLGPAGE                3

#define ADVDOCPROP_PDLGPAGE_START       3
#define ADVDOCPROP_CDLGPAGE             1

#define PRINTERPROP_PDLGPAGE_START      4
#define PRINTERPROP_CDLGPAGE            1

#define TVONLY_PDLGPAGE_START           5
#define TVONLY_CDLGPAGE                 1

typedef struct _INTOIDATA {
    WORD    HelpIdx;
    WORD    wReserved;
    WORD    StrID;
    WORD    IconID;
    } INTOIDATA;

typedef struct _STDDLGPAGE {
    WORD    UseHdrIconID;
    WORD    wReserved;
    WORD    IDSTabName;
    WORD    DlgTemplateID;
    } STDDLGPAGE;


const INTOIDATA   IntOIData[INTIDX_TOTAL] = {

    { IDH_STD_TVROOT,    0, 0,                        IDI_CPSUI_PRINTER3     },
    { IDH_PAPEROUTPUT,   0, IDS_CPSUI_PAPER_OUTPUT,   IDI_CPSUI_PAPER_OUTPUT },
    { IDH_GRAPHIC,       0, IDS_CPSUI_GRAPHIC,        IDI_CPSUI_GRAPHIC      },
    { IDH_OPTIONS,       0, IDS_CPSUI_DOCUMENT,       IDI_CPSUI_OPTION       },
    { IDH_ICMHDR,        0, IDS_CPSUI_ICM,            IDI_CPSUI_ICM_OPTION   },
    { IDH_ADVANCED_PUSH, 0, IDS_CPSUI_ADVANCED,       IDI_CPSUI_EMPTY        }
};


//
// We must use PUSHBUTTON_TYPE_CALLBACK because it will never overwrite the
// pSel which we use for the icon id.
//

OPTPARAM    OptParamHdrPush = {

                sizeof(OPTPARAM),
                0,
                PUSHBUTTON_TYPE_CALLBACK,
                (LPTSTR)InternalRevertOptItem,
                (WORD)IDI_CPSUI_WARNING,
                0
            };

OPTTYPE     OptTypeHdrPush = {

                sizeof(OPTTYPE),
                TVOT_PUSHBUTTON,
                0,
                1,
                0,
                &OptParamHdrPush,
                OTS_PUSH_NO_DOT_DOT_DOT
            };


EXTPUSH     ExtPushAbout = {

                sizeof(EXTPUSH),
                0,
                (LPTSTR)IDS_CPSUI_ABOUT,
                NULL,
                IDI_CPSUI_QUESTION,
                0
            };


STDDLGPAGE StdDlgPage[] = {

    { 0, 0, IDS_CPSUI_STDDOCPROPTAB1,   DP_STD_DOCPROPPAGE1 },
    { 0, 0, IDS_CPSUI_STDDOCPROPTAB2,   DP_STD_DOCPROPPAGE2 },
    { 0, 0, IDS_CPSUI_STDDOCPROPTVTAB,  DP_STD_INT_TVPAGE   },
    { 0, 0, IDS_CPSUI_STDDOCPROPTVTAB,  DP_STD_TREEVIEWPAGE },
    { 0, 0, IDS_CPSUI_DEVICE_SETTINGS,  DP_STD_TREEVIEWPAGE },
    { 0, 0, IDS_CPSUI_OPTIONS,          DP_STD_TREEVIEWPAGE }
};

BYTE    StdTVOT[] = { TVOT_2STATES,     // 0
                      TVOT_3STATES,     // 1
                      TVOT_COMBOBOX,    // 2
                      TVOT_LISTBOX,     // 3
                      TVOT_UDARROW,     // 4
                      TVOT_TRACKBAR,    // 5
                      TVOT_SCROLLBAR    // 6
                    };


STDPAGEINFO StdPageInfo[] = {

{ IDD_ORIENT_GROUP   ,0, 2, IDS_CPSUI_ORIENTATION    ,IDH_ORIENTATION     ,STDPAGEID_0   },
{ 0                  ,4, 3, IDS_CPSUI_SCALING        ,IDH_SCALING         ,STDPAGEID_NONE},
{ 0                  ,4, 1, IDS_CPSUI_NUM_OF_COPIES  ,IDH_NUM_OF_COPIES   ,STDPAGEID_NONE},
{ IDD_DEFSOURCE_GROUP,2, 2, IDS_CPSUI_SOURCE         ,IDH_SOURCE          ,STDPAGEID_1   },
{ 0                  ,0, 4, IDS_CPSUI_PRINTQUALITY   ,IDH_RESOLUTION      ,STDPAGEID_NONE},
{ IDD_COLOR_GROUP    ,0, 1, IDS_CPSUI_COLOR_APPERANCE,IDH_COLOR_APPERANCE ,STDPAGEID_1   },
{ IDD_DUPLEX_GROUP   ,0, 2, IDS_CPSUI_DUPLEX         ,IDH_DUPLEX          ,STDPAGEID_0   },
{ 0                  ,0, 4, IDS_CPSUI_TTOPTION       ,IDH_TTOPTION        ,STDPAGEID_NONE},
{ 0                  ,2, 2, IDS_CPSUI_FORMNAME       ,IDH_FORMNAME        ,STDPAGEID_NONE},
{ 0                  ,0, 4, IDS_CPSUI_ICMMETHOD      ,IDH_ICMMETHOD       ,STDPAGEID_NONE},
{ 0                  ,0, 4, IDS_CPSUI_ICMINTENT      ,IDH_ICMINTENT       ,STDPAGEID_NONE},
{ IDD_MEDIATYPE_GROUP,2, 2, IDS_CPSUI_MEDIA          ,IDH_MEDIA           ,STDPAGEID_1   },
{ 0                  ,0, 4, IDS_CPSUI_DITHERING      ,IDH_DITHERING       ,STDPAGEID_NONE},
{ IDD_OUTPUTBIN_GROUP,2, 2, IDS_CPSUI_OUTPUTBIN      ,IDH_OUTPUTBIN       ,STDPAGEID_1   },
{ IDD_QUALITY_GROUP  ,0, 2, IDS_CPSUI_QUALITY_SETTINGS ,IDH_QUALITY       ,STDPAGEID_1   },
{ IDD_NUP_GROUP      ,2, 2, IDS_CPSUI_NUP            ,IDH_NUP             ,STDPAGEID_0    },
{ IDD_PAGEORDER_GROUP,0, 2, IDS_CPSUI_PAGEORDER      ,IDH_PAGEORDER       ,STDPAGEID_0    },
};





LONG
SetStdPropPageID(
    PTVWND  pTVWnd
    )

/*++

Routine Description:


    Do all the standard checking and set flags


Arguments:




Return Value:




Author:

    22-Aug-1995 Tue 14:34:01 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    POPTITEM    pItem;
    POPTITEM    pFirstItem;
    POPTITEM    pLastItem;
    POPTITEM    pItemColor = NULL;
    POPTITEM    pItemICMMethod = NULL;
    POPTITEM    pItemICMIntent = NULL;
    HINSTANCE   hInstCaller;
    UINT        cDMPub = 0;


    FillMemory(pTVWnd->DMPubIdx, sizeof(pTVWnd->DMPubIdx), 0xFF);

    pFirstItem  =
    pItem       = pTVWnd->ComPropSheetUI.pOptItem;
    pLastItem   = pTVWnd->pLastItem;
    hInstCaller = pTVWnd->ComPropSheetUI.hInstCaller;

    while (pItem <= pLastItem) {

        POPTTYPE    pOptType;
        LPBYTE      pTVOT;
        UINT        cTVOT;
        BYTE        LastTVOT;
        BYTE        DMPubID = pItem->DMPubID;
        BYTE        CurLevel = pItem->Level;

        do {

            if ((DMPubID != DMPUB_NONE) &&
                (DMPubID <= DMPUB_LAST) &&
                (pOptType = pItem->pOptType)) {

                POPTPARAM   pOptParam;
                UINT        Count;
                UINT        Idx;
                WORD        StdNameID;
                WORD        BegCtrlID;


                Idx       = (UINT)(DMPubID - DMPUB_FIRST);
                StdNameID = StdPageInfo[Idx].StdNameID;
#if 1
                //
                // If there is help ID for standard item, use it; otherwise use the
                // system standard help ID
                //
                _OI_HELPIDX(pItem) = (DWORD)(((pItem->pOIExt) && (pItem->pOIExt->pHelpFile)) ?
                    0 : StdPageInfo[Idx].HelpIdx);

#else
                if ((_OI_HINST(pItem) != hInstCaller) ||
                    (!(pItem->HelpIndex))) {

                    _OI_HELPIDX(pItem) = (DWORD)StdPageInfo[Idx].HelpIdx;

                } else {

                    _OI_HELPIDX(pItem) = 0;
                }
#endif
                if ((!(pItem->Flags & OPTIF_ITEM_HIDE)) &&
                    (pTVWnd->DMPubIdx[Idx] == 0xFFFF)) {

                    ++cDMPub;

                    switch (DMPubID) {

                    case DMPUB_PRINTQUALITY:

                        switch (LODWORD(pItem->pName)) {

                        case IDS_CPSUI_RESOLUTION:
                        case IDS_CPSUI_PRINTQUALITY:

                            StdNameID = LOWORD(LODWORD(pItem->pName));
                            break;
                        }

                        break;

                    case DMPUB_COPIES_COLLATE:

                        if ((pItem->Flags & OPTIF_EXT_IS_EXTPUSH) &&
                            (pItem->pExtChkBox)) {

                            return(ERR_CPSUI_DMCOPIES_USE_EXTPUSH);
                        }

                        break;

                    case DMPUB_COLOR:

                        pItemColor = pItem;
                        break;

                    case DMPUB_ICMINTENT:

                        pItemICMIntent = pItem;
                        break;

                    case DMPUB_ICMMETHOD:

                        pItemICMMethod = pItem;
                        break;

                    case DMPUB_ORIENTATION:

                        pOptParam = pOptType->pOptParam;
                        Count     = pOptType->Count;

                        if (Count > 2 )
                        {
                            while (Count--) {

                                switch (pOptParam->IconID) {

                                case IDI_CPSUI_PORTRAIT:

                                    pOptParam->pData = (LPTSTR)IDS_CPSUI_PORTRAIT;
                                    break;

                                case IDI_CPSUI_LANDSCAPE:

                                    pOptParam->pData = (LPTSTR)IDS_CPSUI_LANDSCAPE;
                                    break;

                                case IDI_CPSUI_ROT_LAND:

                                    pOptParam->pData = (LPTSTR)IDS_CPSUI_ROT_LAND;
                                    break;

                                }
                                pOptParam++;
                            }
                        }
                        else
                        {
                            while (Count--) {

                                switch (pOptParam->IconID) {

                                case IDI_CPSUI_PORTRAIT:

                                    pOptParam->pData = (LPTSTR)IDS_CPSUI_PORTRAIT;
                                    break;

                                case IDI_CPSUI_LANDSCAPE:
                                case IDI_CPSUI_ROT_LAND:

                                    pOptParam->pData = (LPTSTR)IDS_CPSUI_LANDSCAPE;
                                    break;

                                }
                                pOptParam++;
                            }
                        }
                        break;

                    case DMPUB_DUPLEX:

                        pOptParam = pOptType->pOptParam;
                        Count     = pOptType->Count;

                        while (Count--) {

                            switch (pOptParam->IconID) {

                            case IDI_CPSUI_DUPLEX_NONE:
                            case IDI_CPSUI_DUPLEX_NONE_L:

                                pOptParam->pData = (LPTSTR)IDS_CPSUI_SIMPLEX;
                                break;

                            case IDI_CPSUI_DUPLEX_HORZ:
                            case IDI_CPSUI_DUPLEX_HORZ_L:

                                pOptParam->pData = (LPTSTR)IDS_CPSUI_HORIZONTAL;
                                break;

                            case IDI_CPSUI_DUPLEX_VERT:
                            case IDI_CPSUI_DUPLEX_VERT_L:

                                pOptParam->pData = (LPTSTR)IDS_CPSUI_VERTICAL;
                                break;
                            }

                            pOptParam++;
                        }

                        break;

                    default:

                        break;
                    }

                    pItem->pName          = (LPTSTR)StdNameID;
                    pTVWnd->DMPubIdx[Idx] = (WORD)(pItem - pFirstItem);
                }

                pTVOT    = (LPBYTE)&StdTVOT[StdPageInfo[Idx].iStdTVOT];
                cTVOT    = (UINT)StdPageInfo[Idx].cStdTVOT;
                LastTVOT = pTVOT[cTVOT - 1];

                while (cTVOT--) {

                    if (pOptType->Type == *pTVOT++) {

                        pTVOT = NULL;
                        break;
                    }
                }

                if (pTVOT) {

                    CPSUIERR(("DMPubID=%u has wrong type=%u",
                            (UINT)DMPubID, (UINT)pOptType->Type));

                    return(ERR_CPSUI_INVALID_DMPUB_TVOT);
                }

                if (BegCtrlID = StdPageInfo[Idx].BegCtrlID) {

                    BYTE    HideMask;

                    switch (pOptType->Type) {

                    case TVOT_3STATES:

                        pOptParam = pOptType->pOptParam;
                        Count     = pOptType->Count;
                        HideMask  = OTINTF_STATES_1;

                        //
                        // The OPTPF_HIDE cannot be dynamically changed for
                        // standard page items (3 states one)
                        //

                        while (Count--) {

                            if (pOptParam++->Flags & OPTPF_HIDE) {

                                _OT_FLAGS(pOptType) |=
                                            (OTINTF_STDPAGE_3STATES | HideMask);
                            }

                            HideMask <<= 1;
                        }


                        break;

                    case TVOT_2STATES:

                        if (LastTVOT == TVOT_3STATES) {

                            //
                            // The 0x04 is to hide the last radio button/text
                            // on the standard page and 0x80 is to tell the
                            // InitStates() that ExtChkBoxID is located on
                            // the end of 3 states
                            //

                            _OT_FLAGS(pOptType) |= (OTINTF_STDPAGE_3STATES |
                                                    OTINTF_STATES_3);
                        }

                        break;

                    case TVOT_LISTBOX:

                        pOptType->Style |= OTS_LBCB_PROPPAGE_LBUSECB;
                    }

                    pOptType->BegCtrlID = BegCtrlID;

                    CPSUIOPTITEM(DBGITEM_STDPAGEID, pTVWnd,
                                 "SetStdPageID", 1, pItem);
                }

            } else {

                _OI_HELPIDX(pItem) = 0;
            }

        } WHILE_SKIP_CHILDREN(pItem, pLastItem, CurLevel);
    }

    if (pItemColor) {

        DWORD   dw;


        dw = (pItemColor->Sel < 1) ? OPTIF_DISABLED : 0;

        if (pItemICMMethod) {

            pItemICMMethod->Flags &= ~OPTIF_DISABLED;
            pItemICMMethod->Flags |= dw;
        }

        if (pItemICMIntent) {

            pItemICMIntent->Flags &= ~OPTIF_DISABLED;
            pItemICMIntent->Flags |= dw;
        }
    }

    pTVWnd->cDMPub = (BYTE)cDMPub;

    return(cDMPub);

}




LONG
AddIntOptItem(
    PTVWND  pTVWnd
    )

/*++

Routine Description:

    This function add standard internal OPTITEM to the TVWND

Arguments:

    pTVWnd  - Our instance data


Return Value:

    LONG    number of item added if >= 0, else error code

Author:

    13-Sep-1995 Wed 14:40:37 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    POPTITEM    pItem;
    POIDATA     pOIData;
    UINT        i;

    for (i = 0, pItem = PBEG_INTOPTITEM(pTVWnd), pOIData = pTVWnd->IntOIData;
         i < INTIDX_TOTAL;
         i++, pItem++, pOIData++) {

        //
        // Only set anything is none zero to it
        //

        pItem->cbSize   = sizeof(OPTITEM);

        if (!(pItem->pName = (LPTSTR)IntOIData[i].StrID)) {

            if (!(pItem->pName = pTVWnd->ComPropSheetUI.pOptItemName)) {

                if (!(pItem->pName = pTVWnd->ComPropSheetUI.pCallerName)) {

                    pItem->pName = (LPTSTR)IDS_CPSUI_OPTIONS;
                }
            }

            pItem->pSel      = (LPTSTR)pTVWnd->ComPropSheetUI.IconID;
            pItem->Flags    |= OPTIF_EXT_IS_EXTPUSH;
            pItem->pExtPush  = &ExtPushAbout;

            if (pTVWnd->ComPropSheetUI.Flags & CPSUIF_ICONID_AS_HICON) {

                pItem->Flags |= OPTIF_SEL_AS_HICON;
            }

        } else if (pItem->pName == (LPTSTR)IDS_CPSUI_DOCUMENT) {

            pItem->Flags |= OPTIF_COLLAPSE;
        }

        if (!pItem->pName) {

            pItem->pName = (LPTSTR)IDS_CPSUI_PROPERTIES;
        }

        if (!pItem->Sel) {

            pItem->Sel    = IntOIData[i].IconID;
            pItem->Flags &= ~OPTIF_SEL_AS_HICON;
        }

        pItem->pOptType        = &OptTypeHdrPush;
        pItem->DMPubID         = DMPUB_NONE;

        pOIData->HelpIdx       = IntOIData[i].HelpIdx;
        pOIData->OIExtFlags    = (pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                    OIEXTF_ANSI_STRING : 0;
        pOIData->hInstCaller   = pTVWnd->hInstCaller;
        pOIData->pHelpFile     = (LPTSTR)IDS_INT_CPSUI_HELPFILE;
        _OI_POIDATA(pItem)     = pOIData;
    }

    pTVWnd->OptParamNone.cbSize = sizeof(OPTPARAM);
    pTVWnd->OptParamNone.pData  = (LPTSTR)IDS_CPSUI_LBCB_NOSEL;
    pTVWnd->OptParamNone.IconID = IDI_CPSUI_SEL_NONE;
    pTVWnd->OptParamNone.lParam = 0;

    return(INTIDX_TOTAL);
}




LONG
SetpMyDlgPage(
    PTVWND      pTVWnd,
    UINT        cCurPages
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    06-Sep-1995 Wed 12:12:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDLGPAGE    pDP;
    PMYDLGPAGE  pMyDP;
    POPTITEM    pHdrItem;
    UINT        cInitPage;
    UINT        cPage;
    INT         iPage;
    UINT        cb;
    BOOL        ChkDMPub = FALSE;


    pHdrItem = PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT);

    switch ((ULONG_PTR)(pDP = pTVWnd->ComPropSheetUI.pDlgPage)) {

    case (ULONG_PTR)CPSUI_PDLGPAGE_DOCPROP:

        cInitPage             = DOCPROP_CDLGPAGE - 1;
        cPage                 = DOCPROP_CDLGPAGE;
        iPage                 = DOCPROP_PDLGPAGE_START;
        pTVWnd->Flags        |= (TWF_TVPAGE_CHK_DMPUB | TWF_HAS_ADVANCED_PUSH);
        pTVWnd->IntTVOptIdx   = INTIDX_OPTIONS;
        pHdrItem->UserData    = IDS_INT_CPSUI_ADVDOC_SET;
        ChkDMPub              = TRUE;
        _OI_HELPIDX(pHdrItem) = IDH_DOCPROP_TVROOT;

        break;

    case (ULONG_PTR)CPSUI_PDLGPAGE_ADVDOCPROP:

        cInitPage             =
        cPage                 = ADVDOCPROP_CDLGPAGE;
        iPage                 = ADVDOCPROP_PDLGPAGE_START;
        pTVWnd->Flags        |= (TWF_TVPAGE_CHK_DMPUB | TWF_ADVDOCPROP);
        pTVWnd->IntTVOptIdx   = INTIDX_OPTIONS;
        pHdrItem->UserData    = IDS_INT_CPSUI_ADVDOC_SET;
        ChkDMPub              = TRUE;
        _OI_HELPIDX(pHdrItem) = IDH_ADVDOCPROP_TVROOT;
        break;

    case (ULONG_PTR)CPSUI_PDLGPAGE_PRINTERPROP:

        cInitPage             =
        cPage                 = PRINTERPROP_CDLGPAGE;
        iPage                 = PRINTERPROP_PDLGPAGE_START;
        pTVWnd->Flags        |= (TWF_TVPAGE_CHK_DMPUB | TWF_TVPAGE_NODMPUB);
        pHdrItem->UserData    = IDS_INT_CPSUI_DEVICE_SET;
        _OI_HELPIDX(pHdrItem) = IDH_DEVPROP_TVROOT;
        break;

    case (ULONG_PTR)CPSUI_PDLGPAGE_TREEVIEWONLY:

        cInitPage             =
        cPage                 = TVONLY_CDLGPAGE;
        iPage                 = TVONLY_PDLGPAGE_START;
        pHdrItem->UserData    = IDS_INT_CPSUI_SETTINGS;
        _OI_HELPIDX(pHdrItem) = IDH_STD_TVROOT;

        break;

    default:

        if (cPage = (UINT)pTVWnd->ComPropSheetUI.cDlgPage) {

            if (!VALID_PTR(pDP)) {

                return(ERR_CPSUI_INVALID_PDLGPAGE);
            }

        } else {

            return(0);
        }

        cInitPage = cPage;
        iPage     = -1;

        break;
    }

    if ((cPage + cCurPages) > MAXPROPPAGES) {

        return(ERR_CPSUI_TOO_MANY_PROPSHEETPAGES);
    }

    cb                     = (UINT)(cPage * sizeof(MYDLGPAGE));
    pTVWnd->cInitMyDlgPage = (BYTE)cInitPage;
    pTVWnd->cMyDlgPage     = (BYTE)cPage;

    if (!(pMyDP = pTVWnd->pMyDlgPage = (PMYDLGPAGE)LocalAlloc(LPTR, cb))) {

        return(ERR_CPSUI_ALLOCMEM_FAILED);
    }

    if (iPage < 0) {

        InitMYDLGPAGE(pMyDP, pDP, cPage);

    } else {

        POPTITEM    pItem;
        POPTITEM    pLastItem;
        POPTITEM    pNextItem;
        WORD        cChildren;
        BYTE        DlgPageIdx;
        BYTE        CurDMPubID;
        BYTE        CurLevel;


        cb = cPage;

        while (cb--) {

            pMyDP->ID                    = MYDP_ID;
            pMyDP->DlgPage.cbSize        = sizeof(DLGPAGE);
            pMyDP->DlgPage.Flags         = 0;
            pMyDP->DlgPage.DlgProc       = NULL;
            pMyDP->DlgPage.pTabName      = (LPTSTR)StdDlgPage[iPage].IDSTabName;
            pMyDP->DlgPage.DlgTemplateID = StdDlgPage[iPage].DlgTemplateID;
            pMyDP->DlgPage.IconID        = (StdDlgPage[iPage].UseHdrIconID) ?
                                                    (DWORD)pHdrItem->Sel : 0;
            pMyDP++;
            iPage++;
        }

        pItem     = pTVWnd->ComPropSheetUI.pOptItem;
        pLastItem = pTVWnd->pLastItem;

        while (pItem <= pLastItem) {

            DWORD   FlagsClear;
            DWORD   FlagsSet;

            FlagsClear =
            FlagsSet   = 0;
            CurDMPubID = pItem->DMPubID;
            CurLevel   = pItem->Level;

            if (ChkDMPub) {

                switch (CurDMPubID) {

                case DMPUB_NUP:

                    FlagsSet   |= OPTIF_NO_GROUPBOX_NAME;
                    DlgPageIdx  = 0;
                    break;

                case DMPUB_ORIENTATION:
                case DMPUB_PAGEORDER:
                case DMPUB_DUPLEX:

                    FlagsClear |= OPTIF_NO_GROUPBOX_NAME;
                    DlgPageIdx  = 0;
                    break;

                case DMPUB_DEFSOURCE:

                    FlagsSet   |= OPTIF_NO_GROUPBOX_NAME;
                    DlgPageIdx  = (cPage > 1) ? 1 : 0;
                    break;

                case DMPUB_COPIES_COLLATE:

                    pItem->pOptType->pOptParam[0].pData =
                                (LPTSTR)((ULONG_PTR)((pItem->Sel <= 1) ? IDS_CPSUI_COPY :
                                                              IDS_CPSUI_COPIES));

                    if ((!(pItem->Flags & OPTIF_EXT_HIDE)) &&
                        (pItem->pExtChkBox)) {

                        if (pItem->Sel <= 1) {

                            FlagsSet |= OPTIF_EXT_DISABLED;

                        } else {

                            FlagsClear |= OPTIF_EXT_DISABLED;
                        }
                    }

                    FlagsClear |= OPTIF_NO_GROUPBOX_NAME;
                    DlgPageIdx  = cPage - 1;
                    break;


                case DMPUB_COLOR:
                case DMPUB_MEDIATYPE:
                case DMPUB_QUALITY:
                case DMPUB_OUTPUTBIN:

                    FlagsClear |= OPTIF_NO_GROUPBOX_NAME;
                    DlgPageIdx  = (cPage > 1) ? 1 : 0;
                    break;

                default:

                    DlgPageIdx = cPage - 1;
                    break;
                }

            } else {

                DlgPageIdx = 0;
            }

            //
            // Set the correct flags and DlgPageIdx for the item and all of
            // its children
            //

            do {

                BYTE    DMPubID;

                pItem->Flags      = (pItem->Flags & ~FlagsClear) | FlagsSet;
                pItem->DlgPageIdx = DlgPageIdx;

                if (((DMPubID = pItem->DMPubID) < DMPUB_USER) &&
                    (DMPubID != DMPUB_NONE)) {

                    pItem->DMPubID = CurDMPubID;
                }

                CPSUIOPTITEM(DBGITEM_SDP, pTVWnd, "SetDlgPage", 1, pItem);

            } WHILE_SKIP_CHILDREN(pItem, pLastItem, CurLevel);
        }
    }

    if (ChkDMPub) {

        SetStdPropPageID(pTVWnd);
    }

    return(cPage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\proppage.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    proppage.c


Abstract:

    This module contains user page procs


Author:

    18-Aug-1995 Fri 18:57:12 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#define DBG_CPSUIFILENAME   DbgPropPage



#define DBG_PROPPAGEPROC    0x00000001
#define DBG_INITP1          0x00000002
#define DBGITEM_INITP1      0x00000004
#define DBGITEM_UP1         0x00000008
#define DBG_HMII            0x00000010
#define DBG_AII             0x00000020
#define DBG_QSORT           0x00000040
#define DBG_SETFOCUS        0x00000080
#define DBG_STATES          0x00000100
#define DBG_ADVPUSH         0x00000200


DEFINE_DBGVAR(0);


extern HINSTANCE    hInstDLL;
extern STDPAGEINFO  StdPageInfo[];
extern BYTE         StdTVOT[];

#define MAX_ITEM_CTRLS  12

const BYTE  cTVOTCtrls[] = { 8, 10, 9, 9, 9, 6, 6, 8, 6, 6, 0 };


#define IIF_3STATES_1       OTINTF_STATES_1
#define IIF_3STATES_2       OTINTF_STATES_2
#define IIF_3STATES_3       OTINTF_STATES_3
#define IIF_3STATES_HIDE    OTINTF_STATES_HIDE_MASK
#define IIF_STDPAGE_3STATES OTINTF_STDPAGE_3STATES
#define IIF_ITEM_HIDE       0x10
#define IIF_EXT_HIDE        0x20

typedef struct _ITEMINFO {
    POPTITEM    pItem;
    BYTE        Flags;
    BYTE        Type;
    WORD        BegCtrlID;
    WORD        CtrlBits;
    SHORT       xExtMove;
    WORD        yExt;
    WORD        yMoveUp;
    WORD        Extra;
    RECT        rc;
    RECT        rcCtrls;
    } ITEMINFO, *PITEMINFO;

typedef struct _ITEMINFOHEADER {
    HWND        hDlg;
    PTVWND      pTVWnd;
    WORD        cItem;
    WORD        cMaxItem;
    ITEMINFO    ItemInfo[1];
    } ITEMINFOHEADER, *PITEMINFOHEADER;


#define OUTRANGE_LEFT       0x7FFFFFFFL
#define INIT_ADDRECT(rc)    ((rc).left = OUTRANGE_LEFT)
#define HAS_ADDRECT(rc)     ((rc).left != OUTRANGE_LEFT)


typedef struct _HSINFO {
    HWND    hCtrl;
    LONG    x;
    LONG    y;
    } HSINFO, *PHSINFO;


INT
__cdecl
ItemInfoCompare(
    const void  *pItemInfo1,
    const void  *pItemInfo2
    )
{
    return((INT)(((PITEMINFO)pItemInfo1)->rc.top) -
           (INT)(((PITEMINFO)pItemInfo2)->rc.top));
}





UINT
AddRect(
    RECT    *prc1,
    RECT    *prc2
    )

/*++

Routine Description:

    This function add the *prc1 to *prc2, if any of the prc1 corners are
    outside of prc2

Arguments:




Return Value:

    UINT, count of *prc1 corners which is at outside of *prc2 corners, other
    word is the *prc2 corners which added to the *prc2 corner that is.


Author:

    16-Sep-1995 Sat 23:06:53 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    UINT    cAdded = 0;


    if (prc2->left == OUTRANGE_LEFT) {

        *prc2 = *prc1;
        return(0);

    } else {

        CPSUIASSERT(0, "AddRect: invalid rc.left=%d",
                (prc2->left >= 0) && (prc2->top >= 0)   &&
                (prc2->right >= prc2->left) && (prc2->bottom >= prc2->top),
                LongToPtr(prc2->left));
    }

    if (prc2->left > prc1->left) {

        prc2->left = prc1->left;
        ++cAdded;
    }

    if (prc2->top > prc1->top) {

        prc2->top = prc1->top;
        ++cAdded;
    }

    if (prc2->right < prc1->right) {

        prc2->right = prc1->right;
        ++cAdded;
    }

    if (prc2->bottom < prc1->bottom) {

        prc2->bottom = prc1->bottom;
        ++cAdded;
    }

    return(cAdded);
}




UINT
HideStates(
    HWND        hDlg,
    PITEMINFO   pII,
    RECT        *prcVisibleNoStates
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Aug-1995 Tue 16:58:37 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PHSINFO pHSInfo;
    HSINFO  HSInfo[6];
    HWND    hCurCtrl;
    UINT    HideBits;
    UINT    Mask;
    UINT    CtrlID = (UINT)(pII->BegCtrlID + 2);
    RECT    rcStates;
    RECT    rcMax[3];
    UINT    yRemoved = 0;
    SIZEL   szlHide;
    SIZEL   szlSpace;
    INT     cStates;
    INT     cHide;
    INT     i;
    INT     j;
    BOOL    DoXDir;



    szlSpace.cx =
    szlSpace.cy =
    szlHide.cx  =
    szlHide.cy  = 0;
    cStates     = (UINT)((pII->Type == TVOT_2STATES) ? 2 : 3);
    HideBits    = (UINT)(pII->Flags & IIF_3STATES_HIDE);

    CPSUIDBG(DBG_STATES, ("\ncStates=%ld, HideBits=%02lx", cStates, HideBits));

    INIT_ADDRECT(rcStates);

    for (i = 0, cHide = 0, Mask = HideBits, pHSInfo = HSInfo;
         i < cStates;
         i++, Mask >>= 1) {

        INIT_ADDRECT(rcMax[i]);

        for (j = 0; j < 2; j++, pHSInfo++) {

            RECT    rc;

            if (hCurCtrl = CtrlIDrcWnd(hDlg, CtrlID++, &rc)) {

                CPSUIDBG(DBG_STATES,
                         ("MoveStates: States=(%d:%d), ID=%d, Hide=%d",
                                i, j, CtrlID - 1, (Mask & 0x01) ? 1 : 0));

                pHSInfo->hCtrl = hCurCtrl;

                if (Mask & 0x01) {

                    CPSUIDBG(DBG_STATES, ("Hide the State %d", i));
                }

                pHSInfo->x = rc.left;
                pHSInfo->y = rc.top;

                AddRect(&rc, &rcMax[i]);

                CPSUIDBG(DBG_STATES, ("i=%ld, j=%ld, rc=(%ld, %ld)-(%ld, %ld)=%ldx%ld",
                            i, j, rc.left, rc.top, rc.right, rc.bottom,
                            rc.right - rc.left, rc.bottom - rc.top));
            }
        }

        if (HAS_ADDRECT(rcMax[i])) {

            CPSUIRECT(0, "rcMax", &rcMax[i], i, 0);

            if (i) {

                if (rcMax[i].top > rcMax[i - 1].bottom) {

                    yRemoved++;
                }

                szlSpace.cx += (rcMax[i].left - rcMax[i - 1].right);
                szlSpace.cy += (rcMax[i].top - rcMax[i - 1].bottom);
            }

            AddRect(&rcMax[i], &rcStates);

            if (Mask & 0x01) {

                CPSUIDBG(DBG_STATES, ("Hide i=%ld, szlHide.cy=%ld",
                            i, szlHide.cy));

                if (i) {

                    szlHide.cy += (rcMax[i].top - rcMax[i - 1].bottom);
                }

                szlHide.cx += rcMax[i].right - rcMax[i].left;
                szlHide.cy += rcMax[i].bottom - rcMax[i].top;

                if (++cHide == cStates) {

                    CPSUIASSERT(0, "Error: HideStates(HIDE EVERY THING)=%d",
                                                cHide < cStates, UIntToPtr(cHide));
                    return(0);
                }
            }
        }
    }

    CPSUIDBG(DBG_STATES, ("rcStates=(%ld, %ld)-(%ld, %ld)=%ldx%ld",
                rcStates.left, rcStates.top, rcStates.right, rcStates.bottom,
                rcStates.right - rcStates.left, rcStates.bottom - rcStates.top));
    CPSUIDBG(DBG_STATES,
             ("szlHide=%ldx%ld, szlSpace=%ldx%ld, yReMoved=%ld",
                szlHide.cx, szlHide.cy, szlSpace.cx, szlSpace.cy, yRemoved));

    if (yRemoved) {

        szlSpace.cy /= yRemoved;

        //
        // If we arrange top/down and we do not intersect with the visible
        // bits then we can remove the y space
        //

        if ((rcStates.top >= prcVisibleNoStates->bottom) ||
            (rcStates.bottom <= prcVisibleNoStates->top)) {

            //
            // We can remove the Y line now
            //

            rcStates.bottom -= (yRemoved = szlHide.cy);
            szlHide.cy       = 0;

            CPSUIDBG(DBG_STATES,
                     ("HideStates: OK to remove Y, yRemoved=%ld", yRemoved));

        } else {

            yRemoved = 0;

            //
            // Do not remove Y spaces, just arrange it
            //

            CPSUIINT(("---- STATES: CANNOT remove Y space, Re-Arrange it ---"));
        }

        DoXDir      = FALSE;
        szlHide.cx  =
        szlHide.cy  = 0;
        szlSpace.cx = 0;

    } else {

        DoXDir      = TRUE;
        szlHide.cy  =
        szlSpace.cy = 0;
    }

    switch (cStates - cHide) {

    case 1:

        //
        // Only one state left, just center it
        //

        if (DoXDir) {

            szlHide.cx  = ((szlSpace.cx + szlHide.cx) / 2);
        }

        break;

    case 2:

        if (DoXDir) {

            szlHide.cx   = ((szlHide.cx + 1) / 3);
            szlSpace.cx += szlHide.cx;
        }

        break;
    }

    rcStates.left += szlHide.cx;
    rcStates.top  += szlHide.cy;

    CPSUIDBG(DBG_STATES,
            ("State1=(%ld, %ld): szlHide=%ld x %ld, szlSpace=%ld x %ld, DoXDir=%ld",
            rcStates.left, rcStates.top,
            szlHide.cx, szlHide.cy, szlSpace.cx, szlSpace.cy, DoXDir));

    for (i = 0, Mask = HideBits, pHSInfo = HSInfo;
         i < cStates;
         i++, Mask >>= 1) {

        if (Mask & 0x01) {

            pHSInfo += 2;

        } else {

            for (j = 0; j < 2; j++, pHSInfo++) {

                if (hCurCtrl = pHSInfo->hCtrl) {

                    szlHide.cx = pHSInfo->x - rcMax[i].left;
                    szlHide.cy = pHSInfo->y - rcMax[i].top;

                    CPSUIDBG(DBG_STATES,
                             ("HideStates: MOVE(%d:%d) from (%ld, %ld) to (%ld, %ld)",
                                i,  j,  pHSInfo->x, pHSInfo->y,
                                rcStates.left + szlHide.cx,
                                rcStates.top + szlHide.cy));

                    SetWindowPos(hCurCtrl, NULL,
                                 rcStates.left + szlHide.cx,
                                 rcStates.top  + szlHide.cy,
                                 0, 0,
                                 SWP_NOSIZE | SWP_NOZORDER);
                }
            }

            if (DoXDir) {

                rcStates.left += (szlSpace.cx + rcMax[i].right - rcMax[i].left);

            } else {

                rcStates.top += (szlSpace.cy + rcMax[i].bottom - rcMax[i].top);
            }
        }
    }

    return(yRemoved);
}



VOID
AddItemInfo(
    PITEMINFOHEADER pIIHdr,
    POPTITEM        pItem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Sep-1995 Sat 17:27:01 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hDlg;
    WORD        Mask;
    WORD        HideBits;
    WORD        ExtBits;
    WORD        NonStatesBits;
    UINT        CurCtrlID;
    UINT        cCtrls;
    UINT        cStates;
    RECT        rcVisible;
    RECT        rcVisibleNoStates;
    RECT        rcExt;
    RECT        rcGrpBox;
    ITEMINFO    II;


    if (pItem) {

        POPTTYPE    pOptType;


        II.Flags = (pItem->Flags & OPTIF_ITEM_HIDE) ? IIF_ITEM_HIDE : 0;

        if ((pItem->Flags & OPTIF_EXT_HIDE) ||
            (!pItem->pExtChkBox)) {

            II.Flags |= IIF_EXT_HIDE;
        }

        if (pOptType = pItem->pOptType) {

            II.BegCtrlID = (WORD)pOptType->BegCtrlID;


            if (((II.Type = pOptType->Type) == TVOT_2STATES) ||
                (II.Type == TVOT_3STATES)) {

                II.Flags |= (_OT_FLAGS(pOptType) &
                             (IIF_3STATES_HIDE | IIF_STDPAGE_3STATES));
            }

        } else {

            II.Type      = TVOT_NONE;
            II.BegCtrlID = 0;
        }

    } else {

        //
        // Some Flags/Type/BegCtrlID and of the stuff already set in here
        //

        II = pIIHdr->ItemInfo[pIIHdr->cItem];
    }

    if (II.Flags & IIF_STDPAGE_3STATES) {

        II.Type = TVOT_3STATES;
    }

    CurCtrlID    = II.BegCtrlID;
    cCtrls       = (UINT)cTVOTCtrls[II.Type];
    II.pItem     = pItem;
    II.CtrlBits  = 0;
    II.xExtMove  = 0;
    II.yExt      = 0;
    II.yMoveUp   = 0;
    hDlg         = pIIHdr->hDlg;

    INIT_ADDRECT(II.rc);
    INIT_ADDRECT(rcExt);
    INIT_ADDRECT(rcVisible);
    INIT_ADDRECT(rcGrpBox);
    INIT_ADDRECT(rcVisibleNoStates);

    HideBits = 0;

    if ((II.Flags & IIF_3STATES_HIDE) &&
        (!(II.Flags & IIF_ITEM_HIDE))) {

        if (II.Flags & IIF_3STATES_1) {

            HideBits |= 0x0c;
        }

        if (II.Flags & IIF_3STATES_2) {

            HideBits |= 0x30;
        }

        if (II.Flags & IIF_3STATES_3) {

            HideBits |= 0xc0;
        }

        NonStatesBits = 0xff03;

    } else {

        NonStatesBits = 0;
    }

    if (II.Flags & IIF_EXT_HIDE) {

        ExtBits   = (WORD)(3 << (cCtrls - 2));
        HideBits |= ExtBits;

    } else {

        ExtBits = 0;
    }

    CPSUIINT(("   !! HideBits=%04lx, NonStateBits=%04lx, ExtBits=%04lx",
                                            HideBits, NonStatesBits, ExtBits));


    Mask = 0x0001;

    while (cCtrls--) {

        HWND    hCtrl;
        RECT    rc;


        //
        // We only count this ctrl's rectangle if it is vaild and visible
        //

        if (hCtrl = CtrlIDrcWnd(hDlg, CurCtrlID, &rc)) {

            CPSUIRECT(0, "AddItemInfo", &rc, cCtrls, CurCtrlID);

            if (Mask == 0x0001) {

                rcGrpBox = rc;

            } else {

                if (HideBits & Mask) {

                    ShowWindow(hCtrl, SW_HIDE);
                    EnableWindow(hCtrl, FALSE);

                } else {

                    AddRect(&rc, &rcVisible);

                    if (Mask & NonStatesBits) {

                        AddRect(&rc, &rcVisibleNoStates);
                    }
                }

                if (ExtBits & Mask) {

                    AddRect(&rc, &rcExt);
                }

                AddRect(&rc, &II.rc);
            }

            II.CtrlBits |= Mask;
        }

        Mask <<= 1;
        CurCtrlID++;
    }

    II.rcCtrls = II.rc;

    CPSUIRECT(0, "  rcGrpBox", &rcGrpBox,   0, 0);
    CPSUIRECT(0, "   rcCtrls", &II.rcCtrls, 0, 0);
    CPSUIRECT(0, "     rcExt", &rcExt,      0, 0);
    CPSUIRECT(0, "rcVisiable", &rcVisible,  0, 0);

    if (II.CtrlBits & 0x0001) {

        UINT    cAdded;

        if ((cAdded = AddRect(&rcGrpBox, &II.rc)) != 4) {

            CPSUIINT(("AddRect(&rcGrp, &II.rc)=%d", cAdded));
            CPSUIOPTITEM(DBG_AII, pIIHdr->pTVWnd,
                         "GroupBox too small", 1, pItem);
        }
    }

    if (HAS_ADDRECT(rcVisible)) {

        if ((II.Flags & IIF_3STATES_HIDE) &&
            (!(II.Flags & IIF_ITEM_HIDE))) {

            if (!HAS_ADDRECT(rcVisibleNoStates)) {

                rcVisibleNoStates.left   =
                rcVisibleNoStates.top    = 999999;
                rcVisibleNoStates.right  =
                rcVisibleNoStates.bottom = -999999;
            }

            CPSUIRECT(0, "rcVisiableNoStates", &rcVisibleNoStates, 0, 0);

            II.yExt += (WORD)HideStates(hDlg, &II, &rcVisibleNoStates);
        }

        if (HAS_ADDRECT(rcExt)) {

            //
            // We need to move all other controls and shrink the group
            // box if necessary
            //

            if (II.CtrlBits & 0x0001) {

                if (rcExt.left > rcVisible.right) {

                    //
                    // The extended are at right of the ctrls, move to right
                    //

                    II.xExtMove = (SHORT)(rcExt.left - rcVisible.right);

                } else if (rcExt.right < rcVisible.left) {

                    //
                    // The extended are at left of the ctrls, move to left
                    //

                    II.xExtMove = (SHORT)(rcVisible.left - rcVisible.right);
                }

                //
                // distribute the move size on each side of the control
                //

                II.xExtMove /= 2;
            }

            if (rcExt.bottom > rcVisible.bottom) {

                //
                // The extended are at bottom of the ctrls, remove overlay
                //

                II.yExt += (WORD)(rcExt.bottom - rcVisible.bottom);
            }

            if (rcExt.top < rcVisible.top) {

                //
                // The extended are at top of the ctrls, remove that overlay
                //

                II.yExt += (WORD)(rcVisible.top - rcExt.top);
            }

            CPSUIINT(("!! Hide Extended(%d): xMove=%ld, yExt=%ld",
                            II.BegCtrlID, (LONG)II.xExtMove, (LONG)II.yExt));
        }


    } else {

        II.Flags |= (IIF_ITEM_HIDE | IIF_EXT_HIDE);
    }


    if (pIIHdr->cItem >= pIIHdr->cMaxItem) {

        CPSUIERR(("AddItemInfo: Too many Items, Max=%ld", pIIHdr->cMaxItem));

    } else {

        pIIHdr->ItemInfo[pIIHdr->cItem++] = II;
    }
}



VOID
HideMoveII(
    HWND        hDlg,
    PITEMINFO   pII
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Sep-1995 Mon 12:56:06 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    ITEMINFO    II     = *pII;
    BOOL        GrpBox = TRUE;


    if ((!(II.Flags & IIF_ITEM_HIDE))   &&
        (II.xExtMove == 0)              &&
        (II.yExt == 0)                  &&
        (II.yMoveUp == 0)) {

        return;
    }
    CPSUIINT(("\n%hs Item: Flags=%04x, CtrlBits=%04lx, xExt=%d, yExt=%d, yMoveUp=%d",
                        (II.Flags & IIF_ITEM_HIDE) ? "HIDE" : "MOVE",
                II.Flags, II.CtrlBits, II.xExtMove, II.yExt, II.yMoveUp));
    CPSUIRECT(DBG_HMII, "II.rcCtrls", &II.rcCtrls, II.BegCtrlID, 0);
    CPSUIRECT(DBG_HMII, "     II.rc", &II.rc, II.BegCtrlID, 0);
    CPSUIOPTITEM(DBG_HMII, GET_PTVWND(hDlg), "HideMoveII", 1, II.pItem);

    while (II.CtrlBits) {

        HWND    hCtrl;


        if ((II.CtrlBits & 0x0001) &&
            (hCtrl = GetDlgItem(hDlg, II.BegCtrlID))) {

            RECT    rc;


            if (II.Flags & IIF_ITEM_HIDE) {

                ShowWindow(hCtrl, SW_HIDE);
                EnableWindow(hCtrl, FALSE);

                CPSUIINT((" HIDE Ctrls ID=%d", II.BegCtrlID));
            } else {

                hCtrlrcWnd(hDlg, hCtrl, &rc);

                if (GrpBox) {

                    if ((II.yExt) || (II.yMoveUp)) {

                        CPSUIINT(("Move GrpBox ID=%5d, Y: %ld -> %ld, cy: %ld -> %ld",
                                II.BegCtrlID, rc.top,
                                rc.top - II.yMoveUp, rc.bottom - rc.top,
                                rc.bottom - rc.top - (LONG)II.yExt));

                        SetWindowPos(hCtrl, NULL,
                                     rc.left, rc.top - II.yMoveUp,
                                     rc.right - rc.left,
                                     rc.bottom - rc.top - (LONG)II.yExt,
                                     SWP_NOZORDER);
                    }

                } else if ((II.xExtMove) || (II.yMoveUp)) {

                    //
                    // We only need to move xExtMove if it is not group box
                    // and also do the yMoveUp
                    //

                    CPSUIINT((" Move Ctrls ID=%5d, (%ld, %d) -> (%ld, %ld)",
                            II.BegCtrlID, rc.left, rc.top,
                            rc.left + (LONG)II.xExtMove,
                            rc.top - (LONG)II.yMoveUp));

                    SetWindowPos(hCtrl, NULL,
                                 rc.left + (LONG)II.xExtMove,
                                 rc.top - (LONG)II.yMoveUp,
                                 0, 0,
                                 SWP_NOSIZE | SWP_NOZORDER);
                }
            }
        }

        GrpBox        = FALSE;
        II.CtrlBits >>= 1;
        II.BegCtrlID++;
    }
}




VOID
HideMoveType(
    HWND    hDlg,
    UINT    BegCtrlID,
    UINT    Type
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    19-Sep-1995 Tue 21:01:55 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    ITEMINFO    II;
    UINT        cCtrls;


    cCtrls       = (UINT)cTVOTCtrls[Type];
    II.Flags     = IIF_ITEM_HIDE | IIF_EXT_HIDE;
    II.BegCtrlID = (WORD)BegCtrlID;
    II.CtrlBits  = (WORD)(0xFFFF >> (16 - cCtrls));

    HideMoveII(hDlg, &II);
}





INT
HideMovePropPage(
    PITEMINFOHEADER pIIHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Sep-1995 Mon 01:25:53 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hDlg;
    PITEMINFO   pII;
    PITEMINFO   pIIEnd;
    UINT        yMoveUp;
    UINT        yLastTop;
    UINT        cItem;


    //
    // firstable, sort all the item based on the rc.top of each item
    //

    qsort(pII = pIIHdr->ItemInfo,
          cItem = (UINT)pIIHdr->cItem,
          sizeof(ITEMINFO),
          ItemInfoCompare);

    pIIEnd   = pII + cItem;
    yMoveUp  = 0;
    yLastTop = (UINT)pII->rc.top;
    hDlg     = pIIHdr->hDlg;

    CPSUIDBGBLK({

        UINT        i = cItem;
        PITEMINFO   pIITmp = pII;

        CPSUIDBG(DBG_QSORT, ("qsort: cItem = %d", cItem));

        while (i--) {

            CPSUIRECT(DBG_QSORT, "QSort", &pIITmp->rc, pIITmp->BegCtrlID, 0);

            CPSUIOPTITEM(DBG_QSORT, pIIHdr->pTVWnd,
                         "Sorted Item RECT", 1, pIITmp->pItem);
            pIITmp++;
        }
    })

    while (pII < pIIEnd) {

        PITEMINFO   pIIBeg;
        PITEMINFO   pIIBegSave;
        RECT        rcBeg;
        UINT        cHide;
        UINT        cII;
        UINT        cyCurHide;
        UINT        yBegExt;
        UINT        yGrpBoxShrink;
        UINT        yGrpHideMoveUp;
        INT         GrpBox;


        //
        // Do the group item first assume we do not need to hide the group
        // box, and skip the space between group box and first control, The
        // first group's top is the first control's top
        //

        pIIBegSave =
        pIIBeg     = pII;
        rcBeg      = pIIBeg->rc;
        cHide      = 0;
        GrpBox     = 1;

        //
        // yLastTop < 0 means the last group is totally hide and it need to
        // delete the space between last group end and this group begin
        //

        if (yLastTop == (UINT)0xFFFF) {

            yLastTop = 0;

        } else {

            yLastTop = (UINT)(rcBeg.top - yLastTop);
        }

        yGrpBoxShrink   = 0;
        yMoveUp        += yLastTop;
        yGrpHideMoveUp  = (UINT)(yMoveUp + (rcBeg.bottom - rcBeg.top));
        yLastTop        = rcBeg.top;

        do {

            CPSUIINT(("Item: yLastTop=%ld, yGrpBoxShrink=%d, yMoveUp=%d",
                                yLastTop, yGrpBoxShrink, yMoveUp));

            if (pII->rc.bottom > rcBeg.bottom) {

                CPSUIOPTITEM(DBG_HMII, pIIHdr->pTVWnd, "Item Ctrls Overlay",
                             1, pII->pItem);

                CPSUIASSERT(0, "Item ctrls overlay",
                            pII->rc.bottom <= rcBeg.bottom, LongToPtr(pII->rc.bottom));
            }

            if (pII->Flags & IIF_ITEM_HIDE) {

                cyCurHide = (UINT)(pII->rc.top - yLastTop);
                ++cHide;

            } else {

                cyCurHide    = pII->yExt;
                pII->yMoveUp = (WORD)yMoveUp;
            }

            yGrpBoxShrink += cyCurHide;
            yMoveUp       += cyCurHide;
            yLastTop       = (GrpBox-- > 0) ? pII->rcCtrls.top : pII->rc.top;

        } while ((++pII < pIIEnd) && (pII->rc.top < rcBeg.bottom));


        CPSUIINT(("FINAL: yLastTop=%ld, yGrpBoxShrink=%d, yMoveUp=%d",
                                    yLastTop, yGrpBoxShrink, yMoveUp));

        //
        // Now check if we have same hide item
        //

        if (cHide == (cII = (UINT)(pII - pIIBeg))) {

            //
            // Hide them all and add in the extra yMoveUp for the the space
            // between group box and the first control which we reduced out
            // front.
            //

            yMoveUp  = yGrpHideMoveUp;
            yLastTop = rcBeg.bottom;

            CPSUIINT(("Hide ALL items = %d, yMoveUp Change to %ld",
                                                    cHide, yMoveUp));

            while (cHide--) {

                HideMoveII(hDlg, pIIBegSave++);
            }

        } else {

            CPSUIINT(("!! Grpup Items cII=%d !!", cII));

            //
            // We need to enable the group box and shrink it too
            //

            if (pIIBeg->Flags & IIF_ITEM_HIDE) {

                pIIBeg->yExt     += (WORD)yGrpBoxShrink;
                pIIBeg->Flags    &= ~IIF_ITEM_HIDE;
                pIIBeg->CtrlBits &= 0x01;

            } else {

                pIIBeg->yExt = (WORD)yGrpBoxShrink;
            }

            while (cII--) {

                HideMoveII(hDlg, pIIBegSave++);
            }

            yLastTop = 0xFFFF;
        }
    }

    return(yMoveUp);
}



LONG
UpdatePropPageItem(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem,
    BOOL        DoInit
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    31-Aug-1995 Thu 23:53:44 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hCtrl;
    POPTTYPE    pOptType;
    POPTPARAM   pOptParam;
    LONG        Sel;
    UINT        Type;
    UINT        BegCtrlID;
    UINT        SetCurSelID;
    UINT        cSetIcon;
    UINT        ExtID;
    UINT        UDArrowHelpID = 0;
    LONG        Result = 1;
    WORD        InitItemIdx;
    WORD        InitFlags;
    BYTE        CtrlData = 0;
    BOOL        CanUpdate;


    InitItemIdx = (WORD)(pItem - pTVWnd->ComPropSheetUI.pOptItem);
    pOptType    = pItem->pOptType;
    pOptParam   = pOptType->pOptParam;
    BegCtrlID   = (UINT)pOptType->BegCtrlID;
    Sel         = pItem->Sel;
    Type        = (UINT)pOptType->Type;

    //
    // If we have push button, and it said we always can call it then update
    // is true
    //

    if ((Type == TVOT_PUSHBUTTON) &&
        (pOptType->Flags & OTS_PUSH_ENABLE_ALWAYS)) {

        CanUpdate = TRUE;

    } else {

        CanUpdate = (BOOL)(pTVWnd->Flags & TWF_CAN_UPDATE);
    }

    if ((pItem->Flags & OPTIF_DISABLED) || (!CanUpdate)) {

        InitFlags = 0;

    } else {

        InitFlags = INITCF_ENABLE;
    }

    if (DoInit) {

        InitFlags |= (INITCF_INIT | INITCF_SETCTRLDATA);

        for (cSetIcon = 0; cSetIcon < (UINT)cTVOTCtrls[Type]; cSetIcon++) {

            if (hCtrl = GetDlgItem(hDlg, BegCtrlID++)) {

                //
                // This prevent to overwrite GWLP_USERDATA for the WNDPROC
                // saved for the hEdit
                //

                SETCTRLDATA(hCtrl, CTRLS_PROPPAGE_STATIC, (BYTE)cSetIcon);

                CPSUIINT(("SETCTRLDATA: %ld, hCtrl=%08lx, USER_DATA=%p",
                        BegCtrlID - 1, hCtrl,
                        GetWindowLongPtr(hCtrl, GWLP_USERDATA)));

#if 0
                if ((Type != TVOT_UDARROW) &&
                    (cSetIcon != 6)) {

                    SETCTRLDATA(hCtrl, CTRLS_PROPPAGE_STATIC, (BYTE)cSetIcon);
                }
#endif
            }
        }

        BegCtrlID = (UINT)pOptType->BegCtrlID;
    }

    //
    // We always set at least one icon
    //

    cSetIcon = 1;
    ExtID    = (UINT)(BegCtrlID + cTVOTCtrls[Type] - 2);

    INIT_EXTENDED(pTVWnd,
                  hDlg,
                  pItem,
                  ExtID,
                  ExtID,
                  ExtID + 1,
                  InitItemIdx,
                  InitFlags);

    if (pOptType->Flags & OPTTF_TYPE_DISABLED) {

        InitFlags &= ~INITCF_ENABLE;
    }

    switch(Type) {

    case TVOT_3STATES:
    case TVOT_2STATES:

        //
        // If this internal flag is set then this is a standard page which
        // always has a 3 states contrl ID but the caller's POPTTYPE only
        // presendt as TVOT_2STATES
        //

        if (_OT_FLAGS(pOptType) & OTINTF_STDPAGE_3STATES) {

            ExtID = (UINT)(BegCtrlID + cTVOTCtrls[TVOT_3STATES] - 2);
        }

        InitStates(pTVWnd,
                   hDlg,
                   pItem,
                   pOptType,
                   BegCtrlID + 2,
                   InitItemIdx,
                   (LONG)Sel,
                   InitFlags);

        if (InitFlags & INITCF_INIT) {

            cSetIcon = pOptType->Count;
            CtrlData = 0;

        } else {

            CtrlData   = (BYTE)Sel;
            pOptParam += Sel;
            BegCtrlID += (Sel << 1);
        }

        InitFlags |= INITCF_ICON_NOTIFY;

        break;

    case TVOT_UDARROW:

        if ((Result = InitUDArrow(pTVWnd,
                                  hDlg,
                                  pItem,
                                  pOptParam,
                                  BegCtrlID + 6,
                                  BegCtrlID + 2,
                                  BegCtrlID + 4,
                                  UDArrowHelpID = BegCtrlID + 5,
                                  InitItemIdx,
                                  Sel,
                                  InitFlags)) < 0) {

            return(Result);
        }
        break;

    case TVOT_TRACKBAR:
    case TVOT_SCROLLBAR:

        InitFlags |= INITCF_ADDSELPOSTFIX;
        hCtrl = GetDlgItem(hDlg, BegCtrlID + 2);

        if (Type == TVOT_TRACKBAR) {

            hCtrl = GetWindow(hCtrl, GW_HWNDNEXT);
        }

        InitTBSB(pTVWnd,
                 hDlg,
                 pItem,
                 hCtrl,
                 pOptType,
                 BegCtrlID + 6,
                 BegCtrlID + 4,
                 BegCtrlID + 5,
                 InitItemIdx,
                 Sel,
                 InitFlags);

        break;

    case TVOT_LISTBOX:
    case TVOT_COMBOBOX:

        SetCurSelID = LB_SETCURSEL;

        if (Type == TVOT_LISTBOX) {

            if (pOptType->Style & OTS_LBCB_PROPPAGE_LBUSECB) {

                SetCurSelID = CB_SETCURSEL;
            }

        } else if (!(pOptType->Style & OTS_LBCB_PROPPAGE_CBUSELB)) {

            SetCurSelID = CB_SETCURSEL;
        }

        //
        // Always need to set this new state icon
        //

        if ((DWORD)pItem->Sel >= (DWORD)pOptType->Count) {

            pOptParam = &pTVWnd->OptParamNone;

        } else {

            pOptParam += (DWORD)pItem->Sel;
        }

        if (hCtrl = GetDlgItem(hDlg, BegCtrlID + 2)) {

            InvalidateRect(hCtrl, NULL, FALSE);
        }

        InitLBCB(pTVWnd,
                 hDlg,
                 pItem,
                 BegCtrlID + 2,
                 SetCurSelID,
                 pOptType,
                 InitItemIdx,
                 Sel,
                 InitFlags,
                 (UINT)_OT_ORGLBCBCY(pOptType));

        break;

    case TVOT_EDITBOX:

        InitEditBox(pTVWnd,
                    hDlg,
                    pItem,
                    pOptParam,
                    BegCtrlID + 2,
                    BegCtrlID + 4,
                    BegCtrlID + 5,
                    InitItemIdx,
                    (LPTSTR)(LONG_PTR)Sel,
                    InitFlags);
        break;

    case TVOT_PUSHBUTTON:

        InitPushButton(pTVWnd,
                       hDlg,
                       pItem,
                       (WORD)(BegCtrlID + 2),
                       InitItemIdx,
                       InitFlags);
        break;

    case TVOT_CHKBOX:

        InitFlags |= INITCF_ICON_NOTIFY;

        InitChkBox(pTVWnd,
                   hDlg,
                   pItem,
                   BegCtrlID + 2,
                   pItem->pName,
                   InitItemIdx,
                   (BOOL)Sel,
                   InitFlags);


        break;

    default:

        return(ERR_CPSUI_INVALID_TVOT_TYPE);
    }

    if (InitFlags & (INITCF_INIT | INITCF_ADDSELPOSTFIX)) {

        SetDlgPageItemName(hDlg, pTVWnd, pItem, InitFlags, UDArrowHelpID);
    }

    if (cSetIcon) {

        UINT    i;

        for (i = 0, BegCtrlID += 3;
             i < cSetIcon;
             i++, pOptParam++, CtrlData++, BegCtrlID += 2) {

            if (hCtrl = GetDlgItem(hDlg, BegCtrlID)) {

                WORD    IconMode = 0;

                if ((pItem->Flags & OPTIF_OVERLAY_WARNING_ICON) ||
                    (pOptParam->Flags & OPTPF_OVERLAY_WARNING_ICON)) {

                    IconMode |= MIM_WARNING_OVERLAY;
                }

                if ((pItem->Flags & (OPTIF_OVERLAY_STOP_ICON | OPTIF_HIDE)) ||
                    (pOptParam->Flags & OPTPF_OVERLAY_STOP_ICON)) {

                    IconMode |= MIM_STOP_OVERLAY;
                }

                if ((pItem->Flags & (OPTIF_OVERLAY_NO_ICON)) ||
                    (pOptParam->Flags & OPTPF_OVERLAY_NO_ICON)) {

                    IconMode |= MIM_NO_OVERLAY;
                }

                SetIcon(_OI_HINST(pItem),
                        hCtrl,
                        GET_ICONID(pOptParam, OPTPF_ICONID_AS_HICON),
                        MK_INTICONID(IDI_CPSUI_GENERIC_ITEM, IconMode),
                        32);

                if (InitFlags & INITCF_INIT) {

                    HCTRL_SETCTRLDATA(hCtrl, CTRLS_PROPPAGE_ICON, CtrlData);
                }

                if (InitFlags & INITCF_ICON_NOTIFY) {

                    DWORD   dw = (DWORD)GetWindowLongPtr(hCtrl, GWL_STYLE);

                    if (pOptParam->Flags & (OPTPF_DISABLED | OPTPF_HIDE)) {

                        dw &= ~SS_NOTIFY;

                    } else {

                        dw |= SS_NOTIFY;
                    }

                    SetWindowLongPtr(hCtrl, GWL_STYLE, (LONG)dw);
                }
            }
        }
    }

    return(Result);
}



LONG
InitPropPage(
    HWND        hDlg,
    PMYDLGPAGE  pCurMyDP
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    14-Jun-1995 Wed 15:30:28 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PITEMINFOHEADER pIIHdr = NULL;
    PSTDPAGEINFO    pSPI;
    PTVWND          pTVWnd;
    POPTITEM        pItem;
    POPTITEM        pLastItem;
    LONG            Result;
    WORD            StdPageHide[DMPUB_LAST];
    BYTE            CurPageIdx;
    UINT            i;
    UINT            BegCtrlID;
    UINT            Type;
    UINT            cStdPageHide = 0;
    UINT            cStatesHide = 0;
    UINT            cItem;
    UINT            cHide;


    pTVWnd     = (PTVWND)pCurMyDP->pTVWnd;
    CurPageIdx = pCurMyDP->PageIdx;
    pItem      = pTVWnd->ComPropSheetUI.pOptItem;
    pLastItem  = pTVWnd->pLastItem;
    cItem      = (UINT)pCurMyDP->cItem;
    cHide      = (UINT)pCurMyDP->cHide;

    if ((CurPageIdx == pTVWnd->StdPageIdx1) ||
        (CurPageIdx == pTVWnd->StdPageIdx2)) {

        //
        // Check if any our standard pages' controls are not present in the
        // pOptItem
        //

        for (i = 0, pSPI = StdPageInfo; i < DMPUB_LAST; i++, pSPI++) {

            POPTITEM    pDMPubItem;
            POPTTYPE    pOptType;
            WORD        Idx;


            if ((pSPI->StdPageID == CurPageIdx) &&
                (pSPI->BegCtrlID)) {

                if ((Idx = pTVWnd->DMPubIdx[i]) == 0xFFFF) {

                    ++cStdPageHide;

                } else {

                    pDMPubItem = pItem + Idx;
                    pOptType   = pDMPubItem->pOptType;

                    switch (pOptType->Type) {

                    case TVOT_2STATES:
                    case TVOT_3STATES:

                        if (_OT_FLAGS(pOptType) & OTINTF_STATES_HIDE_MASK) {

                            ++cStatesHide;
                        }

                        break;

                    default:

                        break;
                    }
                }
            }
        }
    }

    CPSUIDBG(DBG_INITP1,
             ("InitPropPage: PageIdx=%d, cItem=%d, cHide=%d, cStdPageHide=% (%d)",
                    CurPageIdx, cItem, cHide, cStdPageHide, cStatesHide));

    if ((cHide += cStdPageHide) || (cStatesHide)) {

        //
        // Some item in this page may have to hide
        //

        i = (UINT)(((cItem + cStdPageHide + cStatesHide) * sizeof(ITEMINFO)) +
                   sizeof(ITEMINFOHEADER));

        CPSUIINT(("Total ItemInfo allocated=%d, cb=%d", cItem+cStdPageHide, i));

        if (pIIHdr = LocalAlloc(LPTR, i)) {

            pIIHdr->hDlg     = hDlg;
            pIIHdr->pTVWnd   = pTVWnd;
            pIIHdr->cItem    = 0;
            pIIHdr->cMaxItem = (WORD)(cItem + cStdPageHide);

            //
            // Stop redraw everything
            //

            SendMessage(hDlg, WM_SETREDRAW, (WPARAM)FALSE, 0L);

        } else {

            CPSUIERR(("LocalAlloc(pIIHdr(%u)) failed, cannot move items", i));
        }
    }

    while (pItem <= pLastItem) {

        BYTE    CurLevel = pItem->Level;


        if (pItem->DlgPageIdx != CurPageIdx) {

            SKIP_CHILDREN(pItem, pLastItem, CurLevel);
            continue;
        }

        do {

            POPTTYPE    pOptType;

            if (pOptType = pItem->pOptType) {

                UINT    BegCtrlID = (UINT)pOptType->BegCtrlID;
                DWORD   cySize;


                --cItem;

                BegCtrlID = (UINT)pOptType->BegCtrlID;
                Type      = (UINT)pOptType->Type;

                if (pItem->Flags & OPTIF_ITEM_HIDE) {

                    --cHide;

                    if (!pIIHdr) {

                        HideMoveType(hDlg, BegCtrlID, Type);
                    }

                } else {

                    CPSUIOPTITEM(DBGITEM_INITP1, pTVWnd, "InitP1", 2, pItem);

                    //
                    // Checking anything need to done for the internal item
                    //

                    switch (Type) {

                    case TVOT_LISTBOX:

                        cySize = ReCreateLBCB(hDlg,
                                              BegCtrlID + 2,
                                              !(BOOL)(pOptType->Style &
                                                    OTS_LBCB_PROPPAGE_LBUSECB));

                        _OT_ORGLBCBCY(pOptType) = HIWORD(cySize);

                        break;

                    case TVOT_COMBOBOX:

                        cySize = ReCreateLBCB(hDlg,
                                              BegCtrlID + 2,
                                              (BOOL)(pOptType->Style &
                                                    OTS_LBCB_PROPPAGE_CBUSELB));

                        _OT_ORGLBCBCY(pOptType) = HIWORD(cySize);

                        break;

                    case TVOT_TRACKBAR:

                        if (!CreateTrackBar(hDlg, BegCtrlID + 2)) {

                            return(ERR_CPSUI_CREATE_TRACKBAR_FAILED);
                        }

                        break;

                    case TVOT_UDARROW:

                        if (!CreateUDArrow(hDlg,
                                           BegCtrlID + 2,
                                           BegCtrlID + 6,
                                           (LONG)pOptType->pOptParam[1].IconID,
                                           (LONG)pOptType->pOptParam[1].lParam,
                                           (LONG)pItem->Sel)) {

                            return(ERR_CPSUI_CREATE_UDARROW_FAILED);
                        }

                        break;
                    }

                    if ((Result = UpdatePropPageItem(hDlg,
                                                     pTVWnd,
                                                     pItem,
                                                     TRUE)) < 0) {

                        return(Result);
                    }
                }

                if (pIIHdr) {

                    //
                    // Add the item info header
                    //

                    AddItemInfo(pIIHdr, pItem);
                }
            }

        } WHILE_SKIP_CHILDREN(pItem, pLastItem, CurLevel);
    }

    CPSUIASSERT(0, "Error: mismatch visable items=%d", cItem == 0, UIntToPtr(cItem));

    if (cStdPageHide) {

        PITEMINFO   pII;

        if (pIIHdr) {

            pII = &(pIIHdr->ItemInfo[pIIHdr->cItem]);

            CPSUIINT(("cItem in ItemInfoHdr=%d", (UINT)pIIHdr->cItem));
        }

        for (i = 0, pSPI = StdPageInfo; i < DMPUB_LAST; i++, pSPI++) {

            if ((BegCtrlID = (UINT)pSPI->BegCtrlID) &&
                (pSPI->StdPageID == CurPageIdx)     &&
                (pTVWnd->DMPubIdx[i] == 0xFFFF)) {

                Type = (UINT)StdTVOT[pSPI->iStdTVOT + pSPI->cStdTVOT - 1];

                if (pIIHdr) {

                    CPSUIINT(("Add Extra DMPUB ID=%d, BegCtrID=%d ITEMINFO",
                                i, BegCtrlID));

                    pII->Flags     = IIF_ITEM_HIDE | IIF_EXT_HIDE ;
                    pII->Type      = (BYTE)Type;
                    pII->BegCtrlID = (WORD)BegCtrlID;

                    AddItemInfo(pIIHdr, NULL);
                    pII++;

                } else {

                    HideMoveType(hDlg, BegCtrlID, Type);
                }

                --cHide;
            }
        }
    }

    if ((cStdPageHide) || (cStatesHide)) {

        //
        // Now hide/move all page's item
        //
        if (pIIHdr) {

            HideMovePropPage(pIIHdr);
        }

        SendMessage(hDlg, WM_SETREDRAW, (WPARAM)TRUE, 0L);
        InvalidateRect(hDlg, NULL, FALSE);
    }

    if (pIIHdr) {

        LocalFree((HLOCAL)pIIHdr);
    }

    CPSUIASSERT(0, "Error: mismatch hide items=%d", cHide == 0, UIntToPtr(cHide));

    return(pCurMyDP->cItem);
}




LONG
UpdatePropPage(
    HWND        hDlg,
    PMYDLGPAGE  pCurMyDP
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    08-Aug-1995 Tue 15:37:16 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    INT cUpdated = 0;


    if (pCurMyDP->Flags & (MYDPF_CHANGED | MYDPF_REINIT)) {

        PTVWND      pTVWnd;
        POPTITEM    pItem;
        UINT        cItem;
        BYTE        CurPageIdx;
        BOOL        ReInit;


        pTVWnd     = (PTVWND)pCurMyDP->pTVWnd;
        CurPageIdx = (BYTE)pCurMyDP->PageIdx;
        pItem      = pTVWnd->ComPropSheetUI.pOptItem;
        cItem      = (UINT)pTVWnd->ComPropSheetUI.cOptItem;
        ReInit     = (BOOL)(pCurMyDP->Flags & MYDPF_REINIT);

        CPSUIDBG(DBGITEM_UP1, ("UpdatePropPage Flags (OPTIDX_INT_CHANGED)"));

        while (cItem--) {

            if ((pItem->pOptType)                   &&
                (pItem->DlgPageIdx == CurPageIdx)   &&
                (pItem->Flags & OPTIF_INT_CHANGED)) {

                CPSUIOPTITEM(DBGITEM_UP1, pTVWnd, "UpdatePage1", 1, pItem);

                UpdatePropPageItem(hDlg, pTVWnd, pItem, ReInit);

                pItem->Flags &= ~OPTIF_INT_CHANGED;
                ++cUpdated;
            }

            pItem++;
        }

        pCurMyDP->Flags &= ~(MYDPF_CHANGED | MYDPF_REINIT);
    }

    return((LONG)cUpdated);
}




LONG
CountPropPageItems(
    PTVWND  pTVWnd,
    BYTE    CurPageIdx
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Aug-1995 Tue 14:34:01 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PMYDLGPAGE  pCurMyDP;
    POPTITEM    pItem;
    POPTITEM    pLastItem;
    BOOL        IsTVPage;
    UINT        cHideItems = 0;
    UINT        cPageItems = 0;


    if (CurPageIdx >= pTVWnd->cMyDlgPage) {

        return(0);
    }

    pItem     = pTVWnd->ComPropSheetUI.pOptItem;
    pLastItem = pTVWnd->pLastItem;

    if (pTVWnd->Flags & TWF_HAS_ADVANCED_PUSH) {

        IsTVPage = FALSE;

    } else {

        IsTVPage  = (BOOL)(pTVWnd->TVPageIdx == CurPageIdx);
    }

    while (pItem <= pLastItem) {

        if (IsTVPage) {

            ++cPageItems;

            if (pItem->Flags & OPTIF_ITEM_HIDE) {

                ++cHideItems;
            }

        } else if (pItem->DlgPageIdx == CurPageIdx) {

            cPageItems++;

            if (pItem->Flags & OPTIF_ITEM_HIDE) {

                ++cHideItems;
            }
        }

        pItem++;
    }

    pCurMyDP        = pTVWnd->pMyDlgPage + CurPageIdx;
    pCurMyDP->cItem = (WORD)cPageItems;
    pCurMyDP->cHide = (WORD)cHideItems;

    CPSUIINT(("PageIdx=%ld, cItem=%ld, cHide=%ld",
                                    CurPageIdx, cPageItems, cHideItems));

    return((LONG)(cPageItems - cHideItems));
}



BOOL
CALLBACK
ChildWndCleanUp(
    HWND    hWnd,
    LPARAM  lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);

    if ((SendMessage(hWnd, WM_GETDLGCODE, 0, 0) & DLGC_STATIC) &&
        ((GetWindowLongPtr(hWnd, GWL_STYLE) & SS_TYPEMASK) == SS_ICON)) {

        HICON       hIcon;


        if (hIcon = (HICON)SendMessage(hWnd, STM_SETICON, 0, 0L)) {

            DestroyIcon(hIcon);
        }

        CPSUIINT(("ChildWndCleanUp: Static ID=%u, Icon=%08lx",
                                        GetDlgCtrlID(hWnd), hIcon));
    }

    return(TRUE);
}



BOOL
CALLBACK
FixIconChildTo32x32(
    HWND    hWnd,
    LPARAM  lParam
    )
{
    HWND    hDlg = (HWND)lParam;

    if ((SendMessage(hWnd, WM_GETDLGCODE, 0, 0) & DLGC_STATIC) &&
        ((GetWindowLongPtr(hWnd, GWL_STYLE) & SS_TYPEMASK) == SS_ICON)) {

        RECT    rc;

        hCtrlrcWnd(hDlg, hWnd, &rc);

        if (((rc.right - rc.left) != 32) ||
            ((rc.bottom - rc.top) != 32)) {

            CPSUIINT(("FixIcon32x32: Icon ID=%u, size=%ld x %ld, fix to 32x32",
                    GetDlgCtrlID(hWnd),
                    rc.right - rc.left, rc.bottom - rc.top));

            SetWindowPos(hWnd, NULL, 0, 0, 32, 32, SWP_NOMOVE | SWP_NOZORDER);
        }
    }

    return(TRUE);
}




VOID
MoveAdvancedPush(
    HWND    hDlg,
    UINT    EnlargeCtrlID,
    UINT    CenterCtrlID
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Aug-1998 Tue 10:30:55 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hTabCtrl;
    HWND    hCtrl;
    RECT    rcAdvPush;
    RECT    rcDlg;
    POINTL  ptl;


    if ((hTabCtrl = PropSheet_GetTabControl(GetParent(hDlg)))   &&
        (hCtrl = GetDlgItem(hDlg, ADVANCED_PUSH))) {

        GetWindowRect(hDlg, &rcDlg);

        CPSUIDBG(DBG_ADVPUSH, ("Prop Page Rect (before adjust)=(%ld, %ld) - (%ld, %ld)",
                    rcDlg.left, rcDlg.top, rcDlg.right, rcDlg.bottom));

        TabCtrl_AdjustRect(hTabCtrl, FALSE, &rcDlg);

        CPSUIDBG(DBG_ADVPUSH, ("Prop Page Rect (after adjust)=(%ld, %ld) - (%ld, %ld)",
                    rcDlg.left, rcDlg.top, rcDlg.right, rcDlg.bottom));

        GetWindowRect(hCtrl, &rcAdvPush);

        CPSUIDBG(DBG_ADVPUSH, ("Advanced Btn Rect=(%ld, %ld) - (%ld, %ld)",
                    rcAdvPush.left, rcAdvPush.top, rcAdvPush.right, rcAdvPush.bottom));

        ptl.y = rcDlg.bottom - (rcAdvPush.bottom - rcAdvPush.top);

        CPSUIDBG(DBG_ADVPUSH, ("AdvPush cy=%ld, Move Y from %ld to %ld",
                rcAdvPush.bottom - rcAdvPush.top, rcAdvPush.top, ptl.y));

        MapWindowPoints(NULL, hDlg, (LPPOINT)&rcAdvPush, 2);
        ScreenToClient(hDlg, (LPPOINT)&ptl);
        ptl.x  = rcAdvPush.left;

        CPSUIDBG(DBG_ADVPUSH, ("New Push left/top in CLIENT top=%ld, Add=%ld",
                    ptl.y, ptl.y - rcAdvPush.top));

        if (rcAdvPush.top != ptl.y) {

            CPSUIDBG(DBG_ADVPUSH, ("Advance Push top change from %ld to %ld",
                        rcAdvPush.top, ptl.y));

            SetWindowPos(hCtrl,
                         NULL,
                         ptl.x, ptl.y,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER);

            ptl.y -= rcAdvPush.top;

            if (hCtrl = CtrlIDrcWnd(hDlg, EnlargeCtrlID, &rcDlg)) {

                SetWindowPos(hCtrl,
                             NULL,
                             0, 0,
                             rcDlg.right - rcDlg.left,
                             rcDlg.bottom - rcDlg.top + ptl.y,
                             SWP_NOMOVE | SWP_NOZORDER);
            }

            if (hCtrl = CtrlIDrcWnd(hDlg, CenterCtrlID, &rcDlg)) {

                SetWindowPos(hCtrl,
                             NULL,
                             rcDlg.left,
                             rcDlg.top + (ptl.y / 2),
                             0, 0,
                             SWP_NOSIZE | SWP_NOZORDER);
            }
        }
    }
}



INT_PTR
CALLBACK
PropPageProc(
    HWND    hDlg,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    28-Aug-1995 Mon 16:13:10 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define pNMHdr      ((NMHDR *)lParam)

    HWND        hWndFocus;
    HWND        hCtrl;
    PMYDLGPAGE  pCurMyDP;
    PTVWND      pTVWnd;
    POPTITEM    pItem;
    LONG        MResult;
    PLAYOUTBMP  pData;
    PCPSUIPAGE  pPage;




    if (Msg == WM_INITDIALOG) {

        CPSUIINT(("PropPage WM_INITDIALOG: hDlg=%08lx, pPSP=%08lx", hDlg, lParam));

        pCurMyDP           = (PMYDLGPAGE)(((LPPROPSHEETPAGE)lParam)->lParam);
        pTVWnd             = (PTVWND)pCurMyDP->pTVWnd;
        pCurMyDP->pPSPInfo = PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam);

        if (!ADD_PMYDLGPAGE(hDlg, pCurMyDP)) {

            return(FALSE);
        }

        CreateImageList(hDlg, pTVWnd);

        if ((MResult = InitPropPage(hDlg, pCurMyDP)) < 0) {

            CPSUIERR(("InitProPage()=%ld, FAILED", MResult));
        }

        SetUniqChildID(hDlg);
        CommonPropSheetUIHelpSetup(NULL, pTVWnd);
        UpdateCallBackChanges(hDlg, pTVWnd, TRUE);
        EnumChildWindows(hDlg, FixIconChildTo32x32, (LPARAM)hDlg);
        SetFocus((HWND)wParam);
        MResult = TRUE;

        ((LPPROPSHEETPAGE)lParam)->lParam = pCurMyDP->CPSUIUserData;

        if ((pTVWnd->Flags & TWF_HAS_ADVANCED_PUSH) &&
            (hCtrl = GetDlgItem(hDlg, ADVANCED_PUSH))) {

            if (CountPropPageItems(pTVWnd, (BYTE)(pTVWnd->cMyDlgPage - 1))) {

                WORD    InitItemIdx = INTIDX_ADVANCED;

                SETCTRLDATA(hCtrl, CTRLS_PUSHBUTTON, 0);

            } else {

                ShowWindow(hCtrl, SW_HIDE);
            }
        }
    }

    if (pCurMyDP = GET_PMYDLGPAGE(hDlg)) {

        pTVWnd = (PTVWND)pCurMyDP->pTVWnd;

        if (pTVWnd) {

            if (pCurMyDP->DlgPage.DlgProc) {

                //
                // Passed the caller's original CPSUIUserData which is the UserData
                // in the COMPROPSHEETUI data structure
                //

                MResult = (LONG)pCurMyDP->DlgPage.DlgProc(hDlg, Msg, wParam, lParam);

                if (MResult) {

                    return(TRUE);
                }
            }

            if (Msg == WM_INITDIALOG) {

                if ((pCurMyDP->PageIdx != pTVWnd->StdPageIdx1)  ||
                    (!(hCtrl = GetDlgItem(hDlg, IDD_LAYOUT_PICTURE)))) {

                    hCtrl = NULL;
                }

                MoveAdvancedPush(hDlg,
                                 IDD_LAYOUT_PICTURE_GROUP,
                                 IDD_LAYOUT_PICTURE);

                if ((hCtrl)  &&
                    (pData = InitLayoutBmp(hDlg, hCtrl, pTVWnd))) {

                    SetProp(hCtrl, CPSUIPROP_LAYOUTPUSH, (HANDLE)pData);
                }

                return((BOOL)MResult);
            }

        } else {

            return(FALSE);
        }

    } else {

        return(FALSE);
    }

    //
    // Check if which one got the keyboard focus, if it is not the same as
    // the one recored then send out the Focus message
    //

    if ((pCurMyDP->Flags & MYDPF_PAGE_ACTIVE)                   &&
        (hWndFocus = GetFocus())                                &&
        (hWndFocus != pCurMyDP->hWndFocus)                      &&
        (pItem = pItemFromhWnd(hDlg, pTVWnd, hWndFocus, -1))    &&
        (pItem != pCurMyDP->pCurItem)) {

        pCurMyDP->hWndFocus = hWndFocus;
        pCurMyDP->pCurItem  = pItem;

        CPSUIOPTITEM(DBG_SETFOCUS, pTVWnd,
                     "PropPage: Keyboard Focus Changed", 0, pItem);

        if ((pItem->Flags & OPTIF_CALLBACK)             &&
            (pTVWnd->ComPropSheetUI.pfnCallBack)        &&
            (pItem >= pTVWnd->ComPropSheetUI.pOptItem)  &&
            (pItem <= pTVWnd->pLastItem)) {

            DoCallBack(hDlg,
                       pTVWnd,
                       pItem,
                       pItem->pSel,
                       NULL,
                       NULL,
                       0,
                       CPSUICB_REASON_OPTITEM_SETFOCUS);
        }
    }

    switch (Msg) {

    case WM_DRAWITEM:

        return(DrawLBCBItem(pTVWnd, (LPDRAWITEMSTRUCT)lParam));

    case WM_COMMAND:

        if ((LOWORD(wParam) == ADVANCED_PUSH)           &&
            (pTVWnd->Flags & TWF_HAS_ADVANCED_PUSH)     &&
            (HIWORD(wParam) == BN_CLICKED)              &&
            (pTVWnd->hCPSUIPage)                        &&
            (pPage = HANDLETABLE_GetCPSUIPage(pTVWnd->hCPSUIPage))) {

            pPage->Flags  |= CPF_CALL_TV_DIRECT;
            pTVWnd->Flags |= TWF_TV_BY_PUSH;

            AddComPropSheetPage(pPage, pTVWnd->cInitMyDlgPage);

            pTVWnd->Flags &= ~TWF_TV_BY_PUSH;
            pPage->Flags  &= ~CPF_CALL_TV_DIRECT;

            HANDLETABLE_UnGetCPSUIPage(pPage);

            SET_APPLY_BUTTON(pTVWnd, hDlg);

            UpdatePropPage(hDlg, pCurMyDP);
            InvalidateBMP(hDlg, pTVWnd);


            break;

        } else {

            NULL;
        }

        //
        // Fall through
        //


    case WM_HSCROLL:

        if (pItem = DlgHScrollCommand(hDlg, pTVWnd, (HWND)lParam, wParam)) {

            UpdatePropPageItem(hDlg, pTVWnd, pItem, FALSE);
            InvalidateBMP(hDlg, pTVWnd);
        }

        break;

    case WM_HELP:

        wParam = (WPARAM)((LPHELPINFO)lParam)->hItemHandle;
        lParam = (LPARAM)MAKELONG(((LPHELPINFO)lParam)->MousePos.x,
                                  ((LPHELPINFO)lParam)->MousePos.y);

    case WM_CONTEXTMENU:

        if (lParam == 0xFFFFFFFF) {

            RECT    rc;

            wParam = (WPARAM)GetFocus();

            GetWindowRect((HWND)wParam, &rc);

            CPSUIINT(("MousePos=0xFFFFFFFF, GetFocus=%08lx, rc=(%ld, %ld)-(%ld, %ld)",
                     (HWND)wParam, rc.left, rc.top, rc.right, rc.bottom));

            rc.left += ((rc.right - rc.left) / 2);
            rc.top  += ((rc.bottom - rc.top) / 2);
            lParam   = (LPARAM)MAKELONG(rc.left, rc.top);
        }

        pTVWnd = GET_PTVWND(hDlg);

        if (pTVWnd) {

            pItem  = pItemFromhWnd(hDlg, pTVWnd, (HWND)wParam, (LONG)lParam);

            if (Msg == WM_CONTEXTMENU) {

                DoContextMenu(pTVWnd, hDlg, pItem, lParam);

            } else if (pItem) {

                CommonPropSheetUIHelp(hDlg,
                                      pTVWnd,
                                      hDlg, // (HWND)GetFocus(),
                                      (DWORD)lParam,
                                      pItem,
                                      HELP_WM_HELP);
            }
        }

        break;

    case WM_NOTIFY:

        MResult = 0;

        switch (pNMHdr->code) {

        case NM_SETFOCUS:
        case NM_CLICK:
        case NM_DBLCLK:
        case NM_RDBLCLK:
        case NM_RCLICK:

            break;

        case PSN_APPLY:

            if ((pTVWnd->Flags & TWF_CAN_UPDATE)   &&
                (pTVWnd->ActiveDlgPage == pCurMyDP->PageIdx)) {

                CPSUIDBG(DBG_PROPPAGEPROC,
                        ("\nPropPage: Do PSN_APPLY(%ld), Page: Cur=%u, Active=%u, Flags=%04lx, CALLBACK",
                            (pTVWnd->Flags & TWF_APPLY_NO_NEWDEF) ? 1 : 0,
                            (UINT)pCurMyDP->PageIdx, (UINT)pTVWnd->ActiveDlgPage,
                            pTVWnd->Flags));

                if (DoCallBack(hDlg,
                               pTVWnd,
                               (pTVWnd->Flags & TWF_APPLY_NO_NEWDEF) ?
                                    NULL : pTVWnd->ComPropSheetUI.pOptItem,
                               (LPVOID)pCurMyDP->PageIdx,
                               NULL,
                               NULL,
                               0,
                               CPSUICB_REASON_APPLYNOW) ==
                                           CPSUICB_ACTION_NO_APPLY_EXIT) {

                    MResult = PSNRET_INVALID_NOCHANGEPAGE;
                }

            } else {

                CPSUIDBG(DBG_PROPPAGEPROC,
                        ("\nPropPage: Ignore PSN_APPLY, Page: Cur=%u, Active=%u, Flags=%04lx, DO NOTHING",
                        (UINT)pCurMyDP->PageIdx, (UINT)pTVWnd->ActiveDlgPage,
                        pTVWnd->Flags));
            }

            break;

        case PSN_RESET:

            CPSUIDBG(DBG_PROPPAGEPROC, ("\nPropPage: Got PSN_RESET (Cancel)"));

            break;

        case PSN_HELP:

            CPSUIDBG(DBG_PROPPAGEPROC, ("\nPropPage: Got PSN_HELP (Help)"));

            CommonPropSheetUIHelp(hDlg,
                                  pTVWnd,
                                  GetFocus(),
                                  0,
                                  NULL,
                                  HELP_CONTENTS);
            break;

        case PSN_SETACTIVE:

            CPSUIDBG(DBG_PROPPAGEPROC,
                     ("\nPropPage: Got PSN_SETACTIVE, pTVWnd=%08lx (%ld), Page=%u -> %u\n",
                        pTVWnd, pTVWnd->cMyDlgPage,
                        (UINT)pTVWnd->ActiveDlgPage, (UINT)pCurMyDP->PageIdx));

            pCurMyDP->Flags       |= MYDPF_PAGE_ACTIVE;
            pTVWnd->ActiveDlgPage  = pCurMyDP->PageIdx;

            DoCallBack(hDlg,
                       pTVWnd,
                       pTVWnd->ComPropSheetUI.pOptItem,
                       (LPVOID)pCurMyDP->PageIdx,
                       NULL,
                       NULL,
                       0,
                       CPSUICB_REASON_SETACTIVE);

            UpdatePropPage(hDlg, pCurMyDP);
            InvalidateBMP(hDlg, pTVWnd);

            break;

        case PSN_KILLACTIVE:

            CPSUIDBG(DBG_PROPPAGEPROC, ("\nPropPage: Got PSN_KILLACTIVE, pTVWnd=%08lx (%ld)",
                        pTVWnd, pTVWnd->cMyDlgPage));

            pCurMyDP->Flags &= ~MYDPF_PAGE_ACTIVE;

            DoCallBack(hDlg,
                       pTVWnd,
                       pTVWnd->ComPropSheetUI.pOptItem,
                       (LPVOID)pCurMyDP->PageIdx,
                       NULL,
                       NULL,
                       0,
                       CPSUICB_REASON_KILLACTIVE);

            break;

        default:

            CPSUIDBG(DBG_PROPPAGEPROC,
                     ("*PropPageProc: Unknow WM_NOTIFY=%u", pNMHdr->code));

            break;
        }

        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, MResult);
        return(TRUE);
        break;

    case WM_DESTROY:

        CPSUIINT(("PropPage: Get WM_DESTROY Message"));

        if ((hCtrl = GetDlgItem(hDlg, IDD_LAYOUT_PICTURE))  &&
            (pData = (PLAYOUTBMP)GetProp(hCtrl, CPSUIPROP_LAYOUTPUSH))) {

            FreeLayoutBmp(pData);
            RemoveProp(hCtrl, CPSUIPROP_LAYOUTPUSH);
        }

        CommonPropSheetUIHelpSetup(hDlg, pTVWnd);
        EnumChildWindows(hDlg, ChildWndCleanUp, 0);

        DEL_PMYDLGPAGE(hDlg);

        break;
    }

    return(FALSE);

#undef pNMHdr
}

PLAYOUTBMP
InitLayoutBmp(
    HWND        hDlg,
    HANDLE      hWnd,
    PTVWND      pTVWnd
    )
/*++

Routine Description:


    Loads bitmap resource and initializes array used in displaying layout preview

Arguments:

    hDlg - Dialog handle
    hWnd - Handle to the preview window control
    pTVWnd - Treeview info


Return Value:

    Pointer to LAYOUTBMP containing private settings


Author:



Revision History:


--*/
{
    PLAYOUTBMP pData;

    if (!(pData = LocalAlloc(LMEM_FIXED, sizeof(LAYOUTBMP)))) {

        return NULL;

    }

    if (!(LoadLayoutBmp(hDlg, &pData->Portrait,  IDI_CPSUI_LAYOUT_BMP_PORTRAIT))  ||
        !(LoadLayoutBmp(hDlg, &pData->BookletL,  IDI_CPSUI_LAYOUT_BMP_BOOKLETL))  ||
        !(LoadLayoutBmp(hDlg, &pData->BookletP,  IDI_CPSUI_LAYOUT_BMP_BOOKLETP))  ||
        !(LoadLayoutBmp(hDlg, &pData->ArrowL,    IDI_CPSUI_LAYOUT_BMP_ARROWL))    ||
        !(LoadLayoutBmp(hDlg, &pData->ArrowS,    IDI_CPSUI_LAYOUT_BMP_ARROWS)) ) {

        // something went wrong. cleanup...
        FreeLayoutBmp(pData);
        return NULL;
    }

    pData->hWnd = hWnd;

    InitData(pData, pTVWnd);

    return pData;
}


BOOL
LoadLayoutBmp(
    HWND        hDlg,
    MYBMP *     pMyBmpData,
    DWORD       dwBitmapID
    )

/*++

Routine Description:

    Load bitmap resource and get color table information,
    BITMAPINFOHEADER and offset to bits for bltting later.


Arguments:




Return Value:




Author:



Revision History:


--*/
{
    HANDLE  hResource, hBitmap;
    LPBYTE  lpBitmap;
    LPBITMAPINFOHEADER lpbmi;
    DWORD   dwClrUsed;

    if (!(hResource = FindResource(hInstDLL,
                             MAKEINTRESOURCE(dwBitmapID),
                             RT_BITMAP))){

        return FALSE;
    }

    if (!(hBitmap = LoadResource(hInstDLL, hResource))) {

        return FALSE;

    }

    if (!(lpBitmap = LockResource(hBitmap))) {

        FreeResource(hBitmap);
        return FALSE;

    }

    lpbmi = (LPBITMAPINFOHEADER)lpBitmap;

    if (lpbmi->biSize == sizeof(BITMAPINFOHEADER)){

        dwClrUsed = lpbmi->biClrUsed;

        if (dwClrUsed == 0) {

            switch(lpbmi->biBitCount){

            case 1:
                dwClrUsed = 2;
                break;

            case 4:
                dwClrUsed = 16;
                break;

            case 8:
                dwClrUsed = 256;
                break;

            default:
                dwClrUsed = 0;
                break;

            }
        }

        lpBitmap += lpbmi->biSize + (dwClrUsed * sizeof(RGBQUAD));

    } else {

        FreeResource(hBitmap);
        return FALSE;

    }

    pMyBmpData->hBitmap = hBitmap;
    pMyBmpData->lpbmi   = lpbmi;
    pMyBmpData->lpBits  = lpBitmap;

    return TRUE;
}



VOID
DrawLayoutArrowAndText(
    HDC     hDC,
    PRECT   prcIn,
    PRECT   prcOut,
    PLAYOUTBMP pData
    )

/*++

Routine Description:

    This function draws the arrow and the Side1/Side2 text for the
    preview pages in duplex mode.

Arguments:

    hDC - Screen DC
    prcIn - Describes the total drawable dimensions for the preview control
    prcOut - Pointer to RECT that describes the dimensions of the last page drawn
    pData - Private data, stores the bitmap information

Return Value:

    None

--*/
{

    LPBITMAPINFOHEADER  lpbmi;
    LPBYTE              lpBits;
    INT                 left, top, strx1,strx2, stry1, stry2;
    WCHAR               awchBuf[MAX_RES_STR_CHARS];
    HBITMAP             hbm = NULL;
    HDC                 hdcMem = NULL;
    BOOL                bArrowS;

    if (pData->DuplexIdx == DUPLEX_SIMPLEX)
        return;

    if ((pData->DuplexIdx == DUPLEX_LONGSIDE && pData->OrientIdx == ORIENT_PORTRAIT) ||
        (pData->DuplexIdx == DUPLEX_SHORTSIDE && pData->OrientIdx != ORIENT_PORTRAIT)) {

        if ((pData->NupIdx == NUP_TWOUP || pData->NupIdx == NUP_SIXUP))
            bArrowS = TRUE;
        else
            bArrowS = FALSE;
    }
    else {

        if ((pData->NupIdx == NUP_TWOUP || pData->NupIdx == NUP_SIXUP))
            bArrowS = FALSE;
        else
            bArrowS = TRUE;

    }

    if (bArrowS) {

        lpbmi = pData->ArrowS.lpbmi;
        lpBits = pData->ArrowS.lpBits;
        left = prcOut->right + SHADOW_SIZE*2;
        top  = prcOut->top - (lpbmi->biHeight + SHADOW_SIZE)/2;
        strx1 = strx2 = prcIn->left + (prcIn->right - prcIn->left)/16 ;
        stry1 = prcIn->top;
        stry2 = stry1 + ((prcIn->bottom - prcIn->top) + SHADOW_SIZE)/2;
    }
    else {

        lpbmi = pData->ArrowL.lpbmi;
        lpBits = pData->ArrowL.lpBits;
        left = prcIn->left + (prcOut->right - prcOut->left) + SHADOW_SIZE;
        top  = prcOut->top + (prcOut->bottom - prcOut->top) + SHADOW_SIZE*2;
        strx1 = prcIn->left + (prcIn->right - prcIn->left)/6 - SHADOW_SIZE;
        stry1 = stry2 = prcIn->top + (prcIn->bottom - prcIn->top)/6 ;
        strx2 = strx1 + (prcIn->right - prcIn->left)/2;

    }

    if (!(hbm = CreateCompatibleBitmap(hDC, lpbmi->biWidth, lpbmi->biHeight))  ||
        !(hdcMem = CreateCompatibleDC(hDC))  ||
        !SelectObject(hdcMem, hbm))
    {
        goto DrawArrowAndTextExit;

    }


    StretchDIBits(hdcMem,
                  0,
                  0,
                  lpbmi->biWidth,
                  lpbmi->biHeight,
                  0,
                  0,
                  lpbmi->biWidth,
                  lpbmi->biHeight,
                  lpBits,
                  (LPBITMAPINFO)lpbmi,
                  DIB_RGB_COLORS,
                  SRCCOPY
                );


    TransparentBlt(hDC,
                   left,
                   top,
                   lpbmi->biWidth,
                   lpbmi->biHeight,
                   hdcMem,
                   0,
                   0,
                   lpbmi->biWidth,
                   lpbmi->biHeight,
                   RGB(255, 0, 255)
                   );

    //
    // Draw the Text
    //

    LoadString(hInstDLL, IDS_CPSUI_SIDE1, awchBuf, MAX_RES_STR_CHARS);
    TextOut(hDC, strx1, stry1, awchBuf, wcslen(awchBuf));

    LoadString(hInstDLL, IDS_CPSUI_SIDE2, awchBuf, MAX_RES_STR_CHARS);
    TextOut(hDC, strx2, stry2, awchBuf, wcslen(awchBuf));

DrawArrowAndTextExit:

    if (hbm)
        DeleteObject(hbm);
    if (hdcMem)
        DeleteDC(hdcMem);

}



VOID
UpdateLayoutBmp(
    HDC     hDC,
    PLAYOUTBMP pData
    )

/*++

Routine Description:

    Calls whenever we get a WM_DRAWITEM to draw owner drawn controls.


Arguments:

    hDC - Handle to screen DC
    pData - Private data containing current selections etc.

Return Value:

    None


Author:



Revision History:

Note:

    PAGE_BOUNDARY_SCALE is 7 since it assumes that the destination control is
    a square where in portrait mode, the width of the dest window is 5/7 of the square and in
    landscape mode, the height of the dest window is 5/7 of the square.  This is used to simplify
    the code for both scenarios.  We just need to scale based on the orientation
    selected.


--*/
{

#define  PAGE_BOUNDARY_SCALE    7

    INT     i, j, k, Row, Columm;
    BOOL    bDoBooklet = FALSE;
    DWORD   dwWidth, dwHeight, dwBookletLeft, dwBookletTop, dwOffset;
    RECT    rcControlIn, rcControlOut;
    LPBITMAPINFOHEADER  lpbmi;
    LPBYTE              lpBits;
    HDC                 hCompDC;
    HBITMAP             hCompBitmap;
    PAGEBORDER *        pPageBorder;
    BYTE                DuplexIdx;

    //
    // PageBorder represents the factor for calculating the
    // left, top, right, bottom rectangle of the current selected duplex option
    //

    static PAGEBORDER  PageBorderP[] = {
        { 4,  4,  2,  2 },
        { 0,  4,  2,  2 },
        { 2,  4,  2,  2 },
        { 4,  0,  2,  2 },
        { 4,  2,  2,  2 }
        };

    static PAGEBORDER PageBorderL[] = {
        { 4,  4,  2,  2 },
        { 4,  0,  2,  2 },
        { 4,  2,  2,  2 },
        { 0,  4,  2,  2 },
        { 2,  4,  2,  2 }
        };

    //
    // Duplex represents the the start and end of rectangles to be drawn for
    // the current selected duplex options.
    // For example, to draw page border for Long Side duplexinng,
    // Start with PageBorder[1] and End with PageBorder[3]
    //

    static DUPLEX   Duplex[MAX_DUPLEX_OPTION] = {
        { 1, 3 },      // Long Side
        { 3, 5 },      // Short Side
        { 0, 1 }       // Simplex
        };

    //
    // Nup[] represents the row and columm for each Nup option
    //

    static NUP      Nup[] = {
        { 1, 1 },       // 1-up
        { 2, 1 },       // 2-up
        { 2, 2 },       // 4-up
        { 3, 2 },       // 6-up
        { 3, 3 },       // 9-up
        { 4, 4 },       // 16-up
        { 1, 1 }        // Booklet
        };

    GetClientRect(pData->hWnd, &rcControlIn);
    dwOffset = (rcControlIn.right - rcControlIn.left)/ PAGE_BOUNDARY_SCALE;

    if (pData->OrientIdx == ORIENT_PORTRAIT){

        if ((pData->NupIdx == NUP_TWOUP || pData->NupIdx == NUP_SIXUP))
        {
            rcControlIn.top += dwOffset;
            rcControlIn.bottom -= dwOffset;
            pPageBorder =PageBorderL;
        }
        else
        {
            rcControlIn.left += dwOffset;
            rcControlIn.right -= dwOffset;
            pPageBorder =PageBorderP;
        }

    }else {

        if ((pData->NupIdx == NUP_TWOUP || pData->NupIdx == NUP_SIXUP))
        {
            rcControlIn.left += dwOffset;
            rcControlIn.right -= dwOffset;
            pPageBorder =PageBorderP;
        }
        else
        {
            rcControlIn.top += dwOffset;
            rcControlIn.bottom -= dwOffset;
            pPageBorder =PageBorderL;
        }

    }

    CopyMemory(&rcControlOut, &rcControlIn, sizeof(RECT));

    SetStretchBltMode(hDC, BLACKONWHITE);

    if (bDoBooklet = (pData->NupIdx == NUP_BOOKLET))
        DuplexIdx = DUPLEX_SIMPLEX;
    else
        DuplexIdx = pData->DuplexIdx;

    for (k= Duplex[DuplexIdx].Start; k < Duplex[DuplexIdx].End; k++) {

        DrawBorder(hDC,
                   !bDoBooklet,
                   !bDoBooklet,
                   &rcControlIn,
                   &rcControlOut,
                   &pPageBorder[k]
                  );

        if (!bDoBooklet) {

            rcControlOut.left += FRAME_BORDER;
            rcControlOut.right -= FRAME_BORDER;
            rcControlOut.top += FRAME_BORDER;
            rcControlOut.bottom -= FRAME_BORDER;

            dwWidth = rcControlOut.right - rcControlOut.left;
            dwHeight = rcControlOut.bottom - rcControlOut.top;

            lpBits = pData->Portrait.lpBits;
            lpbmi  = pData->Portrait.lpbmi;

            if (pData->OrientIdx == ORIENT_PORTRAIT)
            {

                Row = Nup[pData->NupIdx].row;
                Columm = Nup[pData->NupIdx].columm;

            }
            else {

                Row = Nup[pData->NupIdx].columm;
                Columm = Nup[pData->NupIdx].row;

            }

            if ((pData->NupIdx == NUP_TWOUP || pData->NupIdx == NUP_SIXUP)) {
                i = Row;
                Row = Columm;
                Columm = i;
            }

            dwWidth /= Columm;
            dwHeight /= Row;

        }
        else {

            dwBookletLeft = rcControlOut.left;
            dwBookletTop = rcControlOut.top;

            if (pData->OrientIdx == ORIENT_PORTRAIT) {

                lpBits = pData->BookletP.lpBits;
                lpbmi = pData->BookletP.lpbmi;
                dwWidth = pData->BookletP.lpbmi->biWidth;
                dwHeight = pData->BookletP.lpbmi->biHeight;
                rcControlOut.right = rcControlOut.left + dwWidth;
                rcControlOut.bottom = rcControlOut.top + dwHeight;
                rcControlOut.top = rcControlOut.top + dwHeight/5;

           }
            else {

                lpBits = pData->BookletL.lpBits;
                lpbmi = pData->BookletL.lpbmi;
                dwWidth = pData->BookletL.lpbmi->biWidth;
                dwHeight = pData->BookletL.lpbmi->biHeight;
                rcControlOut.right = rcControlOut.left + dwWidth;
                rcControlOut.bottom = rcControlOut.top + dwHeight;
                rcControlOut.left = rcControlOut.left + dwWidth/5;

            }
        }

        hCompDC = CreateCompatibleDC(hDC);
        hCompBitmap = CreateCompatibleBitmap(hDC, dwWidth, dwHeight);

        if (!hCompDC || !hCompBitmap)
            return;

        SelectObject(hCompDC, hCompBitmap);

        StretchDIBits(hCompDC,
                      0,
                      0,
                      dwWidth,
                      dwHeight,
                      0,
                      0,
                      lpbmi->biWidth,
                      lpbmi->biHeight,
                      lpBits,
                      (LPBITMAPINFO)lpbmi,
                      DIB_RGB_COLORS,
                      SRCCOPY
                  );

        if (bDoBooklet) {

            DrawBorder(hDC,
                       TRUE,
                       FALSE,
                       NULL,
                       &rcControlOut,
                       NULL
                      );

            TransparentBlt(hDC,
                        dwBookletLeft,
                        dwBookletTop ,
                        dwWidth,
                        dwHeight,
                        hCompDC,
                        0,
                        0,
                        dwWidth,
                        dwHeight,
                        RGB(255, 0, 255)
                        );

        }
        else  {

            for ( i = 0; i < Row; i++) {

                    for (j = 0; j < Columm; j++) {

                            BitBlt( hDC,
                                    rcControlOut.left + dwWidth*j ,
                                    rcControlOut.top  + dwHeight*i,
                                    dwWidth,
                                    dwHeight,
                                    hCompDC,
                                    0,
                                    0,
                                    SRCCOPY
                                    );
                    }
             }
        }
        DeleteObject(hCompBitmap);
        DeleteDC(hCompDC);

    }

    if (!bDoBooklet)
        DrawLayoutArrowAndText(hDC,&rcControlIn, &rcControlOut, pData);

}

VOID
FreeLayoutBmp(
    PLAYOUTBMP  pData
    )

/*++

Routine Description:

    Unlock and Free Resources and free memory allocated for pData


Arguments:




Return Value:




Author:



Revision History:


--*/
{

    if (pData){
        UnlockResource(pData->Portrait.hBitmap);
        UnlockResource(pData->BookletL.hBitmap);
        UnlockResource(pData->BookletP.hBitmap);
        UnlockResource(pData->ArrowL.hBitmap);
        UnlockResource(pData->ArrowS.hBitmap);
        FreeResource(pData->Portrait.hBitmap);
        FreeResource(pData->BookletL.hBitmap);
        FreeResource(pData->BookletP.hBitmap);
        FreeResource(pData->ArrowL.hBitmap);
        FreeResource(pData->ArrowS.hBitmap);

        LocalFree(pData);
    }
}

VOID
DrawBorder(
    HDC     hDC,
    BOOL    bDrawShadow,
    BOOL    bDrawBorder,
    PRECT   pRectIn,
    PRECT   pRectOut,
    PAGEBORDER * pPageBorder
    )
/*++

Routine Description:

    Draw the page border for the preview bitmap

Arguments:




Return Value:




Author:



Revision History:


--*/
{
    HPEN    hOldPen, hPen;
    HBRUSH  hBrush;
    DWORD   dwWidth, dwHeight;
    RECT    rcShadow;

    hPen    = GetStockObject(BLACK_PEN);
    hBrush  = GetStockObject(GRAY_BRUSH);
    hOldPen = (HPEN) SelectObject(hDC, hPen);


    if (pPageBorder) {

        dwWidth = pRectIn->right - pRectIn->left  ;
        dwHeight = pRectIn->bottom - pRectIn->top ;

        pRectOut->left     = pRectIn->left + ADDOFFSET(dwWidth ,pPageBorder->left);
        pRectOut->top      = pRectIn->top  + ADDOFFSET(dwHeight,pPageBorder->top);
        pRectOut->right    = pRectOut->left + ADDOFFSET(dwWidth ,pPageBorder->right) ;
        pRectOut->bottom   = pRectOut->top  + ADDOFFSET(dwHeight,pPageBorder->bottom);
    }

    if (bDrawBorder) {

        InflateRect(pRectOut, -5, -5);

        SelectObject ( hDC, hPen);
        Rectangle( hDC, pRectOut->left, pRectOut->top, pRectOut->right , pRectOut->bottom );
    }


    if (bDrawShadow) {

        rcShadow.left = pRectOut->right;
        rcShadow.top = pRectOut->top + SHADOW_SIZE;
        rcShadow.right = pRectOut->right + SHADOW_SIZE;
        rcShadow.bottom = pRectOut->bottom + SHADOW_SIZE;

        FillRect(hDC, &rcShadow, hBrush);

        rcShadow.left = pRectOut->left + SHADOW_SIZE;
        rcShadow.top = pRectOut->bottom;
        rcShadow.right = pRectOut->right + SHADOW_SIZE;
        rcShadow.bottom = pRectOut->bottom + SHADOW_SIZE;

        FillRect(hDC, &rcShadow, hBrush);
    }

    SelectObject ( hDC,  hOldPen);

    if (hPen) {
        DeleteObject ( hPen    );
    }

    if (hBrush) {
        DeleteObject ( hBrush  );
    }
}

VOID
InvalidateBMP(
    HWND     hDlg,
    PTVWND   pTVWnd
    )
/*++

Routine Description:

    Call InvalidateRect to get WM_DRAWITEM to update preview.


Arguments:




Return Value:




Author:



Revision History:


--*/
{
    HWND        hWnd;
    PLAYOUTBMP  pData;


    if ((hWnd = GetDlgItem(hDlg, IDD_LAYOUT_PICTURE))   &&
        (pData = (PLAYOUTBMP)GetProp(hWnd, CPSUIPROP_LAYOUTPUSH))) {

        UpdateData(pData, pTVWnd);
        InvalidateRect(hWnd, NULL, TRUE);
    }
}

VOID
InitData(
    PLAYOUTBMP  pData,
    PTVWND      pTVWnd
    )
/*++

Routine Description:




Arguments:




Return Value:




Author:



Revision History:


--*/
{
    UINT        Idx, Count, i;
    POPTTYPE    pOptType;
    POPTPARAM   pOptParam;

    POPTITEM    pItem = pTVWnd->ComPropSheetUI.pOptItem;

    pData->OrientIdx = ORIENT_PORTRAIT;
    pData->NupIdx = NUP_ONEUP;
    pData->DuplexIdx = DUPLEX_SIMPLEX;

    if (pItem = GET_PITEMDMPUB(pTVWnd, DMPUB_ORIENTATION, Idx)) {

        pOptType = pItem->pOptType;
        pOptParam = pOptType->pOptParam;
        Count     = pOptType->Count;

        for ( i = 0; i < Count; i++) {

            switch (pOptParam->IconID) {

            case IDI_CPSUI_PORTRAIT:

                pData->Orientation.PortraitIdx = (BYTE)i;
                break;

            case IDI_CPSUI_LANDSCAPE:

                pData->Orientation.LandscapeIdx = (BYTE)i;
                break;

            case IDI_CPSUI_ROT_LAND:

                pData->Orientation.RotateIdx = (BYTE)i;
                break;

            }
            pOptParam++;
        }

    }

    if (pItem = GET_PITEMDMPUB(pTVWnd, DMPUB_DUPLEX, Idx)) {

        pOptType = pItem->pOptType;
        pOptParam = pOptType->pOptParam;
        Count     = pOptType->Count;

        for ( i = 0; i < Count; i++) {

            switch (pOptParam->IconID) {

            case IDI_CPSUI_DUPLEX_NONE:
            case IDI_CPSUI_DUPLEX_NONE_L:

                pData->Duplex.SimplexIdx = (BYTE)i;
                break;

            case IDI_CPSUI_DUPLEX_HORZ:
            case IDI_CPSUI_DUPLEX_HORZ_L:

                pData->Duplex.ShortSideIdx = (BYTE)i;
                break;

            case IDI_CPSUI_DUPLEX_VERT:
            case IDI_CPSUI_DUPLEX_VERT_L:

                pData->Duplex.LongSideIdx = (BYTE)i;
                break;
            }

            pOptParam++;

        }

    }
}


VOID
UpdateData(
    PLAYOUTBMP  pData,
    PTVWND      pTVWnd
    )
/*++

Routine Description:




Arguments:




Return Value:




Author:



Revision History:


--*/
{

    POPTITEM    pItem = pTVWnd->ComPropSheetUI.pOptItem;
    UINT        Idx;

    if (pItem = GET_PITEMDMPUB(pTVWnd, DMPUB_DUPLEX, Idx)) {

        if ((BYTE)pItem->Sel == pData->Duplex.SimplexIdx) {

            pData->DuplexIdx = DUPLEX_SIMPLEX;

        } else if ((BYTE)pItem->Sel == pData->Duplex.LongSideIdx) {

            pData->DuplexIdx = DUPLEX_LONGSIDE;

        } else if ((BYTE)pItem->Sel == pData->Duplex.ShortSideIdx) {

            pData->DuplexIdx = DUPLEX_SHORTSIDE;

        }

    }

    if (pItem = GET_PITEMDMPUB(pTVWnd, DMPUB_ORIENTATION, Idx)) {

        if ((BYTE)pItem->Sel == pData->Orientation.PortraitIdx) {

            pData->OrientIdx = ORIENT_PORTRAIT;

        } else if ((BYTE)pItem->Sel == pData->Orientation.LandscapeIdx) {

            pData->OrientIdx = ORIENT_LANDSCAPE;

        } else if ((BYTE)pItem->Sel == pData->Orientation.RotateIdx) {

            pData->OrientIdx = ORIENT_ROTATED;

        }

    }

    if (pItem = GET_PITEMDMPUB(pTVWnd, DMPUB_NUP, Idx)) {

        pData->NupIdx = (BYTE)pItem->Sel;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\resource.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    resource.h


Abstract:

    This module contains definitions for the resources


Author:

    29-Aug-1995 Tue 12:41:52 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/


#define GBF_PREFIX_OK       0x0001
#define GBF_INT_NO_PREFIX   0x0002
#define GBF_ANSI_CALL       0x0004
#define GBF_COPYWSTR        0x0008
#define GBF_IDS_INT_CPSUI   0x0010
#define GBF_DUP_PREFIX      0x0020


typedef struct _GSBUF {
    HINSTANCE   hInst;
    LPWSTR      pBuf;       // Pointer to the begining of the buffer
    LPWSTR      pEndBuf;    // pointer to the end of the buffer
    WORD        Flags;      // GBF_xxxx flags
    WCHAR       chPreAdd;   // the character add before string
    } GSBUF, *PGSBUF;


#define GSBUF_BUF               GSTextBuf
#define GSBUF_PBUF              GSBuf.pBuf
#define GSBUF_FLAGS             GSBuf.Flags
#define GSBUF_COUNT             (UINT)(GSBUF_PBUF - GSBUF_BUF)
#define GSBUF_RESET             GSBUF_PBUF=(LPWSTR)GSBUF_BUF
#define GSBUF_INIT(p,b,c)       GSBuf.hInst=_OI_HINST(p);                   \
                                GSBuf.chPreAdd = L'\0';GSBuf.Flags=         \
                                (_OI_EXTFLAGS(p) & OIEXTF_ANSI_STRING) ?    \
                                GBF_ANSI_CALL : 0;GSBUF_PBUF=(LPWSTR)(b);   \
                                GSBuf.pEndBuf=(LPWSTR)(b)+(c)
#define GSBUF_DEF(p,c)          GSBUF GSBuf;WCHAR GSTextBuf[c];             \
                                GSBUF_INIT((p),GSTextBuf,(c))
#define GSBUF_CHPREADD(c)       GSBuf.chPreAdd=L##c
#define GSBUF_GETSTR(p)         GetString(&GSBuf,(LPTSTR)((ULONG_PTR)(p)))
#define GSBUF_GETINTSTR(p)      GSBUF_FLAGS |= GBF_IDS_INT_CPSUI;           \
                                GSBUF_GETSTR(p);                            \
                                GSBUF_FLAGS &= ~GBF_IDS_INT_CPSUI
#define GSBUF_COPYWSTR(p)       GSBuf.Flags|=GBF_COPYWSTR;GSBUF_GETSTR(p);  \
                                GSBuf.Flags&=~GBF_COPYWSTR
#define GSBUF_CHGETSTR(c,p)     GSBUF_CHPREADD(c);GetString(&GSBuf,(LPTSTR)(p))
#define GSBUF_SUB_SIZE(c)       *(GSBUF_PBUF-=(c))=(WCHAR)0
#define GSBUF_ADDC(i, c)        GSBufAddWChar(&GSBuf, i, c)
#define GSBUF_ADD_SPACE(c)      GSBufAddSpace(&GSBuf, c)
#define GSBUF_ADDNUM(n,s)       GSBufAddNumber(&GSBuf,n,s)
#define GSBUF_COMPOSE(i,p,a,b)  GSBUF_PBUF += ComposeStrData(GSBuf.hInst,   \
                                    GSBUF_FLAGS, GSBUF_PBUF,                \
                                    (UINT)(GSBuf.pEndBuf - GSBUF_PBUF),     \
                                    (UINT)i, p, LODWORD(a), LODWORD(b))

#define GETICON_SIZE(hInst, IconID, cx, cy)                                 \
    ((IconID) ? LoadImage((((IconID) >= IDI_CPSUI_ICONID_FIRST) &&          \
                           ((IconID) <= IDI_CPSUI_ICONID_LAST)) ?           \
                                hInstDLL :  hInst,                          \
                          MAKEINTRESOURCE(IconID),                          \
                          IMAGE_ICON, cx, cy, 0) : NULL)

#define GETICON16(hInst, IconID)    GETICON_SIZE(hInst, IconID, 16, 16)
#define GETICON32(hInst, IconID)    GETICON_SIZE(hInst, IconID, 32, 32)

#define GETICON(hInst, IconID)                                              \
    ((IconID) ? LoadIcon((((IconID) >= IDI_CPSUI_ICONID_FIRST) &&           \
                          ((IconID) <= IDI_CPSUI_ICONID_LAST)) ?            \
                                hInstDLL :  hInst,                          \
                         MAKEINTRESOURCE(IconID)) : NULL)


UINT
RemoveAmpersandA(
    LPSTR   pStr
    );

UINT
RemoveAmpersandW(
    LPWSTR  pwStr
    );


UINT
GetStringBuffer(
    HINSTANCE   hInst,
    WORD        GBFlags,
    WCHAR       chPreAdd,
    LPTSTR      pStr,
    LPWSTR      pBuf,
    UINT        cwBuf
    );

UINT
GSBufAddWChar(
    PGSBUF  pGSBuf,
    UINT    IntCharStrID,
    UINT    Count
    );

UINT
GSBufAddSpace(
    PGSBUF  pGSBuf,
    UINT    Count
    );

UINT
GSBufAddNumber(
    PGSBUF  pGSBuf,
    DWORD   Number,
    BOOL    Sign
    );

UINT
GetString(
    PGSBUF  pGSBuf,
    LPTSTR  pStr
    );

LONG
LoadCPSUIString(
    LPTSTR  pStr,
    UINT    cStr,
    UINT    StrResID,
    BOOL    AnsiCall
    );

UINT
ComposeStrData(
    HINSTANCE   hInst,
    WORD        GBFlags,
    LPWSTR      pBuf,
    UINT        cwBuf,
    UINT        IntFormatStrID,
    LPTSTR      pStr,
    DWORD       dw1,
    DWORD       dw2
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\treeview.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    treeview.h


Abstract:

    This module contains header definition for the treeview.c


Author:

    19-Jun-1995 Mon 11:52:01 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/



#define COUNT_ARRAY(a)      (sizeof(a) / sizeof(a[0]))


#define MAX_COMPTRUI_TABS           2

#define TWF_CAN_UPDATE              0x0001
#define TWF_TVPAGE_CHK_DMPUB        0x0002
#define TWF_TVPAGE_NODMPUB          0x0004
#define TWF_ANSI_CALL               0x0008
#define TWF_ONE_REVERT_ITEM         0x0010
#define TWF_ADVDOCPROP              0x0020
#define TWF_HAS_ADVANCED_PUSH       0x0040
#define TWF_TV_BY_PUSH              0x0080
#define TWF_APPLY_NO_NEWDEF         0x0100
#define TWF_TVITEM_NOTYPE           0x0200
#define TWF_IN_TVPAGE               0x0400


#define ICONIDX_NONE                0xFFFF

#define OTINTF_STATES_1             0x0001
#define OTINTF_STATES_2             0x0002
#define OTINTF_STATES_3             0x0004
#define OTINTF_STATES_HIDE_MASK     (OTINTF_STATES_1    |   \
                                     OTINTF_STATES_2    |   \
                                     OTINTF_STATES_3)
#define OTINTF_STDPAGE_3STATES      0x0008
#define OTINTF_ITEM_HAS_ICON16      0x0010
#define OTINTF_TV_USE_2STATES       0x0020
#define OTINTF_TV_USE_3STATES       0x0040


#define OIDF_IN_EN_UPDATE           0x01
#define OIDF_ZERO_SEL_LEN           0x02
#define OIDF_SEL_LEN_SPACES         0x04

typedef struct _OIDATA {
    BYTE            IntFlags;
    BYTE            TVLevel;
    WORD            OIExtFlags;
    WORD            LBCBSelIdx;
    WORD            cbpDefSel;
    WORD            cxExt;
    WORD            cyExtAdd;
    HTREEITEM       hItem;
    LPVOID          pDefSel;
    LPVOID          pDefSel2;
    DWORD           DefOPTIF;
    DWORD           DefOPTIF2;
    DWORD           HelpIdx;
    HINSTANCE       hInstCaller;
    LPTSTR          pHelpFile;
    } OIDATA, *POIDATA;

#define _OT_ORGLBCBCY(pOT)          ((pOT)->wReserved[0])
#define _OT_FLAGS(pOT)              ((pOT)->wReserved[1])
#define _OI_POIDATA(pItem)          ((POIDATA)((pItem)->dwReserved[0]))
#define _OI_INTFLAGS(pItem)         (_OI_POIDATA(pItem)->IntFlags)
#define _OI_TVLEVEL(pItem)          (_OI_POIDATA(pItem)->TVLevel)
#define _OI_EXTFLAGS(pItem)         (_OI_POIDATA(pItem)->OIExtFlags)
#define _OI_LBCBSELIDX(pItem)       (_OI_POIDATA(pItem)->LBCBSelIdx)
#define _OI_CBPDEFSEL(pItem)        (_OI_POIDATA(pItem)->cbpDefSel)
#define _OI_HELPIDX(pItem)          (_OI_POIDATA(pItem)->HelpIdx)
#define _OI_CXEXT(pItem)            (_OI_POIDATA(pItem)->cxExt)
#define _OI_CYEXTADD(pItem)         (_OI_POIDATA(pItem)->cyExtAdd)
#define _OI_HITEM(pItem)            (_OI_POIDATA(pItem)->hItem)
#define _OI_PDEFSEL(pItem)          (_OI_POIDATA(pItem)->pDefSel)
#define _OI_PDEFSEL2(pItem)         (_OI_POIDATA(pItem)->pDefSel2)
#define _OI_DEF_OPTIF(pItem)        (_OI_POIDATA(pItem)->DefOPTIF)
#define _OI_DEF_OPTIF2(pItem)       (_OI_POIDATA(pItem)->DefOPTIF2)
#define _OI_HINST(pItem)            (_OI_POIDATA(pItem)->hInstCaller)
#define _OI_PHELPFILE(pItem)        (_OI_POIDATA(pItem)->pHelpFile)

#define DO_IN_PLACE                 1


#define CPSUIPROP_WNDPROC           (LPCTSTR)0xAFBEL
#define CPSUIPROP_TABTABLE          (LPCTSTR)0xAFBFL
#define CPSUIPROP_PTVWND            (LPCTSTR)0xAFC0L
#define CPSUIPROP                   (LPCTSTR)0xAFC1L
#define CPSUIPROP_LAYOUTPUSH        (LPCTSTR)0xAFC2L
#define CPSUIPROP_CBPRESEL          (LPCTSTR)0xAFC3L

#define ADD_PMYDLGPAGE(hDlg, p)     SetProp(hDlg, CPSUIPROP, (HANDLE)(p))
#define GET_PMYDLGPAGE(hDlg)        ((PMYDLGPAGE)GetProp(hDlg, CPSUIPROP))
#define DEL_PMYDLGPAGE(hDlg)        RemoveProp(hDlg, CPSUIPROP)
#define GET_PTVWND(hDlg)            ((PTVWND)((GET_PMYDLGPAGE(hDlg))->pTVWnd))
#define PAGEIDX_NONE                0xFF


#define INTIDX_FIRST                0xFFFA
#define INTIDX_TVROOT               0xFFFA
#define INTIDX_PAPER                0xFFFB
#define INTIDX_GRAPHIC              0xFFFC
#define INTIDX_OPTIONS              0xFFFD
#define INTIDX_ICM                  0xFFFE
#define INTIDX_ADVANCED             0xFFFF
#define INTIDX_LAST                 0xFFFF

#define INTIDX_TOTAL                (INTIDX_LAST - INTIDX_FIRST + 1)

#define PIDX_INTOPTITEM(pTVWnd,i)   (&((pTVWnd)->IntOptItem[i-INTIDX_FIRST]))
#define PBEG_INTOPTITEM(pTVWnd)     PIDX_INTOPTITEM((pTVWnd), INTIDX_FIRST)
#define PEND_INTOPTITEM(pTVWnd)     PIDX_INTOPTITEM((pTVWnd), INTIDX_LAST)
#define IIDX_INTOPTITEM(pTVWnd,poi) (poi-PBEG_INTOPTITEM(pTVWnd)+INTIDX_FIRST)




#define TVLPF_DISABLED              0x01
#define TVLPF_WARNING               0x02
#define TVLPF_CHANGEONCE            0x04
#define TVLPF_STOP                  0x08
#define TVLPF_HAS_ANGLE             0x10
#define TVLPF_ECBICON               0x20
#define TVLPF_NO                    0x40
#define TVLPF_EMPTYICON             0x80

typedef struct _TVLP {
    WORD    ItemIdx;
    BYTE    Flags;
    BYTE    cName;
    } TVLP, *PTVLP;

#define TVLP2LP(tvlp)               ((LPARAM)*((DWORD *)&(tvlp)))
#define GET_TVLP(l)                 (*((PTVLP)&(l)))


#define DMPUB_HDR_FIRST             DMPUB_USER
#define DMPUB_HDR_TVROOT            (DMPUB_USER + 0)
#define DMPUB_HDR_PAPER             (DMPUB_USER + 1)
#define DMPUB_HDR_GRAPHIC           (DMPUB_USER + 2)
#define DMPUB_HDR_OPTIONS           (DMPUB_USER + 3)
#define DMPUB_HDR_ICM               (DMPUB_USER + 4)

#ifdef _WIN64
    #define LODWORD(u)              (DWORD)((ULONG_PTR)(u) & 0xFFFFFFFF)
    #define HIDWORD(u)              LOUINTPTR(u >> 32)
    #define MKUINTPTR(l,h)          ((ULONG_PTR)(l) | ((ULONG_PTR)(h) << 32))
#else
    #define LODWORD(u)              (DWORD)(u)
    #define HIDWORD(u)              (DWORD)(u)
    #define MKUINTPTR(l,h)          (DWORD)(l)
#endif

#define ID_MASK                 (ULONG_PTR)0xFFFF
#define PTR_MASK                (ULONG_PTR)~ID_MASK
#define VALID_PTR(p)            ((ULONG_PTR)(p) & PTR_MASK)
#define MKHICONID(id)           ((VALID_PTR(id)) ? (id) : (id) | PTR_MASK)
#define GET_HICON(id)           (HICON)((((id) & PTR_MASK) == PTR_MASK) ?   \
                                                ((id) & ID_MASK) : (id))

#if 0
#define MKHICONID(id)           ((HIWORD(id))?(id):MAKELONG((id),0xFFFF))
#define GET_HICON(id)           (HICON)((HIWORD(id)==0xFFFF) ? LOWORD(id) : \
                                                               (id))
#endif

#define GETSELICONID(p)         (ULONG_PTR)(((p)->Flags&OPTIF_SEL_AS_HICON)  \
                                    ? MKHICONID((ULONG_PTR)((p)->pSel)) :    \
                                      (p)->Sel)
#define GET_ICONID(p,f)         (ULONG_PTR)(((p)->Flags & (f)) ?             \
                                    MKHICONID((ULONG_PTR)((p)->IconID)) :    \
                                    (p)->IconID)

#define GET_PITEMDMPUB(p, i, Idx)                                           \
    ((((i)<=DMPUB_LAST) && (((Idx)=(p)->DMPubIdx[(i)-DMPUB_FIRST])!=0xFFFF))\
        ? ((p)->ComPropSheetUI.pOptItem + (Idx)) : NULL)


typedef struct _TVOTSTATESINFO {
    WORD    Top;
    WORD    Inc;
} TVOTSTATESINFO, *PTVOTSTATESINFO;


#define MYDPF_CHANGED           0x0001
#define MYDPF_CHANGEONCE        0x0002
#define MYDPF_REINIT            0x0004
#define MYDPF_PAGE_ACTIVE       0x0008


#define MYDP_ID                 0x49555043

typedef struct _MYDLGPAGE {
    DWORD       ID;
    ULONG_PTR   CPSUIUserData;
    HWND        hDlgChild;
    HWND        hWndFocus;
    PPSPINFO    pPSPInfo;
    POPTITEM    pCurItem;
    WORD        Flags;
    BYTE        PageIdx;
    BYTE        NotUsed;
    DLGPAGE     DlgPage;
    HICON       hIcon;
    LPVOID      pTVWnd;
    WORD        cItem;
    WORD        cHide;
    } MYDLGPAGE, *PMYDLGPAGE;


typedef struct _TVWND {
    HWND            hWndTV;
    WNDPROC         TVWndProc;
    HFONT           hBoldFont;
    HWND            hDlgTV;
#if DO_IN_PLACE
    POPTITEM        pMouseItem;
    LPARAM          MousePos;
    HFONT           hTVFont[4];
    HWND            hWndEdit[3];
    BYTE            chWndEdit;
    BYTE            cyImage;
    BYTE            yLinesOff;
    BYTE            bNotUsed;
    WORD            cxEdit;
    WORD            cxItem;
    WORD            cxMaxItem;
    WORD            cxMaxUDEdit;
    POINTL          ptCur;
    HWND            hWndExt;
    HDC             hDCTVWnd;
    WORD            cxCBAdd;
    WORD            cxChkBoxAdd;
    WORD            cxSelAdd;
    WORD            cxExtAdd;
    WORD            cxAveChar;
    WORD            cxSpace;
#endif
    HANDLE          hCPSUIPage;
    LPDWORD         pRootFlags;
    HINSTANCE       hInstCaller;
    POPTITEM        pCurTVItem;
    POPTITEM        pLastItem;
    HIMAGELIST      himi;
    PMYDLGPAGE      pMyDlgPage;
    LPDWORD         pIcon16ID;
    WORD            Icon16Count;
    WORD            Icon16Added;
    WORD            Flags;
    WORD            VKeyTV;
    WORD            cxcyTVIcon;
    WORD            cxcyECBIcon;
    BYTE            TVPageIdx;
    BYTE            StdPageIdx1;
    BYTE            StdPageIdx2;
    BYTE            cMyDlgPage;
    BYTE            ActiveDlgPage;
    WORD            xCtrls;
    WORD            yECB;
    WORD            IntTVOptIdx;
    WORD            tLB;
    WORD            yLB[2];
    TVOTSTATESINFO  SI2[2];
    TVOTSTATESINFO  SI3[2];
    WORD            DMPubIdx[(DMPUB_LAST + 1) & ~1];
    OPTITEM         IntOptItem[INTIDX_TOTAL];
    OIDATA          IntOIData[INTIDX_TOTAL];
    OPTPARAM        OptParamNone;
    BYTE            cInitMyDlgPage;
    BYTE            bReserved;
    BYTE            cDMPub;
    BYTE            OverlayIconBits;
    PCOMPROPSHEETUI pCPSUI;
    COMPROPSHEETUI  ComPropSheetUI;
    } TVWND, *PTVWND;



#define OPTIF_INT_ADDED         0x80000000L
#define OPTIF_INT_CHANGED       0x40000000L
#define OPTIF_INT_TV_CHANGED    0x20000000L
#define OPTIF_INT_HIDE          0x10000000L

#define OPTIF_INT_MASK          0xF0000000L
#define OPTIF_ITEM_HIDE         (OPTIF_HIDE | OPTIF_INT_HIDE)
#define OPTIF_ENTER_MASK        (OPTIF_CHANGED          |   \
                                 OPTIF_CHANGEONCE)
#define OPTIF_EXIT_MASK         OPTIF_CHANGED
#define OPTIF_ECB_MASK          (OPTIF_ECB_CHECKED      |   \
                                 OPTIF_EXT_HIDE         |   \
                                 OPTIF_EXT_DISABLED)

#define IS_HDR_PUSH(po)         (BOOL)((po) == &OptTypeHdrPush)
#define GET_POPTTYPE(pi)        (((pi)->pOptType) ? (pi)->pOptType :        \
                                                    &OptTypeHdrPush)

//
// This is used by the TreeViewChangeMode()
//

#define TVCM_TOGGLE             1
#define TVCM_SELECT             2

//
// this is used for the treeview page initialization
//

typedef struct _TVDLGITEM {
    BYTE    cItem;              // count of item start from BegID
    BYTE    NotUsed;            // not used
    WORD    BegID;              // first control window ID
    } TVDLGITEM, *PTVDLGITEM;


//
// This is used to add the public header and order the DMPUB in the treeview
//


#define ITVG_LEVEL_MASK     0x0F
#define ITVGF_COLLAPSE      0x80
#define ITVGF_BOLD          0x40

typedef struct _INTTVGRP {
    BYTE    LevelFlags;         // level/flags in the public treeview header
    BYTE    DMPubID;            // DMPUB_xxxx, DMPUB_HDR_xxxx
    } INTTVGRP, *PINTTVGRP;



//
// SKIP ITEM CHILDREN
//
//

#define WHILE_SKIP_CHILDREN(pItem, pLastItem, ItemLevel)                    \
    while ((++(pItem) <= (pLastItem)) && ((pItem)->Level > ItemLevel))

#define SKIP_CHILDREN(p,pl,l)       WHILE_SKIP_CHILDREN(p,pl,l)

#define SKIP_CHILDREN_ORFLAGS(pItem, pLastItem, ItemLevel, OrFlags)         \
    do {                                                                    \
        (pItem)->Flags |= (OrFlags);                                        \
    } WHILE_SKIP_CHILDREN(pItem, pLastItem, ItemLevel)

#define SKIP_CHILDREN_ANDFLAGS(pItem, pLastItem, ItemLevel, AndFlags)       \
    do {                                                                    \
        (pItem)->Flags &= (AndFlags);                                       \
    } WHILE_SKIP_CHILDREN(pItem, pLastItem, ItemLevel)



//
// Prototypes
//

#define CROIF_DO_SIBLING    0x0001
#define CROIF_REVERT        0x0002
#define CROIF_REVERT_DEF2   0x0004

VOID
SetTVItemState(
    PTVWND          pTVWnd,
    TV_INSERTSTRUCT *ptvins,
    POPTITEM        pCurItem
    );

POPTITEM
SetupTVSelect(
    HWND        hDlg,
    NM_TREEVIEW *pNMTV,
    DWORD       STVSMode
    );

UINT
CountRevertOptItem(
    PTVWND      pTVWnd,
    POPTITEM    pOptItem,
    HTREEITEM   hItem,
    DWORD       Flags
    );

POPTITEM
GetOptions(
    PTVWND      pTVWnd,
    LPARAM      lParam
    );

CPSUICALLBACK
InternalRevertOptItem(
    PCPSUICBPARAM   pCBParam
    );

LONG
UpdateTreeViewItem(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem,
    BOOL        ReInit
    );

LONG
UpdateTreeView(
    HWND        hDlg,
    PMYDLGPAGE  pMyDlgPage
    );

POPTITEM
TreeViewHitTest(
    PTVWND      pTVWnd,
    LONG        MousePos,
    UINT        TVHTMask
    );

VOID
TreeViewChangeMode(
    PTVWND      pTVWnd,
    POPTITEM    pItem,
    UINT        Mode
    );

INT_PTR
CALLBACK
TreeViewProc(
    HWND    hDlg,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\tvctrl.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    tvctrl.h


Abstract:

    This module contains all defineds for the treeview


Author:

    17-Oct-1995 Tue 16:39:11 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/



#define MAGIC_INDENT    3


VOID
DeleteTVFonts(
    PTVWND  pTVWnd
    );

BOOL
CreateTVFonts(
    PTVWND  pTVWnd,
    HFONT   hTVFont
    );

LRESULT
CALLBACK
MyTVWndProc(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    );

LRESULT
CALLBACK
FocusCtrlProc(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\treeview.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    treeview.c


Abstract:

    This module contains tree view function for the printer driver


Author:

    19-Jun-1995 Mon 11:50:26 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


#define DBG_CPSUIFILENAME   DbgTreeView



#define DBG_AI              0x00000001
#define DBG_UTV             0x00000002
#define DBG_MAI             0x00000004
#define DBG_CTVWND          0x00000008
#define DBG_AC              0x00000010
#define DBG_TVPROC          0x00000020
#define DBG_STVS            0x00000040
#define DBG_AIG             0x00000080
#define DBGITEM_INS         0x00000100
#define DBGITEM_SET         0x00000200
#define DBGITEM_AIG         0x00000400
#define DBGITEM_SETUP       0x00000800
#define DBGITEM_HIT         0x00001000
#define DBGITEM_NEXTGRP     0x00002000
#define DBGITEM_ADDITEM     0x00004000
#define DBG_LBSIZE          0x00008000
#define DBG_COTD            0x00010000
#define DBG_INITDLG         0x00020000
#define DBG_APG             0x00040000
#define DBGITEM_SELCHG      0x00080000
#define DBGITEM_UTV         0x00100000
#define DBG_MSR             0x00200000
#define DBGITEM_NEWICON     0x00400000
#define DBG_TVHT            0x00800000
#define DBGITEM_CREVERT     0x01000000
#define DBGITEM_REVERT      0x02000000
#define DBG_OEM_ITEM        0x04000000
#define DBG_SCID            0x08000000
#define DBG_KEYS            0x10000000
#define DBG_ASSERT          0x80000000

DEFINE_DBGVAR(0);


CPSUIDBGBLK(extern LPSTR pTVOTName[])


#define ICON_SIZE_ANY   0


extern       HINSTANCE  hInstDLL;
extern       OPTTYPE    OptTypeHdrPush;
extern       OPTPARAM   OptParamHdrPush;


static const TVDLGITEM  TVDlgItem[] = {

    {    5, 0, IDD_3STATES_1     },      //  0 TVOT_2STATES
    {    5, 0, IDD_3STATES_1     },      //  1 TVOT_3STATES
    {    4, 0, IDD_TV_UDARROW    },      //  2 TVOT_UDARROW
    {    3, 0, IDD_TV_TRACKBAR   },      //  3 TVOT_TRACKBAR
    {    3, 0, IDD_TV_SB         },      //  4 TVOT_SCROLLBAR
    {    1, 0, IDD_TV_LB         },      //  5 TVOT_LISTBOX
    {    1, 0, IDD_TV_CB         },      //  6 TVOT_COMBOBOX
    {    3, 0, IDD_TV_EDIT_EDIT  },      //  7 TVOT_EDITBOX
    {    1, 0, IDD_TV_PUSH       },      //  8 TVOT_PUSHBUTTON
    {    1, 0, IDD_TV_CHKBOX     },      //  9 TVOT_CHKBOX
    {    1, 0, IDD_TV_EXTPUSH    },
    {    1, 0, IDD_TV_EXTCHKBOX  }
};



#define ITVGF_BPCL      (ITVGF_BOLD | ITVGF_COLLAPSE)

static const INTTVGRP   IntTVGrpPaper[] = {

        { 1,                    DMPUB_HDR_PAPER             },
            { 2,                    DMPUB_FORMNAME          },
            { 2,                    DMPUB_ORIENTATION       },
            { 2,                    DMPUB_DEFSOURCE         },
            { 2,                    DMPUB_OUTPUTBIN         },
            { 2,                    DMPUB_MEDIATYPE         },
            { 2,                    DMPUB_COPIES_COLLATE    },
            { 2,                    DMPUB_DUPLEX            },
            { 2,                    DMPUB_PAGEORDER         },
            { 2,                    DMPUB_NUP               },
        { 0,                    DMPUB_HDR_TVROOT            }
    };

static const INTTVGRP   IntTVGrpGraphic[] = {

        { 1,                    DMPUB_HDR_GRAPHIC           },
            { 2,                    DMPUB_QUALITY           },
            { 2,                    DMPUB_PRINTQUALITY      },
            { 2 ,                   DMPUB_COLOR             },
            { 2 | ITVGF_BOLD,       DMPUB_HDR_ICM           },
                { 3,                    DMPUB_ICMMETHOD     },
                { 3,                    DMPUB_ICMINTENT     },
            { 2,                    DMPUB_SCALE             },
            { 2,                    DMPUB_DITHERTYPE        },
            { 2,                    DMPUB_TTOPTION          },
        { 0,                    DMPUB_HDR_TVROOT            }
    };

static  const WORD  ChkBoxStrID[] = { IDS_CPSUI_FALSE,
                                      IDS_CPSUI_TRUE,
                                      IDS_CPSUI_NO,
                                      IDS_CPSUI_YES,
                                      IDS_CPSUI_OFF,
                                      IDS_CPSUI_ON,
                                      IDS_CPSUI_FALSE,
                                      0,
                                      IDS_CPSUI_NO,
                                      0,
                                      IDS_CPSUI_OFF,
                                      0,
                                      IDS_CPSUI_NONE,
                                      0 };


#define STVS_REINIT         0x0001
#define STVS_ACTIVE         0x0002

POPTITEM
GetOptions(
    PTVWND      pTVWnd,
    LPARAM      lParam
    )
{
    TVLP    tvlp;

    tvlp = GET_TVLP(lParam);

    if (tvlp.ItemIdx >= INTIDX_FIRST) {

        return(PIDX_INTOPTITEM(pTVWnd, tvlp.ItemIdx));

    } else if (tvlp.ItemIdx < pTVWnd->ComPropSheetUI.cOptItem) {

        return(pTVWnd->ComPropSheetUI.pOptItem + tvlp.ItemIdx);

    } else {

        CPSUIERR(("ERROR: GetOptions(tvlp): Idx=%04lx, cName=%ld, Flags=%02lx",
                    (DWORD)tvlp.ItemIdx, (DWORD)tvlp.cName, (DWORD)tvlp.Flags));

        return(PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT));
    }
}


#if (DO_IN_PLACE == 0)


VOID
MoveStateRadios(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTTYPE    pOptType,
    WORD        InitFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    02-Sep-1995 Sat 21:08:14 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND            hCtrl;
    UINT            x;
    UINT            CtrlID;
    UINT            Count;
    UINT            HideBits;
    TVOTSTATESINFO  TSI;


    x = (InitFlags & INITCF_HAS_EXT) ? 0 : 1;

    if ((HideBits = (UINT)(_OT_FLAGS(pOptType) & OTINTF_STATES_HIDE_MASK)) ||
        (pOptType->Type == TVOT_2STATES)) {

        TSI = pTVWnd->SI2[x];

        if (!HideBits) {

            HideBits |= 0x04;
        }

    } else {

        TSI = pTVWnd->SI3[x];
    }

    CPSUIDBG(DBG_MSR, ("!! %hs: TSI: Top=%d, Inc=%d, Hide=%02x",
            pTVOTName[pOptType->Type], TSI.Top, TSI.Inc, HideBits));

    x      = (UINT)pTVWnd->xCtrls;
    Count  = 3;
    CtrlID = IDD_3STATES_1;

    while (Count--) {

        if (hCtrl = GetDlgItem(hDlg, CtrlID)) {

            if (HideBits & 0x01) {

                ShowWindow(hCtrl, SW_HIDE);
                EnableWindow(hCtrl, FALSE);

                CPSUIDBG(DBG_MSR,
                         ("HIDE Radio Idx=%d (%d, %d)", 3-Count, x, TSI.Top));

            } else {

                CPSUIDBG(DBG_MSR,
                         ("SHOW Radio Idx=%d (%d, %d)", 3-Count, x, TSI.Top));

                SetWindowPos(hCtrl, NULL,
                             x, TSI.Top,
                             0, 0,
                             SWP_NOSIZE | SWP_NOZORDER);

                TSI.Top += TSI.Inc;
            }
        }

        CtrlID    += 2;
        HideBits >>= 1;
    }
}

#endif



VOID
SetOptHeader(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem,
    BOOL        HdrPush
    )

/*++

Routine Description:

    This function setup the string in the TREEVIEW page change item windows
    group box title.

Arguments:




Return Value:




Author:

    16-Oct-1995 Mon 19:23:36 created  -by-  Daniel Chou (danielc)


Revision History:

    20-Jul-1996 Sat 00:26:33 updated  -by-  Daniel Chou (danielc)
        Fixed the internationalize problem for compsition dynamic user data



--*/

{
    POPTITEM    pRootItem = PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT);
    UINT        IntFmtStrID;
    GSBUF_DEF(pItem, MAX_RES_STR_CHARS + 80);


    if (HdrPush) {

        //
        // Root Header item:  XXX Document/Advance Document/Device Settings
        // Other Header Item: XXX Options

        if (pItem == pRootItem) {

            GSBUF_FLAGS |= GBF_PREFIX_OK | GBF_DUP_PREFIX;
            IntFmtStrID  = (UINT)pRootItem->UserData;

        } else {

            IntFmtStrID = (UINT)IDS_INT_CPSUI_OPTIONS;
        }

    } else {

        IntFmtStrID = IDS_INT_CPSUI_CHANGE_SET;
    }

    GSBUF_COMPOSE(IntFmtStrID, pItem->pName, 0, 0);

    SetWindowText(GetDlgItem(hDlg, IDD_TV_OPTION), GSBUF_BUF);
}



VOID
ChangeOptTypeDisplay(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTTYPE    pOldOptType,
    POPTTYPE    pNewOptType,
    BOOL        NewTypeUpdatePermission
    )

/*++

Routine Description:

    This function hide the old type and enable the new type's option
    header/icon depends on the NewTypeEnable flag

Arguments:

    hDlg                    - Handle to the dialog box

    pTVWnd                  - Pointer to TVWND structure of our instance data

    pCurItem                - Pointer to OPTITEM associate with NewType

    pOldOptType             - Pointer to the OLD OPTTYPE

    pNewOptType             - Pointer to the NEW OPTTYPE

    NewTypeUpdatePermission - TRUE if new type is not disabled


Return Value:

    VOID


Author:

    21-Jun-1995 Wed 20:30:53 created  -by-  Daniel Chou (danielc)

    31-Aug-1995 Thu 18:34:16 updated  -by-  Daniel Chou (danielc)
        Updated according to the usage of DlgCtrl.c


Revision History:


--*/

{
    HWND    hCtrl;
    BOOL    Enable;
    UINT    OldType;
    UINT    NewType;
    INT     swMode;


    if ((pOldOptType != pNewOptType)    &&
        (pOldOptType)                   &&
        ((OldType = (UINT)pOldOptType->Type) <= TVOT_LAST)) {

        TVDLGITEM   tdi;

#if DO_IN_PLACE
        CPSUIINT(("OldType=%ld, NewType=%ld, hWndEdit=%08lx:%08lx:%08lx",
                OldType,
                (pNewOptType) ? pNewOptType->Type : - 1,
                pTVWnd->hWndEdit[0], pTVWnd->hWndEdit[1], pTVWnd->hWndEdit[2]));

        switch (OldType) {

        case TVOT_2STATES:
        case TVOT_3STATES:
        case TVOT_LISTBOX:
        case TVOT_CHKBOX:

            OldType = TVOT_COMBOBOX;
            break;

        case TVOT_SCROLLBAR:
        case TVOT_TRACKBAR:
#if 1
            OldType = TVOT_UDARROW;
#else
            if (pOldOptType->pOptParam[2].IconID <= 1) {

                OldType = TVOT_UDARROW;
            }

#endif
            break;

        default:

            break;

        }

        pTVWnd->chWndEdit = 0;
#endif

        CPSUIINT(("OldType=%ld, NewType=%ld", OldType,
                    (pNewOptType) ? pNewOptType->Type : - 1));

        tdi = TVDlgItem[OldType];

        while (tdi.cItem--) {

            if (hCtrl = GetDlgItem(hDlg, tdi.BegID++)) {

                EnableWindow(hCtrl, FALSE);
                ShowWindow(hCtrl, SW_HIDE);

                CPSUIINT(("Disable/Hide hCtrl=%08lx (%ld)",
                        hCtrl, tdi.BegID - 1));
            }

            if (tdi.BegID == (IDD_TV_TRACKBAR + 1)) {

                tdi.BegID = IDD_TV_SB_LOW;
            }
        }
    }

    //
    // Display option header, icon if any
    //

    NewType = (UINT)((pNewOptType) ? pNewOptType->Type : TVOT_NONE);

    if (Enable = (BOOL)(NewType <= TVOT_LAST)) {

        swMode = SW_SHOW;

        if ((!NewTypeUpdatePermission) ||
            (!(pTVWnd->Flags & TWF_CAN_UPDATE))) {

            Enable = FALSE;
        }

    } else {

        swMode = SW_HIDE;
    }

    ShowWindow(hCtrl = GetDlgItem(hDlg, IDD_TV_OPTION), swMode);
    EnableWindow(hCtrl, Enable);
    ShowWindow(GetDlgItem(hDlg, IDD_TV_ICON), swMode);

    //
    // We only show the hdr push icon if it is not disabled
    //

#if 0
    ShowWindow(GetDlgItem(hDlg, IDD_TV_HDR_PUSH_ICON),
               ((pNewOptType)               &&
                (IS_HDR_PUSH(pNewOptType))  &&
                (!(pNewOptType->Flags & OPTTF_TYPE_DISABLED))) ? SW_SHOW :
                                                                 SW_HIDE);
#endif

    CPSUIDBG(DBG_COTD, ("OldType=%ld, NewType=%ld, Enable=%ld, swMode=%ld",
                (LONG)OldType, (LONG)NewType, (DWORD)Enable, (DWORD)swMode));
}



LRESULT
CALLBACK
MyEditWndProc(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    This is the subclass WNDPROC for the numberical edit control, it check
    valid input for the number entered.


Arguments:

    WNDPROC standard


Return Value:

    INT (The original WNDPROC returned), if the entered keys are not valid
    then it return right away without processing


Author:

    20-Mar-1996 Wed 15:36:48 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PTVWND  pTVWnd;
    WNDPROC OldWndProc;


    if (OldWndProc = (WNDPROC)GetProp(hWnd, CPSUIPROP_WNDPROC)) {

        switch (Msg) {

        case WM_KEYDOWN:

            if (ChkEditKEYDOWN(hWnd, wParam)) {

                return(0);
            }

            break;

        case WM_DESTROY:

            SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LPARAM)OldWndProc);
            RemoveProp(hWnd, CPSUIPROP_WNDPROC);
            RemoveProp(hWnd, CPSUIPROP_PTVWND);

            break;

        default:

            break;
        }

        return(CallWindowProc(OldWndProc, hWnd, Msg, wParam, lParam));

    } else {

        CPSUIERR(("MyEditWndProc: GetProc(%08lx) FAILED", hWnd));

        return(0);
    }
}




VOID
DrawPushFocusRect(
    HWND    hWnd
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-Aug-1998 Thu 11:21:49 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{

    if (GetFocus() == hWnd) {

        HDC     hDC;
        RECT    rc;

        GetClientRect(hWnd, &rc);
        hDC = GetWindowDC(hWnd);

        rc.left   += 3;
        rc.top    += 3;
        rc.right  -= 3;
        rc.bottom -= 3;

        if (hDC) {

            DrawFocusRect(hDC, &rc);
            ReleaseDC(hWnd, hDC);
        }
    }
}



LRESULT
CALLBACK
PushWndProc(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    This is the subclass WNDPROC for the numberical edit control, it check
    valid input for the number entered.


Arguments:

    WNDPROC standard


Return Value:

    INT (The original WNDPROC returned), if the entered keys are not valid
    then it return right away without processing


Author:

    20-Mar-1996 Wed 15:36:48 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HDC     hDC;
    PTVWND  pTVWnd;
    WNDPROC OldWndProc;
    RECT    rc;
    LRESULT Result;


    if (OldWndProc = (WNDPROC)GetProp(hWnd, CPSUIPROP_WNDPROC)) {

        switch (Msg) {

        case WM_KILLFOCUS:

            break;

        case WM_SETFOCUS:

            InvalidateRect(hWnd, NULL, FALSE);

            break;

        case WM_PAINT:
        case WM_NCPAINT:

            Result = CallWindowProc(OldWndProc, hWnd, Msg, wParam, lParam);
            DrawPushFocusRect(hWnd);
            return(Result);

        case WM_GETDLGCODE:

            return(DLGC_WANTARROWS);

        case WM_KEYDOWN:

            CPSUIDBG(DBG_KEYS,
                     ("PushWndProc: WM_KEYDOWN, VKey=%ld", wParam));

            if (ChkhWndEdit0KEYDOWN(hWnd, wParam)) {

                return(0);
            }

            break;

        case WM_DESTROY:

            SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LPARAM)OldWndProc);
            RemoveProp(hWnd, CPSUIPROP_WNDPROC);
            RemoveProp(hWnd, CPSUIPROP_PTVWND);

            break;

        default:

            break;
        }

        return(CallWindowProc(OldWndProc, hWnd, Msg, wParam, lParam));

    } else {

        CPSUIERR(("PushWndProc: GetProc(%08lx) FAILED", hWnd));

        return(0);
    }
}





LRESULT
CALLBACK
ExtWndProc(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    This is the subclass WNDPROC for the numberical edit control, it check
    valid input for the number entered.


Arguments:

    WNDPROC standard


Return Value:

    INT (The original WNDPROC returned), if the entered keys are not valid
    then it return right away without processing


Author:

    20-Mar-1996 Wed 15:36:48 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HDC     hDC;
    PTVWND  pTVWnd;
    WNDPROC OldWndProc;
    RECT    rc;
    LRESULT Result;


    if (OldWndProc = (WNDPROC)GetProp(hWnd, CPSUIPROP_WNDPROC)) {

        switch (Msg) {

        case WM_KILLFOCUS:

            break;

        case WM_SETFOCUS:

            InvalidateRect(hWnd, NULL, FALSE);

            break;

        case WM_PAINT:
        case WM_NCPAINT:

            Result = CallWindowProc(OldWndProc, hWnd, Msg, wParam, lParam);

            if ((GetWindowLongPtr(hWnd, GWL_STYLE) & 0x0F) == 0) {

                DrawPushFocusRect(hWnd);
            }

            return(Result);

        case WM_GETDLGCODE:

            return(DLGC_WANTARROWS);

        case WM_KEYDOWN:

            CPSUIDBG(DBG_KEYS,
                     ("ExtWndProc: WM_KEYDOWN, VKey=%ld", wParam));

            switch (wParam) {

            case VK_LEFT:
            case VK_BACK:
            case VK_RIGHT:

                if (pTVWnd = (PTVWND)GetProp(hWnd, CPSUIPROP_PTVWND)) {

                    switch (wParam) {

                    case VK_LEFT:
                    case VK_BACK:

                        if (pTVWnd->hWndEdit[0]) {

                            SetFocus(pTVWnd->hWndEdit[0]);
                            return(0);
                        }

                    case VK_RIGHT:

                        return(0);

                    default:

                        break;
                    }
                }

                break;
            }

            break;

        case WM_DESTROY:

            SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LPARAM)OldWndProc);
            RemoveProp(hWnd, CPSUIPROP_WNDPROC);
            RemoveProp(hWnd, CPSUIPROP_PTVWND);

            break;

        default:

            break;
        }

        return(CallWindowProc(OldWndProc, hWnd, Msg, wParam, lParam));

    } else {

        CPSUIERR(("MyCBWndProc: GetProc(%08lx) FAILED", hWnd));

        return(0);
    }
}



VOID
InitDlgCtrl(
    HWND    hDlg,
    PTVWND  pTVWnd
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    05-Jul-1995 Wed 17:49:58 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hWndTV = pTVWnd->hWndTV;
    HFONT   hFont;
    HWND    hCtrl;
    RECT    rc;
    RECT    rc2;
    DWORD   dw;
    WORD    tECB;
    WORD    bECB;
    WORD    tLB;
    WORD    bLB;
    WORD    cyUnit;
    WORD    cyStates;
    LONG    tOpt;
    LONG    bOpt;
    LONG    cx;
    LONG    cy;
    UINT    i;
    WORD    InitItemIdx = 0xFFFE;


    ReCreateLBCB(hDlg, IDD_TV_LB, TRUE);
    dw = ReCreateLBCB(hDlg, IDD_TV_CB, FALSE);
    CreateTrackBar(hDlg, IDD_TV_TRACKBAR);
    CreateUDArrow(hDlg, IDD_TV_UDARROW_EDIT, IDD_TV_UDARROW, 0, 100, 50);

#if DO_IN_PLACE
    CtrlIDrcWnd(hDlg, IDD_TV_UDARROW, &rc);
    CtrlIDrcWnd(hDlg, IDD_TV_UDARROW_EDIT, &rc2);

    pTVWnd->cxCBAdd      = LOWORD(dw);
    pTVWnd->cxMaxUDEdit += LOWORD(dw);

    CtrlIDrcWnd(hDlg, IDD_TV_CHKBOX, &rc);

    pTVWnd->cxChkBoxAdd = (WORD)(rc.right - rc.left);
    pTVWnd->cxChkBoxAdd = (WORD)GetSystemMetrics(SM_CXSMICON);

    CPSUIINT(("cxCBAdd = %ld, cxChkBoxAdd=%ld",
                pTVWnd->cxCBAdd, pTVWnd->cxChkBoxAdd));

    if (hCtrl = GetDlgItem(hDlg, IDD_TV_EDIT_EDIT)) {

        SetProp(hCtrl,
                CPSUIPROP_WNDPROC,
                (HANDLE)GetWindowLongPtr(hCtrl, GWLP_WNDPROC));
        SetProp(hCtrl, CPSUIPROP_PTVWND, (HANDLE)pTVWnd);
        SetWindowLongPtr(hCtrl, GWLP_WNDPROC, (LPARAM)MyEditWndProc);
    }

    if (hCtrl = GetDlgItem(hDlg, IDD_TV_PUSH)) {

        SetProp(hCtrl,
                CPSUIPROP_WNDPROC,
                (HANDLE)GetWindowLongPtr(hCtrl, GWLP_WNDPROC));
        SetProp(hCtrl, CPSUIPROP_PTVWND, (HANDLE)pTVWnd);
        SetWindowLongPtr(hCtrl, GWLP_WNDPROC, (LPARAM)PushWndProc);
    }

    hFont = pTVWnd->hTVFont[0];

#endif

    for (i = 0; i < COUNT_ARRAY(TVDlgItem); i++) {

        TVDLGITEM   tdi;
        HWND        hCtrl;


        tdi = TVDlgItem[i];

        while (tdi.cItem--) {

            if (hCtrl = GetDlgItem(hDlg, tdi.BegID++)) {

                ShowWindow(hCtrl, SW_HIDE);
                EnableWindow(hCtrl, FALSE);
                SETCTRLDATA(hCtrl, CTRLS_TV_STATIC, 0);
#if DO_IN_PLACE
                SetParent(hCtrl, hWndTV);
                SendMessage(hCtrl, WM_SETFONT, (WPARAM)hFont, 0);

                SetWindowLongPtr(hCtrl,
                                 GWL_EXSTYLE,
                                 GetWindowLongPtr(hCtrl, GWL_EXSTYLE) |
                                                    WS_EX_CONTEXTHELP);
#endif
                if (tdi.BegID == (IDD_TV_TRACKBAR + 1)) {

                    tdi.BegID = IDD_TV_SB_LOW;
                }
            }
        }
    }

    //
    // Set MSAA name label as a child of treeview dialog
    //
    if (hCtrl = GetDlgItem(hDlg, IDD_TV_MSAA_NAME)) 
    {
        SetParent(hCtrl, hWndTV);
    }

    //
    // Figure how to expand/shrink the listbox in the treeview page, the
    // maximum for non ExtChkBox/ExtPush is at bottom of Extended control
    // otherwise the maximu is at top of Extended control - space between
    // bottom of extended control and option header bottom
    //

#if DO_IN_PLACE
    hCtrl = GetDlgItem(hWndTV, IDD_TV_EXTPUSH);
#else
    hCtrl = GetDlgItem(hDlg, IDD_TV_EXTPUSH);
#endif
    ShowWindow(hCtrl, SW_HIDE);
    EnableWindow(hCtrl, FALSE);

    SetProp(hCtrl,
            CPSUIPROP_WNDPROC,
            (HANDLE)GetWindowLongPtr(hCtrl, GWLP_WNDPROC));
    SetProp(hCtrl, CPSUIPROP_PTVWND, (HANDLE)pTVWnd);
    SetWindowLongPtr(hCtrl, GWLP_WNDPROC, (LPARAM)ExtWndProc);

#if DO_IN_PLACE
    hCtrl = CtrlIDrcWnd(hWndTV, IDD_TV_EXTCHKBOX, &rc);
#else
    hCtrl = CtrlIDrcWnd(hDlg, IDD_TV_EXTCHKBOX, &rc);
#endif
    ShowWindow(hCtrl, SW_HIDE);
    EnableWindow(hCtrl, FALSE);
    SETCTRLDATA(hCtrl, CTRLS_TV_STATIC, 0);

    pTVWnd->yECB   =
    tECB           = (WORD)rc.top;
    bECB           = (WORD)rc.bottom;

#if DO_IN_PLACE
    SetProp(hCtrl,
            CPSUIPROP_WNDPROC,
            (HANDLE)GetWindowLongPtr(hCtrl, GWLP_WNDPROC));
    SetProp(hCtrl, CPSUIPROP_PTVWND, (HANDLE)pTVWnd);
    SetWindowLongPtr(hCtrl, GWLP_WNDPROC, (LPARAM)ExtWndProc);

    CtrlIDrcWnd(hWndTV, IDD_TV_LB, &rc);
#else
    CtrlIDrcWnd(hDlg, IDD_TV_LB, &rc);
#endif

    pTVWnd->xCtrls = (WORD)rc.left;
    pTVWnd->tLB    =
    tLB            = (WORD)rc.top;
    bLB            = (WORD)rc.bottom;

    hCtrl = CtrlIDrcWnd(hDlg, IDD_TV_OPTION, &rc);

    ShowWindow(hCtrl, SW_HIDE);
    EnableWindow(hCtrl, TRUE);
    SETCTRLDATA(hCtrl, CTRLS_TV_STATIC, 0);
    pTVWnd->yLB[0] = (WORD)(tECB - (rc.bottom - bECB) - tLB);
    pTVWnd->yLB[1] = bECB - tLB;

    tOpt = tLB;
    bOpt = tECB;

    CPSUIDBG(DBG_INITDLG, ("!! yLB=(%ld / %ld) !!",
                                    pTVWnd->yLB[0], pTVWnd->yLB[1]));

    //
    // Figure how to move 2 states, and 3 states, basically this is range
    // in the space between top and bottom of options header
    //
#if DO_IN_PLACE
    CtrlIDrcWnd(hWndTV, IDD_3STATES_1, &rc);
#else
    CtrlIDrcWnd(hDlg, IDD_3STATES_1, &rc);
#endif
    cyStates = (WORD)(rc.bottom - rc.top);

    //
    // For 2/3 states, there is top, increment, one with extended and one not
    //

    cy                 = (LONG)(bLB - tLB);
    cyUnit             = (WORD)((cy - (cyStates * 2) + 1) / 3);
    pTVWnd->SI2[0].Top = tLB + (WORD)cyUnit;
    pTVWnd->SI2[0].Inc = (WORD)(cyStates + cyUnit);

    cyUnit             = (WORD)((cy - (cyStates * 3) + 2) / 4);
    pTVWnd->SI3[0].Top = tLB + (WORD)cyUnit;
    pTVWnd->SI3[0].Inc = (WORD)(cyStates + cyUnit);

    cy                 = (LONG)(bOpt - tOpt);
    cyUnit             = (WORD)((cy - (cyStates * 2) + 1) / 3);
    pTVWnd->SI2[1].Top = (WORD)tOpt + (WORD)cyUnit;
    pTVWnd->SI2[1].Inc = (WORD)(cyStates + cyUnit);

    cyUnit             = (WORD)((cy - (cyStates * 3) + 2) / 4);
    pTVWnd->SI3[1].Top = (WORD)tOpt + (WORD)cyUnit;
    pTVWnd->SI3[1].Inc = (WORD)(cyStates + cyUnit);

    CPSUIINT(("SI2[0]=%d, %d, SI2[1]=%d, %d, SI3[0]=%d, %d, SI3[1]=%d, %d",
                pTVWnd->SI2[0].Top, pTVWnd->SI2[0].Inc,
                pTVWnd->SI2[1].Top, pTVWnd->SI2[1].Inc,
                pTVWnd->SI3[0].Top, pTVWnd->SI3[0].Inc,
                pTVWnd->SI3[1].Top, pTVWnd->SI3[1].Inc));

    //
    // Change the static rectangle to the static ICON style and how big the
    // icon will stretch to
    //

    hCtrl  = CtrlIDrcWnd(hDlg, IDD_TV_ICON, &rc);
    dw     = (DWORD)GetWindowLongPtr(hCtrl, GWL_STYLE);
    dw    &= ~SS_TYPEMASK;
    dw    |= (SS_ICON | SS_CENTERIMAGE);
    SetWindowLongPtr(hCtrl, GWL_STYLE, dw);

    ShowWindow(hCtrl, SW_HIDE);
    EnableWindow(hCtrl, TRUE);
    SETCTRLDATA(hCtrl, CTRLS_TV_STATIC, 0);

    //
    // We want to make sure that the cx/cy TVICON is the same size, if not
    // then we will correct it and adjust it to the right size
    //

#if ICON_SIZE_ANY
    if ((cx = rc.right - rc.left) != (cy = rc.bottom - rc.top)) {

        CPSUIINT(("\nORIGINAL TVIcon=(%ld, %ld) %ld x %ld",
                                                rc.left, rc.top, cx, cy));

        cy = cx;
    }
#else
    cx =
    cy = 32;
#endif

    rc.left = rc.left + ((rc.right - rc.left - cx + 1) / 2);
    rc.top  = (LONG)(tOpt + ((bOpt - tOpt - cy + 1) / 2));

    SetWindowPos(hCtrl, NULL, rc.left, rc.top, cx, cy, SWP_NOZORDER);

    CPSUIINT(("\nCHANGED TVIcon=(%ld, %ld) %ld x %ld",
                                                rc.left, rc.top, cx, cy));
    pTVWnd->cxcyTVIcon = (WORD)cx;

    CPSUIDBG(DBG_CTVWND, ("\nIDD_TV_ICON Style=%08lx", dw));

    //
    // now check it out ECB icon
    //

    hCtrl  = CtrlIDrcWnd(hDlg, IDD_TV_ECB_ICON, &rc);
    dw     = (DWORD)GetWindowLongPtr(hCtrl = GetDlgItem(hDlg, IDD_TV_ECB_ICON), GWL_STYLE);
    dw    &= ~SS_TYPEMASK;
    dw    |= (SS_ICON | SS_CENTERIMAGE);
    SetWindowLongPtr(hCtrl, GWL_STYLE, dw);

    //
    // We want to make sure that the cx/cy ECBICON is the same size, if not
    // then we will correct it and adjust it to the right size
    //

    if ((cx = rc.right - rc.left) != (cy = rc.bottom - rc.top)) {

        CPSUIINT(("\nORIGINAL ECBIcon=(%ld, %ld) %ld x %ld",
                                                rc.left, rc.top, cx, cy));

        rc.right = rc.left + (cx = cy);

        SetWindowPos(hCtrl, NULL, rc.left, rc.top, cx, cy, SWP_NOZORDER);

        CPSUIINT(("\nCHANGED ECBIcon=(%ld, %ld) %ld x %ld",
                                                rc.left, rc.top, cx, cy));
    }

    pTVWnd->cxcyECBIcon = (WORD)cx;

    CPSUIDBG(DBG_CTVWND,
            ("\nTVIcon=%ld x %ld, ECBIcon=%ld x %ld",
            (DWORD)pTVWnd->cxcyTVIcon, (DWORD)pTVWnd->cxcyTVIcon,
            (DWORD)pTVWnd->cxcyECBIcon, (DWORD)pTVWnd->cxcyECBIcon));
}



HTREEITEM
SelectFirstVisibleOptItem(
    PTVWND      pTVWnd,
    HTREEITEM   hItem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    21-Sep-1995 Thu 14:31:01 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hWndTV = pTVWnd->hWndTV;

    //
    // Do all the siblings and for each calling the child to do their work
    //

    while (hItem) {

        POPTITEM    pItem;
        TV_ITEM     tvi;


        tvi.mask  = TVIF_CHILDREN | TVIF_HANDLE | TVIF_PARAM | TVIF_STATE;
        tvi.hItem = hItem;

        TreeView_GetItem(hWndTV, &tvi);

        //
        // Now check if we can do it
        //

        if ((pItem = GetOptions(pTVWnd, tvi.lParam))    &&
            (pItem->pOptType)                           &&
            (!IS_HDR_PUSH(pItem->pOptType))             &&
            (pItem->pOptType->Type <= TVOT_LAST)) {

            TreeView_SelectItem(hWndTV, hItem);
            return(hItem);
        }

        if ((tvi.cChildren)                             &&
            (tvi.state & TVIS_EXPANDED)                 &&
            (hItem = TreeView_GetChild(hWndTV, hItem))  &&
            (hItem = SelectFirstVisibleOptItem(pTVWnd, hItem))) {

            return(hItem);
        }

        hItem = TreeView_GetNextSibling(hWndTV, hItem);
    }

    return(hItem);
}



UINT
CountRevertOptItem(
    PTVWND      pTVWnd,
    POPTITEM    pOptItem,
    HTREEITEM   hItem,
    DWORD       Flags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    21-Sep-1995 Thu 14:31:01 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hWndTV = pTVWnd->hWndTV;
    POPTITEM    pLastItem;
    UINT        cRevert = 0;
    NM_TREEVIEW NMtv;

    //
    // Do all the siblings and for each calling the child to do their work
    //

    if ((hWndTV) && (hItem)) {

        pOptItem  =
        pLastItem = NULL;

    } else {

        Flags |= CROIF_DO_SIBLING;
        hItem  = (HTREEITEM)1;

        if (!pOptItem) {

            pOptItem  = pTVWnd->ComPropSheetUI.pOptItem;
            pLastItem = pTVWnd->pLastItem;

        } else {

            pLastItem = pOptItem;
        }
    }

    while (hItem) {

        POPTITEM        pItem;
        PDEVHTADJDATA   pDevHTAdjData;
        POPTTYPE        pOptType;
        POPTPARAM       pOptParam;
        TV_ITEM         tvi;
        UINT            cAdd = 0;


        if (pOptItem) {

            pItem = pOptItem;

        } else {

            tvi.mask  = TVIF_CHILDREN | TVIF_HANDLE | TVIF_PARAM | TVIF_STATE;
            tvi.hItem = hItem;

            TreeView_GetItem(hWndTV, &tvi);
            pItem = GetOptions(pTVWnd, tvi.lParam);
        }

        //
        // Now check if we can do it
        //

        if ((pItem)                                 &&
            ((pItem->Flags & OPTIF_CHANGEONCE)  ||
             (Flags & CROIF_REVERT_DEF2))           &&
            (pOptType = pItem->pOptType)) {

            LPBYTE  pDefSelMem;
            LPVOID  pDefSel;
            LPVOID  pvAlloc;
            DWORD   DefOPTIF;


            pvAlloc =
            pDefSel = (LPVOID)(pDefSelMem = (LPBYTE)_OI_PDEFSEL(pItem));

            if (Flags & CROIF_REVERT_DEF2) {

                DefOPTIF    = (DWORD)_OI_DEF_OPTIF2(pItem);
                pDefSelMem += _OI_CBPDEFSEL(pItem);
                pDefSel     = _OI_PDEFSEL2(pItem);

            } else {

                DefOPTIF = (DWORD)_OI_DEF_OPTIF(pItem);
            }

            switch (pOptType->Type) {

            case TVOT_EDITBOX:

                if (!pvAlloc) {

                    CPSUIASSERT(0, "CountRevertOptItem(EDITBOX:pvAlloc=NULL)", pvAlloc, 0);
                    break;
                }

                if (pTVWnd->Flags & TWF_ANSI_CALL) {

                    CPSUIINT(("pEdit=%hs, pDefEdit=%hs",
                                    pItem->pSel, pDefSel));

                    if (lstrcmpA((LPSTR)(LONG_PTR)pItem->Sel, (LPSTR)pDefSelMem)) {

                        cAdd = 1;

                        if (Flags & CROIF_REVERT) {

                            lstrcpyA((LPSTR)pItem->pSel, (LPSTR)pDefSelMem);
                        }
                    }

                } else {

                    CPSUIINT(("pEdit=%s, pDefEdit=%s",
                                pItem->pSel, pDefSel));

                    if (lstrcmp(pItem->pSel, (LPWSTR)pDefSelMem)) {

                        cAdd = 1;

                        if (Flags & CROIF_REVERT) {

                            lstrcpy((LPWSTR)pItem->pSel, (LPWSTR)pDefSelMem);
                        }
                    }
                }

                break;

            case TVOT_PUSHBUTTON:

                pOptParam = pOptType->pOptParam;

                switch (pOptParam->Style) {

                case PUSHBUTTON_TYPE_HTSETUP:

                    if (!pvAlloc) {

                        CPSUIASSERT(0, "CountRevertOptItem(HTSETUP:pvAlloc=NULL)", pvAlloc, 0);
                        break;
                    }

                    pDevHTAdjData = (PDEVHTADJDATA)(pOptParam->pData);

                    if (memcmp(pDefSelMem,
                               pDevHTAdjData->pAdjHTInfo,
                               sizeof(DEVHTINFO))) {

                        cAdd = 1;

                        if (Flags & CROIF_REVERT) {

                            CopyMemory(pDevHTAdjData->pAdjHTInfo,
                                       pDefSelMem,
                                       sizeof(DEVHTINFO));
                        }
                    }

                    break;

                case PUSHBUTTON_TYPE_HTCLRADJ:

                    if (!pvAlloc) {

                        CPSUIASSERT(0, "CountRevertOptItem(HTCLRADJ:pvAlloc=NULL)", pvAlloc, 0);
                        break;
                    }

                    if (memcmp(pDefSelMem,
                               pOptParam->pData,
                               sizeof(COLORADJUSTMENT))) {

                        cAdd = 1;

                        if (Flags & CROIF_REVERT) {

                            CopyMemory(pOptParam->pData,
                                       pDefSelMem,
                                       sizeof(COLORADJUSTMENT));
                        }
                    }

                    break;

                default:

                    break;
                }

                break;

            default:

                if (pItem->pSel != (LPVOID)pDefSel) {

                    cAdd = 1;

                    if (Flags & CROIF_REVERT) {

                        pItem->pSel = pDefSel;
                    }

                }

                break;
            }

            if ((pItem->pExtChkBox)                         &&
                (!(pItem->Flags & OPTIF_EXT_IS_EXTPUSH))    &&
                ((pItem->Flags & OPTIF_ECB_MASK) !=
                                            (DefOPTIF & OPTIF_ECB_MASK))) {

                cAdd = 1;

                if (Flags & CROIF_REVERT) {

                    pItem->Flags &= ~OPTIF_ECB_MASK;
                    pItem->Flags |= (DWORD)(DefOPTIF & OPTIF_ECB_MASK);
                }
            }

            if (cAdd) {

                if (Flags & CROIF_REVERT) {

                    pItem->Flags |= OPTIF_CHANGED;

                    //
                    // Call the callback function if there is one, and update the current
                    // selected item after changing the content
                    //

                    DoCallBack(pTVWnd->hDlgTV,
                               pTVWnd,
                               pItem,
                               pItem->pSel,
                               NULL,
                               NULL,
                               0,
                               CPSUICB_REASON_SEL_CHANGED);

                    //
                    // Refresh the current selected item data, otherwise the data may 
                    // not be consistent
                    //
                    NMtv.itemNew.hItem = TreeView_GetSelection(pTVWnd->hWndTV);
                    NMtv.itemNew.mask  = TVIF_HANDLE | TVIF_PARAM;

                    if (TreeView_GetItem(pTVWnd->hWndTV, &(NMtv.itemNew))) {

                        NMtv.itemOld = NMtv.itemNew;

                        SetupTVSelect(pTVWnd->hDlgTV, &NMtv, STVS_REINIT);
                    }
                }

                CPSUIOPTITEM(DBGITEM_CREVERT,
                             pTVWnd,
                             "CountRevertOptItem",
                             0,
                             pItem);
            }

            cRevert += cAdd;
        }

        if (pOptItem) {

            if (++pOptItem > pLastItem) {

                hItem = NULL;

            } else {

                ++(ULONG_PTR)hItem;
            }

        } else {

            if (tvi.cChildren) {

                cRevert += CountRevertOptItem(pTVWnd,
                                              NULL,
                                              TreeView_GetChild(hWndTV, hItem),
                                              Flags | CROIF_DO_SIBLING);
            }

            hItem = (Flags & CROIF_DO_SIBLING) ?
                                TreeView_GetNextSibling(hWndTV, hItem) : NULL;
        }
    }

    CPSUIDBG(DBG_CTVWND, ("hWndTV=%08lx, hItem=%08lx, pOptItem=%08lx, cRevert=%u",
                hWndTV, hItem, pOptItem, cRevert));

    return(cRevert);
}






CPSUICALLBACK
InternalRevertDef2(
    PCPSUICBPARAM   pCBParam
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    21-Sep-1995 Thu 10:50:19 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PTVWND      pTVWnd;
    POPTITEM    pItem;
    UINT        cRevert;


    CPSUIINT(("INTERNAL CALLBACK: GOT Internal RevertOptItem() PUSH"));

    pTVWnd = GET_PTVWND(pCBParam->hDlg);
    pItem  = pCBParam->pCurItem;

    CPSUIOPTITEM(DBGITEM_REVERT,
                 pTVWnd,
                 "InternalRevertOptItem",
                 2,
                 pItem);

    cRevert = CountRevertOptItem(pTVWnd,
                                 NULL,
                                 NULL,
                                 CROIF_REVERT | CROIF_REVERT_DEF2);

    //
    // Now is the time to hide the push button
    //

    return((cRevert) ? CPSUICB_ACTION_OPTIF_CHANGED : CPSUICB_ACTION_NONE);
}




CPSUICALLBACK
InternalRevertOptItem(
    PCPSUICBPARAM   pCBParam
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    21-Sep-1995 Thu 10:50:19 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PTVWND      pTVWnd;
    POPTITEM    pItem;
    UINT        cRevert;


    CPSUIINT(("INTERNAL CALLBACK: GOT Internal RevertOptItem() PUSH"));

    pTVWnd = GET_PTVWND(pCBParam->hDlg);
    pItem  = pCBParam->pCurItem;

    CPSUIOPTITEM(DBGITEM_REVERT,
                 pTVWnd,
                 "InternalRevertOptItem",
                 2,
                 pItem);

    cRevert = CountRevertOptItem(pTVWnd,
                                 pItem,
                                 _OI_HITEM(pItem),
                                 CROIF_REVERT);

    //
    // Now is the time to hide the push button
    //

#if DO_IN_PLACE
    return((cRevert) ? CPSUICB_ACTION_OPTIF_CHANGED : CPSUICB_ACTION_NONE);
#else
    if (cRevert) {

        if ((pItem >= pTVWnd->ComPropSheetUI.pOptItem)   &&
            (pItem <= pTVWnd->pLastItem)) {

            pItem->Flags |= OPTIF_CHANGED;

        } else {

            UpdateTreeViewItem(pCBParam->hDlg, pTVWnd, pItem, TRUE);
        }

        return(CPSUICB_ACTION_OPTIF_CHANGED);

    } else {

        return(CPSUICB_ACTION_NONE);
    }
#endif
}




BOOL
SetTVItemImage(
    PTVWND      pTVWnd,
    TV_DISPINFO *ptvdi
    )

/*++

Routine Description:

    This function either insert a item to the tree or reset the content of
    the tree item


Arguments:

    pTVWnd      - Pointer to the TVWND for common UI instance data

    ptvi        - pointer to TV_ITEM strucuture.



Return Value:

    BOOLEAN


Author:

    06-Jul-1995 Thu 19:38:51 created  -by-  Daniel Chou (danielc)

    31-Aug-1995 Thu 12:03:32 updated  -by-  Daniel Chou (danielc)
        Updated so it will not take pStrName anymore and it will also insert
        the item at this function


Revision History:


--*/

{
    TV_ITEM *ptvi = &(ptvdi->item);


    if (ptvi->mask & (TVIF_IMAGE | TVIF_SELECTEDIMAGE)) {

        POPTTYPE    pOptType;
        POPTITEM    pItem;
        ULONG_PTR    IconResID;
        DWORD       IntIconID;


        pItem = GetOptions(pTVWnd, ptvi->lParam);

        if (IS_HDR_PUSH(pOptType = GET_POPTTYPE(pItem))) {

            IconResID = GETSELICONID(pItem);
            IntIconID = IDI_CPSUI_GENERIC_OPTION;

        } else {

            PEXTCHKBOX  pECB;
            POPTPARAM   pOptParam = pOptType->pOptParam;

            switch (pOptType->Type) {

            case TVOT_COMBOBOX:
            case TVOT_LISTBOX:

                if ((DWORD)pItem->Sel >= (DWORD)pOptType->Count) {

                    pOptParam = &pTVWnd->OptParamNone;
                    break;
                }

            case TVOT_2STATES:
            case TVOT_3STATES:

                pOptParam += (DWORD)pItem->Sel;
                break;

            case TVOT_CHKBOX:
            case TVOT_TRACKBAR:
            case TVOT_SCROLLBAR:
            case TVOT_UDARROW:
            case TVOT_PUSHBUTTON:
            case TVOT_EDITBOX:

                break;
            }


            IconResID = GET_ICONID(pOptParam, OPTPF_ICONID_AS_HICON);
            IntIconID = IDI_CPSUI_GENERIC_ITEM;
        }

        ptvi->iSelectedImage =
        ptvi->iImage         = (INT)GetIcon16Idx(pTVWnd,
                                                 _OI_HINST(pItem),
                                                 IconResID,
                                                 IntIconID);
        ptvi->hItem          = _OI_HITEM(pItem);
        ptvi->mask           = (TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_HANDLE);

        SendMessage(pTVWnd->hWndTV, TVM_SETITEM, 0, (LPARAM)ptvi);

        CPSUIOPTITEM(DBGITEM_NEWICON, pTVWnd, "SetTVItemImage", 0, pItem);
    }

    return(TRUE);
}




VOID
SetTVItemState(
    PTVWND          pTVWnd,
    TV_INSERTSTRUCT *ptvins,
    POPTITEM        pCurItem
    )

/*++

Routine Description:

    This function either insert a item to the tree or reset the content of
    the tree item


Arguments:

    pTVWnd      - Pointer to the TVWND for common UI instance data

    ptvins      - pointer to TV_INSERTSTRUCT strucuture, if it is not NULL then
                  this item will be inserted to the tree

    pCurItem    - Pointer to the current OPTITEM



Return Value:

    WORD    - Icon resource ID


Author:

    06-Jul-1995 Thu 19:38:51 created  -by-  Daniel Chou (danielc)

    31-Aug-1995 Thu 12:03:32 updated  -by-  Daniel Chou (danielc)
        Updated so it will not take pStrName anymore and it will also insert
        the item at this function

    20-Jul-1996 Sat 00:26:33 updated  -by-  Daniel Chou (danielc)
        Fixed the internationalize problem for compsition dynamic user data


Revision History:


--*/

{
    POPTTYPE        pOptType;
    TV_INSERTSTRUCT tvins;
    TVLP            tvlp;
    ULONG_PTR       IconResID;
    DWORD           IntIconID;
    DWORD           Flags;
    GSBUF_DEF(pCurItem, MAX_RES_STR_CHARS * 2);


    if (ptvins) {

        tvins            = *ptvins;
        tvins.item.mask |= TVIF_TEXT            |
                            TVIF_PARAM          |
                            TVIF_IMAGE          |
                            TVIF_SELECTEDIMAGE  |
                            TVIF_STATE;

    } else {

        CPSUIASSERT(0, "SetTVItemState, NULL hItem", _OI_HITEM(pCurItem),0);

        if (!(tvins.item.hItem = _OI_HITEM(pCurItem))) {

            CPSUIOPTITEM(DBG_ASSERT,
                         pTVWnd,
                         "SetTVItemState(NULL)", 1,
                         pCurItem);

            return;
        }

        tvins.item.state     =
        tvins.item.stateMask = 0;
        tvins.item.mask      = TVIF_HANDLE          |
                                TVIF_PARAM          |
                                TVIF_TEXT           |
                                TVIF_IMAGE          |
                                TVIF_SELECTEDIMAGE  |
                                TVIF_STATE;
    }

    if ((pCurItem >= pTVWnd->ComPropSheetUI.pOptItem)   &&
        (pCurItem <= pTVWnd->pLastItem)) {

        tvlp.ItemIdx = (WORD)(pCurItem - pTVWnd->ComPropSheetUI.pOptItem);

    } else if ((pCurItem >= PBEG_INTOPTITEM(pTVWnd))   &&
             (pCurItem <= PEND_INTOPTITEM(pTVWnd))) {

        tvlp.ItemIdx = (WORD)IIDX_INTOPTITEM(pTVWnd, pCurItem);

    } else {

        CPSUIERR(("ERROR: SetupTVItemState(Invalid pOptItem=%08lx)", pCurItem));

        tvlp.ItemIdx = INTIDX_TVROOT;
    }

    tvins.item.pszText = GSBUF_BUF;

    //
    // Check if we need to overlay CPSUI provided icons
    //

    tvlp.Flags = ((Flags = pCurItem->Flags) & OPTIF_OVERLAY_WARNING_ICON) ?
                                                            TVLPF_WARNING : 0;

    if (Flags & (OPTIF_OVERLAY_STOP_ICON | OPTIF_HIDE)) {

        tvlp.Flags |= TVLPF_STOP;
    }

    if (Flags & OPTIF_OVERLAY_NO_ICON) {

        tvlp.Flags |= TVLPF_NO;
    }

    if (IS_HDR_PUSH(pOptType = GET_POPTTYPE(pCurItem))) {

        POPTITEM    pRootItem = PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT);


        if (pCurItem == pRootItem) {

            GSBUF_FLAGS |= GBF_PREFIX_OK;
            GSBUF_COMPOSE(LODWORD(pCurItem->UserData), pCurItem->pName, 0, 0);

        } else if (pCurItem == PIDX_INTOPTITEM(pTVWnd, INTIDX_OPTIONS)) {

            //
            // Make it 'Document Options' here
            //

            GSBUF_GETINTSTR(IDS_INT_CPSUI_OPTIONS);

        } else {

            GSBUF_GETSTR(pCurItem->pName);
        }

        tvlp.cName = (BYTE)(GSBUF_COUNT);

        CPSUIINT(("HeaderItem (%ld): '%ws'", tvlp.cName, GSBUF_BUF));

        IconResID = GETSELICONID(pCurItem);
        IntIconID = IDI_CPSUI_GENERIC_OPTION;

#if DO_IN_PLACE
        if ((!IconResID)    ||
            (!GetIcon16Idx(pTVWnd,
                           _OI_HINST(pCurItem),
                           IconResID,
                           IDI_CPSUI_EMPTY))) {

            tvins.item.mask &= ~(TVIF_IMAGE | TVIF_SELECTEDIMAGE);
            tvlp.Flags      |= TVLPF_EMPTYICON;
        }
#endif

    } else {

        POPTPARAM   pOptParam;
        PEXTCHKBOX  pECB;
        LPTSTR      pEndText = NULL;
        UINT        Idx;
        BOOL        RealECBChecked;
        BOOL        EndTextAddSpace;

#if DO_IN_PLACE
        tvins.item.mask &= ~(TVIF_IMAGE | TVIF_SELECTEDIMAGE);
        tvlp.Flags      |= TVLPF_EMPTYICON;
#endif

        GSBUF_GETSTR(pCurItem->pName);

        pOptParam = pOptType->pOptParam;

        if (RealECBChecked = REAL_ECB_CHECKED(pCurItem, pECB)) {

            if (pECB->Flags & ECBF_OVERLAY_ECBICON_IF_CHECKED) {

                tvlp.Flags |= TVLPF_ECBICON;

                if (pECB->Flags & ECBF_OVERLAY_WARNING_ICON) {

                    tvlp.Flags |= TVLPF_WARNING;
                }

                if (pECB->Flags & ECBF_OVERLAY_STOP_ICON) {

                    tvlp.Flags |= TVLPF_STOP;
                }

                if (pECB->Flags & ECBF_OVERLAY_NO_ICON) {

                    tvlp.Flags |= TVLPF_NO;
                }
            }
        }

        if ((RealECBChecked) &&
            ((!(Flags & OPTIF_EXT_DISABLED)) ||
             (!(pECB->Flags & ECBF_CHECKNAME_ONLY_ENABLED)))) {

            NULL;

        } else {

            pECB = NULL;
        }

        //
        // PUSHBUTTON: PusName... <pCheckedName>
        //

        if (pOptType->Type == TVOT_PUSHBUTTON) {

            if (!(pOptType->Style & OTS_PUSH_NO_DOT_DOT_DOT)) {

                GSBUF_GETSTR(IDS_CPSUI_MORE);
            }

        } else {

            GSBUF_GETSTR(IDS_CPSUI_COLON_SEP);
        }

        tvlp.cName = (BYTE)(GSBUF_COUNT);

        CPSUIINT(("TreeviewItem (%ld): '%ws'", tvlp.cName, GSBUF_BUF));

        if ((pECB) && (pECB->Flags & ECBF_CHECKNAME_ONLY)){

            GSBUF_GETSTR(pECB->pCheckedName);
            pECB = NULL;

        } else {

            if ((pECB) && (pECB->Flags & ECBF_CHECKNAME_AT_FRONT)) {

                //
                // pName: <pCheckedName SEP pSelection>
                //

                GSBUF_GETSTR(pECB->pCheckedName);
                GSBUF_GETSTR(pECB->pSeparator);
                pECB  = NULL;
            }

            EndTextAddSpace = (!(pOptType->Flags & OPTTF_NOSPACE_BEFORE_POSTFIX));

            switch (pOptType->Type) {

            case TVOT_CHKBOX:

                Idx = (UINT)(pCurItem->Sel + (pOptParam->Style << 1));

                if (!(pEndText = (LPTSTR)ChkBoxStrID[Idx])) {

                    pEndText = pOptParam->pData;
                }

                GSBUF_GETSTR(pEndText);
                pEndText = NULL;

                break;

            case TVOT_COMBOBOX:
            case TVOT_LISTBOX:

                if ((DWORD)pCurItem->Sel >= (DWORD)pOptType->Count) {

                    pOptParam = &pTVWnd->OptParamNone;

                } else {

                    pOptParam += (DWORD)pCurItem->Sel;
                }

                GSBUF_GETSTR(pOptParam->pData);

                break;

            case TVOT_2STATES:
            case TVOT_3STATES:

                pOptParam += pCurItem->Sel;
                GSBUF_GETSTR(pOptParam->pData);
                break;

            case TVOT_TRACKBAR:
            case TVOT_SCROLLBAR:

                GSBUF_ADDNUM(pCurItem->Sel * (LONG)pOptParam[2].IconID, TRUE);

                pEndText = pOptParam->pData;
                break;

            case TVOT_UDARROW:

                GSBUF_ADDNUM(pCurItem->Sel, TRUE);
                pEndText = pOptParam->pData;
                break;

            case TVOT_PUSHBUTTON:

                Flags &= ~OPTIF_CHANGEONCE;
                break;

            case TVOT_EDITBOX:

                GSBUF_GETSTR(pCurItem->pSel);
                pEndText = pOptParam->pData;
                break;
            }

            if (pEndText) {

                LPWSTR  pwBuf;

                if (EndTextAddSpace) {

                    GSBUF_ADD_SPACE(1);
                }

                pwBuf = GSBUF_PBUF;

                GSBUF_GETSTR(pEndText);

                if ((GSBUF_PBUF == pwBuf)   &&
                    (EndTextAddSpace)) {

                    GSBUF_SUB_SIZE(1);
                }
            }

        }

        if (pECB) {

            GSBUF_GETSTR(pECB->pSeparator);
            GSBUF_GETSTR(pECB->pCheckedName);
        }

        IconResID = GET_ICONID(pOptParam, OPTPF_ICONID_AS_HICON);
        IntIconID = IDI_CPSUI_GENERIC_ITEM;

        if (pOptParam->Flags & OPTPF_OVERLAY_WARNING_ICON) {

            tvlp.Flags |= TVLPF_WARNING;
        }

        if (pOptParam->Flags & OPTPF_OVERLAY_STOP_ICON) {

            tvlp.Flags |= TVLPF_STOP;
        }

        if (pOptParam->Flags & OPTPF_OVERLAY_NO_ICON) {

            tvlp.Flags |= TVLPF_NO;
        }
    }

    if (ptvins) {

        tvins.item.iImage         =
        tvins.item.iSelectedImage = -1;

    } else {

        tvins.item.iSelectedImage =
        tvins.item.iImage         = (INT)GetIcon16Idx(pTVWnd,
                                                      _OI_HINST(pCurItem),
                                                      IconResID,
                                                      IntIconID);
    }

    tvins.item.cchTextMax  = GSBUF_COUNT;

#if DO_IN_PLACE
    if (tvins.item.mask & (TVIF_IMAGE | TVIF_SELECTEDIMAGE)) {

        tvins.item.state  |= TVIS_OVERLAYMASK | TVIS_STATEIMAGEMASK;

    } else {

        tvins.item.state  &= ~(TVIS_OVERLAYMASK | TVIS_STATEIMAGEMASK);
    }
#endif

    tvins.item.stateMask |= TVIS_OVERLAYMASK | TVIS_STATEIMAGEMASK;

    //
    // Change the overlay mask
    //

    if ((!(pTVWnd->Flags & TWF_CAN_UPDATE))  ||
        (pCurItem->Flags & OPTIF_DISABLED)) {

        tvlp.Flags |= TVLPF_DISABLED;
    }

    if (Flags & OPTIF_CHANGEONCE) {

        tvlp.Flags |= TVLPF_CHANGEONCE;
    }

    tvins.item.lParam = TVLP2LP(tvlp);

    if (ptvins) {

        _OI_HITEM(pCurItem) = TreeView_InsertItem(pTVWnd->hWndTV, &tvins);

        CPSUIOPTITEM(DBGITEM_INS, pTVWnd, "SetTVItemState(INSERT)", 1, pCurItem);


    } else {

        if (_OI_INTFLAGS(pCurItem) & OIDF_ZERO_SEL_LEN) {

            UINT    cSpace;

            //
            // Do not update string while is selected
            //

            if (pTVWnd->cxItem > pTVWnd->cxMaxItem) {

                cSpace = (UINT)(((DWORD)pTVWnd->cxEdit +
                                 (DWORD)pTVWnd->cxSpace - 1) /
                                (DWORD)pTVWnd->cxSpace) + 1;

                GSBUF_PBUF = GSBUF_BUF + tvlp.cName;
                GSBUF_ADD_SPACE(cSpace);

                CPSUIINT(("!! ZERO_SEL_LEN Item: %ld GREATER Than %ld, cName=%ld, cSpace=%ld",
                        pTVWnd->cxItem, pTVWnd->cxMaxItem, tvlp.cName, cSpace));

                pTVWnd->cxMaxItem = pTVWnd->cxItem;

                TreeView_SetItem(pTVWnd->hWndTV, &(tvins.item));

            } else {

                CPSUIINT(("!! ZERO_SEL_LEN Item: %ld Less than %ld, cName=%ld",
                        pTVWnd->cxItem, pTVWnd->cxMaxItem, tvlp.cName));
            }

            GSBUF_BUF[tvlp.cName] = L'\0';

            CPSUIINT(("!! ZERO_SEL_LEN Item pszText='%ws'",
                        tvins.item.pszText));
        }

        TreeView_SetItem(pTVWnd->hWndTV, &(tvins.item));

        CPSUIOPTITEM(DBGITEM_SET, pTVWnd, "SetTVItemState(SET)", 1, pCurItem);
    }
}




POPTITEM
SetupTVSelect(
    HWND        hDlg,
    NM_TREEVIEW *pNMTV,
    DWORD       STVSMode
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    21-Jun-1995 Wed 15:14:54 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hParent;
    HWND        hCtrl;
    HWND        hWndTV;
    PTVWND      pTVWnd = GET_PTVWND(hDlg);
    POPTTYPE    pOldOptType;
    POPTITEM    pOldItem;
    POPTTYPE    pOptType;
    POPTITEM    pNewItem;
    POPTPARAM   pOptParam;
    TVLP        tvlp;
    WORD        InitFlags;
    WORD        InitItemIdx;
    WORD        IconMode = 0;
    BYTE        NewType;
    BOOL        CanUpdate;


    hWndTV      = pTVWnd->hWndTV;
    pNewItem    = GetOptions(pTVWnd, pNMTV->itemNew.lParam);
    tvlp        = GET_TVLP(pNMTV->itemNew.lParam);
    InitItemIdx = tvlp.ItemIdx;

    if (!pTVWnd->pCurTVItem) {

        pOldItem    = NULL;
        pOldOptType = NULL;

    } else {

        pOldItem    = GetOptions(pTVWnd, pNMTV->itemOld.lParam);
        pOldOptType = GET_POPTTYPE(pOldItem);
    }

    CPSUIOPTITEM(DBGITEM_SETUP, pTVWnd, "Setup OLD", 0, pOldItem);
    CPSUIOPTITEM(DBGITEM_SETUP, pTVWnd, "Setup New", 0, pNewItem);

    pOptType = GET_POPTTYPE(pNewItem);

#if DO_IN_PLACE
    hParent = hWndTV;

    switch (NewType = pOptType->Type) {

    case TVOT_2STATES:
    case TVOT_3STATES:
    case TVOT_LISTBOX:

        NewType = TVOT_COMBOBOX;
        break;

    case TVOT_SCROLLBAR:
    case TVOT_TRACKBAR:
#if 1
        NewType = TVOT_UDARROW;
#else
        if (pOptType->pOptParam[2].IconID <= 1) {

            NewType = TVOT_UDARROW;
        }
#endif
        break;

    default:

        break;
    }
#else
    hParent = hDlg;
    NewType = pOptType->Type;
#endif

    //
    // If we have push button, and it said we always can call it then update
    // is true
    //

    if ((STVSMode & STVS_ACTIVE)                        &&
        (pOldItem != pNewItem)                          &&
        (pNewItem->Flags & OPTIF_CALLBACK)              &&
        (InitItemIdx < pTVWnd->ComPropSheetUI.cOptItem)) {

        //
        // Callback back ONLY for the user item which has CALLBACK
        //

        DoCallBack(hDlg,
                   pTVWnd,
                   pNewItem,
                   pNewItem->pSel,
                   NULL,
                   NULL,
                   0,
                   CPSUICB_REASON_OPTITEM_SETFOCUS);
    }

    if ((pNewItem == PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT)) ||
        ((NewType == TVOT_PUSHBUTTON) &&
         (pOptType->Flags & OTS_PUSH_ENABLE_ALWAYS))) {

        CanUpdate = TRUE;

    } else {

        CanUpdate = (BOOL)(pTVWnd->Flags & TWF_CAN_UPDATE);
    }

    pTVWnd->Flags &= ~TWF_TVITEM_NOTYPE;

    if (IS_HDR_PUSH(pOptType)) {
#if DO_IN_PLACE
        pOptType = NULL;
        NewType  = TVOT_NONE;
#else
        HTREEITEM   hItem;
        UINT        cRevert;


        if ((!CanUpdate)                                    ||
            (!(cRevert = CountRevertOptItem(pTVWnd,
                                            pNewItem,
                                            _OI_HITEM(pNewItem),
                                            0)))) {

            CPSUIINT(("CountRevertOptItem=0, NOT REVERT"));

            //
            // We always enable the ROOT
            //

            if ((InitItemIdx == INTIDX_TVROOT) ||
                ((pNewItem->pExtChkBox) &&
                 (!(pNewItem->Flags & OPTIF_EXT_HIDE)))) {

                pTVWnd->Flags   |= TWF_ONE_REVERT_ITEM;
                pOptType->Flags |= OPTTF_TYPE_DISABLED;

            } else {

                pTVWnd->Flags |= TWF_TVITEM_NOTYPE;
                pOptType       = NULL;
                NewType        = TVOT_NONE;
            }

        } else {

            pOptType->Flags &= ~OPTTF_TYPE_DISABLED;

            if (cRevert == 1) {

                pTVWnd->Flags |= TWF_ONE_REVERT_ITEM;

            } else {

                pTVWnd->Flags &= ~TWF_ONE_REVERT_ITEM;
            }

            CPSUIINT(("CountRevertOptItem=%d, Let's do the PUSH", cRevert));
        }
#endif
    }

    if ((pNewItem->Flags & OPTIF_DISABLED) || (!CanUpdate)) {

        InitFlags = INITCF_TVDLG;

    } else {

        InitFlags = INITCF_ENABLE | INITCF_TVDLG;
    }

    if ((STVSMode & STVS_REINIT) || (pOldItem != pNewItem)) {

        InitFlags |= (INITCF_INIT | INITCF_SETCTRLDATA);

        ChangeOptTypeDisplay(hParent,
                             pTVWnd,
                             pOldOptType,
                             pOptType,
                             InitFlags & INITCF_ENABLE);
    }

    //
    // The extended check box will also looked at TWF_CAN_UPDATE flags to
    // disable the ECB if the flag is clear
    //

    if (pOptType) {

        if (INIT_EXTENDED(pTVWnd,
                          hParent,
                          pNewItem,
                          IDD_TV_EXTCHKBOX,
                          IDD_TV_EXTPUSH,
                          IDD_TV_ECB_ICON,
                          InitItemIdx,
                          InitFlags)) {

            InitFlags |= INITCF_HAS_EXT;
        }

    } else if (InitFlags & INITCF_INIT) {

        if (hCtrl = GetDlgItem(hParent, IDD_TV_EXTPUSH)) {

            CPSUIINT(("!! DISABLE/HIDE HEADER EXTPUSH !!!"));

            EnableWindow(hCtrl, FALSE);
            ShowWindow(hCtrl, SW_HIDE);
        }

        if (hCtrl = GetDlgItem(hParent, IDD_TV_EXTCHKBOX)) {

            CPSUIINT(("!! DISABLE/HIDE HEADER EXTCHKBOX !!"));

            EnableWindow(hCtrl, FALSE);
            ShowWindow(hCtrl, SW_HIDE);
        }
    }

    if (pOptType) {

        LONG        Select;
        UINT        IDSetCurSel = CB_SETCURSEL;
        UINT        idLBCB = IDD_TV_CB;
        UINT        cyLBMax = 0;
        ULONG_PTR    IconResID;
        WORD        BegCtrlID;
        WORD        IntIconID = IDI_CPSUI_GENERIC_ITEM;


        if (pNewItem->Flags & OPTIF_OVERLAY_WARNING_ICON) {

            IconMode |= MIM_WARNING_OVERLAY;
        }

        if (pNewItem->Flags & (OPTIF_OVERLAY_STOP_ICON | OPTIF_HIDE)) {

            IconMode |= MIM_STOP_OVERLAY;
        }

        if (pNewItem->Flags & OPTIF_OVERLAY_NO_ICON) {

            IconMode |= MIM_NO_OVERLAY;
        }

        if (pOptType->Flags & OPTTF_TYPE_DISABLED) {

            InitFlags &= ~INITCF_ENABLE;
        }

        //
        // We have something to do here, if we have same option type
        // with the old one then we need not to re-create them
        // and if we have same select then we do not need to re-draw
        //
        // Now set the option text to reflect the changes
        //

        pOptParam = pOptType->pOptParam;

        //
        // Compose '&Change xxxx Option' or
        //         'xxxxx Option"
        //
#if (DO_IN_PLACE == 0)
        if (InitFlags & INITCF_INIT) {

            SetOptHeader(hDlg, pTVWnd, pNewItem, IS_HDR_PUSH(pOptType));
        }
#endif
        Select    = pNewItem->Sel;
        BegCtrlID = pOptType->BegCtrlID;

        CPSUIDBG(DBG_STVS,
                ("TVOT_TYPE=%hs, InitFlags=%04lx, InitItemIdx = %ld, Select=%ld [%08lx]",
                    (LPTSTR)pTVOTName[NewType],
                    (DWORD)InitFlags, (DWORD)InitItemIdx, Select, Select));

        switch(NewType) {

        case TVOT_2STATES:
        case TVOT_3STATES:

#if (DO_IN_PLACE == 0)
            if (InitFlags & INITCF_INIT) {

                MoveStateRadios(hDlg, pTVWnd, pOptType, InitFlags);
            }
#endif
#if DO_IN_PLACE
            cyLBMax = pTVWnd->yLB[(InitFlags & INITCF_HAS_EXT) ? 0 : 1];

            InitLBCB(pTVWnd,
                     hParent,
                     pNewItem,
                     idLBCB,
                     IDSetCurSel,
                     pOptType,
                     InitItemIdx,
                     Select,
                     InitFlags,
                     cyLBMax);
#else
            InitStates(pTVWnd,
                       hParent,
                       pNewItem,
                       pOptType,
                       IDD_3STATES_1,
                       InitItemIdx,
                       Select,
                       InitFlags);
#endif
            pOptParam += Select;
            break;

        case TVOT_UDARROW:

            InitUDArrow(pTVWnd,
                        hParent,
                        pNewItem,
                        pOptParam,
                        IDD_TV_UDARROW,
                        IDD_TV_UDARROW_EDIT,
                        IDD_TV_UDARROW_ENDTEXT,
                        IDD_TV_UDARROW_HELP,
                        InitItemIdx,
                        Select,
                        InitFlags);

            break;

        case TVOT_SCROLLBAR:
        case TVOT_TRACKBAR:

            CPSUIINT(("hParent=%08lx, NewType=%ld, hCtrl=%08lx",
                    hParent, NewType,
                    GetDlgItem(hParent, (NewType == TVOT_TRACKBAR) ?
                                            IDD_TV_TRACKBAR : IDD_TV_SB)));

            InitTBSB(pTVWnd,
                     hParent,
                     pNewItem,
                     GetDlgItem(hParent, (NewType == TVOT_TRACKBAR) ?
                                            IDD_TV_TRACKBAR : IDD_TV_SB),
                     pOptType,
                     0,
                     IDD_TV_SB_LOW,
                     IDD_TV_SB_HIGH,
                     InitItemIdx,
                     Select,
                     InitFlags);

            break;

        case TVOT_LISTBOX:

            //
            // If we only has one item then make it combo box
            //

            cyLBMax     = pTVWnd->yLB[(InitFlags & INITCF_HAS_EXT) ? 0 : 1];
            IDSetCurSel = LB_SETCURSEL;
            idLBCB      = IDD_TV_LB;

            //
            // Fall through
            //

        case TVOT_COMBOBOX:

            InitLBCB(pTVWnd,
                     hParent,
                     pNewItem,
                     idLBCB,
                     IDSetCurSel,
                     pOptType,
                     InitItemIdx,
                     Select,
                     InitFlags,
                     cyLBMax);

            if ((DWORD)Select >= (DWORD)pOptType->Count) {

                CPSUIDBG(DBG_STVS, ("Get NONE type of select=%ld", Select));

                pOptParam = &pTVWnd->OptParamNone;

            } else {

                pOptParam += (DWORD)Select;
            }

            break;

        case TVOT_EDITBOX:

            InitEditBox(pTVWnd,
                        hParent,
                        pNewItem,
                        pOptParam,
                        IDD_TV_EDIT_EDIT,
                        IDD_TV_EDIT_ENDTEXT,
                        IDD_TV_EDIT_HELP,
                        InitItemIdx,
                        pNewItem->pSel,
                        InitFlags);

            break;

        case TVOT_PUSHBUTTON:

            InitPushButton(pTVWnd,
                           hParent,
                           pNewItem,
                           IDD_TV_PUSH,
                           InitItemIdx,
                           InitFlags);
            break;

        case TVOT_CHKBOX:
#if DO_IN_PLACE
#if 0
            InitChkBox(pTVWnd,
                       hParent,
                       pNewItem,
                       IDD_TV_CHKBOX,
                       pNewItem->pName,
                       InitItemIdx,
                       (BOOL)Select,
                       InitFlags);
#else
            {
                OPTTYPE     ChkBoxOT;
                OPTPARAM    ChkBoxOP[2];
                UINT        Idx;


                ChkBoxOT           = *pOptType;
                ChkBoxOT.Type      = TVOT_COMBOBOX;
                ChkBoxOT.Count     = 2;
                ChkBoxOT.pOptParam = ChkBoxOP;
                ChkBoxOP[0]        =
                ChkBoxOP[1]        = *pOptParam;
                ChkBoxOP[0].Style  =
                ChkBoxOP[1].Style  = 0;
                ChkBoxOP[0].IconID =
                ChkBoxOP[1].IconID = 0;

                Idx = (UINT)(pOptParam->Style << 1);

                if (ChkBoxStrID[Idx]) {

                    ChkBoxOP[0].pData = (LPTSTR)ChkBoxStrID[Idx];
                }

                if (ChkBoxStrID[Idx + 1]) {

                    ChkBoxOP[1].pData = (LPTSTR)ChkBoxStrID[Idx + 1];
                }

                cyLBMax = pTVWnd->yLB[(InitFlags & INITCF_HAS_EXT) ? 0 : 1];

                InitLBCB(pTVWnd,
                         hParent,
                         pNewItem,
                         idLBCB,
                         IDSetCurSel,
                         &ChkBoxOT,
                         InitItemIdx,
                         Select,
                         InitFlags,
                         cyLBMax);
            }
#endif
#else
            InitChkBox(pTVWnd,
                       hParent,
                       pNewItem,
                       IDD_TV_CHKBOX,
                       pNewItem->pName,
                       InitItemIdx,
                       (BOOL)Select,
                       InitFlags);
#endif

            break;
        }

        if (IS_HDR_PUSH(pOptType)) {

            IconResID  = GETSELICONID(pNewItem);
            IntIconID  = IDI_CPSUI_GENERIC_OPTION;

        } else {

            IconResID = GET_ICONID(pOptParam, OPTPF_ICONID_AS_HICON);

            if (pOptParam->Flags & OPTPF_OVERLAY_WARNING_ICON) {

                IconMode |= MIM_WARNING_OVERLAY;
            }

            if (pOptParam->Flags & OPTPF_OVERLAY_STOP_ICON) {

                IconMode |= MIM_STOP_OVERLAY;
            }

            if (pOptParam->Flags & OPTPF_OVERLAY_NO_ICON) {

                IconMode |= MIM_NO_OVERLAY;
            }
        }
#if (DO_IN_PLACE == 0)
        SetIcon(_OI_HINST(pNewItem),
                GetDlgItem(hParent, IDD_TV_ICON),
                IconResID,
                MK_INTICONID(IntIconID, IconMode),
                pTVWnd->cxcyTVIcon);
#endif
    }

#if DO_IN_PLACE
#if 0
    EnableWindow(GetDlgItem(hDlg, IDD_PRE_EDIT), (BOOL)pTVWnd->chWndEdit);
    EnableWindow(GetDlgItem(hDlg, IDD_POST_EDIT), (BOOL)pTVWnd->chWndEdit);
#endif
#endif
    return(pNewItem);
}




LONG
UpdateTreeViewItem(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem,
    BOOL        ReInit
    )

/*++

Routine Description:

    This function update a single item in the treeview, and reset the bottom
    option change controls if this item also the current selected one

Arguments:

    hDlg    - Handle to the dialog box

    pTVWnd  - Handle to common UI instance data

    pItem   - Pointer to OPTITEM to be updated



Return Value:

    LONG


Author:

    01-Sep-1995 Fri 01:05:56 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    if ((pItem) && (!(pItem->Flags & OPTIF_INT_HIDE))) {

        SetTVItemState(pTVWnd, NULL, pItem);

        if (pItem == pTVWnd->pCurTVItem) {

            NM_TREEVIEW NMtv;

            NMtv.itemNew.hItem = _OI_HITEM(pItem);
            NMtv.itemNew.mask  = TVIF_HANDLE | TVIF_PARAM;

            if (IS_HDR_PUSH(GET_POPTTYPE(pItem))) {

                ReInit = TRUE;
            }

            if (TreeView_GetItem(pTVWnd->hWndTV, &(NMtv.itemNew))) {

                NMtv.itemOld = NMtv.itemNew;

                SetupTVSelect(hDlg, &NMtv, (ReInit) ? STVS_REINIT : 0);

                CPSUIDBG(DBG_UTV, ("*UpdateTreeViewItem: Item=Current Selection"));
            }
        }

        return(1);

    } else {

        return(0);
    }
}




LONG
UpdateTreeView(
    HWND        hDlg,
    PMYDLGPAGE  pCurMyDP
    )

/*++

Routine Description:





Arguments:




Return Value:




Author:

    08-Aug-1995 Tue 15:37:16 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    INT cUpdated = 0;


    if (pCurMyDP->Flags & (MYDPF_CHANGED | MYDPF_REINIT)) {

        PTVWND      pTVWnd;
        POPTITEM    pItem;
        UINT        cItem;
        BOOL        ReInit;
        BOOL        TVByPush;
        BYTE        TVPageIdx;


        pTVWnd    = (PTVWND)pCurMyDP->pTVWnd;
        pItem     = pTVWnd->ComPropSheetUI.pOptItem;
        cItem     = (UINT)pTVWnd->ComPropSheetUI.cOptItem;
        ReInit    = (pCurMyDP->Flags & MYDPF_REINIT);
        TVByPush  = (BOOL)(pTVWnd->Flags & TWF_TV_BY_PUSH);
        TVPageIdx = pTVWnd->TVPageIdx;

        CPSUIASSERT(0, "UpdateTreeView: DlgPage not treevie page (%ld)",
                ((pCurMyDP->DlgPage.DlgTemplateID == DP_STD_TREEVIEWPAGE)   ||
                 (pCurMyDP->DlgPage.DlgTemplateID == DP_STD_INT_TVPAGE))
                 && ((BYTE)pCurMyDP->PageIdx == TVPageIdx),
                (BYTE)pCurMyDP->PageIdx);

        CPSUIDBG(DBGITEM_UTV, ("UpdateTreeView (OPTIF_INT_TV_CHANGED)"));

        while (cItem--) {

            if (pItem->Flags & OPTIF_INT_TV_CHANGED) {

                if ((!TVByPush) || (pItem->DlgPageIdx == TVPageIdx)) {

                    CPSUIOPTITEM(DBGITEM_UTV, pTVWnd, "UpdateTreeView",
                                 1, pItem);

                    UpdateTreeViewItem(hDlg, pTVWnd, pItem, ReInit);

                    ++cUpdated;
                }

                pItem->Flags &= ~OPTIF_INT_TV_CHANGED;
            }

            pItem++;
        }

        pCurMyDP->Flags &= ~(MYDPF_CHANGED | MYDPF_REINIT);
    }

    return((LONG)cUpdated);
}





POPTITEM
TreeViewHitTest(
    PTVWND      pTVWnd,
    LONG        MousePos,
    UINT        TVHTMask
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    07-Sep-1995 Thu 22:32:04 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND            hWndTV = pTVWnd->hWndTV;
    TV_HITTESTINFO  ht;


    //
    // Find out the mouse cursor location if on the state icon/bmp
    //

    if (MousePos != -1) {

        ht.pt.x = (LONG)LOWORD(MousePos);
        ht.pt.y = (LONG)HIWORD(MousePos);

    } else {

        GetCursorPos(&ht.pt);
    }

    ScreenToClient(hWndTV, &ht.pt);
    TreeView_HitTest(hWndTV, &ht);

    CPSUIDBG(DBG_TVHT,
             ("TreeViewHitTest: pt=(%ld, %ld), HitTest=%04lx, TVHT_xx=%ld",
                    (DWORD)ht.pt.x, (DWORD)ht.pt.y, TVHTMask, (DWORD)ht.flags));

    if (ht.flags & TVHTMask) {

        POPTTYPE    pOptType;
        POPTITEM    pItem;
        TV_ITEM     tvi;


        tvi.hItem     = ht.hItem;
        tvi.mask      = TVIF_CHILDREN | TVIF_HANDLE | TVIF_STATE | TVIF_PARAM;
        tvi.stateMask = TVIS_STATEIMAGEMASK;

        if (TreeView_GetItem(hWndTV, &tvi)) {

            return(GetOptions(pTVWnd, tvi.lParam));
        }
    }

    return(NULL);
}




VOID
TreeViewChangeMode(
    PTVWND      pTVWnd,
    POPTITEM    pItem,
    UINT        Mode
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    07-Sep-1995 Thu 22:56:05 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hWndTV = pTVWnd->hWndTV;
    POPTTYPE    pOptType;
    TV_ITEM     tvi;

    tvi.mask  = TVIF_CHILDREN | TVIF_HANDLE | TVIF_STATE | TVIF_PARAM;

    if ((!pItem)                            ||
        (!(tvi.hItem = _OI_HITEM(pItem)))   ||
        (!TreeView_GetItem(hWndTV, &tvi))) {

        return;
    }

    switch (Mode) {

    case TVCM_TOGGLE:

        if (tvi.cChildren) {

            PostMessage(hWndTV,
                        TVM_EXPAND,
                        (WPARAM)TVE_TOGGLE,
                        (LPARAM)tvi.hItem);
        }

        break;

    case TVCM_SELECT:

        PostMessage(hWndTV,
                    TVM_SELECTITEM,
                    (WPARAM)TVGN_CARET,
                    (LPARAM)tvi.hItem);
        //
        // We will go to the next control only if the item is not disabled
        // and has an update permisson (push button always has one).
        //

#if DO_IN_PLACE
        if ((!tvi.cChildren)                        &&
            (!(pItem->Flags & OPTIF_DISABLED))      &&
            (pOptType = GET_POPTTYPE(pItem))        &&
            (!IS_HDR_PUSH(pOptType))                &&
            ((pTVWnd->Flags & TWF_CAN_UPDATE)   ||
             (pOptType->Flags & OTS_PUSH_ENABLE_ALWAYS))) {

            if (pOptType->Type == TVOT_PUSHBUTTON) {

                PostMessage(pTVWnd->hDlgTV,
                            WM_COMMAND,
                            MAKEWPARAM(IDD_TV_PUSH, BN_CLICKED),
                            (LPARAM)GetDlgItem(pTVWnd->hWndTV, IDD_TV_PUSH));

            } else if (pTVWnd->chWndEdit) {

                PostMessage(pTVWnd->hDlgTV,
                            WM_NEXTDLGCTL,
                            (WPARAM)pTVWnd->hWndEdit[0],
                            (LPARAM)1);
            }
        }
#else
        if ((!tvi.cChildren)                        &&
            (!(pItem->Flags & OPTIF_DISABLED))      &&
            (pOptType = GET_POPTTYPE(pItem))        &&
            (pOptType->Type == TVOT_PUSHBUTTON)     &&
            (!IS_HDR_PUSH(pOptType))                &&
            ((pTVWnd->Flags & TWF_CAN_UPDATE)   ||
             (pOptType->Flags & OTS_PUSH_ENABLE_ALWAYS))) {

            PostMessage(pTVWnd->hDlgTV,
                        WM_COMMAND,
                        MAKEWPARAM(IDD_TV_PUSH, BN_CLICKED),
                        (LPARAM)GetDlgItem(pTVWnd->hDlgTV, IDD_TV_PUSH));
        }
#endif

        break;
    }

}



VOID
MouseSelectItem(
    HWND    hDlg,
    PTVWND  pTVWnd
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Jun-1995 Thu 13:44:18 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    POPTITEM    pItem;

    //
    // Find out the mouse cursor location if on the state icon/bmp
    //

    if (pItem = TreeViewHitTest(pTVWnd, -1, TVHT_ONITEM)) {

        TreeViewChangeMode(pTVWnd, pItem, TVCM_SELECT);
    }
}


#if 0


BOOL
CreateTVCtrls(
    HWND    hDlg
    )

/*++

Routine Description:

    This function create any treeview change control that not in the static
    template


Arguments:




Return Value:




Author:

    06-Feb-1998 Fri 15:57:42 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hCtrl;

    //
    // Create TrackBar Control
    //

    if (hCtrl = CreateTrackBar(hDlg, IDD_TV_TRACKBAR)) {

        EnableWindow(hCtrl, FALSE);
        ShowWindow(hCtrl, SW_HIDE);

        //
        // Create Up/Down Control
        //

        if (hCtrl = CreateUDArrow(hDlg, IDD_TV_UDARROW_EDIT, IDD_TV_UDARROW)) {

            ShowWindow(hCtrl, SW_HIDE);
            EnableWindow(hCtrl, FALSE);

            return(TRUE);
        }
    }

    return(FALSE);
}

#endif



HWND
CreatehWndTV(
    HWND    hDlg,
    PTVWND  pTVWnd
    )

/*++

Routine Description:

    This function create TREE VIEW window


Arguments:

    hDlg    - Handle to the dialog for the treeview to be created, it must
              have item identify as IDD_TV_WND for the treeview window location

Return Value:

    HWND for the treeview window


Author:

    21-Jun-1995 Wed 13:33:29 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hWndTV = NULL;
    HWND    hCtrl;
    DWORD   dw;
    RECT    rc;
    WORD    InitItemIdx = 0xFFFE;


#if 0
    if (!CreateTVCtrls(hDlg)) {

        return(NULL);
    }
#endif

    //
    // Create TreeView Window, Get the window size for the treeview
    //

    hCtrl   = CtrlIDrcWnd(hDlg, IDD_TV_WND, &rc);
    if (hCtrl)
    {
        SETCTRLDATA(hCtrl, CTRLS_TV_STATIC, 0);
        ShowWindow(hCtrl, SW_HIDE);

        CPSUIDBG(DBG_CTVWND,
                ("\nINIT DEV DLG, CLIENT rc=(%ld, %ld) - (%ld, %ld) = %ld x %ld",
                    rc.left, rc.top, rc.right, rc.bottom,
                    rc.right - rc.left, rc.bottom - rc.top));

        if (hWndTV = CreateWindowEx(WS_EX_NOPARENTNOTIFY    |
                                        WS_EX_CLIENTEDGE,
                                    WC_TREEVIEW,
                                    L"",
                                    WS_VISIBLE              |
                                        TVS_HASBUTTONS      |
                                        TVS_SHOWSELALWAYS   |
                                        TVS_DISABLEDRAGDROP |
                                        // TVS_LINESATROOT     |
                                        TVS_HASLINES        |
                                        WS_CLIPCHILDREN     |
                                        WS_CHILD            |
                                        WS_BORDER           |
                                        WS_TABSTOP          |
                                        WS_CLIPSIBLINGS     |
                                        WS_GROUP,
                                    rc.left,
                                    rc.top,
                                    rc.right - rc.left,
                                    rc.bottom - rc.top,
                                    hDlg,
                                    (HMENU)(IDD_TV_WND + 0),
                                    hInstDLL,
                                    0)) {



            DestroyWindow(hCtrl);

            pTVWnd->hWndTV = hWndTV;
            SetWindowPos(hWndTV, GetDlgItem(hDlg, IDD_TV_WND), 0, 0, 0, 0,
                         SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);

            InitItemIdx = 0xFFFF;
            SETCTRLDATA(hWndTV, CTRLS_TV_WND, 0);

    #if DO_IN_PLACE
    #if 1
    #if 0
            if (hCtrl = GetDlgItem(hDlg, IDD_PRE_EDIT)) {

                ShowWindow(hCtrl, SW_HIDE);
                EnableWindow(hCtrl, FALSE);
            }

            if (hCtrl = GetDlgItem(hDlg, IDD_POST_EDIT)) {

                ShowWindow(hCtrl, SW_HIDE);
                EnableWindow(hCtrl, FALSE);
            }
    #endif
    #else
            if (hCtrl = GetDlgItem(hDlg, IDD_PRE_EDIT)) {

                SetWindowPos(hWndTV,
                             hCtrl,
                             0, 0, 0, 0,
                             SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);

                SetProp(hCtrl,
                        CPSUIPROP_WNDPROC,
                        (HANDLE)GetWindowLongPtr(hCtrl, GWLP_WNDPROC));

                SetWindowLongPtr(hCtrl, GWLP_WNDPROC, (LPARAM)FocusCtrlProc);

                SetWindowPos(hCtrl, NULL,
                             -10000, -10000, 0, 0,
                             SWP_NOSIZE | SWP_NOZORDER);
            }

            //
            // Doing Post window
            //

            if (hCtrl = GetDlgItem(hDlg, IDD_POST_EDIT)) {

                SetWindowPos(hCtrl, hWndTV,
                             -9000, -9000, 0, 0,
                             SWP_NOSIZE | SWP_NOREDRAW);

                SetProp(hCtrl,
                        CPSUIPROP_WNDPROC,
                        (HANDLE)GetWindowLongPtr(hCtrl, GWLP_WNDPROC));

                SetWindowLongPtr(hCtrl, GWLP_WNDPROC, (LPARAM)FocusCtrlProc);
            }
    #endif

            if (pTVWnd->hDCTVWnd = GetWindowDC(hWndTV)) {

                CreateTVFonts(pTVWnd,
                              (HANDLE)SendMessage(hWndTV, WM_GETFONT, 0, 0));
            }

    #endif
            pTVWnd->TVWndProc = (WNDPROC)SetWindowLongPtr(hWndTV,
                                                          GWLP_WNDPROC,
                                                          (LPARAM)MyTVWndProc);

        }

        CPSUIDBG(DBG_CTVWND, ("\nINIT DLG (%08lx), hWndTV = %08lx",
                                                hDlg, hWndTV));
    }

    return(hWndTV);
}




HTREEITEM
AddItem(
    PTVWND      pTVWnd,
    HTREEITEM   hParent,
    POPTITEM    pItem,
    UINT        DefTVIS,
    UINT        TVLevel
    )

/*++

Routine Description:

    This function add a item to the end of list of treeview specified by

Arguments:

    hParent     - handle to the parent item for the item to be added

    pItem       - Pointer to the OPTITEM to be added

    ItemIdx     - Index to the pOptItem

    DefTVIS     - default TVIS_xxxx

Return Value:

    HTREEITEM of the item added or NULL if nothing added


Author:

    19-Jun-1995 Mon 16:38:27 created  -by-  Daniel Chou (danielc)

    08-Sep-1995 Fri 13:43:34 updated  -by-  Daniel Chou (danielc)
        Re-write to make it more compact

Revision History:


--*/

{
    WORD    ItemIdx;
    DWORD   Flags;


    if ((VALID_PTR(pItem))                         &&
        (pItem >= pTVWnd->ComPropSheetUI.pOptItem) &&
        (pItem <= pTVWnd->pLastItem)) {

        ItemIdx = (WORD)(pItem - pTVWnd->ComPropSheetUI.pOptItem);

    } else {

        ItemIdx = LOWORD(LODWORD(pItem));
        pItem   = PIDX_INTOPTITEM(pTVWnd, ItemIdx);

        if ((ItemIdx == INTIDX_PAPER)   ||
            (ItemIdx == INTIDX_GRAPHIC)) {

            if (pTVWnd->Flags & TWF_ADVDOCPROP) {

                DefTVIS &= ~TVIS_EXPANDED;

            } else {

                DefTVIS |= TVIS_EXPANDED;
            }
        }
    }

    CPSUIDBG(DBG_AI, ("ItemIdx = %ld (%08lx)", ItemIdx, ItemIdx));
    CPSUIOPTITEM(DBG_AI, pTVWnd, "AddItem", 1, pItem);

    if (!(pItem->Flags & (OPTIF_INT_ADDED | OPTIF_ITEM_HIDE))) {

        TV_INSERTSTRUCT tvins;

        //
        // Set to internal added if this item is a user item
        //

        _OI_TVLEVEL(pItem)   = (BYTE)TVLevel;
        tvins.item.state     = DefTVIS;
        tvins.item.stateMask = TVIS_EXPANDED;   //  | TVIS_BOLD;
        tvins.item.mask      = TVIF_TEXT        |
                                TVIF_STATE      |
                                TVIF_IMAGE      |
                                TVIF_SELECTEDIMAGE;
        tvins.hInsertAfter   = TVI_LAST;
        tvins.hParent        = hParent;

        SetTVItemState(pTVWnd, &tvins, pItem);

        if ((pItem->Flags |= OPTIF_INT_ADDED) & OPTIF_INITIAL_TVITEM) {

            if (pTVWnd->pCurTVItem) {

                CPSUIWARN(("Treeview: More than one OPTIF_INITIAL_TVITEM, OverRide"));
            }

            pTVWnd->pCurTVItem = pItem;
        }

        return(_OI_HITEM(pItem));
    }

    return(NULL);
}




UINT
AddItemGroup(
    PTVWND      pTVWnd,
    HTREEITEM   hParent,
    POPTITEM    *ppItem,
    UINT        TVLevel,
    UINT        BegDMPubID,
    UINT        EndDMPubID
    )

/*++

Routine Description:

    This function add items starting from the *ppItem, the item added includes
    item's sibling and all theirs children until end of the the pOptItem array.
    It also skip all the OPTIF_INT_ADDED and OPTIF_ITEM_HIDE items
    and its children

Arguments:

    pTVWnd  - Pointer to the TVWND instance data

    hParent - Parent of the starting item

    ppItem  - Pointer to POPTITEM for the starting item in the pOptItem array
              at return this pointer is updated to the next item which either
              at end of array or the parent's sibling

Return Value:

    UINT, count of item added to the treeview, it also update ppItem pointer


Author:

    27-Jun-1995 Tue 18:44:16 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    POPTITEM    pItem;
    HTREEITEM   hCurGrp;
    POPTITEM    pLastItem;
    BYTE        GrpLevel;
    BYTE        CurLevel;
    UINT        cAdd;



    pItem     = *ppItem;
    pLastItem = pTVWnd->pLastItem;
    GrpLevel  = pItem->Level;
    hCurGrp   = hParent;
    cAdd      = 0;

    while (pItem <= pLastItem) {

        if ((CurLevel = pItem->Level) < GrpLevel) {

            //
            // Finished the group level
            //

            break;

        } else if (pItem->Flags & (OPTIF_ITEM_HIDE | OPTIF_INT_ADDED)) {

            //
            // Skip this item and all its children
            //

            CPSUIOPTITEM(DBGITEM_AIG, pTVWnd, "Skip HIDE/INT_ADDED Item", 1, pItem);

            while ((++pItem <= pLastItem) && (pItem->Level > CurLevel));

        } else if (CurLevel > GrpLevel) {

            //
            // Adding its children only if this item is not OPTIF_INT_ADDED and
            // OPTIF_ITEM_HIDE
            //

            CPSUIOPTITEM(DBG_AIG, pTVWnd, "AddItemGroup", 1, pItem);

            cAdd += AddItemGroup(pTVWnd,
                                 hCurGrp,
                                 &pItem,
                                 TVLevel + 1,
                                 0,
                                 0xFFFF);

        } else if (((UINT)pItem->DMPubID < BegDMPubID)  ||
                   ((UINT)pItem->DMPubID > EndDMPubID)) {

            //
            // Skip this item and all its children
            //


            CPSUIOPTITEM(DBGITEM_AIG, pTVWnd, "Skip DMPubID Item", 1, pItem);
            CPSUIDBG(DBGITEM_AIG, ("Skip %ld (ONLY DMPubID=%ld-%ld Items)",
                                    pItem->DMPubID, BegDMPubID, EndDMPubID));

            while ((++pItem <= pLastItem) && (pItem->Level > CurLevel));

        } else {

            HTREEITEM   hAdd;
            UINT        DefTVIS = 0;

            //
            // Adding its sibling, checking if we could have children, if
            // we do then add the TVIS_BOLD flag to it, at return we want to
            // know if did add the item, if we do then this is his childrern's
            // parent handle
            //

            DefTVIS = (pItem->Flags & OPTIF_COLLAPSE) ? 0 : TVIS_EXPANDED;

            if ((pItem < pLastItem) && ((pItem + 1)->Level > CurLevel)) {

                DefTVIS |= TVIS_BOLD;
            }

            if (hAdd = AddItem(pTVWnd, hParent, pItem, DefTVIS, TVLevel)) {

                hCurGrp = hAdd;
                cAdd++;
            }

            pItem++;
        }
    }

    *ppItem = pItem;

    return(cAdd);
}




UINT
AddPubGroup(
    PTVWND      pTVWnd,
    HTREEITEM   hParent,
    PINTTVGRP   *ppitvg,
    UINT        TVLevel,
    UINT        DMPubIDAdd
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Sep-1995 Sat 11:58:59 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    POPTITEM    pItem = NULL;
    HTREEITEM   hLastGrp;
    HTREEITEM   hCurGrp;
    PINTTVGRP   pitvg;
    LPWORD      pDMPubIdx;
    UINT        cAdd;
    WORD        Idx;
    BYTE        GrpLevel;
    BYTE        CurLevel;


    pitvg     = *ppitvg;
    pDMPubIdx = pTVWnd->DMPubIdx;
    GrpLevel  = (BYTE)(pitvg->LevelFlags & ITVG_LEVEL_MASK);
    hLastGrp  = NULL;
    hCurGrp   = hParent;
    cAdd      = 0;

    while ((CurLevel = (pitvg->LevelFlags & ITVG_LEVEL_MASK)) >= GrpLevel) {

        if (CurLevel > GrpLevel) {

            //
            // Adding its children
            //

            PINTTVGRP   pParentitvg = pitvg - 1;

            CPSUIASSERT(0, "AddPubGroup: Internal ERROR, no parent=%ld",
                        (cAdd) && (hCurGrp), UIntToPtr(cAdd));

            if (Idx = (WORD)AddPubGroup(pTVWnd,
                                        hCurGrp,
                                        &pitvg,
                                        TVLevel + 1,
                                        DMPubIDAdd)) {

                cAdd += (UINT)Idx;

            } else {

                CPSUIDBG(DBG_APG,
                         ("AddPubGroup(Level=%02lx, ID=%ld), pItem=%08lx",
                        pParentitvg->LevelFlags, pParentitvg->DMPubID, pItem));

                if ((pParentitvg->DMPubID >= DMPUB_HDR_FIRST) ||
                       ((pItem) && (pItem->pOptType == NULL))) {

                    //
                    // Nothing added for this group, if this is the internal
                    // group item then delete otherwise do not delete user's
                    // item if the item has OPTTYPE
                    //

                    CPSUIINT(("0 Added, DELETE its Parent"));

                    TreeView_DeleteItem(pTVWnd->hWndTV, hCurGrp);

                    --cAdd;
                    hCurGrp  = hLastGrp;
                    hLastGrp = NULL;

                } else {

                    //
                    // We need to take out the BOLD status
                    //

                    TV_ITEM tvi;

                    tvi.mask      = TVIF_STATE;
                    tvi.hItem     = hCurGrp;
                    tvi.state     = 0;
                    tvi.stateMask = TVIS_BOLD;

                    CPSUIINT(("0 Added, Remove pItem's BOLD"));

                    TreeView_SetItem(pTVWnd->hWndTV, &tvi);
                }
            }

        } else {

            HTREEITEM   hAdd = NULL;
            UINT        DefTVIS;
            BYTE        DMPubID;
            BOOL        IsHdr;

            //
            // Adding its sibling, checking if we could have children, if
            // we do then add the TVIS_BOLD flag to it, at return we want to
            // know if did add the item, if we do then this is his childrern's
            // parent handle
            //

            if (pitvg->LevelFlags & ITVGF_COLLAPSE) {

                DefTVIS = 0;

            } else {

                DefTVIS = TVIS_EXPANDED;
            }

            if (pitvg->LevelFlags & ITVGF_BOLD) {

                DefTVIS |= TVIS_BOLD;
            }

            if ((DMPubID = pitvg->DMPubID) >= DMPUB_HDR_FIRST) {

                pItem    = (POPTITEM)UIntToPtr(DMPubID - DMPUB_HDR_FIRST + INTIDX_FIRST);
                DefTVIS |= TVIS_BOLD;

            } else if ((Idx = pDMPubIdx[DMPubID - DMPUB_FIRST]) != 0xFFFF) {

                pItem = pTVWnd->ComPropSheetUI.pOptItem + Idx;

            } else {

                pItem = NULL;
            }

            if ((pItem) &&
                (hAdd = AddItem(pTVWnd, hParent, pItem, DefTVIS, TVLevel))) {

                hLastGrp = hCurGrp;
                hCurGrp  = hAdd;
                cAdd++;

                //
                // If this item has children, add the children
                //

                if ((VALID_PTR(pItem))              &&
                    (++pItem <= pTVWnd->pLastItem)  &&
                    (pItem->Level > (pItem-1)->Level)) {

                    cAdd += AddItemGroup(pTVWnd,
                                         hAdd,
                                         &pItem,
                                         TVLevel + 1,
                                         0,
                                         0xFFFF);
                }

                pitvg++;

            } else {

                //
                // Skip all the childrens belongs to him
                //

                CPSUIDBG(DBG_APG,
                         ("Eiter pItem=NULL(%08lx) or AddItem()=NULL(%08lx)",
                                                pItem, hAdd));

                while (((++pitvg)->LevelFlags & ITVG_LEVEL_MASK) > CurLevel) {

                    //
                    // We need to skip all the internal header and hide all
                    // the real user items
                    //

                    if ((DMPubID = pitvg->DMPubID)  &&
                        (DMPubID <= DMPUB_LAST)     &&
                        ((Idx = pDMPubIdx[DMPubID - DMPUB_FIRST]) != 0xFFFF)) {

                        POPTITEM    pLastItem;
                        BYTE        ItemLevel;


                        pItem     = pTVWnd->ComPropSheetUI.pOptItem + Idx;
                        pLastItem = pTVWnd->pLastItem;
                        ItemLevel = pItem->Level;

                        CPSUIOPTITEM(DBG_APG, pTVWnd, "Skip ITVG", 1, pItem);

                        SKIP_CHILDREN_ORFLAGS(pItem,
                                              pLastItem,
                                              ItemLevel,
                                              OPTIF_INT_ADDED);
                    }
                }
            }
        }
    }

    if ((GrpLevel == 1) && (hCurGrp)) {

        CPSUIDBG(DBG_OEM_ITEM,
                 ("Add OEM Item Group, DMPubID=%ld", DMPubIDAdd));

        pItem = pTVWnd->ComPropSheetUI.pOptItem;

        cAdd += AddItemGroup(pTVWnd,
                             hCurGrp,
                             &pItem,
                             TVLevel,
                             DMPubIDAdd,
                             DMPubIDAdd);
    }

    *ppitvg = pitvg;

    return(cAdd);
}



BOOL
AddOptItemToTreeView(
    PTVWND      pTVWnd
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    18-Aug-1995 Fri 14:39:32 created  -by-  Daniel Chou (danielc)


Revision History:

    30-Jul-1997 Wed 14:02:36 updated  -by-  Daniel Chou (danielc)
        Added codes that allowed DMPubID 0 to be added to Root


--*/

{
    HTREEITEM   hParent;
    HTREEITEM   hRoot;
    POPTITEM    pItem;
    UINT        DefTVIS = TVIS_EXPANDED;
    UINT        TVLevel = 0;


    //
    // Adding the header to it as Icon: CallerName XXXX
    //

    hRoot    =
    hParent  = AddItem(pTVWnd,
                       TVI_ROOT,
                       (POPTITEM)INTIDX_TVROOT,
                       DefTVIS | TVIS_BOLD,
                       TVLevel);
    TVLevel += 1;


    if (pTVWnd->Flags & TWF_TVPAGE_CHK_DMPUB) {

        if (pTVWnd->Flags & TWF_TVPAGE_NODMPUB) {

            POPTITEM    pLastItem = pTVWnd->pLastItem;

            //
            // Mark all the DMPUB_xxx to OPTIF_INT_ADDED
            //

            pItem = pTVWnd->ComPropSheetUI.pOptItem;

            while (pItem <= pLastItem) {

                BYTE    CurLevel = pItem->Level;

                if ((pItem->DMPubID != DMPUB_NONE)  &&
                    (pItem->DMPubID < DMPUB_USER)) {

                    SKIP_CHILDREN_ORFLAGS(pItem,
                                          pLastItem,
                                          CurLevel,
                                          OPTIF_INT_ADDED);

                } else {

                    SKIP_CHILDREN(pItem, pLastItem, CurLevel);
                }
            }

        } else {

            HTREEITEM   hHdrGrp;
            PINTTVGRP   pitvg;


            pitvg = (PINTTVGRP)IntTVGrpPaper;

            AddPubGroup(pTVWnd,
                        hRoot,
                        &pitvg,
                        TVLevel,
                        DMPUB_OEM_PAPER_ITEM);

            pitvg = (PINTTVGRP)IntTVGrpGraphic;

            AddPubGroup(pTVWnd,
                        hRoot,
                        &pitvg,
                        TVLevel,
                        DMPUB_OEM_GRAPHIC_ITEM);

            DefTVIS = 0;
        }
    }

    if (pTVWnd->IntTVOptIdx) {

        pItem = PIDX_INTOPTITEM(pTVWnd, pTVWnd->IntTVOptIdx);

        if (pTVWnd->Flags & (TWF_ADVDOCPROP | TWF_TV_BY_PUSH)) {

            pItem->Flags &= ~OPTIF_COLLAPSE;
        }

        if (pItem->Flags & OPTIF_COLLAPSE) {

            DefTVIS &= ~TVIS_EXPANDED;

        } else {

            DefTVIS |= TVIS_EXPANDED;
        }

        hParent = AddItem(pTVWnd,
                          hRoot,
                          (POPTITEM)pTVWnd->IntTVOptIdx,
                          DefTVIS | TVIS_BOLD,
                          TVLevel);

        //
        // Add OEM items that under the TVROOT
        //

        CPSUIDBG(DBG_OEM_ITEM,
                 ("Add OEM Item Group, DMPubID=%ld", DMPUB_OEM_ROOT_ITEM));

        pItem = pTVWnd->ComPropSheetUI.pOptItem;

        AddItemGroup(pTVWnd,
                     hRoot,
                     &pItem,
                     TVLevel,
                     DMPUB_OEM_ROOT_ITEM,
                     DMPUB_OEM_ROOT_ITEM);

        TVLevel += 1;
    }

    //
    // Add rest of the OPTITEMS
    //

    pItem = pTVWnd->ComPropSheetUI.pOptItem;

    if ((!AddItemGroup(pTVWnd, hParent, &pItem, TVLevel, 0, 0xFFFF)) &&
        (hParent != hRoot)) {

        //
        // Since we did not add any item, s delete the Options header if any
        //

        CPSUIINT(("There is NO 'Options' items, delete the header"));

        TreeView_DeleteItem(pTVWnd->hWndTV, hParent);
    }

    return(TRUE);
}



HWND
CreateTVOption(
    HWND        hDlg,
    PTVWND      pTVWnd
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    19-Jun-1995 Mon 16:18:43 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hWndTV;
    HTREEITEM   hRoot;
    POPTITEM    pItem;
    POPTITEM    pCurTVItem;
    POPTITEM    pLastItem;
    BYTE        TVPageIdx;


    pTVWnd->hDlgTV = hDlg;
    pCurTVItem     = pTVWnd->pCurTVItem;

    if (hWndTV = CreatehWndTV(hDlg, pTVWnd)) {

        pItem     = &(pTVWnd->IntOptItem[0]);
        pLastItem = &(pTVWnd->IntOptItem[INTIDX_TOTAL - 1]);
        TVPageIdx = (BYTE)(pTVWnd->cMyDlgPage - 1);

        while (pItem <= pLastItem) {

            _OI_HITEM(pItem)   = NULL;
            pItem->Flags      &= ~(OPTIF_INT_ADDED | OPTIF_INITIAL_TVITEM);
            pItem->DlgPageIdx  = TVPageIdx;

            if (pItem == pCurTVItem) {

                pItem->Flags |= OPTIF_INITIAL_TVITEM;
            }

            ++pItem;
        }

        pItem      = pTVWnd->ComPropSheetUI.pOptItem;
        pLastItem  = pTVWnd->pLastItem;

        while (pItem <= pLastItem) {

            _OI_HITEM(pItem)  = NULL;
            pItem->Flags     &= ~(OPTIF_INT_ADDED | OPTIF_INITIAL_TVITEM);

            if ((pTVWnd->Flags & TWF_TV_BY_PUSH) &&
                (pItem->DlgPageIdx != TVPageIdx)) {

                pItem->Flags |= OPTIF_INT_ADDED;
            }

            if (pItem == pCurTVItem) {

                pItem->Flags |= OPTIF_INITIAL_TVITEM;
            }

            ++pItem;
        }

        pTVWnd->pCurTVItem = NULL;

        InitDlgCtrl(hDlg, pTVWnd);

        SendMessage(pTVWnd->hWndTV,
                    TVM_SETIMAGELIST,
                    (WPARAM)TVSIL_NORMAL,
                    (LPARAM)pTVWnd->himi);

        AddOptItemToTreeView(pTVWnd);

    } else {

        CPSUIERR(("\nCreatehWndTV() failed"));
    }

    return(hWndTV);
}


#if DBG
#if 0

LRESULT
CALLBACK
ShowChildWndProc(
    HWND    hWnd,
    LPARAM  lParam
    )
{
    HWND    hParent = (HWND)hWnd;
    DWORD   dw;
    WCHAR   Buf[64];

    dw = 0;

    while ((HWND)lParam != hParent) {

        Buf[dw++] = L' ';
        Buf[dw++] = L' ';

        hParent = GetParent(hParent);
    }

    Buf[dw++] = L'\0';

    CPSUIDBG(DBG_SCID, ("%wshWnd=%08lx, hParent=%08lx, ID=%5ld",
                Buf, hWnd, GetParent(hWnd),
                GetWindowLongPtr(hWnd, GWLP_ID)));

    return(TRUE);
}

#endif
#endif



INT_PTR
CALLBACK
TreeViewProc(
    HWND    hDlg,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    28-Jun-1995 Wed 17:00:44 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    POPTITEM    pItem;
    HWND        hWndTV;
    HWND        *phWnd;
    HICON       hIcon;
    PTVWND      pTVWnd;
    PMYDLGPAGE  pCurMyDP;
    NM_TREEVIEW *pNMTV;
    DWORD       dw;
    HTREEITEM   hItem;


    if (Msg == WM_INITDIALOG) {

        CPSUIINT(("Treeview WM_INITDIALOG: hDlg=%08lx, pPSP=%08lx", hDlg, lParam));

        pCurMyDP             = (PMYDLGPAGE)(((LPPROPSHEETPAGE)lParam)->lParam);
        pTVWnd               = (PTVWND)pCurMyDP->pTVWnd;
        pCurMyDP->pPSPInfo   = PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam);
        pCurMyDP->hDlgChild  = NULL;
        pTVWnd->Flags       |= TWF_IN_TVPAGE;

        SetWindowLongPtr(hDlg,
                         GWL_EXSTYLE,
                         GetWindowLongPtr(hDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);


        if (!ADD_PMYDLGPAGE(hDlg, pCurMyDP)) {

            return(FALSE);
        }

        if (pTVWnd->Flags & TWF_TV_BY_PUSH) {

            SetWindowText(hDlg, ((LPPROPSHEETPAGE)lParam)->pszTitle);
        }

        CreateImageList(hDlg, pTVWnd);
        CreateTVOption(hDlg, pTVWnd);
        SetUniqChildID(hDlg);
        CommonPropSheetUIHelpSetup(NULL, pTVWnd);
        UpdateCallBackChanges(hDlg, pTVWnd, TRUE);

        if (pItem = pTVWnd->pCurTVItem) {

            pTVWnd->pCurTVItem = NULL;

            if (!TreeView_SelectItem(pTVWnd->hWndTV, _OI_HITEM(pItem))) {

                pItem = NULL;
            }
        }

        if ((!pItem)                                    &&
            (hItem = TreeView_GetRoot(pTVWnd->hWndTV))  &&
            (!SelectFirstVisibleOptItem(pTVWnd, hItem))) {

            TreeView_SelectItem(pTVWnd->hWndTV, hItem);
        }

        if (pTVWnd->Flags & TWF_TV_BY_PUSH) {

            SetOptItemNewDef(hDlg, pTVWnd, TRUE);
        }

        SetFocus(pTVWnd->hWndTV);
        return(FALSE);
    }

    if (pCurMyDP = GET_PMYDLGPAGE(hDlg)) {

        pTVWnd = pCurMyDP->pTVWnd;
        hWndTV = pTVWnd->hWndTV;

        switch(Msg) {

        case WM_GETDLGCODE:

            CPSUIINT(("TreeViewProc: WM_GETDLGCODE"));
            break;

        case WM_NEXTDLGCTL:

            CPSUIINT(("TreeViewProc: WM_NEXTDLGCTL: flHandle=%ld, wParam=%08lx",
                        LOWORD(lParam), wParam));
            break;

        case WM_DRAWITEM:

            return(DrawLBCBItem(pTVWnd, (LPDRAWITEMSTRUCT)lParam));

        case WM_COMMAND:

            if (pTVWnd->Flags & TWF_TV_BY_PUSH) {

                switch (LOWORD(wParam)) {

                case IDCANCEL:

                    pItem = PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT);

                    DoCallBack(hDlg,
                               pTVWnd,
                               pItem,
                               pItem->pSel,
                               (_CPSUICALLBACK)InternalRevertDef2,
                               NULL,
                               0,
                               CPSUICB_REASON_SEL_CHANGED);

                    UpdateCallBackChanges(hDlg, pTVWnd, TRUE);
                    EndDialog(hDlg, 0);
                    return(TRUE);

                case IDOK:

                    UpdateCallBackChanges(hDlg, pTVWnd, TRUE);
                    EndDialog(hDlg, 1);
                    return(TRUE);

                default:

                    break;
                }
            }

            //
            // Fall though
            //

        case WM_HSCROLL:

            if (pItem = DlgHScrollCommand(hDlg, pTVWnd, (HWND)lParam, wParam)) {

                UpdateTreeViewItem(hDlg, pTVWnd, pItem, FALSE);
            }

            break;

        case WM_ACTIVATE:

            if (LOWORD(wParam) != WA_INACTIVE) {

                CPSUIINT(("!! WM_SETACTIVE: cEdit=%ld !!", pTVWnd->chWndEdit));

                InvalidateRect(hWndTV, NULL, FALSE);

                if (dw = (DWORD)pTVWnd->chWndEdit) {

                    phWnd = pTVWnd->hWndEdit;

                    while (dw--) {

                        if (hWndTV = *phWnd++) {

                            SetWindowPos(hWndTV, NULL,
                                         0, 0, 0, 0,
                                         SWP_NOSIZE | SWP_NOZORDER |
                                            SWP_NOMOVE | SWP_FRAMECHANGED);
                            InvalidateRect(hWndTV, NULL, FALSE);
                        }
                    }
                }
            }

            break;

        case WM_HELP:

            wParam = (WPARAM)((LPHELPINFO)lParam)->hItemHandle;
            lParam = (LPARAM)MAKELONG(((LPHELPINFO)lParam)->MousePos.x,
                                      ((LPHELPINFO)lParam)->MousePos.y);

        case WM_CONTEXTMENU:

            if (lParam == 0xFFFFFFFF) {

                RECT    rc;


                if ((HWND)(wParam = (WPARAM)GetFocus()) == hWndTV) {

                    pTVWnd->VKeyTV = VK_F1;

                    if (TreeView_GetItemRect(hWndTV,
                                             _OI_HITEM(pTVWnd->pCurTVItem),
                                             &rc,
                                             TRUE)) {

                        ClientToScreen(hWndTV, (LPPOINT)&rc.left);
                        ClientToScreen(hWndTV, (LPPOINT)&rc.right);

                    } else {

                        GetWindowRect((HWND)wParam, &rc);
                    }

                } else {

                    GetWindowRect((HWND)wParam, &rc);
                }

                CPSUIINT(("MousePos=0xFFFFFFFF, GetFocus=%08lx, rc=(%ld, %ld)-(%ld, %ld)",
                         (HWND)wParam, rc.left, rc.top, rc.right, rc.bottom));

                rc.left += ((rc.right - rc.left) / 2);
                rc.top  += ((rc.bottom - rc.top) / 2);
                lParam   = (LPARAM)MAKELONG(rc.left, rc.top);
            }

            CPSUIINT(("--- WM_%ws --hWndTV=%08lx, wParam=%08lx. Mouse=(%ld, %ld)----",
                    (Msg == WM_HELP) ? L"HELP" : L"CONTEXTMENU",
                    hWndTV, wParam, LOWORD(lParam), HIWORD(lParam)));

            if ((HWND)wParam == hWndTV) {

                pItem = (pTVWnd->VKeyTV == VK_F1) ?
                            pTVWnd->pCurTVItem : TreeViewHitTest(pTVWnd,
                                                                 (LONG)lParam,
                                                                 TVHT_ONITEM);

                if (!pItem) {

                    CPSUIINT(("pItem=NULL, hWnd=%08lx, ID=%ld",
                        wParam, GetWindowLongPtr((HWND)wParam, GWLP_ID)));

                    pItem = pItemFromhWnd(hWndTV, pTVWnd, NULL, (LONG)lParam);
                }

            } else {

                pItem = pItemFromhWnd(hDlg, pTVWnd, (HWND)wParam, (LONG)lParam);
            }

            //
            // Reset key now
            //

            pTVWnd->VKeyTV = 0;

            if (Msg == WM_CONTEXTMENU) {

                DoContextMenu(pTVWnd, hDlg, pItem, lParam);

            } else if (pItem) {

                CommonPropSheetUIHelp(hDlg,
                                      pTVWnd,
                                      (HWND)hWndTV,
                                      (DWORD)lParam,
                                      pItem,
                                      HELP_WM_HELP);
            }

            break;

        case WM_NOTIFY:

            pNMTV = (NM_TREEVIEW *)lParam;
            dw    = 0;

            switch (pNMTV->hdr.code) {

            case NM_DBLCLK:

                TreeViewChangeMode(pTVWnd, pTVWnd->pCurTVItem, TVCM_SELECT);
                break;

            case NM_SETFOCUS:
            case NM_CLICK:
            case NM_RDBLCLK:
            case NM_RCLICK:

                break;

            case TVN_ITEMEXPANDING:

                CPSUIDBG(DBG_TVPROC, ("TVN_ITEMEXPANDING:"));
                break;

            case TVN_ITEMEXPANDED:

                CPSUIDBG(DBG_TVPROC, ("TVN_ITEMEXPANDED:"));

                if ((pTVWnd->IntTVOptIdx)                                   &&
                    (pItem = PIDX_INTOPTITEM(pTVWnd, pTVWnd->IntTVOptIdx))  &&
                    (_OI_HITEM(pItem) == pNMTV->itemNew.hItem)) {

                    if (pNMTV->itemNew.state & TVIS_EXPANDED) {

                        CPSUIINT(("Internal OPTIONS Expanded"));

                        pItem->Flags &= ~OPTIF_COLLAPSE;

                    } else {

                        CPSUIINT(("Internal OPTIONS Collapse"));

                        pItem->Flags |= OPTIF_COLLAPSE;
                    }
                }

                break;

            case TVN_KEYDOWN:

                pTVWnd->VKeyTV = ((TV_KEYDOWN *)lParam)->wVKey;

                CPSUIDBG(DBG_KEYS, ("TVN_KEYDOWN: VKey=%ld", pTVWnd->VKeyTV));

                if ((pItem = pTVWnd->pCurTVItem)    &&
                    (hItem = _OI_HITEM(pItem))) {

                    switch (pTVWnd->VKeyTV) {

                    case VK_LEFT:
                    case VK_BACK:

                        if ((!TreeView_GetChild(hWndTV, hItem)) &&
                            (hItem = TreeView_GetParent(hWndTV, hItem))) {

                            PostMessage(hWndTV,
                                        TVM_SELECTITEM,
                                        (WPARAM)TVGN_CARET,
                                        (LPARAM)hItem);
                        }

                        break;

                    case VK_RIGHT:

                        if ((pTVWnd->chWndEdit) &&
                            (pTVWnd->hWndEdit[0])) {

                            SetFocus(pTVWnd->hWndEdit[0]);
                        }

                        break;

                    }
                }

                break;

            case TVN_GETDISPINFO:

                SetTVItemImage(pTVWnd, (TV_DISPINFO *)lParam);
                break;

            case TVN_SELCHANGED:
#if DO_IN_PLACE
                if (pItem = pTVWnd->pCurTVItem) {

                    _OI_INTFLAGS(pItem) &= ~OIDF_ZERO_SEL_LEN;
                    SetTVItemState(pTVWnd, NULL, pItem);
                }

                if ((pItem = GetOptions(pTVWnd, pNMTV->itemNew.lParam)) &&
                    (!(pItem->Flags & OPTIF_INT_HIDE))) {

                    CPSUIINT(("pOldItem=%08lx, pNewItem=%08lx, cxItem=%ld/%ld",
                        pTVWnd->pCurTVItem, pItem, pTVWnd->cxItem, pTVWnd->cxMaxItem));

                    _OI_INTFLAGS(pItem) |= OIDF_ZERO_SEL_LEN;
                    SetTVItemState(pTVWnd, NULL, pItem);
                }

                pTVWnd->pCurTVItem = (POPTITEM)~0;
#endif
                pTVWnd->pCurTVItem = SetupTVSelect(hDlg,
                                                   pNMTV,
                                                   STVS_REINIT | STVS_ACTIVE);
#if DO_IN_PLACE
                if (pTVWnd->cxItem > pTVWnd->cxMaxItem) {

                    CPSUIINT(("pCurTVItem=%08lx, cxItem=%ld <= %ld, Redo SetTVItemState()",
                                pTVWnd->pCurTVItem, pTVWnd->cxItem, pTVWnd->cxMaxItem));

                    SetTVItemState(pTVWnd, NULL, pTVWnd->pCurTVItem);
                }
#endif
                CPSUIOPTITEM(DBGITEM_SELCHG, pTVWnd, "TVN_SELCHANGED", 1, pTVWnd->pCurTVItem);

                CPSUIDBG(DBG_SCID, ("\n-----EnumChild of (%08lx)-----",
                                        GetParent(hDlg)));

#if DBG
#if 0
                EnumChildWindows(GetParent(hDlg),
                                 ShowChildWndProc,
                                 (LPARAM)GetParent(hDlg));
#endif
#endif

                break;

            case PSN_SETACTIVE:

                CPSUIDBG(DBG_TVPROC,
                         ("\nTreeView: Got PSN_SETACTIVE, pTVWnd=%08lx (%ld), Page=%u -> %u\n",
                            pTVWnd, pTVWnd->cMyDlgPage,
                            (UINT)pTVWnd->ActiveDlgPage, (UINT)pCurMyDP->PageIdx));

                pCurMyDP->Flags       |= MYDPF_PAGE_ACTIVE;
                pTVWnd->ActiveDlgPage  = pCurMyDP->PageIdx;
                pTVWnd->Flags         |= TWF_IN_TVPAGE;

                DoCallBack(hDlg,
                           pTVWnd,
                           pTVWnd->ComPropSheetUI.pOptItem,
                           (LPVOID)-1,
                           NULL,
                           NULL,
                           0,
                           CPSUICB_REASON_SETACTIVE);

                if ((pTVWnd->pCurTVItem) &&
                    (IS_HDR_PUSH(GET_POPTTYPE(pTVWnd->pCurTVItem)))) {

                    UpdateTreeViewItem(hDlg, pTVWnd, pTVWnd->pCurTVItem, TRUE);
                }

                UpdateTreeView(hDlg, pCurMyDP);

                CPSUIINT(("!! WM_SETACTIVE: cEdit=%ld", pTVWnd->chWndEdit));

                InvalidateRect(hWndTV, NULL, FALSE);

                if (dw = (DWORD)pTVWnd->chWndEdit) {

                    phWnd = pTVWnd->hWndEdit;

                    while (dw--) {

                        if (hWndTV = *phWnd++) {

                            InvalidateRect(hWndTV, NULL, FALSE);
                        }
                    }
                }

                dw = 0;

                break;

            case PSN_KILLACTIVE:

                CPSUIDBG(DBG_TVPROC, ("TreeView: Got PSN_KILLACTIVE, pTVWnd=%08lx (%ld)",
                            pTVWnd, pTVWnd->cMyDlgPage));

                if (pCurMyDP) {

                    pCurMyDP->hWndFocus  = GetFocus();
                    pCurMyDP->Flags     &= ~MYDPF_PAGE_ACTIVE;

                    DoCallBack(hDlg,
                               pTVWnd,
                               pTVWnd->ComPropSheetUI.pOptItem,
                               (LPVOID)-1,
                               NULL,
                               NULL,
                               0,
                               CPSUICB_REASON_KILLACTIVE);

                    pTVWnd->Flags &= ~TWF_IN_TVPAGE;
                }

                break;

            case PSN_APPLY:

                if ((pTVWnd->Flags & TWF_CAN_UPDATE)    &&
                    (pTVWnd->ActiveDlgPage == pCurMyDP->PageIdx)) {

                    CPSUIDBG(DBG_TVPROC,
                         ("\nTreeViewPage: Do PSN_APPLY(%ld), Page: Cur=%u, Active=%u, Flags=%04lx, CALLBACK",
                            (pTVWnd->Flags & TWF_APPLY_NO_NEWDEF) ? 1 : 0,
                            (UINT)pCurMyDP->PageIdx, (UINT)pTVWnd->ActiveDlgPage,
                            pTVWnd->Flags));

                    if (DoCallBack(hDlg,
                                   pTVWnd,
                                   (pTVWnd->Flags & TWF_APPLY_NO_NEWDEF) ?
                                        NULL : pTVWnd->ComPropSheetUI.pOptItem,
                                   (LPVOID)-1,
                                   NULL,
                                   NULL,
                                   0,
                                   CPSUICB_REASON_APPLYNOW) ==
                                               CPSUICB_ACTION_NO_APPLY_EXIT) {

                        // send a PSN_SETACTIVE message to treeview page so that we will set the 
                        // flags like TWF_IN_TVPAGE
                        HWND hParent;
                        if (hParent = GetParent(pTVWnd->hDlgTV)) {

                            PropSheet_SetCurSelByID(hParent, pCurMyDP->DlgPage.DlgTemplateID);
                        }
                        dw = PSNRET_INVALID_NOCHANGEPAGE;
                    }

                } else {

                    CPSUIDBG(DBG_TVPROC,
                         ("\nTreeViewPage: Ignore PSN_APPLY, Page: Cur=%u, Active=%u, Flags=%04lx, DO NOTHING",
                            (UINT)pCurMyDP->PageIdx, (UINT)pTVWnd->ActiveDlgPage,
                            pTVWnd->Flags));
                }

                break;

            case PSN_RESET:

                CPSUIDBG(DBG_TVPROC, ("\nTreeView: Got PSN_RESET (Cancel)\n"));

                break;

            case PSN_HELP:

                CPSUIDBG(DBG_TVPROC, ("\nTreeView: Got PSN_HELP (Help)\n"));
                CommonPropSheetUIHelp(hDlg,
                                      pTVWnd,
                                      hWndTV,
                                      0,
                                      NULL,
                                      HELP_CONTENTS);
                break;

            default:

                CPSUIDBG(DBG_TVPROC,
                         ("*TVProc: Unknow WM_NOTIFY=%08lx, id=%ld, hWnd=%08lx",
                            (DWORD)pNMTV->hdr.code, pNMTV->hdr.idFrom, pNMTV->hdr.hwndFrom));

                break;
            }

            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)dw);
            return(TRUE);
            break;

        case WM_DESTROY:

            CPSUIINT(("TreeViewProc: Get WM_DESTROY Message"));

            SetWindowLongPtr(hWndTV, GWLP_WNDPROC, (LPARAM)pTVWnd->TVWndProc);

            CommonPropSheetUIHelpSetup(hDlg, pTVWnd);

            DeleteTVFonts(pTVWnd);

            if (pTVWnd->hDCTVWnd) {

                ReleaseDC(hWndTV, pTVWnd->hDCTVWnd);
                pTVWnd->hDCTVWnd = NULL;
            }

            if (hIcon = (HICON)SendDlgItemMessage(hDlg,
                                                  IDD_TV_ICON,
                                                  STM_SETIMAGE,
                                                  (WPARAM)IMAGE_ICON,
                                                  (LPARAM)NULL)) {

                DestroyIcon(hIcon);
            }

            if (hIcon = (HICON)SendDlgItemMessage(hDlg,
                                                  IDD_TV_ECB_ICON,
                                                  STM_SETIMAGE,
                                                  (WPARAM)IMAGE_ICON,
                                                  (LPARAM)NULL)) {

                DestroyIcon(hIcon);
            }
#if 0
            if (hIcon = (HICON)SendDlgItemMessage(hDlg,
                                                  IDD_TV_HDR_PUSH_ICON,
                                                  STM_SETIMAGE,
                                                  (WPARAM)IMAGE_ICON,
                                                  (LPARAM)NULL)) {

                DestroyIcon(hIcon);
            }
#endif
            SendMessage(hWndTV,
                        TVM_SETIMAGELIST,
                        (WPARAM)TVSIL_NORMAL,
                        (LPARAM)NULL);

            DEL_PMYDLGPAGE(hDlg);

            pTVWnd->hWndTV  = NULL;
            pTVWnd->Flags  &= ~TWF_IN_TVPAGE;

            break;
        }
    }

    return(FALSE);

#undef pPSPInfo
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\tvctrl.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    tvctrl.c


Abstract:

    This module contains all procedures to paint the treeview window


Author:

    17-Oct-1995 Tue 16:06:50 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#define DBG_CPSUIFILENAME   DbgTVCtrl


#define DBG_WM_PAINT        0x00000001
#define DBG_DRAWITEM_RECT   0x00000002
#define DBG_DRAWITEM_COLOR  0x00000004
#define DBG_SYS_COLOR       0x00000008
#define DBG_ORIGIN          0x00000010
#define DBG_COMMAND         0x00000020
#define DBG_EDIT_PROC       0x00000040
#define DBG_SCROLL          0x00000080
#define DBG_CYICON          0x00000100
#define DBG_WM_SETFONT      0x00000200
#define DBG_KEYS            0x00000400
#define DBG_CTRLCOLOR       0x00000800


DEFINE_DBGVAR(0);


extern HINSTANCE    hInstDLL;


typedef struct _MYBMPINFO {
    BITMAPINFOHEADER    bh;
    RGBQUAD             clr[2];
    } MYBMPINFO;

#define CY_LINES        9

static const BYTE HLineBits[CY_LINES * 4] = {

        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x55, 0x55, 0x55, 0x55
    };

static const BYTE TLineBits[CY_LINES * 4] = {

        0x00, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x55, 0x55, 0x55, 0x55
    };

static const BITMAPINFOHEADER bhLines = {

        sizeof(BITMAPINFOHEADER),
        CXIMAGE,
        CY_LINES,
        1,
        1,
        BI_RGB,
        ALIGN_DW(CXIMAGE, 24) * CY_LINES,
        0,
        0,
        2,
        2
    };



VOID
DeleteTVFonts(
    PTVWND  pTVWnd
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Aug-1998 Tue 14:05:24 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HDC     hDC;
    HFONT   hFont;

    if ((hDC = pTVWnd->hDCTVWnd)    &&
        (hFont = pTVWnd->hTVFont[0])) {

        SelectObject(hDC, (HANDLE)hFont);

        if (hFont = pTVWnd->hTVFont[1]) {

            DeleteObject(hFont);
            pTVWnd->hTVFont[1] = NULL;
        }

        if (hFont = pTVWnd->hTVFont[2]) {

            DeleteObject(hFont);
            pTVWnd->hTVFont[2] = NULL;
        }

        if (hFont = pTVWnd->hTVFont[3]) {

            DeleteObject(hFont);
            pTVWnd->hTVFont[3] = NULL;
        }
    }
}



BOOL
CreateTVFonts(
    PTVWND  pTVWnd,
    HFONT   hFont
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Aug-1998 Tue 14:04:04 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hWndTV;
    HDC         hDC;


    if ((hWndTV = pTVWnd->hWndTV)   &&
        (hDC = pTVWnd->hDCTVWnd)    &&
        (hFont)) {

        RECT        rc;
        SIZEL       szlText;
        WCHAR       Buf[16];
        LOGFONT     lf;
        TEXTMETRIC  tm;

        DeleteTVFonts(pTVWnd);

        //
        // hTVFont[0] = Regular current treeview font
        //

        pTVWnd->hTVFont[0] = hFont;
        GetObject(hFont, sizeof(lf), &lf);

        //
        // hTVFont[1] = BOLD Font
        //

        lf.lfWeight = FW_BOLD;

        if (!(pTVWnd->hTVFont[1] = CreateFontIndirect(&lf))) {

            CPSUIERR(("CreateFontIndirect(hTVFont[1] BOLD) failed"));

            pTVWnd->hTVFont[1] = hFont;
        }

        //
        // hTVFont[2] = Underline font
        //

        GetObject(hFont, sizeof(lf), &lf);

        lf.lfUnderline = 1;

        if (!(pTVWnd->hTVFont[2] = CreateFontIndirect(&lf))) {

            CPSUIERR(("CreateFontIndirect(hTVFont[2] UnderLine) failed"));

            pTVWnd->hTVFont[2] = hFont;
        }

        //
        // hTVFont[3] = Bold + Underline font
        //

        lf.lfWeight = FW_BOLD;

        if (!(pTVWnd->hTVFont[3] = CreateFontIndirect(&lf))) {

            CPSUIERR(("CreateFontIndirect(hTVFont[3]) failed"));
            pTVWnd->hTVFont[3] = hFont;
        }

        SelectObject(hDC, (HANDLE)pTVWnd->hTVFont[0]);

        Buf[0] = L' ';

        GetTextExtentPoint(hDC, Buf, 1, &szlText);

        pTVWnd->cxSpace  = (WORD)szlText.cx;
        pTVWnd->cxSelAdd = (WORD)((szlText.cx + 1) / 2);

        szlText.cy = (LONG)wsprintf(Buf, L"-88888 ");

        GetTextExtentPoint(hDC, Buf, szlText.cy, &szlText);
        pTVWnd->cxMaxUDEdit = (WORD)szlText.cx;

        GetTextMetrics(hDC, &tm);

        pTVWnd->cxAveChar = (WORD)tm.tmAveCharWidth;

        GetClientRect(hWndTV, &rc);

        pTVWnd->cxExtAdd = (WORD)(tm.tmAveCharWidth + pTVWnd->cxSelAdd);

        CPSUIDBG(DBG_WM_SETFONT, ("CreateTVFonts: 0=%p, 1=%p, 2=%p, 3=%p, Ave=%ld, Space=%ld",
                    pTVWnd->hTVFont[0], pTVWnd->hTVFont[1],
                    pTVWnd->hTVFont[2], pTVWnd->hTVFont[3],
                    pTVWnd->cxAveChar, pTVWnd->cxSpace));

        return(TRUE);

    } else {

        return(FALSE);
    }
}



UINT
DrawTVItems(
    HDC     hDC,
    HWND    hWndTV,
    PTVWND  pTVWnd,
    PRECT   prcUpdate
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    17-Oct-1995 Tue 14:54:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HFONT       hTVFont;
    HFONT       hBoldFont;
    HFONT       hStdFont;
    HFONT       hChgFont;
    HFONT       hOldFont;
    HTREEITEM   hCurItem;
    DWORD       OldTextClr;
    DWORD       OldBkClr;
    DWORD       ClrFill;
    RECT        rcUpdate;
    RECT        rc;
    TV_ITEM     tvi;
    POINTL      ptlOff;
    MYBMPINFO   bi;
    LONG        yIconOff = -1;
    UINT        cUpdate = 0;
    UINT        cxIndent;
    UINT        OldTAMode;
    UINT        OldBkMode;
    INT         yLinesOff;
    DWORD       HLState;
    BOOL        HasFocus;
    WCHAR       Buf[MAX_RES_STR_CHARS * 2 + 10];


    rcUpdate   = *prcUpdate;
    hTVFont    = pTVWnd->hTVFont[0];
    hBoldFont  = pTVWnd->hTVFont[1];
    hStdFont   = pTVWnd->hTVFont[2];
    hChgFont   = pTVWnd->hTVFont[3];
    hOldFont   = SelectObject(hDC, hTVFont);
    cxIndent   = TreeView_GetIndent(hWndTV);
    HasFocus   = (BOOL)(GetFocus() == hWndTV);
    hCurItem   = (pTVWnd->pCurTVItem) ? _OI_HITEM(pTVWnd->pCurTVItem) : NULL;
    OldTextClr = SetTextColor(hDC, RGB(0x00, 0x00, 0x00));
    OldBkClr   = SetBkColor(hDC, RGB(0xFF, 0xFF, 0xFF));
    OldBkMode  = (UINT)SetBkMode(hDC, TRANSPARENT);
    OldTAMode  = (UINT)SetTextAlign(hDC, TA_UPDATECP);
    tvi.mask   = TVIF_CHILDREN          |
                  TVIF_HANDLE           |
                  TVIF_STATE            |
                  TVIF_PARAM            |
                  TVIF_IMAGE            |
                  TVIF_SELECTEDIMAGE    |
                  TVIF_TEXT;
    tvi.hItem  = TreeView_GetFirstVisible(hWndTV);
    HLState    = (DWORD)((TreeView_GetDropHilight(hWndTV)) ? TVIS_DROPHILITED :
                                                             TVIS_SELECTED);

    bi.bh                 = bhLines;
    ClrFill               = GetSysColor(COLOR_WINDOW);
    bi.clr[0].rgbRed      = GetRValue(ClrFill);
    bi.clr[0].rgbGreen    = GetGValue(ClrFill);
    bi.clr[0].rgbBlue     = GetBValue(ClrFill);
    ClrFill               = GetSysColor(COLOR_3DSHADOW);
    bi.clr[1].rgbRed      = GetRValue(ClrFill);
    bi.clr[1].rgbGreen    = GetGValue(ClrFill);
    bi.clr[1].rgbBlue     = GetBValue(ClrFill);

    while (tvi.hItem) {

        tvi.pszText    = Buf;
        tvi.cchTextMax = sizeof(Buf);

        if ((TreeView_GetItemRect(hWndTV, tvi.hItem, &rc, TRUE))    &&
            (rc.left   < rcUpdate.right)                            &&
            (rc.right  > rcUpdate.left)                             &&
            (rc.top    < rcUpdate.bottom)                           &&
            (rc.bottom > rcUpdate.top)                              &&
            (TreeView_GetItem(hWndTV, &tvi))) {

            TVLP        tvlp;
            UINT        cBuf;
            UINT        cName;
            RECT        rcFill;
            DWORD       ClrBk;
            DWORD       ClrName;
            SIZEL       szlText;
            INT         xIcon;
            INT         yIcon;


            rcFill      = rc;
            rcFill.left = rc.right;

            //
            // Draw the Text
            //

            tvlp  = GET_TVLP(tvi.lParam);
            cBuf  = (UINT)lstrlen(Buf);
            cName = (UINT)tvlp.cName;

            SelectObject(hDC, (tvi.state & TVIS_BOLD) ? hBoldFont : hTVFont);
            GetTextExtentPoint(hDC, Buf, cBuf,  &szlText);

            if (yIconOff == -1) {

                yIconOff  = rc.bottom - rc.top;
                //
                // Currently the common control group is drawing the text left aligned, starting at
                // rc.left + GetSystemMetrics(SM_CXEDGE). So we are following the methods
                // in common control to draw the text. Though "guessing" their implementation is 
                // not the best way to do, it's the only solution we can take. Otherwise, we need 
                // to implement all the drawing work for the treeview text, which could be even 
                // worse.
                //
                ptlOff.x  = GetSystemMetrics(SM_CXEDGE);
                ptlOff.y  = (yIconOff - szlText.cy) / 2;
                yIconOff  = (yIconOff - (LONG)pTVWnd->cyImage) / 2;
                yLinesOff = (INT)((pTVWnd->cyImage / 2) + pTVWnd->yLinesOff);

                CPSUIDBG(DBG_CYICON, ("cy=%ld, cyImage=%ld, yIconOff=%ld, yLinesOff=%ld, Indent=%ld",
                        rc.bottom - rc.top, pTVWnd->cyImage, yIconOff,
                        yLinesOff, cxIndent));
            }

            xIcon    = (INT)(rc.left - cxIndent);
            yIcon    = (INT)(rc.top + yIconOff);
            rc.left += ptlOff.x;
            rc.top  += ptlOff.y;

            CPSUIDBG(DBG_DRAWITEM_RECT,
                     ("tvlp=[%04lx] (%ld, %ld)-(%ld, %ld)=%ldx%ld (%ld/%ld) <%ws>",
                        tvlp.Flags, rc.left, rc.top, rc.right, rc.bottom,
                        rc.right - rc.left, rc.bottom - rc.top,
                        cName, cBuf, Buf));

            if (tvi.state & HLState) {

                //
                // Current item is selected
                //

                if (HasFocus) {

                    ClrBk   = COLOR_HIGHLIGHT;
                    ClrName = (tvlp.Flags & TVLPF_DISABLED) ?
                                        COLOR_3DFACE : COLOR_HIGHLIGHTTEXT;

                } else {

                    //
                    // The COLOR_3DFACE is a text background
                    //

                    ClrBk   = COLOR_3DFACE;
                    ClrName = (tvlp.Flags & TVLPF_DISABLED) ? COLOR_3DSHADOW :
                                                              COLOR_BTNTEXT;
                }

            } else {

                //
                // The item is not currently selected
                //

                ClrBk   = COLOR_WINDOW;
                ClrName = (tvlp.Flags & TVLPF_DISABLED) ? COLOR_3DSHADOW :
                                                          COLOR_WINDOWTEXT;
            }

            ClrFill = ClrBk + 1;
            ClrBk   = GetSysColor((UINT)ClrBk);
            ClrName = GetSysColor((UINT)ClrName);

            CPSUIDBG(DBG_SYS_COLOR,
                     ("ClrBk=(%3d,%3d,%3d), ClrName=(%3d,%3d,%3d), State=%08lx/%08lx, Focus=%ld, %ws",
                     GetRValue(ClrBk), GetGValue(ClrBk), GetBValue(ClrBk),
                     GetRValue(ClrName), GetGValue(ClrName), GetBValue(ClrName),
                     tvi.state, HLState, (HasFocus) ? 1 : 0, Buf));

            CPSUIDBG(DBG_DRAWITEM_COLOR,
                     ("COLOR: Item=(%3d,%3d,%3d)",
                     GetRValue(ClrName), GetGValue(ClrName), GetBValue(ClrName)));

            if (cBuf > cName) {

                GetTextExtentPoint(hDC, Buf, cName,  &szlText);
                MoveToEx(hDC, rc.left += szlText.cx, rc.top, NULL);
                SelectObject(hDC, (tvlp.Flags & TVLPF_CHANGEONCE) ? hChgFont :
                                                                    hStdFont);
                GetTextExtentPoint(hDC, &Buf[cName], cBuf - cName, &szlText);

                if ((rcFill.right = rc.left + szlText.cx) > rcFill.left) {

                    FillRect(hDC, &rcFill, (HBRUSH)LongToHandle(ClrFill));
                }

                SetTextColor(hDC, ClrName);
                SetBkColor(hDC, ClrBk);
                SetBkMode(hDC, OPAQUE);
                TextOut(hDC, rc.left, rc.top, &Buf[cName], cBuf - cName);
            }
#if DO_IN_PLACE
            if (tvlp.Flags & TVLPF_EMPTYICON) {
#if DBG
                Buf[cName] = L'\0';
                CPSUIDBG(DBG_CYICON, ("%40ws Lines='%hs'",
                            Buf, ((tvi.cChildren) &&
                                  (tvi.state & TVIS_EXPANDED)) ? "T" : "-"));
#endif
                SetDIBitsToDevice(hDC,
                                  xIcon,
                                  yIcon + yLinesOff,
                                  CXIMAGE,
                                  CY_LINES,
                                  0,
                                  0,
                                  0,
                                  CY_LINES,
                                  ((tvi.cChildren) &&
                                   (tvi.state & TVIS_EXPANDED)) ? TLineBits :
                                                                  HLineBits,
                                  (BITMAPINFO *)&bi,
                                  DIB_RGB_COLORS);
            }
#endif
            if (tvlp.Flags & TVLPF_ECBICON) {

                POPTITEM    pItem;
                PEXTCHKBOX  pECB;

                pItem = GetOptions(pTVWnd, tvi.lParam);
                pECB  = pItem->pExtChkBox;

                ImageList_Draw(pTVWnd->himi,
                               GetIcon16Idx(pTVWnd,
                                            _OI_HINST(pItem),
                                            GET_ICONID(pECB,
                                                       ECBF_ICONID_AS_HICON),
                                            IDI_CPSUI_EMPTY),
                               hDC,
                               xIcon,
                               yIcon,
                               ILD_TRANSPARENT);

            }

            if (tvlp.Flags & TVLPF_STOP) {

                ImageList_Draw(pTVWnd->himi,
                               GetIcon16Idx(pTVWnd, NULL, 0, IDI_CPSUI_STOP),
                               hDC,
                               xIcon,
                               yIcon,
                               ILD_TRANSPARENT);
            }

            if (tvlp.Flags & TVLPF_NO) {

                ImageList_Draw(pTVWnd->himi,
                               GetIcon16Idx(pTVWnd, NULL, 0, IDI_CPSUI_NO),
                               hDC,
                               xIcon,
                               yIcon,
                               ILD_TRANSPARENT);
            }

            if (tvlp.Flags & TVLPF_WARNING) {

                ImageList_Draw(pTVWnd->himi,
                               GetIcon16Idx(pTVWnd,
                                            NULL,
                                            0,
                                            IDI_CPSUI_WARNING_OVERLAY),
                               hDC,
                               xIcon + X_WARNOVLY_ADD,
                               yIcon + Y_WARNOVLY_ADD,
                               ILD_TRANSPARENT);
            }

            ++cUpdate;
        }

        tvi.hItem = TreeView_GetNextVisible(hWndTV, tvi.hItem);
    }

    SelectObject(hDC, hOldFont);
    SetTextColor(hDC, OldTextClr);
    SetBkColor(hDC, OldBkClr);
    SetBkMode(hDC, OldBkMode);
    SetTextAlign(hDC, OldTAMode);

    return(cUpdate);
}


#if 0


LRESULT
CALLBACK
FocusCtrlProc(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    12-Feb-1998 Thu 13:08:24 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PTVWND  pTVWnd;
    HWND    hDlg;
    HWND    hWndTV;
    HWND    hFocus;
    UINT    chWndEdit;
    HWND    hWndEdit[2];
    BOOL    PrevCtrl;
    WNDPROC WndProc;


    if (WndProc = (WNDPROC)GetProp(hWnd, CPSUIPROP_WNDPROC)) {

        switch (Msg) {

        case WM_SETFOCUS:

            if (!wParam) {

                wParam = (WPARAM)GetFocus();
            }

            CPSUIDBG(DBG_EDIT_PROC,
                     ("%ws WM_SETFOCUS, Old=%08lx (%ld)",
                        (GetWindowLongPtr(hWnd, GWLP_ID) == IDD_PRE_EDIT) ?
                            L"PREV" : L"NEXT",
                        wParam, GetWindowLongPtr((HWND)wParam, GWLP_ID)));

            if ((wParam)                                &&
                (hDlg = GetParent(hWnd))                &&
                (pTVWnd = GET_PTVWND(hDlg))             &&
                (chWndEdit = (UINT)pTVWnd->chWndEdit)   &&
                (hWndTV = pTVWnd->hWndTV)) {

                if (hWndEdit[0] = pTVWnd->hWndEdit[0]) {

                    if ((!IsWindowVisible(hWndEdit[0])) ||
                        (!IsWindowEnabled(hWndEdit[0]))) {

                        hWndEdit[0] = NULL;
                    }
                }

                if (hWndEdit[1] = pTVWnd->hWndEdit[1]) {

                    if ((!IsWindowVisible(hWndEdit[1])) ||
                        (!IsWindowEnabled(hWndEdit[1]))) {

                        hWndEdit[1] = NULL;
                    }
                }

                if (PrevCtrl = (BOOL)(GetWindowLongPtr(hWnd, GWLP_ID) ==
                                                            IDD_PRE_EDIT)) {

                    if ((HWND)wParam == hWndTV) {

                        hFocus = NULL;

                    } else if ((HWND)wParam == hWndEdit[1]) {

                        hFocus = hWndEdit[0];

                    } else {

                        hFocus = hWndTV;
                    }

                } else {

                    if ((HWND)wParam == hWndTV) {

                        hFocus = hWndEdit[0];

                    } else if ((HWND)wParam == hWndEdit[0]) {

                        hFocus = hWndEdit[1];

                    } else if ((HWND)wParam == hWndEdit[1]) {

                        hFocus = NULL;

                    } else if (!(hFocus = hWndEdit[1])) {

                        if (!(hFocus = hWndEdit[0])) {

                            hFocus = hWndTV;
                        }
                    }
                }

                if (hFocus) {

                    SetFocus(hFocus);

                } else {

                    if (!(pTVWnd->Flags & TWF_TV_BY_PUSH)) {

                        hDlg = GetParent(hDlg);
                    }

                    PostMessage(hDlg, WM_NEXTDLGCTL, PrevCtrl, 0);
                }

                CPSUIDBG(DBG_EDIT_PROC,
                         ("    %ws WM_SETFOCUS, Old=%08lx (%ld), hWndTV=%08lx, Set to %08lx (%ld)",
                            (PrevCtrl) ? L"PREV" : L"NEXT",
                            wParam, GetWindowLongPtr((HWND)wParam, GWLP_ID),
                            hWndTV, hFocus, GetWindowLongPtr(hFocus, GWLP_ID)));

                return(TRUE);
            }

            break;

        case WM_DESTROY:

            SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LPARAM)WndProc);
            RemoveProp(hWnd, CPSUIPROP_WNDPROC);
            break;

        default:

            break;
        }

        return(CallWindowProc(WndProc, hWnd, Msg, wParam, lParam));
    }

    return(FALSE);
}

#endif


LRESULT
CALLBACK
MyTVWndProc(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    17-Oct-1995 Tue 12:36:19 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hDlg;
    HWND    *phWndEdit;
    HWND    hWndEdit;
    UINT    chWndEdit;
    HDWP    hDWP;
    PTVWND  pTVWnd;
    WNDPROC TVWndProc;
    DWORD   ClrBk;
    DWORD   ClrText;


    if ((hDlg = GetParent(hWnd))    &&
        (pTVWnd = GET_PTVWND(hDlg)) &&
        (TVWndProc = pTVWnd->TVWndProc)) {

        HDC     hDC;
        LRESULT lResult;
        RECT    rcUpdate;

        switch (Msg) {

#if DO_IN_PLACE
        case WM_VSCROLL:
        case WM_HSCROLL:

            CPSUIDBG(DBG_SCROLL, ("MyTVWndProc: WM_%cSCROLL, hScroll=%08lx (%08lx:%08lx:%08lx)=%ld, Pos=%ld, Code=%ld",
                        (Msg == WM_VSCROLL) ? 'V' : 'H',
                        lParam, pTVWnd->hWndEdit[0],
                        pTVWnd->hWndEdit[1], pTVWnd->hWndEdit[2],
                        pTVWnd->chWndEdit, HIWORD(wParam), LOWORD(wParam)));

			chWndEdit = pTVWnd->chWndEdit;
            phWndEdit = pTVWnd->hWndEdit;

            if (lParam) {

                while (chWndEdit--) {

                    if ((HWND)lParam == *phWndEdit++) {

                        PostMessage(hDlg, WM_COMMAND, wParam, lParam);

                        break;
                    }
                }

                return(FALSE);

            }

            break;
#endif
        case WM_COMMAND:

            CPSUIDBG(DBG_COMMAND, ("MyTVWndProc: WM_COMMAND"));

            PostMessage(hDlg, WM_COMMAND, wParam, lParam);

            return(FALSE);

            break;

        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSTATIC:

            switch (GetWindowLongPtr((HWND)lParam, GWLP_ID)) {

            case IDD_TV_CHKBOX:
            case IDD_TV_EXTCHKBOX:

                if (GetFocus() == (HWND)lParam) {

                    CPSUIDBG(DBG_CTRLCOLOR, ("Get WM_CTLCOLOR, HAS FOCUS"));

                    ClrText = (DWORD)COLOR_HIGHLIGHTTEXT;
                    ClrBk   = (DWORD)COLOR_HIGHLIGHT;

                } else {

                    CPSUIDBG(DBG_CTRLCOLOR, ("Get WM_CTLCOLOR, NO FOCUS"));

                    ClrText = COLOR_WINDOWTEXT;
                    ClrBk   = COLOR_WINDOW;
                }

                SetTextColor((HDC)wParam, GetSysColor(ClrText));
                SetBkMode((HDC)wParam, TRANSPARENT);
                return((LRESULT)GetSysColorBrush(ClrBk));

                break;
            }

            break;

        case WM_HELP:
        case WM_CONTEXTMENU:

            PostMessage(hDlg, Msg, wParam, lParam);

            break;

        case WM_SETFONT:

            CPSUIDBG(DBG_WM_SETFONT, ("MyTVWndProc: WM_SETFONT, IGNORE"));
            return(TRUE);

            break;

        case WM_KEYDOWN:

            switch (wParam) {

            case VK_RIGHT:

                if ((pTVWnd->chWndEdit) &&
                    (pTVWnd->hWndEdit[0])) {

                    SetFocus(pTVWnd->hWndEdit[0]);
                    return(0);
                }
            }

        case WM_KEYUP:

            CPSUIDBG(DBG_KEYS, ("MyTVWndProc: WM_KEY%hs: VK=%ld",
                        (Msg == WM_KEYUP) ? "UP" : "DOWN", wParam));

            break;

        case WM_PAINT:
#if DO_IN_PLACE
            if ((pTVWnd->pCurTVItem)                    &&
                (chWndEdit = (UINT)pTVWnd->chWndEdit)   &&
                (TreeView_GetItemRect(hWnd,
                                      _OI_HITEM(pTVWnd->pCurTVItem),
                                      &rcUpdate,
                                      TRUE))            &&
                ((rcUpdate.left != pTVWnd->ptCur.x) ||
                 (rcUpdate.top != pTVWnd->ptCur.y))     &&
                (hDWP = BeginDeferWindowPos(chWndEdit))) {

                POINTL  pt;

                phWndEdit = pTVWnd->hWndEdit;

                CPSUIDBG(DBG_ORIGIN, ("CurTVItem=Moved (%08lx:%08lx:%08lx)From (%4ld, %4ld) ---> (%4ld, %4ld)",
                                pTVWnd->hWndEdit[0],
                                pTVWnd->hWndEdit[1], pTVWnd->hWndEdit[2],
                                pTVWnd->ptCur.x, pTVWnd->ptCur.y,
                                rcUpdate.left, rcUpdate.top));

                pt.x            = rcUpdate.left - pTVWnd->ptCur.x;
                pt.y            = rcUpdate.top - pTVWnd->ptCur.y;
                pTVWnd->ptCur.x = rcUpdate.left;
                pTVWnd->ptCur.y = rcUpdate.top;

                while ((chWndEdit--) && (hDWP)) {

                    if (hWndEdit = *phWndEdit++) {

                        GetWindowRect(hWndEdit, &rcUpdate);

                        rcUpdate.left   += pt.x;
                        rcUpdate.top    += pt.y;
                        rcUpdate.right  += pt.x;
                        rcUpdate.bottom += pt.y;

                        MapWindowPoints(NULL, hWnd, (LPPOINT)&rcUpdate, 2);

                        hDWP = DeferWindowPos(hDWP, hWndEdit, NULL,
                                              rcUpdate.left, rcUpdate.top, 0, 0,
                                              SWP_DRAWFRAME     |
                                              SWP_FRAMECHANGED  |
                                                SWP_NOSIZE      |
                                                SWP_NOZORDER);
                    }
                }

                if (hDWP) {

                    EndDeferWindowPos(hDWP);
                }
            }
#endif
            GetUpdateRect(hWnd, &rcUpdate, FALSE);

            lResult = CallWindowProc(TVWndProc, hWnd, Msg, wParam, lParam);

            CPSUIDBG(DBG_WM_PAINT,
                     ("\n!! Update Rect = (%ld, %ld)-(%ld, %ld) = %ld x %ld\n\n",
                        rcUpdate.left, rcUpdate.top,
                        rcUpdate.right, rcUpdate.bottom,
                        rcUpdate.right - rcUpdate.left,
                        rcUpdate.bottom - rcUpdate.top));

            if (hDC = GetDC(hWnd)) {

                IntersectClipRect(hDC,
                                  rcUpdate.left,
                                  rcUpdate.top,
                                  rcUpdate.right,
                                  rcUpdate.bottom);

                DrawTVItems(hDC, hWnd, pTVWnd, &rcUpdate);
                ReleaseDC(hWnd, hDC);

            } else {

                CPSUIERR(("MyTVWndProc: GetDC(%08lx) FAILED", hWnd));
            }

            return(lResult);

        default:

            break;
        }

        return(CallWindowProc(TVWndProc, hWnd, Msg, wParam, lParam));

    } else {

        CPSUIERR(("MyTVWndProc: hDlg=%08lx, pTVWnd=%08lx, TVWndProc=%08lx",
                    hDlg, pTVWnd, TVWndProc));

        return(TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\validate.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    validate.c


Abstract:

    This module contains the function to validate all optitem


Author:

    05-Sep-1995 Tue 18:42:44 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#define DBG_CPSUIFILENAME   DbgValidate


#define DBG_VALIDATE        0x00000001
#define DBGITEM_VALIDATE    0x00000002
#define DBG_CLEANUP         0x00000004
#define DBG_ALLOCEDIT       0x00000008
#define DBG_DMPUBHIDE       0x00000010

DEFINE_DBGVAR(0);


#if DBG

static const LPSTR  pszDMPub[] = { "DMPUB_ORIENTATION",
                                   "DMPUB_SCALE",
                                   "DMPUB_COPIES_COLLATE",
                                   "DMPUB_DEFSOURCE",
                                   "DMPUB_PRINTQUALITY",
                                   "DMPUB_COLOR",
                                   "DMPUB_DUPLEX",
                                   "DMPUB_TTOPTION",
                                   "DMPUB_FORMNAME",
                                   "DMPUB_ICMMETHOD",
                                   "DMPUB_ICMINTENT",
                                   "DMPUB_MEDIATYPE",
                                   "DMPUB_DITHERTYPE",
                                   "DMPUB_OUTPUTBIN",
                                   "DMPUB_QUALITY",
                                   "DMPUB_NUP",
                                   "DMPUB_PAGEORDER"
                                };

#endif

extern HINSTANCE    hInstDLL;
extern OPTTYPE      OptTypeHdrPush;





LONG
ValidateChildrenItems(
    PTVWND      pTVWnd,
    POPTITEM    *ppItem,
    DWORD       DMPubHideBits,
    DWORD       ParentFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    05-Sep-1995 Tue 18:43:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    POPTITEM    pItem;
    POPTITEM    pNext;
    POPTITEM    pLastItem;
    LONG        cGroup = 1;
    DWORD       Flags;
    BYTE        DMPubID;
    BYTE        DlgPageIdx;
    BYTE        CurLevel;


    pNext     =
    pItem     = *ppItem;
    CurLevel  = pItem->Level;
    pLastItem = pTVWnd->pLastItem;
    Flags     = (ParentFlags &= OPTIF_ITEM_HIDE);

    while ((cGroup >= 0)        &&
           (pItem <= pLastItem) &&
           (pItem->Level >= CurLevel)) {

        CPSUIASSERT(0, "pItem != pNext", pItem == pNext, 0);

        if (pItem->Level > CurLevel) {

            cGroup = ValidateChildrenItems(pTVWnd, &pItem, DMPubHideBits, Flags);
            pNext  = pItem;
            continue;
        }

        DlgPageIdx = pItem->DlgPageIdx;
        DMPubID    = pItem->DMPubID;
        Flags      = pItem->Flags;

        if ((DMPubHideBits)             &&
            (DMPubID >= DMPUB_FIRST)    &&
            (DMPubID <= DMPUB_LAST)     &&
            (MAKE_DMPUB_HIDEBIT(DMPubID) & DMPubHideBits)) {

            Flags |= OPTIF_INT_HIDE;

            CPSUIDBG(DBG_DMPUBHIDE, ("Hide DMPUB_ID=%hs, Bits=%08lx (%08lx)",
                        pszDMPub[DMPubID - DMPUB_FIRST],
                        MAKE_DMPUB_HIDEBIT(DMPubID), DMPubHideBits));

        } else {

            Flags &= ~OPTIF_INT_HIDE;
        }

        {

            POPTTYPE    pOptType;
            POPTPARAM   pOptParam = NULL;
            PEXTCHKBOX  pECB;
            INT         Count;
            INT         IconCount;
            INT         cNotHide;
            BYTE        Mask;
            BYTE        HideBits;
            LONG        MinSel;
            LONG        MaxSel;
            BYTE        Type;
            BOOL        pDefSelIsMem;


            Flags |= ParentFlags;

            CPSUIOPTITEM(DBGITEM_VALIDATE, pTVWnd, "Validate", 2, pItem);

            if (pItem->cbSize != sizeof(OPTITEM)) {

                return(ERR_CPSUI_INVALID_OPTITEM_CBSIZE);
            }

            //
            // clear the unused flags
            //

            pItem->Flags &= (OPTIF_MASK ^ OPTIF_ENTER_MASK);

            if ((Flags & OPTIF_HIDE) && (!(pItem->Flags & OPTIF_HIDE))) {

                return(ERR_CPSUI_SUBITEM_DIFF_OPTIF_HIDE);
            }

            if (Flags & OPTIF_INT_HIDE) {

                pItem->Flags |= OPTIF_INT_HIDE;
            }

            if (!(pItem->Flags & OPTIF_ITEM_HIDE)) {

                if (pOptType = pItem->pOptType) {

                    //
                    // Validate OPTTYPE
                    //

                    if (pOptType->cbSize != sizeof(OPTTYPE)) {

                        return(ERR_CPSUI_INVALID_OPTTYPE_CBSIZE);
                    }

                    IconCount = 1;

                    switch (Type = pOptType->Type) {

                    case TVOT_CHKBOX:
                    case TVOT_PUSHBUTTON:

                        Count = 1;
                        break;

                    case TVOT_2STATES:

                        IconCount = 2;

                    case TVOT_EDITBOX:
                    case TVOT_UDARROW:

                        Count = 2;

                        break;

                    case TVOT_3STATES:

                        IconCount = 3;

                        //
                        // Fall through
                        //

                    case TVOT_TRACKBAR:
                    case TVOT_SCROLLBAR:

                        Count = 3;
                        break;

                    case TVOT_LISTBOX:
                    case TVOT_COMBOBOX:

                        IconCount =
                        Count     = (INT)pOptType->Count;
                        break;

                    default:

                        return(ERR_CPSUI_INVALID_TVOT_TYPE);
                    }

                    if (pOptType->Count != (WORD)Count) {

                        return(ERR_CPSUI_INVALID_OPTTYPE_COUNT);
                    }

                    //
                    // Validate OPTPARAM
                    //

                    if (pOptParam = pOptType->pOptParam) {

                        cNotHide = Count;
                        HideBits = 0;
                        Mask     = 0x01;

                        while (Count--) {

                            if (pOptParam->cbSize != sizeof(OPTPARAM)) {

                                return(ERR_CPSUI_INVALID_OPTPARAM_CBSIZE);
                            }

                            if (pOptParam->Flags & OPTPF_HIDE) {

                                cNotHide--;
                                HideBits |= Mask;
                            }

                            Mask <<= 1;
                            pOptParam++;
                        }

                    } else {

                        return(ERR_CPSUI_NULL_POPTPARAM);
                    }

                    pOptParam = pOptType->pOptParam;

                    //
                    // for TVOT_2STATES, TVOT_3STATES, TVOT_LISTBOX and
                    // TVOT_COMBOBOX, if all selection are hided then we will
                    // hide this item
                    //

                    switch (Type) {

                    case TVOT_PUSHBUTTON:

                        switch (pOptParam->Style) {

                        case PUSHBUTTON_TYPE_HTSETUP:

                            _OI_HELPIDX(pItem)  = IDH_HT_SETUP;
                            pOptType->Flags    |= OTS_PUSH_ENABLE_ALWAYS;
                            break;

                        case PUSHBUTTON_TYPE_HTCLRADJ:

                            _OI_HELPIDX(pItem)  = IDH_HT_CLRADJ;
                            pOptType->Flags    |= OTS_PUSH_ENABLE_ALWAYS;
                            break;

                        case PUSHBUTTON_TYPE_DLGPROC:
                        case PUSHBUTTON_TYPE_CALLBACK:

                            break;

                        default:

                            return(ERR_CPSUI_INVALID_PUSHBUTTON_TYPE);
                        }

                        break;

                    case TVOT_3STATES:
                    case TVOT_2STATES:

                        _OT_FLAGS(pOptType) |= (WORD)HideBits;

                        CPSUIINT(("States Type=%d, HideBits=0x%02x",
                                    (UINT)pOptType->Type, (UINT)HideBits));

                    case TVOT_LISTBOX:
                    case TVOT_COMBOBOX:

                        if (!cNotHide) {

                            CPSUIWARN(("Type=%ld, all OPTPARAMs are OPTPF_HIDE, hide the item"));

                            pItem->Flags |= OPTIF_INT_HIDE;
                            Flags        |= OPTIF_INT_HIDE;
                        }

                        break;

                    default:

                        break;
                    }

                    //
                    // Validate pSel
                    //
                    // 19-May-1998 Tue 16:38:35 updated
                    //                              -by-  Daniel Chou (danielc)
                    //  We allocate (memory * 2) because for new IN PLACE
                    //  treeview editing, we need to save another of undo
                    //

                    MinSel               = 0;
                    MaxSel               = -1;
                    pDefSelIsMem         = FALSE;
                    _OI_CBPDEFSEL(pItem) = (WORD)0;

                    switch (Type) {

                    case TVOT_CHKBOX:
                    case TVOT_2STATES:

                        MaxSel = 1;
                        break;

                    case TVOT_UDARROW:
                    case TVOT_TRACKBAR:
                    case TVOT_SCROLLBAR:

                        MinSel = (LONG)((SHORT)pOptParam[1].IconID);
                        MaxSel = (LONG)((SHORT)pOptParam[1].lParam);

                        if (MinSel > MaxSel) {

                            pOptParam[1].IconID = MaxSel;
                            pOptParam[1].lParam = MinSel;

                            CPSUIWARN(("Type=%d, Swap select range (%d - %d)",
                                                       Type, MinSel, MaxSel));

                            MinSel = MaxSel;
                            MaxSel = (LONG)((SHORT)pOptParam[1].lParam);
                        }

                        if (Type != TVOT_UDARROW) {

                            //
                            // This is the multiple factor
                            //

                            if (!pOptParam[2].IconID) {

                                pOptParam[2].IconID = 1;
                            }

                            if (!pOptParam[2].lParam) {

                                pOptParam[2].lParam = 1;
                            }
                        }

                        break;

                    case TVOT_3STATES:

                        MaxSel = 2;
                        break;

                    case TVOT_LISTBOX:
                    case TVOT_COMBOBOX:

                        if (pOptType->Style & OTS_LBCB_INCL_ITEM_NONE) {

                            MinSel = -1;

                            if (pItem->Sel < 0) {

                                pItem->Sel = -1;
                            }
                        }

                        MaxSel = (LONG)((LONG)pOptType->Count - 1);
                        break;

                    case TVOT_PUSHBUTTON:

                        switch (pOptParam->Style) {

                        case PUSHBUTTON_TYPE_HTSETUP:

                            if (_OI_PDEFSEL(pItem) = (LPVOID)
                                            LocalAlloc(LPTR,
                                                       sizeof(DEVHTINFO) * 2)) {

                                PDEVHTADJDATA   pDevHTAdjData;

                                pDefSelIsMem = TRUE;
                                _OI_CBPDEFSEL(pItem) = (WORD)sizeof(DEVHTINFO);
                                pDevHTAdjData =
                                        (PDEVHTADJDATA)(pOptParam->pData);

                                CopyMemory(_OI_PDEFSEL(pItem),
                                           pDevHTAdjData->pAdjHTInfo,
                                           sizeof(DEVHTINFO));

                            } else {

                                CPSUIERR(("LocalAlloc(HTSETUP/DEVHTINFO) failed"));
                                return(ERR_CPSUI_ALLOCMEM_FAILED);
                            }

                            break;

                        case PUSHBUTTON_TYPE_HTCLRADJ:

                            if (_OI_PDEFSEL(pItem) = (LPVOID)
                                    LocalAlloc(LPTR,
                                               sizeof(COLORADJUSTMENT) * 2)) {

                                pDefSelIsMem = TRUE;
                                _OI_CBPDEFSEL(pItem) =
                                                (WORD)sizeof(COLORADJUSTMENT);

                                CopyMemory(_OI_PDEFSEL(pItem),
                                           pOptParam->pData,
                                           sizeof(COLORADJUSTMENT));

                            } else {

                                CPSUIERR(("LocalAlloc(HTCLRADJ/COLORADJUSTMENT) failed"));
                                return(ERR_CPSUI_ALLOCMEM_FAILED);
                            }

                            break;
                        }

                        break;

                    case TVOT_EDITBOX:

                        if ((!pItem->pSel) || (!VALID_PTR(pItem->pSel))) {

                            return(ERR_CPSUI_INVALID_EDITBOX_PSEL);
                        }

                        if ((MaxSel = (LONG)pOptParam[1].IconID) <= 1) {

                            return(ERR_CPSUI_INVALID_EDITBOX_BUF_SIZE);

                        } else {

                            --MaxSel;

                            if (pTVWnd->Flags & TWF_ANSI_CALL) {

                                MinSel = lstrlenA((LPSTR)pItem->pSel);

                                if (MinSel > MaxSel) {

                                    ((LPSTR)pItem->pSel)[MaxSel] = 0;
                                }

                                MaxSel++;

                            } else {

                                MinSel = lstrlenW((LPWSTR)pItem->pSel);

                                if (MinSel > MaxSel) {

                                    ((LPWSTR)pItem->pSel)[MaxSel] = 0;
                                }

                                MaxSel = (LONG)((DWORD)(MaxSel + 1) << 1);
                            }

                            if (_OI_PDEFSEL(pItem) =
                                        (LPVOID)LocalAlloc(LPTR, MaxSel * 2)) {

                                pDefSelIsMem = TRUE;
                                _OI_CBPDEFSEL(pItem) = (WORD)MaxSel;

                                CopyMemory(_OI_PDEFSEL(pItem),
                                           pItem->pSel,
                                           MaxSel);

                            } else {

                                CPSUIERR(("LocalAlloc(EditBuf=%ld bytes) failed", MaxSel));
                                return(ERR_CPSUI_ALLOCMEM_FAILED);
                            }
                        }

                        //
                        // Fall through
                        //

                    default:

                        MinSel = 0;
                        MaxSel = -1;
                        break;
                    }

                    if ((MinSel < MaxSel) &&
                        ((pItem->Sel < MinSel) ||
                         (pItem->Sel > MaxSel))) {

                        CPSUIWARN(("Sel=%ld (%08lx) Out of range (%ld - %ld)",
                                pItem->Sel, pItem->pSel,  MinSel, MaxSel));

                        pItem->Flags |= OPTIF_CHANGED;
                        pItem->Sel    = MinSel;
                    }

                    //
                    // Saved old selection
                    //

                    if (!pDefSelIsMem) {

                        _OI_PDEFSEL(pItem) = pItem->pSel;
                    }

                    _OI_DEF_OPTIF(pItem) = pItem->Flags;

                    //
                    // Validate pExtChkBox
                    //

                    if ((pECB = pItem->pExtChkBox) &&
                        (!(pItem->Flags & OPTIF_EXT_HIDE))) {

                        if (pItem->Flags & OPTIF_EXT_IS_EXTPUSH) {

                            PEXTPUSH    pEP = (PEXTPUSH)pECB;


                            if (pEP->cbSize != sizeof(EXTPUSH)) {

                                return(ERR_CPSUI_INVALID_EXTPUSH_CBSIZE);
                            }

                            if (pEP->Flags & EPF_PUSH_TYPE_DLGPROC) {

                                if (!(pEP->DlgProc)) {

                                    return(ERR_CPSUI_NULL_EXTPUSH_DLGPROC);
                                }

                                if (((pEP->Flags & EPF_USE_HDLGTEMPLATE) &&
                                     (pEP->hDlgTemplate == NULL))   ||
                                    (pEP->DlgTemplateID == 0)) {

                                    return(ERR_CPSUI_NO_EXTPUSH_DLGTEMPLATEID);
                                }


                            } else {

                                if ((!(pEP->pfnCallBack))   &&
                                    (!(pTVWnd->ComPropSheetUI.pfnCallBack))) {

                                    return(ERR_CPSUI_NULL_EXTPUSH_CALLBACK);
                                }
                            }

                        } else {

                            CPSUIDBG(DBG_VALIDATE, ("ExtChkBox: cbSize=%u [%u]",
                                    pECB->cbSize, sizeof(EXTCHKBOX)));

                            if (pECB->cbSize != sizeof(EXTCHKBOX)) {

                                return(ERR_CPSUI_INVALID_ECB_CBSIZE);
                            }

                            if (!(pECB->pTitle)) {

                                return(ERR_CPSUI_NULL_ECB_PTITLE);
                            }

                            if (!(pECB->pCheckedName)) {

                                return(ERR_CPSUI_NULL_ECB_PCHECKEDNAME);
                            }
                        }
                    }
                }

                //
                // Validate DMPubID
                //

                if ((DMPubID < DMPUB_OEM_PAPER_ITEM)    &&
                    (DMPubID != DMPUB_NONE)             &&
                    (pItem->DMPubID != DMPubID)) {

                    return(ERR_CPSUI_INVALID_DMPUBID);
                }

                //
                // Validate DlgPageIdx
                //

                if (pItem->DlgPageIdx != DlgPageIdx) {

                    return(ERR_CPSUI_SUBITEM_DIFF_DLGPAGEIDX);
                }

                if (DlgPageIdx >= pTVWnd->cMyDlgPage) {

                    return(ERR_CPSUI_INVALID_DLGPAGEIDX);
                }

                if (pItem->Flags & OPTIF_CHANGED) {

                    CPSUIOPTITEM(0,pTVWnd, "Validate: OPTIF_CHANGED", 2, pItem);
                }
            }
        }

        pNext = ++pItem;
    }

    CPSUIASSERT(0, "pItem != *ppItem", pItem != *ppItem, 0);

    *ppItem = pItem;

    return(cGroup);
}




LONG
ValidatepOptItem(
    PTVWND  pTVWnd,
    DWORD   DMPubHideBits
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    05-Sep-1995 Tue 18:43:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    POPTITEM    pItem;


    pItem = pTVWnd->ComPropSheetUI.pOptItem;

    return(ValidateChildrenItems(pTVWnd, &pItem, DMPubHideBits, 0));
}



UINT
SetOptItemNewDef(
    HWND    hDlg,
    PTVWND  pTVWnd,
    BOOL    DoDef2
    )

/*++

Routine Description:

    This function set the new default for the OptItems


Arguments:




Return Value:




Author:

    02-Feb-1996 Fri 22:07:59 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    POPTITEM    pItem;
    POPTITEM    pLastItem;
    POPTTYPE    pOptType;
    LPVOID      pvAlloc;
    LPBYTE      pDefSel;
    UINT        cSet = 0;

    pItem     = pTVWnd->ComPropSheetUI.pOptItem;
    pLastItem = pTVWnd->pLastItem;

    while (pItem <= pLastItem) {

        if ((pOptType = pItem->pOptType)        &&
            (!(pItem->Flags & OPTIF_ITEM_HIDE)) &&
            ((DoDef2) || (pItem->Flags & (OPTIF_CHANGEONCE|OPTIF_CHANGED)))) {

            PDEVHTADJDATA   pDevHTAdjData;

            ++cSet;

            pvAlloc = (LPVOID)(pDefSel = (LPBYTE)_OI_PDEFSEL(pItem));

            if (DoDef2) {

                pDefSel += _OI_CBPDEFSEL(pItem);

            } else {

                pItem->Flags |= OPTIF_CHANGED;
            }

            switch (pOptType->Type) {

            case TVOT_EDITBOX:

                if (!pvAlloc) {

                    CPSUIASSERT(0, "SetOptItemNewDef(EDITBOX:pvAlloc=NULL)", pvAlloc, 0);
                    break;
                }

                if (pTVWnd->Flags & TWF_ANSI_CALL) {

                    lstrcpyA((LPSTR)pDefSel, (LPSTR)pItem->pSel);

                } else {

                    lstrcpy((LPWSTR)pDefSel, (LPWSTR)pItem->pSel);
                }

                break;

            case TVOT_PUSHBUTTON:

                switch (pOptType->pOptParam->Style) {

                case PUSHBUTTON_TYPE_HTSETUP:

                    if (!pvAlloc) {

                        CPSUIASSERT(0, "SetOptItemNewDef(HTSETUP:pvAlloc=NULL)", pvAlloc, 0);
                        break;
                    }

                    pDevHTAdjData = (PDEVHTADJDATA)(pOptType->pOptParam->pData);

                    CopyMemory(pDefSel,
                               pDevHTAdjData->pAdjHTInfo,
                               sizeof(DEVHTINFO));

                    break;

                case PUSHBUTTON_TYPE_HTCLRADJ:

                    if (!pvAlloc) {

                        CPSUIASSERT(0, "SetOptItemNewDef(HTCLRADJ:pvAlloc=NULL)", pvAlloc, 0);
                        break;
                    }

                    CopyMemory(pDefSel,
                               pOptType->pOptParam->pData,
                               sizeof(COLORADJUSTMENT));

                    break;

                default:

                    if (DoDef2) {

                        _OI_PDEFSEL2(pItem) = pItem->pSel;

                    } else {

                        _OI_PDEFSEL(pItem) = pItem->pSel;
                    }

                    break;
                }

                break;

            default:

                if (DoDef2) {

                    _OI_PDEFSEL2(pItem) = pItem->pSel;

                } else {

                    pItem->Flags       &= ~OPTIF_CHANGEONCE;
                    _OI_PDEFSEL(pItem)  = pItem->pSel;
                }

                break;
            }

            if (DoDef2) {

                _OI_DEF_OPTIF2(pItem) = pItem->Flags;

            } else {

                _OI_DEF_OPTIF(pItem) = pItem->Flags;
            }
        }

        pItem++;
    }

    if ((cSet) && (!DoDef2)) {

        UpdateCallBackChanges(hDlg, pTVWnd, TRUE);
        UpdateTreeViewItem(hDlg, pTVWnd, pTVWnd->pCurTVItem, TRUE);
    }

    return(cSet);
}



BOOL
CleanUpTVWND(
    PTVWND  pTVWnd
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    05-Sep-1995 Tue 19:41:45 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PMYDLGPAGE  pMyDP;
    POPTITEM    pItem;
    UINT        cItem;


    pItem = pTVWnd->ComPropSheetUI.pOptItem;
    cItem = (UINT)pTVWnd->ComPropSheetUI.cOptItem;

    while (cItem--) {

        POPTTYPE    pOptType;
        LPVOID      pDefSel;

        pItem->Flags &= (OPTIF_MASK ^ OPTIF_EXIT_MASK);
        pDefSel       = _OI_PDEFSEL(pItem);
        pOptType      = pItem->pOptType;

        if (pOptType) {

            switch (pOptType->Type) {

            case TVOT_PUSHBUTTON:

                switch (pOptType->pOptParam->Style) {

                case PUSHBUTTON_TYPE_HTSETUP:
                case PUSHBUTTON_TYPE_HTCLRADJ:

                    if (pDefSel) {

                        CPSUIOPTITEM(DBG_CLEANUP, pTVWnd, "Free Halftone pointer", 1, pItem);

                        LocalFree((HLOCAL)pDefSel);
                    }
                }

                break;

            case TVOT_EDITBOX:

                if (pDefSel) {

                    CPSUIOPTITEM(DBG_CLEANUP, pTVWnd, "Free EditBuf", 1, pItem);

                    LocalFree((HLOCAL)pDefSel);
                }

                break;
            }

            ZeroMemory(&pOptType->wReserved[0],
                       sizeof(OPTTYPE) - FIELD_OFFSET(OPTTYPE, wReserved));
        }

        pItem->wReserved = 0;

        ZeroMemory(&pItem->dwReserved[0],
                   sizeof(OPTITEM) - FIELD_OFFSET(OPTITEM, dwReserved));


        pItem++;
    }

    if (pMyDP = pTVWnd->pMyDlgPage) {

        UINT    cMyDP = pTVWnd->cMyDlgPage;

        while (cMyDP--) {

            if (pMyDP->hIcon) {

                DestroyIcon(pMyDP->hIcon);
            }

            pMyDP++;
        }

        LocalFree((HLOCAL)pTVWnd->pMyDlgPage);
        pTVWnd->pMyDlgPage = NULL;
    }

    if (pTVWnd->pIcon16ID) {

        LocalFree((HLOCAL)pTVWnd->pIcon16ID);
        pTVWnd->pIcon16ID = NULL;
    }

    if (pTVWnd->himi) {

        ImageList_Destroy(pTVWnd->himi);
        pTVWnd->himi = NULL;
    }

#if 0
    if (pTVWnd->hbrGray) {

        DeleteObject(pTVWnd->hbrGray);
        pTVWnd->hbrGray = NULL;
    }

    if (pTVWnd->hbmGray) {

        DeleteObject(pTVWnd->hbmGray);
        pTVWnd->hbmGray = NULL;
    }
#endif

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\validate.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    validate.h


Abstract:

    This module contains validatation defintions


Author:

    05-Sep-1995 Tue 19:30:34 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/



LONG
ValidatepOptItem(
    PTVWND  pTVWnd,
    DWORD   DMPubHideBits
    );

UINT
SetOptItemNewDef(
    HWND    hDlg,
    PTVWND  pTVWnd,
    BOOL    DoDef2
    );

BOOL
CleanUpTVWND(
    PTVWND  pTVWnd
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\sample\cpsuidat.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation
All Rights Reserved


Module Name:

    cpsuidat.h


Abstract:

    This module


[Environment:]

    NT Windows - Common Printer Driver UI DLL


--*/


#define COUNT_ARRAY(a)                  (sizeof(a) / sizeof((a)[0]))


#define OPTIF_NONE                      0

#define LEVEL_0                         0
#define LEVEL_1                         1
#define LEVEL_2                         2
#define LEVEL_3                         3
#define LEVEL_4                         4


#define DMPUB_TVTEST                    (DMPUB_USER +  1)
#define DMPUB_TVOPT                     (DMPUB_USER +  2)
#define DMPUB_TVOPT_ECB_EP              (DMPUB_USER +  3)
#define DMPUB_TVOPT_ICONS               (DMPUB_USER +  4)
#define DMPUB_TVOPT_DISABLED            (DMPUB_USER +  5)
#define DMPUB_TVOPT_TEST                (DMPUB_USER +  6)
#define DMPUB_2STATES                   (DMPUB_USER +  7)
#define DMPUB_3STATES                   (DMPUB_USER +  8)
#define DMPUB_UDARROW                   (DMPUB_USER +  9)
#define DMPUB_TRACKBAR                  (DMPUB_USER + 10)
#define DMPUB_SCROLLBAR                 (DMPUB_USER + 11)
#define DMPUB_LISTBOX                   (DMPUB_USER + 12)
#define DMPUB_COMBOBOX                  (DMPUB_USER + 13)
#define DMPUB_EDITBOX                   (DMPUB_USER + 14)
#define DMPUB_PUSHBUTTON                (DMPUB_USER + 15)
#define DMPUB_CHKBOX                    (DMPUB_USER + 16)
#define DMPUB_CHKBOX_TYPE               (DMPUB_USER + 17)
#define DMPUB_TVOPT_OVERLAY_WARNING     (DMPUB_USER + 18)
#define DMPUB_TVOPT_OVERLAY_STOP        (DMPUB_USER + 19)
#define DMPUB_TVOPT_OVERLAY_NO          (DMPUB_USER + 20)
#define DMPUB_EXT_OVERLAY_WARNING       (DMPUB_USER + 21)
#define DMPUB_EXT_OVERLAY_STOP          (DMPUB_USER + 22)
#define DMPUB_EXT_OVERLAY_NO            (DMPUB_USER + 23)
#define DMPUB_EXT_DISABLED              (DMPUB_USER + 24)
#define DMPUB_MINRANGE                  (DMPUB_USER + 25)
#define DMPUB_MAXRANGE                  (DMPUB_USER + 26)

#define MAX_INT                         0x00007fff
#define MIN_INT                         0xFFFF8000



BOOL
SetupComPropSheetUI
(
    PCOMPROPSHEETUI pCPSUI
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\sample\cpsuidat.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation
All Rights Reserved


Module Name:

    cpsuidat.c


Abstract:

    This module contains all the predefined data


--*/


#include "precomp.h"
#pragma hdrstop

#define DBG_CPSUIFILENAME   DbgTVPage



#define DBG_TVTESTCB        0x00000001
#define DBG_PUSHDLGPROC     0x00000002

DEFINE_DBGVAR(0);

#define ARRAYSIZE(x)        (sizeof(x)/sizeof(x[0]))


HINSTANCE   hInstApp = NULL;

TCHAR   TitleName[]       = TEXT("Common Property Sheet UI Sample");
TCHAR   ClassName[]       = TEXT("CPSUISampleClass");
TCHAR   MenuName[]        = TEXT("CPSUISampleMenu");
TCHAR   OptItemName[]     = TEXT("CPSUI TreeView Sample");
TCHAR   szWinSpool[]      = TEXT("WinSpool.Drv");
CHAR    szDocPropSheets[] = "DocumentPropertySheets";

BOOL    UpdatePermission = TRUE;
BOOL    UseStdAbout      = TRUE;


BOOL
APIENTRY
PushButtonProc(
    HWND    hDlg,
    UINT    Msg,
    UINT    wParam,
    LONG    lParam
    );

CPSUICALLBACK
TVTestCallBack(
    PCPSUICBPARAM   pCPSUICBParam
    );


OPTPARAM    NoYesOP[] = {

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        (LPTSTR)IDS_CPSUI_NO,                   // pData
        IDI_CPSUI_NO,                           // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        (LPTSTR)IDS_CPSUI_YES,                  // pData
        IDI_CPSUI_YES,                          // IconID
        1                                       // lParam
    }
};

EXTCHKBOX   ECB_EP_ECB = {

        sizeof(EXTCHKBOX),
        0,
        TEXT("Include Icon"),
        (LPTSTR)IDS_CPSUI_SLASH_SEP,
        TEXT("Icon"),
        IDI_CPSUI_GRAPHIC };


OPTPARAM    ECB_EP_OP[] = {

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("None"),                           // pData
        IDI_CPSUI_EMPTY,                        // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("Extended CheckBox"),              // pData
        IDI_CPSUI_EMPTY,                        // IconID
        1                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("Extended Push"),                  // pData
        IDI_CPSUI_EMPTY,                        // IconID
        0                                       // lParam
    }
};


OPTTYPE ECB_EP_OT = {

        sizeof(OPTTYPE),                        // cbSize
        TVOT_3STATES,                           // Type
        0,                                      // Flags OPTTF_xxxx
        3,                                      // Count
        0,                                      // BegCtrlID
        ECB_EP_OP,                              // pOptParam
        0                                       // Style, OTS_xxxx
    };

OPTTYPE NoYesOT = {

        sizeof(OPTTYPE),                        // cbSize
        TVOT_2STATES,                           // Type
        0,                                      // Flags OPTTF_xxxx
        2,                                      // Count
        0,                                      // BegCtrlID
        NoYesOP,                                // pOptParam
        0                                       // Style, OTS_xxxx
    };

OPTPARAM    TVOT3StatesOP[] = {

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("States 1"),                       // pData
        IDI_CPSUI_PORTRAIT,                     // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("States 2"),                       // pData
        IDI_CPSUI_LANDSCAPE,                    // IconID
        1                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("States 3"),                       // pData
        IDI_CPSUI_ROT_LAND,                     // IconID
        0                                       // lParam
    }
};

OPTTYPE TVOT2StatesOT = {

        sizeof(OPTTYPE),                        // cbSize
        TVOT_2STATES,                           // Type
        0,                                      // Flags OPTTF_xxxx
        2,                                      // Count
        0,                                      // BegCtrlID
        TVOT3StatesOP,                          // pOptParam
        0                                       // Style, OTS_xxxx
    };

OPTTYPE TVOT3StatesOT = {

        sizeof(OPTTYPE),                        // cbSize
        TVOT_3STATES,                           // Type
        0,                                      // Flags OPTTF_xxxx
        3,                                      // Count
        0,                                      // BegCtrlID
        TVOT3StatesOP,                          // pOptParam
        0                                       // Style, OTS_xxxx
    };

OPTPARAM    MinRangeOP[] = {

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT(""),                               // pData (postfix)
        IDI_CPSUI_EMPTY,                        // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        NULL,                                   // pData (help line)
        (DWORD)MIN_INT,                         // IconID
        MAX_INT                                 // lParam
    }
};

OPTTYPE MinRangeOT = {

        sizeof(OPTTYPE),                        // cbSize
        TVOT_UDARROW,                           // Type
        0,                                      // Flags OPTTF_xxxx
        2,                                      // Count
        0,                                      // BegCtrlID
        MinRangeOP,                             // pOptParam
        0                                       // Style, OTS_xxxx
    };

OPTPARAM    MaxRangeOP[] = {

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT(""),                               // pData (postfix)
        IDI_CPSUI_EMPTY,                        // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        NULL,                                   // pData (help line)
        (DWORD)MIN_INT,                         // IconID
        MAX_INT                                 // lParam
    }
};

OPTTYPE MaxRangeOT = {

        sizeof(OPTTYPE),                        // cbSize
        TVOT_UDARROW,                           // Type
        0,                                      // Flags OPTTF_xxxx
        2,                                      // Count
        0,                                      // BegCtrlID
        MaxRangeOP,                             // pOptParam
        0                                       // Style, OTS_xxxx
    };


OPTPARAM    MinMaxRangeOP[] = {

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("%"),                              // pData (postfix)
        IDI_CPSUI_SCALING,                      // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        NULL,                                   // pData (help line)
        (DWORD)MIN_INT,                         // IconID
        MAX_INT                                 // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        NULL,                                   // pData (help line)
        2,                                      // IconID
        50                                      // lParam
    }
};

OPTTYPE TVOTUDArrowOT = {

        sizeof(OPTTYPE),                        // cbSize
        TVOT_UDARROW,                           // Type
        0,                                      // Flags OPTTF_xxxx
        2,                                      // Count
        0,                                      // BegCtrlID
        MinMaxRangeOP,                          // pOptParam
        0                                       // Style, OTS_xxxx
    };

OPTTYPE TVOTTrackBarOT = {

        sizeof(OPTTYPE),                        // cbSize
        TVOT_TRACKBAR,                          // Type
        0,                                      // Flags OPTTF_xxxx
        3,                                      // Count
        0,                                      // BegCtrlID
        MinMaxRangeOP,                         // pOptParam
        0                                       // Style, OTS_xxxx
    };

OPTTYPE TVOTScrollBarOT = {

        sizeof(OPTTYPE),                        // cbSize
        TVOT_SCROLLBAR,                         // Type
        0,                                      // Flags OPTTF_xxxx
        3,                                      // Count
        0,                                      // BegCtrlID
        MinMaxRangeOP,                         // pOptParam
        0                                       // Style, OTS_xxxx
    };

OPTPARAM    TVOTLBCBOP[] = {

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        (LPTSTR)IDS_CPSUI_NOTINSTALLED,         // pData
        IDI_CPSUI_SEL_NONE,                     // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT(" 1 MB"),                         // pData
        IDI_CPSUI_MEM,                          // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT(" 2 MB"),                         // pData
        IDI_CPSUI_MEM,                          // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT(" 4 MB"),                         // pData
        IDI_CPSUI_MEM,                          // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT(" 6 MB"),                         // pData
        IDI_CPSUI_MEM,                          // IconID
        0                                       // lParam
    },
    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT(" 8 MB"),                         // pData
        IDI_CPSUI_MEM,                          // IconID
        0                                       // lParam
    },
    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("10 MB"),                         // pData
        IDI_CPSUI_MEM,                          // IconID
        0                                       // lParam
    },
    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("12 MB"),                         // pData
        IDI_CPSUI_MEM,                          // IconID
        0                                       // lParam
    },
    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("14 MB"),                         // pData
        IDI_CPSUI_MEM,                          // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("16 MB"),                         // pData
        IDI_CPSUI_MEM,                          // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("18 MB"),                         // pData
        IDI_CPSUI_MEM,                          // IconID
        0                                       // lParam
    },
    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("20 MB"),                         // pData
        IDI_CPSUI_MEM,                          // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("24 MB"),                         // pData
        IDI_CPSUI_MEM,                          // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("32 MB"),                         // pData
        IDI_CPSUI_MEM,                          // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("48 MB"),                         // pData
        IDI_CPSUI_MEM,                          // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("64 MB"),                         // pData
        IDI_CPSUI_MEM,                          // IconID
        0                                       // lParam
    },
};


OPTTYPE TVOTListBoxOT = {

        sizeof(OPTTYPE),                        // cbSize
        TVOT_LISTBOX,                           // Type
        0,                                      // Flags OPTTF_xxxx
        COUNT_ARRAY(TVOTLBCBOP),                // Count
        0,                                      // BegCtrlID
        TVOTLBCBOP,                             // pOptParam
        0                                       // Style, OTS_xxxx
    };


OPTTYPE TVOTComboBoxOT = {

        sizeof(OPTTYPE),                        // cbSize
        TVOT_COMBOBOX,                           // Type
        0,                                      // Flags OPTTF_xxxx
        COUNT_ARRAY(TVOTLBCBOP),                // Count
        0,                                      // BegCtrlID
        TVOTLBCBOP,                             // pOptParam
        0                                       // Style, OTS_xxxx
    };

TCHAR   TVOTEditBoxBuf[128] = TEXT("Confidential");

OPTPARAM    TVOTEditBoxOP[] = {

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("*Mark*"),                         // pData
        IDI_CPSUI_WATERMARK,                    // IconID
        0                                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("Type in WaterMark text"),         // pData
        COUNT_ARRAY(TVOTEditBoxBuf),            // IconID
        0                                       // lParam
    }
};


OPTTYPE TVOTEditBoxOT = {

        sizeof(OPTTYPE),                        // cbSize
        TVOT_EDITBOX,                           // Type
        0,                                      // Flags OPTTF_xxxx
        2,                                      // Count
        0,                                      // BegCtrlID
        TVOTEditBoxOP,                          // pOptParam
        0                                       // Style, OTS_xxxx
    };

OPTPARAM    TVOTPushButtonOP[] = {

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        PUSHBUTTON_TYPE_DLGPROC,                // style
        (LPTSTR)PushButtonProc,                 // pData
        IDI_CPSUI_RUN_DIALOG,                   // IconID
        PUSHBUTTON_DLG                          // lParam
    }
};


OPTTYPE TVOTPushButtonOT = {

        sizeof(OPTTYPE),                        // cbSize
        TVOT_PUSHBUTTON,                        // Type
        0,                                      // Flags OPTTF_xxxx
        1,                                      // Count
        0,                                      // BegCtrlID
        TVOTPushButtonOP,                       // pOptParam
        0                                       // Style, OTS_xxxx
    };

OPTPARAM    TVOTChkBoxOP[] = {

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        CHKBOXS_FALSE_TRUE,                     // style
        TEXT("Let's do it!"),                   // pData
        IDI_CPSUI_TELEPHONE,                        // IconID
        0                                       // lParam
    }
};



OPTTYPE TVOTChkBoxOT = {

        sizeof(OPTTYPE),                        // cbSize
        TVOT_CHKBOX,                            // Type
        0,                                      // Flags OPTTF_xxxx
        1,                                      // Count
        0,                                      // BegCtrlID
        TVOTChkBoxOP,                           // pOptParam
        0                                       // Style, OTS_xxxx
    };


OPTPARAM    ChkBoxTypeOP[] = {

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("CHKBOXS_FALSE_TRUE"),             // pData
        IDI_CPSUI_EMPTY,                        // IconID
        CHKBOXS_FALSE_TRUE                      // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("CHKBOXS_NO_YES"),                 // pData
        IDI_CPSUI_EMPTY,                        // IconID
        CHKBOXS_NO_YES                          // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("CHKBOXS_OFF_ON"),                 // pData
        IDI_CPSUI_EMPTY,                        // IconID
        CHKBOXS_OFF_ON                          // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("CHKBOXS_FALSE_PDATA"),            // pData
        IDI_CPSUI_EMPTY,                        // IconID
        CHKBOXS_FALSE_PDATA                     // lParam
    },


    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("CHKBOXS_NO_PDATA"),               // pData
        IDI_CPSUI_EMPTY,                        // IconID
        CHKBOXS_NO_PDATA                        // lParam
    },


    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("CHKBOXS_OFF_PDATA"),              // pData
        IDI_CPSUI_EMPTY,                        // IconID
        CHKBOXS_OFF_PDATA                       // lParam
    },

    {
        sizeof(OPTPARAM),                       // cbSize
        0,                                      // OPTPF_xxx
        0,                                      // style
        TEXT("CHKBOXS_NONE_PDATA"),             // pData
        IDI_CPSUI_EMPTY,                        // IconID
        CHKBOXS_NONE_PDATA                      // lParam
    }
};


OPTTYPE ChkBoxTypeOT = {

        sizeof(OPTTYPE),                        // cbSize
        TVOT_LISTBOX,                           // Type
        0,                                      // Flags OPTTF_xxxx
        COUNT_ARRAY(ChkBoxTypeOP),              // Count
        0,                                      // BegCtrlID
        ChkBoxTypeOP,                           // pOptParam
        0                                       // Style, OTS_xxxx
    };

EXTCHKBOX   TV_ECB = {

        sizeof(EXTCHKBOX),
        ECBF_OVERLAY_WARNING_ICON,
        TEXT("Extended CheckBox Test"),
        (LPTSTR)IDS_CPSUI_SLASH_SEP,
        TEXT("Got Checked!!!"),
        IDI_APPLE };

EXTPUSH TV_EP = {

        sizeof(EXTPUSH),
        0,
        TEXT("Extended Push Test"),
        (DLGPROC)NULL,
        IDI_APPLE,
        0 };



OPTITEM TVTestOptItems[] = {

    { sizeof(OPTITEM), LEVEL_0, 0, OPTIF_NONE, 0,
      (LPTSTR)TEXT("TreeView Test"), IDI_CPSUI_QUESTION,   NULL,
       NULL, 0, DMPUB_TVTEST },

        { sizeof(OPTITEM), LEVEL_1, 0, OPTIF_COLLAPSE, 0,
          (LPTSTR)TEXT("CPSUI Options"), 0,   NULL,
           NULL, 0, DMPUB_TVOPT },

            { sizeof(OPTITEM), LEVEL_2, 0, OPTIF_CALLBACK | OPTIF_COLLAPSE, 0,
              (LPTSTR)TEXT("Extended Type"), 0,   &ECB_EP_ECB,
               &ECB_EP_OT, 0, DMPUB_TVOPT_ECB_EP },

                { sizeof(OPTITEM), LEVEL_3, 0, OPTIF_CALLBACK | OPTIF_COLLAPSE, 0,
                  (LPTSTR)TEXT("Disabled Extended"), 0,   NULL,
                   &NoYesOT, 0, DMPUB_EXT_DISABLED },

                { sizeof(OPTITEM), LEVEL_3, 0, OPTIF_CALLBACK | OPTIF_COLLAPSE, 0,
                  (LPTSTR)TEXT("Overlay 'Warning' Icon"), 0,   NULL,
                  &NoYesOT, 0, DMPUB_EXT_OVERLAY_WARNING },

                { sizeof(OPTITEM), LEVEL_3, 0, OPTIF_CALLBACK | OPTIF_COLLAPSE, 0,
                  (LPTSTR)TEXT("Overlay 'Stop' Icon"), 0,   NULL,
                  &NoYesOT, 0, DMPUB_EXT_OVERLAY_STOP },

                { sizeof(OPTITEM), LEVEL_3, 0, OPTIF_CALLBACK | OPTIF_COLLAPSE, 0,
                  (LPTSTR)TEXT("Overlay 'No' Icon"), 0,   NULL,
                  &NoYesOT, 0, DMPUB_EXT_OVERLAY_NO },

            { sizeof(OPTITEM), LEVEL_2, 0, OPTIF_COLLAPSE, 0,
              (LPTSTR)TEXT("OptItem/OptType"), 0,   NULL,
               NULL, 0, DMPUB_TVOPT },

                { sizeof(OPTITEM), LEVEL_3, 0, OPTIF_CALLBACK | OPTIF_COLLAPSE, 0,
                  (LPTSTR)TEXT("Disabled OptType"), 0,   NULL,
                   &NoYesOT, 0, DMPUB_TVOPT_DISABLED },

                { sizeof(OPTITEM), LEVEL_3, 0, OPTIF_CALLBACK | OPTIF_COLLAPSE, 0,
                  (LPTSTR)TEXT("Overlay 'Warning' Icon"), 0,   NULL,
                  &NoYesOT, 0, DMPUB_TVOPT_OVERLAY_WARNING },

                { sizeof(OPTITEM), LEVEL_3, 0, OPTIF_CALLBACK | OPTIF_COLLAPSE, 0,
                  (LPTSTR)TEXT("Overlay 'Stop' Icon"), 0,   NULL,
                  &NoYesOT, 0, DMPUB_TVOPT_OVERLAY_STOP },

                { sizeof(OPTITEM), LEVEL_3, 0, OPTIF_CALLBACK | OPTIF_COLLAPSE, 0,
                  (LPTSTR)TEXT("Overlay 'No' Icon"), 0,   NULL,
                  &NoYesOT, 0, DMPUB_TVOPT_OVERLAY_NO },

            { sizeof(OPTITEM), LEVEL_2, 0, OPTIF_COLLAPSE, 0,
              (LPTSTR)TEXT("ScrollBar/TrackBar Ranges"), 0,   NULL,
               NULL, 0, DMPUB_TVOPT },

                { sizeof(OPTITEM), LEVEL_3, 0, OPTIF_CALLBACK | OPTIF_COLLAPSE, 0,
                  TEXT("Min Range"), MIN_INT, NULL,
                   &MinRangeOT, 0, DMPUB_MINRANGE },

                { sizeof(OPTITEM), LEVEL_3, 0, OPTIF_CALLBACK | OPTIF_COLLAPSE, 0,
                  TEXT("Max. Range"), MAX_INT, NULL,
                   &MaxRangeOT, 0, DMPUB_MAXRANGE },

        { sizeof(OPTITEM), LEVEL_1, 0, OPTIF_NONE, 0,
          TEXT("TVOT Test"), IDI_CPSUI_QUESTION,   NULL,
           NULL, 0, DMPUB_TVOPT_TEST },

            { sizeof(OPTITEM), LEVEL_2, 0, OPTIF_CALLBACK, 0,
              (LPTSTR)TEXT("TVOT_2STATES"), 0, NULL,
               &TVOT2StatesOT, 0, DMPUB_2STATES },

            { sizeof(OPTITEM), LEVEL_2, 0, OPTIF_CALLBACK, 0,
              TEXT("TVOT_3STATES"), 0, NULL,
               &TVOT3StatesOT, 0, DMPUB_3STATES },

            { sizeof(OPTITEM), LEVEL_2, 0, OPTIF_CALLBACK, 0,
              TEXT("TVOT_UDARROW"), 55, NULL,
               &TVOTUDArrowOT, 0, DMPUB_UDARROW },

            { sizeof(OPTITEM), LEVEL_2, 0, OPTIF_CALLBACK, 0,
              TEXT("TVOT_TRACKBAR"), 100, NULL,
               &TVOTTrackBarOT, 0, DMPUB_TRACKBAR },

            { sizeof(OPTITEM), LEVEL_2, 0, OPTIF_CALLBACK, 0,
              TEXT("TVOT_SCROLLBAR"), 210, NULL,
               &TVOTScrollBarOT, 0, DMPUB_SCROLLBAR },

            { sizeof(OPTITEM), LEVEL_2, 0, OPTIF_CALLBACK, 0,
              TEXT("TVOT_LISTBOX"), 2, NULL,
               &TVOTListBoxOT, 0, DMPUB_LISTBOX },

                { sizeof(OPTITEM), LEVEL_3, 0, OPTIF_CALLBACK | OPTIF_COLLAPSE, 0,
                  (LPTSTR)TEXT("Include 16x16 Icons"), 1,   NULL,
                  &NoYesOT, 0, DMPUB_TVOPT_ICONS },

            { sizeof(OPTITEM), LEVEL_2, 0, OPTIF_CALLBACK, 0,
              TEXT("TVOT_COMBOBOX"), 4, NULL,
               &TVOTComboBoxOT, 0, DMPUB_COMBOBOX },

                { sizeof(OPTITEM), LEVEL_3, 0, OPTIF_CALLBACK | OPTIF_COLLAPSE, 0,
                  (LPTSTR)TEXT("Include 16x16 Icons"), 1,   NULL,
                  &NoYesOT, 0, DMPUB_TVOPT_ICONS },

            { sizeof(OPTITEM), LEVEL_2, 0, OPTIF_CALLBACK, 0,
              TEXT("TVOT_EDITBOX"), 0, NULL,  // fill in TVOTEditBoxBuf later
               &TVOTEditBoxOT, 0, DMPUB_EDITBOX },

            { sizeof(OPTITEM), LEVEL_2, 0, OPTIF_CALLBACK, 0,
              TEXT("TVOT_PUSHBUTTON"), 0, NULL,
               &TVOTPushButtonOT, 0, DMPUB_PUSHBUTTON },

            { sizeof(OPTITEM), LEVEL_2, 0, OPTIF_CALLBACK, 0,
              TEXT("TVOT_CHKBOX"), 0, NULL,
               &TVOTChkBoxOT, 0, DMPUB_CHKBOX },

                { sizeof(OPTITEM), LEVEL_3, 0, OPTIF_CALLBACK, 0,
                  TEXT("CheckBox Type"), 0,   NULL,
                   &ChkBoxTypeOT, 0, DMPUB_CHKBOX_TYPE }

};




BOOL
APIENTRY
PushButtonProc(
    HWND    hDlg,
    UINT    Msg,
    UINT    wParam,
    LONG    lParam
    )
{
    switch (Msg) {

    case WM_INITDIALOG:                /* message: initialize dialog box */

        CPSUIDBG(DBG_PUSHDLGPROC,
                ("PushButtonProc lParam=%s", (LPSTR)LongToPtr(lParam)));
        break;

    case WM_COMMAND:

        switch(LOWORD(wParam)) {

        case IDOK:
        case IDCANCEL:

            EndDialog(hDlg, (BOOL)(LOWORD(wParam) == IDOK));
            return(TRUE);
        }
    }

    return(FALSE);
}




BOOL
APIENTRY
MyAboutProc(
    HWND    hDlg,
    UINT    Msg,
    UINT    wParam,
    LONG    lParam
    )

/*++

Routine Description:

    This is the about... callback which pop up appliation's own about


--*/
{
    PCOMPROPSHEETUI pCPSUI;
    TCHAR           Buf[128];

    switch (Msg) {

    case WM_INITDIALOG:                /* message: initialize dialog box */

        pCPSUI = (PCOMPROPSHEETUI)LongToPtr(lParam);

        wsprintf(Buf, TEXT("About %s"), pCPSUI->pCallerName);

        SetWindowText(hDlg, Buf);

        wnsprintf(Buf, ARRAYSIZE(Buf) - 1, 
                        TEXT("%s  Version %u.%u"),
                        pCPSUI->pCallerName,
                        (UINT)HIBYTE(pCPSUI->CallerVersion),
                        (UINT)LOBYTE(pCPSUI->CallerVersion));

        SetDlgItemText(hDlg, IDD_ABOUT1, Buf);

        wnsprintf(Buf, ARRAYSIZE(Buf) - 1, 
                        TEXT("%s  Version %u.%u"),
                        pCPSUI->pOptItemName,
                        (UINT)HIBYTE(pCPSUI->OptItemVersion),
                        (UINT)LOBYTE(pCPSUI->OptItemVersion));

        SetDlgItemText(hDlg, IDD_ABOUT2, Buf);

        break;

    case WM_COMMAND:

        switch(LOWORD(wParam)) {

        case IDOK:
        case IDCANCEL:

            EndDialog(hDlg, (BOOL)(LOWORD(wParam) == IDOK));
            return(TRUE);
        }
    }

    return (FALSE);
}




POPTITEM
FindOptItem(
    POPTITEM    pOptItem,
    UINT        cOptItem,
    BYTE        DMPubID
    )
{
    while (cOptItem--) {

        if (pOptItem->DMPubID == DMPubID) {

            return(pOptItem);
        }

        ++pOptItem;
    }

    return(NULL);
}





CPSUICALLBACK
TVTestCallBack(
    PCPSUICBPARAM   pCPSUICBParam
    )
{
    POPTITEM    pCurItem = pCPSUICBParam->pCurItem;
    POPTITEM    pItem;
    BYTE        DMPubID;
    BYTE        Flags;
    LONG        Sel;
    LONG        Action = CPSUICB_ACTION_NONE;


    DMPubID = pCurItem->DMPubID;
    Sel     = pCurItem->Sel;

    switch (pCPSUICBParam->Reason) {

    case CPSUICB_REASON_OPTITEM_SETFOCUS:

        CPSUIDBG(DBG_TVTESTCB, ("Got OPTITEM_SETFOCUS CallBack now"));

        switch (DMPubID) {

        case DMPUB_MINRANGE:

            if (pItem = FindOptItem(pCPSUICBParam->pOptItem,
                                    pCPSUICBParam->cOptItem,
                                    DMPUB_MAXRANGE)) {

                pCurItem->pOptType->pOptParam[1].lParam = (LONG)pItem->Sel;
            }

            break;

        case DMPUB_MAXRANGE:

            if (pItem = FindOptItem(pCPSUICBParam->pOptItem,
                                    pCPSUICBParam->cOptItem,
                                    DMPUB_MINRANGE)) {

                pCurItem->pOptType->pOptParam[1].IconID = (DWORD)pItem->Sel;
            }

            break;

        }

        break;

    case CPSUICB_REASON_ABOUT:

        DialogBoxParam(hInstApp,
                       MAKEINTRESOURCE(DLGABOUT),
                       pCPSUICBParam->hDlg,
                       (DLGPROC)MyAboutProc,
                       (LPARAM)(pCPSUICBParam->pOldSel));

        break;

    case CPSUICB_REASON_ECB_CHANGED:

        CPSUIDBG(DBG_TVTESTCB, ("Got ECB_CHANGED CallBack now"));

        switch (DMPubID) {

        case DMPUB_TVOPT_ECB_EP:

            if (pCurItem->Flags & OPTIF_ECB_CHECKED) {

                TV_EP.IconID  =
                TV_ECB.IconID = IDI_APPLE;

            } else {

                TV_EP.IconID  =
                TV_ECB.IconID = 0;
            }

            Action = CPSUICB_ACTION_OPTIF_CHANGED;
            break;

        default:

            break;
        }

        break;

    case CPSUICB_REASON_SEL_CHANGED:

        CPSUIDBG(DBG_TVTESTCB, ("Got SEL_CHANGED CallBack now"));

        switch (DMPubID) {

        case DMPUB_CHKBOX_TYPE:

             if (pItem = FindOptItem(pCPSUICBParam->pOptItem,
                                     pCPSUICBParam->cOptItem,
                                     DMPUB_CHKBOX)) {

                pItem->pOptType->pOptParam[0].Style = (BYTE)pCurItem->Sel;

                pItem->Flags |= OPTIF_CHANGED;
                Action        = CPSUICB_ACTION_OPTIF_CHANGED;
            }

            break;

        case DMPUB_TVOPT_ICONS:

            pItem = pCurItem - 1;

            if (Sel) {

                pItem->pOptType->Style &= ~OTS_LBCB_NO_ICON16_IN_ITEM;

            } else {

                pItem->pOptType->Style |= OTS_LBCB_NO_ICON16_IN_ITEM;
            }

            break;

        case DMPUB_EXT_OVERLAY_WARNING:

            if (Sel) {

                TV_EP.Flags  |= EPF_OVERLAY_WARNING_ICON;
                TV_ECB.Flags |= ECBF_OVERLAY_WARNING_ICON;

            } else {

                TV_EP.Flags  &= ~EPF_OVERLAY_WARNING_ICON;
                TV_ECB.Flags &= ~ECBF_OVERLAY_WARNING_ICON;
            }

            break;

        case DMPUB_EXT_OVERLAY_STOP:

            if (Sel) {

                TV_EP.Flags  |= EPF_OVERLAY_STOP_ICON;
                TV_ECB.Flags |= ECBF_OVERLAY_STOP_ICON;

            } else {

                TV_EP.Flags  &= ~EPF_OVERLAY_STOP_ICON;
                TV_ECB.Flags &= ~ECBF_OVERLAY_STOP_ICON;
            }

            break;

        case DMPUB_EXT_OVERLAY_NO:

            if (Sel) {

                TV_EP.Flags  |= EPF_OVERLAY_NO_ICON;
                TV_ECB.Flags |= ECBF_OVERLAY_NO_ICON;

            } else {

                TV_EP.Flags  &= ~EPF_OVERLAY_NO_ICON;
                TV_ECB.Flags &= ~ECBF_OVERLAY_NO_ICON;
            }

            break;

        case DMPUB_MINRANGE:

            MinMaxRangeOP[1].IconID = (DWORD)Sel;
            break;

        case DMPUB_MAXRANGE:

            MinMaxRangeOP[1].lParam = (LONG)Sel;
            break;

        case DMPUB_TVOPT_OVERLAY_WARNING:
        case DMPUB_TVOPT_OVERLAY_STOP:
        case DMPUB_TVOPT_OVERLAY_NO:

            Action = CPSUICB_ACTION_REINIT_ITEMS;

        case DMPUB_TVOPT_ECB_EP:

            if (Sel) {

                pCurItem->Flags &= ~OPTIF_EXT_DISABLED;

            } else {

                pCurItem->Flags |= OPTIF_EXT_DISABLED;
            }

            pCurItem->Flags |= OPTIF_CHANGED;
            Action           = CPSUICB_ACTION_OPTIF_CHANGED;

            //
            // Fall through
            //

        case DMPUB_TVOPT_DISABLED:
        case DMPUB_EXT_DISABLED:

            if (pItem = FindOptItem(pCPSUICBParam->pOptItem,
                                    pCPSUICBParam->cOptItem,
                                    DMPUB_2STATES)) {

                do {

                    if ((pItem->DMPubID >= DMPUB_2STATES) &&
                        (pItem->DMPubID <= DMPUB_CHKBOX)) {

                        switch (DMPubID) {

                        case DMPUB_TVOPT_OVERLAY_WARNING:

                            if (Sel) {

                                pItem->Flags |= OPTIF_OVERLAY_WARNING_ICON;

                            } else {

                                pItem->Flags &= ~OPTIF_OVERLAY_WARNING_ICON;
                            }

                            break;

                        case DMPUB_TVOPT_OVERLAY_STOP:

                            if (Sel) {

                                pItem->Flags |= OPTIF_OVERLAY_STOP_ICON;

                            } else {

                                pItem->Flags &= ~OPTIF_OVERLAY_STOP_ICON;
                            }

                            break;

                        case DMPUB_TVOPT_OVERLAY_NO:

                            if (Sel) {

                                pItem->Flags |= OPTIF_OVERLAY_NO_ICON;

                            } else {

                                pItem->Flags &= ~OPTIF_OVERLAY_NO_ICON;
                            }

                            break;

                        case DMPUB_TVOPT_DISABLED:

                            if (Sel) {

                                pItem->pOptType->Flags |= OPTTF_TYPE_DISABLED;

                            } else {

                                pItem->pOptType->Flags &= ~OPTTF_TYPE_DISABLED;
                            }

                            break;

                        case DMPUB_EXT_DISABLED:

                            if (Sel) {

                                pItem->Flags |= OPTIF_EXT_DISABLED;

                            } else {

                                pItem->Flags &= ~OPTIF_EXT_DISABLED;
                            }

                            break;

                        case DMPUB_TVOPT_ECB_EP:

                            switch (Sel) {

                            case 0:

                                pItem->Flags |= OPTIF_EXT_HIDE;
                                break;

                            case 1:

                                pItem->Flags     &= ~(OPTIF_EXT_HIDE        |
                                                      OPTIF_EXT_IS_EXTPUSH);
                                pItem->pExtChkBox = &TV_ECB;

                                break;

                            case 2:

                                pItem->Flags    &= ~OPTIF_EXT_HIDE;
                                pItem->Flags    |= OPTIF_EXT_IS_EXTPUSH;
                                pItem->pExtPush  = &TV_EP;
                                break;
                            }
                        }
                    }

                    pItem->Flags |= OPTIF_CHANGED;

                } while ((pItem++)->DMPubID != DMPUB_CHKBOX);
            }

            break;

        default:

            break;
        }

        break;

    case CPSUICB_REASON_PUSHBUTTON:

        CPSUIDBG(DBG_TVTESTCB, ("Got PUSH Button CallBack now"));
        break;

    case CPSUICB_REASON_EXTPUSH:

        DialogBoxParam(hInstApp,
                       MAKEINTRESOURCE(EXTPUSH_DLG),
                       pCPSUICBParam->hDlg,
                       (DLGPROC)PushButtonProc,
                       (LPARAM)(pCPSUICBParam->pOldSel));
        break;

    default:

        break;
    }

    return(Action);
}





BOOL
SetupComPropSheetUI(
    PCOMPROPSHEETUI pCPSUI
    )
{
    static BOOL UpdateEditBox = TRUE;
    UINT        i;


    ZeroMemory(pCPSUI, sizeof(COMPROPSHEETUI));

    pCPSUI->cbSize         = sizeof(COMPROPSHEETUI);
    pCPSUI->hInstCaller    = hInstApp;
    pCPSUI->pCallerName    = (LPTSTR)TitleName;
    pCPSUI->CallerVersion  = 0x100;
    pCPSUI->pOptItemName   = (LPTSTR)OptItemName;
    pCPSUI->OptItemVersion = 0x400;
    pCPSUI->UserData       = (ULONG_PTR)pCPSUI;
    pCPSUI->pHelpFile      = (LPTSTR)TEXT("CPSUISam.hlp");
    pCPSUI->pfnCallBack    = TVTestCallBack;
    pCPSUI->pOptItem       = TVTestOptItems;
    pCPSUI->cOptItem       = COUNT_ARRAY(TVTestOptItems);
    pCPSUI->Flags          = 0;
    pCPSUI->pDlgPage       = CPSUI_PDLGPAGE_TREEVIWONLY;
    pCPSUI->cDlgPage       = 0;


    if (UpdateEditBox) {

        //
        // Fixup compiler warning for the LPSTR and LONG
        //

        for (i = 0; i < COUNT_ARRAY(TVTestOptItems); i++) {

            if (TVTestOptItems[i].DMPubID == DMPUB_EDITBOX) {

                TVTestOptItems[i].pSel = (LPTSTR)TVOTEditBoxBuf;
                UpdateEditBox = FALSE;
                break;
            }
        }
    }

    if (UpdatePermission) {

        pCPSUI->Flags |= CPSUIF_UPDATE_PERMISSION;
    }

    if (!UseStdAbout) {

        pCPSUI->Flags |= CPSUIF_ABOUT_CALLBACK;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\sample\cpsuisam.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation
All Rights Reserved


Module Name:

    cpsuisam.h


Abstract:

    This module is the header file for the sample


[Environment:]


--*/


#define IDM_PERMISSION              10
#define IDM_USESTDABOUT             20
#define IDM_DOCPROP                 30
#define IDM_TVTEST                  40
#define IDM_DOCPROP_TVTEST          50

#define IDI_CPSUISAMPLE             500
#define IDI_APPLE                   510

#define PUSHBUTTON_DLG              1000
#define DLGABOUT                    1010
#define EXTPUSH_DLG                 1020
#define IDD_ABOUT1                  201
#define IDD_ABOUT2                  202
#define IDD_ABOUTICON               203
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\sample\debug.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation
All Rights Reserved


Module Name:

    debug.h


Abstract:

    This module contains all debugger definitions


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


--*/


#if DBG

VOID
cdecl
CPSUIDbgPrint
(
    LPSTR   pszFormat,
    ...
);

VOID
CPSUIDbgType
(
    INT    Type
);

VOID
_CPSUIAssert
(
    LPSTR   pMsg,
    LPSTR   pFalseExp,
    LPSTR   pFilename,
    UINT    LineNo,
    DWORD   Exp,
    BOOL    Stop
);



extern BOOL DoCPSUIWarn;


#define DBGP(x)                 (CPSUIDbgPrint x)

#if 1
#define DEFINE_DBGVAR(x)        DWORD DBG_CPSUIFILENAME=(x)
#else
#define DEFINE_DBGVAR(x)
#endif

#define CPSUIDBG(x,y)           if((x)&DBG_CPSUIFILENAME){CPSUIDbgType(0);DBGP(y);}

#define CPSUIDBGBLK(x)          x;
#define CPSUIWARN(x)            if(DoCPSUIWarn) { CPSUIDbgType(1);DBGP(x); }
#define CPSUIERR(x)             CPSUIDbgType(-1);DBGP(x)
#define CPSUIRIP(x)             CPSUIERR(x); DebugBreak()
#define CPSUIASSERT(b,x,e,i)     \
            if (!(e)) { _CPSUIAssert(x,#e,__FILE__,(UINT)__LINE__,(DWORD)i,b); }

#else   // DBG

#define CPSUIDBGBLK(x)
#define DEFINE_DBGVAR(x)
#define CPSUIDBG(x,y)
#define CPSUIWARN(x)
#define CPSUIERR(x)
#define CPSUIRIP(x)
#define CPSUIASSERT(b,x,e,i)

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\sample\debug.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation
All Rights Reserved


Module Name:

    debug.c


Abstract:

    This module contains all debugging routines


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#if DBG


BOOL DoCPSUIWarn = TRUE;



VOID
cdecl
CPSUIDbgPrint
(
    LPSTR   pszFormat,
    ...
)
/*++

Routine Description:

    This fucntion output the debug informat to the debugger


Arguments:

    pszFormat   - format string

    ...         - variable data


Return Value:


    VOID

--*/
{
    va_list         vaList;
    static TCHAR    OutBuf[768];
#ifdef UNICODE
    static WCHAR    FormatBuf[256];
#endif
    //
    // We assume that UNICODE flag is turn on for the compilation, bug the
    // format string passed to here is ASCII version, so we need to convert
    // it to LPWSTR before the wvsprintf()
    //

    va_start(vaList, pszFormat);

#ifdef UNICODE
    MultiByteToWideChar(CP_ACP, 0, pszFormat, -1, FormatBuf, 256);
    wvsprintf(OutBuf, FormatBuf, vaList);
#else
    wvsprintf(OutBuf, pszFormat, vaList);
#endif
    va_end(vaList);

    OutputDebugString((LPTSTR)OutBuf);
    OutputDebugString(TEXT("\n"));
}




VOID
CPSUIDbgType
(
    INT    Type
)
/*++

Routine Description:

    this function output the ERROR/WARNING message


Arguments:

    Type

Return Value:


--*/
{
    static TCHAR DebugDLLName[] = TEXT("SurPtrUI");

    if (Type < 0)
    {
        OutputDebugString(TEXT("ERROR) "));
    }
    else if (Type > 0)
    {
        OutputDebugString(TEXT("WARNING: "));
    }
    OutputDebugString(DebugDLLName);
    OutputDebugString(TEXT("!"));
}


#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\sample\cpsuisam.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation
All Rights Reserved


Module Name:

    cpsuisam.c


Abstract:

    This module contrains sample prototype for the NT 5.0 common Property
    Sheet user interface

--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_CPSUIFILENAME   DbgCPSUISam



#define DBG_WINMAINPROC     0x00000001

DEFINE_DBGVAR(0);



#define HAS_TVTEST_PAGES    0x01
#define HAS_DOCPROP_PAGES   0x02



extern  HINSTANCE   hInstApp;
extern  TCHAR       TitleName[];
extern  TCHAR       ClassName[];
extern  TCHAR       MenuName[];
extern  TCHAR       szWinSpool[];
extern  CHAR        szDocPropSheets[];
extern  BOOL        UpdatePermission;
extern  BOOL        UseStdAbout;


HWND    hWndApp = NULL;


typedef struct _CPSUISAMPLE
{
    HANDLE                  hParent;
    HANDLE                  hCPSUI;
    HANDLE                  hDocProp;
    PFNCOMPROPSHEET         pfnCPS;
    COMPROPSHEETUI          CPSUI;
    DOCUMENTPROPERTYHEADER  DPHdr;
    HGLOBAL                 hDevMode;
    HGLOBAL                 hDevNames;
} CPSUISAMPLE, *PCPSUISAMPLE;




BOOL
GetDefPrinter
(
    PCPSUISAMPLE    pCPSUISample
)
{
    HGLOBAL         h;
    LPTSTR          pszPrinterName;
    DEVMODE         *pDM;
    DEVNAMES        *pDN;
    HANDLE          hPrinter = NULL;
    PAGESETUPDLG    PSD;
    BOOL            Ok = FALSE;


    ZeroMemory(&PSD, sizeof(PSD));

    PSD.lStructSize = sizeof(PSD);
    PSD.Flags       = PSD_RETURNDEFAULT;


    if (PageSetupDlg(&PSD))
    {
        if (  (h   = PSD.hDevMode)
           && (pDM = (DEVMODE *)GlobalLock(h))
           && (h   = PSD.hDevNames)
           && (pDN = (DEVNAMES *)GlobalLock(h))
           && (pszPrinterName = (LPTSTR)((LPBYTE)pDN + pDN->wDeviceOffset))
           && (OpenPrinter(pszPrinterName, &hPrinter, NULL))
           )
        {
            Ok = TRUE;
        }

        if (Ok)
        {
            if (h = pCPSUISample->hDevMode)
            {
                GlobalUnlock(h);
                GlobalFree(h);
            }

            if (h = pCPSUISample->hDevNames)
            {
                GlobalUnlock(h);
                GlobalFree(h);
            }

            if (pCPSUISample->DPHdr.hPrinter)
            {
                ClosePrinter(pCPSUISample->DPHdr.hPrinter);
            }

            pCPSUISample->hDevMode             = PSD.hDevMode;
            pCPSUISample->hDevNames            = PSD.hDevNames;

            pCPSUISample->DPHdr.cbSize         = sizeof(DOCUMENTPROPERTYHEADER);
            pCPSUISample->DPHdr.hPrinter       = hPrinter;
            pCPSUISample->DPHdr.pszPrinterName = pszPrinterName;
            pCPSUISample->DPHdr.pdmIn          =
            pCPSUISample->DPHdr.pdmOut         = pDM;
            pCPSUISample->DPHdr.fMode          = (DM_IN_BUFFER | DM_IN_PROMPT | DM_OUT_BUFFER);

            if (!UpdatePermission)
            {
                pCPSUISample->DPHdr.fMode |= DM_NOPERMISSION;
            }
        }
        else
        {
            if (h = PSD.hDevMode)
            {
                GlobalUnlock(h);
                GlobalFree(h);
            }

            if (h = PSD.hDevNames)
            {
                GlobalUnlock(h);
                GlobalFree(h);
            }

            if (hPrinter)
            {
                ClosePrinter(hPrinter);
            }
        }
    }

    return Ok;
}




LONG
CALLBACK
CPSUIFunc
(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
)
{
    PPROPSHEETUI_INFO_HEADER    pPSUIInfoHdr;
    PCPSUISAMPLE                pCPSUISample;
    HANDLE                      h;
    INSERTPSUIPAGE_INFO         InsPI;

    if (!pPSUIInfo)
    {
        return FALSE;
    }

    switch (pPSUIInfo->Reason)
    {
    case PROPSHEETUI_REASON_INIT:

        if (!(pCPSUISample = (PCPSUISAMPLE)LocalAlloc(LPTR, sizeof(CPSUISAMPLE))))
        {
            return(-1);
        }

        pPSUIInfo->UserData   = (ULONG_PTR)pCPSUISample;
        pCPSUISample->hParent = pPSUIInfo->hComPropSheet;
        pCPSUISample->pfnCPS  = pPSUIInfo->pfnComPropSheet;

        //
        // Add Document Property Sheet for current default Printer
        //

        switch (pPSUIInfo->lParamInit)
        {
        case IDM_DOCPROP:
        case IDM_DOCPROP_TVTEST:

            if (GetDefPrinter(pCPSUISample))
            {
                InsPI.cbSize  = sizeof(INSERTPSUIPAGE_INFO);
                InsPI.Type    = PSUIPAGEINSERT_DLL;
                InsPI.Mode    = INSPSUIPAGE_MODE_FIRST_CHILD;
                InsPI.dwData1 = (ULONG_PTR)szWinSpool;
                InsPI.dwData2 = (ULONG_PTR)szDocPropSheets;
                InsPI.dwData3 = (ULONG_PTR)&(pCPSUISample->DPHdr);

                pCPSUISample->hDocProp =
                        (HANDLE)pCPSUISample->pfnCPS( pCPSUISample->hParent,
                                                      CPSFUNC_INSERT_PSUIPAGE,
                                                      (LPARAM)0,
                                                      (LPARAM)&InsPI
                                                    );
            }
            break;
        }

        //
        // Add TreeView Page
        //

        switch (pPSUIInfo->lParamInit)
        {
        case IDM_TVTEST:
        case IDM_DOCPROP_TVTEST:

            if (SetupComPropSheetUI(&(pCPSUISample->CPSUI)))
            {
                InsPI.cbSize  = sizeof(INSERTPSUIPAGE_INFO);
                InsPI.Type    = PSUIPAGEINSERT_PCOMPROPSHEETUI;
                InsPI.Mode    = INSPSUIPAGE_MODE_FIRST_CHILD;
                InsPI.dwData1 = (ULONG_PTR)&(pCPSUISample->CPSUI);
                InsPI.dwData2 =
                InsPI.dwData3 = 0;

                pCPSUISample->hCPSUI =
                        (HANDLE)pCPSUISample->pfnCPS( pCPSUISample->hParent,
                                                      CPSFUNC_INSERT_PSUIPAGE,
                                                      (LPARAM)0,
                                                      (LPARAM)&InsPI
                                                    );
            }
            break;
        }

        if (  (pCPSUISample->hCPSUI)
           || (pCPSUISample->hDocProp)
           )
        {
            return 1;
        }

        break;

    case PROPSHEETUI_REASON_GET_INFO_HEADER:

        if (pPSUIInfoHdr = (PPROPSHEETUI_INFO_HEADER)lParam)
        {
            pPSUIInfoHdr->pTitle = (LPTSTR)TitleName;

            switch (pPSUIInfo->lParamInit)
            {
            case IDM_DOCPROP:

                pPSUIInfoHdr->IconID = IDI_CPSUI_PRINTER2;
                break;

            case IDM_TVTEST:

                pPSUIInfoHdr->IconID = IDI_CPSUI_OPTION2;
                break;

            case IDM_DOCPROP_TVTEST:

                pPSUIInfoHdr->IconID = IDI_CPSUI_RUN_DIALOG;
                break;
            }

            pPSUIInfoHdr->Flags      = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
            pPSUIInfoHdr->hWndParent = hWndApp;
            pPSUIInfoHdr->hInst      = hInstApp;

            return 1;
        }

        break;

    case PROPSHEETUI_REASON_SET_RESULT:

        if (  (pCPSUISample = (PCPSUISAMPLE)pPSUIInfo->UserData)
           && (pCPSUISample->hCPSUI == ((PSETRESULT_INFO)lParam)->hSetResult)
           )
        {
            //
            // Save the result and propagate to its owner
            //
            pPSUIInfo->Result = ((PSETRESULT_INFO)lParam)->Result;
            return 1;
        }

        break;

    case PROPSHEETUI_REASON_DESTROY:

        if (pCPSUISample = (PCPSUISAMPLE)pPSUIInfo->UserData)
        {
            if (h = pCPSUISample->hDevMode)
            {
                GlobalUnlock(h);
                GlobalFree(h);
            }

            if (h = pCPSUISample->hDevNames)
            {
                GlobalUnlock(h);
                GlobalFree(h);
            }

            if (pCPSUISample->DPHdr.hPrinter)
            {
                ClosePrinter(pCPSUISample->DPHdr.hPrinter);
            }

            LocalFree((HLOCAL)pCPSUISample);
            pPSUIInfo->UserData = 0;
        }
        return 1;
    }
    return -1;
}



LRESULT
APIENTRY
MainWndProc
(
    HWND    hWnd,
    UINT    Msg,
    UINT    wParam,
    LONG    lParam
)
/*++

Routine Description:

    This is the main window procedure to the testing program


Arguments:

    See SDK


Return Value:

    See SDK

--*/
{
    LONG    Result;
    LONG    Ret;

    switch (Msg)
    {
    case WM_INITMENUPOPUP:

        if (!HIWORD(lParam))
        {
            CheckMenuItem( (HMENU)UIntToPtr(wParam),
                           IDM_PERMISSION,
                           MF_BYCOMMAND | ((UpdatePermission) ? MF_CHECKED : MF_UNCHECKED)
                         );

            CheckMenuItem( (HMENU)UIntToPtr(wParam),
                           IDM_USESTDABOUT,
                           MF_BYCOMMAND | ((UseStdAbout) ? MF_CHECKED : MF_UNCHECKED)
                         );
        }
        break;

    case WM_COMMAND:

        switch (wParam)
        {
        case IDM_USESTDABOUT:

            UseStdAbout = !UseStdAbout;
            break;

        case IDM_PERMISSION:

            UpdatePermission = !UpdatePermission;
            break;

        case IDM_DOCPROP:
        case IDM_TVTEST:
        case IDM_DOCPROP_TVTEST:

            Ret = CommonPropertySheetUI( hWnd,
                                         (PFNPROPSHEETUI)CPSUIFunc,
                                         (LPARAM)LOWORD(wParam),
                                         &Result
                                       );

            CPSUIDBG( DBG_WINMAINPROC,
                      ("CommonPropertySheetUI()=%ld, Result=%ld", Ret, Result)
                    );

            break;

        default:

            break;
        }
        break;

    case WM_DESTROY:

        PostQuitMessage(0);
        break;

    default:

        return (DefWindowProc(hWnd, Msg, wParam, lParam));
    }

    return 0L;
}




BOOL
InitInstance
(
    HANDLE  hInstance,
    INT     nCmdShow
)
/*++

Routine Description:

    Saves instance handle and creates main window

    This function is called at initialization time for every instance of
    this application.  This function performs initialization tasks that
    cannot be shared by multiple instances.

    In this case, we save the instance handle in a static variable and
    create and display the main program window.


Arguments:

    hInstance   - Current instance identifier

    nComShow    - Param for first ShowWindow() call.



Return Value:

    TRUE/FALSE


--*/
{
    //
    // Save the instance handle in static variable, which will be used in
    // many subsequence calls from this application to Windows.
    //

    hInstApp = hInstance;

    //
    // Create a main window for this application instance.
    //

    if (hWndApp = CreateWindow( ClassName,
                                TitleName,
                                WS_OVERLAPPEDWINDOW,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                NULL,
                                NULL,
                                hInstance,
                                NULL
                              )
       )
    {
        //
        // Make the window visible; update its client area;
        // and send WM_PAINT message
        //

        ShowWindow(hWndApp, nCmdShow);
        UpdateWindow(hWndApp);
    }

    return ((hWndApp) ? TRUE : FALSE);
}



BOOL
InitApplication
(
    HANDLE  hInstance
)
/*++

Routine Description:

    Initializes window data and registers window class

    This function is called at initialization time only if no other
    instances of the application are running.  This function performs
    initialization tasks that can be done once for any number of running
    instances.

    In this case, we initialize a window class by filling out a data
    structure of type WNDCLASS and calling the Windows RegisterClass()
    function.  Since all instances of this application use the same window
    class, we only need to do this when the first instance is initialized.


Arguments:

    hInstance   - current instance


Return Value:

    BOOLEAN

--*/
{
    WNDCLASS  wc;

    //
    // Fill in window class structure with parameters that describe the
    // main window.
    //

    wc.style         = 0L;
    wc.lpfnWndProc   = (WNDPROC)MainWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon(hInstance, (LPCTSTR)IDI_CPSUISAMPLE);
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH); 
    wc.lpszMenuName  = MenuName;
    wc.lpszClassName = ClassName;

    //
    // Register the window class and return success/failure code.
    //
    return RegisterClass(&wc);
}




INT
APIENTRY
WinMain
(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPSTR       lpCmdLine,
    INT         nCmdShow
)
/*++

Routine Description:

    calls initialization function, processes message loop

    Windows recognizes this function by name as the initial entry point
    for the program.  This function calls the application initialization
    routine, if no other instance of the program is running, and always
    calls the instance initialization routine.  It then executes a message
    retrieval and dispatch loop that is the top-level control structure
    for the remainder of execution.  The loop is terminated when a WM_QUIT
    message is received, at which time this function exits the application
    instance by returning the value passed by PostQuitMessage().

    If this function must abort before entering the message loop, it
    returns the conventional value NULL.


Arguments:



Return Value:

    Integer


--*/
{
    MSG Msg;

    UNREFERENCED_PARAMETER(lpCmdLine);

    //
    // Other instances of app running?
    //

    if (!hPrevInstance)
    {
        if (!InitApplication(hInstance))
        {
            //
            // Initialize shared things, Exits if unable to initialize
            //
            return FALSE;
        }
    }

    //
    // Perform initializations that apply to a specific instance
    //
    if (!InitInstance(hInstance, nCmdShow))
    {
        return FALSE;
    }

    //
    // Acquire and dispatch messages until a WM_QUIT message is received.
    //
    while (GetMessage(&Msg, NULL, 0L, 0L))
    {
        //
        // Translates virtual key codes and Dispatches message to window
        //
        TranslateMessage(&Msg);
        DispatchMessage(&Msg);
    }

    //
    // Returns the value from PostQuitMessage
    //
    return((INT)Msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\sample\precomp.h ===
//
// Copyright (c) 1990-1998 Microsoft Corporation
// All Rights Reserved
//

#include <stddef.h>
#include <windows.h>
#include <winspool.h>
#include <winddiui.h>
#include <commctrl.h>
#include <commdlg.h>
#include <compstui.h>
#include <shlwapi.h>
#include "debug.h"
#include "cpsuisam.h"
#include "cpsuidat.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\extend\dll\extend.h ===
//(C) COPYRIGHT MICROSOFT CORP., 1998-1999

 #ifndef _EXTEND_H_
 #define _EXTEND_H_


 BOOL ShowMessage (HWND hParent, INT idCaption, INT idMessage);
 extern LONG                g_cRef;            // DLL reference counter.
 extern HINSTANCE           g_hInst;


void DllAddRef ();
void DllRelease ();
HRESULT CreateDeviceFromId (LPWSTR szDeviceId, IWiaItem **ppItem);
LPWSTR GetNamesFromDataObject (IDataObject *lpdobj, UINT *puItems);

DEFINE_GUID(CLSID_TestShellExt, 0xb6c280f7,0x0f07,0x11d3,0x94, 0xc7, 0x00, 0x80, 0x5f, 0x65, 0x96, 0xd2);

// {EDB8B35D-C15F-4e45-9658-50D7F8ADDB56}
DEFINE_GUID(CLSID_TestUIExtension, 0xedb8b35d, 0xc15f, 0x4e45, 0x96, 0x58, 0x50, 0xd7, 0xf8, 0xad, 0xdb, 0x56);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\extend\dll\classes.h ===
//(C) COPYRIGHT MICROSOFT CORP., 1998-1999

#ifndef _CLASSES_H_
#define _CLASSES_H_


/*****************************************************************************
class CShellExt

Implement our regular shell extensions.


******************************************************************************/

class ATL_NO_VTABLE CShellExt :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CShellExt, &CLSID_TestShellExt>,
    public IShellExtInit, public IContextMenu, public IShellPropSheetExt
{
    private:
        UINT_PTR m_idCmd;
        CComPtr<IWiaItem> m_pItem;

        static INT_PTR CALLBACK PropPageProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
        HRESULT GetNewRootPath (HWND hwnd);

    public:
    BEGIN_COM_MAP(CShellExt)
        COM_INTERFACE_ENTRY(IShellExtInit)
        COM_INTERFACE_ENTRY(IContextMenu)
        COM_INTERFACE_ENTRY(IShellPropSheetExt)
    END_COM_MAP()
        DECLARE_NO_REGISTRY()

        // IShellExtInit
        STDMETHODIMP Initialize (LPCITEMIDLIST pidlFolder,LPDATAOBJECT lpdobj,HKEY hkeyProgID);

        // IShellPropSheetExt
        STDMETHODIMP AddPages (LPFNADDPROPSHEETPAGE lpfnAddPage,LPARAM lParam);
        STDMETHODIMP ReplacePage (UINT uPageID,LPFNADDPROPSHEETPAGE lpfnReplacePage,LPARAM lParam) {return E_NOTIMPL;};

        // IContextMenu
        STDMETHODIMP QueryContextMenu (HMENU hmenu,UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);
        STDMETHODIMP InvokeCommand    (LPCMINVOKECOMMANDINFO lpici);
        STDMETHODIMP GetCommandString (UINT_PTR idCmd, UINT uType,UINT* pwReserved,LPSTR pszName,UINT cchMax);
        ~CShellExt ();
        CShellExt ();
};

class ATL_NO_VTABLE CWiaUIExtension :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CWiaUIExtension, &CLSID_TestUIExtension>,
    public IWiaUIExtension
{
    public:

        CWiaUIExtension ();
        ~CWiaUIExtension ();

        DECLARE_REGISTRY_RESOURCEID(IDR_VIEWREG)
        DECLARE_PROTECT_FINAL_CONSTRUCT()
        BEGIN_COM_MAP(CWiaUIExtension)
            COM_INTERFACE_ENTRY(IWiaUIExtension)
        END_COM_MAP()

        //
        // IWiaUIExtension
        //
        STDMETHODIMP DeviceDialog( PDEVICEDIALOGDATA pDeviceDialogData );
        STDMETHODIMP GetDeviceIcon( BSTR bstrDeviceId, HICON *phIcon, ULONG nSize );
        STDMETHODIMP GetDeviceBitmapLogo( BSTR bstrDeviceId, HBITMAP *phBitmap, ULONG nMaxWidth, ULONG nMaxHeight );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\extend\dll\resource.h ===
//(C) COPYRIGHT MICROSOFT CORP., 1998-1999
#define IDR_CMENU                       101
#define IDC_LOGOBMP                     102
#define IDD_DEVICE_PROPPAGE             106
#define IDC_IMAGEROOT                   1000
#define ID_CHANGEROOT                  40001
#define IDS_ERRCAPTION                  40002
#define IDS_ERRPROPSET                  40003
#define IDS_BADPATH                     40004
#define IDS_BROWSETITLE                 40005

#define IDR_VIEWREG                     2001

#define IDI_TESTDEVICE                  2005
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\extend\dll\extend.cpp ===
////////////////////////////////////
// (C) COPYRIGHT MICROSOFT CORP., 1998-1999
//
// FILE: EXTEND.CPP
//
// DESCRIPTION: Implements core DLL routines as well as web view extensions.
//
#include "precomp.h"
#pragma hdrstop
#include <string.h>
#include <tchar.h>
#include "resource.h"

#include "extidl_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TestShellExt,  CShellExt)
OBJECT_ENTRY(CLSID_TestUIExtension,  CWiaUIExtension)
END_OBJECT_MAP()


STDAPI DllRegisterServer(void)
{

    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}


STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}


EXTERN_C
BOOL
DllMain(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:

            _Module.Init (ObjectMap, hinst);
            DisableThreadLibraryCalls(hinst);

            break;

        case DLL_PROCESS_DETACH:
            _Module.Term();
            break;
    }
    return TRUE;
}


extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return _Module.GetLockCount()==0 ? S_OK : S_FALSE;
}

extern "C" STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);

}


/*****************************************************************************

ShowMessage

Utility function for displaying messageboxes

******************************************************************************/

BOOL ShowMessage (HWND hParent, INT idCaption, INT idMessage)
{
    MSGBOXPARAMS mbp;
    BOOL bRet;
    INT  i;

    ZeroMemory (&mbp, sizeof(mbp));
    mbp.cbSize = sizeof(mbp);
    mbp.hwndOwner = hParent;
    mbp.hInstance = g_hInst;
    mbp.lpszText = MAKEINTRESOURCE(idMessage);
    mbp.lpszCaption = MAKEINTRESOURCE(idCaption);
    mbp.dwStyle = MB_OK | MB_APPLMODAL;

    i = MessageBoxIndirect (&mbp);
    bRet = (IDOK==i);
    return bRet;
}

/*****************************************************************************

FindLastID

Utility for getting the last relative pidl from a full pidl

******************************************************************************/
// unsafe macros
#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)

LPITEMIDLIST
FindLastID(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlLast = pidl;
    LPCITEMIDLIST pidlNext = pidl;

    if (pidl == NULL)
        return NULL;

    // Find the last one
    while (pidlNext->mkid.cb)
    {
        pidlLast = pidlNext;
        pidlNext = ILNext(pidlLast);
    }

    return (LPITEMIDLIST)pidlLast;
}

/*****************************************************************************

CreateDeviceFromID

Utility for attaching to WIA and getting a root IWiaItem interface

*****************************************************************************/
HRESULT
CreateDeviceFromId (LPWSTR szDeviceId, IWiaItem **ppItem)
{
    IWiaDevMgr *pDevMgr;
    HRESULT hr = CoCreateInstance (CLSID_WiaDevMgr,
                                   NULL,
                                   CLSCTX_LOCAL_SERVER,
                                   IID_IWiaDevMgr,
                                   reinterpret_cast<LPVOID*>(&pDevMgr));
    if (SUCCEEDED(hr))
    {
        BSTR strId = SysAllocString (szDeviceId);
        hr = pDevMgr->CreateDevice (strId, ppItem);
        SysFreeString (strId);
        pDevMgr->Release ();
    }
    return hr;
}

/*****************************************************************************\

    GetNamesFromDataObject

    Return the list of selected item identifiers. Each identifier is of the form
    "<DEVICEID>::<FULL PATH NAME>". the list is double-null terminated

*****************************************************************************/

LPWSTR
GetNamesFromDataObject (IDataObject *lpdobj, UINT *puItems)
{
    FORMATETC fmt;
    STGMEDIUM stg;
    LPWSTR szRet = NULL;
    LPWSTR szCurrent;
    UINT nItems;
    size_t size;
    if (puItems)
    {
        *puItems = 0;
    }

    fmt.cfFormat = (CLIPFORMAT) RegisterClipboardFormat (TEXT("WIAItemNames"));
    fmt.dwAspect = DVASPECT_CONTENT;
    fmt.lindex = -1;
    fmt.ptd = NULL;
    fmt.tymed = TYMED_HGLOBAL;

    if (lpdobj && puItems && SUCCEEDED(lpdobj->GetData (&fmt, &stg)))
    {
        szCurrent = reinterpret_cast<LPWSTR>(GlobalLock (stg.hGlobal));

        // count the number of items in the double-null terminated string
        szRet  = szCurrent;
        nItems = 0;
        while (*szRet)
        {
            nItems++;
            while (*szRet)
            {
                szRet++;
            }
            szRet++;
        }
        *puItems = nItems;
        size = (szRet-szCurrent+1)*sizeof(WCHAR);
        szRet = new WCHAR[size];
        CopyMemory (szRet, szCurrent, size);
        GlobalUnlock (stg.hGlobal);
        GlobalFree (stg.hGlobal);
    }
    return szRet;
}

CWiaUIExtension::CWiaUIExtension(void)
{
}

CWiaUIExtension::~CWiaUIExtension(void)
{
}

//
// IWiaUIExtension
//
STDMETHODIMP CWiaUIExtension::DeviceDialog( PDEVICEDIALOGDATA pDeviceDialogData )
{
    //
    // We are not going to implement an actual device dialog here.  Just say "hi" and return.
    //
    MessageBox( NULL, TEXT("CWiaUIExtension::DeviceDialog is being called"), TEXT("DEBUG"), 0 );
    return E_NOTIMPL;
}

STDMETHODIMP CWiaUIExtension::GetDeviceIcon( BSTR bstrDeviceId, HICON *phIcon, ULONG nSize )
{
    //
    // Load an icon, and copy it, using CopyIcon, so it will still be valid if our interface is freed
    //
    HICON hIcon = reinterpret_cast<HICON>(LoadImage( _Module.m_hInst, MAKEINTRESOURCE(IDI_TESTDEVICE), IMAGE_ICON, nSize, nSize, LR_DEFAULTCOLOR ));
    if (hIcon)
    {
        *phIcon = CopyIcon(hIcon);
        DestroyIcon(hIcon);
        return S_OK;
    }
    return E_NOTIMPL;
}

STDMETHODIMP CWiaUIExtension::GetDeviceBitmapLogo( BSTR bstrDeviceId, HBITMAP *phBitmap, ULONG nMaxWidth, ULONG nMaxHeight )
{
    //
    // This method is never actually called currently.  It is only here for future use.
    //
    MessageBox( NULL, TEXT("CWiaUIExtension::GetDeviceBitmapLogo is being called"), TEXT("DEBUG"), 0 );
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\extend\dll\precomp.h ===
//(C) COPYRIGHT MICROSOFT CORP., 1998-1999
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#define _ATL_NO_UUIDOF
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#include <initguid.h>
#include <shlguid.h>
#include "wiadevd.h"
#include "extidl.h"
#include "wia.h"
#include "resource.h"
#include "extend.h"
#include "classes.h"

// tcamprop defines the private test cam properties
#include "tcamprop.h"
#define g_hInst _Module.GetModuleInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\extend\dll\tcamprop.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       TCamProp.H
*
*  VERSION:     1.0
*
*  DATE:        16 May, 1999
*
*  DESCRIPTION:
*   Definitions and declarations for test camera's private properties.
*
*******************************************************************************/

#ifndef __TCAMPROP_H__
#define __TCAMPROP_H__

#include  <guiddef.h>

//
// Path where test camera builds its item tree, BSTR & RW
//

#define  WIA_DPP_TCAM_ROOT_PATH         WIA_PRIVATE_DEVPROP
#define  WIA_DPP_TCAM_ROOT_PATH_STR     L"Test Camera Root Path"

//
// Private event after the Root Path is changed
//

const GUID WIA_EVENT_NAME_CHANGE =
{ /* 88f80f75-af08-11d2-a094-00c04f72dc3c */
    0x88f80f75,
    0xaf08,
    0x11d2,
    {0xa0, 0x94, 0x00, 0xc0, 0x4f, 0x72, 0xdc, 0x3c}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\extend\dll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
#pragma hdrstop

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\inc\prwiziid.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       prwiziid.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        12/15/00
 *
 *  DESCRIPTION: Define clsid/iids for this project
 *
 *****************************************************************************/

#ifndef _PHOTO_PRINT_WIZARD_IIDS_H_
#define _PHOTO_PRINT_WIZARD_IIDS_H_


//CLSID_PrintPhotoshDropTarget  {60fd46de-f830-4894-a628-6fa81bc0190d}
DEFINE_GUID(CLSID_PrintPhotosDropTarget, 0x60fd46de, 0xf830, 0x4894, 0xa6, 0x28, 0x6f, 0xa8, 0x1b, 0xc0, 0x19, 0x0d);


#undef INTERFACE
#define INTERFACE IPrintPhotosWizardSetInfo
//
// IPrintPhotosWizardSetInfo is meant as a way to get information
// to the wizard from outside objects/classes.  Primarily, we use
// this as a way to transfer a dataobject to the wizard that holds
// all of the items we want to print.
//
DECLARE_INTERFACE_(IPrintPhotosWizardSetInfo, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IPrintPhotosWizardSetInfo methods
    STDMETHOD(SetFileListDataObject) (THIS_ IN IDataObject * pdo);
    STDMETHOD(SetFileListArray) (THIS_ IN LPITEMIDLIST *aidl, IN int cItems, IN int iSelectedItem);
    STDMETHOD(RunWizard) (THIS_ VOID);
};

typedef HRESULT (*LPFNPPWPRINTTO)(LPCMINVOKECOMMANDINFO pCMI,IDataObject * pdtobj);
#define PHOTO_PRINT_WIZARD_PRINTTO_ENTRY "UsePPWForPrintTo"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\extend\dll\shellext.cpp ===
///////////////////
// (C) COPYRIGHT MICROSOFT CORP., 1998-1999
//
// FILE: SHELLEXT.CPP
//
// DESCRIPTION: Implements IContextMenu and IShellPropSheetExt interfaces for
// the WIA test camera device
//
#include "precomp.h"
#pragma hdrstop

// Define a language-independent name for our menu verb
static const CHAR  g_PathVerbA[] = "ChangeRoot";
static const WCHAR g_PathVerbW[] = L"ChangeRoot";


/*****************************************************************************

CShellExt::CShellExt



******************************************************************************/

CShellExt :: CShellExt ()
{

}

/*****************************************************************************

CShellExt::~CShellExt



******************************************************************************/

CShellExt::~CShellExt ()
{



}


/*****************************************************************************

CShellExt::Initialize

Called by the shell when the user invokes context menu or property sheet for
one of our items. For context menus the dataobject may include more than one
selected item.

******************************************************************************/

STDMETHODIMP CShellExt::Initialize (LPCITEMIDLIST pidlFolder,
                                    LPDATAOBJECT lpdobj,
                                    HKEY hkeyProgID)
{

    LONG lType = 0;
    HRESULT hr = NOERROR;
    if (!lpdobj)
    {
        return E_INVALIDARG;
    }


    // For singular selections, the WIA namespace should always provide a
    // dataobject that also supports IWiaItem

    if (FAILED(lpdobj->QueryInterface (IID_IWiaItem, reinterpret_cast<LPVOID*>(&m_pItem))))
    {
        // failing that, get the list of selected items from the data object
        UINT uItems = 0;
        LPWSTR szName;
        LPWSTR szToken;
        IWiaItem *pDevice;

        szName = GetNamesFromDataObject (lpdobj, &uItems);
        // we only support singular objects
        if (uItems != 1)
        {
            hr = E_FAIL;
        }
        else
        {
            // The name is of this format: <device id>::<item name>
            LPWSTR szToken = wcstok (szName, L":");
            if (!szToken)
            {
                hr = E_FAIL;
            }
            // Our extension only supports root items, so make sure there's no item
            // name
            else if (wcstok (NULL, L":"))
            {
                hr = E_FAIL;
            }
            else
            {
                hr = CreateDeviceFromId (szToken, &m_pItem);
            }
        }
        if (szName)
        {
            delete [] szName;
        }
    }
    if (SUCCEEDED(hr))
    {

        m_pItem->GetItemType (&lType);
        if (!(lType & WiaItemTypeRoot))
        {
            hr = E_FAIL; // we only support changing the property on the root item
        }
    }
    return hr;
}

/*****************************************************************************

CShellExt::AddPages

Called by the shell to get our property pages.

******************************************************************************/

STDMETHODIMP CShellExt::AddPages (LPFNADDPROPSHEETPAGE lpfnAddPage,LPARAM lParam)
{
    HPROPSHEETPAGE hpsp;
    PROPSHEETPAGE psp;

    HRESULT hr = E_FAIL;
    // We only have 1 page.
    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = g_hInst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_DEVICE_PROPPAGE);
    psp.pfnDlgProc = PropPageProc;
    psp.lParam = reinterpret_cast<LPARAM>(this);

    hpsp = CreatePropertySheetPage (&psp);
    if (hpsp)
    {
        hr = (*lpfnAddPage) (hpsp, lParam) ? NOERROR:E_FAIL;
        if (SUCCEEDED(hr))
        {
            InternalAddRef (); // the propsheetpage will release us when it is destroyed
        }
    }
    return E_FAIL;
}

/*****************************************************************************

CShellExt::QueryContextMenu

Called by the shell to get our context menu strings for the selected item.

******************************************************************************/

STDMETHODIMP CShellExt::QueryContextMenu (HMENU hmenu,UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags)
{
    MENUITEMINFO mii;
    TCHAR szPathRoot[MAX_PATH];
    // insert our only menu item at index indexMenu. Remember the cmd value.

    LoadString (g_hInst, ID_CHANGEROOT, szPathRoot, MAX_PATH);
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_STRING | MIIM_ID;
    mii.fState = MFS_ENABLED;
    mii.wID = idCmdFirst;
    mii.dwTypeData = szPathRoot;
    m_idCmd = 0; // we only have 1 item.
    if (InsertMenuItem (hmenu, indexMenu, TRUE, &mii))
    {

        return MAKE_HRESULT(SEVERITY_SUCCESS, 0, 1);
    }
    return E_FAIL;
}

/*****************************************************************************

CShellExt::InvokeCommand

Called by the shell when the user clicks one of our menu items

******************************************************************************/

STDMETHODIMP CShellExt::InvokeCommand    (LPCMINVOKECOMMANDINFO lpici)
{
    UINT_PTR idCmd = reinterpret_cast<UINT_PTR>(lpici->lpVerb);
    if (idCmd == m_idCmd)
    {
        return GetNewRootPath (lpici->hwnd);
    }
    // it wasn't our verb.
    return E_FAIL;
}

/*****************************************************************************

CShellExt::GetCommandString

Called by the shell to get our language independent verb name.

******************************************************************************/

STDMETHODIMP CShellExt::GetCommandString (UINT_PTR idCmd, UINT uType,UINT* pwReserved,LPSTR pszName,UINT cchMax)
{

    if (idCmd != m_idCmd)
    {
        // not our verb
        return E_FAIL;
    }

    switch (uType)
    {
        case GCS_VALIDATEA:

            if (pszName)
            {
                lstrcpyA (pszName, g_PathVerbA);
            }
            return S_OK;
        case GCS_VALIDATEW:

            if (pszName)
            {
                lstrcpyW (reinterpret_cast<LPWSTR>(pszName), g_PathVerbW);
            }
            return S_OK;

        case GCS_VERBA:

            lstrcpyA (pszName, g_PathVerbA);
            break;

        case GCS_VERBW:

            lstrcpyW (reinterpret_cast<LPWSTR>(pszName), g_PathVerbW);
            break;

        default:
            return E_FAIL;
    }

    return NOERROR;
}


/*****************************************************************************

GetSetRootPath

Utility function for setting or retrieving the test camera's root path property

******************************************************************************/

HRESULT GetSetRootPath (IWiaItem *pCamera, LPTSTR pszPath, BOOL bSet)
{
    IWiaPropertyStorage *pps;
    HRESULT hr;
    PROPVARIANT pv;
    PROPSPEC ps;

    ps.ulKind = PRSPEC_PROPID;
    ps.propid = WIA_DPP_TCAM_ROOT_PATH;


    hr = pCamera->QueryInterface (IID_IWiaPropertyStorage, reinterpret_cast<LPVOID*>(&pps));
    if (SUCCEEDED(hr))
    {
        if (!bSet) // retrieval
        {
            *pszPath = TEXT('\0');
            hr = pps->ReadMultiple (1, &ps, &pv);
            if (SUCCEEDED(hr))
            {
                #ifdef UNICODE
                lstrcpy (pszPath, pv.bstrVal);
                #else
                WideCharToMultiByte (CP_ACP, 0,
                                     pv.bstrVal, -1,
                                     pszPath, MAX_PATH,
                                     NULL, NULL);
                #endif //UNICODE
                SysFreeString (pv.bstrVal);
            }
        }
        else // assignment
        {

            pv.vt = VT_BSTR;

            #ifdef UNICODE
            pv.bstrVal =SysAllocString ( pszPath);
            #else
            INT len = lstrlen(pszPath);
            LPWSTR pwszVal = new WCHAR[len+1];
            MultiByteToWideChar (CP_ACP, 0, pszPath, -1, pwszVal, len+1);
            pv.bstrVal =SysAllocString ( pwszVal);
            delete [] pwszVal;
            #endif // UNICODE
            hr = pps->WriteMultiple (1, &ps, &pv, 2);
            SysFreeString (pv.bstrVal);
        }
    }
    if (pps)
    {
        pps->Release ();
    }
    return hr;
}

/*****************************************************************************

CShellExt::PropPageProc

Dialog procedure for the simple property sheet page.

******************************************************************************/

INT_PTR CALLBACK CShellExt::PropPageProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    CShellExt *pThis;

    pThis = reinterpret_cast<CShellExt *>(GetWindowLongPtr (hwnd, DWLP_USER));
    TCHAR szPath[MAX_PATH] ;
    INT_PTR iRet = TRUE;
    switch (msg)
    {
        case WM_INITDIALOG:
            pThis = reinterpret_cast<CShellExt *>(reinterpret_cast<LPPROPSHEETPAGE>(lp)->lParam);
            SetWindowLongPtr (hwnd, DWLP_USER, reinterpret_cast<LONG_PTR>(pThis));
            GetSetRootPath (pThis->m_pItem, szPath, FALSE);
            SetDlgItemText (hwnd, IDC_IMAGEROOT, szPath);
            break;

        case WM_COMMAND:
            if (LOWORD(wp) == IDC_IMAGEROOT && HIWORD(wp) == EN_CHANGE)
            {
                SendMessage(GetParent(hwnd),
                            PSM_CHANGED,
                            reinterpret_cast<WPARAM>(hwnd), 0);
                return TRUE;
            }
            iRet = FALSE;
            break;
        case WM_NOTIFY:
        {
            LONG lCode = PSNRET_NOERROR;
            LPPSHNOTIFY psn = reinterpret_cast<LPPSHNOTIFY>(lp);
            switch (psn->hdr.code)
            {
                case PSN_APPLY:
                    // Set the new root path property
                    GetDlgItemText (hwnd, IDC_IMAGEROOT, szPath, MAX_PATH);
                    if (FAILED(GetSetRootPath (pThis->m_pItem, szPath, TRUE)))
                    {
                        ::ShowMessage (hwnd, IDS_ERRCAPTION, IDS_ERRPROPSET);
                        lCode = PSNRET_INVALID_NOCHANGEPAGE;
                    }
                    break;

                case PSN_KILLACTIVE:
                    // Validate the new path is valid
                    GetDlgItemText (hwnd, IDC_IMAGEROOT, szPath, MAX_PATH);
                    if (! (GetFileAttributes(szPath) & FILE_ATTRIBUTE_DIRECTORY))
                    {
                        ::ShowMessage (hwnd, IDS_ERRCAPTION, IDS_BADPATH);
                        lCode = TRUE;
                    }
                    break;

                default:
                    iRet = FALSE;
                    break;
            }
            SetWindowLongPtr (hwnd, DWLP_MSGRESULT, lCode);
        }
            break;
        case WM_CLOSE:
            pThis->InternalRelease ();
            break;

        default:
            iRet = FALSE;
            break;

    }
    return iRet;
}

/*****************************************************************************
BrowseCallback

Sets the default selection in the folder selection dialog to the current
camera image root path

******************************************************************************/

INT CALLBACK BrowseCallback (HWND hwnd, UINT msg, LPARAM lp, WPARAM wp)
{
    IWiaItem *pItem = reinterpret_cast<IWiaItem*>(lp);
    if (BFFM_INITIALIZED == msg)
    {

        TCHAR szPath[MAX_PATH];

        // find the current root path
        GetSetRootPath (pItem, szPath, FALSE);
        // send the appropriate message to the dialog
        SendMessage (hwnd,
                     BFFM_SETSELECTION,
                     reinterpret_cast<LPARAM>(szPath),
                     TRUE);


    }
    return 0;
}


/*****************************************************************************

CShellExt::GetNewRootPath

Invoked in response to choosing our context menu item

******************************************************************************/

HRESULT CShellExt::GetNewRootPath(HWND hwnd)
{
    BROWSEINFO bi;
    LPITEMIDLIST pidl;
    TCHAR szPath[MAX_PATH];
    TCHAR szTitle[MAX_PATH];


    // Init the dialog with the current path

    LoadString (g_hInst, IDS_BROWSETITLE, szTitle, MAX_PATH);
    bi.hwndOwner = hwnd;
    bi.pidlRoot = NULL;
    bi.pszDisplayName = szPath;
    bi.lpszTitle = szTitle;
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_USENEWUI | BIF_EDITBOX;
    bi.lpfn = NULL;


    pidl = SHBrowseForFolder (&bi);
    if (pidl)
    {
        SHGetPathFromIDList (pidl, szPath);
        if (FAILED(GetSetRootPath (m_pItem, szPath, TRUE)))
        {
            ::ShowMessage (hwnd, IDS_ERRCAPTION, IDS_ERRPROPSET);
            return S_FALSE;
        }
        return NOERROR;
    }
    return S_FALSE; // don't return failure code to the shell.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\inc\pviewids.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       PVIEWIDS.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        8/12/1999
 *
 *  DESCRIPTION: Message and other constants used by the preview control
 *
 *******************************************************************************/
#ifndef __PVIEWIDS_H_INCLUDED
#define __PVIEWIDS_H_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#define IDC_INNER_PREVIEW_WINDOW 23401

void WINAPI RegisterWiaPreviewClasses( HINSTANCE hInstance );

/**************************************************************
 *
 * Window class names
 *
 **************************************************************/
#define PREVIEW_WINDOW_CLASSW       L"WiaPreviewControl"
#define PREVIEW_WINDOW_CLASSA        "WiaPreviewControl"

#define PREVIEW_WINDOW_FRAME_CLASSW L"WiaPreviewControlFrame"
#define PREVIEW_WINDOW_FRAME_CLASSA  "WiaPreviewControlFrame"

#if defined(UNICODE) || defined(_UNICODE)
#define PREVIEW_WINDOW_CLASS        PREVIEW_WINDOW_CLASSW
#define PREVIEW_WINDOW_FRAME_CLASS  PREVIEW_WINDOW_FRAME_CLASSW
#else
#define PREVIEW_WINDOW_CLASS        PREVIEW_WINDOW_CLASSA
#define PREVIEW_WINDOW_FRAME_CLASS  PREVIEW_WINDOW_FRAME_CLASSA
#endif


/**************************************************************
 *
 * Notification codes, sent via WM_COMMAND
 *
 **************************************************************/
#define PWN_SELCHANGE              1


/**************************************************************
 *
 * Messages and flags
 *
 **************************************************************/
//wParam = 0, lParam = LPSIZE lpResolution
#define PWM_SETRESOLUTION         (WM_USER+601)

//wParam = 0, lParam = 0
#define PWM_CLEARSELECTION            (WM_USER+602)

//wParam = 0, lParam = LPSIZE pSize
#define PWM_GETIMAGESIZE          (WM_USER+603)

// wParam = MAKEWPARAM(bRepaint,bDontDestroy), lParam = (HBITMAP)hBmp
#define PWM_SETBITMAP             (WM_USER+604)

// wParam = 0, lParam = 0
#define PWM_GETBITMAP             (WM_USER+605)

// wParam = 0, lParam = LPSIZE lpResolution
#define PWM_GETRESOLUTION         (WM_USER+606)

// wParam = bOuter, lParam = 0
#define PWM_GETBORDERSIZE         (WM_USER+607)

// wParam = 0, lParam = 0
#define PWM_GETHANDLESIZE         (WM_USER+608)

// wParam = 0, lParam = 0
#define PWM_GETBGALPHA            (WM_USER+609)

// wParam = 0, lParam = 0
#define PWM_GETHANDLETYPE         (WM_USER+610)

// wParam = (BOOL)MAKEWPARAM(bRepaint,bOuter), lParam = (UINT)nBorderSize
#define PWM_SETBORDERSIZE         (WM_USER+611)

// wParam = (BOOL)bRepaint, lParam = (UINT)nHandleSize
#define PWM_SETHANDLESIZE         (WM_USER+612)

// wParam = (BOOL)bRepaint, lParam = (BYTE)nAlpha
#define PWM_SETBGALPHA            (WM_USER+613)

#define PREVIEW_WINDOW_SQUAREHANDLES 0x00000000
#define PREVIEW_WINDOW_ROUNDHANDLES  0x00000001
#define PREVIEW_WINDOW_FILLEDHANDLES 0x00000000
#define PREVIEW_WINDOW_HOLLOWHANDLES 0x00010000

// wParam = (BOOL)bRepaint, lParam = (int)nHandleType
#define PWM_SETHANDLETYPE         (WM_USER+614)

// wParam = 0, lParam = 0
#define PWM_GETSELCOUNT           (WM_USER+615)

// wParam = (BOOL)MAKEWPARAM((WORD)nItem,(BOOL)bPhysical), lParam = (PPOINT)pOrigin
#define PWM_GETSELORIGIN          (WM_USER+616)

// wParam = (BOOL)MAKEWPARAM((WORD)nItem,(BOOL)bPhysical), lParam = (PSIZE)pExtent
#define PWM_GETSELEXTENT          (WM_USER+617)

// wParam = 0, lParam = 0
#define PWM_GETALLOWNULLSELECTION (WM_USER+618)

// wParam = (BOOL)bAllowNullSelection, lParam = 0
#define PWM_SETALLOWNULLSELECTION (WM_USER+619)

// wParam = 0, lParam = 0
#define PWM_SELECTIONDISABLED     (WM_USER+620)

// wParam = (BOOL)bDisableSelection, lParam = 0
#define PWM_DISABLESELECTION      (WM_USER+621)

// wParam = 0, lParam = 0
#define PWM_DETECTREGIONS         (WM_USER+622)

// wParam = MAKEWPARAM(bOuterBorder,0), lParam = 0
#define PWM_GETBKCOLOR            (WM_USER+623)

// wParam = MAKEWPARAM(bOuterBorder,bRepaint), lParam = (COLORREF)color
#define PWM_SETBKCOLOR            (WM_USER+624)

// wParam = 0, lParam = (LPSIZE)pSize
#define PWM_SETDEFASPECTRATIO     (WM_USER+625)

// wParam = 0, lParam = (BOOL)bPreviewMode
#define PWM_SETPREVIEWMODE        (WM_USER+626)

// wParam = 0, lParam = 0
#define PWM_GETPREVIEWMODE        (WM_USER+627)

// wParam = MAKEWPARAM(bRepaint,0), lParam = MAKELPARAM(nBorderStyle,nBorderThickness)
#define PWM_SETBORDERSTYLE        (WM_USER+628)

#define PREVIEW_WINDOW_SELECTED    0x00000000
#define PREVIEW_WINDOW_UNSELECTED  0x00000001
#define PREVIEW_WINDOW_DISABLED    0x00000002

// wParam = MAKEWPARAM(bRepaint,nState), lParam = (COLORREF)crColor
#define PWM_SETBORDERCOLOR        (WM_USER+629)

// wParam = MAKEWPARAM(bRepaint,nState), lParam = (COLORREF)crColor
#define PWM_SETHANDLECOLOR        (WM_USER+630)

// wParam = 0, lParam = (SIZE *)psizeClient
#define PWM_GETCLIENTSIZE         (WM_USER+631)

// wParam = 0, lParam = BOOL bEnable
#define PWM_SETENABLESTRETCH         (WM_USER+632)

// wParam = 0, lParam = 0
#define PWM_GETENABLESTRETCH         (WM_USER+633)

// wParam = 0, lParam = bHide
#define PWM_HIDEEMPTYPREVIEW         (WM_USER+634)

#define PREVIEW_WINDOW_CENTER      0x0000
#define PREVIEW_WINDOW_RIGHT       0x0001
#define PREVIEW_WINDOW_LEFT        0x0002
#define PREVIEW_WINDOW_TOP         0x0004
#define PREVIEW_WINDOW_BOTTOM      0x0008

// wParam = bRedraw, lParam = MAKELPARAM(horz,vert)
#define PWM_SETPREVIEWALIGNMENT      (WM_USER+635)

// wParam = (BOOL)MAKEWPARAM((WORD)nItem,(BOOL)bPhysical), lParam = (PPOINT)pOrigin
#define PWM_SETSELORIGIN          (WM_USER+636)

// wParam = (BOOL)MAKEWPARAM((WORD)nItem,(BOOL)bPhysical), lParam = (PSIZE)pExtent
#define PWM_SETSELEXTENT          (WM_USER+637)

// wParam = 0, LPARAM = 0
#define PWM_REFRESHBITMAP         (WM_USER+638)

//
// wParam = bShow, lParam = 0
//
#define PWM_SETPROGRESS          (WM_USER+639)

//
// wParam = 0, lParam = 0
//
#define PWM_GETPROGRESS          (WM_USER+640)

//
// wParam = BOOL bUserChanged, lParam = 0
//
#define PWM_SETUSERCHANGEDSELECTION (WM_USER+641)

//
// wParam = 0, lParam = 0
//
#define PWM_GETUSERCHANGEDSELECTION (WM_USER+642)

/**************************************************************
 *
 * inline WINAPI message wrapper helpers
 *
 **************************************************************/
#ifdef __cplusplus  // C doesn't know what inline WINAPI is...

inline void WINAPI WiaPreviewControl_SetResolution( HWND hWnd, SIZE *pResolution)
{
    ::SendMessage( hWnd, PWM_SETRESOLUTION, 0, reinterpret_cast<LPARAM>(pResolution) );
}

inline void WINAPI WiaPreviewControl_ClearSelection( HWND hWnd )
{
    ::SendMessage( hWnd, PWM_CLEARSELECTION, 0, 0 );
}

inline BOOL WINAPI WiaPreviewControl_GetImageSize( HWND hWnd, SIZE *pSize )
{
    return static_cast<BOOL>(::SendMessage( hWnd, PWM_GETIMAGESIZE, 0, reinterpret_cast<LPARAM>(pSize)));
}

inline void WINAPI WiaPreviewControl_SetBitmap( HWND hWnd, BOOL bRepaint, BOOL bDontDestroy, HBITMAP hBitmap )
{
    ::SendMessage( hWnd, PWM_SETBITMAP, MAKEWPARAM(bRepaint,bDontDestroy), reinterpret_cast<LPARAM>(hBitmap) );
}

inline HBITMAP WINAPI WiaPreviewControl_GetBitmap( HWND hWnd )
{
    return reinterpret_cast<HBITMAP>(::SendMessage( hWnd, PWM_GETBITMAP, 0, 0 ));
}

inline BOOL WINAPI WiaPreviewControl_GetResolution( HWND hWnd, SIZE *pResolution )
{
    return static_cast<BOOL>(::SendMessage( hWnd, PWM_GETRESOLUTION, 0, reinterpret_cast<LPARAM>(pResolution)));
}

inline UINT WINAPI WiaPreviewControl_GetBorderSize( HWND hWnd, BOOL bOuter )
{
    return static_cast<UINT>(::SendMessage( hWnd, PWM_GETBORDERSIZE, bOuter, 0 ));
}

inline UINT WINAPI WiaPreviewControl_GetHandleSize( HWND hWnd )
{
    return static_cast<UINT>(::SendMessage( hWnd, PWM_GETHANDLESIZE, 0, 0 ));
}

inline BYTE WINAPI WiaPreviewControl_GetBgAlpha( HWND hWnd )
{
    return static_cast<BYTE>(::SendMessage( hWnd, PWM_GETBGALPHA, 0, 0 ));
}

inline int WINAPI WiaPreviewControl_GetHandleType( HWND hWnd )
{
    return static_cast<int>(::SendMessage( hWnd, PWM_GETHANDLETYPE, 0, 0 ));
}

inline void WINAPI WiaPreviewControl_SetBorderSize( HWND hWnd, BOOL bRepaint, BOOL bOuter, UINT nBorderSize )
{
    ::SendMessage( hWnd, PWM_SETBORDERSIZE, MAKEWPARAM(bRepaint,bOuter), nBorderSize );
}

inline void WINAPI WiaPreviewControl_SetHandleSize( HWND hWnd, BOOL bRepaint, UINT nHandleSize )
{
    ::SendMessage( hWnd, PWM_SETHANDLESIZE, bRepaint, nHandleSize );
}

inline void WINAPI WiaPreviewControl_SetBgAlpha( HWND hWnd, BOOL bRepaint, BYTE nAlpha )
{
    ::SendMessage( hWnd, PWM_SETBGALPHA, bRepaint, nAlpha );
}

inline void WINAPI WiaPreviewControl_SetHandleType( HWND hWnd, BOOL bRepaint, int nHandleType )
{
    ::SendMessage( hWnd, PWM_SETHANDLETYPE, bRepaint, nHandleType );
}

inline WORD WINAPI WiaPreviewControl_GetSelCount( HWND hWnd )
{
    return static_cast<WORD>(::SendMessage( hWnd, PWM_GETSELCOUNT, 0, 0 ));
}

inline BOOL WINAPI WiaPreviewControl_GetSelOrigin( HWND hWnd, WORD nItem, BOOL bPhysical, POINT *pOrigin  )
{
    return static_cast<BOOL>(::SendMessage( hWnd, PWM_GETSELORIGIN, MAKEWPARAM(nItem,bPhysical), reinterpret_cast<LPARAM>(pOrigin)));
}

inline BOOL WINAPI WiaPreviewControl_GetSelExtent( HWND hWnd, WORD nItem, BOOL bPhysical, SIZE *pExtent  )
{
    return static_cast<BOOL>(::SendMessage( hWnd, PWM_GETSELEXTENT, MAKEWPARAM(nItem,bPhysical), reinterpret_cast<LPARAM>(pExtent)));
}

inline BOOL WINAPI WiaPreviewControl_SetSelOrigin( HWND hWnd, WORD nItem, BOOL bPhysical, POINT *pOrigin  )
{
    return static_cast<BOOL>(::SendMessage( hWnd, PWM_SETSELORIGIN, MAKEWPARAM(nItem,bPhysical), reinterpret_cast<LPARAM>(pOrigin)));
}

inline BOOL WINAPI WiaPreviewControl_SetSelExtent( HWND hWnd, WORD nItem, BOOL bPhysical, SIZE *pExtent  )
{
    return static_cast<BOOL>(::SendMessage( hWnd, PWM_SETSELEXTENT, MAKEWPARAM(nItem,bPhysical), reinterpret_cast<LPARAM>(pExtent)));
}

inline BOOL WINAPI WiaPreviewControl_NullSelectionAllowed( HWND hWnd )
{
    return static_cast<BOOL>(::SendMessage( hWnd, PWM_GETALLOWNULLSELECTION, 0, 0 ));
}

inline void WINAPI WiaPreviewControl_AllowNullSelection( HWND hWnd, BOOL bAllowNullSelection )
{
    ::SendMessage( hWnd, PWM_SETALLOWNULLSELECTION, bAllowNullSelection, 0 );
}

inline BOOL WINAPI WiaPreviewControl_SelectionDisabled( HWND hWnd )
{
    return static_cast<BOOL>(::SendMessage( hWnd, PWM_SELECTIONDISABLED, 0, 0 ));
}

inline void WINAPI WiaPreviewControl_DisableSelection( HWND hWnd, BOOL bDisableSelection )
{
    ::SendMessage( hWnd, PWM_DISABLESELECTION, bDisableSelection, 0 );
}

inline BOOL WINAPI WiaPreviewControl_DetectRegions( HWND hWnd )
{
    return static_cast<BOOL>(::SendMessage( hWnd, PWM_DETECTREGIONS, 0, 0 ));
}

inline COLORREF WINAPI WiaPreviewControl_GetBkColor( HWND hWnd, BOOL bOuterBorder )
{
    return static_cast<COLORREF>(::SendMessage( hWnd, PWM_GETBKCOLOR, MAKEWPARAM(bOuterBorder,0), 0 ));
}

inline void WINAPI WiaPreviewControl_SetBkColor( HWND hWnd, BOOL bRepaint, BOOL bOuterBorder, COLORREF color )
{
    ::SendMessage( hWnd, PWM_SETBKCOLOR, MAKEWPARAM(bOuterBorder,bRepaint), color );
}

inline void WINAPI WiaPreviewControl_SetDefAspectRatio( HWND hWnd, SIZE *pAspectRatio )
{
    ::SendMessage( hWnd, PWM_SETDEFASPECTRATIO, 0, reinterpret_cast<LPARAM>(pAspectRatio) );
}

inline void WINAPI WiaPreviewControl_SetPreviewMode( HWND hWnd, BOOL bPreviewMode )
{
    ::SendMessage( hWnd, PWM_SETPREVIEWMODE, 0, static_cast<LPARAM>(bPreviewMode) );
}

inline BOOL WINAPI WiaPreviewControl_GetPreviewMode( HWND hWnd )
{
    return static_cast<BOOL>(::SendMessage( hWnd, PWM_GETPREVIEWMODE, 0, 0 ));
}

inline void WINAPI WiaPreviewControl_SetBorderStyle( HWND hWnd, BOOL bRepaint, WORD nBorderStyle, WORD nBorderThickness )
{
    ::SendMessage( hWnd, PWM_SETBORDERSTYLE, MAKEWPARAM(bRepaint,0), MAKELPARAM(nBorderStyle,nBorderThickness) );
}

inline void WINAPI WiaPreviewControl_SetBorderColor( HWND hWnd, BOOL bRepaint, WORD nState, COLORREF crColor )
{
    ::SendMessage( hWnd, PWM_SETBORDERCOLOR, MAKEWPARAM(bRepaint,nState), static_cast<LPARAM>(crColor) );
}

inline void WINAPI WiaPreviewControl_SetHandleColor( HWND hWnd, BOOL bRepaint, WORD nState, COLORREF crColor )
{
    ::SendMessage( hWnd, PWM_SETHANDLECOLOR, MAKEWPARAM(bRepaint,nState), static_cast<LPARAM>(crColor) );
}

inline BOOL WINAPI WiaPreviewControl_GetClientSize( HWND hWnd, SIZE *psizeClient )
{
    return static_cast<BOOL>(::SendMessage( hWnd, PWM_GETCLIENTSIZE, 0, reinterpret_cast<LPARAM>(psizeClient) ) );
}

inline BOOL WINAPI WiaPreviewControl_GetEnableStretch( HWND hWnd )
{
    return static_cast<BOOL>(::SendMessage( hWnd, PWM_GETENABLESTRETCH, 0, 0 ) );
}

inline void WINAPI WiaPreviewControl_SetEnableStretch( HWND hWnd, BOOL bEnable )
{
    ::SendMessage( hWnd, PWM_SETENABLESTRETCH, 0, bEnable );
}

inline void WINAPI WiaPreviewControl_HideEmptyPreview( HWND hWnd, BOOL bHide )
{
    ::SendMessage( hWnd, PWM_HIDEEMPTYPREVIEW, 0, bHide );
}

inline void WINAPI WiaPreviewControl_SetPreviewAlignment( HWND hWnd, WORD fHorizontal, WORD fVertical, BOOL bRepaint )
{
    ::SendMessage( hWnd, PWM_SETPREVIEWALIGNMENT, bRepaint, MAKELPARAM(fHorizontal,fVertical) );
}

inline void WINAPI WiaPreviewControl_RefreshBitmap( HWND hWnd )
{
    ::SendMessage( hWnd, PWM_REFRESHBITMAP, 0, 0 );
}

inline BOOL WINAPI WiaPreviewControl_SetProgress( HWND hWnd, BOOL bSet )
{
    return static_cast<BOOL>(::SendMessage( hWnd, PWM_SETPROGRESS, bSet, 0 ) );
}

inline BOOL WINAPI WiaPreviewControl_GetProgress( HWND hWnd )
{
    return static_cast<BOOL>(::SendMessage( hWnd, PWM_GETPROGRESS, 0, 0 ) );
}

inline BOOL WINAPI WiaPreviewControl_GetUserChangedSelection( HWND hWnd )
{
    return static_cast<BOOL>(::SendMessage( hWnd, PWM_GETUSERCHANGEDSELECTION, 0, 0 ) );
}

inline BOOL WINAPI WiaPreviewControl_SetUserChangedSelection( HWND hWnd, BOOL bUserChangedSelection )
{
    return static_cast<BOOL>(::SendMessage( hWnd, PWM_SETUSERCHANGEDSELECTION, bUserChangedSelection, 0 ) );
}



#endif // __cplusplus


#ifdef __cplusplus
}
#endif


#endif // __PVIEWIDS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\inc\shellext.h ===
#ifndef __SHELLEXT_H_INCLUDED
#define __SHELLEXT_H_INCLUDED

#include <windows.h>
#include <shlobj.h>
#include <wiapropui.h>


interface IWiaItem;
interface IWiaItem;
interface IWiaPropUI;


STDAPI_(HRESULT) PropertySheetFromDevice(
    IN LPCWSTR szDeviceId,
    DWORD dwFlags,
    HWND hParent
    );

STDAPI_(HRESULT) PropertySheetFromItem(
    IN LPCWSTR szDeviceId,
    IN LPCWSTR szItemName,
    DWORD dwFlags,
    HWND hParent
    );

STDAPI_(HRESULT) CreateWiaPropertySheetPages(
    LPPROPSHEETHEADER ppsh,
    IWiaItem *pItem
    );


STDAPI_(HRESULT) IMGetDeviceIdFromIDL( LPITEMIDLIST pidl, CSimpleStringWide &strDeviceId);
STDAPI_(HRESULT) GetDeviceFromDeviceId( LPCWSTR pWiaItemRootId, REFIID riid, LPVOID * ppWiaItemRoot, BOOL bShowProgress );
HRESULT IMGetItemFromIDL (LPITEMIDLIST pidl, IWiaItem **ppItem, BOOL bShowProgress=FALSE);
STDAPI_(HKEY)    GetDeviceUIKey (IUnknown *pWiaItemRoot,  DWORD dwType);
STDAPI_(HKEY)    GetGeneralUIKey (IUnknown *pWiaItemRoot,  DWORD dwType);
STDAPI_(HRESULT) DoDeleteAllItems(BSTR bstrDeviceId, HWND hwndOwner);
STDAPI_(HRESULT) TakeAPicture (BSTR strDeviceId);
// types of extensions
#define WIA_UI_PROPSHEETHANDLER     0
#define WIA_UI_CONTEXTMENUHANDLER   1
#define WIA_UI_ICONHANDLER          2

typedef HRESULT (WINAPI *WIAMAKEFULLPIDLFORDEVICE)(
    LPWSTR pDeviceId,
    IN OUT LPITEMIDLIST * ppidl
);


// Module name.  To be used with LoadLibrary
#define WIA_SHELL_EXTENSION_MODULE      TEXT("wiashext.dll")

// Exported function names
#define WIA_PROPERTYSHEETFROMDEVICE     "PropertySheetFromDevice"
#define WIA_CREATEWIAPROPERTYSHEETPAGES "CreateWiaPropertySheetPages"

// Exported function prototypes
typedef HRESULT (WINAPI *CreateWiaPropertySheetPagesProc)( LPPROPSHEETHEADER, IWiaItem * );
typedef HRESULT (WINAPI *PropertySheetFromDeviceProc)( LPWSTR, DWORD, HWND );


#endif //__SHELLEXT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\cfdefs.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       cfdefs.h
 *
 *  VERSION:     1.0, stolen from shell\inc
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/12/00
 *
 *  DESCRIPTION: Class factory implementation
 *
 *****************************************************************************/

#ifndef _STATIC_CLASS_FACTORY_
#define _STATIC_CLASS_FACTORY_

#define VERSION_2 2 // so we don't get confused by too many integers
#define VERSION_1 1
#define VERSION_0 0
#define COCREATEONLY NULL,NULL,VERSION_0,0,0 // piid,piidEvents,lVersion,dwOleMiscFlags,dwClassFactFlags
#define COCREATEONLY_NOFLAGS NULL,NULL,VERSION_0,0 // piid,piidEvents,lVersion,dwOleMiscFlags

/*
 * Class Factory Implementation for C++ without CTRStartup required.
 */

#ifdef __cplusplus

#ifdef UNIX

#define STDMETHODX  STDMETHOD
#define STDMETHODX_ STDMETHOD_

#define DECLARE_CLASS_FACTORY(cf)                                \
   class cf: public IClassFactory                                \
   {                                                             \
     public:                                                     \
       STDMETHODX (QueryInterface)(REFIID, void **);             \
       STDMETHODX_(ULONG, AddRef)();                             \
       STDMETHODX_(ULONG, Release)();                            \
                                                                 \
       STDMETHODX (CreateInstance)(IUnknown *, REFIID, void **); \
       STDMETHODX (LockServer)(BOOL);                            \
   }                                                             \


#else  // UNIX

#define STDMETHODX(fn)      HRESULT STDMETHODCALLTYPE fn
#define STDMETHODX_(ret,fn) ret STDMETHODCALLTYPE fn

#define DECLARE_CLASS_FACTORY(cf)                                \
   class cf                                                      \
   {                                                             \
     public:                                                     \
       IClassFactory *vtable;                                    \
       STDMETHODX (QueryInterface)(REFIID, void **);             \
       STDMETHODX_(ULONG, AddRef)();                             \
       STDMETHODX_(ULONG, Release)();                            \
                                                                 \
       STDMETHODX (CreateInstance)(IUnknown *, REFIID, void **); \
       STDMETHODX (LockServer)(BOOL);                            \
   }                                                             \

#endif // UNIX


DECLARE_CLASS_FACTORY( CClassFactory );


struct IClassFactoryVtbl
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE CClassFactory::*QueryInterface)(REFIID riid, void ** ppvObj);
    ULONG (STDMETHODCALLTYPE CClassFactory::*AddRef)();
    ULONG (STDMETHODCALLTYPE CClassFactory::*Release)();

    // IClassFactory
    HRESULT (STDMETHODCALLTYPE CClassFactory::*CreateInstance)(IUnknown *pUnkOuter, REFIID riid, void ** ppvObject);
    HRESULT (STDMETHODCALLTYPE CClassFactory::*LockServer)(BOOL);
};

typedef struct IClassFactoryVtbl IClassFactoryVtbl;

//
// class CObjectInfo
//

class CObjectInfo;
typedef CObjectInfo* LPOBJECTINFO;
typedef CObjectInfo const* LPCOBJECTINFO;
typedef HRESULT (*LPFNCREATEOBJINSTANCE)(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

class CObjectInfo : public CClassFactory
{
public:
    CLSID const* pclsid;
    LPFNCREATEOBJINSTANCE pfnCreateInstance;

    // for OCs and automation objects:
    IID const* piid;
    IID const* piidEvents;
    long lVersion;
    DWORD dwOleMiscFlags;
    DWORD dwClassFactFlags;

    CObjectInfo(CLSID const* pclsidin, LPFNCREATEOBJINSTANCE pfnCreatein,  IID const* piidIn, IID const* piidEventsIn, long lVersionIn,  DWORD dwOleMiscFlagsIn,  DWORD dwClassFactFlagsIn);

};
#ifndef NO_CFVTBL
const IClassFactoryVtbl c_CFVtbl = {
    CClassFactory::QueryInterface,
    CClassFactory::AddRef,
    CClassFactory::Release,
    CClassFactory::CreateInstance,
    CClassFactory::LockServer
};
#endif
//
// CLASS FACTORY TABLE STUFF
//

typedef struct tagOBJECTINFO
{
    void *cf;
    CLSID const* pclsid;
    LPFNCREATEOBJINSTANCE pfnCreateInstance;

    // for OCs and automation objects:
    IID const* piid;
    IID const* piidEvents;
    long lVersion;
    DWORD dwOleMiscFlags;
    DWORD dwClassFactFlags;
} OBJECTINFO;


#ifdef UNIX


#define CF_TABLE_BEGIN(cfTable) const CObjectInfo cfTable[] = {
#define CF_TABLE_ENTRY         CObjectInfo
#define CF_TABLE_ENTRY_NOFLAGS CObjectInfo
#define CF_TABLE_ENTRY_ALL     CObjectInfo
#define CF_TABLE_END(cfTable)  \
    CF_TABLE_ENTRY(NULL, NULL, COCREATEONLY) };
#define GET_ICLASSFACTORY(ptr) ((IClassFactory *)ptr)

#else // UNIX

#define CF_TABLE_BEGIN(cfTable) const OBJECTINFO cfTable##_tble[] = {
#define CF_TABLE_ENTRY(p1, p2, p3) { (void *)&c_CFVtbl, p1, p2, p3 }
#define CF_TABLE_ENTRY_NOFLAGS(p1, p2, p3, p4) { (void *)&c_CFVtbl, p1, p2, p3, p4 }
#define CF_TABLE_ENTRY_ALL(p1, p2, p3, p4, p5, p6, p7) { (void *)&c_CFVtbl, p1, p2, p3, p4 , p5, p6, p7}
#define CF_TABLE_END(cfTable)                                         \
    CF_TABLE_ENTRY(NULL, NULL, COCREATEONLY) }; \
    const CObjectInfo *cfTable = (const CObjectInfo *)cfTable##_tble;
#define GET_ICLASSFACTORY(ptr) ((IClassFactory *)&ptr->vtable)

#endif // UNIX

#define DECLARE_CF_TABLE(cfTable) extern const CObjectInfo *cfTable;

#endif // __cplusplus


#endif // _STATIC_CLASS_FACTORY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\end.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       end.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        11/7/00
 *
 *  DESCRIPTION: End page class definition
 *
 *****************************************************************************/


#ifndef _PRINT_PHOTOS_WIZARD_END_PAGE_DLG_PROC_
#define _PRINT_PHOTOS_WIZARD_END_PAGE_DLG_PROC_

class CEndPage
{
public:
    CEndPage( CWizardInfoBlob * pBlob );
    ~CEndPage();

    INT_PTR DoHandleMessage( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );

private:

    // window message handlers
    LRESULT         _OnInitDialog();
    VOID            _OnWizFinish();


private:
    CWizardInfoBlob *               _pWizInfo;
    HWND                            _hDlg;
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\end.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       emd.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        11/7/00
 *
 *  DESCRIPTION: Implements code for the end page of the
 *               print photos wizard...
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop


/*****************************************************************************

   CEndPage -- constructor/desctructor

   <Notes>

 *****************************************************************************/

CEndPage::CEndPage( CWizardInfoBlob * pBlob )
  : _hDlg(NULL)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_END, TEXT("CEndPage::CEndPage()")));
    _pWizInfo = pBlob;
    _pWizInfo->AddRef();
}

CEndPage::~CEndPage()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_END, TEXT("CEndPage::~CEndPage()")));

    if (_pWizInfo)
    {
        _pWizInfo->Release();
        _pWizInfo = NULL;
    }
}


/*****************************************************************************

   CEndPage::_OnInitDialog

   Handle initializing the wizard page...

 *****************************************************************************/

LRESULT CEndPage::_OnInitDialog()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_END, TEXT("CEndPage::_OnInitDialog()")));


    if (!_pWizInfo)
    {
        WIA_ERROR((TEXT("FATAL: _pWizInfo is NULL, exiting early")));
        return FALSE;
    }

    //
    // Set font...
    //

    SendDlgItemMessage(_hDlg, IDC_DONE, WM_SETFONT, (WPARAM)_pWizInfo->GetIntroFont(_hDlg), 0);

    return TRUE;
}


/*****************************************************************************

   CEndPage::DoHandleMessage

   Hanlder for messages sent to this page...

 *****************************************************************************/

INT_PTR CEndPage::DoHandleMessage( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DLGPROC, TEXT("CEndPage::DoHandleMessage( uMsg = 0x%x, wParam = 0x%x, lParam = 0x%x )"),uMsg,wParam,lParam));

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            _hDlg = hDlg;
            return _OnInitDialog();

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            LONG_PTR lpRes = 0;
            switch (pnmh->code)
            {

            case PSN_SETACTIVE:
                {
                    WIA_TRACE((TEXT("got PSN_SETACTIVE")));

                    //
                    // Put the correct text in the wizard page...
                    //

                    INT idText = IDS_WIZ_END_PAGE_SUCCESS;

                    if (_pWizInfo)
                    {
                        if (_pWizInfo->NumberOfErrorsEncountered() > 0)
                        {
                            idText = IDS_WIZ_END_PAGE_ERROR;
                        }

                        //
                        // Reset the error count
                        //

                        _pWizInfo->ResetErrorCount();

                    }

                    CSimpleString strText( idText, g_hInst );
                    SetDlgItemText( _hDlg, IDC_END_PAGE_TEXT, strText.String() );




                    //
                    // Turn cancel into finish...
                    //

                    lpRes = 0;
                    PropSheet_SetWizButtons( GetParent(_hDlg), PSWIZB_BACK | PSWIZB_FINISH );
                }
                break;

            case PSN_WIZNEXT:
                WIA_TRACE((TEXT("got PSN_WIZNEXT")));
                lpRes = -1;
                break;

            case PSN_WIZBACK:
                WIA_TRACE((TEXT("got PSN_WIZBACK")));
                lpRes = IDD_SELECT_TEMPLATE;
                break;


            case PSN_WIZFINISH:
                WIA_TRACE((TEXT("got PSN_WIZFINISH")));
                lpRes = FALSE;  // allow wizard to exit
                if (_pWizInfo)
                {
                    _pWizInfo->ShutDownWizard();
                }
                break;
            }

            SetWindowLongPtr( hDlg, DWLP_MSGRESULT, lpRes );
            return TRUE;
        }
    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\item.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       item.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/18/00
 *
 *  DESCRIPTION: Describes item class used in print photos wizard
 *
 *****************************************************************************/

#ifndef _PRINT_PHOTOS_WIZARD_ITEM_H_
#define _PRINT_PHOTOS_WIZARD_ITEM_H_

#define     RF_ROTATE_90                0x00000001
#define     RF_ROTATE_180               0x00000002
#define     RF_ROTATE_270               0x00000004
#define     RF_ROTATE_AS_NEEDED         0x00000008
#define     RF_ROTATION_MASK            0x0000000F

#define     RF_CROP_TO_FIT              0x00000010  // maintains aspect ratio
#define     RF_SCALE_TO_FIT             0x00000020  // maintains aspect ratio
#define     RF_STRETCH_TO_FIT           0x00000040  // does not maintain aspect ratio
#define     RF_USE_THUMBNAIL_DATA       0x00001000  // use small res thumbnail data to render
#define     RF_USE_MEDIUM_QUALITY_DATA  0x00002000  // use meidum quality data to render
#define     RF_USE_FULL_IMAGE_DATA      0x00004000  // use full image bits to render
#define     RF_SET_QUALITY_FOR_SCREEN   0x00010000  // this image is being rendered to the screen, so set the quality modes appropriately

#define     RF_NO_ERRORS_ON_FAILURE_TO_ROTATE 0x80000000 // even if we can't rotate, continue and print non-rotated

#define     RF_QUALITY_FLAGS_MASK       (RF_USE_THUMBNAIL_DATA | RF_USE_MEDIUM_QUALITY_DATA | RF_USE_FULL_IMAGE_DATA)

typedef struct {
    Gdiplus::Graphics *         g;
    Gdiplus::Rect *             pDest;
    RENDER_DIMENSIONS           Dim;
    UINT                        Flags;
    LONG                        lFrame;
} RENDER_OPTIONS, *LPRENDER_OPTIONS;


HRESULT _CropImage( Gdiplus::Rect * pSrc, Gdiplus::Rect * pDest );
HRESULT _ScaleImage( Gdiplus::Rect * pSrc, Gdiplus::Rect * pDest );

class CPhotoItem
{

enum
{
    DontKnowImageType = 0,
    ImageTypeIsLowResolutionFax,
    ImageTypeIsNOTLowResolutionFax
};

public:

    CPhotoItem( LPITEMIDLIST pidlFull );
    ~CPhotoItem();

    HBITMAP GetThumbnailBitmap( const SIZE &sizeDesired, LONG lFrame = 0 );
    HBITMAP GetClassBitmap( const SIZE &sizeDesired );
    HRESULT Render( RENDER_OPTIONS * pRO );
    HRESULT GetImageFrameCount( LONG * pFrameCount);
    LPITEMIDLIST GetPIDL() {return _pidlFull;}
    LPTSTR  GetFilename() {return _szFileName;}
    LONGLONG GetFileSize() {return _llFileSize;}

    ULONG   AddRef();
    ULONG   Release();
    ULONG   ReleaseWithoutDeleting();


private:
    HRESULT _DoRotateAnnotations( BOOL bClockwise, UINT Flags );
    HRESULT _DoHandleRotation( Gdiplus::Image * pImage, Gdiplus::Rect &src, Gdiplus::Rect * pDest, UINT Flags, Gdiplus::REAL &ScaleFactorForY );
    HRESULT _RenderAnnotations( HDC hDC, RENDER_DIMENSIONS * pDim, Gdiplus::Rect * pDest, Gdiplus::Rect &src, Gdiplus::Rect &srcAfterClipping );
    HRESULT _MungeAnnotationDataForThumbnails( Gdiplus::Rect &src, Gdiplus::Rect &srcBeforeClipping, Gdiplus::Rect * pDest, UINT Flags );
    HRESULT _LoadAnnotations();
    HRESULT _CreateGdiPlusImage();
    HRESULT _CreateGdiPlusThumbnail( const SIZE &sizeDesired, LONG lFrame = 0 );
    HRESULT _DiscardGdiPlusImages();

    HRESULT _GetThumbnailQualityImage( Gdiplus::Image ** ppImage, RENDER_OPTIONS * pRO, BOOL * pbNeedsToBeDeleted );
    HRESULT _GetMediumQualityImage( Gdiplus::Image ** ppImage, RENDER_OPTIONS * pRO, BOOL * pbNeedsToBeDeleted );
    HRESULT _GetFullQualityImage( Gdiplus::Image ** ppImage, RENDER_OPTIONS * pRO, BOOL * pbNeedsToBeDeleted );

private:

    LONG                        _cRef;
    LPITEMIDLIST                _pidlFull;
    Gdiplus::Image *            _pImage;
    Gdiplus::Bitmap *           _pClassBitmap;
    Gdiplus::PropertyItem **    _pAnnotBits;
    CAnnotationSet *            _pAnnotations;
    CComPtr<IStream>            _pStream;
    LONG                        _lFrameCount;
    BOOL                        _bTimeFrames;
    CSimpleCriticalSection      _csItem;
    HBITMAP *                   _pThumbnails;
    BOOL                        _bWeKnowAnnotationsDontExist;
    TCHAR                       _szFileName[MAX_PATH];
    LONGLONG                    _llFileSize;
    UINT                        _uImageType;
    Gdiplus::REAL               _DPIx;
    Gdiplus::REAL               _DPIy;

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\listitem.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       listitem.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        12/06/00
 *
 *  DESCRIPTION: Implements an item class that encapsulates each item in
 *               the photo list.  Each of these items is backed by
 *               a CPhotoItem class.
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

/*****************************************************************************

   CListItem -- constructors/desctructor

   <Notes>

 *****************************************************************************/

CListItem::CListItem( CPhotoItem * pItem, LONG lFrame )
  : _pImageInner(NULL),
    _bSelectedForPrinting(FALSE),
    _lFrameIndex(-1),
    _bJustAdded(TRUE),
    _bIsCopyItem(FALSE)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_LIST_ITEM, TEXT("CListItem::CListItem( CPhotoItem(%d), Frame(%d) )"),pItem,lFrame));

    if (pItem)
    {
        pItem->AddRef();
        _pImageInner = pItem;
    }

    _lFrameIndex= lFrame;

}

CListItem::~CListItem()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_LIST_ITEM, TEXT("CListItem::~CListItem()")));

    //
    // Free reference to backing CPhotoItem
    //

    if (_pImageInner)
    {
        _pImageInner->Release();
    }
}

/*****************************************************************************

   CListItem::GetClassBitmap

   Returns default icon for class (.jpg, .bmp, etc) for this item...

 *****************************************************************************/

HBITMAP CListItem::GetClassBitmap( const SIZE &sizeDesired )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_LIST_ITEM,TEXT("CListItem::GetClassBitmap( size = %d,%d "),sizeDesired.cx, sizeDesired.cy ));

    if (_pImageInner)
    {
        return _pImageInner->GetClassBitmap( sizeDesired );
    }

    return NULL;
}



/*****************************************************************************

   CListItem::GetThumbnailBitmap

   Given a desired size, return an HBITMAP of the thumbnail
   for a this item. The caller MUST free the HBITMAP returned
   from this function.

 *****************************************************************************/

HBITMAP CListItem::GetThumbnailBitmap( const SIZE &sizeDesired )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_LIST_ITEM,TEXT("CListItem::GetThumbnailBitmap( size = %d,%d "),sizeDesired.cx, sizeDesired.cy ));

    if (_pImageInner)
    {
        return _pImageInner->GetThumbnailBitmap( sizeDesired, _lFrameIndex );
    }

    return NULL;
}


/*****************************************************************************

   CListItem::Render

   Renders the given item into the Graphics that is supplied...

 *****************************************************************************/

HRESULT CListItem::Render( RENDER_OPTIONS * pRO )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_LIST_ITEM,TEXT("CListItem::Render()")));

    if (_pImageInner && pRO)
    {
        pRO->lFrame = _lFrameIndex;
        return _pImageInner->Render( pRO );
    }

    return E_FAIL;
}



/*****************************************************************************

   CListItem::GetPIDL

   Returns the backing pidl for this item...

 *****************************************************************************/

LPITEMIDLIST CListItem::GetPIDL()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_LIST_ITEM,TEXT("CListItem::GetPIDL()")));

    if (_pImageInner)
    {
        return _pImageInner->GetPIDL();
    }

    return NULL;
}



/*****************************************************************************

   CListItem::GetFilename

   Returns a CSimpleStringWide that contains the file name with any
   frame information.  Caller is responsible for freeing returned
   CSimpleStringWide.

 *****************************************************************************/

CSimpleStringWide * CListItem::GetFilename()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_LIST_ITEM,TEXT("CListItem::GetFilename()")));

    if (_pImageInner)
    {
        CSimpleStringWide * str = new CSimpleStringWide( CSimpleStringConvert::WideString(CSimpleString(_pImageInner->GetFilename())) );

        LONG lFrameCount = 0;
        HRESULT hr = _pImageInner->GetImageFrameCount( &lFrameCount );

        if (str && (str->Length() > 0) && SUCCEEDED(hr) && (lFrameCount > 1))
        {
            //
            // Construct suffix for pages
            //

            CSimpleString strSuffix;
            strSuffix.Format( IDS_FRAME_SUFFIX, g_hInst, _lFrameIndex + 1 );

            //
            // add suffix onto the end of the string we had
            //

            str->Concat( CSimpleStringConvert::WideString( strSuffix ) );
        }

        return str;

    }

    return NULL;
}


/*****************************************************************************

   CListItem::GetFileSize

   returns the size of the file, if known

 *****************************************************************************/

LONGLONG CListItem::GetFileSize()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_LIST_ITEM,TEXT("CListItem::GetFileSize()")));

    if (_pImageInner)
    {
        return _pImageInner->GetFileSize();
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\drop.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       drop.cpp
 *
 *  VERSION:     1.0, stolen from netplwiz
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/12/00
 *
 *  DESCRIPTION: IDropTarget implementation
 *
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*****************************************************************************

   CPrintDropTarget

   class definition

 *****************************************************************************/

class CPrintDropTarget : public IDropTarget, IPersistFile
{
public:
    CPrintDropTarget(CLSID clsidWizard);
    ~CPrintDropTarget();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID)
        { *pClassID = _clsidWizard; return S_OK; };

    // IPersistFile
    STDMETHODIMP IsDirty(void)
        { return S_FALSE; };
    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode)
        { return S_OK; };
    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember)
        { return S_OK; };
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName)
        { return S_OK; };
    STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName)
        { *ppszFileName = NULL; return S_OK; };

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
        { *pdwEffect = DROPEFFECT_COPY; return S_OK; };
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
        { *pdwEffect = DROPEFFECT_COPY; return S_OK; };
    STDMETHODIMP DragLeave(void)
        { return S_OK; };
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

private:
    static DWORD   s_PrintPhotosThreadProc(void *pv);
    void            _PrintPhotos(IDataObject *pdo);

    CLSID           _clsidWizard;               // instance of the wizard being invoked (publish vs. ipp)
    LONG            _cRef;

    CComPtr<IPrintPhotosWizardSetInfo> _ppwsi;          // print photos set wizard info object
};

#define WIZDLG(dlg_id, name_id, title_id, dlgproc, dwFlags)   \
    { MAKEINTRESOURCE(##dlg_id##), dlgproc, MAKEINTRESOURCE(##name_id##), MAKEINTRESOURCE(##title_id##), dwFlags }



/*****************************************************************************

   CPrintDropTarget

   Constructor/Destructor

 *****************************************************************************/

CPrintDropTarget::CPrintDropTarget(CLSID clsidWizard) :
    _clsidWizard(clsidWizard),
    _cRef(1)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DROP,TEXT("CPrintDropTarget::CPrintDropTarget( this == 0x%x )"),this));
    DllAddRef();
}

CPrintDropTarget::~CPrintDropTarget()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DROP,TEXT("CPrintDropTarget::~CPrintDropTarget( this == 0x%x )"),this));
    DllRelease();
}



/*****************************************************************************

   CPrintDropTarget

   IUnknown methods

 *****************************************************************************/

ULONG CPrintDropTarget::AddRef()
{
    ULONG ul = InterlockedIncrement(&_cRef);

    WIA_PUSH_FUNCTION_MASK((TRACE_REF_COUNTS,TEXT("CPrintDropTarget::AddRef( new count is %d )"), ul));

    return ul;
}

ULONG CPrintDropTarget::Release()
{
    ULONG ul = InterlockedDecrement(&_cRef);

    WIA_PUSH_FUNCTION_MASK((TRACE_REF_COUNTS,TEXT("CPrintDropTarget::Release( new count is %d )"), ul));

    if (ul)
        return ul;

    WIA_TRACE((TEXT("deleting CPrintDropTarget( this == 0x%x ) object"),this));
    delete this;
    return 0;
}

HRESULT CPrintDropTarget::QueryInterface(REFIID riid, void **ppv)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DROP,TEXT("CPrintDropTarget::QueryInterface()")));

    static const QITAB qit[] =
    {
        QITABENT(CPrintDropTarget, IDropTarget),      // IID_IDropTarget
        QITABENT(CPrintDropTarget, IPersistFile),     // IID_IPersistFile
        {0, 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppv);

    WIA_RETURN_HR(hr);
}


/*****************************************************************************

   CPrintDropTarget::_PrintPhotos

   Creates the wizard.

 *****************************************************************************/

void CPrintDropTarget::_PrintPhotos(IDataObject *pdo)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DROP, TEXT("CPrintDropTarget::_PrintPhotos")));


    CComPtr<IUnknown> pUnk;
    HRESULT hr = CPrintPhotosWizard_CreateInstance(NULL, (IUnknown **)&pUnk, NULL);
    WIA_CHECK_HR(hr,"CPrintPhotosWizard_CreateInstance()");
    if (SUCCEEDED(hr) && pUnk)
    {
        hr = pUnk->QueryInterface( IID_IPrintPhotosWizardSetInfo, (LPVOID *)&_ppwsi );
        WIA_CHECK_HR(hr, "pUnk->QI( IID_IPrintPhotosWizardSetInfo )");
    }

    // initialize the wizard with the DataObject that expressess the
    // files that we are going to copy to.

    if (SUCCEEDED(hr) && _ppwsi)
    {
        hr = _ppwsi->SetFileListDataObject( pdo );
        WIA_CHECK_HR(hr,"_ppwsi->SetFileListDataObject()");

        if (SUCCEEDED(hr))
        {
            hr = _ppwsi->RunWizard();
            WIA_CHECK_HR(hr,"_ppwsi->RunWizard()")
        }
    }
    else
    {
        WIA_ERROR((TEXT("not calling into wizard, hr = 0x%x, _ppwsi = 0x%x"),hr,_ppwsi));
    }
}


typedef struct
{
   CLSID                clsidWizard;            // which wizard is being invoked
   IStream             *pStream;                // stream for doing marshalling
   CPrintDropTarget    *that;                   // copy of object pointer
} PRINTWIZDROPINFO;

/*****************************************************************************

   CPrintDropTarget::s_PrintPhotosThreadProc

   Thread to handle creating & running the wizard (in order to free up
   caller to ::Drop).


 *****************************************************************************/


DWORD CPrintDropTarget::s_PrintPhotosThreadProc(void *pv)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DROP, TEXT("CPrintDropTarget::s_PrintPhotosThreadProc")));


    PRINTWIZDROPINFO *ppwdi = (PRINTWIZDROPINFO*)pv;
    CPrintDropTarget * that = (ppwdi) ? (ppwdi->that):NULL;

    if (ppwdi)
    {
        WIA_PRINTGUID((ppwdi->clsidWizard,TEXT("ppwdi->_clsid =")));

        CComPtr<IDataObject> pdo;
        HRESULT hr = CoGetInterfaceAndReleaseStream(ppwdi->pStream, IID_PPV_ARG(IDataObject, &pdo));
        WIA_CHECK_HR(hr,"CoGetInterfaceAndReleaseStream()");

        if (SUCCEEDED(hr) && pdo)
        {
            that->_PrintPhotos(pdo);
        }

        delete [] ppwdi;
    }

    if (that)
    {
        that->Release();
    }

    return 0;
}



/*****************************************************************************

   CPrintDropTarget::Drop

   Handle the drop operation, as the printing wizard can take a long time we
       marshall the IDataObject and then create a worker thread which can
       handle showing the wizard.

 *****************************************************************************/

STDMETHODIMP CPrintDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DROP, TEXT("CPrintDropTarget::Drop")));

    HRESULT hr = E_OUTOFMEMORY;

    // create an instance of the wizard on another thread, package up any parameters
    // into a structure for the thread to handle (eg. the drop target)

    PRINTWIZDROPINFO *ppwdi = (PRINTWIZDROPINFO*) new BYTE[sizeof(PRINTWIZDROPINFO)];
    if (ppwdi)
    {
        ppwdi->clsidWizard = _clsidWizard;
        ppwdi->that        = this;
        hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pdtobj, &ppwdi->pStream);
        WIA_CHECK_HR(hr,"CoMarshalInterThreadInterfaceInStream()");

        if (SUCCEEDED(hr))
        {
            //
            // AddRef this object so it stays around for the length of the
            // thread.  The thread will Release() the object, unless there
            // is an error creating it in which case we need to release it
            // here...

            AddRef();

            if (!SHCreateThread(s_PrintPhotosThreadProc, ppwdi, CTF_COINIT | CTF_FREELIBANDEXIT, NULL))
            {
                WIA_ERROR((TEXT("SHCreateThread failed!  Cleaning up.")));
                hr = E_FAIL;
                ppwdi->pStream->Release();
                Release();
            }
        }

        if (FAILED(hr))
            delete [] ppwdi;
    }

    WIA_RETURN_HR(hr);
}



/*****************************************************************************

   CPrintPhotosDropTarget_CreateInstance

   Create an instance of the CPrintDropTarget specifically configured
   as the photo printing wizard.

 *****************************************************************************/

STDAPI CPrintPhotosDropTarget_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DROP, TEXT("CPrintPhotosDropTarget_CreateInstance")));
    HRESULT hr = E_OUTOFMEMORY;

    CPrintDropTarget *pDrop = new CPrintDropTarget(*poi->pclsid);
    if (!pDrop)
    {
        *ppunk = NULL;          // incase of failure
        WIA_RETURN_HR(hr);
    }

    hr = pDrop->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pDrop->Release();  // we do this release because the new of CPrintPhotosDropTarget
                       // set the ref count to 1, doing the QI bumps it up to 2,
                       // and we want to leave this function with the ref count
                       // at zero...

    WIA_RETURN_HR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\item.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       item.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/18/00
 *
 *  DESCRIPTION: Implements an item class that encapsulates the photos
 *               we are dealing with.
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop


/*****************************************************************************

   _ScaleImage

   Scales src rect to fit into dest rect while preserving aspect ratio

 *****************************************************************************/

HRESULT _ScaleImage( Gdiplus::Rect * pSrc, Gdiplus::Rect * pDest )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("_ScaleImage()")));

    if (!pDest || !pSrc)
    {
        WIA_ERROR((TEXT("_ScaleImage: bad params, exiting early!")));
        return E_INVALIDARG;
    }


    WIA_TRACE((TEXT("_ScaleImage: src before scaling:  (%d, %d) @ (%d, %d)"), pSrc->Width, pSrc->Height, pSrc->X, pSrc->Y));

    //
    // Scale without any crop
    //

    SIZE sizeNew;
    INT  NewX = pDest->X, NewY = pDest->Y;

    WIA_TRACE((TEXT("_ScaleImage: dest before scaling: (%d, %d) @ (%d, %d)"),pDest->Width, pDest->Height, pDest->X, pDest->Y));

    sizeNew = PrintScanUtil::ScalePreserveAspectRatio( pDest->Width, pDest->Height, pSrc->Width, pSrc->Height );

    NewX += ((pDest->Width  - sizeNew.cx) / 2);
    NewY += ((pDest->Height - sizeNew.cy) / 2);

    pDest->X      = NewX;
    pDest->Y      = NewY;
    pDest->Width  = sizeNew.cx;
    pDest->Height = sizeNew.cy;

    WIA_TRACE((TEXT("_ScaleImage: dest after scaling:  (%d, %d) @ (%d, %d)"),pDest->Width, pDest->Height, pDest->X, pDest->Y));

    return S_OK;
}

/*****************************************************************************

   _CropImage

   Scales src rect to fit into dest rect while preserving aspect ratio

 *****************************************************************************/

HRESULT _CropImage( Gdiplus::Rect * pSrc, Gdiplus::Rect * pDest )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("_CropImage()")));

    if (!pDest || !pSrc)
    {
        WIA_ERROR((TEXT("_CropImage: bad params, exiting early!")));
        return E_INVALIDARG;
    }


    WIA_TRACE((TEXT("_CropImage: pDest before cropping:  (%d, %d) @ (%d, %d)"), pDest->Width, pDest->Height, pDest->X, pDest->Y));

    //
    // Scale without any crop
    //

    SIZE sizeNew;
    INT  NewX = pSrc->X, NewY = pSrc->Y;

    WIA_TRACE((TEXT("_CropImage: pSrc before cropping: (%d, %d) @ (%d, %d)"),pSrc->Width, pSrc->Height, pSrc->X, pSrc->Y));

    sizeNew = PrintScanUtil::ScalePreserveAspectRatio( pSrc->Width, pSrc->Height, pDest->Width, pDest->Height );

    NewX += ((pSrc->Width  - sizeNew.cx) / 2);
    NewY += ((pSrc->Height - sizeNew.cy) / 2);

    pSrc->X      = NewX;
    pSrc->Y      = NewY;
    pSrc->Width  = sizeNew.cx;
    pSrc->Height = sizeNew.cy;

    WIA_TRACE((TEXT("_CropImage: pSrc after cropping:  (%d, %d) @ (%d, %d)"),pSrc->Width, pSrc->Height, pSrc->X, pSrc->Y));

    return S_OK;
}


/*****************************************************************************

   _GetImageDimensions

   Given a GDI+ image object, return the dimensions in the given
   rectangle...


 *****************************************************************************/

HRESULT _GetImageDimensions( Gdiplus::Image * pImage, Gdiplus::RectF &rect, Gdiplus::REAL &scalingFactorForY )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("_GetImageDimensions()")));

    if (!pImage)
    {
        WIA_ERROR((TEXT("_GetImageDimensions: bad params, exiting early!")));
        return E_INVALIDARG;
    }

    Gdiplus::Unit Unit;

    HRESULT hr = Gdiplus2HRESULT( pImage->GetBounds( &rect, &Unit ) );

    if (FAILED(hr))
    {
        //
        // Try the old fashioned way...
        //

        rect.X = (Gdiplus::REAL)0.0;
        rect.Y = (Gdiplus::REAL)0.0;

        rect.Width = (Gdiplus::REAL)pImage->GetWidth();
        hr = Gdiplus2HRESULT( pImage->GetLastStatus() );
        WIA_CHECK_HR(hr,"_GetImageDimensions: GetWidth failed!");
        if (SUCCEEDED(hr))
        {
            rect.Height = (Gdiplus::REAL)pImage->GetHeight();
            hr = Gdiplus2HRESULT( pImage->GetLastStatus() );
            WIA_CHECK_HR(hr,"_GetImageDimensions: GetHeight failed!");
        }
    }
    else
    {
        if (Unit != Gdiplus::UnitPixel)
        {
            hr = S_FALSE;
        }
    }

    Gdiplus::REAL xDPI = pImage->GetHorizontalResolution();
    Gdiplus::REAL yDPI = pImage->GetVerticalResolution();

    if (yDPI)
    {
        scalingFactorForY = xDPI / yDPI;
    }
    else
    {
        scalingFactorForY = (Gdiplus::REAL)1.0;
    }


    WIA_RETURN_HR(hr);
}


/*****************************************************************************

   CPhotoItem -- constructors/desctructor

   <Notes>

 *****************************************************************************/

CPhotoItem::CPhotoItem( LPITEMIDLIST pidlFull )
  : _pidlFull(NULL),
    _pImage(NULL),
    _lFrameCount(-1),
    _bTimeFrames(FALSE),
    _pAnnotations(NULL),
    _pAnnotBits(NULL),
    _bWeKnowAnnotationsDontExist(FALSE),
    _pThumbnails(NULL),
    _cRef(0),
    _llFileSize(0),
    _uImageType(DontKnowImageType),
    _DPIx((Gdiplus::REAL)0.0),
    _DPIy((Gdiplus::REAL)0.0)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM, TEXT("CPhotoItem::CPhotoItem( fully qualified pidl )")));

    if (pidlFull)
    {
        _pidlFull = ILClone( pidlFull );
        WIA_TRACE((TEXT("_pidlFull = 0x%x"),_pidlFull));
    }

    *_szFileName = 0;

    //
    // Get just file name from the pidl
    //

    SHFILEINFO fi = {0};

    if (SHGetFileInfo( (LPCTSTR)pidlFull, 0, &fi, sizeof(fi), SHGFI_DISPLAYNAME| SHGFI_PIDL ))
    {
        lstrcpyn( _szFileName, fi.szDisplayName, ARRAYSIZE(_szFileName) );
    }

}

CPhotoItem::~CPhotoItem()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM, TEXT("CPhotoItem::~CPhotoItem()")));

    CAutoCriticalSection lock( _csItem );

    //
    // Free pidl for item
    //

    if (_pidlFull)
    {
        WIA_TRACE((TEXT("_pidlFull = 0x%x"),_pidlFull));
        ILFree( _pidlFull );
        _pidlFull = NULL;
    }

    //
    // Free GDI+ icon
    //

    if (_pClassBitmap)
    {
        delete _pClassBitmap;
        _pClassBitmap = NULL;
    }

    //
    // Free bitmaps of thumbnails
    //

    if (_pThumbnails)
    {
        for (INT i=0; i < _lFrameCount; i++)
        {
            if (_pThumbnails[i])
            {
                DeleteObject( _pThumbnails[i] );
            }
        }

        delete _pThumbnails;
        _pThumbnails = NULL;
    }

    //
    // Destroy GDI+ backing images.  This also destroys any
    // annotation data we have...
    //

    _DiscardGdiPlusImages();

}

/*****************************************************************************

   CPhotoItem IUnknown methods

   <Notes>

 *****************************************************************************/

ULONG CPhotoItem::AddRef()
{
    LONG l = InterlockedIncrement(&_cRef);

    WIA_PUSH_FUNCTION_MASK((TRACE_REF_COUNTS,TEXT("CPhotoItem(0x%x)::AddRef( new count is %d )"),this,l));

    if (l < 0)
    {
        return 0;
    }

    return (ULONG)l;
}

ULONG CPhotoItem::Release()
{
    LONG l = InterlockedDecrement(&_cRef);

    WIA_PUSH_FUNCTION_MASK((TRACE_REF_COUNTS,TEXT("CPhotoItem(0x%x)::Release( new count is %d )"),this,l));

    if (l > 0)
        return (ULONG)l;

    WIA_TRACE((TEXT("deleting object ( this == 0x%x ) because ref count is zero."),this));
    delete this;
    return 0;
}

ULONG CPhotoItem::ReleaseWithoutDeleting()
{
    LONG l = InterlockedDecrement(&_cRef);

    WIA_PUSH_FUNCTION_MASK((TRACE_REF_COUNTS,TEXT("CPhotoItem(0x%x)::Release( new count is %d )"),this,l));

    return (ULONG)l;
}


/*****************************************************************************

   CPhotoItem::GetImageFrameCount

   returns the number of frames (pages) in this image

 *****************************************************************************/

HRESULT CPhotoItem::GetImageFrameCount(LONG * pFrameCount)
{

    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("CPhotoItem::GetImageFrameCount(%s)"),_szFileName));


    if (!pFrameCount)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    // Protect us as we go get info about the item...
    //

    CAutoCriticalSection lock(_csItem);

    if (_lFrameCount == -1)
    {
        _lFrameCount = 1;

        //
        // Ensure the GDI+ image object has been created...this will also
        // update the frame count...
        //

        hr = _CreateGdiPlusImage();

        if (SUCCEEDED(hr) && _pImage)
        {
            LONG lPageFrames;
            LONG lTimeFrames;

            lPageFrames = _pImage->GetFrameCount(&Gdiplus::FrameDimensionPage);
            lTimeFrames = _pImage->GetFrameCount(&Gdiplus::FrameDimensionTime);

            if ((lPageFrames > 0) && (lTimeFrames <= 1))
            {
                _lFrameCount = lPageFrames;
            }
            else if (lTimeFrames > 0)
            {
                //
                // This is an animated GIF, report only 1 frame...
                //

                _lFrameCount = 1;
                _bTimeFrames = TRUE;
            }
            else
            {
                _lFrameCount = 1;
            }

        }

    }

    *pFrameCount = ((_lFrameCount == -1) ? 0 : _lFrameCount);

    WIA_TRACE((TEXT("%s: returning _FrameCount = %d"),_szFileName,*pFrameCount));

    return hr;
}


/*****************************************************************************

   CPhotoItem::GetClassBitmap

   Returns default icon for class (.jpg, .bmp, etc) for this item...

 *****************************************************************************/

HBITMAP CPhotoItem::GetClassBitmap( const SIZE &sizeDesired )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("CPhotoItem::GetClassBitmap( %s, size = %d,%d "),_szFileName,sizeDesired.cx, sizeDesired.cy ));

    HBITMAP hbmReturn = NULL;

    CAutoCriticalSection lock(_csItem);

    if (!_pClassBitmap)
    {
        //
        // Get icon from shell
        //

        SHFILEINFO fi = {0};

        if (SHGetFileInfo( (LPCTSTR)_pidlFull, 0, &fi, sizeof(fi), SHGFI_PIDL | SHGFI_SYSICONINDEX ))
        {
            //
            // Get large (48 x 48) icon image list
            //

            IImageList * piml = NULL;
            if (SUCCEEDED(SHGetImageList( SHIL_EXTRALARGE, IID_IImageList, (void **)&piml )) && piml)
            {

                HICON hIcon = NULL;

                if (SUCCEEDED(piml->GetIcon( fi.iIcon, 0, &hIcon )) && hIcon)
                {
                    //
                    // Got the ICON, create a bitmap for it...
                    //

                    hbmReturn = WiaUiUtil::CreateIconThumbnail( (HWND)NULL, 50, 60, hIcon, NULL );

                    if (hbmReturn)
                    {
                        _pClassBitmap = new Gdiplus::Bitmap( hbmReturn, NULL );
                        DeleteObject( hbmReturn );
                        hbmReturn = NULL;
                    }

                    DestroyIcon( hIcon );
                }
                piml->Release();
            }
        }
    }


    if (_pClassBitmap)
    {
        SIZE sizeDrawSize = {0};

        //
        // Scale image to fill thumbnail space while preserving
        // aspect ratio...
        //

        sizeDrawSize = PrintScanUtil::ScalePreserveAspectRatio( sizeDesired.cx,
                                                                sizeDesired.cy,
                                                                _pClassBitmap->GetWidth(),
                                                                _pClassBitmap->GetHeight()
                                                               );

        WIA_TRACE((TEXT("CPhotoItem::GetClassBitmap(%s) - _pClassBitmap( %d, %d )"),_szFileName,_pClassBitmap->GetWidth(), _pClassBitmap->GetHeight()));
        WIA_TRACE((TEXT("CPhotoItem::GetClassBitmap(%s) - sizeDesired(   %d, %d )"),_szFileName,sizeDesired.cx, sizeDesired.cy));
        WIA_TRACE((TEXT("CPhotoItem::GetClassBitmap(%s) - sizeDrawsize(  %d, %d )"),_szFileName,sizeDrawSize.cx, sizeDrawSize.cy));

        Gdiplus::Bitmap * pImage = new Gdiplus::Bitmap( sizeDesired.cx, sizeDesired.cy );
        if (pImage)
        {
            HRESULT hr = Gdiplus2HRESULT(pImage->GetLastStatus());
            if (SUCCEEDED(hr))
            {
                //
                // Get a graphics to render to
                //

                Graphics *pGraphics = Gdiplus::Graphics::FromImage((Gdiplus::Image *)pImage);

                if (pGraphics)
                {
                    hr = Gdiplus2HRESULT(pGraphics->GetLastStatus());

                    //
                    // Make sure it is valid
                    //

                    if (SUCCEEDED(hr))
                    {
                        //
                        // erase the background of the image
                        //

                        pGraphics->Clear( g_wndColor );

                        //
                        // Set the interpolation mode to high quality
                        //

                        pGraphics->SetInterpolationMode( Gdiplus::InterpolationModeHighQualityBicubic );

                        //
                        // Set the smoothing (anti-aliasing) mode to high quality as well
                        //

                        pGraphics->SetSmoothingMode( Gdiplus::SmoothingModeHighQuality );

                        //
                        // Draw scaled image
                        //

                        WIA_TRACE((TEXT("CPhotoItem::GetClassBitmap(%s) - calling pGraphics->DrawImage( _pClassBitmap, %d, %d, %d, %d )"),_szFileName,0 + ((sizeDesired.cx - sizeDrawSize.cx) / 2),0 + ((sizeDesired.cy - sizeDrawSize.cy) / 2),sizeDrawSize.cx,sizeDrawSize.cy));

                        hr = Gdiplus2HRESULT(pGraphics->DrawImage( _pClassBitmap,
                                                                   0 + ((sizeDesired.cx - sizeDrawSize.cx) / 2),
                                                                   0 + ((sizeDesired.cy - sizeDrawSize.cy) / 2),
                                                                   sizeDrawSize.cx,
                                                                   sizeDrawSize.cy
                                                                  ));

                        WIA_CHECK_HR(hr,"CPhotoItem::GetClassBitmap() - pGraphics->DrawImage( _pClassBitmap ) failed!");

                        if (SUCCEEDED(hr))
                        {
                            pImage->GetHBITMAP( g_wndColor, &hbmReturn );
                        }

                    }

                    //
                    // Clean up our dynamically allocated graphics
                    //

                    delete pGraphics;

                }
                else
                {
                    WIA_ERROR((TEXT("CPhotoItem::GetClassBitmap(%s) - pGraphics was NULL!"),_szFileName));
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                WIA_ERROR((TEXT("CPhotoItem::GetClassBitmap(%s) - pImage failed to be created, hr = 0x%x"),hr));
            }

            delete pImage;
        }

    }

    return hbmReturn;

}



/*****************************************************************************

   CPhotoItem::GetThumbnailBitmap

   Given a DC and a desired size, return an HBITMAP of the thumbnail
   for a this item. The caller MUST free the HBITMAP returned
   from this function.

 *****************************************************************************/

HBITMAP CPhotoItem::GetThumbnailBitmap( const SIZE &sizeDesired, LONG lFrame )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("CPhotoItem::GetThumbnailBitmap( %s, size = %d,%d "),_szFileName,sizeDesired.cx, sizeDesired.cy ));

    HBITMAP hbmReturn = NULL;
    Gdiplus::Image * pImageToUse = NULL;

    CAutoCriticalSection lock(_csItem);

    //
    // Make sure we have a thumbnail image for our photo...
    //

    _CreateGdiPlusThumbnail( sizeDesired, lFrame );

    if (_pThumbnails && (lFrame < _lFrameCount) && _pThumbnails[lFrame])
    {
        //
        // Use bitmap to draw with instead of going to the file...
        //

        pImageToUse = (Gdiplus::Image *)(Gdiplus::Bitmap::FromHBITMAP( _pThumbnails[lFrame], NULL ));
    }


    if (pImageToUse)
    {
        WIA_TRACE((TEXT("CPhotoItem::GetThumbnailBitmap(%s) - pImageToUse is (%d x %d)"),_szFileName,pImageToUse->GetWidth(),pImageToUse->GetHeight()));

        Gdiplus::Bitmap * pImage = new Gdiplus::Bitmap( sizeDesired.cx, sizeDesired.cy );
        if (pImage)
        {
            HRESULT hr = Gdiplus2HRESULT(pImage->GetLastStatus());
            if (SUCCEEDED(hr))
            {
                //
                // Get a graphics to render to
                //

                Graphics *pGraphics = Gdiplus::Graphics::FromImage((Gdiplus::Image *)pImage);

                if (pGraphics)
                {
                    hr = Gdiplus2HRESULT(pGraphics->GetLastStatus());

                    //
                    // Make sure it is valid
                    //

                    if (SUCCEEDED(hr))
                    {
                        //
                        // compute how to scale the thumbnail image
                        //

                        SIZE sizeDrawSize = {0};
                        sizeDrawSize = PrintScanUtil::ScalePreserveAspectRatio( sizeDesired.cx,
                                                                                sizeDesired.cy,
                                                                                pImageToUse->GetWidth(),
                                                                                pImageToUse->GetHeight()
                                                                               );

                        //
                        // erase the background of the image
                        //

                        pGraphics->Clear( g_wndColor );

                        //
                        // Set the interpolation mode to high quality
                        //

                        pGraphics->SetInterpolationMode( Gdiplus::InterpolationModeHighQualityBilinear );

                        //
                        // Draw scaled image
                        //

                        WIA_TRACE((TEXT("CPhotoItem::GetThumbnailBitmap(%s) - calling pGraphics->DrawImage( pImageToUse, %d, %d, %d, %d )"),_szFileName,0 + ((sizeDesired.cx - sizeDrawSize.cx) / 2),0 + ((sizeDesired.cy - sizeDrawSize.cy) / 2),sizeDrawSize.cx,sizeDrawSize.cy));

                        hr = Gdiplus2HRESULT(pGraphics->DrawImage( pImageToUse,
                                                                   0 + ((sizeDesired.cx - sizeDrawSize.cx) / 2),
                                                                   0 + ((sizeDesired.cy - sizeDrawSize.cy) / 2),
                                                                   sizeDrawSize.cx,
                                                                   sizeDrawSize.cy
                                                                  ));

                        WIA_CHECK_HR(hr,"CPhotoItem::GetThumbnailBitmap() - pGraphics->DrawImage( pImageToUse ) failed!");

                        if (SUCCEEDED(hr))
                        {
                            pImage->GetHBITMAP( g_wndColor, &hbmReturn );
                        }

                    }

                    //
                    // Clean up our dynamically allocated graphics
                    //

                    delete pGraphics;

                }
                else
                {
                    WIA_ERROR((TEXT("CPhotoItem::GetThumbnailBitmap(%s) - pGraphics was NULL!"),_szFileName));
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                WIA_ERROR((TEXT("CPhotoItem::GetThumbnailBitmap(%s) - pImage failed to be created, hr = 0x%x"),hr));
            }

            delete pImage;
        }

        //
        // If we created an image to wrap the bitmap bits, then delete it...
        //

        if (pImageToUse)
        {
            delete pImageToUse;
        }

    }
    else
    {
        WIA_ERROR((TEXT("CPhotoItem::GetThumbnailBitmap(%s) - don't have stored thumbnail bitmap for this image!"),_szFileName));
    }

    return hbmReturn;
}


/*****************************************************************************

   CPhotoItem::_DoRotateAnnotations

   This function requires that the annotation data be already set up
   and initialized. This is true for the _pImage object as well.  This
   function will not initialize on the fly.

 *****************************************************************************/


HRESULT CPhotoItem::_DoRotateAnnotations( BOOL bClockwise, UINT Flags )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("CPhotoItem::_DoRotateAnnotations( %s, Flags = 0x%x )"),_szFileName,Flags));

    if (!_pAnnotations)
    {
        WIA_RETURN_HR(E_INVALIDARG);
    }

    if (!_pImage)
    {
        WIA_RETURN_HR(E_INVALIDARG);
    }

    HRESULT hr;
    Gdiplus::REAL scaleY;

    //
    // Get width & height of backing image...
    //

    Gdiplus::RectF rectBounds;
    hr = _GetImageDimensions( _pImage, rectBounds, scaleY );

    if (SUCCEEDED(hr))
    {
        INT i = 0;
        CAnnotation * pA = NULL;
        INT iNewW = 0, iNewH = 0;

        if ((Flags & RF_USE_THUMBNAIL_DATA) || (Flags & RF_USE_MEDIUM_QUALITY_DATA))
        {
            //
            // We flip here, because in the main _DoHandleRotation we only
            // rotated the thumbnail data, so the backing image width & height
            // haven't changed.  It will be changed when we rotate to print, however,
            // so feed the correct values to the annotation rotate code...
            //

            iNewW = (INT)rectBounds.Height;
            iNewH = (INT)rectBounds.Width;
        }
        else
        {
            iNewW = (INT)rectBounds.Width;
            iNewH = (INT)rectBounds.Height;
        }

        WIA_TRACE((TEXT("CPhotoItem::_DoRotateAnnotations - bClockwise = %d, new width = %d, new height = %d"),bClockwise,iNewW,iNewH));

        //
        // rotate all the annotations
        //

        do
        {
            pA = _pAnnotations->GetAnnotation(i++);

            if (pA)
            {
                pA->Rotate( iNewW, iNewH, bClockwise );
            }

        } while( pA );

    }

    WIA_RETURN_HR(hr);
}

#define DO_CONVERT_GDIPLUS_STATUS(hr,status) if ( (status == Gdiplus::Ok) || \
                                                  (status == Gdiplus::OutOfMemory) || \
                                                  (status == Gdiplus::ObjectBusy) || \
                                                  (status == Gdiplus::FileNotFound) || \
                                                  (status == Gdiplus::AccessDenied) || \
                                                  (status == Gdiplus::Win32Error) \
                                                 ) \
                                             { \
                                                 hr = Gdiplus2HRESULT( status ); \
                                             }\
                                             else \
                                             {\
                                                 WIA_TRACE((TEXT("Mapping Gdiplus error %d to PPW_E_UNABLE_TO_ROTATE"),status));\
                                                 hr = PPW_E_UNABLE_TO_ROTATE;\
                                             }

/*****************************************************************************

   CPhotoItem::_DoHandleRotation

   Handle rotating the image to render if/when needed or specified...

 *****************************************************************************/

HRESULT CPhotoItem::_DoHandleRotation( Gdiplus::Image * pImage, Gdiplus::Rect &src, Gdiplus::Rect * pDest, UINT Flags, Gdiplus::REAL &ScaleFactorForY )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("CPhotoItem::_DoHandleRotation( %s, Flags = 0x%x )"),_szFileName,Flags));

    HRESULT hr = S_OK;
    Gdiplus::GpStatus status = Gdiplus::Ok;

    if (Flags & RF_ROTATION_MASK)
    {
        WIA_TRACE((TEXT("CPhotoItem::_DoHandleRotation(%s) - A rotation flag was specified"),_szFileName));
        if (Flags & RF_ROTATE_AS_NEEDED)
        {
            WIA_TRACE((TEXT("CPhotoItem::_DoHandleRotation(%s) - RF_ROTATE_AS_NEEDED was specified"),_szFileName));

            //
            // If the source and destination aspect ratios are on the opposite sides of 1.0,
            // rotate the image 90 degrees
            //

            const DOUBLE srcAspect  = (DOUBLE)src.Width  / (DOUBLE)src.Height;
            const DOUBLE destAspect = (DOUBLE)pDest->Width / (DOUBLE)pDest->Height;

            if((srcAspect >= (DOUBLE)1.0) ^ (destAspect >= (DOUBLE)1.0))
            {
                //
                // Rotate the image as needed...
                //

                if (Flags & RF_ROTATE_270)
                {
                    WIA_TRACE((TEXT("CPhotoItem::_DoHandleRotation(%s) - Rotating Image 270 degrees"),_szFileName));
                    status = pImage->RotateFlip( Gdiplus::Rotate270FlipNone );
                    if (status == Gdiplus::Ok)
                    {
                        _DoRotateAnnotations( FALSE, Flags );
                    }

                }
                else
                {
                    WIA_TRACE((TEXT("CPhotoItem::_DoHandleRotation(%s) - Rotating Image 90 degrees"),_szFileName));
                    status = pImage->RotateFlip( Gdiplus::Rotate90FlipNone );
                    if (status == Gdiplus::Ok)
                    {
                        _DoRotateAnnotations( TRUE, Flags );
                    }
                }

                //
                // Map most of these error codes to UNABLE_TO_ROTATE...
                //

                DO_CONVERT_GDIPLUS_STATUS(hr,status)
            }

        }
        else
        {
            //
            // Rotate the image...
            //

            if (Flags & RF_ROTATE_90)
            {
                WIA_TRACE((TEXT("CPhotoItem::_DoHandleRotation(%s) - Rotating Image 90 degrees"),_szFileName));
                status = pImage->RotateFlip( Gdiplus::Rotate90FlipNone );
                if (status == Gdiplus::Ok)
                {
                    _DoRotateAnnotations( TRUE, Flags );
                }
            }
            else if (Flags & RF_ROTATE_180)
            {
                WIA_TRACE((TEXT("CPhotoItem::_DoHandleRotation(%s) - Rotating Image 180 degrees"),_szFileName));
                status = pImage->RotateFlip( Gdiplus::Rotate180FlipNone );

                if (status == Gdiplus::Ok)
                {
                    //
                    // Rotate 90 degrees twice...
                    //

                    _DoRotateAnnotations( TRUE, Flags );
                    _DoRotateAnnotations( TRUE, Flags );
                }

            }
            else if (Flags & RF_ROTATE_270)
            {
                WIA_TRACE((TEXT("CPhotoItem::_DoHandleRotation(%s) - Rotating Image 270 degrees"),_szFileName));
                status = pImage->RotateFlip( Gdiplus::Rotate270FlipNone );
                if (status == Gdiplus::Ok)
                {
                    _DoRotateAnnotations( FALSE, Flags );
                }
            }
            else
            {
                status = Gdiplus::Ok;
            }

            //
            // Map most of these error codes to UNABLE_TO_ROTATE...
            //

            DO_CONVERT_GDIPLUS_STATUS(hr,status);
        }

        //
        // If we were able to rotate the image, then update the source rectangle
        // to make sure it still reflects reality...
        //

        if (SUCCEEDED(hr))
        {
            Gdiplus::RectF rectBounds;
            hr = _GetImageDimensions( pImage, rectBounds, ScaleFactorForY );

            if (SUCCEEDED(hr))
            {
                src.Width   = (INT)rectBounds.Width;
                src.Height  = (INT)(rectBounds.Height * ScaleFactorForY);
                src.X       = (INT)rectBounds.X;
                src.Y       = (INT)(rectBounds.Y * ScaleFactorForY);
            }
            else
            {
                src.Width = 0;
                src.Height = 0;
                src.X = 0;
                src.Y = 0;
            }
        }
    }

    if (Flags & RF_NO_ERRORS_ON_FAILURE_TO_ROTATE)
    {
        WIA_RETURN_HR(S_OK);
    }

    WIA_RETURN_HR(hr);

}


/*****************************************************************************

   CPhotoItem::_RenderAnnotations

   If annotations exist, then render them on top of this image...

 *****************************************************************************/

HRESULT CPhotoItem::_RenderAnnotations( HDC hDC, RENDER_DIMENSIONS * pDim, Gdiplus::Rect * pDest, Gdiplus::Rect &src, Gdiplus::Rect &srcAfterClipping )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("CPhotoItem::_RenderAnnotations(%s)"),_szFileName));

    if (!_pAnnotations || !hDC)
    {
        WIA_RETURN_HR(E_INVALIDARG);
    }

    //
    // Save the settings for this DC...
    //

    INT iSavedDC = SaveDC( hDC );

    //
    // setup the destination DC:
    //

    SetMapMode(hDC, MM_TEXT);
    SetStretchBltMode(hDC, COLORONCOLOR);

    WIA_TRACE((TEXT("CPhotoItem::_RenderAnnotations(%s) - dest is (%d,%d) @ (%d,%d)"),_szFileName,pDest->Width,pDest->Height,pDest->X,pDest->Y));
    WIA_TRACE((TEXT("CPhotoItem::_RenderAnnotations(%s) - rcDevice is (%d,%d) @ (%d,%d)"),_szFileName,pDim->rcDevice.right - pDim->rcDevice.left,pDim->rcDevice.bottom - pDim->rcDevice.top,pDim->rcDevice.left,pDim->rcDevice.top));
    WIA_TRACE((TEXT("CPhotoItem::_RenderAnnotations(%s) - NominalPhysicalSize is (%d,%d)"),_szFileName,pDim->NominalPhysicalSize.cx,pDim->NominalPhysicalSize.cy));
    WIA_TRACE((TEXT("CPhotoItem::_RenderAnnotations(%s) - NominalDevicePrintArea is (%d,%d)"),_szFileName,pDim->NominalDevicePrintArea.cx,pDim->NominalDevicePrintArea.cy));

    //
    // Get device rect
    //

    Gdiplus::RectF rectDevice;

    rectDevice.X        = (Gdiplus::REAL)pDim->rcDevice.left;
    rectDevice.Y        = (Gdiplus::REAL)pDim->rcDevice.top;
    rectDevice.Width    = (Gdiplus::REAL)(pDim->rcDevice.right - pDim->rcDevice.left);
    rectDevice.Height   = (Gdiplus::REAL)(pDim->rcDevice.bottom - pDim->rcDevice.top);

    //
    // Compute LPtoDP scaling factors
    //

    Gdiplus::REAL xLPtoDP = 0.0;
    Gdiplus::REAL yLPtoDP = 0.0;

    if (pDim->bDeviceIsScreen)
    {
        xLPtoDP = rectDevice.Width  / (Gdiplus::REAL)pDim->NominalPhysicalSize.cx;
        yLPtoDP = rectDevice.Height / (Gdiplus::REAL)pDim->NominalPhysicalSize.cy;
    }
    else
    {
        xLPtoDP = rectDevice.Width  / (Gdiplus::REAL)pDim->NominalDevicePrintArea.cx;
        yLPtoDP = rectDevice.Height / (Gdiplus::REAL)pDim->NominalDevicePrintArea.cy;
    }

    //
    // Get destination rect in device coords...
    //

    Gdiplus::RectF rectDest;

    rectDest.X      = pDest->X * xLPtoDP;
    rectDest.Y      = pDest->Y * xLPtoDP;
    rectDest.Width  = pDest->Width * xLPtoDP;
    rectDest.Height = pDest->Height * xLPtoDP;

    WIA_TRACE((TEXT("CPhotoItem::_RenderAnnotations(%s) - original source rect is (%d, %d) @ (%d, %d)"),_szFileName,src.Width,src.Height,src.X,src.Y));
    WIA_TRACE((TEXT("CPhotoItem::_RenderAnnotations(%s) - clipped  source rect is (%d, %d) @ (%d, %d)"),_szFileName,srcAfterClipping.Width,srcAfterClipping.Height,srcAfterClipping.X,srcAfterClipping.Y));
    WIA_TRACE((TEXT("CPhotoItem::_RenderAnnotations(%s) - clipped destination rect in device coords is (%d, %d) @ (%d, %d)"),_szFileName,(INT)rectDest.Width, (INT)rectDest.Height, (INT)rectDest.X, (INT)rectDest.Y));


    //
    // dx & dy represent how much bigger a destination rectangle would be
    // for the whole image, rather than the copped image...
    //

    Gdiplus::REAL dx = (Gdiplus::REAL)(src.Width  - srcAfterClipping.Width)  * (rectDest.Width  / (Gdiplus::REAL)srcAfterClipping.Width);
    Gdiplus::REAL dy = (Gdiplus::REAL)(src.Height - srcAfterClipping.Height) * (rectDest.Height / (Gdiplus::REAL)srcAfterClipping.Height);

    WIA_TRACE((TEXT("CPhotoItem::_RenderAnnotations(%s) - dx = %d   dy = %d"),_szFileName,(INT)dx,(INT)dy));

    //
    // Set the clipping rectangle on the device hDC in device coords...
    //

    RECT rcClip;
    rcClip.left   = (INT)rectDest.X;
    rcClip.right  = rcClip.left + (INT)rectDest.Width;
    rcClip.top    = (INT)rectDest.Y;
    rcClip.bottom = rcClip.top + (INT)rectDest.Height;


    #ifdef SHOW_ANNOT_RECTS
    {
        WIA_TRACE((TEXT("CPhotoItem::_RenderAnnotations(%s) - rcClip is (%d,%d) @ (%d,%d)"),_szFileName,rcClip.right-rcClip.left,rcClip.bottom-rcClip.top,rcClip.left,rcClip.top));
        HBRUSH hbr = CreateSolidBrush( RGB( 0xFF, 0x00, 0x00 ) );
        FrameRect( hDC, &rcClip, hbr );
        DeleteObject( (HGDIOBJ)hbr );
    }
    #endif

    HRGN hrgn = CreateRectRgnIndirect(&rcClip);
    if (hrgn != NULL)
    {
        WIA_TRACE((TEXT("CPhotoItem::_RenderAnnotations(%s) - setting clip region to (%d, %d, %d, %d)"),_szFileName,rcClip.left, rcClip.top, rcClip.right, rcClip.bottom));
        SelectClipRgn(hDC, hrgn);
    }


    //
    // Make dest rect for whole image, knowing we will clip later...
    //

    rectDest.X -= (dx / (Gdiplus::REAL)2.0);
    rectDest.Y -= (dy / (Gdiplus::REAL)2.0);
    rectDest.Width += dx;
    rectDest.Height += dy;

    WIA_TRACE((TEXT("CPhotoItem::_RenderAnnotations(%s) - full dest image rect in device coords is (%d, %d) @ (%d,%d)"),_szFileName,(INT)rectDevice.Width,(INT)rectDevice.Height,(INT)rectDevice.X,(INT)rectDevice.Y));

    #ifdef SHOW_ANNOT_RECTS
    {
        RECT rc;
        rc.left = (INT)rectDest.X;
        rc.top  = (INT)rectDest.Y;
        rc.right = rc.left + (INT)rectDest.Width;
        rc.bottom = rc.top + (INT)rectDest.Height;
        HBRUSH hbr = CreateSolidBrush( RGB( 0x00, 0xFF, 0x00 ) );
        FrameRect( hDC, &rc, hbr );
        DeleteObject( (HGDIOBJ)hbr );
    }
    #endif

    //
    // set up mapping modes for annotations
    //

    SetMapMode(hDC, MM_ANISOTROPIC);

    //
    // Set window org/ext to entire image...
    //

    SetWindowOrgEx(hDC, src.X, src.Y, NULL);
    WIA_TRACE((TEXT("CPhotoItem::_RenderAnnotations(%s) - set window org to (%d,%d)"),_szFileName,src.X,src.Y));

    SetWindowExtEx(hDC, src.Width, src.Height, NULL);
    WIA_TRACE((TEXT("CPhotoItem::_RenderAnnotations(%s) - set window ext to (%d,%d)"),_szFileName,src.Width,src.Height));

    //
    // Set the viewport to be at the corner of the image we are trying
    // to draw annotations for...
    //

    SetViewportOrgEx( hDC, (INT)rectDest.X, (INT)rectDest.Y, NULL );
    WIA_TRACE((TEXT("CPhotoItem::_RenderAnnotations(%s) - set viewport org to (%d,%d)"),_szFileName,(INT)rectDest.X,(INT)rectDest.Y));

    //
    // We need to set scaling mode of image to dest rect
    //

    SetViewportExtEx( hDC, (INT)rectDest.Width, (INT)rectDest.Height, NULL );
    WIA_TRACE((TEXT("CPhotoItem::_RenderAnnotations(%s) - set viewport ext to (%d,%d)"),_szFileName,(INT)rectDest.Width, (INT)rectDest.Height));

    //
    // Now that everything is set up, render the annotations...
    //

    WIA_TRACE((TEXT("CPhotoItem::_RenderAnnotations(%s) - calling RenderAllMarks(0x%x)"),_szFileName,hDC));
    _pAnnotations->RenderAllMarks(hDC);

    SelectClipRgn(hDC, NULL);

    if (hrgn != NULL)
        DeleteObject(hrgn);

    if (iSavedDC)
    {
        RestoreDC( hDC, iSavedDC );
    }

    WIA_RETURN_HR(S_OK);
}


/*****************************************************************************

   CPhotoItem::_MungeAnnotationDataForThumbnails

   If we're rendering using thumbnails, then we need to munge some data
   so that we will render correctly...

 *****************************************************************************/

HRESULT CPhotoItem::_MungeAnnotationDataForThumbnails( Gdiplus::Rect &src,
                                                       Gdiplus::Rect &srcBeforeClipping,
                                                       Gdiplus::Rect * pDest,
                                                       UINT Flags
                                                       )
{
    WIA_TRACE((TEXT("CPhotoItem::_MungeAnnotationDataForThumbnails(%s)"),_szFileName));

    HRESULT hr = _CreateGdiPlusImage();

    if (FAILED(hr))
    {
        WIA_RETURN_HR(hr);
    }

    if (!_pImage)
    {
        WIA_RETURN_HR(E_FAIL);
    }

    //
    // we need to construct the original image rectangle appropriate for
    // annotation use...
    //

    Gdiplus::RectF rectImage;
    Gdiplus::REAL  scaleY;

    hr = _GetImageDimensions( _pImage, rectImage, scaleY );

    if (FAILED(hr))
    {
        //
        // If we couldn't accurately get the image dimensions, then bail...
        //

        return hr;
    }

    //
    // Scale image if it's non-square pixels
    //

    if (scaleY != (Gdiplus::REAL)0.0)
    {
        rectImage.Height *= scaleY;
        rectImage.Y      *= scaleY;
    }

    WIA_TRACE((TEXT("CPhotoItem::_Munge(%s) - rectImage is (%d,%d) @ (%d,%d)"),_szFileName,(INT)rectImage.Width,(INT)rectImage.Height,(INT)rectImage.X,(INT)rectImage.Y));

    //
    // Now, do all the transforms on the real image rectangle...
    //

    const DOUBLE srcAspect  = (DOUBLE)rectImage.Width  / (DOUBLE)rectImage.Height;
    const DOUBLE destAspect = (DOUBLE)pDest->Width / (DOUBLE)pDest->Height;

    if((srcAspect >= (DOUBLE)1.0) ^ (destAspect >= (DOUBLE)1.0))
    {
        //
        // Image needs to be rotated, swap width & height
        //

        rectImage.X      = rectImage.Width;
        rectImage.Width  = rectImage.Height;
        rectImage.Height = rectImage.X;
        rectImage.X      = 0.0;
    }

    src.X      = (INT)rectImage.X;
    src.Y      = (INT)rectImage.Y;
    src.Width  = (INT)rectImage.Width;
    src.Height = (INT)rectImage.Height;

    WIA_TRACE((TEXT("CPhotoItem::_Munge(%s) - srcRect after rotation is (%d,%d) @ (%d,%d)"),_szFileName,src.Width,src.Height,src.X,src.Y));

    srcBeforeClipping = src;

    if (Flags & RF_CROP_TO_FIT)
    {
        hr = _CropImage( &src, pDest );
    }
    else if (Flags & RF_SCALE_TO_FIT)
    {
        hr = _ScaleImage( &src, pDest );
    }

    //
    // Unscale the src rect
    //

    if (scaleY != (Gdiplus::REAL)0.0)
    {
        src.Height = (INT)(((Gdiplus::REAL)src.Height) / scaleY);
        src.Y      = (INT)(((Gdiplus::REAL)src.Y)      / scaleY);

        srcBeforeClipping.Height = (INT)(((Gdiplus::REAL)srcBeforeClipping.Height) / scaleY);
        srcBeforeClipping.Y      = (INT)(((Gdiplus::REAL)srcBeforeClipping.Y)      / scaleY);

    }

    WIA_RETURN_HR(hr);
}



/*****************************************************************************

   CPhotoItem::_GetThumbnailQualityImage

   Returns in ppImage a pointer to an image class.  If pbNeedsToBeDeleted
   then the caller must call delete on the returned pImage.

 *****************************************************************************/

HRESULT CPhotoItem::_GetThumbnailQualityImage( Gdiplus::Image ** ppImage, RENDER_OPTIONS * pRO, BOOL * pbNeedsToBeDeleted )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("CPhotoItem::_GetThumbnailQualityImage( %s )"),_szFileName));

    if (!ppImage || !pRO || !pbNeedsToBeDeleted)
    {
        WIA_ERROR((TEXT("CPhotoItem::_GetThumbnailQualityImage( %s ) - returning E_INVALIDARG!"),_szFileName));
        return E_INVALIDARG;
    }

    //
    // Initialize incoming params
    //

    *ppImage = NULL;
    *pbNeedsToBeDeleted = FALSE;

    //
    // Make sure we have a GDI+ image class for our thumbnail...
    //

    SIZE sizeDesired = { DEFAULT_THUMB_WIDTH, DEFAULT_THUMB_HEIGHT };
    HRESULT hr = _CreateGdiPlusThumbnail( sizeDesired, pRO->lFrame );

    if (SUCCEEDED(hr) && (NULL!=_pThumbnails) && (pRO->lFrame < _lFrameCount) && (NULL!=_pThumbnails[pRO->lFrame]))
    {
        //
        // If we already have thumbnail bits, then use those by creating
        // a GDI+ bitmap class over those bits...
        //

        *ppImage = Gdiplus::Bitmap::FromHBITMAP( _pThumbnails[pRO->lFrame], NULL );

        if (*ppImage)
        {
            hr = Gdiplus2HRESULT((*ppImage)->GetLastStatus());
            WIA_TRACE((TEXT("CPhotoItem::_GetThumbnailQualityImage(%s) -- pImage created from thumbnail data is sized as (%d x %d)"),_szFileName,(*ppImage)->GetWidth(),(*ppImage)->GetHeight()));

            if (SUCCEEDED(hr))
            {
                *pbNeedsToBeDeleted = TRUE;
            }
            else
            {
                delete (*ppImage);
                *ppImage = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    }
    else
    {
        WIA_ERROR((TEXT("CPhotoItem::_GetThumbnailQualityImage(%s) -- no thumbnail exists (_pThumbnails=0x%x, lFrame = %d, _lFrameCount = %d)"),_szFileName,_pThumbnails,pRO->lFrame,_lFrameCount));
    }


    WIA_RETURN_HR(hr);

}

/*****************************************************************************

   CPhotoItem::_GetMediumQualityImage

   Returns in ppImage a pointer to an image class.  If pbNeedsToBeDeleted
   then the caller must call delete on the returned pImage.

 *****************************************************************************/

HRESULT CPhotoItem::_GetMediumQualityImage( Gdiplus::Image ** ppImage, RENDER_OPTIONS * pRO, BOOL * pbNeedsToBeDeleted )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("CPhotoItem::_GetMediumQualityImage( %s )"),_szFileName));

    if (!ppImage || !pRO || !pbNeedsToBeDeleted)
    {
        WIA_ERROR((TEXT("CPhotoItem::_GetMediumQualityImage(%s) - returning E_INVALIDARG!"),_szFileName));
        return E_INVALIDARG;
    }

    //
    // Initialize incoming params
    //

    *ppImage = NULL;
    *pbNeedsToBeDeleted = FALSE;

    //
    // We want to use the full high-res image.
    // Make sure we have a GDI+ image class for our photo...
    //

    HRESULT hr = _CreateGdiPlusImage();

    if (SUCCEEDED(hr) && _pImage)
    {
        //
        // If this a metafile type of image, just use the original image
        //

        GUID guidFormat = {0};

        hr = Gdiplus2HRESULT(_pImage->GetRawFormat(&guidFormat));

        if ( (SUCCEEDED(hr) && (guidFormat == ImageFormatIcon)) ||
             (Gdiplus::ImageTypeMetafile == _pImage->GetType())
            )
        {
            WIA_TRACE((TEXT("CPhotoItem::_GetMediumQualityImage(%s) - this is a metafile or an icon, using the full image..."),_szFileName));
            hr = Gdiplus2HRESULT(_pImage->SelectActiveFrame( _bTimeFrames ? &Gdiplus::FrameDimensionTime : &Gdiplus::FrameDimensionPage, pRO->lFrame ));
            *ppImage = _pImage;
        }
        else
        {
            //
            // Select the specified page
            //

            hr = Gdiplus2HRESULT(_pImage->SelectActiveFrame( _bTimeFrames ? &Gdiplus::FrameDimensionTime : &Gdiplus::FrameDimensionPage, pRO->lFrame ));
            WIA_CHECK_HR(hr,"CPhotoItem::_GetMediumQualityImage() - couldn't select frame!");

            if (SUCCEEDED(hr))
            {

                //
                // Here's the algoritm to decide how big an image to create.
                //
                //  (1) At least thumbnail size (120x120)
                //  (2) Attempt to scale to either 150dpi or 180dpi, depending on X DPI resolution of the printer
                //

                INT xDPI = 0, yDPI = 0;

                if ((pRO->Dim.DPI.cx % 150) == 0)
                {
                    //
                    // DPI is some even multiple of 150 (i.e., 150, 300, 600, 1200, 2400, etc)
                    //

                    xDPI = 150;
                    yDPI = MulDiv( pRO->Dim.DPI.cy, xDPI, pRO->Dim.DPI.cx );
                }
                else
                {
                    //
                    // DPI is some even multiple of 180 (i.e., 180, 360, 720, 1440, 2880, etc)
                    //

                    xDPI = 180;
                    yDPI = MulDiv( pRO->Dim.DPI.cy, xDPI, pRO->Dim.DPI.cx );
                }

                WIA_TRACE((TEXT("CPhotoItem::_GetMediumQualityImage(%s) - scaling to xDPI=%d yDPI=%d"),_szFileName,xDPI,yDPI));

                //
                // Handle the error case of trying to scale yDPI
                //

                if (yDPI <= 0)
                {
                    yDPI = xDPI;
                    WIA_TRACE((TEXT("CPhotoItem::_GetMediumQualityImage(%s) - fixing up yDPI to be %d"),_szFileName,yDPI));
                }

                //
                // Figure out the desired size of the new image...
                //

                INT Width  = MulDiv( pRO->pDest->Width,  xDPI, 10000 );
                INT Height = MulDiv( pRO->pDest->Height, yDPI, 10000 );

                WIA_TRACE((TEXT("CPhotoItem::_GetMediumQualityImage(%s) - desired size of image is (%d x %d)"),_szFileName,Width,Height));

                if ((Width < DEFAULT_THUMB_WIDTH) && (Height < DEFAULT_THUMB_HEIGHT))
                {
                    Width = 120;
                    Height = 120;
                    WIA_TRACE((TEXT("CPhotoItem::_GetMediumQualityImage(%s) - desired size of image is smaller than thumbnail, making it thumbnail size (%d x %d)"),_szFileName,Width,Height));
                }

                //
                // Now we now what size we're trying to scale to, create an image scaled (without cropping) to that size...
                //

                Gdiplus::RectF rectImage;
                Gdiplus::REAL  scaleY;

                if (SUCCEEDED(_GetImageDimensions( _pImage, rectImage, scaleY )))
                {
                    //
                    // scale for non-square pixels...
                    //

                    if (scaleY != (Gdiplus::REAL)0.0)
                    {
                        rectImage.Height *= scaleY;
                        rectImage.Y      *= scaleY;
                    }

                    SIZE sizeDrawSize = {0};
                    sizeDrawSize = PrintScanUtil::ScalePreserveAspectRatio( Width,
                                                                            Height,
                                                                            (INT)rectImage.Width,
                                                                            (INT)rectImage.Height
                                                                           );

                    WIA_TRACE((TEXT("CPhotoItem::_GetMediumQualityImage(%s) - size of full image( %d x %d )"),_szFileName, (INT)rectImage.Width, (INT)rectImage.Height));
                    WIA_TRACE((TEXT("CPhotoItem::_GetMediumQualityImage(%s) - sizeDesired( %d x %d )"),_szFileName, Width, Height));
                    WIA_TRACE((TEXT("CPhotoItem::_GetMediumQualityImage(%s) - sizeDrawsize( %d x %d )"),_szFileName, sizeDrawSize.cx, sizeDrawSize.cy));

                    //
                    // Create the target bitmap and make sure it succeeded
                    //

                    *ppImage = (Gdiplus::Image *)new Gdiplus::Bitmap( sizeDrawSize.cx, sizeDrawSize.cy );
                    if (*ppImage)
                    {
                        hr = Gdiplus2HRESULT((*ppImage)->GetLastStatus());
                        if (SUCCEEDED(hr))
                        {
                            //
                            // Set the resolution (DPI) for the bitmap
                            //

                            ((Gdiplus::Bitmap *)(*ppImage))->SetResolution( (Gdiplus::REAL)xDPI, (Gdiplus::REAL)yDPI );

                            //
                            // Get a graphics to render to
                            //

                            Graphics *pGraphics = Gdiplus::Graphics::FromImage(*ppImage);
                            if (pGraphics)
                            {
                                hr = Gdiplus2HRESULT(pGraphics->GetLastStatus());

                                //
                                // Make sure it is valid
                                //

                                if (SUCCEEDED(hr))
                                {
                                    //
                                    // Set the interpolation mode to high quality
                                    //

                                    pGraphics->SetInterpolationMode( Gdiplus::InterpolationModeHighQualityBicubic );

                                    //
                                    // Set the smoothing (anti-aliasing) mode to high quality as well
                                    //

                                    pGraphics->SetSmoothingMode( Gdiplus::SmoothingModeHighQuality );

                                    //
                                    // Draw scaled image
                                    //

                                    WIA_TRACE((TEXT("CPhotoItem::_GetMediumQualityImage(%s) - calling pGraphics->DrawImage( _pImage, 0, 0, %d, %d )"),_szFileName,sizeDrawSize.cx,sizeDrawSize.cy));

                                    Gdiplus::Rect rectDest;
                                    rectDest.X = 0;
                                    rectDest.Y = 0;
                                    rectDest.Width = sizeDrawSize.cx;
                                    rectDest.Height = sizeDrawSize.cy;


                                    Gdiplus::ImageAttributes imageAttr;
                                    imageAttr.SetWrapMode( Gdiplus::WrapModeTileFlipXY, Gdiplus::Color(), FALSE );

                                    //
                                    // Undo scaling
                                    //

                                    if (scaleY != (Gdiplus::REAL)0.0)
                                    {
                                        rectImage.Height /= scaleY;
                                        rectImage.Y      /= scaleY;
                                    }

                                    //
                                    // Finally render the image w/the right settings
                                    //

                                    pGraphics->DrawImage( _pImage, rectDest, 0, 0, (INT)rectImage.Width, (INT)rectImage.Height, Gdiplus::UnitPixel, &imageAttr );

                                    WIA_CHECK_HR(hr,"CPhotoItem::_GetMediumQualityImage() - pGraphics->DrawImage( _pImage, 0, 0, sizeDrawSize.cx, sizeDrawSize.cy ) failed!");

                                    if (SUCCEEDED(hr))
                                    {
                                        *pbNeedsToBeDeleted = TRUE;
                                    }
                                    else
                                    {
                                        delete (*ppImage);
                                        *ppImage = NULL;
                                    }

                                }

                                //
                                // Clean up our dynamically allocated graphics
                                //

                                delete pGraphics;

                            }
                            else
                            {
                                WIA_ERROR((TEXT("CPhotoItem::_GetMediumQualityImage(%s) - pGraphics was NULL!"),_szFileName));
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        else
                        {
                            delete (*ppImage);
                            *ppImage = NULL;
                        }
                    }
                    else
                    {
                        WIA_ERROR((TEXT("CPhotoItem::_GetMediumQualityImage(%s) - failed to create new pImage for medium quality data!"),_szFileName));
                        hr = E_OUTOFMEMORY;
                    }

                }
            }
        }
    }

    WIA_RETURN_HR(hr);
}



/*****************************************************************************

    CPhotoItem::_GetFullQualityImage

    Returns in ppImage a pointer to an image class.  If pbNeedsToBeDeleted
    then the caller must call delete on the returned pImage.

 *****************************************************************************/

HRESULT CPhotoItem::_GetFullQualityImage( Gdiplus::Image ** ppImage, RENDER_OPTIONS * pRO, BOOL * pbNeedsToBeDeleted )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("CPhotoItem::_GetFullQualityImage( %s )"),_szFileName));

    if (!ppImage || !pbNeedsToBeDeleted)
    {
        WIA_ERROR((TEXT("CPhotoItem::_GetFullQualityImage(%s) - returning E_INVALIDARG!"),_szFileName));
        return E_INVALIDARG;
    }

    //
    // Initialize incoming params
    //

    *ppImage = NULL;
    *pbNeedsToBeDeleted = FALSE;

    //
    // We want to use the full high-res image.
    // Make sure we have a GDI+ image class for our photo...
    //

    HRESULT hr = _CreateGdiPlusImage();

    if (SUCCEEDED(hr) && _pImage)
    {
        //
        // Select the specified page
        //

        hr = Gdiplus2HRESULT(_pImage->SelectActiveFrame( _bTimeFrames ? &Gdiplus::FrameDimensionTime : &Gdiplus::FrameDimensionPage, pRO->lFrame ));

        if (SUCCEEDED(hr))
        {
            *ppImage = _pImage;
            WIA_TRACE((TEXT("CPhotoItem::_GetFullQualityImage(%s) -- *ppImage created from full image data is sized as (%d x %d)"),_szFileName,_pImage->GetWidth(),_pImage->GetHeight()));
        }
        else
        {
            WIA_ERROR((TEXT("CPhotoItem::_GetFullQualityImage(%s) - couldn't select frame %d, hr = 0x%x"),_szFileName,pRO->lFrame,hr));
        }

    }

    WIA_RETURN_HR(hr);
}




#define CHECK_AND_EXIT_ON_FAILURE(hr) if (FAILED(hr)) {if (pImage && (pImage!=_pImage)) {delete pImage;} WIA_RETURN_HR(hr);}

/*****************************************************************************

   CPhotoItem::Render

   Renders the given item into the Graphics that is supplied...

 *****************************************************************************/

HRESULT CPhotoItem::Render( RENDER_OPTIONS * pRO )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("CPhotoItem::Render( %s, pRO = 0x%x)"),_szFileName,pRO));

    if (!pRO)
    {
        WIA_ERROR((TEXT("CPhotoItem::Render(%s) - pRO is NULL, don't have any input!"),_szFileName));
        return E_INVALIDARG;
    }

    WIA_TRACE((TEXT("CPhotoItem::Render(%s) - Render Options were specificed as:"),_szFileName));
    WIA_TRACE((TEXT("CPhotoItem::Render(%s) -     g      = 0x%x"),_szFileName,pRO->g));
    WIA_TRACE((TEXT("CPhotoItem::Render(%s) -     pDest  = (%d x %d) at (%d,%d)"),_szFileName,pRO->pDest->Width,pRO->pDest->Height,pRO->pDest->X,pRO->pDest->Y));
    WIA_TRACE((TEXT("CPhotoItem::Render(%s) -     Flags  = 0x%x"),_szFileName,pRO->Flags));
    WIA_TRACE((TEXT("CPhotoItem::Render(%s) -     lFrame = %d"),_szFileName,pRO->lFrame));

    HRESULT             hr      = S_OK;
    Gdiplus::Image *    pImage  = NULL;
    BOOL                bNeedsToBeDeleted = FALSE;
    Gdiplus::GpStatus   status;

    //
    // Check for bad args...
    //

    if (!pRO->g)
    {
        WIA_ERROR((TEXT("CPhotoItem::Render(%s) - g is NULL, can't draw anything"),_szFileName));
        return E_INVALIDARG;
    }

    if ((pRO->Flags & RF_STRETCH_TO_FIT) && (pRO->Flags & (RF_CROP_TO_FIT | RF_SCALE_TO_FIT)))
    {
        WIA_ERROR((TEXT("CPhotoItem::Render(%s) - RF_STRETCH_TO_FIT can't be combined with CROP or SCALE"),_szFileName));
        return E_INVALIDARG;
    }


    CAutoCriticalSection lock(_csItem);

    //
    // Refresh annotation data if we have it
    //

    _LoadAnnotations();


    if (pRO->Flags & RF_USE_THUMBNAIL_DATA)
    {
        WIA_TRACE((TEXT("CPhotoItem::Render(%s) -- render using thumbnail data..."),_szFileName));
        hr = _GetThumbnailQualityImage( &pImage, pRO, &bNeedsToBeDeleted );
    }
    else if (pRO->Flags & RF_USE_MEDIUM_QUALITY_DATA)
    {
        WIA_TRACE((TEXT("CPhotoItem::Render(%s) -- render using high quality thumbnail data..."),_szFileName));
        hr = _GetMediumQualityImage( &pImage, pRO, &bNeedsToBeDeleted );

    }
    else if (pRO->Flags & RF_USE_FULL_IMAGE_DATA)
    {
        WIA_TRACE((TEXT("CPhotoItem::Render(%s) -- render using full image data..."),_szFileName));
        hr = _GetFullQualityImage( &pImage, pRO, &bNeedsToBeDeleted );
    }
    else
    {
        WIA_ERROR((TEXT("CPhotoItem::Render(%s) -- bad render data flags"),_szFileName));
        WIA_RETURN_HR(E_INVALIDARG);
    }

    CHECK_AND_EXIT_ON_FAILURE(hr);

    //
    // We've constructed the appropriate image, now try to load the annotations...
    //

    if (_pAnnotBits && _pAnnotBits[pRO->lFrame] && _pAnnotations && _pImage)
    {
        _pAnnotations->BuildAllMarksFromData( _pAnnotBits[pRO->lFrame]->value,
                                              _pAnnotBits[pRO->lFrame]->length,
                                              (ULONG)_pImage->GetHorizontalResolution(),
                                              (ULONG)_pImage->GetVerticalResolution()
                                             );

        WIA_TRACE((TEXT("CPhotoItem::Render(%s) -- %d annotation marks for frame %d found and initialized"),_szFileName,_pAnnotations->GetCount(),pRO->lFrame));

    }

    //
    // Get the dimensions of the source image...
    //

    Gdiplus::Rect src;

    //
    // Do this so EMF/WMF print and draw correctly...
    //

    Gdiplus::RectF rectBounds;
    Gdiplus::REAL  scaleY;

    hr = _GetImageDimensions( pImage, rectBounds, scaleY );
    if (SUCCEEDED(hr))
    {
        src.Width   = (INT)rectBounds.Width;
        src.Height  = (INT)(rectBounds.Height * scaleY);
        src.X       = (INT)rectBounds.X;
        src.Y       = (INT)(rectBounds.Y * scaleY);
    }

    CHECK_AND_EXIT_ON_FAILURE(hr);

    WIA_TRACE((TEXT("CPhotoItem::Render(%s) - srcRect is (%d,%d) @ (%d,%d) before any changes"),_szFileName,src.Width, src.Height, src.X, src.Y));

    //
    // do any needed rotation
    //

    hr = _DoHandleRotation( pImage, src, pRO->pDest, pRO->Flags, scaleY );
    CHECK_AND_EXIT_ON_FAILURE(hr);

    WIA_TRACE((TEXT("CPhotoItem::Render(%s) - srcRect is (%d,%d) @ (%d,%d) after any needed rotation"),_szFileName,src.Width,src.Height,src.X,src.Y));
    WIA_TRACE((TEXT("CPhotoItem::Render(%s) - destRect is (%d,%d) @ (%d,%d) after any needed rotation"),_szFileName,pRO->pDest->Width,pRO->pDest->Height,pRO->pDest->X,pRO->pDest->Y));

    //
    // If things are still good, do croping/scaling and then draw the image...
    //
    // First check if we should crop...
    //

    Gdiplus::Rect srcBeforeClipping = src;

    if (pRO->Flags & (RF_CROP_TO_FIT | RF_SCALE_TO_FIT))
    {
        #ifdef DEBUG
        if (pRO->Flags & RF_CROP_TO_FIT)
        {
            WIA_TRACE((TEXT("CPhotoItem::Render(%s) - RF_CROP_TO_FIT was specified"),_szFileName));
        }
        if (pRO->Flags & RF_SCALE_TO_FIT)
        {
            WIA_TRACE((TEXT("CPhotoItem::Render(%s) - RF_SCALE_TO_FIT was specified"),_szFileName));
        }
        #endif

        if (pRO->Flags & RF_CROP_TO_FIT)
        {
            hr = _CropImage( &src, pRO->pDest );
        }
        else if (pRO->Flags & RF_SCALE_TO_FIT)
        {
            hr = _ScaleImage( &src, pRO->pDest );
        }
        else
        {
            WIA_ERROR((TEXT("CPhotoItem::Render(%s) - CropScale: unknown configuration"),_szFileName));
            hr = E_FAIL;
        }
    }

    WIA_TRACE((TEXT("CPhotoItem::Render(%s) - srcRect is (%d,%d) @ (%d,%d) after scaling"),_szFileName,src.Width, src.Height, src.X, src.Y));
    WIA_TRACE((TEXT("CPhotoItem::Render(%s) - destRect is (%d,%d) @ (%d,%d) after scaling"),_szFileName,pRO->pDest->Width, pRO->pDest->Height, pRO->pDest->X, pRO->pDest->Y));

    CHECK_AND_EXIT_ON_FAILURE(hr);

    //
    // set the destination rectangle...
    //

    Gdiplus::Rect destTemp( pRO->pDest->X, pRO->pDest->Y, pRO->pDest->Width, pRO->pDest->Height );

    //
    // If this is a non-square pixel image, we need to reset the source rectangle to be back to actual
    // pixels, instead of incorporating DPI as well...
    //

    if ((scaleY != (Gdiplus::REAL)0.0) && (scaleY != (Gdiplus::REAL)1.0))
    {
        src.Height = (INT)((Gdiplus::REAL)src.Height / scaleY);
        src.Y      = (INT)((Gdiplus::REAL)src.Y      / scaleY);
        srcBeforeClipping.Height = (INT)((Gdiplus::REAL)srcBeforeClipping.Height / scaleY);
        srcBeforeClipping.Y      = (INT)((Gdiplus::REAL)srcBeforeClipping.Y      / scaleY);
    }

    //
    // Set the interpolation mode to high quality
    //

    pRO->g->SetInterpolationMode( Gdiplus::InterpolationModeHighQualityBicubic );

    //
    // Set the smoothing (anti-aliasing) mode to high quality as well
    //

    pRO->g->SetSmoothingMode( Gdiplus::SmoothingModeHighQuality );

    //
    // Set the wrap mode
    //

    Gdiplus::ImageAttributes imageAttr;
    imageAttr.SetWrapMode( Gdiplus::WrapModeTileFlipXY, Gdiplus::Color(), FALSE );

    //
    // Time to draw the image.
    //

    WIA_TRACE((TEXT("CPhotoItem::Render(%s) - calling DrawImage( pImage, destTemp( %d x %d at %d,%d ), %d, %d, %d, %d )"),_szFileName,destTemp.Width,destTemp.Height,destTemp.X,destTemp.Y,src.X,src.Y,src.Width,src.Height));
    status = pRO->g->DrawImage( pImage, destTemp, src.X, src.Y, src.Width, src.Height, Gdiplus::UnitPixel, &imageAttr );

    //
    // Check for errors, and then draw annotations...
    //

    hr = Gdiplus2HRESULT(status);
    WIA_CHECK_HR(hr,"CPhotoItem::Render() - g->DrawImage( pImage ) failed!");

    //
    // Render annotations if they exist...
    //

    if (_pAnnotations && _pAnnotBits && _pAnnotBits[pRO->lFrame])
    {
        if ((pRO->Flags & RF_USE_THUMBNAIL_DATA) || (pRO->Flags & RF_USE_MEDIUM_QUALITY_DATA))
        {
            _MungeAnnotationDataForThumbnails( src, srcBeforeClipping, pRO->pDest, pRO->Flags );
        }

        HDC hdcTemp = pRO->g->GetHDC();
        if ((Gdiplus::Ok == pRO->g->GetLastStatus()) && hdcTemp)
        {
            _RenderAnnotations( hdcTemp, &pRO->Dim, pRO->pDest, srcBeforeClipping, src );
            pRO->g->ReleaseHDC( hdcTemp );
        }
    }



    //
    // If we created a new object for the image bits then delete it here...
    //

    if (bNeedsToBeDeleted)
    {
        delete pImage;
    }

    //
    // To save memory, once we have rendered the full image we discard it
    // so the memory can be reclaimed...
    //

    if ((pRO->Flags & RF_USE_FULL_IMAGE_DATA) || (pRO->Flags & RF_USE_MEDIUM_QUALITY_DATA))
    {
        _DiscardGdiPlusImages();
    }

    WIA_RETURN_HR(hr);
}



/*****************************************************************************

   CPhotoItem::_LoadAnnotations

   If there are annotations in this image, load them...

 *****************************************************************************/

HRESULT CPhotoItem::_LoadAnnotations()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("CPhotoItem::_LoadAnnotations(%s)"),_szFileName));

    //
    // Only do this if we don't already have the data and haven't already
    // tried to load this before and found out there are no annotations...
    //

    if (!_pAnnotBits && !_pAnnotations && !_bWeKnowAnnotationsDontExist)
    {
        //
        // Ensure we have the image...
        //

        _CreateGdiPlusImage();

        //
        // Make sure we have frame data
        //

        LONG lDummy = 0;
        GetImageFrameCount( &lDummy );

        //
        // If we have any annotations, then load them up accross all the frames...
        //

        UINT uSize = 0;
        BOOL bHasAnnotations = FALSE;
        Gdiplus::Status status;

        _pAnnotations = (CAnnotationSet *)new CAnnotationSet();

        if (_pAnnotations)
        {
            _pAnnotBits = (Gdiplus::PropertyItem **) new BYTE[ sizeof(LPVOID) * _lFrameCount ];

            if (_pAnnotBits)
            {
                for (LONG lCurFrame=0; lCurFrame < _lFrameCount; lCurFrame++)
                {
                    status = _pImage->SelectActiveFrame( _bTimeFrames ? &Gdiplus::FrameDimensionTime : &Gdiplus::FrameDimensionPage, lCurFrame );

                    if (Gdiplus::Ok == status)
                    {
                        //
                        // Load the annotation bits for this frame...
                        //

                        uSize = _pImage->GetPropertyItemSize( ANNOTATION_IMAGE_TAG );

                        if (uSize > 0)
                        {
                            _pAnnotBits[lCurFrame] = (Gdiplus::PropertyItem *) new BYTE[ uSize ];
                            if (_pAnnotBits[lCurFrame])
                            {
                                //
                                // Read the annotations tag from the file...
                                //

                                status = _pImage->GetPropertyItem( ANNOTATION_IMAGE_TAG, uSize, _pAnnotBits[lCurFrame] );
                                if ((Gdiplus::Ok == status) && _pAnnotBits[lCurFrame])
                                {
                                    bHasAnnotations = TRUE;
                                }
                                else
                                {
                                    WIA_ERROR((TEXT("CPhotoItem::_LoadAnnotations - GetPropertyItem failed w/hr=0x%x"),Gdiplus2HRESULT(status)));
                                }
                            }
                            else
                            {
                                WIA_ERROR((TEXT("CPhotoItem::_LoadAnnotations - couldn't create _pAnnotBits[%d]"),lCurFrame));
                            }
                        }
                        else
                        {
                            WIA_TRACE((TEXT("CPhotoItem::_LoadAnnotations - GetPropertyItemSize returned %d size"),uSize));
                        }

                    }
                    else
                    {
                        WIA_ERROR((TEXT("CPhotoItem::_LoadAnnotations - SelectActiveFrame(%d) failed w/hr=0x%x"),lCurFrame,Gdiplus2HRESULT(status)));
                    }
                }
            }
            else
            {
                WIA_ERROR((TEXT("CPhotoItem::_LoadAnnotations - couldn't create _pAnnotBits")));

                delete _pAnnotations;
                _pAnnotations = NULL;
            }
        }
        else
        {
            WIA_ERROR((TEXT("CPhotoItem::_LoadAnnotations - couldn't create _pAnnotations!")));
        }


        if (!bHasAnnotations)
        {
            WIA_TRACE((TEXT("CPhotoItem::_LoadAnnotations - no annotations were found!")));

            //
            // delete anything we created, as we didn't load any annotations...
            //

            if (_pAnnotBits)
            {
                for (LONG l=0; l < _lFrameCount; l++)
                {
                    delete [] _pAnnotBits[l];
                    _pAnnotBits[l] = NULL;
                }

                delete [] _pAnnotBits;
                _pAnnotBits = NULL;
            }

            if (_pAnnotations)
            {
                delete _pAnnotations;
                _pAnnotations = NULL;
            }

            //
            // We gave it our best shot -- there aren't any annotations
            // so don't bother trying again for this session of the wizard
            // for this image...

            _bWeKnowAnnotationsDontExist = TRUE;

        }

    }
    else
    {
        WIA_TRACE((TEXT("CPhotoItem::_LoadAnnotations - not loading because we already have pointers to the data.")));
    }

    WIA_RETURN_HR(S_OK);
}


/*****************************************************************************

   CPhotoItem::_CreateGdiPlusImage

   Instantiates Gdi+ plus over the given image...

 *****************************************************************************/

HRESULT CPhotoItem::_CreateGdiPlusImage()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("CPhotoItem::_CreateGdiPlusImage(%s)"),_szFileName));


    HRESULT hr = S_OK;

    CAutoCriticalSection lock(_csItem);

    //
    // Try and get the size of the file...
    //

    if (_llFileSize == 0)
    {
        TCHAR szPath[ MAX_PATH + 64 ];

        *szPath = 0;
        if (SHGetPathFromIDList( _pidlFull, szPath ) && *szPath)
        {
            HANDLE hFile = CreateFile( szPath,
                                       GENERIC_READ,
                                       FILE_SHARE_READ,
                                       NULL,
                                       OPEN_EXISTING,
                                       FILE_ATTRIBUTE_NORMAL,
                                       NULL
                                      );

            if (hFile != INVALID_HANDLE_VALUE)
            {
                LARGE_INTEGER li;
                if (GetFileSizeEx( hFile, &li ))
                {
                    _llFileSize = li.QuadPart;
                }

                CloseHandle( hFile );
            }

        }
    }

    //
    // Make sure we've got a stream pointer to the file
    //

    if (!_pImage)
    {
        //
        // Get an IStream pointer for our item
        //

        CComPtr<IShellFolder> psfDesktop;
        hr = SHGetDesktopFolder( &psfDesktop );
        if (SUCCEEDED(hr) && psfDesktop)
        {
            hr = psfDesktop->BindToObject( _pidlFull, NULL, IID_IStream, (LPVOID *)&_pStream );
            WIA_CHECK_HR(hr,"_CreateGdiPlusImage: psfDesktop->BindToObject( IStream for _pidlFull )");

            if (SUCCEEDED(hr) && _pStream)
            {
                //
                // Create GDI+ image object from stream
                //

                _pImage = new Gdiplus::Image( _pStream, TRUE );
                if (!_pImage)
                {
                    _pStream = NULL;
                    WIA_ERROR((TEXT("CPhotoItem::_CreateGdiPlusImage(%s) - _pImage is NULL, creation of GDI+ image object failed!"),_szFileName));
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    hr = Gdiplus2HRESULT(_pImage->GetLastStatus());

                    if (FAILED(hr))
                    {
                        delete _pImage;
                        _pImage  = NULL;
                        _pStream = NULL;
                        WIA_ERROR((TEXT("CPhotoItem::_CreateGdiPlusImage(%s) - creation of image failed w/GDI+ hr = 0x%x"),_szFileName,hr));
                    }
                }

            }
        }
        else
        {
            WIA_ERROR((TEXT("CPhotoItem::_CreateGdiPlusImage(%s) - Couldn't get psfDesktop!"),_szFileName));
        }
    }

    WIA_RETURN_HR(hr);

}



/*****************************************************************************

   CPhotoItem::_CreateGdiPlusThumbnail

   Ensure we have a GdiPlus::Image for the thumbnail

 *****************************************************************************/

HRESULT CPhotoItem::_CreateGdiPlusThumbnail( const SIZE &sizeDesired, LONG lFrame )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("CPhotoItem::_CreateGdiPlusThumbnail( %s, this = 0x%x )"),_szFileName,this));

    HRESULT           hr     = S_OK;
    Gdiplus::GpStatus status = Gdiplus::Ok;

    CAutoCriticalSection lock(_csItem);

    //
    // Ensure we have backing Image for file..
    //

    hr = _CreateGdiPlusImage();

    if (SUCCEEDED(hr) && _pImage)
    {
        //
        // Get the number of frames...
        //

        LONG lFrameCount = 0;
        hr = GetImageFrameCount( &lFrameCount );

        if (SUCCEEDED(hr))
        {

            //
            // Our primary goal is to get at the thumbnail bitmap bits for the
            // specified frame.  First, make sure we've got an array to place
            // these in to.
            //

            if ((!_pThumbnails) && (lFrameCount >= 1))
            {
                WIA_TRACE((TEXT("CPhotoItem::_CreateGdiPlusThumbnail(%s) - _pThumbnails(0x%x) and _lFrameCount(%d)"),_szFileName,_pThumbnails,lFrameCount));

                _pThumbnails = (HBITMAP *) new HBITMAP [lFrameCount];


                if (_pThumbnails)
                {
                    //
                    // Ensure we start out with NULL HBITMAPS...
                    //

                    for (INT i=0; i<lFrameCount; i++)
                    {
                        _pThumbnails[i] = NULL;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                WIA_TRACE((TEXT("CPhotoItem::_CreateGdiPlusThumbnail(%s) - _pThumbnails is now (0x%x)"),_szFileName,_pThumbnails));
            }

            if (SUCCEEDED(hr) && _pThumbnails)
            {
                WIA_TRACE((TEXT("CPhotoItem::_CreateGdiPlusThumbnail(%s) - we have _pThumbnails"),_szFileName));

                //
                // Do we already have thumbnail bits for this frame?
                //

                if ((lFrame < lFrameCount) && (!_pThumbnails[lFrame]))
                {
                    //
                    // Have to create thumbnail for this frame.
                    // Select the specified frame.
                    //

                    status = _pImage->SelectActiveFrame( _bTimeFrames ? &Gdiplus::FrameDimensionTime : &Gdiplus::FrameDimensionPage, lFrame );
                    hr = Gdiplus2HRESULT(status);

                    if (SUCCEEDED(hr))
                    {
                        GUID guidFormat = {0};
                        Gdiplus::Image * pThumb = NULL;

                        status = _pImage->GetRawFormat( &guidFormat );

                        if (status == Gdiplus::Ok && (guidFormat == ImageFormatIcon))
                        {
                            pThumb = _pImage;
                        }
                        else
                        {
                            pThumb = _pImage->GetThumbnailImage( 0, 0, NULL, NULL );
                        }


                        if (pThumb)
                        {

                            WIA_TRACE((TEXT("CPhotoItem::_CreateGdiPlusThumbnail(%s) - SIZE - _pImage (%d x %d )"),_szFileName,_pImage->GetWidth(), _pImage->GetHeight()));
                            WIA_TRACE((TEXT("CPhotoItem::_CreateGdiPlusThumbnail(%s) - SIZE - pThumb (%d x %d)"),_szFileName,pThumb->GetWidth(),pThumb->GetHeight()));

                            //
                            // Scale image to fill thumbnail space while preserving
                            // aspect ratio...
                            //

                            SIZE sizeDrawSize = {0};
                            sizeDrawSize = PrintScanUtil::ScalePreserveAspectRatio( sizeDesired.cx,
                                                                                    sizeDesired.cy,
                                                                                    _pImage->GetWidth(),
                                                                                    _pImage->GetHeight()
                                                                                   );

                            WIA_TRACE((TEXT("CPhotoItem::_CreateGdiPlusThumbnail(%s) - SIZE - sizeDesired( %d x %d )"),_szFileName,sizeDesired.cx, sizeDesired.cy));
                            WIA_TRACE((TEXT("CPhotoItem::_CreateGdiPlusThumbnail(%s) - SIZE - sizeDrawsize( %d x %d )"),_szFileName,sizeDrawSize.cx, sizeDrawSize.cy));


                            //
                            // Create an HBITMAP of the thumbnail...
                            //

                            Gdiplus::Bitmap * pBitmap = new Gdiplus::Bitmap( sizeDrawSize.cx, sizeDrawSize.cy );
                            if (pBitmap)
                            {
                                hr = Gdiplus2HRESULT(pBitmap->GetLastStatus());
                                if (SUCCEEDED(hr))
                                {
                                    //
                                    // Get a graphics to render to
                                    //

                                    Graphics *pGraphics = Gdiplus::Graphics::FromImage((Gdiplus::Image *)pBitmap);

                                    if (pGraphics)
                                    {
                                        hr = Gdiplus2HRESULT(pGraphics->GetLastStatus());

                                        //
                                        // Make sure it is valid
                                        //

                                        if (SUCCEEDED(hr))
                                        {
                                            //
                                            // erase the background of the image
                                            //

                                            pGraphics->Clear( g_wndColor );

                                            //
                                            // Set the interpolation mode to high quality
                                            //

                                            pGraphics->SetInterpolationMode( Gdiplus::InterpolationModeHighQualityBilinear );

                                            //
                                            // Draw scaled image
                                            //

                                            WIA_TRACE((TEXT("CPhotoItem::GetThumbnailBitmap(%s) - calling pGraphics->DrawImage( pThumb, %d, %d, %d, %d )"),_szFileName,0 + ((sizeDesired.cx - sizeDrawSize.cx) / 2),0 + ((sizeDesired.cy - sizeDrawSize.cy) / 2),sizeDrawSize.cx,sizeDrawSize.cy));

                                            hr = Gdiplus2HRESULT(pGraphics->DrawImage( pThumb,
                                                                                       0,
                                                                                       0,
                                                                                       sizeDrawSize.cx,
                                                                                       sizeDrawSize.cy
                                                                                      ));

                                            WIA_CHECK_HR(hr,"CPhotoItem::GetThumbnailBitmap() - pGraphics->DrawImage( pThumb ) failed!");

                                            if (SUCCEEDED(hr))
                                            {
                                                DWORD dw = GetSysColor( COLOR_WINDOW );
                                                Gdiplus::Color wndClr(255,GetRValue(dw),GetGValue(dw),GetBValue(dw));

                                                pBitmap->GetHBITMAP( wndClr, &_pThumbnails[lFrame] );
                                            }

                                        }

                                        //
                                        // Clean up our dynamically allocated graphics
                                        //

                                        delete pGraphics;

                                    }
                                    else
                                    {
                                        WIA_ERROR((TEXT("CPhotoItem::GetThumbnailBitmap(%s) - pGraphics was NULL!"),_szFileName));
                                        hr = E_OUTOFMEMORY;
                                    }
                                }
                                else
                                {
                                    WIA_ERROR((TEXT("CPhotoItem::GetThumbnailBitmap(%s) - pImage failed to be created, hr = 0x%x"),hr));
                                }

                                delete pBitmap;
                            }

                            if (pThumb != _pImage)
                            {
                                delete pThumb;
                            }
                        }
                        else
                        {
                            hr = Gdiplus2HRESULT(_pImage->GetLastStatus());
                            WIA_ERROR((TEXT("CPhotoItem::_CreateGdiPlusThumbnail(%s): unable to GetThumbnailImage"),_szFileName));
                        }

                    }
                    else
                    {
                        WIA_ERROR((TEXT("CPhotoItem::_CreateGdiPlusThumbnail(%s): unable to select frame %d"),_szFileName,lFrame));
                    }

                }
                else
                {
                    WIA_TRACE((TEXT("CPhotoItem::_CreateGdiPlusThumbnail(%s): we already have _pThumbnails[%d], it is (0x%x)"),_szFileName,lFrame,_pThumbnails[lFrame]));
                }

            }

        }
        else
        {
            WIA_ERROR((TEXT("CPhotoItem::_CreateGdiPlusThumbnail(%s): _pImage was NULL!"),_szFileName));
        }

    }
    else
    {
        WIA_ERROR((TEXT("CPhotoItem::_CreateGdiPlusThumbnail(%s): _pImage was NULL!"),_szFileName));
    }

    WIA_RETURN_HR(hr);
}


/*****************************************************************************

   CPhotoItem::_DiscardGdiPlusImages

   Releases GDI+ objects for thumbnail and image

 *****************************************************************************/

HRESULT CPhotoItem::_DiscardGdiPlusImages()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PHOTO_ITEM,TEXT("CPhotoItem::_DiscardGdiPlusImages(%s)"),_szFileName));

    CAutoCriticalSection lock(_csItem);

    //
    // Clear out GDI+ image objects...
    //

    if (_pImage)
    {
        delete _pImage;
        _pImage = NULL;
    }

    if (_pStream)
    {
        //
        // Since this is an CComPtr, setting this to NULL will free
        // the reference on the stream object...
        //

        _pStream = NULL;
    }

    if (_pClassBitmap)
    {
        delete _pClassBitmap;
        _pClassBitmap = NULL;
    }

    if (_pAnnotations)
    {
        delete _pAnnotations;
        _pAnnotations = NULL;
    }

    if (_pAnnotBits)
    {
        for (INT i=0; i < _lFrameCount; i++)
        {
            delete [] _pAnnotBits[i];
            _pAnnotBits[i] = NULL;
        }

        delete [] _pAnnotBits;
        _pAnnotBits = NULL;
    }

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\dll.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       dll.cpp
 *
 *  VERSION:     1.0, stolen from netplwiz
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/12/00
 *
 *  DESCRIPTION: DLL main & class factory code
 *
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

// shell/lib files look for this instance variable
HINSTANCE g_hInst  = 0;
LONG      g_cLocks = 0;
ATOM      g_cPreviewClassWnd = 0;


// guids for our stuff
// some guids are in shguidp.lib. We need to move them out of the shell depot into printscan at some point
const GUID IID_ISetWaitEventForTesting   = {0xd61e2fe1, 0x4af8, 0x4dbd, {0xb8, 0xad, 0xe7, 0xe0, 0x7a, 0xdc, 0xf9, 0x0f}};


// DLL lifetime stuff

STDAPI_(BOOL) DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInst = hinstDLL;
        SHFusionInitializeFromModuleID( hinstDLL, 123 );
        WIA_DEBUG_CREATE(hinstDLL);
        WIA_TRACE((TEXT("DLL_PROCESS_ATTACH called on photowiz.dll")));
        CPreviewWindow::s_RegisterClass(hinstDLL);
        break;

    case DLL_PROCESS_DETACH:
        WIA_TRACE((TEXT("DLL_PROCESS_DETACH called on photowiz.dll")));
        if (g_cPreviewClassWnd)
        {
            UnregisterClass( (LPCTSTR)g_cPreviewClassWnd, hinstDLL );
        }
        SHFusionUninitialize();
        WIA_REPORT_LEAKS();
        WIA_DEBUG_DESTROY();
        break;

    case DLL_THREAD_ATTACH:
        // WIA_TRACE((TEXT("DLL_THREAD_ATTACH called on photowiz.dll")));
        break;

    case DLL_THREAD_DETACH:
        // WIA_TRACE((TEXT("DLL_THREAD_DETACH called on photowiz.dll")));
        break;
    }

    return TRUE;
}



STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK;
}



STDAPI DllCanUnloadNow()
{
    HRESULT hr = (g_cLocks == 0) ? S_OK:S_FALSE;

    WIA_PUSH_FUNCTION_MASK((TRACE_REF_COUNTS, TEXT("DllCanUnloadNowRef, ref count is %d, hr = 0x%x"),g_cLocks,hr));

    WIA_RETURN_HR(hr);
}



STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cLocks);
    WIA_PUSH_FUNCTION_MASK((TRACE_REF_COUNTS, TEXT("DllAddRef, new ref count is %d"),g_cLocks));
}



STDAPI_(void) DllRelease(void)
{
    InterlockedDecrement(&g_cLocks);
    WIA_PUSH_FUNCTION_MASK((TRACE_REF_COUNTS, TEXT("DllRelease, new ref count is %d"),g_cLocks));
}



/*****************************************************************************

   _CallRegInstall

   Helper function to allow us to invoke our .inf for installation...

 *****************************************************************************/

HRESULT _CallRegInstall(LPCSTR szSection, BOOL bUninstall)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = NULL;

    //
    // Get system32 directory..
    //

    TCHAR szAdvPackPath[ MAX_PATH ];
    UINT  uDirLen = lstrlen( TEXT("\\system32\\advpack.dll")+1 );
    UINT  uRes;

    *szAdvPackPath = 0;
    uRes = GetSystemWindowsDirectory( szAdvPackPath, MAX_PATH - uDirLen );

    if (uRes && (uRes <= (MAX_PATH-uDirLen)))
    {
        lstrcat( szAdvPackPath, TEXT("\\system32\\advpack.dll") );
        hinstAdvPack = LoadLibrary( szAdvPackPath );
    }

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            STRENTRY seReg[] = {
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };

            hr = pfnri(g_hInst, szSection, &stReg);
            if (bUninstall)
            {
                // ADVPACK will return E_UNEXPECTED if you try to uninstall
                // (which does a registry restore) on an INF section that was
                // never installed.  We uninstall sections that may never have
                // been installed, so ignore this error
                hr = ((E_UNEXPECTED == hr) ? S_OK : hr);
            }
        }
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}

STDAPI DllRegisterServer()
{
    _CallRegInstall("UnregDll", TRUE);

    return _CallRegInstall("RegDll", FALSE);
}

STDAPI DllUnregisterServer()
{
    return _CallRegInstall("UnregDll", TRUE);
}


HMODULE GetThreadHMODULE( LPTHREAD_START_ROUTINE pfnThreadProc )
{
    MEMORY_BASIC_INFORMATION mbi;
    if (VirtualQuery(pfnThreadProc, &mbi, sizeof(mbi)))
    {
        TCHAR szModule[MAX_PATH];
        if (GetModuleFileName((HMODULE)mbi.AllocationBase, szModule, ARRAYSIZE(szModule)))
        {
            return LoadLibrary(szModule);
        }
    }

    return NULL;
}

STDAPI PPWCoInitialize(void)
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    if (FAILED(hr))
    {
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    }
    return hr;
}




/*****************************************************************************

   ClassFactory code

   <Notes>

 *****************************************************************************/

//
// This array holds information needed for ClassFacory.
// OLEMISC_ flags are used by shembed and shocx.
//
// PERF: this table should be ordered in most-to-least used order
//
#define OIF_ALLOWAGGREGATION  0x0001

CF_TABLE_BEGIN(g_ObjectInfo)

    CF_TABLE_ENTRY( &CLSID_PrintPhotosDropTarget, CPrintPhotosDropTarget_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_PrintPhotosWizard, CPrintPhotosWizard_CreateInstance, COCREATEONLY),

CF_TABLE_END(g_ObjectInfo)

// constructor for CObjectInfo.

CObjectInfo::CObjectInfo(CLSID const* pclsidin, LPFNCREATEOBJINSTANCE pfnCreatein, IID const* piidIn,
                         IID const* piidEventsIn, long lVersionIn, DWORD dwOleMiscFlagsIn,
                         DWORD dwClassFactFlagsIn)
{
    pclsid            = pclsidin;
    pfnCreateInstance = pfnCreatein;
    piid              = piidIn;
    piidEvents        = piidEventsIn;
    lVersion          = lVersionIn;
    dwOleMiscFlags    = dwOleMiscFlagsIn;
    dwClassFactFlags  = dwClassFactFlagsIn;
}


// static class factory (no allocs!)

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_CF, TEXT("CClassFactory::QueryInterface")));

    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        DllAddRef();
        WIA_TRACE((TEXT("returning our class factory & S_OK")));
        return NOERROR;
    }

    *ppvObj = NULL;
    WIA_ERROR((TEXT("returning E_NOINTERFACE")));
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_CF, TEXT("CClassFactory::AddRef")));
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_CF, TEXT("CClassFactory::Release")));
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_CF, TEXT("CClassFactory::CreateInstance")));
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        // It is technically illegal to aggregate an object and request
        // any interface other than IUnknown. Enforce this.
        //
        WIA_ERROR((TEXT("we don't support aggregation, returning CLASS_E_NOAGGREGATION")));
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;

        if (punkOuter && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
        {
            WIA_ERROR((TEXT("we don't support aggregation, returning CLASS_E_NOAGGREGATION")));
            return CLASS_E_NOAGGREGATION;
        }

        IUnknown *punk;
        HRESULT hres = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hres))
        {
            hres = punk->QueryInterface(riid, ppv);
            punk->Release();
        }

        //_ASSERT(FAILED(hres) ? *ppv == NULL : TRUE);
        WIA_RETURN_HR(hres);
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_CF, TEXT("CClassFactory::LockServer")));
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_CF, TEXT("DllGetClassObject")));

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls;
                DllAddRef();        // class factory holds DLL ref count
                hr = S_OK;
            }
        }

    }

#ifdef ATL_ENABLED
    if (hr == CLASS_E_CLASSNOTAVAILABLE)
        hr = AtlGetClassObject(rclsid, riid, ppv);
#endif

    WIA_RETURN_HR(hr);
}


STDMETHODIMP UsePPWForPrintTo( LPCMINVOKECOMMANDINFO pCMI, IDataObject * pdo )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PRINTTO, TEXT("UsePPWForPrintTo")));

    HRESULT hr = E_INVALIDARG;
    CSimpleString strPrinterName;

    if (pCMI &&
        ((pCMI->cbSize == sizeof(CMINVOKECOMMANDINFO)) || (pCMI->cbSize == sizeof(CMINVOKECOMMANDINFOEX))) &&
        pdo)
    {
        //
        // Keep a reference on the data object while we do our thing...
        //

        pdo->AddRef();

        //
        // Get printer to use...
        //


        if ( (pCMI->cbSize == sizeof(CMINVOKECOMMANDINFO)) ||
             (pCMI->cbSize == sizeof(CMINVOKECOMMANDINFOEX) && (!(pCMI->fMask & CMIC_MASK_UNICODE)))
             )
        {
            //
            // printer name is first token on the line, but it might be quoted...
            //

            CHAR szPrinterName[ MAX_PATH ];
            LPCSTR p = pCMI->lpParameters;
            INT i = 0;

            if (p)
            {
                //
                // skip beginning "'s, if any
                //

                while (*p && (*p == '\"'))
                {
                    p++;
                }

                //
                // Copy first param, which would be printer name...
                //

                while ( *p && (*p != '\"'))
                {
                    szPrinterName[i++] = *p;
                    p++;
                }

                szPrinterName[i] = 0;

            }

            //
            // Convert into CSimpleString...

            strPrinterName.Assign(CSimpleStringConvert::NaturalString(CSimpleStringAnsi(szPrinterName)));
        }
        else if ((pCMI->cbSize == sizeof(CMINVOKECOMMANDINFOEX)) && (pCMI->fMask & CMIC_MASK_UNICODE))
        {
            LPCMINVOKECOMMANDINFOEX pCMIEX = (LPCMINVOKECOMMANDINFOEX) pCMI;

            WCHAR szwPrinterName[ MAX_PATH ];

            LPCWSTR p = pCMIEX->lpParametersW;
            INT i = 0;

            if (p)
            {
                //
                // skip beginning "'s, if any
                //

                while (*p && (*p == L'\"'))
                {
                    p++;
                }

                //
                // Copy first param, which would be printer name...
                //

                while ( *p && (*p != L'\"'))
                {
                    szwPrinterName[i++] = *p;
                    p++;
                }

                szwPrinterName[i] = 0;

            }

            //
            // Convert into CSimpleString...

            strPrinterName.Assign(CSimpleStringConvert::NaturalString(CSimpleStringWide(szwPrinterName)));


        }

        WIA_TRACE((TEXT("UsePPWForPrintTo - printer name to use is [%s]"),strPrinterName.String()));

        //
        // Create wizard object in UI less mode...
        //

        CWizardInfoBlob * pWizInfo = new CWizardInfoBlob( pdo, FALSE, TRUE );

        if (pWizInfo)
        {
            //
            // create full page print template...
            //

            WIA_TRACE((TEXT("UsePPWForPrintTo - constructing full page template")));
            pWizInfo->ConstructPrintToTemplate();

            //
            // Get a list of items...
            //

            WIA_TRACE((TEXT("UsePPWForPrintTo - adding items to print to pWizInfo")));
            pWizInfo->AddAllPhotosFromDataObject();

            //
            // Mark all items as selected for printing...
            //

            LONG nItemCount = pWizInfo->CountOfPhotos(FALSE);
            WIA_TRACE((TEXT("UsePPWForPrintTo - there are %d photos to be marked for printing"),nItemCount));

            //
            // Loop through all the photos and add them...
            //

            CListItem * pItem = NULL;
            for (INT i=0; i < nItemCount; i++)
            {
                //
                // Get the item in question
                //

                pItem = pWizInfo->GetListItem(i,FALSE);
                if (pItem)
                {
                    pItem->SetSelectionState(TRUE);
                }
            }

            //
            // Set up for printing...
            //

            pWizInfo->SetPrinterToUse( strPrinterName.String() );

            HANDLE hPrinter = NULL;
            if (OpenPrinter( (LPTSTR)strPrinterName.String(), &hPrinter, NULL ) && hPrinter)
            {
                LONG lSize = DocumentProperties( NULL, hPrinter, (LPTSTR)strPrinterName.String(), NULL, NULL, 0 );
                if (lSize)
                {
                    DEVMODE * pDevMode = (DEVMODE *) new BYTE[ lSize ];
                    if (pDevMode)
                    {
                        if (IDOK == DocumentProperties( NULL, hPrinter, (LPTSTR)strPrinterName.String(), NULL, pDevMode, DM_OUT_BUFFER ))
                        {
                            WIA_TRACE((TEXT("UsePPWForPrintTo - setting devmode to use")));
                            pWizInfo->SetDevModeToUse( pDevMode );
                        }

                        delete [] pDevMode;
                    }
                }
            }

            if (hPrinter)
            {
                ClosePrinter(hPrinter);
            }


            //
            // Create HDC for the printer...
            //

            HDC hDC = CreateDC( TEXT("WINSPOOL"), pWizInfo->GetPrinterToUse(), NULL, pWizInfo->GetDevModeToUse() );
            if (hDC)
            {
                DOCINFO di = {0};
                di.cbSize = sizeof(DOCINFO);

                //
                // turn on ICM for this hDC
                //

                WIA_TRACE((TEXT("UsePPWForPrintTo - setting ICM mode on for hDC")));
                SetICMMode( hDC, ICM_ON );

                //
                // Lets use the template name for the document name...
                //

                CSimpleString strTitle;
                CTemplateInfo * pTemplateInfo = NULL;

                if (SUCCEEDED(pWizInfo->GetTemplateByIndex( 0 ,&pTemplateInfo)) && pTemplateInfo)
                {
                    pTemplateInfo->GetTitle( &strTitle );
                }

                //
                // Let's remove the ':' at the end if there is one
                //

                INT iLen = strTitle.Length();
                if (iLen && (strTitle[(INT)iLen-1] == TEXT(':')))
                {
                    strTitle.Truncate(iLen);
                }

                di.lpszDocName = strTitle;

                WIA_TRACE((TEXT("UsePPWForPrintTo - calling StartDoc")));
                if (StartDoc( hDC, &di ) > 0)
                {
                    //
                    // Loop through until we've printed all the photos...
                    //

                    INT iPageCount = 0;
                    if (SUCCEEDED(hr = pWizInfo->GetCountOfPrintedPages( 0, &iPageCount )))
                    {
                        WIA_TRACE((TEXT("UsePPWForPrintTo - iPageCount is %d"),iPageCount));
                        for (INT iPage = 0; iPage < iPageCount; iPage++)
                        {
                            //
                            // Print the page...
                            //

                            if (StartPage( hDC ) > 0)
                            {
                                WIA_TRACE((TEXT("UsePPWForPrintTo - printing page %d"),iPage));
                                hr = pWizInfo->RenderPrintedPage( 0, iPage, hDC, NULL, (float)0.0, NULL );
                                EndPage( hDC );
                            }
                            else
                            {
                                WIA_ERROR((TEXT("UsePPWForPrintTo - StartPage failed w/GLE = %d"),GetLastError()));
                            }

                        }
                    }

                    WIA_TRACE((TEXT("UsePPWForPrintTo - calling EndDoc")));
                    EndDoc( hDC );

                }

                DeleteDC( hDC );
            }

            delete pWizInfo;
        }

        pdo->Release();
    }

    WIA_RETURN_HR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\listitem.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       listitem.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/18/00
 *
 *  DESCRIPTION: Describes listitem class used in print photos wizard
 *
 *****************************************************************************/

#ifndef _PRINT_PHOTOS_WIZARD_LISTITEM_H_
#define _PRINT_PHOTOS_WIZARD_LISTITEM_H_

class CListItem
{

public:

    CListItem( CPhotoItem * pItem, LONG lFrame );
    ~CListItem();

    HBITMAP GetThumbnailBitmap( const SIZE &sizeDesired );
    HBITMAP GetClassBitmap( const SIZE &sizeDesired );
    BOOL    SelectedForPrinting() {return _bSelectedForPrinting;}
    VOID    SetSelectionState( BOOL b ) { _bSelectedForPrinting = b; }
    BOOL    JustAdded() {return _bJustAdded;}
    VOID    SetJustAdded(BOOL b) { _bJustAdded = b; }
    VOID    ToggleSelectionState() { _bSelectedForPrinting = (!_bSelectedForPrinting); }
    //HRESULT Render( Gdiplus::Graphics * g, HDC hDC, Gdiplus::Rect &dest, UINT Flags, RENDER_DIMENSIONS * pDim, BOOL bUseThumbnail = FALSE );
    HRESULT Render( RENDER_OPTIONS * pRO );
    LPITEMIDLIST GetPIDL();
    BOOL    IsCopyItem() {return _bIsCopyItem;}
    VOID    MarkAsCopy() {_bIsCopyItem = TRUE;}
    CPhotoItem * GetSubItem() {return _pImageInner;}
    LONG    GetSubFrame() {return _lFrameIndex;}
    CSimpleStringWide * GetFilename();
    LONGLONG GetFileSize();

private:

    BOOL                _bSelectedForPrinting;
    BOOL                _bJustAdded;
    BOOL                _bIsCopyItem;
    LONG                _lFrameIndex;
    CPhotoItem *        _pImageInner;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\photosel.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       photosel.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/18/00
 *
 *  DESCRIPTION: Implements code for the photo selection page of the
 *               print photos wizard...
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

//
// Quickly check a listview state flag to see if it is checked or not
//
static inline bool IsStateChecked( UINT nState )
{
    //
    // State image indices are stored in bits 12 through 15 of the listview
    // item state, so we shift the state right 12 bits.  We subtract 1, because
    // the checked image is stored as index 2, an unchecked image is stored as index 1.
    //
    return (((nState >> 12) - 1) != 0);
}

// Thumbnail whitespace: the space in between images and their selection rectangles
// These values were discovered by trail and error.  For instance, if you reduce
// c_nAdditionalMarginY to 20, you get really bizarre spacing problems in the list view
// in vertical mode.  These values could become invalid in future versions of the listview.

static const int c_nAdditionalMarginX       = 8;
static const int c_nAdditionalMarginY       = 21;

#define LVS_EX_FLAGS (LVS_EX_DOUBLEBUFFER|LVS_EX_BORDERSELECT|LVS_EX_HIDELABELS|LVS_EX_SIMPLESELECT|LVS_EX_CHECKBOXES)


/*****************************************************************************

   CPhotoSelectionPage -- constructor/desctructor

   <Notes>

 *****************************************************************************/

CPhotoSelectionPage::CPhotoSelectionPage( CWizardInfoBlob * pBlob )
  : _hDlg(NULL),
    _bActive(FALSE),
    _hThumbnailThread(NULL)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PHOTO_SEL, TEXT("CPhotoSelectionPage::CPhotoSelectionPage()")));
    _pWizInfo = pBlob;
    _pWizInfo->AddRef();
}

CPhotoSelectionPage::~CPhotoSelectionPage()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PHOTO_SEL, TEXT("CPhotoSelectionPage::~CPhotoSelectionPage()")));

    if (_pWizInfo)
    {
        _pWizInfo->Release();
        _pWizInfo = NULL;
    }
}

VOID CPhotoSelectionPage::ShutDownBackgroundThreads()
{
    //
    // Wait for the thumbnail thread to complete...
    //

    if (_hThumbnailThread)
    {
        WiaUiUtil::MsgWaitForSingleObject( _hThumbnailThread, INFINITE );
        CloseHandle( _hThumbnailThread );
        _hThumbnailThread = NULL;
    }

    //
    // Notify _pWizInfo that we've shut down
    //

    if (_pWizInfo)
    {
        _pWizInfo->PhotoSelIsShutDown();
    }

}



/*****************************************************************************

   _AddThumbnailToListViewImageList

   Creates a thumbnail for the given item and then adds it to the
   listview's image list.

 *****************************************************************************/


INT _AddThumbnailToListViewImageList( CWizardInfoBlob * _pWizInfo, HWND hDlg, HWND hwndList, HIMAGELIST hImageList, CListItem *pItem, int nIndex, BOOL bIconInstead )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PHOTO_SEL, TEXT("_AddThumbnailToListViewImageList")));

    if (!_pWizInfo)
    {
        WIA_ERROR((TEXT("FATAL: _pWizInfo is NULL, exiting early")));
        return -1;
    }

    //
    // Assume we have the default thumbnail.  If there are any problems, this is what we will use.
    //

    int nImageListIndex = _pWizInfo->_nDefaultThumbnailImageListIndex;

    //
    // Make sure we have a valid item
    //
    if (pItem)
    {

        //
        // We only have the default thumbnail, so create and use the
        // real thumbnail...
        //

        HBITMAP hThumbnail = NULL;

        if (!_pWizInfo->IsWizardShuttingDown())
        {
            if (bIconInstead)
            {
                WIA_TRACE((TEXT("retreiving class icon...")));
                hThumbnail = pItem->GetClassBitmap( _pWizInfo->_sizeThumbnails );
            }
            else
            {
                WIA_TRACE((TEXT("retreiving thumbnail...")));
                hThumbnail = pItem->GetThumbnailBitmap( _pWizInfo->_sizeThumbnails );
            }
        }

        if (hThumbnail)
        {
            if (!_pWizInfo->IsWizardShuttingDown())
            {
                //
                // Add this thumbnail to the listview
                //

                if (hImageList)
                {
                    nImageListIndex = ImageList_Add( hImageList, hThumbnail, NULL );
                }
            }

            DeleteObject((HGDIOBJ)hThumbnail);
        }
        else
        {
            WIA_ERROR((TEXT("FATAL: hThumbnail was NULL!")));
        }


    }
    else
    {
        WIA_ERROR((TEXT("FATAL: pItem is NULL, not creating thumbnail")));
    }

    return nImageListIndex;
}

typedef struct {
    CPhotoSelectionPage * that;
    HWND                  hDlg;
    HWND                  hwndList;
    HIMAGELIST            hImageList;
    CWizardInfoBlob     * pWizInfo;
} THUMB_PROC_INFO;


VOID _AddItemToListView( CWizardInfoBlob * pWizInfo, HWND hwndList, INT iIndexOfItem, INT nImageListIndex )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PHOTO_SEL, TEXT("CPhotoSelectionPage::_AddItemToListView( iIndexOfItem = %d, nImageListIndex = %d)"),iIndexOfItem,nImageListIndex));

    //
    // Verify Params
    //

    if (!pWizInfo || !hwndList)
    {
        return;
    }

    //
    // Get item from master item list...
    //

    CListItem * pItem = pWizInfo->GetListItem(iIndexOfItem,FALSE);

    if (pItem)
    {

        //
        // Add a new listview item for this photo...
        //

        LVITEM lvItem = {0};
        lvItem.iItem = iIndexOfItem;
        lvItem.mask = LVIF_IMAGE|LVIF_PARAM|LVIF_STATE;
        lvItem.iImage = nImageListIndex;
        lvItem.lParam = reinterpret_cast<LPARAM>(pItem);

        //
        // If we're in force select all, the do select all
        //
        // ...else...
        //
        // If we only had one item in the initial selection,
        // and we're on the first item, then select it.
        //
        // ...else...
        //
        // Otherwise, do select all
        //


        if (pWizInfo->GetForceSelectAll())
        {
            pItem->SetSelectionState( TRUE );
        }
        else if (pWizInfo->ItemsInInitialSelection() == 1)
        {

            if (iIndexOfItem==0)
            {
                //
                // It's the first item, and there was only
                // one selected, so select this item.
                //

                pItem->SetSelectionState( TRUE );
            }
            else
            {
                //
                // There was only one item selected, but
                // these are the rest of the items from the
                // folder, so don't select them.
                //

                pItem->SetSelectionState( FALSE );
            }
        }
        else
        {
            //
            // Except the the one item selection case, everything else
            // defaults to all items selected in the wizard to begin with.
            //

            pItem->SetSelectionState( TRUE );
        }

        INT nResult = ListView_InsertItem( hwndList, &lvItem );

        if (nResult == -1)
        {
            WIA_ERROR((TEXT("Couldn't add item %d to ListView"),iIndexOfItem));
            pItem->SetSelectionState( FALSE );
        }
        else
        {
            ListView_SetCheckState( hwndList, nResult, pItem->SelectedForPrinting() );
        }
    }


}

/*****************************************************************************

   CPhotoSelectionPage::s_UpdateThumbnailThreadProc

   Thread which will go through and generate thumbnails for all the items
   in the listview...

 *****************************************************************************/


DWORD CPhotoSelectionPage::s_UpdateThumbnailThreadProc(VOID *pv)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PHOTO_SEL, TEXT("CPhotoSelectionPage::s_UpdateThumbnailThreadProc()")));

    //
    // Okay -- we can't have any code that calls back into the main UI
    // thread synchronously.  That means no SendMessage calls in
    // particular.  This is so that we can clean up nicely when the
    // user cancels and, of course, that message comes in on the main
    // UI thread, and we don't want to return until we know we've cleaned
    // up...
    //

    THUMB_PROC_INFO * pTPI = (THUMB_PROC_INFO *)pv;

    if (pTPI && pTPI->pWizInfo)
    {
        //
        // First thing -- addref our dll so we don't get unloaded...
        //

        HINSTANCE hDll = GetThreadHMODULE( s_UpdateThumbnailThreadProc );

        //
        // Initialize COM for this thread...
        //

        HRESULT hrCo = PPWCoInitialize();

        //
        // Add items to listview
        //

        if (pTPI->hwndList)
        {

            //
            // Tell the window not to redraw while we add these items
            //

            PostMessage( pTPI->hwndList, WM_SETREDRAW, FALSE, 0 );

            //
            // Wait until all items have been processed by pWizInfo
            //

            while ((!pTPI->pWizInfo->IsWizardShuttingDown()) && (!pTPI->pWizInfo->AllPicturesAdded()))
            {
                //
                // The items are not there yet for adding, wait another 1/2 second
                //

                Sleep( 500 );
            }

            //
            // Get the number of items
            //

            LONG nItemCount = pTPI->pWizInfo->CountOfPhotos(FALSE);
            WIA_TRACE((TEXT("There are %d photos to add to the listview"),nItemCount));

            //
            // Loop through all the photos and add them...
            //

            CListItem * pItem = NULL;
            INT nImageListIndex = -1;
            for (INT i=0; (!pTPI->pWizInfo->IsWizardShuttingDown()) && (i < nItemCount); i++)
            {
                //
                // Tell the user what's going on...
                //

                PostMessage( pTPI->hDlg, PSP_MSG_UPDATE_ITEM_COUNT, i+1, nItemCount );

                pItem = pTPI->pWizInfo->GetListItem(i,FALSE);
                if (pItem)
                {

                    //
                    // Get class icon for this image...
                    //

                    nImageListIndex = _AddThumbnailToListViewImageList( pTPI->pWizInfo, pTPI->hDlg, pTPI->hwndList, pTPI->hImageList, pItem, i, TRUE );

                    //
                    // Tell main UI thread to add this item to the listview...
                    //

                    PostMessage( pTPI->hDlg, PSP_MSG_ADD_ITEM, i, nImageListIndex );

                }
            }

            //
            // Make sure the first item is selected and has the focus
            //

            PostMessage( pTPI->hDlg, PSP_MSG_SELECT_ITEM, 0, 0 );


            //
            // Tell the window to redraw now, because we are done.  Invalidate the window, in case it is visible
            //

            PostMessage( pTPI->hwndList, WM_SETREDRAW, TRUE, 0 );
            PostMessage( pTPI->hDlg, PSP_MSG_INVALIDATE_LISTVIEW, 0, 0 );

            //
            // If there were items rejected, say so...
            //

            if (pTPI->pWizInfo->ItemsWereRejected())
            {
                WIA_TRACE((TEXT("ItemsWereRejected is TRUE, setting message...")));
                PostMessage( pTPI->hDlg, PSP_MSG_NOT_ALL_LOADED, 0, 0 );
            }
            else
            {
                //
                // otherwise, clear temporary status area...
                //

                WIA_TRACE((TEXT("ItemsWereRejected is FALSE, resetting message area...")));
                PostMessage( pTPI->hDlg, PSP_MSG_CLEAR_STATUS, 0, 0 );
            }

            //
            // If there are 0 items, then let's disable the "Select All" and "Clear All" buttons
            //

            PostMessage( pTPI->hDlg, PSP_MSG_ENABLE_BUTTONS, (WPARAM)nItemCount, 0 );

            //
            // Now, loop through and update all the thumbnails with the correct images...
            //

            pItem = NULL;
            nImageListIndex = -1;

            for (INT i=0; (!pTPI->pWizInfo->IsWizardShuttingDown()) && (i < nItemCount); i++)
            {
                pItem = pTPI->pWizInfo->GetListItem(i,FALSE);
                if (pItem)
                {
                    nImageListIndex = _AddThumbnailToListViewImageList( pTPI->pWizInfo, pTPI->hDlg, pTPI->hwndList, pTPI->hImageList, pItem, i, FALSE );
                    if (nImageListIndex >= 0)
                    {
                        WIA_TRACE((TEXT("Updating thumbnail for listview item %d"),i));

                        PostMessage( pTPI->hDlg, PSP_MSG_UPDATE_THUMBNAIL, i, nImageListIndex );

                    }
                }

            }


        }
        else
        {
            WIA_ERROR((TEXT("FATAL: Couldn't get hwndList")));
        }


        pTPI->pWizInfo->Release();
        delete [] pTPI;

        //
        // Unitialize COM
        //

        PPWCoUninitialize(hrCo);

        //
        // Exit the thread
        //

        if (hDll)
        {
            FreeLibraryAndExitThread( hDll, 0 );
        }
    }

    return 0;
}



/*****************************************************************************

   CPhotoSelectionPage::_PopulateListView

   Gets thumbnails for each of the items in the list view...

 *****************************************************************************/

VOID CPhotoSelectionPage::_PopulateListView()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PHOTO_SEL, TEXT("CPhotoSelectionPage::_PopulateListView()")));

    if (!_pWizInfo)
    {
        WIA_ERROR((TEXT("FATAL: _pWizInfo is NULL, exiting early")));
        return;
    }

    //
    // Do all the population on the background thread...
    //

    THUMB_PROC_INFO * pTPI = (THUMB_PROC_INFO *) new BYTE[sizeof(THUMB_PROC_INFO)];
    if (pTPI)
    {
        pTPI->that = this;
        pTPI->hDlg = _hDlg;
        pTPI->hwndList = GetDlgItem( _hDlg, IDC_THUMBNAILS );
        pTPI->hImageList = ListView_GetImageList( pTPI->hwndList, LVSIL_NORMAL );
        _pWizInfo->AddRef();            // make sure it doesn't go away while the thread is running...
        pTPI->pWizInfo = _pWizInfo;


        //
        // Create the thumbnail update thread...
        //

        _hThumbnailThread = CreateThread( NULL, 0, s_UpdateThumbnailThreadProc, (LPVOID)pTPI, CREATE_SUSPENDED, NULL );

        if (!_hThumbnailThread)
        {
            WIA_ERROR((TEXT("CreateThread( s_UpdateThumbnailThreadProc ) failed!")));
            _pWizInfo->Release();
            delete [] pTPI;
        }
        else
        {
            SetThreadPriority( _hThumbnailThread, THREAD_PRIORITY_BELOW_NORMAL );
            ResumeThread( _hThumbnailThread );
        }
    }




}


/*****************************************************************************

   CPhotoSelectionPage::OnInitDialog

   Handle initializing the wizard page...

 *****************************************************************************/

LRESULT CPhotoSelectionPage::_OnInitDialog()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PHOTO_SEL, TEXT("CPhotoSelectionPage::_OnInitDialog()")));


    if (!_pWizInfo)
    {
        WIA_ERROR((TEXT("FATAL: _pWizInfo is NULL, exiting early")));
        return FALSE;
    }

    //
    // Register ourselves with _pWizInfo
    //

    _pWizInfo->SetPhotoSelectionPageClass( this );

    //
    // Initialize Thumbnail Listview control
    //

    HWND hwndList = GetDlgItem( _hDlg, IDC_THUMBNAILS );
    if (hwndList)
    {
        //
        // Get the number of items
        //

        LONG nItemCount = _pWizInfo->CountOfPhotos(FALSE);
        WIA_TRACE((TEXT("There are %d photos to add to the listview"),nItemCount));

        //
        // If there are 0 items, then let's disable the "Select All" and "Clear All" buttons
        //

        EnableWindow( GetDlgItem( _hDlg, IDC_SELECTALL ), (nItemCount > 0) );
        EnableWindow( GetDlgItem( _hDlg, IDC_CLEARALL ), (nItemCount > 0) );

        //
        // Hide the labels and use border selection
        //

        ListView_SetExtendedListViewStyleEx( hwndList, LVS_EX_FLAGS, LVS_EX_FLAGS );

        //
        // Create the image list
        //

        HIMAGELIST hImageList = ImageList_Create( _pWizInfo->_sizeThumbnails.cx, _pWizInfo->_sizeThumbnails.cy, ILC_COLOR32|ILC_MIRROR, nItemCount, 50 );
        if (hImageList)
        {
            //
            // Set the background color
            //

            COLORREF dw = (COLORREF)GetSysColor( COLOR_WINDOW );
            ImageList_SetBkColor( hImageList, dw );

            //
            // Create the default thumbnail
            //

            HBITMAP hBmpDefaultThumbnail = WiaUiUtil::CreateIconThumbnail( hwndList, _pWizInfo->_sizeThumbnails.cx, _pWizInfo->_sizeThumbnails.cy, g_hInst, IDI_UNAVAILABLE, CSimpleString( IDS_DOWNLOADINGTHUMBNAIL, g_hInst) );
            if (hBmpDefaultThumbnail)
            {
                _pWizInfo->_nDefaultThumbnailImageListIndex = ImageList_Add( hImageList, hBmpDefaultThumbnail, NULL );
                DeleteObject( hBmpDefaultThumbnail );
            }

            //
            // Set the image list
            //

            ListView_SetImageList( hwndList, hImageList, LVSIL_NORMAL );

            //
            // Set the spacing
            //

            ListView_SetIconSpacing( hwndList, _pWizInfo->_sizeThumbnails.cx + c_nAdditionalMarginX, _pWizInfo->_sizeThumbnails.cy + c_nAdditionalMarginY );

            //
            // Set the item count, to minimize recomputing the list size
            //

            ListView_SetItemCount( hwndList, nItemCount );

            //
            // Create a small image list, to prevent the checkbox state images from being resized in WM_SYSCOLORCHANGE
            //

            HIMAGELIST hImageListSmall = ImageList_Create( GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), ILC_COLOR32, 1, 1 );
            if (hImageListSmall)
            {
                ListView_SetImageList( hwndList, hImageListSmall, LVSIL_SMALL );
            }
        }
        else
        {
            WIA_ERROR((TEXT("FATAL: Creation of the imagelist failed!")));
            return FALSE;
        }

    }
    else
    {
        WIA_ERROR((TEXT("FATAL: Couldn't get listview")));
    }

    //
    // Populate the list view
    //

    _PopulateListView();

    return TRUE;
}







/*****************************************************************************

   CPhotoSelectionPage::OnCommand

   Handle WM_COMMAND for this dlg page

 *****************************************************************************/

LRESULT CPhotoSelectionPage::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PHOTO_SEL, TEXT("CPhotoSelectionPage::_OnCommand()")));

    WORD wNotifyCode = HIWORD(wParam);
    WORD wID         = LOWORD(wParam);
    HWND hwndCtrl    = (HWND)lParam;

    switch (wID)
    {
    case IDC_SELECTALL:
        if (_pWizInfo)
        {
            HWND hwndList = GetDlgItem( _hDlg, IDC_THUMBNAILS );
            if (hwndList)
            {
                CListItem * pItem = NULL;
                for (INT i=0; i < _pWizInfo->CountOfPhotos(FALSE); i++)
                {
                    pItem = _pWizInfo->GetListItem(i,FALSE);
                    if (pItem)
                    {
                        pItem->SetSelectionState(TRUE);
                        ListView_SetCheckState( hwndList, i, TRUE );
                    }
                }

                //
                // Now mark for all copies as well...
                //

                for (INT i=0; i < _pWizInfo->CountOfPhotos(TRUE); i++)
                {
                    pItem = _pWizInfo->GetListItem(i,TRUE);
                    if (pItem)
                    {
                        pItem->SetSelectionState(TRUE);
                    }
                }

            }

            _pWizInfo->SetPreviewsAreDirty(TRUE);

        }
        break;
    case IDC_CLEARALL:
        if (_pWizInfo)
        {
            HWND hwndList = GetDlgItem( _hDlg, IDC_THUMBNAILS );
            if (hwndList)
            {
                CListItem * pItem = NULL;
                for (INT i=0; i < _pWizInfo->CountOfPhotos(FALSE); i++)
                {
                    pItem = _pWizInfo->GetListItem(i,FALSE);
                    if (pItem)
                    {
                        pItem->SetSelectionState(FALSE);
                        ListView_SetCheckState( hwndList, i, FALSE );
                    }
                }

                //
                // Now mark for all copies as well...
                //

                for (INT i=0; i < _pWizInfo->CountOfPhotos(TRUE); i++)
                {
                    pItem = _pWizInfo->GetListItem(i,TRUE);
                    if (pItem)
                    {
                        pItem->SetSelectionState(FALSE);
                    }
                }

            }

            _pWizInfo->SetPreviewsAreDirty(TRUE);

        }
        break;
    }

    return 0;
}



/*****************************************************************************

   CPhotoSelectionPage::OnDestroy

   Handle WM_DESTROY message for this wizard page...

 *****************************************************************************/


LRESULT CPhotoSelectionPage::_OnDestroy()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PHOTO_SEL, TEXT("CPhotoSelectionPage::_OnDestroy()")));


    //
    // Nuke the large imagelist
    //
    HIMAGELIST hImageList = ListView_SetImageList( GetDlgItem( _hDlg, IDC_THUMBNAILS ), NULL, LVSIL_NORMAL );
    if (hImageList)
    {
        ImageList_Destroy(hImageList);
    }

    //
    // Nuke the small imagelist
    //
    hImageList = ListView_SetImageList( GetDlgItem( _hDlg, IDC_THUMBNAILS ), NULL, LVSIL_SMALL );
    if (hImageList)
    {
        ImageList_Destroy(hImageList);
    }

    return 0;
}



/*****************************************************************************

   CPhotoSelectionPage::_OnNotify

   Handles WM_NOTIFY messages...

 *****************************************************************************/

LRESULT CPhotoSelectionPage::_OnNotify( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DLGPROC, TEXT("CPhotoSelectionPage::_OnNotify()")));

    LPNMHDR pnmh = (LPNMHDR)lParam;
    LONG_PTR lpRes = 0;

    switch (pnmh->code)
    {

        case PSN_SETACTIVE:
            WIA_TRACE((TEXT("CPhotoSelectionPage: got PSN_SETACTIVE")));
            {
                //
                // Set the thread priority of thumbnail generation thread
                // to be our normal (which is below normal) since we're
                // on this page...
                //

                if (_hThumbnailThread)
                {
                    SetThreadPriority( _hThumbnailThread, THREAD_PRIORITY_BELOW_NORMAL );
                }

                lpRes = 0;
                DWORD dwFlags = PSWIZB_BACK;
                _bActive = TRUE;

                if (_pWizInfo)
                {
                    if (_pWizInfo->CountOfSelectedPhotos(FALSE) > 0)
                        dwFlags |= PSWIZB_NEXT;
                }

                PropSheet_SetWizButtons( GetParent(_hDlg), dwFlags );
            }
            break;

        case PSN_KILLACTIVE:
            WIA_TRACE((TEXT("CPhotoSelectionPage: got PSN_KILLACTIVE")));

            //
            // Since we're leaving this thread, set the priority of the
            // thread doing the listview thumbnail generation to even
            // lower than normal...
            //

            if (_hThumbnailThread)
            {
                SetThreadPriority( _hThumbnailThread, THREAD_PRIORITY_LOWEST );
            }


            _bActive = FALSE;
            lpRes = 0;
            break;

        case PSN_WIZNEXT:
            WIA_TRACE((TEXT("CPhotoSelectionPage: got PSN_WIZNEXT")));
            lpRes = IDD_PRINTING_OPTIONS;
            break;

        case PSN_WIZBACK:
            WIA_TRACE((TEXT("CPhotoSelectionPage: got PSN_WIZBACK")));
            lpRes = IDD_START_PAGE;
            break;

        case PSN_QUERYCANCEL:
            WIA_TRACE((TEXT("CPhotoSelectionPage: got PSN_QUERYCANCEL")));
            if (_pWizInfo)
            {
                lpRes = _pWizInfo->UserPressedCancel();
            }
            break;

        case LVN_ITEMCHANGED:
        {
            NMLISTVIEW *pNmListView = reinterpret_cast<NMLISTVIEW*>(lParam);
            if (pNmListView)
            {
                //
                // If this is a state change (check marks are stored as state image indices)
                //
                if ((pNmListView->uChanged & LVIF_STATE) && ((pNmListView->uOldState&LVIS_STATEIMAGEMASK) ^ (pNmListView->uNewState&LVIS_STATEIMAGEMASK)))
                {
                    //
                    // Get the item * from the LVITEM structure
                    //
                    CListItem *pItem = reinterpret_cast<CListItem *>(pNmListView->lParam);
                    if (pItem)
                    {
                        //
                        // If just added is true, ignore this notification, because
                        // we unfortunately get two notifications for items with check
                        // state set.  The first time, it is not set, so if we process it,
                        // it will clear the selection state.
                        //
                        if (pItem->JustAdded())
                        {
                            pItem->SetJustAdded(FALSE);
                        }
                        else
                        {
                            //
                            // Set selected flag in the item
                            //
                            pItem->SetSelectionState( IsStateChecked(pNmListView->uNewState) );

                            if (_pWizInfo)
                            {
                                //
                                // toggle all copies as well..
                                //

                                _pWizInfo->ToggleSelectionStateOnCopies( pItem, IsStateChecked(pNmListView->uNewState) );

                                //
                                // The previews are wrong, mark them as such...
                                //

                                _pWizInfo->SetPreviewsAreDirty(TRUE);

                                if (_bActive)
                                {
                                    DWORD dwFlags = PSWIZB_BACK;

                                    if (_pWizInfo->CountOfSelectedPhotos(FALSE) > 0)
                                    {
                                        dwFlags |= PSWIZB_NEXT;
                                        EnableWindow( GetDlgItem( _hDlg, IDC_CLEARALL ), TRUE );
                                    }
                                    else
                                    {
                                        EnableWindow( GetDlgItem( _hDlg, IDC_CLEARALL ), FALSE );
                                    }

                                    EnableWindow( GetDlgItem( _hDlg, IDC_SELECTALL ), (_pWizInfo->CountOfSelectedPhotos(FALSE) != _pWizInfo->CountOfPhotos(FALSE)) ? TRUE : FALSE );

                                    PropSheet_SetWizButtons( GetParent(_hDlg), dwFlags );
                                }

                            }

                        }
                    }
                }
            }
        }
        break;
    }

    SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, lpRes );
    return TRUE;

}



/*****************************************************************************

   CPhotoSelectionPage::DoHandleMessage

   Hanlder for messages sent to this page...

 *****************************************************************************/

INT_PTR CPhotoSelectionPage::DoHandleMessage( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DLGPROC, TEXT("CPhotoSelectionPage::DoHandleMessage( uMsg = 0x%x, wParam = 0x%x, lParam = 0x%x )"),uMsg,wParam,lParam));

    static CSimpleString strFormat( IDS_NUM_IMAGES_FORMAT, g_hInst );
    static CSimpleString strMessage;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            _hDlg = hDlg;
            return _OnInitDialog();
        }

        case WM_COMMAND:
            return _OnCommand(wParam, lParam);

        case WM_DESTROY:
            return _OnDestroy();

        case WM_NOTIFY:
            return _OnNotify(wParam, lParam);

        case WM_SYSCOLORCHANGE:

            //
            // Forward the color change message, and send a bogus setting change message, just
            // to be sure the control repaints
            //

            SendDlgItemMessage( _hDlg, IDC_THUMBNAILS, WM_SYSCOLORCHANGE, wParam, lParam );
            SendDlgItemMessage( _hDlg, IDC_THUMBNAILS, WM_SETTINGCHANGE, 0, 0 );
            break;

        case WM_SETTINGCHANGE:
            {

                //
                // Create a small image list, to prevent the checkbox state images from being resized in WM_SYSCOLORCHANGE
                //

                HIMAGELIST hImageListSmall = ImageList_Create( GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), ILC_COLOR32|ILC_MASK, 1, 1 );
                if (hImageListSmall)
                {
                    //
                    // Set the new image list and destroy the old one
                    //

                    HIMAGELIST hImgListOld = ListView_SetImageList( GetDlgItem( _hDlg, IDC_THUMBNAILS ), hImageListSmall, LVSIL_SMALL );
                    if (hImgListOld)
                    {
                        ImageList_Destroy(hImgListOld);
                    }
                }


                //
                // Forward the setting change message, and send a bogus color change message, just
                // to be sure the control repaints
                //

                SendDlgItemMessage( _hDlg, IDC_THUMBNAILS, WM_SETTINGCHANGE, wParam, lParam );
                SendDlgItemMessage( _hDlg, IDC_THUMBNAILS, WM_SYSCOLORCHANGE, 0, 0 );
            }
            break;

       case PSP_MSG_UPDATE_ITEM_COUNT:
           strMessage.Format( strFormat, wParam, lParam );
           strMessage.SetWindowText( GetDlgItem( _hDlg, IDC_NUM_IMAGES ) );
           break;

       case PSP_MSG_ADD_ITEM:
           _AddItemToListView( _pWizInfo, GetDlgItem( _hDlg, IDC_THUMBNAILS ), (INT)wParam, (INT)lParam );
           break;

       case PSP_MSG_SELECT_ITEM:
           ListView_SetItemState( GetDlgItem( _hDlg, IDC_THUMBNAILS ), wParam, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED );
           break;

       case PSP_MSG_NOT_ALL_LOADED:
           {
               CSimpleString strReject( IDS_NOT_ALL_IMAGES_WILL_PRINT, g_hInst );
               SetDlgItemText( _hDlg, IDC_NUM_IMAGES, strReject.String() );
           }
           break;

        case PSP_MSG_CLEAR_STATUS:
            SetDlgItemText( _hDlg, IDC_NUM_IMAGES, TEXT("") );
            break;

        case PSP_MSG_UPDATE_THUMBNAIL:
            {
                LVITEM lvItem = {0};
                lvItem.iItem  = (INT)wParam;
                lvItem.mask   = LVIF_IMAGE;
                lvItem.iImage = (INT)lParam;
                ListView_SetItem( GetDlgItem( _hDlg, IDC_THUMBNAILS ), &lvItem );
            }
            break;

    case PSP_MSG_ENABLE_BUTTONS:
            if (_pWizInfo)
            {
                EnableWindow( GetDlgItem( _hDlg, IDC_SELECTALL ), (((INT)wParam > 0) && (_pWizInfo->CountOfSelectedPhotos(FALSE) != _pWizInfo->CountOfPhotos(FALSE))) ? TRUE : FALSE );
            }
            else
            {
                EnableWindow( GetDlgItem( _hDlg, IDC_SELECTALL ), ((INT)wParam > 0) );
            }
            EnableWindow( GetDlgItem( _hDlg, IDC_CLEARALL ),  ((INT)wParam > 0) );
            break;

        case PSP_MSG_INVALIDATE_LISTVIEW:
            InvalidateRect( GetDlgItem( _hDlg, IDC_THUMBNAILS ), NULL, FALSE );
            break;

    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\photosel.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       photosel.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/18/00
 *
 *  DESCRIPTION: Photo selection dlg proc class header
 *
 *****************************************************************************/

#ifndef _PRINT_PHOTOS_WIZARD_PHOTO_SELECTION_DLG_PROC_
#define _PRINT_PHOTOS_WIZARD_PHOTO_SELECTION_DLG_PROC_

class CWizardInfoBlob;

#define PSP_MSG_UPDATE_ITEM_COUNT   (WM_USER+50)    // wParam = current item, lParam = total items
#define PSP_MSG_NOT_ALL_LOADED      (WM_USER+51)    // show the "not all items are being displayed" message
#define PSP_MSG_CLEAR_STATUS        (WM_USER+52)    // clear the status line
#define PSP_MSG_ADD_ITEM            (WM_USER+53)    // wParam = index of item to add, lParam = image list index for item
#define PSP_MSG_SELECT_ITEM         (WM_USER+54)    // wParam = index of item to select
#define PSP_MSG_UPDATE_THUMBNAIL    (WM_USER+55)    // wParam = index of listview item, lParam = index of new imagelist item
#define PSP_MSG_ENABLE_BUTTONS      (WM_USER+56)    // wParam = number of items in listview
#define PSP_MSG_INVALIDATE_LISTVIEW (WM_USER+57)    // no params


class CPhotoSelectionPage
{
public:
    CPhotoSelectionPage( CWizardInfoBlob * pBlob );
    ~CPhotoSelectionPage();

    INT_PTR DoHandleMessage( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    HWND    hwnd() {return _hDlg;};

    VOID    ShutDownBackgroundThreads();

private:

    VOID            _PopulateListView();
    static DWORD   s_UpdateThumbnailThreadProc(VOID *pv);

    // window message handlers
    LRESULT         _OnInitDialog();
    LRESULT         _OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT         _OnDestroy();
    LRESULT         _OnNotify(WPARAM wParam, LPARAM lParam);


private:
    CWizardInfoBlob *               _pWizInfo;
    HWND                            _hDlg;
    BOOL                            _bActive;
    HANDLE                          _hThumbnailThread;
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/12/00
 *
 *  DESCRIPTION: Precompiled header for photowiz dll
 *
 *****************************************************************************/

#ifndef _PHOTOWIZ_PRECOMP_H_
#define _PHOTOWIZ_PRECOMP_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <windows.h>
#include <commctrl.h>
#include <commoncontrols.h>
#include <objbase.h>
#include <advpub.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shlobjp.h>
#include <shlguidp.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <compstui.h>
#include <winddiui.h>
#include <winspool.h>
#include <prsht.h>
#include <shpriv.h>
#include <shfusion.h>
#include <atlbase.h>
#include <msxml.h>
#include <urlmon.h>
#include <errno.h>
#include <gdiplus.h>
#include <gdiplusinit.h>
#include <assert.h>


// psutil stuff
#include <psutil.h>
#include <tmplutil.h>

#include <wiadebug.h>
#include <uicommon.h>
#include <wiatextc.h>
#include <wiadevdp.h>
#include <annotlib.h>

//
// Trace mask fields
//

#define TRACE_CF                0x80000000
#define TRACE_REF_COUNTS        0x40000000
#define TRACE_UTIL              0x20000000
#define TRACE_DLGPROC           0x10000000
#define TRACE_WIZ_INFO_BLOB     0x08000000
#define TRACE_IDLIST            0x04000000
#define TRACE_XML               0x02000000
#define TRACE_LIST_ITEM         0x01000000
#define TRACE_PRINTTO           0x00800000
#define TRACE_PREVIEW           0x00000800
#define TRACE_PREVIEW_BITMAP    0x00000400
#define TRACE_TEMPLATE          0x00000200
#define TRACE_PAGE_END          0x00000100
#define TRACE_PAGE_STATUS       0x00000080
#define TRACE_PAGE_SEL_TEMPLATE 0x00000040
#define TRACE_PAGE_PRINT_OPT    0x00000020
#define TRACE_PAGE_PHOTO_SEL    0x00000010
#define TRACE_PAGE_START        0x00000008
#define TRACE_PHOTO_ITEM        0x00000004
#define TRACE_WIZ               0x00000002
#define TRACE_DROP              0x00000001


#define RESOLVE_PRINTER_MACROS 1

// from dll.cpp
EXTERN_C HINSTANCE g_hInst;
EXTERN_C ATOM      g_cPreviewClassWnd;
STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);
HMODULE       GetThreadHMODULE( LPTHREAD_START_ROUTINE pfnThreadProc );
STDAPI        PPWCoInitialize(void);
#define       PPWCoUninitialize(hr) if(SUCCEEDED(hr)){CoUninitialize();}

//
// Needs to be global
//

extern Gdiplus::Color g_wndColor;

typedef struct {

    RECT    rcDevice;
    BOOL    bDeviceIsScreen;
    SIZE    DPI;
    RECT    rcNominalTemplatePrintArea;
    RECT    rcNominalPageClip;
    SIZE    NominalDevicePrintArea;
    SIZE    NominalPageOffset;
    SIZE    NominalPhysicalSize;
    SIZE    NominalPhysicalOffset;


} RENDER_DIMENSIONS, *LPRENDER_DIMENSIONS;


#include "cfdefs.h"
#include "prwiziid.h"
#include "resource.h"
#include "item.h"
#include "listitem.h"
#include "xmltools2.h"
#include "preview.h"
#include "status.h"
#include "photosel.h"   // photosel.h must come after item.h
#include "wizblob.h"    // wizblob.h must come after item.h, preview.h
#include "printopt.h"
#include "seltemp.h"
#include "start.h"
#include "end.h"

#define SIZEOF sizeof

#define MAX_WIZPAGES 6

#define DEFAULT_THUMB_WIDTH 120
#define DEFAULT_THUMB_HEIGHT 120

//
// Let's define some custom error codes so that we can give better error messages
//

#define FACILITY_PPW    0x777
#define PPW_E_UNABLE_TO_ROTATE MAKE_HRESULT(SEVERITY_ERROR,FACILITY_PPW,0x1)


// from drop.cpp
STDAPI CPrintPhotosDropTarget_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

// from printwiz.cpp
STDAPI CPrintPhotosWizard_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

// from ccstock.h in nt\shell\inc
#ifdef __cplusplus
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#define IID_X_PPV_ARG(IType, X, ppType) IID_##IType, X, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#else
#define IID_PPV_ARG(IType, ppType) &IID_##IType, (void**)(ppType)
#define IID_X_PPV_ARG(IType, X, ppType) &IID_##IType, X, (void**)(ppType)
#endif
#define IID_PPV_ARG_NULL(IType, ppType) IID_X_PPV_ARG(IType, NULL, ppType)

// from netwiz.h in nt\shell\ext\netplwiz
typedef struct
{
    LPCWSTR idPage;
    DLGPROC pDlgProc;
    LPCWSTR pHeading;
    LPCWSTR pSubHeading;
    DWORD dwFlags;
} WIZPAGE;


#endif // !_PHOTOWIZ_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\printopt.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       printopt.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/18/00
 *
 *  DESCRIPTION: Implements code for the print options page of the
 *               print photos wizard...
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#define LENGTH_OF_MEDIA_NAME 64

/*****************************************************************************

    EnumPrintersWrap -- Wrapper function for spooler API EnumPrinters

    Arguments:

        pServerName - Specifies the name of the print server
        level - Level of PRINTER_INFO_x structure
        pcPrinters - Returns the number of printers enumerated
        dwFlags - Flag bits passed to EnumPrinters

    Return Value:

        Pointer to an array of PRINTER_INFO_x structures
        NULL if there is an error

 *****************************************************************************/

PVOID
EnumPrintersWrap(
    LPTSTR  pServerName,
    DWORD   level,
    PDWORD  pcPrinters,
    DWORD   dwFlags
    )

{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PRINT_OPT, TEXT("CPrintOptionsPage::EnumPrintersWrap()")));

    PBYTE   pPrinterInfo = NULL;
    int     iTry = -1;
    DWORD   cbNeeded = 0;
    BOOL    bStatus = FALSE;

    for( ;; )
    {
        if( iTry++ >= ENUM_MAX_RETRY )
        {
            // max retry count reached. this is also
            // considered out of memory case
            break;
        }

        // call EnumPrinters...
        bStatus = EnumPrinters(dwFlags, pServerName, level, pPrinterInfo, cbNeeded, &cbNeeded, pcPrinters);
        if( !bStatus && (ERROR_INSUFFICIENT_BUFFER == GetLastError()) && cbNeeded )
        {
            // buffer too small case
            if (pPrinterInfo)
            {
                delete [] pPrinterInfo;
            }

            WIA_TRACE((TEXT("EnumPrintersWrap: trying to allocate %d bytes"),cbNeeded));
            if( pPrinterInfo = (PBYTE) new BYTE[cbNeeded] )
            {
                continue;
            }
        }

        break;
    }

    if( bStatus )
    {
        return pPrinterInfo;
    }

    //
    // clean up if fail
    //
    if (pPrinterInfo)
    {
        delete [] pPrinterInfo;
    }

    return NULL;
}

/*****************************************************************************

    GetPrinterWrap -- Wrapper function for GetPrinter spooler API

    Arguments:

        szPrinterName - Printer name
        dwLevel - Specifies the level of PRINTER_INFO_x structure requested

    Return Value:

        Pointer to a PRINTER_INFO_x structure, NULL if there is an error

 *****************************************************************************/

PVOID
GetPrinterWrap(
    LPTSTR  szPrinterName,
    DWORD   dwLevel
    )

{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PRINT_OPT, TEXT("CPrintOptionsPage::GetPrinterWrap()")));

    int     iTry = -1;
    HANDLE  hPrinter = NULL;
    PBYTE   pPrinterInfo = NULL;
    DWORD   cbNeeded = 0;
    BOOL    bStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults;

    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_READ; //PRINTER_ALL_ACCESS;

    if (!OpenPrinter( szPrinterName, &hPrinter, &PrinterDefaults )) {
        return NULL;
    }

    for( ;; )
    {
        if( iTry++ >= ENUM_MAX_RETRY )
        {
            // max retry count reached. this is also
            // considered out of memory case
            WIA_TRACE(("Exceed max retries..."));
            break;
        }

        // call EnumPrinters...
        bStatus = GetPrinter( hPrinter, dwLevel, pPrinterInfo, cbNeeded, &cbNeeded );
        if( !bStatus && (ERROR_INSUFFICIENT_BUFFER == GetLastError()) && cbNeeded )
        {
            // buffer too small case
            if (pPrinterInfo)
            {
                delete [] pPrinterInfo;
            }

            WIA_TRACE((TEXT("GetPrinterWrap: trying to allocate %d bytes"),cbNeeded));
            if( pPrinterInfo = (PBYTE) new BYTE[cbNeeded] )
            {
                continue;
            }
        }

        break;
    }

    ClosePrinter( hPrinter );

    if( bStatus )
    {
        return pPrinterInfo;
    }

    //
    // clean up if fail
    //
    if (pPrinterInfo)
    {
        delete [] pPrinterInfo;
    }

    return NULL;
}

#ifdef FILTER_OUT_FAX_PRINTER
#include <faxreg.h>
/*****************************************************************************

    IsFaxPrinter -- test whether the given printer is a fax printer

    Arguments:

        szPrinterName - Printer name
        pPrinterInfo - PRINTER_INFO_2 printer info of given printer

        if they both have value, we only check szPrinterName.

    Return Value:

        TRUE if given printer is a fax printer, FALSE otherwise

 *****************************************************************************/

BOOL
IsFaxPrinter (
    LPTSTR  szPrinterName,
    PPRINTER_INFO_2 pPrinterInfo
    )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PRINT_OPT, TEXT("CPrintOptionsPage::IsFaxPrinter( %s )"),szPrinterName ? szPrinterName : TEXT("NULL POINTER!")));

    BOOL    bRet = FALSE;

    if( !szPrinterName && !pPrinterInfo )
    {
        return FALSE;
    }

    if( szPrinterName )
    {
        pPrinterInfo = (PPRINTER_INFO_2)GetPrinterWrap( szPrinterName, 2 );

        if( pPrinterInfo )
        {
            bRet = (0 == lstrcmp( pPrinterInfo->pDriverName, FAX_DRIVER_NAME )) ||
                   ( pPrinterInfo->Attributes & PRINTER_ATTRIBUTE_FAX );
            delete [] pPrinterInfo;

            return bRet;
        }
        else
        {
            WIA_ERROR((TEXT("Can't get printer info for %s!"), szPrinterName));
        }
    }

    return ((0 == lstrcmp(pPrinterInfo->pDriverName, FAX_DRIVER_NAME)) ||
            (pPrinterInfo->Attributes & PRINTER_ATTRIBUTE_FAX));
}
#endif

/*****************************************************************************

   CPrintOptionsPage -- constructor/desctructor

   <Notes>

 *****************************************************************************/

CPrintOptionsPage::CPrintOptionsPage( CWizardInfoBlob * pBlob ) :
    _hLibrary( NULL ),
    _pfnPrinterSetup( NULL )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PRINT_OPT, TEXT("CPrintOptionsPage::CPrintOptionsPage()")));
    _pWizInfo = pBlob;
    if (_pWizInfo)
    {
        _pWizInfo->AddRef();
    }

}

CPrintOptionsPage::~CPrintOptionsPage()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PRINT_OPT, TEXT("CPrintOptionsPage::~CPrintOptionsPage()")));

    if (_pWizInfo)
    {
        _pWizInfo->Release();
        _pWizInfo = NULL;
    }

    _FreePrintUI();
}


/*****************************************************************************

   CPrintOptionsPage::_bLoadLibrary -- load library printui.dll

   Return value: TRUE for success, FALSE for error

 *****************************************************************************/

BOOL CPrintOptionsPage::_LoadPrintUI( )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PRINT_OPT, TEXT("CPrintOptionsPage::_LoadPrintUI()")));

    if (_hLibrary && _pfnPrinterSetup)
    {
        WIA_TRACE((TEXT("_LoadPrintUI: already loaded printui, returning TRUE")));
        return TRUE;
    }

    if (!_hLibrary)
    {
        _hLibrary = LoadLibrary( g_szPrintLibraryName );
        if (!_hLibrary)
        {
            WIA_ERROR((TEXT("_LoadPrintUI: Can't load library printui.dll!")));
        }
    }

    if( _hLibrary && !_pfnPrinterSetup )
    {
        _pfnPrinterSetup = (PF_BPRINTERSETUP) ::GetProcAddress( _hLibrary, g_szPrinterSetup );

        if( _pfnPrinterSetup )
        {
            return TRUE;
        }
        else
        {
            WIA_ERROR((TEXT("_LoadPrintUI: Can't get correct proc address for %s!"),g_szPrinterSetup));
        }

    }

    if( _hLibrary )
    {
        FreeLibrary( _hLibrary );
        _hLibrary = NULL;
        _pfnPrinterSetup = NULL;
    }

    return FALSE;
}

/*****************************************************************************

   CPrintOptionsPage::_FreePrintUI -- release library printui.dll

   Return value: no return value

 *****************************************************************************/

VOID CPrintOptionsPage::_FreePrintUI( )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PRINT_OPT, TEXT("CPrintOptionsPage::_FreePrintUI()")));

    if( _hLibrary )
    {
        FreeLibrary( _hLibrary );
        _hLibrary = NULL;
        _pfnPrinterSetup = NULL;
    }

    return;
}

/*****************************************************************************

   CPrintOptionsPage::_ValidateControls -- validate controls in this page
       depending on printer selection

    Arguments:

        None

   Return value: no return value

 *****************************************************************************/

VOID CPrintOptionsPage::_ValidateControls( )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PRINT_OPT, TEXT("CPrintOptionsPage::_ValidateControls()")));

    HWND    hCtrl;
    LRESULT iCount;
    BOOL    bEnabled = TRUE;

    if( hCtrl = GetDlgItem( _hDlg, IDC_CHOOSE_PRINTER ))
    {
        iCount = SendMessage( hCtrl, CB_GETCOUNT, 0, 0L );
        if( iCount == CB_ERR )
        {
            // no change ?
            return;
        }
        else if( iCount == 0 )
        {
            bEnabled = FALSE;
        }

        ShowWindow( GetDlgItem( _hDlg, IDC_NO_PRINTER_TEXT), bEnabled ? SW_HIDE : SW_SHOW);
        EnableWindow( GetDlgItem(_hDlg, IDC_PRINTER_PREFERENCES), bEnabled );
        PropSheet_SetWizButtons( GetParent(_hDlg), PSWIZB_BACK | ( bEnabled ? PSWIZB_NEXT : 0 ));
    }

    return;
}

/*****************************************************************************

   CPrintOptionsPage::_HandleSelectPrinter -- reset the combo box content
       when user changes the printer selection

    Arguments:

        None

   Return value: no return value

 *****************************************************************************/

VOID CPrintOptionsPage::_HandleSelectPrinter()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PRINT_OPT, TEXT("CPrintOptionsPage::_HandleSelectPrinter()")));

    HWND    hCtrl;
    LRESULT iCurSel;
    TCHAR   szPrinterName[MAX_PATH];

    hCtrl = GetDlgItem( _hDlg, IDC_CHOOSE_PRINTER );

    if( hCtrl )
    {
        //
        // this also takes care of empty combo box situation,
        // the function will return CB_ERR if the combo box is
        // empty.
        //
        iCurSel = SendMessage( hCtrl, CB_GETCURSEL, 0, 0L );
        if( iCurSel == CB_ERR )
        {
            return;
        }

        *szPrinterName = 0;
        SendMessage( hCtrl, CB_GETLBTEXT, (WPARAM)iCurSel, (LPARAM)szPrinterName );
        _strPrinterName.Assign(szPrinterName);

        //
        // change the hDevMode for selected printer
        //

        PPRINTER_INFO_2 pPrinterInfo2;
        pPrinterInfo2 = (PPRINTER_INFO_2)GetPrinterWrap( szPrinterName, 2 );

        if( pPrinterInfo2 )
        {
            //
            // update cached information...
            //

            _UpdateCachedInfo( pPrinterInfo2->pDevMode );

            //
            // Save port name...
            //

            _strPortName.Assign( pPrinterInfo2->pPortName );


            delete [] pPrinterInfo2;
        }
        else
        {
            WIA_ERROR((TEXT("Can't get printer info for %s!"), szPrinterName));
        }

    }

    //
    // refresh the content of media type list
    //

    _ShowCurrentMedia( _strPrinterName.String(), _strPortName.String() );


    return;
}

/*****************************************************************************

   CPrintOptionsPage::_ShowCurrentMedia -- modify the combobox list of
        the media type.

   Return value: None.

 *****************************************************************************/

VOID CPrintOptionsPage::_ShowCurrentMedia( LPCTSTR pszPrinterName, LPCTSTR pszPortName )
{
    BOOL bEnable = FALSE;

    DWORD dwCountType = DeviceCapabilities( pszPrinterName,
                                            pszPortName,
                                            DC_MEDIATYPES,
                                            NULL,
                                            NULL );

    DWORD dwCountName = DeviceCapabilities( pszPrinterName,
                                            pszPortName,
                                            DC_MEDIATYPENAMES,
                                            NULL,
                                            NULL );

    WIA_ASSERT( dwCountType == dwCountName );
    if( ( (dwCountType != (DWORD)-1) && (dwCountType != 0) ) &&
        ( (dwCountName != (DWORD)-1) && (dwCountName != 0) ) )
    {
        LPDWORD pdwMediaType = (LPDWORD) new BYTE[dwCountType * sizeof(DWORD)];
        LPTSTR  pszMediaType = (LPTSTR)  new BYTE[dwCountName * LENGTH_OF_MEDIA_NAME * sizeof(TCHAR)];

        if( pdwMediaType && pszMediaType )
        {

            dwCountType = DeviceCapabilities( pszPrinterName,
                                              pszPortName,
                                              DC_MEDIATYPES,
                                              (LPTSTR)pdwMediaType,
                                              NULL );

            dwCountName = DeviceCapabilities( pszPrinterName,
                                              pszPortName,
                                              DC_MEDIATYPENAMES,
                                              (LPTSTR)pszMediaType,
                                              NULL );

            WIA_ASSERT( dwCountType == dwCountName );
            if ( ( (dwCountType != (DWORD)-1) && (dwCountType != 0) ) &&
                 ( (dwCountName != (DWORD)-1) && (dwCountName != 0) )
                 )
            {
                //
                // Find the currently selected media type...
                //

                if (_pWizInfo)
                {
                    PDEVMODE pDevMode = _pWizInfo->GetDevModeToUse();
                    if (pDevMode)
                    {
                        //
                        // find index of currently selected item...
                        //

                        DWORD dwCurMedia = 0;
                        for (INT i=0; i < (INT)dwCountType; i++)
                        {
                            if (pdwMediaType[i] == pDevMode->dmMediaType)
                            {
                                dwCurMedia = i;
                            }
                        }

                        //
                        // Set the current media type in the control...
                        //

                        if (dwCurMedia < dwCountName)
                        {
                            SetDlgItemText( _hDlg, IDC_CURRENT_PAPER, (LPCTSTR)&pszMediaType[ dwCurMedia * LENGTH_OF_MEDIA_NAME ] );
                            bEnable = TRUE;
                        }
                    }
                }
            }
        }

        if (pdwMediaType)
        {
            delete [] pdwMediaType;
        }

        if (pszMediaType)
        {
            delete [] pszMediaType;
        }
    }

    EnableWindow( GetDlgItem( _hDlg, IDC_CURRENT_PAPER_LABEL ), bEnable );
    ShowWindow(   GetDlgItem( _hDlg, IDC_CURRENT_PAPER_LABEL ), bEnable ? SW_SHOW : SW_HIDE );
    EnableWindow( GetDlgItem( _hDlg, IDC_CURRENT_PAPER ), bEnable );
    ShowWindow(   GetDlgItem( _hDlg, IDC_CURRENT_PAPER ), bEnable ? SW_SHOW : SW_HIDE );
}


/*****************************************************************************

   CPrintOptionsPage::_UpdateCachedInfo

   Given a devnode, updates _pWizInfo w/new cached information...

 *****************************************************************************/

VOID CPrintOptionsPage::_UpdateCachedInfo( PDEVMODE pDevMode )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PRINT_OPT, TEXT("CPrintOptionsPage::_UpdateCachedInfo()")));

    //
    // New devmode to use, cache it...
    //

    if (_pWizInfo)
    {
        //
        // User could have changed things which make
        // our preview assumptions invalid...
        //

        _pWizInfo->SetPreviewsAreDirty(TRUE);

        //
        // Store the devmode to use going forward...
        //

        WIA_TRACE((TEXT("CPrintOptionsPage::_UpdateCachedInfo - saving pDevMode of 0x%x"),pDevMode));
        _pWizInfo->SetDevModeToUse( pDevMode );

        //
        // Create an HDC that works for this new devmode...
        //

        HDC hDCPrint = CreateDC( TEXT("WINSPOOL"),
                                 _strPrinterName.String(),
                                 NULL,
                                 pDevMode
                                );
        if (hDCPrint)
        {
            //
            // Turn on ICM for this hDC just for parity's sake with
            // final hDC we will use to print...
            //

            SetICMMode( hDCPrint, ICM_ON );

            //
            // Hand off DC to pWizInfo
            //

            _pWizInfo->SetCachedPrinterDC( hDCPrint );

        }

    }

}



/*****************************************************************************

   CPrintOptionsPage::_HandlePrinterPreferences

   Handle when "Printer Preferences" is pressed...

 *****************************************************************************/

VOID CPrintOptionsPage::_HandlePrinterPreferences()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PRINT_OPT, TEXT("CPrintOptionsPage::_HandlePrinterPreferences()")));

    //
    // Get a handle to the printer...
    //

    HANDLE hPrinter = NULL;
    if (OpenPrinter( (LPTSTR)_strPrinterName.String(), &hPrinter, NULL ) && hPrinter)
    {
        //
        // Get the size of the devmode needed...
        //

        LONG lSize = DocumentProperties( _hDlg, hPrinter, (LPTSTR)_strPrinterName.String(), NULL, NULL, 0 );
        if (lSize)
        {
            PDEVMODE pDevMode = (PDEVMODE)new BYTE[lSize];
            if (pDevMode)
            {

                WIA_TRACE((TEXT("CPrintOptionsPage::_HandlePrinterPreferences - calling DocumentProperties with DM_IN_BUFFER of 0x%x"),_pWizInfo->GetDevModeToUse() ));
                if (IDOK == DocumentProperties( _hDlg, hPrinter, (LPTSTR)_strPrinterName.String(), pDevMode, _pWizInfo->GetDevModeToUse(), DM_OUT_BUFFER | DM_IN_BUFFER | DM_PROMPT))
                {
                    //
                    // Set these settings as the current ones for this app
                    //

                    _UpdateCachedInfo( pDevMode );

                }

                //
                // clean up so we don't leak...
                //

                delete [] pDevMode;

            }
        }
    }

    //
    // Get printer info so we have portname...
    //

    _ShowCurrentMedia( _strPrinterName.String(), _strPortName.String() );
}


/*****************************************************************************

   CPrintOptionsPage::_HandleInstallPrinter

   Handle when "Install Printer..." is pressed

 *****************************************************************************/

VOID CPrintOptionsPage::_HandleInstallPrinter()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PRINT_OPT, TEXT("CPrintOptionsPage::_HandleInstallPrinter()")));

    if( _LoadPrintUI() && _pfnPrinterSetup )
    {
        TCHAR szPrinterName[ MAX_PATH ];
        *szPrinterName        = 0;
        UINT  iPrinterNameLen = 0;

        //
        // Invoke the add printer wizard.
        //

        if( _pfnPrinterSetup( _hDlg,                  // Parent window handle
                              1,                      // Action code, 1 for modal, 11 for modeless
                              MAX_PATH,               // Length of printer name buffer
                              szPrinterName,          // Pointer to printer name
                              &iPrinterNameLen,       // Return length of printer name.
                              NULL ) )                // Server name, NULL for local
        {
            LRESULT iNew;

            HWND hCtrl = GetDlgItem( _hDlg, IDC_CHOOSE_PRINTER );

#ifdef FILTER_OUT_FAX_PRINTER
            if( hCtrl && !IsFaxPrinter( szPrinterName, NULL ) &&
#else
            if( hCtrl &&
#endif
                CB_ERR == SendMessage( hCtrl, CB_FINDSTRINGEXACT, 0, (LPARAM)szPrinterName ) )
            {
                iNew = SendMessage( hCtrl, CB_ADDSTRING, 0, (LPARAM)szPrinterName );
                if( iNew != CB_ERR )
                {
                    SendMessage( hCtrl, CB_SETCURSEL, iNew, 0L );
                    _strPrinterName = szPrinterName;
                }

                //
                // reset the dropped width if necessary
                //

                WiaUiUtil::ModifyComboBoxDropWidth( hCtrl );
                _ValidateControls();
                _HandleSelectPrinter();
            }
        }
    }

}


/*****************************************************************************

   CPrintOptionsPage::OnInitDialog

   Handle initializing the wizard page...

 *****************************************************************************/

LRESULT CPrintOptionsPage::_OnInitDialog()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PRINT_OPT, TEXT("CPrintOptionsPage::_OnInitDialog()")));

    HWND            hCtrl;
    TCHAR           szPrinterName[ MAX_PATH ];
    PPRINTER_INFO_2 pPrinterInfo = NULL;
    DWORD           dwCountPrinters;
    DWORD           i;
    DWORD           dwPrinterNameLen;



    hCtrl = GetDlgItem( _hDlg, IDC_CHOOSE_PRINTER );
    if( !hCtrl )
    {
        return FALSE;
    }

    pPrinterInfo = (PPRINTER_INFO_2) EnumPrintersWrap( NULL, 2, &dwCountPrinters,
        PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS );

    if( pPrinterInfo )
    {
        for( i = 0; i < dwCountPrinters; i++)
        {
#ifdef FILTER_OUT_FAX_PRINTER
            if( !IsFaxPrinter( NULL, &pPrinterInfo[i] ) )
            {
                SendMessage( hCtrl, CB_ADDSTRING, 0, (LPARAM)pPrinterInfo[i].pPrinterName );
            }
#else
            SendMessage( hCtrl, CB_ADDSTRING, 0, (LPARAM)pPrinterInfo[i].pPrinterName );
#endif
        }

        //
        // select the default printer if possible
        //
        szPrinterName[0] = '\0';
        dwPrinterNameLen = MAX_PATH;

        //
        // if fax printer is default printer, we'll select the first printer in the list
        //
        SendMessage( hCtrl, CB_SETCURSEL, 0, 0L );
        if( GetDefaultPrinter( (LPTSTR)szPrinterName, &dwPrinterNameLen ) )
        {
            SendMessage( hCtrl, CB_SELECTSTRING, -1, (LPARAM)szPrinterName );
        }

        delete [] pPrinterInfo;
    }
    else
    {
        WIA_ERROR((TEXT("Can't enumerate printer info!")));
    }

    WiaUiUtil::ModifyComboBoxDropWidth( hCtrl );
    _HandleSelectPrinter();

    return TRUE;
}

/*****************************************************************************

   CPrintOptionsPage::OnCommand

   Handle WM_COMMAND for this dlg page

 *****************************************************************************/

LRESULT CPrintOptionsPage::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PRINT_OPT, TEXT("CPrintOptionsPage::_OnCommand()")));


    switch (LOWORD(wParam))
    {
        case IDC_PRINTER_PREFERENCES:
        {
            _HandlePrinterPreferences();
            break;
        }

        case IDC_INSTALL_PRINTER:
        {
            _HandleInstallPrinter();
            break;
        }

        case IDC_CHOOSE_PRINTER:
        {
            if( HIWORD(wParam) == CBN_SELCHANGE )
            {
                //
                // change the combobox content of the media type
                //
                _HandleSelectPrinter();
            }
            break;
        }

    }

    return 0;
}


/*****************************************************************************

   CPrintOptions::_OnKillActive

   Save settings into the wizard info blob when the page changes away from
   us...

 *****************************************************************************/

VOID CPrintOptionsPage::_OnKillActive()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_PRINT_OPT, TEXT("CPrintOptionsPage::_OnKillActive()")));

    //
    // set the printer to use for later retrieval
    //
    if (_pWizInfo)
    {
        _pWizInfo->SetPrinterToUse( _strPrinterName.String() );
    }
}


/*****************************************************************************

   CPrintOptions::_OnNotify

   Handles WM_NOTIFY for this page...

 *****************************************************************************/

LRESULT CPrintOptionsPage::_OnNotify( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DLGPROC, TEXT("CPrintOptionsPage::_OnNotify()")));

    LONG_PTR lpRes = 0;

    LPNMHDR pnmh = (LPNMHDR)lParam;
    switch (pnmh->code)
    {
        case PSN_SETACTIVE:
            WIA_TRACE((TEXT("got PSN_SETACTIVE")));
            PropSheet_SetWizButtons( GetParent(_hDlg), PSWIZB_BACK | PSWIZB_NEXT );

            //
            // disable the Next button if the printer list is empty
            //
            _ValidateControls();
            lpRes = 0;
            break;

        case PSN_WIZNEXT:
            WIA_TRACE((TEXT("CPrintOptionsPage: got PSN_WIZNEXT")));
            lpRes = IDD_SELECT_TEMPLATE;
            break;

        case PSN_WIZBACK:
            WIA_TRACE((TEXT("CPrintOptionsPage: got PSN_WIZBACK")));
            if (_pWizInfo && (_pWizInfo->CountOfPhotos(FALSE)==1))
            {
                lpRes = IDD_START_PAGE;
            }
            else
            {
                lpRes = IDD_PICTURE_SELECTION;
            }
            break;

        case PSN_KILLACTIVE:
            WIA_TRACE((TEXT("CPrintOptionsPage: got PSN_KILLACTIVE")));
            _OnKillActive();
            break;

        case PSN_QUERYCANCEL:
            WIA_TRACE((TEXT("CPrintOptionsPage: got PSN_QUERYCANCEL")));
            if (_pWizInfo)
            {
                lpRes = _pWizInfo->UserPressedCancel();
            }
            break;


    }

    SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, lpRes );

    return TRUE;

}


/*****************************************************************************

   CPrintOptionsPage::DoHandleMessage

   Hanlder for messages sent to this page...

 *****************************************************************************/

INT_PTR CPrintOptionsPage::DoHandleMessage( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    HWND    hCtrl;
    TCHAR   szPrinterName[ MAX_PATH ];

    WIA_PUSH_FUNCTION_MASK((TRACE_DLGPROC, TEXT("CPrintOptionsPage::DoHandleMessage( uMsg = 0x%x, wParam = 0x%x, lParam = 0x%x )"),uMsg,wParam,lParam));

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            _hDlg = hDlg;
            return _OnInitDialog();

        case WM_COMMAND:
            return _OnCommand(wParam, lParam);

        case WM_NOTIFY:
            return _OnNotify(wParam, lParam);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\printwiz.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       printwiz.cpp
 *
 *  VERSION:     1.0, stolen from netplwiz (pubwiz.cpp)
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/12/00
 *
 *  DESCRIPTION: Implements IWizardExtension for printing wizard
 *
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

class CPrintPhotosWizard : public IPrintPhotosWizardSetInfo
{
public:
    CPrintPhotosWizard();
    ~CPrintPhotosWizard();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IPrintPhotosWizardSetInfo
    STDMETHODIMP SetFileListDataObject( IDataObject * pdo );
    STDMETHODIMP SetFileListArray( LPITEMIDLIST *aidl, int cidl, int iSelectedItem);
    STDMETHODIMP RunWizard( VOID );

private:
    LONG            _cRef;                      // object lifetime count
    HPROPSHEETPAGE  _aWizPages[MAX_WIZPAGES];   // page handles for this wizard (so we can navigate)
    CComPtr<IDataObject> _pdo;                  // dataobject which contains files to print
    LPITEMIDLIST*   _aidl;
    int             _cidl;
    int             _iSelection;
    HRESULT         _CreateWizardPages(void);   // construct and load our wizard pages


    // Get a pointer to our wizard class from static members
    static CPrintPhotosWizard* s_GetPPW(HWND hwnd, UINT uMsg, LPARAM lParam);

    // DlgProc's for our wizard pages -- we forward through s_GetPPW
    CStartPage          * _pStartPage;
    CPhotoSelectionPage * _pPhotoSelectionPage;
    CPrintOptionsPage   * _pPrintOptionsPage;
    CSelectTemplatePage * _pSelectTemplatePage;
    CStatusPage         * _pStatusPage;
    CEndPage            * _pEndPage;

    static INT_PTR s_StartPageDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) \
        { \
            CPrintPhotosWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); \
            if (ppw && ppw->_pStartPage) \
            { \
                return ppw->_pStartPage->DoHandleMessage(hwnd, uMsg, wParam, lParam); \
            } \
            return FALSE; \
        }


    static INT_PTR s_PictureSelectionDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) \
        { \
            CPrintPhotosWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); \
            if (ppw && ppw->_pPhotoSelectionPage) \
            { \
                return ppw->_pPhotoSelectionPage->DoHandleMessage(hwnd, uMsg, wParam, lParam); \
            } \
            return FALSE; \
        }

    static INT_PTR s_PrintOptionsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) \
        { \
            CPrintPhotosWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); \
            if (ppw && ppw->_pPrintOptionsPage) \
            { \
                return ppw->_pPrintOptionsPage->DoHandleMessage(hwnd, uMsg, wParam, lParam); \
            } \
            return FALSE; \
        }

    static INT_PTR s_SelectTemplateDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { \
            CPrintPhotosWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); \
            if (ppw && ppw->_pSelectTemplatePage) \
            { \
                return ppw->_pSelectTemplatePage->DoHandleMessage(hwnd, uMsg, wParam, lParam); \
            } \
            return FALSE; \
        }


    static INT_PTR s_StatusPageDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) \
        { \
            CPrintPhotosWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); \
            if (ppw && ppw->_pStatusPage) \
            { \
                return ppw->_pStatusPage->DoHandleMessage(hwnd, uMsg, wParam, lParam); \
            } \
            return FALSE; \
        }


    static INT_PTR s_EndPageDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) \
        { \
            CPrintPhotosWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); \
            if (ppw && ppw->_pEndPage) \
            { \
                return ppw->_pEndPage->DoHandleMessage(hwnd, uMsg, wParam, lParam); \
            } \
            return FALSE; \
        }

};



/*****************************************************************************

   CPrintPhotosWizard constructor/destructor

   <Notes>

 *****************************************************************************/

CPrintPhotosWizard::CPrintPhotosWizard() :
    _cRef(1),
    _pStartPage(NULL),
    _pPhotoSelectionPage(NULL),
    _pPrintOptionsPage(NULL),
    _pSelectTemplatePage(NULL),
    _pStatusPage(NULL),
    _pEndPage(NULL),
    _cidl(0),
    _aidl(NULL),
    _iSelection(0)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ,TEXT("CPrintPhotosWizard::CPrintPhotosWizard( this == 0x%x )"), this));
    DllAddRef();
}

CPrintPhotosWizard::~CPrintPhotosWizard()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ,TEXT("CPrintPhotosWizard::~CPrintPhotosWizard( this == 0x%x )"), this));
    if (_aidl)
    {
        for (int i=0;i<_cidl;i++)
        {
            ILFree(_aidl[i]);
        }
        delete[] _aidl;
    }
    DllRelease();
}


/*****************************************************************************

   CPrintPhotosWizard IUnknown methods

   <Notes>

 *****************************************************************************/

ULONG CPrintPhotosWizard::AddRef()
{
    ULONG ul = InterlockedIncrement(&_cRef);

    WIA_PUSH_FUNCTION_MASK((TRACE_REF_COUNTS,TEXT("CPrintPhotosWizard::AddRef( new count is %d )"),ul));

    return ul;
}

ULONG CPrintPhotosWizard::Release()
{
    ULONG ul = InterlockedDecrement(&_cRef);

    WIA_PUSH_FUNCTION_MASK((TRACE_REF_COUNTS,TEXT("CPrintPhotosWizard::Release( new count is %d )"),ul));

    if (ul)
        return ul;

    WIA_TRACE((TEXT("deleting object ( this == 0x%x ) because ref count is zero."),this));
    delete this;
    return 0;
}

HRESULT CPrintPhotosWizard::QueryInterface(REFIID riid, void **ppv)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_REF_COUNTS,TEXT("CPrintPhotosWizard::QueryInterface()")));

    static const QITAB qit[] =
    {
        QITABENT(CPrintPhotosWizard, IPrintPhotosWizardSetInfo),  // IID_IPrintPhotosWizardSetInfo
        {0, 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppv);

    WIA_RETURN_HR(hr);
}


/*****************************************************************************

   CPrintPhotosWizard_CreateInstance

   Creates an instance of our wizard

 *****************************************************************************/

STDAPI CPrintPhotosWizard_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ,TEXT("CPrintPhotosWizard_CreateInstance()")));

    CPrintPhotosWizard *pwiz = new CPrintPhotosWizard();
    if (!pwiz)
    {
        *ppunk = NULL;          // incase of failure
        WIA_ERROR((TEXT("returning E_OUTOFMEMORY")));
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pwiz->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));

    pwiz->Release(); // we do this release because the new of CPrintPhotosWizard
                     // set the ref count to 1, doing the QI bumps it up to 2,
                     // and we want to leave this function with the ref count
                     // at zero...

    WIA_RETURN_HR(hr);
}



/*****************************************************************************

   CPrintPhotosWizard::s_GetPPW

   static function that stores the "this" pointer for the class in
   user data slot of dlg, so that we can have our wndproc's as methods
   of this class.

 *****************************************************************************/

CPrintPhotosWizard* CPrintPhotosWizard::s_GetPPW(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DLGPROC,TEXT("CPrintPhotosWizard::s_GetPPW()")));

    if (uMsg == WM_INITDIALOG)
    {
        PROPSHEETPAGE *ppsp = (PROPSHEETPAGE*)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, ppsp->lParam);
        return (CPrintPhotosWizard*)ppsp->lParam;
    }
    return (CPrintPhotosWizard*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
}



/*****************************************************************************

   CPrintPhotosWizard::_CreateWizardPages

   utility function to contruct and then create our wizard pages (property
   sheets).

 *****************************************************************************/


HRESULT CPrintPhotosWizard::_CreateWizardPages( VOID )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ,TEXT("CPrintPhotosWizard::_CreateWizardPages()")));

#define WIZDLG(name, dlgproc, title, sub, dwFlags)   \
    { MAKEINTRESOURCE(##name##), dlgproc, MAKEINTRESOURCE(##title##), MAKEINTRESOURCE(##sub##), dwFlags }

    static const WIZPAGE c_wpPages[] =
    {
        WIZDLG(IDD_START_PAGE,        CPrintPhotosWizard::s_StartPageDlgProc,        0,                         0,                            PSP_HIDEHEADER),
        WIZDLG(IDD_PICTURE_SELECTION, CPrintPhotosWizard::s_PictureSelectionDlgProc, IDS_WIZ_SEL_PICTURE_TITLE, IDS_WIZ_SEL_PICTURE_SUBTITLE, PSP_PREMATURE),
        WIZDLG(IDD_PRINTING_OPTIONS,  CPrintPhotosWizard::s_PrintOptionsDlgProc,     IDS_WIZ_PRINTER_OPT_TITLE, IDS_WIZ_PRINTER_OPT_SUBTITLE, 0),
        WIZDLG(IDD_SELECT_TEMPLATE,   CPrintPhotosWizard::s_SelectTemplateDlgProc,   IDS_WIZ_SEL_TEMPLATE_TITLE, IDS_WIZ_SEL_TEMPLATE_SUBTITLE, PSP_PREMATURE),
        WIZDLG(IDD_PRINT_PROGRESS,    CPrintPhotosWizard::s_StatusPageDlgProc,       IDS_WIZ_PRINT_PROGRESS_TITLE, IDS_WIZ_PRINT_PROGRESS_SUBTITLE, PSP_PREMATURE),
        WIZDLG(IDD_END_PAGE,          CPrintPhotosWizard::s_EndPageDlgProc,          0,                         0,                            PSP_HIDEHEADER),
    };


    // if we haven't created the pages yet, then lets initialize our array of handlers.

    if (!_aWizPages[0])
    {
        WIA_TRACE((TEXT("Pages have not been created yet, creating them now...")));

        INITCOMMONCONTROLSEX iccex = { 0 };
        iccex.dwSize = sizeof (iccex);
        iccex.dwICC  = ICC_LISTVIEW_CLASSES | ICC_USEREX_CLASSES | ICC_PROGRESS_CLASS;
        WIA_TRACE((TEXT("Initializing common controls...")));
        InitCommonControlsEx(&iccex);

        for (int i = 0; i < ARRAYSIZE(c_wpPages) ; i++ )
        {
            PROPSHEETPAGE psp = { 0 };
            psp.dwSize = SIZEOF(PROPSHEETPAGE);
            psp.hInstance = g_hInst;
            psp.lParam = (LPARAM)this;
            psp.dwFlags = PSP_USETITLE | PSP_DEFAULT |
                          PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE |
                          c_wpPages[i].dwFlags;

            psp.pszTemplate = c_wpPages[i].idPage;
            psp.pfnDlgProc = c_wpPages[i].pDlgProc;
            psp.pszTitle = MAKEINTRESOURCE(IDS_WIZ_TITLE);
            psp.pszHeaderTitle = c_wpPages[i].pHeading;
            psp.pszHeaderSubTitle = c_wpPages[i].pSubHeading;

            WIA_TRACE((TEXT("attempting to create page %d"),i));
            _aWizPages[i] = CreatePropertySheetPage(&psp);
            if (!_aWizPages[i])
            {
                WIA_ERROR((TEXT("returning E_FAIL because wizard page %d didn't create."),i));
                return E_FAIL;
            }
        }
    }
    else
    {
        WIA_TRACE((TEXT("Wizard pages already created.")));
    }

    return S_OK;
}

/*****************************************************************************

   CPrintPhotosWizard [IPrintPhotosWizardSetInfo methods]

   <Notes>

 *****************************************************************************/

STDMETHODIMP CPrintPhotosWizard::SetFileListDataObject( IDataObject * pdo )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ,TEXT("CPrintPhotosWizard::SetFileListDataObject()")));

    HRESULT hr = E_INVALIDARG;

    if (pdo)
    {
        _pdo = pdo;
        hr   = S_OK;
    }

    WIA_RETURN_HR(hr);
}


STDMETHODIMP CPrintPhotosWizard::SetFileListArray( LPITEMIDLIST *aidl, int cidl, int iSelection )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ,TEXT("CPrintPhotosWizard::SetFileListArray()")));

    HRESULT hr = E_INVALIDARG;

    if (aidl && cidl)
    {
        _aidl = new LPITEMIDLIST[cidl];
        if (_aidl)
        {
            for (int i=0;i<cidl;i++)
            {
                _aidl[i] = ILClone(aidl[i]);
            }
            if (iSelection > 0)
            {
                LPITEMIDLIST pTemp = _aidl[0];
                _aidl[0] = _aidl[iSelection];
                _aidl[iSelection] = pTemp;
            }
            _cidl = cidl;
            _iSelection = iSelection;
            hr   = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }        
    }

    WIA_RETURN_HR(hr);
}

STDMETHODIMP CPrintPhotosWizard::RunWizard( VOID )
{
    HRESULT hr = E_FAIL;

    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ,TEXT("CPrintPhotosWizard::RunWizard()")));

    //
    // Create wizard blob
    //

    CWizardInfoBlob * pBlob = new CWizardInfoBlob( _aidl?NULL:_pdo, TRUE, FALSE );
    if (pBlob && _aidl)
    {
        pBlob->AddPhotosFromList(_aidl, _cidl, _iSelection >= 0? FALSE:TRUE);
    }
    //
    // Create each page handling class
    //

    _pStartPage          = new CStartPage( pBlob );
    _pPhotoSelectionPage = new CPhotoSelectionPage( pBlob );
    _pPrintOptionsPage   = new CPrintOptionsPage( pBlob );
    _pSelectTemplatePage = new CSelectTemplatePage( pBlob );
    _pStatusPage         = new CStatusPage( pBlob );
    _pEndPage            = new CEndPage( pBlob );

    //
    // Create the wizard pages...
    //

    hr = _CreateWizardPages();
    WIA_CHECK_HR(hr,"_CreateWizardPages()");

    if (SUCCEEDED(hr))
    {
        PROPSHEETHEADER psh = {0};

        psh.dwSize      = sizeof(PROPSHEETHEADER);
        psh.dwFlags     = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
        psh.hwndParent  = NULL;
        psh.hInstance   = g_hInst;
        psh.nPages      = MAX_WIZPAGES;
        psh.nStartPage  = 0;
        psh.phpage      = (HPROPSHEETPAGE *)_aWizPages;
        psh.pszbmHeader = MAKEINTRESOURCE(IDB_BANNER);
        psh.pszbmWatermark = MAKEINTRESOURCE(IDB_WATERMARK);

        WIA_TRACE((TEXT("Wizard pages created, trying to start wizard via PropertySheet()...")));

        if (PropertySheet( &psh ))
        {
            hr = S_OK;
        }
        else
        {
            WIA_ERROR((TEXT("PropertySheet() failed")));
        }
    }

    //
    // Give wizard a chance to shut down in an orderly fashion...
    //

    pBlob->ShutDownWizard();

    //
    // clean up page handling classes...
    //

    if (_pStartPage)
    {
        delete _pStartPage;
        _pStartPage = NULL;
    }

    if (_pPhotoSelectionPage)
    {
        delete _pPhotoSelectionPage;
        _pPhotoSelectionPage = NULL;
    }

    if (_pPrintOptionsPage)
    {
        delete _pPrintOptionsPage;
        _pPrintOptionsPage = NULL;
    }

    if (_pSelectTemplatePage)
    {
        delete _pSelectTemplatePage;
        _pSelectTemplatePage = NULL;
    }

    if (_pStatusPage)
    {
        delete _pStatusPage;
        _pStatusPage = NULL;
    }

    if (_pEndPage)
    {
        delete _pEndPage;
        _pEndPage = NULL;
    }

    WIA_RETURN_HR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\preview.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       preview.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        11/02/00
 *
 *  DESCRIPTION: Class which backs up the template preview window
 *
 *****************************************************************************/

#ifndef _PRINT_PHOTOS_PREVIEW_H_
#define _PRINT_PHOTOS_PREVIEW_H_


#define PW_SETNEWTEMPLATE   (WM_USER+1)     // wParam holds index of template that was chosen


class CWizardInfoBlob;
class CPreviewBitmap;
extern ATOM g_cPreviewClassWnd;

#define PREVIEW_WIDTH 200
#define PREVIEW_HEIGHT 260



typedef struct {
    HBITMAP hPrevBmp;
    BOOL    bValid;
    BOOL    bBitmapGenerationInProgress;
    CPreviewBitmap * pPreviewBitmap;
} PREVIEW_STATE, *LPPREVIEW_STATE;


#define PV_MSG_PREVIEW_BITMAP_AVAILABLE (WM_USER+100)   // wParam is template index
                                                        // lParam holds hBitmap of image to show.
                                                        // hBitmap must be freed by receiver of message.

#define PV_MSG_GENERATE_NEW_PREVIEW (WM_USER+101)       // wParam is template index

#define PV_NO_LAST_TEMPLATE_CHOSEN  -1

class CPreviewWindow
{

public:

    static CPreviewWindow* s_GetPW(HWND hwnd, UINT uMsg, LPARAM lParam)
    {
        WIA_PUSH_FUNCTION_MASK((0x10000000,TEXT("CPreviewWindow::s_GetPW()")));
        if ((uMsg == WM_CREATE) || (uMsg == WM_NCCREATE))
        {
            WIA_TRACE((TEXT("got WM_CREATE or WM_NCCREATE")));
            if (lParam)
            {
                WIA_TRACE((TEXT("Setting GWLP_USERDATA to be 0x%x"),((LPCREATESTRUCT)lParam)->lpCreateParams));
                SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)((LPCREATESTRUCT)lParam)->lpCreateParams );
            }
        }
        return (CPreviewWindow*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }


    static LRESULT s_PreviewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        WIA_PUSH_FUNCTION_MASK((0x10000000,TEXT("CPreviewWindow::s_PreviewWndProc( 0x%x, 0x%x, 0x%x, 0x%x)"),hwnd,uMsg,wParam,lParam));
        CPreviewWindow *pw = CPreviewWindow::s_GetPW(hwnd, uMsg, lParam);
        if (pw)
        {
            return pw->DoHandleMessage(hwnd, uMsg, wParam, lParam);
        }
        else
        {
            WIA_ERROR((TEXT("Got back NULL pw!")));
        }
        return FALSE;
    }

    static VOID s_RegisterClass( HINSTANCE hInstance )
    {
        WIA_PUSH_FUNCTION_MASK((0x100,TEXT("CPreviewWindow::s_RegisterClass()")));
        if (!g_cPreviewClassWnd)
        {
            WNDCLASSEX wcex = {0};
            wcex.cbSize = sizeof(wcex);
            wcex.style  = CS_HREDRAW | CS_VREDRAW;
            wcex.lpfnWndProc = CPreviewWindow::s_PreviewWndProc;
            wcex.hInstance = hInstance;
            wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
            wcex.lpszClassName = TEXT("PhotoPrintingPreviewWindowClass");
            ::g_cPreviewClassWnd = RegisterClassEx(&wcex);
            if (!::g_cPreviewClassWnd)
            {
                WIA_ERROR((TEXT("Couldn't register class, GLE = %d"),GetLastError()));
            }
        }
    }

public:

    CPreviewWindow( CWizardInfoBlob * pWizInfo );
    ~CPreviewWindow();

    LRESULT DoHandleMessage( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    LRESULT OnSetNewTemplate( WPARAM wParam, HDC hdc = NULL );
    VOID    DrawBitmap( HBITMAP hBitmap, HDC hdc = NULL );
    HBITMAP GetPreviewBitmap( INT iTemplate );
    VOID    GenerateNewPreview( INT iTemplate );
    VOID    GenerateWorkingBitmap( HWND hwnd );
    VOID    ShowStillWorking( HWND hwnd );
    VOID    InvalidateAllPreviews();
    VOID    ShutDownBackgroundThreads();
    VOID    StallBackgroundThreads();
    VOID    RestartBackgroundThreads();

private:

    LRESULT _OnNewPreviewAvailable( WPARAM wParam, LPARAM lParam );
    LRESULT _OnPaint();
    LRESULT _OnSize( WPARAM wParam, LPARAM lParam );
    VOID _InitList();


private:


    CWizardInfoBlob       * _pWizInfo;
    INT                     _LastTemplate;
    PREVIEW_STATE         * _hPreviewList;
    INT                     _NumTemplates;
    HWND                    _hwnd;
    HWND                    _hwndProgress;
    CSimpleCriticalSection  _csList;
    HBITMAP                 _hStillWorkingBitmap;
    BOOL                    _bThreadsAreStalled;

};

#define PVB_MSG_START (WM_USER+200)
#define PVB_MSG_GENERATE_PREVIEW    (PVB_MSG_START)
#define PVB_MSG_EXIT_THREAD         (PVB_MSG_START+1)
#define PVB_MSG_END                 (PVB_MSG_EXIT_THREAD)


class CPreviewBitmap
{
public:
    CPreviewBitmap( CWizardInfoBlob * pWizInfo, HWND hwnd, INT iTemplateIndex );
    ~CPreviewBitmap();

    VOID    Invalidate();
    HRESULT GetPreview();
    VOID    MessageQueueCreated();
    VOID    GeneratePreview();
    VOID    StallThread();
    VOID    RestartThread();


    static DWORD CPreviewBitmap::s_PreviewBitmapWorkerThread(void *pv);

private:
    HWND                    _hwndPreview;
    INT                     _iTemplateIndex;
    CWizardInfoBlob *       _pWizInfo;
    CSimpleCriticalSection  _csItem;
    HANDLE                  _hWorkThread;
    DWORD                   _dwWorkThreadId;
    HANDLE                  _hEventForMessageQueueCreation;
    BOOL                    _bThreadIsStalled;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\preview.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       preview.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        11/02/00
 *
 *  DESCRIPTION: Template Preview Window implementation
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop



/*****************************************************************************

   GetProgressControlRect

   Takes preivew window as an input, returns a rectangle that contains
   the size of the progress control

 *****************************************************************************/

void GetProgressControlRect( HWND hwnd, RECT * pRect )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("GetProgressControlRect()")));

    if (pRect)
    {
        if (hwnd)
        {
            RECT rcWnd = {0};
            GetClientRect( hwnd, &rcWnd );

            WIA_TRACE((TEXT("GetProgressControlRect: client rect is %d,%d,%d,%d"),rcWnd.left, rcWnd.top, rcWnd.right, rcWnd.bottom));

            pRect->left  = rcWnd.left + ((rcWnd.right - rcWnd.left) / 10);
            pRect->right = rcWnd.right - (pRect->left - rcWnd.left);
            pRect->top   = rcWnd.top  + ((rcWnd.bottom - rcWnd.top) / 2) + 15;

            //
            // Themes requires that progress bars be at least 10 pix high
            //

            pRect->bottom = pRect->top + 10;

            WIA_TRACE((TEXT("GetProgressControlRect: progress control rect being returned as %d,%d,%d,%d"),pRect->left,pRect->top,pRect->right,pRect->bottom));
        }
    }
}


/*****************************************************************************

   CPreviewBitmap constructor/destructor



 *****************************************************************************/

CPreviewBitmap::CPreviewBitmap( CWizardInfoBlob * pWizInfo, HWND hwnd, INT iTemplateIndex )
  : _hwndPreview(hwnd),
    _iTemplateIndex(iTemplateIndex),
    _hWorkThread(NULL),
    _dwWorkThreadId(0),
    _pWizInfo(pWizInfo),
    _bThreadIsStalled(FALSE)

{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW_BITMAP,TEXT("CPreviewBitmap::CPreviewBitmap( %i )"),iTemplateIndex));

    if (_pWizInfo)
    {
        _pWizInfo->AddRef();
    }

    _hEventForMessageQueueCreation = CreateEvent( NULL, FALSE, FALSE, NULL );

}

CPreviewBitmap::~CPreviewBitmap()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW_BITMAP,TEXT("CPreviewBitmap::~CPreviewBitmap( %i )"),_iTemplateIndex));

    CAutoCriticalSection lock(_csItem);

    //
    // Tell thread to exit and then for it to exit...
    //

    if (_hWorkThread && _dwWorkThreadId)
    {
        PostThreadMessage( _dwWorkThreadId, PVB_MSG_EXIT_THREAD, 0, 0 );
        WiaUiUtil::MsgWaitForSingleObject( _hWorkThread, INFINITE );
        CloseHandle( _hWorkThread );
    }

    //
    // Now that the thread is closed (or never created), close the event handle...
    //

    if (_hEventForMessageQueueCreation)
    {
        CloseHandle( _hEventForMessageQueueCreation );
        _hEventForMessageQueueCreation = NULL;
    }

    //
    // Let go of wizard class
    //

    if (_pWizInfo)
    {
        _pWizInfo->Release();
        _pWizInfo = NULL;
    }
}


/*****************************************************************************

   CPreviewBitmap::MessageQueueCreated

   Called once message queue is created in thread proc...

 *****************************************************************************/

VOID CPreviewBitmap::MessageQueueCreated()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW_BITMAP,TEXT("CPreviewBitmap::MessageQueueCreated( %i )"),_iTemplateIndex));

    if (_hEventForMessageQueueCreation)
    {
        SetEvent(_hEventForMessageQueueCreation);
    }
}


/*****************************************************************************

   CPreivewBitmap::GetPreview

   Called by preview window to have us post the preview bitmap back to them...

 *****************************************************************************/

HRESULT CPreviewBitmap::GetPreview()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW_BITMAP,TEXT("CPreviewBitmap::GetPreview( %i )"),_iTemplateIndex));

    HRESULT hr = S_OK;

    //
    // First, see if our thread is already running...
    //

    CAutoCriticalSection lock(_csItem);

    if (_pWizInfo && (!_bThreadIsStalled))
    {
        if (!_pWizInfo->IsWizardShuttingDown())
        {
            if (!_hWorkThread)
            {


                _hWorkThread = CreateThread( NULL, 0, s_PreviewBitmapWorkerThread, (LPVOID)this, CREATE_SUSPENDED, &_dwWorkThreadId );
                if (_hWorkThread)
                {
                    //
                    // If we created the thread, set it's priority to slight below normal so other
                    // things run okay.  This can be a CPU intensive task...
                    //

                    SetThreadPriority( _hWorkThread, THREAD_PRIORITY_BELOW_NORMAL );
                    ResumeThread( _hWorkThread );

                    //
                    // Wait for message queue to be created...
                    //

                    if (_hEventForMessageQueueCreation)
                    {
                        WaitForSingleObject( _hEventForMessageQueueCreation, INFINITE );
                    }

                }
                else
                {
                    WIA_ERROR((TEXT("GetPreview: CreateThread failed w/GLE=%d"),GetLastError()));

                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    //
    // If we have the thread, then tell it to generate a new preview...
    //

    if (SUCCEEDED(hr) && _hWorkThread && _dwWorkThreadId)
    {
        PostThreadMessage( _dwWorkThreadId, PVB_MSG_GENERATE_PREVIEW, 0, 0 );
    }

    WIA_RETURN_HR(hr);
}



/*****************************************************************************

   CPreviewBitmap::GeneratePreview

   This function is called by the worker thread to generate a new
   preview for this template...

 *****************************************************************************/

VOID CPreviewBitmap::GeneratePreview()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW_BITMAP,TEXT("CPreviewBitmap::GeneratePreview( %i )"),_iTemplateIndex));

    //
    // we always generate a new bitmap here, because we only get called if
    // the preview window doesn't have a bitmap for this template yet or
    // if something has caused the previews to become invalid...
    //

    if (_pWizInfo && (!_pWizInfo->IsWizardShuttingDown()) && (!_bThreadIsStalled))
    {
        HBITMAP bmp = _pWizInfo->RenderPreview( _iTemplateIndex, _hwndPreview );

        if (bmp)
        {
            //
            // We use sendmessage here to make sure this bitmap doesn't get
            // lost in transit.
            //

            LRESULT lRes = -1;

            if (!_pWizInfo->IsWizardShuttingDown() && (!_bThreadIsStalled))
            {
                lRes = SendMessage( _hwndPreview, PV_MSG_PREVIEW_BITMAP_AVAILABLE, (WPARAM)_iTemplateIndex, (LPARAM)bmp );
            }

            if ((lRes == -1) || (lRes == 0))
            {
                //
                // For some reason, there was an error.  So clean up by deleting
                // the bitmap here...
                //

                WIA_ERROR((TEXT("CPreviewBitmap::GeneratePreview - SendMessage returned error, deleting bitmap!")));
                DeleteObject( (HGDIOBJ)bmp );
            }

        }
        else
        {
            WIA_ERROR((TEXT("CPreviewBitmap::GeneratePreview - RenderPreview returned null bmp!")));
        }
    }


}


/*****************************************************************************

   CPreviewBitmap::StallThread

   Terminate the background thread (gracefully) and don't allow it
   to start again until RestartThread is called...

 *****************************************************************************/

VOID CPreviewBitmap::StallThread()
{
    CAutoCriticalSection lock(_csItem);

    _bThreadIsStalled = TRUE;

    if (_hWorkThread && _dwWorkThreadId)
    {
        PostThreadMessage( _dwWorkThreadId, PVB_MSG_EXIT_THREAD, 0, 0 );
        WiaUiUtil::MsgWaitForSingleObject( _hWorkThread, INFINITE );
        CloseHandle( _hWorkThread );
        _hWorkThread    = NULL;
        _dwWorkThreadId = 0;
    }
}



/*****************************************************************************

   CPreviewBitmap::RestartThread

   Allow background thread to be started up again...

 *****************************************************************************/

VOID CPreviewBitmap::RestartThread()
{
    CAutoCriticalSection lock(_csItem);

    _bThreadIsStalled = FALSE;
}


/*****************************************************************************

   CPreviewBitmap::s_PreviewBitmapWorkerThread

   Thread proc that does all the work of generating the bitmaps

 *****************************************************************************/

DWORD CPreviewBitmap::s_PreviewBitmapWorkerThread(void *pv)
{
    CPreviewBitmap * pPB = (CPreviewBitmap *)pv;

    if (pPB)
    {
        //
        // Add-ref the DLL so that it doesn't get unloaded while we're running...
        //

        HMODULE hDll = GetThreadHMODULE( s_PreviewBitmapWorkerThread );

        //
        // Make sure COM is initialized for this thread...
        //

        HRESULT hrCo = PPWCoInitialize();

        //
        // Create the message queue...
        //

        MSG msg;
        PeekMessage( &msg, NULL, WM_USER, WM_USER, PM_NOREMOVE );

        //
        // Signal that we're ready to receive messages...
        //

        pPB->MessageQueueCreated();

        //
        // Loop until we get message to quit...
        //

        BOOL bExit = FALSE;

        while ((!bExit) && (-1!=GetMessage( &msg, NULL, PVB_MSG_START, PVB_MSG_END )))
        {
            switch (msg.message)
            {
            case PVB_MSG_GENERATE_PREVIEW:
                pPB->GeneratePreview();
                break;

            case PVB_MSG_EXIT_THREAD:
                bExit = TRUE;
                break;
            }
        }

        //
        // Unitialize COM if we initialized it earlier...
        //

        PPWCoUninitialize( hrCo );

        //
        // Remove our reference on the DLL and exit...
        //

        if (hDll)
        {
            WIA_TRACE((TEXT("Exiting preview bitmap worker thread via FLAET...")));
            FreeLibraryAndExitThread( hDll, 0 );
        }
    }

    WIA_TRACE((TEXT("Exiting preview bitmap worker thread via error path...")));

    return 0;
}




/*****************************************************************************

   CPreviewWindow contructor/desctructor

   <Notes>

 *****************************************************************************/

CPreviewWindow::CPreviewWindow( CWizardInfoBlob * pWizInfo )
  : _pWizInfo(pWizInfo),
    _LastTemplate(PV_NO_LAST_TEMPLATE_CHOSEN),
    _NumTemplates(0),
    _hwnd(NULL),
    _hwndProgress(NULL),
    _hPreviewList(NULL),
    _hStillWorkingBitmap(NULL),
    _bThreadsAreStalled(FALSE)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("CPreviewWindow::CPreviewWindow")));

    if (_pWizInfo)
    {
        _pWizInfo->AddRef();
    }

}

CPreviewWindow::~CPreviewWindow()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("CPreviewWindow::~CPreviewWindow")));

    //
    // Make sure we clear out any remaining background info...
    //

    ShutDownBackgroundThreads();

    //
    // Kill the progress window if it exists...
    //

    if (_hwndProgress)
    {
        DestroyWindow( _hwndProgress );
        _hwndProgress = NULL;
    }

    //
    // Tear down whatever is remaining...
    //

    if (_hStillWorkingBitmap)
    {
        DeleteObject( (HGDIOBJ)_hStillWorkingBitmap );
    }

    if (_pWizInfo)
    {
        _pWizInfo->Release();
    }

}


/*****************************************************************************

   CPreviewWindow::StallBackgroundThreads()

   Tell the preview generation threads to stall out while
   the number of copies is changed.  The threads will stay
   stalled until a call to CPreviewWindow::RestartBackgroundThreads()
   is made...

 *****************************************************************************/

VOID CPreviewWindow::StallBackgroundThreads()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("CPreviewWindow::StallBackgroundThreads()")));

    CAutoCriticalSection lock(_csList);

    _bThreadsAreStalled = TRUE;

    if (_hPreviewList)
    {
        for (INT i=0; i < _NumTemplates; i++)
        {
            //
            // Stall the thread...
            //

            if (_hPreviewList[i].pPreviewBitmap)
            {
                _hPreviewList[i].pPreviewBitmap->StallThread();
            }

            //
            // Invalidate current bitmaps...
            //

            _hPreviewList[i].bValid = FALSE;
            _hPreviewList[i].bBitmapGenerationInProgress = FALSE;
            if (_hPreviewList[i].hPrevBmp)
            {
                DeleteObject( (HGDIOBJ)_hPreviewList[i].hPrevBmp );
                _hPreviewList[i].hPrevBmp = NULL;
            }
        }
    }
}


/*****************************************************************************

   CPreviewWindow::RestartBackgroundThreads

   Tell the preview generation threads to start back up again...

 *****************************************************************************/

VOID CPreviewWindow::RestartBackgroundThreads()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("CPreviewWindow::RestartBackgroundThreads()")));

    CAutoCriticalSection lock(_csList);

    if (_hPreviewList)
    {
        for (INT i=0; i < _NumTemplates; i++)
        {
            if (_hPreviewList[i].pPreviewBitmap)
            {
                _hPreviewList[i].pPreviewBitmap->RestartThread();
            }
        }
    }

    _bThreadsAreStalled = FALSE;

    //
    // Redraw currently selected template...
    //

    if (_LastTemplate != PV_NO_LAST_TEMPLATE_CHOSEN)
    {
        PostMessage( _hwnd, PV_MSG_GENERATE_NEW_PREVIEW, _LastTemplate, 0 );
    }


    //
    // Tell the user we're working on a preview for them...
    //

    if (_hStillWorkingBitmap)
    {
        DrawBitmap( _hStillWorkingBitmap, NULL );
    }

}



/*****************************************************************************

   CPreivewWindow::ShutDownBackgroundThread()

   Terminates the background threads and waits until they are gone...

 *****************************************************************************/

VOID CPreviewWindow::ShutDownBackgroundThreads()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("CPreviewWindow::ShutDownBackgroundThreads()")));

    //
    // Let's tear down the background threads...
    //

    _csList.Enter();

    if (_hPreviewList)
    {
        for (INT i = 0; i < _NumTemplates; i++)
        {
            if (_hPreviewList[i].hPrevBmp)
            {
                DeleteObject( (HGDIOBJ)_hPreviewList[i].hPrevBmp );
                _hPreviewList[i].hPrevBmp = NULL;
            }

            if (_hPreviewList[i].pPreviewBitmap)
            {
                delete _hPreviewList[i].pPreviewBitmap;
                _hPreviewList[i].pPreviewBitmap = NULL;
            }
        }

        delete [] _hPreviewList;
        _hPreviewList = NULL;
    }

    _csList.Leave();

    //
    // Notify wizard that we've shut down
    //

    if (_pWizInfo)
    {
        _pWizInfo->PreviewIsShutDown();
    }
}

/*****************************************************************************

   CPreviewWindow::InitList

   If not already done, initialize the bitmap list for the window...

 *****************************************************************************/

VOID CPreviewWindow::_InitList()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("CPreviewWindow::_InitList()")));

    CAutoCriticalSection lock(_csList);

    if (_pWizInfo && (!_pWizInfo->IsWizardShuttingDown()))
    {
        if (!_hPreviewList)
        {

            //
            // Create a list for holding the hBitmap previews...
            //

            if (_pWizInfo)
            {
                _NumTemplates = _pWizInfo->CountOfTemplates();

                _hPreviewList = new PREVIEW_STATE [_NumTemplates];

                if (_hPreviewList)
                {
                    //
                    // Pre-initialize each entry
                    //

                    for (INT i = 0; i < _NumTemplates; i++)
                    {
                        _hPreviewList[i].hPrevBmp = NULL;
                        _hPreviewList[i].bValid   = FALSE;
                        _hPreviewList[i].bBitmapGenerationInProgress = FALSE;
                        _hPreviewList[i].pPreviewBitmap = new CPreviewBitmap( _pWizInfo, _hwnd, i );
                    }
                }
            }
        }
    }
}



/*****************************************************************************

   CPreviewWindow::InvalidateAllPreviews

   Marks all the previews as invalid -- must be re-computed

 *****************************************************************************/

VOID CPreviewWindow::InvalidateAllPreviews()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("CPreviewWindow::InvalidateAllPreviews()")));

    CAutoCriticalSection lock(_csList);

    if (_hPreviewList)
    {
        for (INT i = 0; i < _NumTemplates; i++)
        {
            _hPreviewList[i].bValid = FALSE;
            _hPreviewList[i].bBitmapGenerationInProgress = FALSE;
            if (_hPreviewList[i].hPrevBmp)
            {
                DeleteObject( (HGDIOBJ)_hPreviewList[i].hPrevBmp );
                _hPreviewList[i].hPrevBmp = NULL;
            }
        }
    }

    if (_hStillWorkingBitmap)
    {
        DeleteObject(_hStillWorkingBitmap);
        _hStillWorkingBitmap = NULL;
    }

}

/*****************************************************************************

   CPreviewWindow::DrawBitmap

   <Notes>

 *****************************************************************************/

VOID CPreviewWindow::DrawBitmap( HBITMAP hBitmap, HDC hdc )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("CPreviewWindow::DrawBitmap()")));

    //
    // Don't bother painting the bitmap if we don't have an image.
    //

    if (!hBitmap)
        return;

    Gdiplus::Bitmap bmp( hBitmap, NULL );

    if (Gdiplus::Ok == bmp.GetLastStatus())
    {
        Gdiplus::Graphics * g;

        if (hdc)
            g = Gdiplus::Graphics::FromHDC( hdc );
        else
            g = Gdiplus::Graphics::FromHWND( _hwnd );

        if (g && (Gdiplus::Ok == g->GetLastStatus()))
        {
            g->DrawImage( &bmp, 0, 0 );

            if (Gdiplus::Ok != g->GetLastStatus())
            {
                WIA_ERROR((TEXT("DrawBitmap: g->DrawImage call failed, Status = %d"),g->GetLastStatus()));
            }

        }
        else
        {
            WIA_ERROR((TEXT("DrawBitmap: couldn't create GDI+ Graphics from Bitmap")));
        }

        if (g)
        {
            delete g;
        }
    }

}

/*****************************************************************************

   CPreviewWindow::ShowStillWorking

   Shows the "generating a preview" message...

 *****************************************************************************/

VOID CPreviewWindow::ShowStillWorking( HWND hwnd )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("CPreviewWindow::ShowStillWorking()")));

    if (_pWizInfo && (!_pWizInfo->IsWizardShuttingDown()))
    {

        CAutoCriticalSection lock(_csList);

        //
        // Get size of preview window
        //

        RECT rcWnd = {0};
        GetClientRect( hwnd, &rcWnd );
        Gdiplus::RectF rectWindow( 0.0, 0.0, (Gdiplus::REAL)(rcWnd.right - rcWnd.left), (Gdiplus::REAL)(rcWnd.bottom - rcWnd.top) );

        //
        // Clear out window...
        //

        Gdiplus::Graphics g( hwnd );
        if (Gdiplus::Ok == g.GetLastStatus())
        {
            //
            // First, draw bounding rectangle
            //

            g.SetPageUnit( Gdiplus::UnitPixel );
            g.SetPageScale( 1.0 );

            DWORD dw = GetSysColor( COLOR_BTNFACE );

            Gdiplus::Color wndClr(255,GetRValue(dw),GetGValue(dw),GetBValue(dw));
            Gdiplus::SolidBrush br(wndClr);

            //
            // Clear out the contents
            //

            g.FillRectangle( &br, rectWindow );

            //
            // Frame the rectangle
            //

            rectWindow.Inflate( -1, -1 );
            Gdiplus::Color black(255,0,0,0);
            Gdiplus::SolidBrush BlackBrush( black );
            Gdiplus::Pen BlackPen( &BlackBrush, (Gdiplus::REAL)1.0 );
            g.DrawRectangle( &BlackPen, rectWindow );

            //
            // Draw text about generating preview...
            //

            CSimpleString strText(IDS_DOWNLOADINGTHUMBNAIL, g_hInst);
            Gdiplus::StringFormat DefaultStringFormat;
            Gdiplus::Font Verdana( TEXT("Verdana"), 8.0 );

            Gdiplus::REAL FontH = (Gdiplus::REAL)Verdana.GetHeight( &g );
            rectWindow.Y += ((rectWindow.Height - FontH) / (Gdiplus::REAL)2.0);
            rectWindow.Height = FontH;

            DefaultStringFormat.SetAlignment(Gdiplus::StringAlignmentCenter);

            g.DrawString( strText, strText.Length(), &Verdana, rectWindow, &DefaultStringFormat, &BlackBrush );

        }

    }

}


/*****************************************************************************

   CPreviewWindow::GenerateWorkingBitmap

   Creates the "generating a preview" bitmap...

 *****************************************************************************/

VOID CPreviewWindow::GenerateWorkingBitmap( HWND hwnd )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("CPreviewWindow::GenerateWorkingBitmap()")));

    if (_pWizInfo && (!_pWizInfo->IsWizardShuttingDown()))
    {
        CAutoCriticalSection lock(_csList);

        //
        // Do we need to generate a new one...?
        //

        if (!_hStillWorkingBitmap)
        {

            //
            // Get size of preview window
            //

            RECT rcWnd = {0};
            GetClientRect( hwnd, &rcWnd );
            Gdiplus::RectF rectWindow( 0.0, 0.0, (Gdiplus::REAL)(rcWnd.right - rcWnd.left), (Gdiplus::REAL)(rcWnd.bottom - rcWnd.top) );
            WIA_TRACE((TEXT("GenerateWorkingBitmap: rectWindow is (%d,%d) @ (%d,%d)"),(INT)rectWindow.Width, (INT)rectWindow.Height, (INT)rectWindow.X, (INT)rectWindow.Y));

            //
            // Size progress control
            //

            if (_hwndProgress)
            {
                RECT rcProgress = {0};
                GetProgressControlRect( hwnd, &rcProgress );

                MoveWindow( _hwndProgress,
                            rcProgress.left,
                            rcProgress.top,
                            (rcProgress.right - rcProgress.left),
                            (rcProgress.bottom - rcProgress.top),
                            TRUE
                           );
            }

            //
            // Allocate memory for bitmap
            //

            INT stride = ((INT)rectWindow.Width * sizeof(long));
            if ( (stride % 4) != 0)
            {
                stride += (4 - (stride % 4));
            }

            BYTE * data = new BYTE[ stride * (INT)rectWindow.Height ];

            if (data)
            {
                memset( data, 0, stride * (INT)rectWindow.Height );
                Gdiplus::Bitmap bmp( (INT)rectWindow.Width, (INT)rectWindow.Height, stride, PixelFormat32bppRGB, data );

                if (Gdiplus::Ok == bmp.GetLastStatus())
                {
                    //
                    // Draw a rectangle, 1 pixel wide, around the outside
                    // with an interior that is white
                    //

                    Gdiplus::Graphics g( &bmp );

                    if (Gdiplus::Ok == g.GetLastStatus())
                    {

                        //
                        // First, draw bounding rectangle
                        //

                        g.SetPageUnit( Gdiplus::UnitPixel );
                        g.SetPageScale( 1.0 );

                        DWORD dw = GetSysColor( COLOR_BTNFACE );

                        Gdiplus::Color wndClr(255,GetRValue(dw),GetGValue(dw),GetBValue(dw));
                        Gdiplus::SolidBrush br(wndClr);

                        //
                        // Clear out the contents
                        //

                        g.FillRectangle( &br, rectWindow );

                        //
                        // Frame the rectangle
                        //

                        rectWindow.Inflate( -1, -1 );
                        Gdiplus::Color black(255,0,0,0);
                        Gdiplus::SolidBrush BlackBrush( black );
                        Gdiplus::Pen BlackPen( &BlackBrush, (Gdiplus::REAL)1.0 );
                        g.DrawRectangle( &BlackPen, rectWindow );

                        //
                        // Draw text about generating preview...
                        //

                        CSimpleString strText(IDS_DOWNLOADINGTHUMBNAIL, g_hInst);
                        Gdiplus::StringFormat DefaultStringFormat;
                        Gdiplus::Font Verdana( TEXT("Verdana"), 8.0 );

                        Gdiplus::REAL FontH = (Gdiplus::REAL)Verdana.GetHeight( &g );
                        rectWindow.Y += ((rectWindow.Height - FontH) / (Gdiplus::REAL)2.0);
                        rectWindow.Height = FontH;

                        DefaultStringFormat.SetAlignment(Gdiplus::StringAlignmentCenter);

                        g.DrawString( strText, strText.Length(), &Verdana, rectWindow, &DefaultStringFormat, &BlackBrush );


                        //
                        // Get the HBITMAP to return...
                        //


                        bmp.GetHBITMAP( wndClr, &_hStillWorkingBitmap );

                        WIA_TRACE((TEXT("GenerateWorkingBitmap: created _hStillWorkingBitmap as 0x%x"),_hStillWorkingBitmap));
                    }
                    else
                    {
                        WIA_ERROR((TEXT("GenerateWorkingBitmap: couldn't get graphics from bitmap")));
                    }
                }
                else
                {
                    WIA_ERROR((TEXT("GenerateWorkingBitmap: couldn't create bitmap")));
                }

                delete [] data;
            }
            else
            {
                WIA_ERROR((TEXT("GenerateWorkingBitmap: couldn't allocate data for bitmap")));
            }

        }
        else
        {
            WIA_TRACE((TEXT("GenerateWorkingBitmap: _hStillWorkingBitmap is already valid, not generating a new one...")));
        }

    }
    else
    {
        WIA_ERROR((TEXT("GenerateWorkingBitmap: _pWizInfo is NULL or wizard is shutting down, NOT generating bitmap...")));
    }

}


/*****************************************************************************

   CPreviewWindow::GenerateNewPreview

   Generates a new preview bitmap for the given template on a background thread.

 *****************************************************************************/

VOID CPreviewWindow::GenerateNewPreview( INT iTemplate )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("CPreviewWindow::GenerateNewPreview( iTemplate = %d )"),iTemplate));

    CAutoCriticalSection lock(_csList);

    if (_pWizInfo && (!_pWizInfo->IsWizardShuttingDown()))
    {
        //
        // If we're not already generating a preview for this item, then queue
        // up a request for a new preview...
        //

        if (_hPreviewList)
        {
            if (iTemplate < _NumTemplates)
            {
                if (!_hPreviewList[iTemplate].bBitmapGenerationInProgress)
                {
                    if (_hPreviewList[iTemplate].pPreviewBitmap)
                    {
                        _hPreviewList[iTemplate].bBitmapGenerationInProgress = TRUE;
                        _hPreviewList[iTemplate].pPreviewBitmap->GetPreview();
                    }
                }
            }
            else
            {
                WIA_ERROR((TEXT("GenerateNewPreview: iTemplate >= _NumTemplates!")));
            }
        }
        else
        {
            WIA_ERROR((TEXT("GenerateNewPreview: _hPreviewList is NULL!")));
        }
    }

}



/*****************************************************************************

   CPreviewWindow::GetPreviewBitmap

   Retrieves current preview bitmap if there is a valid one already
   computed.  Otherwise, returns NULL.

 *****************************************************************************/

HBITMAP CPreviewWindow::GetPreviewBitmap( INT iTemplate )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("CPreviewWindow::GetPreviewBitmap( iTemplate = %d )"),iTemplate));

    CAutoCriticalSection lock(_csList);

    if (_hPreviewList)
    {
        if (iTemplate < _NumTemplates)
        {
            if (_hPreviewList[iTemplate].bValid)
            {
                return _hPreviewList[iTemplate].hPrevBmp;
            }
        }
        else
        {
            WIA_ERROR((TEXT("GetPreviewBitmap: iTemplate >= _NumTemplates!")));
        }
    }
    else
    {
        WIA_ERROR((TEXT("GetPreviewBitmap: _hPreviewList is NULL!")));
    }

    return NULL;
}


/*****************************************************************************

   CPreviewWindow::OnSetNewTemplate

   wParam holds index of new template to do preview for

 *****************************************************************************/

LRESULT CPreviewWindow::OnSetNewTemplate( WPARAM wParam, HDC hdc )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("CPreviewWindow::OnSetNewTemplate( wParam = %d )"),wParam));

    //
    // Make sure have an bitmap list to work with
    //

    _InitList();
    CAutoCriticalSection lock(_csList);

    //
    // Get hBitmap of preview...
    //

    if (((INT)wParam < _NumTemplates) && _hPreviewList)
    {
        _LastTemplate = (INT)wParam;

        if (_LastTemplate != PV_NO_LAST_TEMPLATE_CHOSEN)
        {
            HBITMAP hBmp = GetPreviewBitmap( (INT)wParam );

            if (hBmp)
            {
                //
                // Turn off the progress meter
                //

                if (_hwndProgress)
                {
                    WIA_TRACE((TEXT("CPreviewWindow::OnSetNewTemplate - setting progress window to SW_HIDE")));
                    ShowWindow( _hwndProgress, SW_HIDE );
                }

                WIA_TRACE((TEXT("CPreviewWindow::OnSetNewTemplate - preview is available, drawing it...")));
                DrawBitmap( hBmp, hdc );
            }
            else
            {
                //
                // no preview bitmap exists for this item
                // so, queue one up to be made...

                WIA_TRACE((TEXT("CPreviewWindow::OnSetNewTemplate - preview is not available, requesting it...")));
                PostMessage( _hwnd, PV_MSG_GENERATE_NEW_PREVIEW, wParam, 0 );

                //
                // Tell the user we're working on a preview for them...
                //

                if (_hStillWorkingBitmap)
                {
                    WIA_TRACE((TEXT("CPreviewWindow::OnSetNewTemplate - still working bitmap is available, drawing it...")));
                    DrawBitmap( _hStillWorkingBitmap, hdc );

                    //
                    // Show the progress meter...
                    //

                    if (_hwndProgress)
                    {
                        WIA_TRACE((TEXT("CPreviewWindow::OnSetNewTemplate - setting progress window to SW_SHOW")));
                        ShowWindow( _hwndProgress, SW_SHOW );
                    }

                }
                else
                {
                    WIA_ERROR((TEXT("CPreviewWindow::OnSetNewTemplate - still working bitmap is NOT available, showing nothing!")));
                }
            }
        }
        else
        {
            WIA_ERROR((TEXT("CPreviewWindow::OnSetNewTemplate - called to show template -1!")));
        }

    }
    else
    {
        WIA_ERROR((TEXT("either bad index or _hPreviewList doesn't exist!")));
    }

    return 0;
}



/*****************************************************************************

   CPreviewWindow::_OnPaint

   Handle WM_PAINT for our preview window

 *****************************************************************************/

LRESULT CPreviewWindow::_OnPaint()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("CPreviewWindow::_OnPaint()")));

    if (GetUpdateRect( _hwnd, NULL, FALSE ))
    {
        PAINTSTRUCT ps = {0};

        HDC hdcPaint = BeginPaint( _hwnd, &ps );

        if (_LastTemplate != PV_NO_LAST_TEMPLATE_CHOSEN)
        {
            OnSetNewTemplate( _LastTemplate, hdcPaint );
        }

        EndPaint( _hwnd, &ps );
    }

    return 0;
}


/*****************************************************************************

   CPreviewWindow:_OnSize

   Handles WM_SIZE

 *****************************************************************************/

LRESULT CPreviewWindow::_OnSize( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("CPreviewWindow::_OnSize( new size is %d by %d )"),LOWORD(lParam),HIWORD(lParam)));

    //
    // If the size changes, we need to invalidate the "Generating preview"
    // bitmap...
    //
    CAutoCriticalSection lock(_csList);

    if (_hStillWorkingBitmap)
    {
        WIA_TRACE((TEXT("CPreviewWindow::_OnSize - deleting _hStillWorkingBitmap")));
        DeleteObject(_hStillWorkingBitmap);
        _hStillWorkingBitmap = NULL;
    }

    //
    // If we have the progress control, resize it...
    //

    if (_hwndProgress)
    {
        RECT rc = {0};

        GetProgressControlRect( _hwnd, &rc );

        WIA_TRACE((TEXT("CPreviewWindow::_OnSize - calling MoveWindow( _hwndProgress, %d, %d, %d, %d, TRUE )"),rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top ));
        MoveWindow( _hwndProgress,
                    rc.left,
                    rc.top,
                    rc.right - rc.left,
                    rc.bottom - rc.top,
                    TRUE
                   );
    }

    return 1;
}


/*****************************************************************************

   CPreviewWindow::_OnNewPreviewAvailable

   This is called when the CPreviewBitmap class has rendered a new
   preview and wants us to update...

   We must return TRUE if we handle the message and everything went okay.

   wParam = index of template
   lParam = HBITMAP of preview.  Note, we now own this.

 *****************************************************************************/

LRESULT CPreviewWindow::_OnNewPreviewAvailable( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PREVIEW,TEXT("CPreviewWindow::_OnNewPreviewAvailable( %i )"),wParam));

    LRESULT lRes = -1;

    CAutoCriticalSection lock(_csList);

    if (_hPreviewList)
    {
        if ((INT)wParam < _NumTemplates)
        {
            if (!_hPreviewList[wParam].bValid)
            {
                if (_hPreviewList[wParam].bBitmapGenerationInProgress)
                {
                    //
                    // We're expecting this bitmap!
                    //

                    if (lParam)
                    {
                        if (_hPreviewList[wParam].hPrevBmp)
                        {
                            DeleteObject( (HGDIOBJ)_hPreviewList[wParam].hPrevBmp );
                        }

                        _hPreviewList[wParam].hPrevBmp = (HBITMAP)lParam;
                        _hPreviewList[wParam].bValid   = TRUE;
                        _hPreviewList[wParam].bBitmapGenerationInProgress = FALSE;
                        lRes = 1;

                        //
                        // Do we need to draw this new bitmap?
                        //

                        if (_LastTemplate == (INT)wParam)
                        {
                            //
                            // Turn off the progress meter
                            //

                            if (_hwndProgress)
                            {
                                WIA_TRACE((TEXT("CPreviewWindow::_OnNewPreviewAvailable - setting progress window to SW_HIDE")));
                                ShowWindow( _hwndProgress, SW_HIDE );
                            }

                            //
                            // Draw new template...
                            //

                            DrawBitmap( _hPreviewList[wParam].hPrevBmp );
                        }
                    }
                }
                else
                {
                    //
                    // Looks like the preview was invalidated!  So, dump this
                    // bitmap -- this should happen automatically by returning
                    // an error code...
                    //

                    WIA_TRACE((TEXT("_OnNewPreviewAvailable: Dumping bitmap because bBitmapGenerationInProgress was false")));
                }
            }
            else
            {
                WIA_ERROR((TEXT("_OnNewPreviewAvailable: Template bitmap is already valid?")));
            }
        }
        else
        {
            WIA_ERROR((TEXT("_OnNewPreviewAvailable: bad template index!")));
        }
    }
    else
    {
        WIA_ERROR((TEXT("_OnNewPreviewAvailable: There's no _hPreviewList!")));
    }

    return lRes;
}



/*****************************************************************************

   CPreviewWindow::DoHandleMessage

   Handles incoming window messages

 *****************************************************************************/

LRESULT CPreviewWindow::DoHandleMessage( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DLGPROC, TEXT("CPreviewWindow::DoHandleMessage( 0x%x, 0x%x, 0x%x, 0x%x )"),hwnd,uMsg,wParam,lParam));

    switch (uMsg)
    {
    case WM_NCCREATE:
        return TRUE;

    case WM_CREATE:
        {
            _hwnd = hwnd;
            _InitList();

            RECT rc = {0};
            GetProgressControlRect( hwnd, &rc );

            //
            // Create progress bar, initially hidden
            //

            _hwndProgress = CreateWindow( PROGRESS_CLASS,
                                          TEXT(""),
                                          WS_CHILD|PBS_MARQUEE,
                                          rc.left,
                                          rc.top,
                                          rc.right - rc.left,
                                          rc.bottom - rc.top,
                                          hwnd,
                                          reinterpret_cast<HMENU>(IDC_PREVIEW_PROGRESS),
                                          NULL,
                                          NULL
                                         );

            if (_hwndProgress)
            {
                //
                // Put it in marquee mode
                //

                SendMessage( _hwndProgress, PBM_SETMARQUEE, TRUE, 100 );

            }
        }
        return 0;

    case WM_PAINT:
        return _OnPaint();

    case WM_SIZE:
        return _OnSize( wParam, lParam );


    case PW_SETNEWTEMPLATE:
        if (_LastTemplate == (INT)wParam)
        {
            if (_hPreviewList)
            {
                if (_hPreviewList[wParam].bValid)
                {
                    //
                    // Don't need to draw again, so return...
                    //

                    return 0;

                }
            }
        }
        return OnSetNewTemplate( wParam );

    case PV_MSG_GENERATE_NEW_PREVIEW:
        GenerateNewPreview( (INT)wParam );
        return 0;

    case PV_MSG_PREVIEW_BITMAP_AVAILABLE:
        return _OnNewPreviewAvailable( wParam, lParam );

    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\printopt.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       printopt.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/18/00
 *
 *  DESCRIPTION: Definition of class which handles dlg proc duties
 *               for the print options wizard page
 *
 *****************************************************************************/

#ifndef _PRINT_PHOTOS_WIZARD_PRINT_OPTIONS__DLG_PROC_
#define _PRINT_PHOTOS_WIZARD_PRINT_OPTIONS_DLG_PROC_

typedef BOOL (*PF_BPRINTERSETUP)(HWND, UINT, UINT, LPTSTR, UINT*, LPCTSTR);
const LPTSTR g_szPrintLibraryName = TEXT("printui.dll");
const LPSTR  g_szPrinterSetup = "bPrinterSetup";

#define ENUM_MAX_RETRY  5

#ifndef DC_MEDIATYPENAMES
#define DC_MEDIATYPENAMES 34
#endif

#ifndef DC_MEDIATYPES
#define DC_MEDIATYPES 35
#endif


class CPrintOptionsPage
{
public:
    CPrintOptionsPage( CWizardInfoBlob * pBlob );
    ~CPrintOptionsPage();

    INT_PTR DoHandleMessage( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    VOID    MessageQueueCreated();
    CSimpleCriticalSection          _csList;                // used to syncronize access to printer list information


private:
    CWizardInfoBlob *               _pWizInfo;
    HWND                            _hDlg;
    CSimpleString                   _strPrinterName;        // selected printer name
    CSimpleString                   _strPortName;           // selected printer's port name
    HMODULE                         _hLibrary;              // library handle
    PF_BPRINTERSETUP                _pfnPrinterSetup;       // function entrance for APW


    BOOL _LoadPrintUI();                                   // Load library
    VOID _FreePrintUI();                                   // Free Library
    BOOL _ModifyDroppedWidth( HWND );                      // modify dropped width if needed
    VOID _ValidateControls();                              // validate controls in this page
    VOID _HandleSelectPrinter();                           // save new selected printer and refresh media type selection
    VOID _HandleInstallPrinter();                          // run add printer wizard
    VOID _HandlePrinterPreferences();                      // handle when user presses Printer Preferences
    VOID _UpdateCachedInfo( PDEVMODE pDevMode );           // update global cached copies of printer information
    VOID _ShowCurrentMedia( LPCTSTR pszPrinterName, LPCTSTR pszPortName );

    // window message handlers
    LRESULT _OnInitDialog();
    LRESULT _OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT _OnNotify(WPARAM wParam, LPARAM lParam);
    VOID    _OnKillActive();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDD_START_PAGE                  106
#define IDD_PICTURE_SELECTION           107
#define IDD_PRINTING_OPTIONS            108
#define IDD_SELECT_TEMPLATE             109
#define IDD_PRINT_PROGRESS              110
#define IDD_END_PAGE                    111
#define IDI_APP_ICON                    200
#define IDI_UNAVAILABLE                 201
#define IDC_CHOOSE_PRINTER              1000
#define IDC_INSTALL_PRINTER             1001
#define IDC_PRINTER_PREFERENCES         1003
#define IDC_THUMBNAILS                  1004
#define IDC_YOU_CAN_ALSO                1005
#define IDC_PICTURE_PROPERTIES          1006
#define IDC_ROTATE                      1007
#define IDC_SELECTALL                   1008
#define IDC_NO_PRINTER_TEXT             1009
#define IDC_TEMPLATES                   1010
#define IDC_TEMPLATE_PREVIEW            1011
#define IDC_PRINT_PROGRESS              1012
#define IDC_PRINT_PROGRESS_TEXT         1013
#define IDC_CANCEL_PRINT                1014
#define IDC_WARNING_TEXT                1015
#define IDC_PREVIEW_WINDOW              1016
#define IDC_WELCOME                     1017
#define IDC_DONE                        1018
#define IDC_SAMPLE                      1019
#define IDC_NUM_IMAGES                  1020
#define IDC_REPEAT_PICTURE              1021
#define IDC_CANCEL_PRINTING             1022
#define IDC_CLEARALL                    1023
#define IDC_CURRENT_PAPER               1024
#define IDC_CURRENT_PAPER_LABEL         1025
#define IDC_END_PAGE_TEXT               1026
#define IDC_NUM_PICS                    1027
#define IDC_SPIN_PICS                   1028
#define IDC_PREVIEW_PROGRESS            1029

#define IDB_WATERMARK                   1500
#define IDB_BANNER                      1501

#define IDS_WIZ_TITLE                   2000
#define IDS_WIZ_SEL_PICTURE_TITLE       2001
#define IDS_WIZ_SEL_PICTURE_SUBTITLE    2002
#define IDS_WIZ_PRINTER_OPT_TITLE       2003
#define IDS_WIZ_PRINTER_OPT_SUBTITLE    2004
#define IDS_WIZ_SEL_TEMPLATE_TITLE      2005
#define IDS_WIZ_SEL_TEMPLATE_SUBTITLE   2006
#define IDS_DOWNLOADINGTHUMBNAIL        2007
#define IDS_PRINTING_PROGRESS           2012
#define IDS_TITLEFONTNAME               2013
#define IDS_TITLEFONTSIZE               2014
#define IDS_SAMPLE                      2015
#define IDS_CANCEL_PRINT_MESSAGE        2016
#define IDS_CANCEL_PRINT_CAPTION        2017
#define IDS_WIZ_PRINT_PROGRESS_TITLE    2018
#define IDS_WIZ_PRINT_PROGRESS_SUBTITLE 2019
#define IDS_NUM_IMAGES_FORMAT           2020
#define IDS_NOT_ALL_IMAGES_WILL_PRINT   2021
#define IDS_READY_TO_PRINT              2022
#define IDS_FULL_PAGE_TITLE             2023
#define IDS_FULL_PAGE_DESC              2024


#define IDS_ERROR_TITLE                 3000
#define IDS_ERROR_CREATEDC_FAILED       3001
#define IDS_ERROR_WHILE_PRINTING        3002
#define IDS_ERROR_WITH_FILE             3003

#define IDS_ERROR_GENERIC               3004
#define IDS_ERROR_NOMEMORY              3005
#define IDS_ERROR_FILENOTFOUND          3006
#define IDS_ERROR_ACCESSDENIED          3007
#define IDS_ERROR_UNKNOWNFORMAT         3008
#define IDS_UNKNOWN_FILE                3009
#define IDS_ERROR_ROTATION              3010
#define IDS_ERROR_WRONG_DISK            3011

#define IDS_WIZ_END_PAGE_SUCCESS        3012
#define IDS_WIZ_END_PAGE_ERROR          3013

#define IDS_ONLY_NUMBERS_TOOLTIP        3014

#define IDS_FRAME_SUFFIX                3015

#define IDC_STATIC                      -1


// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1027
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\seltemp.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       seltemp.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/18/00
 *
 *  DESCRIPTION: Implements code for the template selection page of the
 *               print photos wizard...
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop


#define TILE_TITLE          0
#define TILE_DESCRIPTION    1
#define TILE_MAX            1
#define LVS_EX_FLAGS        (LVS_EX_DOUBLEBUFFER|LVS_EX_FULLROWSELECT)

const UINT c_auTileColumns[] = {TILE_TITLE, TILE_DESCRIPTION};
const UINT c_auTileSubItems[] = {TILE_DESCRIPTION};


/*****************************************************************************

   CSelectTemplatePage -- constructor/desctructor

   <Notes>

 *****************************************************************************/

CSelectTemplatePage::CSelectTemplatePage( CWizardInfoBlob * pBlob )
  : _hDlg(NULL),
    _pPreview(NULL),
    _hPrevWnd(NULL),
    _iFirstItemInListViewIndex(-1),
    _bAlreadySetSelection(FALSE),
    _bListviewIsDirty(TRUE)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_SEL_TEMPLATE, TEXT("CSelectTemplatePage::CSelectTemplatePage()")));
    _pWizInfo = pBlob;
    _pWizInfo->AddRef();
}

CSelectTemplatePage::~CSelectTemplatePage()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_SEL_TEMPLATE, TEXT("CSelectTemplatePage::~CSelectTemplatePage()")));

    if (_pPreview)
    {
        delete _pPreview;
        _pPreview = NULL;
    }

    if (_pWizInfo)
    {
        _pWizInfo->Release();
        _pWizInfo = NULL;
    }
}


/*****************************************************************************

   CSelectTemplatePage::_PopulateTemplateListView()

   Populates list of templates w/template info...

 *****************************************************************************/

VOID CSelectTemplatePage::_PopulateTemplateListView()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_SEL_TEMPLATE, TEXT("CSelectTemplatePage::_PopulateTemplateListView()")));

    if (!_pWizInfo)
    {
        WIA_ERROR((TEXT("_PopulateTemplateListView: FATAL: _pWizInfo is NULL, exiting early")));
        return;
    }

    HWND hwndList = GetDlgItem( _hDlg, IDC_TEMPLATES );
    if (hwndList)
    {
        HIMAGELIST hImageList = ListView_GetImageList(hwndList, LVSIL_NORMAL);
        if (hImageList)
        {
            //
            // Loop through templates and create list view items for each one...
            //
            SIZE size = { 48,62 };
            INT nImageListIndex = -1;
            INT iCount = _pWizInfo->CountOfTemplates();
            CTemplateInfo * pTemplateInfo;
            LONGLONG liTemplateWidth   = 0;
            LONGLONG liTemplateHeight  = 0;
            LONGLONG liPrintAreaWidth  = 0;
            LONGLONG liPrintAreaHeight = 0;
            LONGLONG liTemplateArea    = 0;
            LONGLONG liPrintArea       = 0;

            CSimpleString strTitle, strDesc;
            for (INT i = 0; i < iCount; i++)
            {
                pTemplateInfo = NULL;
                if (SUCCEEDED(_pWizInfo->GetTemplateByIndex(i,&pTemplateInfo)) && pTemplateInfo)
                {
                    HBITMAP hBmp = NULL;
                    if (SUCCEEDED(_pWizInfo->TemplateGetPreviewBitmap(i, size, &hBmp)) && hBmp)
                    {
                        //
                        // If the template is > 10% larger than printable
                        // area of printer, then don't add it to the listview
                        // as a choice as it won't print out very good anyway...
                        //

                        RENDER_DIMENSIONS dim = {0};
                        RECT rc = {0};

                        _pWizInfo->_SetupDimensionsForPrinting( NULL, pTemplateInfo, &dim );
                        if (SUCCEEDED(pTemplateInfo->GetNominalRectForImageableArea( &rc )))
                        {
                            if ( (rc.left   != -1) &&
                                 (rc.top    != -1) &&
                                 (rc.right  != -1) &&
                                 (rc.bottom != -1)
                                )
                            {
                                liTemplateWidth   = (LONGLONG)(rc.right - rc.left);
                                liTemplateHeight  = (LONGLONG)(rc.bottom - rc.top);
                                liPrintAreaWidth  = (LONGLONG)dim.NominalDevicePrintArea.cx;
                                liPrintAreaHeight = (LONGLONG)dim.NominalDevicePrintArea.cy;
                                liTemplateArea    = liTemplateWidth * liTemplateHeight;
                                liPrintArea       = liPrintAreaWidth * liPrintAreaHeight;

                                WIA_TRACE((TEXT("_PopulateTemplateListView: Template %d area is (%ld x %ld) = %ld"),i,liTemplateWidth,liTemplateHeight,liTemplateArea));
                                WIA_TRACE((TEXT("_PopulateTemplateListView: Print area is (%ld x %ld) = %ld"),liPrintAreaWidth,liPrintAreaHeight,liPrintArea));

                                if (liTemplateArea)
                                {
                                    LONGLONG liRatio = (liPrintArea * 100) / liTemplateArea;

                                    if (liRatio < 85)
                                    {
                                        WIA_TRACE((TEXT("_PopulateTemplateListView: skipping template %d"),i));
                                        continue;
                                    }
                                }

                            }
                        }

                        WIA_TRACE((TEXT("_PopulateTemplateListView: adding template %d"),i));

                        //
                        // If we're adding this template, then get the title
                        // and description...
                        //

                        if (SUCCEEDED(pTemplateInfo->GetTitle(&strTitle)) &&
                            SUCCEEDED(pTemplateInfo->GetDescription(&strDesc)))
                        {
                            nImageListIndex = ImageList_Add(hImageList, hBmp, NULL);

                            LV_ITEM lvi = { 0 };
                            lvi.mask = LVIF_TEXT|LVIF_PARAM;
                            lvi.lParam = (LPARAM)i;
                            lvi.iItem = ListView_GetItemCount(hwndList); // append
                            if (nImageListIndex >= 0)
                            {
                                lvi.mask |= LVIF_IMAGE;
                                lvi.iImage = nImageListIndex;
                            }

                            #ifdef TEMPLATE_GROUPING
                            CSimpleString strGroupName;
                            if (SUCCEEDED(pTemplateInfo->GetGroup(&strGroupName)))
                            {
                                //
                                // Get the group ID for this group name...
                                //

                                INT iGroupId = _GroupList.GetGroupId( strGroupName, hwndList );
                                WIA_TRACE((TEXT("_PopulateTemplateListView: _GroupList.GetGroupId( %s ) returned %d"),strGroupName.String(),iGroupId));

                                //
                                // Set the item to be in the group...
                                //

                                if (-1 != iGroupId)
                                {
                                    lvi.mask |= LVIF_GROUPID;
                                    lvi.iGroupId = iGroupId;
                                }
                            }
                            #endif

                            lvi.pszText = const_cast<LPTSTR>(static_cast<LPCTSTR>(strTitle));
                            lvi.iItem = ListView_InsertItem(hwndList, &lvi);
                            if (_iFirstItemInListViewIndex == -1)
                            {
                                _iFirstItemInListViewIndex = lvi.iItem;
                            }


                            lvi.iSubItem = 1;
                            lvi.mask = LVIF_TEXT;
                            lvi.pszText = const_cast<LPTSTR>(static_cast<LPCTSTR>(strDesc));
                            ListView_SetItem(hwndList, &lvi);

                            if (lvi.iItem != -1)
                            {
                                LVTILEINFO lvti;
                                lvti.cbSize = sizeof(LVTILEINFO);
                                lvti.iItem = lvi.iItem;
                                lvti.cColumns = ARRAYSIZE(c_auTileSubItems);
                                lvti.puColumns = (UINT*)c_auTileSubItems;
                                ListView_SetTileInfo(hwndList, &lvti);
                            }
                        }
                        DeleteObject( (HGDIOBJ)hBmp );
                    }
                }
            }
        }
        _bListviewIsDirty = FALSE;
    }
}

/*****************************************************************************

   CSelectTemplatePage::_OnInitDialog

   Handles WM_INITDIALOG chores for this page...

 *****************************************************************************/

LRESULT CSelectTemplatePage::_OnInitDialog()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_SEL_TEMPLATE, TEXT("CSelectTemplatePage::_OnInitDialog()")));

    if (!_pWizInfo)
    {
        WIA_ERROR((TEXT("FATAL: _pWizInfo is NULL, exiting early")));
        return FALSE;
    }

    //
    // Set the text size of the edit control to only be 2 characters
    //

    SendDlgItemMessage( _hDlg, IDC_NUM_PICS, EM_LIMITTEXT, 2, 0 );

    //
    // Limit outselves to number only...and inform the user if they
    // press something other than numbers...
    //

    LIMITINPUT li   = {0};
    li.cbSize       = sizeof(li);
    li.dwMask       = LIM_FLAGS | LIM_FILTER | LIM_MESSAGE | LIM_HINST;
    li.dwFlags      = LIF_HIDETIPONVALID | LIF_CATEGORYFILTER;
    li.hinst        = g_hInst;
    li.pszMessage   = MAKEINTRESOURCE(IDS_ONLY_NUMBERS_TOOLTIP);
    li.pszFilter    = (LPWSTR)(LICF_DIGIT | LICF_CNTRL | LICF_SPACE);

    SHLimitInputEditWithFlags( GetDlgItem( _hDlg, IDC_NUM_PICS ), &li );

    //
    // Set the base for the up/down control to base 10
    //

    SendDlgItemMessage( _hDlg, IDC_SPIN_PICS, UDM_SETBASE, (WPARAM)10, 0 );


    //
    // Set the range to be 1 - 99
    //

    SendDlgItemMessage( _hDlg, IDC_SPIN_PICS, UDM_SETRANGE, 0, (LPARAM)MAKELONG(MAX_NUMBER_OF_COPIES_ALLOWED,1) );

    //
    // Set the number to 1 to begin with...
    //

    SendDlgItemMessage( _hDlg, IDC_SPIN_PICS, UDM_SETPOS, 0, (LPARAM)MAKELONG(1,0) );

    //
    // Create preview window...
    //

    RECT rcWnd = {0};
    HWND hwnd = GetDlgItem( _hDlg, IDC_TEMPLATE_PREVIEW );
    if (hwnd)
    {
        GetClientRect( hwnd, &rcWnd );
        MapWindowPoints( hwnd, _hDlg, (LPPOINT)&rcWnd, 2 );
    }


    CPreviewWindow::s_RegisterClass(g_hInst);
    _pPreview = new CPreviewWindow( _pWizInfo );
    _pWizInfo->SetPreviewWindowClass( _pPreview );

    WIA_TRACE((TEXT("g_cPreviewClassWnd = 0x%x"),g_cPreviewClassWnd));
    WIA_TRACE((TEXT("Calling CreateWindowEx( x=%d, y=%d, w=%d, h=%d, hWndParent=0x%x, hInstance=0x%x"),rcWnd.left,rcWnd.top,rcWnd.right-rcWnd.left,rcWnd.bottom-rcWnd.top,_hDlg,g_hInst));
    _hPrevWnd = CreateWindowEx( WS_EX_NOPARENTNOTIFY,
                                (LPCTSTR)g_cPreviewClassWnd,
                                TEXT("PhotoPrintPreviewWindow"),
                                WS_CHILD | WS_VISIBLE,
                                rcWnd.left,
                                rcWnd.top,
                                rcWnd.right - rcWnd.left,
                                rcWnd.bottom - rcWnd.top,
                                _hDlg,
                                (HMENU)IDC_PREVIEW_WINDOW,
                                g_hInst,
                                (LPVOID)_pPreview
                               );

    if (_hPrevWnd)
    {
        WIA_TRACE((TEXT("Preview window created, hwnd = 0x%x"),_hPrevWnd));
        _pWizInfo->SetPreviewWnd( _hPrevWnd );
    }
    else
    {
        WIA_ERROR((TEXT("Couldn't create the preview window! (GLE = %d)"),GetLastError()));
    }

    //
    // Initialize Template Listview control
    //

    HWND hwndList = GetDlgItem(_hDlg, IDC_TEMPLATES);
    if (hwndList)
    {
        //
        // Hide the labels and use border selection
        //

        ListView_SetExtendedListViewStyleEx( hwndList,LVS_EX_FLAGS, LVS_EX_FLAGS);

        for (int i=0; i<ARRAYSIZE(c_auTileColumns); i++)
        {
            LV_COLUMN col;
            col.mask = LVCF_SUBITEM;
            col.iSubItem = c_auTileColumns[i];
            ListView_InsertColumn(hwndList, i, &col);
        }


        //
        // Set up tile view for this list view..
        //

        LVTILEVIEWINFO tvi = {0};
        tvi.cbSize      = sizeof(tvi);
        tvi.dwMask      = LVTVIM_TILESIZE | LVTVIM_COLUMNS;
        tvi.dwFlags     = LVTVIF_AUTOSIZE;
        tvi.cLines      = TILE_MAX;
        ListView_SetTileViewInfo(hwndList, &tvi);

        //
        // Switch to tile view
        //

        ListView_SetView(hwndList, LV_VIEW_TILE);

        #ifdef TEMPLATE_GROUPING
        ListView_EnableGroupView(hwndList, TRUE);
        #endif
        //
        // Turn on groups
        //

        //
        // Get the number of templates
        //

        LONG nItemCount = _pWizInfo->CountOfTemplates();
        WIA_TRACE((TEXT("There are %d templates to add to the listview"),nItemCount));

        //
        // Set the item count, to minimize recomputing the list size
        //

        ListView_SetItemCount( hwndList, nItemCount );

        //
        // Create the image list for the listview...
        //

        HIMAGELIST hImageList = ImageList_Create( _pWizInfo->_sizeTemplatePreview.cx, _pWizInfo->_sizeTemplatePreview.cy, ILC_COLOR24|ILC_MIRROR, nItemCount, 50 );
        if (hImageList)
        {

            //
            // Set the image list
            //

            ListView_SetImageList( hwndList, hImageList, LVSIL_NORMAL );

        }
        else
        {
            WIA_ERROR((TEXT("FATAL: Creation of the imagelist failed!")));
            return FALSE;
        }

        #ifdef TEMPLATE_GROUPING
        //
        // Add only the groups which have more than one item in them...
        //

        INT iCount = _pWizInfo->CountOfTemplates();
        CSimpleString strGroupName;
        CTemplateInfo * pTemplateInfo;

        for (INT i=0; i < iCount; i++)
        {
            pTemplateInfo = NULL;

            if (SUCCEEDED(_pWizInfo->GetTemplateByIndex( i, &pTemplateInfo )) && pTemplateInfo)
            {
                if (SUCCEEDED(pTemplateInfo->GetGroup( &strGroupName )))
                {
                    INT iRes;
                    iRes = _GroupList.GetGroupId( strGroupName, hwndList );
                    WIA_TRACE((TEXT("_GroupList.GetGroupId( %s ) return %d"),strGroupName.String(),iRes));

                    if (-1 == iRes)
                    {
                        WIA_TRACE((TEXT("Adding '%s' via _GroupList.Add"),strGroupName.String()));
                        _GroupList.Add( hwndList, strGroupName );
                    }

                }
            }

        }
        #endif

    }
    else
    {
        WIA_ERROR((TEXT("FATAL: Couldn't get listview")));
    }

    return TRUE;

}


/*****************************************************************************

   CSelectTemplatePage::_OnDestroy

   Handle WM_DESTROY for this wizard page...

 *****************************************************************************/

LRESULT CSelectTemplatePage::_OnDestroy()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_SEL_TEMPLATE, TEXT("CSelectTemplatePage::_OnDestroy()")));

    //
    // Nuke the imagelist
    //

    HIMAGELIST hImageList = ListView_SetImageList( GetDlgItem( _hDlg, IDC_TEMPLATES ), NULL, LVSIL_NORMAL );
    if (hImageList)
    {
        ImageList_Destroy(hImageList);
    }

    return 0;

}



/*****************************************************************************

   SelectTemplateTimerProc

   Called when the timer expires for typing in the edit box

 *****************************************************************************/

VOID CALLBACK SelectTemplateTimerProc( HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_SEL_TEMPLATE, TEXT("SelectTemplateTimerProc()")));

    if (idEvent == STP_TIMER_ID)
    {
        //
        // Kill the timer, and post a message to have the copies made and
        // the template previews updated...
        //

        KillTimer( hwnd, STP_TIMER_ID );
        PostMessage( hwnd, STP_MSG_DO_READ_NUM_PICS, 0, 0 );
    }

}


/*****************************************************************************

   CSelectTemplatePage::_OnCommand

   Handle WM_COMMAND messages sent to this page...

 *****************************************************************************/

LRESULT CSelectTemplatePage::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_SEL_TEMPLATE, TEXT("CSelectTemplatePage::_OnCommand()")));

    if ((wParam !=0) && (wParam !=1))
    {
        WORD wCode = HIWORD(wParam);
        WORD wId   = LOWORD(wParam);

        switch (wId)
        {
        case IDC_NUM_PICS:
            if (wCode == EN_CHANGE)
            {
                //
                // User changed the number of times to print each
                // photo.  But let's start (or reset) a timer so that
                // we can catch multiple keystrokes and not regenerate
                // on each one...
                //

                SetTimer( _hDlg, STP_TIMER_ID, COPIES_TIMER_TIMEOUT_VALUE, SelectTemplateTimerProc );
            }
            break;


        }
    }

    return 0;

}


/*****************************************************************************

   CSelectTemplatePage::_OnNotify

   Handles WM_NOTIFY for this page...

 *****************************************************************************/

LRESULT CSelectTemplatePage::_OnNotify( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DLGPROC, TEXT("CSelectTemplatePage::_OnNotify()")));

    LONG_PTR lpRes = 0;

    LPNMHDR pnmh = (LPNMHDR)lParam;
    switch (pnmh->code)
    {
        case LVN_ITEMCHANGED:
        {
            WIA_TRACE((TEXT("CSelectTemplatePage: got LVN_ITEMCHANGED")));
            LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;

            if( !(pnmv->uOldState & LVIS_SELECTED) && (pnmv->uNewState & LVIS_SELECTED) )
            {
                // update the preview picture
                HWND hwndList = GetDlgItem(_hDlg, IDC_TEMPLATES);
                if( hwndList && pnmv && 0 == pnmv->iSubItem )
                {
                    _pWizInfo->SetCurrentTemplateIndex( (INT)pnmv->lParam );
                    if (_hPrevWnd)
                    {
                        PostMessage( _hPrevWnd, PW_SETNEWTEMPLATE, (WPARAM)pnmv->lParam, 0 );
                    }

                }
            }
            break;
        }

        case PSN_SETACTIVE:
            {
                WIA_TRACE((TEXT("CSelectTemplatePage: got PSN_SETACTIVE")));

                PropSheet_SetWizButtons( GetParent(_hDlg), PSWIZB_BACK | PSWIZB_NEXT );

                //
                // If the listview is dirty, then remove all entries and re-populate...
                //

                if (_bListviewIsDirty)
                {
                    ListView_DeleteAllItems( GetDlgItem( _hDlg, IDC_TEMPLATES ) );
                    _iFirstItemInListViewIndex = -1;
                    _bAlreadySetSelection = FALSE;
                    _PopulateTemplateListView();
                }

                RENDER_DIMENSIONS Dim;
                CTemplateInfo * pTemplateInfo = NULL;

                //
                // Just use first template in the list, doesn't matter for this...
                //

                if (SUCCEEDED(_pWizInfo->GetTemplateByIndex( 0, &pTemplateInfo )) && pTemplateInfo)
                {
                    //
                    // size the preview window according to the printer layout...
                    //

                    _pWizInfo->_SetupDimensionsForScreen( pTemplateInfo, _hPrevWnd, &Dim );
                }

                //
                // Invalidate the previews...
                //

                if (_pWizInfo)
                {
                    if (_pWizInfo->GetPreviewsAreDirty())
                    {
                        _pWizInfo->InvalidateAllPreviews();
                        _pWizInfo->SetPreviewsAreDirty(FALSE);
                    }
                }

                //
                // Now that we've set up the window, generate the "still working" bitmap...
                //

                _pWizInfo->GenerateStillWorkingBitmap();

                //
                // pick the template to view...
                //

                PostMessage( _hDlg, STP_MSG_DO_SET_ACTIVE, 0, 0 );
            }
            lpRes = 0;
            break;

        case PSN_WIZNEXT:
            WIA_TRACE((TEXT("CSelectTemplatePage: got PSN_WIZNEXT")));

            //
            // Read and fix the number of copies if needed.  We do
            // a sendmessage here to make sure that this completes
            // before we switch pages...
            //
            SendMessage(_hDlg,STP_MSG_DO_READ_NUM_PICS,0,0);

            lpRes = IDD_PRINT_PROGRESS;
            break;

        case PSN_WIZBACK:
            WIA_TRACE((TEXT("CSelectTemplatePage: got PSN_WIZBACK")));
            lpRes = IDD_PRINTING_OPTIONS;
            _bListviewIsDirty = TRUE;
            break;

        case PSN_QUERYCANCEL:
            WIA_TRACE((TEXT("CSelectTemplatePage: got PSN_QUERYCANCEL")));
            if (_pWizInfo)
            {
                lpRes = _pWizInfo->UserPressedCancel();
            }
            break;

    }

    SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, lpRes );

    return TRUE;

}


/*****************************************************************************

   CSelectTemplatePage::DoHandleMessage

   Hanlder for messages sent to this page...

 *****************************************************************************/

INT_PTR CSelectTemplatePage::DoHandleMessage( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DLGPROC, TEXT("CSelectTemplatePage::DoHandleMessage( uMsg = 0x%x, wParam = 0x%x, lParam = 0x%x )"),uMsg,wParam,lParam));

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            _hDlg = hDlg;
            return _OnInitDialog();

        case WM_DESTROY:
            return _OnDestroy();

        case WM_COMMAND:
            return _OnCommand( wParam, lParam );

        case WM_NOTIFY:
            return _OnNotify( wParam, lParam );

        case WM_SYSCOLORCHANGE:
        case WM_SETTINGCHANGE:
            //
            // Forward these messages to the listview
            //
            SendDlgItemMessage( _hDlg, IDC_TEMPLATES, uMsg, wParam, lParam );
            break;

        case STP_MSG_DO_SET_ACTIVE:
            //
            // If selection has never been set, set it to the first item...
            //

            if ((_iFirstItemInListViewIndex != -1) && (!_bAlreadySetSelection))
            {
                ListView_SetItemState( GetDlgItem(_hDlg,IDC_TEMPLATES),
                                       _iFirstItemInListViewIndex,
                                       LVIS_SELECTED, LVIS_SELECTED
                                      );
                _bAlreadySetSelection = TRUE;
            }
            break;

        case STP_MSG_DO_READ_NUM_PICS:
            {
                //
                // Read the number of copies...
                //

                BOOL bSuccess = FALSE;
                BOOL bUpdate  = FALSE;
                UINT uCopies = GetDlgItemInt( _hDlg, IDC_NUM_PICS, &bSuccess, FALSE );

                if (!bSuccess)
                {
                    uCopies = 1;
                    bUpdate = TRUE;
                }

                if (uCopies == 0)
                {
                    uCopies = 1;
                    bUpdate = TRUE;
                }

                if (uCopies > MAX_NUMBER_OF_COPIES_ALLOWED)
                {
                    uCopies = MAX_NUMBER_OF_COPIES_ALLOWED;
                    bUpdate = TRUE;
                }

                if (bUpdate)
                {
                    SendDlgItemMessage( _hDlg, IDC_NUM_PICS, WM_CHAR, (WPARAM)TEXT("a"), 0 );
                    SetDlgItemInt( _hDlg, IDC_NUM_PICS, uCopies, FALSE );
                }

                if (_pWizInfo)
                {
                    _pWizInfo->SetNumberOfCopies( uCopies );
                }
            }
            break;



    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\seltemp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       seltemp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/18/00
 *
 *  DESCRIPTION: Definition of class which handles dlg proc duties
 *               for the select templates wizard page
 *
 *****************************************************************************/

#ifndef _PRINT_PHOTOS_WIZARD_SELECT_TEMPLATE_DLG_PROC_
#define _PRINT_PHOTOS_WIZARD_SELECT_TEMPLATE_DLG_PROC_

#define STP_MSG_DO_SET_ACTIVE    (WM_USER+350)   // post back to ourselves to handle PSN_SETACTIVE
#define STP_MSG_DO_READ_NUM_PICS (WM_USER+351)   // post back to ourselves to read the number of time to use each picture

#define STP_TIMER_ID    100


#define MAX_NUMBER_OF_COPIES_ALLOWED 15
#define COPIES_TIMER_TIMEOUT_VALUE   2000

#define TEMPLATE_GROUPING 1

class CSelectTemplatePage
{
public:
    CSelectTemplatePage( CWizardInfoBlob * pBlob );
    ~CSelectTemplatePage();

    INT_PTR DoHandleMessage( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );

private:
    VOID            _PopulateTemplateListView();


    // window message handlers
    LRESULT         _OnInitDialog();
    LRESULT         _OnDestroy();
    LRESULT         _OnCommand( WPARAM wParam, LPARAM lParam );
    LRESULT         _OnNotify( WPARAM wParam, LPARAM lParam );

#ifdef TEMPLATE_GROUPING
    //
    // Used for icon grouping
    //
    class CListviewGroupInfo
    {
    private:
        CSimpleStringWide m_strGroupName;
        int               m_nGroupId;

    public:
        CListviewGroupInfo(void)
          : m_strGroupName(TEXT("")),
            m_nGroupId(-1)
        {
        }
        CListviewGroupInfo( const CListviewGroupInfo &other )
          : m_strGroupName(other.GroupName()),
            m_nGroupId(other.GroupId())
        {
        }
        CListviewGroupInfo( const CSimpleStringWide &strGroupName, int nGroupId=-1 )
          : m_strGroupName(strGroupName),
            m_nGroupId(nGroupId)
        {
        }
        ~CListviewGroupInfo(void)
        {
        }
        CListviewGroupInfo &operator=( const CListviewGroupInfo &other )
        {
            if (this != &other)
            {
                m_strGroupName = other.GroupName();
                m_nGroupId = other.GroupId();
            }
            return *this;
        }
        bool operator==( const CListviewGroupInfo &other )
        {
            return (other.GroupName() == m_strGroupName);
        }
        bool operator==( const CSimpleStringWide &strGroupName )
        {
            return (strGroupName == m_strGroupName);
        }
        CSimpleStringWide GroupName(void) const
        {
            return m_strGroupName;
        }
        int GroupId(void) const
        {
            return m_nGroupId;
        }
    };

    class CGroupList : public CSimpleDynamicArray<CListviewGroupInfo>
    {
    private:
        CGroupList( const CGroupList & );
        CGroupList& operator=( const CGroupList & );

    public:
        CGroupList(void)
        {
        }
        ~CGroupList(void)
        {
        }
        int Add( HWND hwndList, const CSimpleString &strGroupName )
        {
            int nResult = -1;
            if (strGroupName.Length())
            {
                LVGROUP LvGroup = {0};
                LvGroup.cbSize = sizeof(LvGroup);
                LvGroup.pszHeader = const_cast<LPTSTR>(strGroupName.String());
                LvGroup.mask = LVGF_HEADER | LVGF_ALIGN | LVGF_GROUPID | LVGF_STATE;
                LvGroup.uAlign = LVGA_HEADER_LEFT;
                LvGroup.iGroupId = Size();
                LvGroup.state = LVGS_NORMAL;
                nResult = static_cast<int>(ListView_InsertGroup( hwndList, Size(), &LvGroup ));
                WIA_TRACE((TEXT("ListView_InsertGroup on %s returned %d"), strGroupName.String(), nResult ));
                if (nResult >= 0)
                {
                    Append( CListviewGroupInfo( strGroupName, nResult ) );
                }
            }
            return nResult;
        }
        int GetGroupId( const CSimpleString &strGroupName, HWND hwndList )
        {
            WIA_PUSH_FUNCTION((TEXT("GetGroupId(%s)"),strGroupName.String()));
            int nResult = -1;
            if (Size())
            {
                nResult = (*this)[0].GroupId();

                if (strGroupName.Length())
                {
                    int nIndex = Find(strGroupName);
                    if (nIndex < 0)
                    {
                        LVGROUP LvGroup = {0};
                        LvGroup.cbSize = sizeof(LvGroup);
                        LvGroup.pszHeader = const_cast<LPTSTR>(strGroupName.String());
                        LvGroup.mask = LVGF_HEADER | LVGF_ALIGN | LVGF_GROUPID | LVGF_STATE;
                        LvGroup.uAlign = LVGA_HEADER_LEFT;
                        LvGroup.iGroupId = Size();
                        LvGroup.state = LVGS_NORMAL;
                        nResult = static_cast<int>(ListView_InsertGroup( hwndList, Size(), &LvGroup ));
                        WIA_TRACE((TEXT("ListView_InsertGroup on %s returned %d"), strGroupName.String(), nResult ));
                        if (nResult >= 0)
                        {
                            Append( CListviewGroupInfo( strGroupName, nResult ) );
                        }
                    }
                    else
                    {
                        nResult = (*this)[nIndex].GroupId();
                    }
                }
            }
            return nResult;
        }
        int FindGroupId( const CSimpleString &strGroupName, HWND hwndList )
        {
            WIA_PUSH_FUNCTION((TEXT("FindGroupId(%s)"),strGroupName.String()));
            int nResult = -1;
            if (Size())
            {
                nResult = (*this)[0].GroupId();

                if (strGroupName.Length())
                {
                    int nIndex = Find(strGroupName);
                    if (nIndex >= 0)
                    {
                        nResult = (*this)[nIndex].GroupId();
                    }
                }
            }
            return nResult;
        }
    };

    CGroupList _GroupList;
#endif


private:
    CWizardInfoBlob *               _pWizInfo;
    CPreviewWindow *                _pPreview;
    HWND                            _hPrevWnd;
    HWND                            _hDlg;
    INT                             _iFirstItemInListViewIndex;
    BOOL                            _bAlreadySetSelection;
    BOOL                            _bListviewIsDirty;
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\sources.inc ===
#
# include the WIA global build settings
#

!include $(PROJECT_ROOT)\ui\uienv.inc
SOURCES_USED = $(SOURCES_USED) $(PROJECT_ROOT)\ui\uienv.inc


#
# Our specific build settings
#


TARGETNAME= photowiz
TARGETTYPE= DYNLINK
TARGETPATH= obj

DLLENTRY  = _DllMainCRTStartup
DLLDEF    = $(O)\photowiz.def

NO_BROWSER_FILE    = 1
USE_NT_PRODUCT_VER = 1
USE_NOLIBS         = 1

ATL_VER         = 30
USE_STATIC_ATL  = 1

#
# Precompiled header settings
#

PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\precomp.h


#
# Fill in as needed
#

# DELAYLOAD= WININET.DLL;RASDLG.DLL;RASAPI32.DLL;ACTIVEDS.DLL

#INCLUDES=\
#        $(INCLUDES);            \
#        $(PROJECT_ROOT)\ui\inc;

SOURCES=\
        ..\resource.rc  \
        ..\dll.cpp      \
        ..\drop.cpp     \
        ..\end.cpp      \
        ..\item.cpp     \
        ..\listitem.cpp \
        ..\photosel.cpp \
        ..\preview.cpp  \
        ..\printopt.cpp \
        ..\printwiz.cpp \
        ..\seltemp.cpp  \
        ..\start.cpp    \
        ..\status.cpp   \
        ..\wizblob.cpp  \
        ..\xmltools2.cpp

TARGETLIBS=$(TARGETLIBS)\
        $(PRINTSCAN_LIB_PATH)\annotlib.lib \
        $(SHELL_LIB_PATH)\shguidp.lib    \
        $(SHELL_LIB_PATH)\ieguidp.lib    \
        $(SHELL_LIB_PATH)\shfusion.lib   \
        $(SDK_LIB_PATH)\winspool.lib     \
        $(SDK_LIB_PATH)\urlmon.lib       \
        $(SDK_LIB_PATH)\shell32.lib
        
#
#
# Fusion manifest
#
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=photowiz.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\start.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       start.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        11/7/00
 *
 *  DESCRIPTION: Implements code for the start page of the
 *               print photos wizard...
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop


/*****************************************************************************

   CStartPage -- constructor/desctructor

   <Notes>

 *****************************************************************************/

CStartPage::CStartPage( CWizardInfoBlob * pBlob )
  : _hDlg(NULL)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_START, TEXT("CStartPage::CStartPage()")));
    _pWizInfo = pBlob;
    _pWizInfo->AddRef();
}

CStartPage::~CStartPage()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_START, TEXT("CStartPage::~CStartPage()")));

    if (_pWizInfo)
    {
        _pWizInfo->Release();
        _pWizInfo = NULL;
    }
}

/*****************************************************************************

   CStartPage::OnInitDialog

   Handle initializing the wizard page...

 *****************************************************************************/

LRESULT CStartPage::_OnInitDialog()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_START, TEXT("CStartPage::_OnInitDialog()")));


    if (!_pWizInfo)
    {
        WIA_ERROR((TEXT("FATAL: _pWizInfo is NULL, exiting early")));
        return FALSE;
    }

    //
    // Set font...
    //

    SendDlgItemMessage(_hDlg, IDC_WELCOME, WM_SETFONT, (WPARAM)_pWizInfo->GetIntroFont(_hDlg), 0);

    //
    // Set wizard icons...
    //

    SendMessage( GetParent(_hDlg), WM_SETICON, ICON_SMALL, (LPARAM)_pWizInfo->GetSmallIcon() );
    SendMessage( GetParent(_hDlg), WM_SETICON, ICON_BIG,   (LPARAM)_pWizInfo->GetLargeIcon() );



    return TRUE;
}


/*****************************************************************************

   CStartPage::DoHandleMessage

   Hanlder for messages sent to this page...

 *****************************************************************************/

INT_PTR CStartPage::DoHandleMessage( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DLGPROC, TEXT("CStartPage::DoHandleMessage( uMsg = 0x%x, wParam = 0x%x, lParam = 0x%x )"),uMsg,wParam,lParam));

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            _hDlg = hDlg;
            return _OnInitDialog();

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            LONG_PTR lpRes = 0;
            switch (pnmh->code)
            {

            case PSN_SETACTIVE:
                WIA_TRACE((TEXT("CStartPage: got PSN_SETACTIVE")));

                //
                // Add all the objects to the list...
                //

                PropSheet_SetWizButtons( GetParent(_hDlg), PSWIZB_NEXT );
                PostMessage( _hDlg, STARTPAGE_MSG_LOAD_ITEMS, 0, 0 );
                lpRes = 0;
                break;

            case PSN_WIZNEXT:
                WIA_TRACE((TEXT("CStartPage: got PSN_WIZNEXT")));
                if (_pWizInfo && (_pWizInfo->AllPicturesAdded()) && (_pWizInfo->CountOfPhotos(FALSE) == 1))
                {
                    lpRes = IDD_PRINTING_OPTIONS;
                }
                else
                {
                    lpRes = IDD_PICTURE_SELECTION;
                }
                break;

            case PSN_WIZBACK:
                WIA_TRACE((TEXT("CStartPage: got PSN_WIZBACK")));
                lpRes = -1;
                break;

            case PSN_QUERYCANCEL:
                WIA_TRACE((TEXT("CStartPage: got PSN_QUERYCANCEL")));
                if (_pWizInfo)
                {
                    lpRes = _pWizInfo->UserPressedCancel();
                }
                break;

            }

            SetWindowLongPtr( hDlg, DWLP_MSGRESULT, lpRes );
            return TRUE;
        }

        case STARTPAGE_MSG_LOAD_ITEMS:
            if (_pWizInfo)
            {
                _pWizInfo->AddAllPhotosFromDataObject();
            }
            break;

    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\start.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       start.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        11/7/00
 *
 *  DESCRIPTION: Start page class definition
 *
 *****************************************************************************/


#ifndef _PRINT_PHOTOS_WIZARD_START_PAGE_DLG_PROC_
#define _PRINT_PHOTOS_WIZARD_START_PAGE_DLG_PROC_

#define STARTPAGE_MSG_LOAD_ITEMS    (WM_USER+150)   // start loading items...

class CStartPage
{
public:
    CStartPage( CWizardInfoBlob * pBlob );
    ~CStartPage();

    INT_PTR DoHandleMessage( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );

private:

    // window message handlers
    LRESULT         _OnInitDialog();


private:
    CWizardInfoBlob *               _pWizInfo;
    HWND                            _hDlg;
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\version.h ===
// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Photo Printing Wizard"
#define VER_INTERNALNAME_STR            "photowiz"
//#define VER_LEGALCOPYRIGHT_YEARS        "2000,2001"
#define VER_ORIGINALFILENAME_STR        "photowiz.dll"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\status.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       status.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        11/8/00
 *
 *  DESCRIPTION: status page class definition
 *
 *****************************************************************************/


#ifndef _PRINT_PHOTOS_WIZARD_STATUS_PAGE_DLG_PROC_
#define _PRINT_PHOTOS_WIZARD_STATUS_PAGE_DLG_PROC_


#define PP_STATUS_PRINT             (WM_USER+300)
#define SP_MSG_UPDATE_PROGRESS_TEXT (WM_USER+301)   // wParam = cur page, lParam = total pages
#define SP_MSG_JUMP_TO_PAGE         (WM_USER+302)   // lParam = offset (+1, -1) from current page


class CWizardInfoBlob;


class CStatusPage
{
public:
    CStatusPage( CWizardInfoBlob * pBlob );
    ~CStatusPage();

    INT_PTR DoHandleMessage( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    VOID ShutDownBackgroundThreads();

private:

    // window message handlers
    LRESULT         _OnInitDialog();
    LRESULT         _OnDestroy();
    LRESULT         _OnNotify(WPARAM wParam, LPARAM lParam);

    // thread message handlers
    VOID            _DoHandleThreadMessage( LPMSG pMSG );

    // cancel printing
    VOID            _CancelPrinting();



    // worker thread proc
    static DWORD s_StatusWorkerThreadProc( LPVOID lpv )
    {
        WIA_PUSH_FUNCTION_MASK((0x80, TEXT("CStatusPage::s_StatusWorkerThreadProc()")));
        MSG msg;
        LONG lRes = 0;
        CStatusPage * pSP = (CStatusPage *)lpv;

        HMODULE hDll = GetThreadHMODULE( s_StatusWorkerThreadProc );
        HRESULT hrCo = PPWCoInitialize();

        if (pSP)
        {
            PeekMessage( &msg, NULL, WM_USER, WM_USER, PM_NOREMOVE );
            do {
                lRes = GetMessage( &msg, NULL, 0, 0 );
                if (lRes > 0)
                {
                    pSP->_DoHandleThreadMessage( &msg );
                }
            } while ( (lRes != 0) && (lRes != -1) );
        }
        WIA_TRACE((TEXT("s_StatusWorkerThreadProc: exiting thread now...")));

        PPWCoUninitialize(hrCo);

        if (hDll)
        {
            FreeLibraryAndExitThread( hDll, 0 );
        }
        return 0;
    }

private:
    CWizardInfoBlob *               _pWizInfo;
    HWND                            _hDlg;
    HANDLE                          _hWorkerThread;
    DWORD                           _dwWorkerThreadId;
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\status.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       status.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        11/7/00
 *
 *  DESCRIPTION: Implements code for the printing status page of the
 *               print photos wizard...
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

BOOL g_bCancelPrintJob = FALSE;


/*****************************************************************************

   PhotoPrintAbortProc

   Called by GDI to see if the print job should be canceled.

 *****************************************************************************/

BOOL CALLBACK PhotoPrintAbortProc( HDC hDC, INT iError )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_STATUS, TEXT("PhotoPrintAbortProc(0x%x, %d)"),hDC,iError));

    #ifdef DEBUG
    if (g_bCancelPrintJob)
    {
        WIA_TRACE((TEXT("PhotoPrintAbortProc: attempting to cancel print job...")))
    }
    #endif

    return (!g_bCancelPrintJob);

}


/*****************************************************************************

   CStatusPage -- constructor/desctructor

   <Notes>

 *****************************************************************************/

CStatusPage::CStatusPage( CWizardInfoBlob * pBlob )
  : _hDlg(NULL),
    _hWorkerThread(NULL),
    _dwWorkerThreadId(0)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_STATUS, TEXT("CStatusPage::CStatusPage()")));
    _pWizInfo = pBlob;
    _pWizInfo->AddRef();

    //
    // Create worker thread
    //

    _hWorkerThread = CreateThread( NULL,
                                   0,
                                   CStatusPage::s_StatusWorkerThreadProc,
                                   (LPVOID)this,
                                   CREATE_SUSPENDED,
                                   &_dwWorkerThreadId );

    //
    // If we created the thread, set it's priority to slight below normal so other
    // things run okay.  This can be a CPU intensive task...
    //

    if (_hWorkerThread)
    {
        SetThreadPriority( _hWorkerThread, THREAD_PRIORITY_BELOW_NORMAL );
        ResumeThread( _hWorkerThread );
    }
}

CStatusPage::~CStatusPage()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_STATUS, TEXT("CStatusPage::~CStatusPage()")));

    if (_pWizInfo)
    {
        _pWizInfo->Release();
        _pWizInfo = NULL;
    }

}

VOID CStatusPage::ShutDownBackgroundThreads()
{

    //
    // Shutdown the background thread...
    //

    _OnDestroy();

    //
    // Signify that we've shutdown our threads...
    //

    if (_pWizInfo)
    {
        _pWizInfo->StatusIsShutDown();
    }
}



/*****************************************************************************

   CStatusPage::_DoHandleThreadMessage

   Depending on the message received, does the work for the given message...

 *****************************************************************************/

VOID CStatusPage::_DoHandleThreadMessage( LPMSG pMSG )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_STATUS, TEXT("CStatusPage::_DoHandleThreadMessage()")));

    if (!pMSG)
    {
        WIA_ERROR((TEXT("pMSG is NULL, returning early!")));
        return;
    }

    switch (pMSG->message)
    {

    case PP_STATUS_PRINT:
        WIA_TRACE((TEXT("Got PP_STATUS_PRINT message")));
        if (_pWizInfo)
        {
            BOOL bDeleteDC = FALSE;

            //
            // Create an hDC for the printer...
            //

            HDC hDC = _pWizInfo->GetCachedPrinterDC();

            if (!hDC)
            {
                hDC = CreateDC( TEXT("WINSPOOL"), _pWizInfo->GetPrinterToUse(), NULL, _pWizInfo->GetDevModeToUse() );
                bDeleteDC = TRUE;
            }

            if (hDC)
            {
                DOCINFO         di           = {0};
                BOOL            bCancel      = FALSE;
                HWND            hwndProgress = GetDlgItem( _hDlg, IDC_PRINT_PROGRESS );

                //
                // Set the progress meter to 0
                //

                if (hwndProgress)
                {
                    PostMessage( hwndProgress, PBM_SETRANGE, 0, MAKELPARAM(0,100) );
                    PostMessage( hwndProgress, PBM_SETPOS,   0, 0 );
                }

                //
                // turn on ICM for this hDC
                //

                SetICMMode( hDC, ICM_ON );

                di.cbSize = sizeof(DOCINFO);

                //
                // Lets use the template name for the document name...
                //

                CSimpleString strTitle;
                CTemplateInfo * pTemplateInfo = NULL;

                if (SUCCEEDED(_pWizInfo->GetTemplateByIndex( _pWizInfo->GetCurrentTemplateIndex() ,&pTemplateInfo)) && pTemplateInfo)
                {
                    pTemplateInfo->GetTitle( &strTitle );
                }

                //
                // Let's remove the ':' at the end if there is one
                //

                INT iLen = strTitle.Length();
                if (iLen && (strTitle[(INT)iLen-1] == TEXT(':')))
                {
                    strTitle.Truncate(iLen);
                }

                di.lpszDocName = strTitle;

                if (!_pWizInfo->IsWizardShuttingDown())
                {
                    if (StartDoc( hDC, &di ) > 0)
                    {
                        HRESULT         hr;
                        INT             iPageCount = 0;
                        float           fPercent   = 0.0;
                        MSG             msg;

                        g_bCancelPrintJob = FALSE;

                        //
                        // Set the abort proc...
                        //

                        if (SP_ERROR == SetAbortProc( hDC, PhotoPrintAbortProc ))
                        {
                            WIA_ERROR((TEXT("Got SP_ERROR trying to set AbortProc!")));
                        }

                        //
                        // Loop through until we've printed all the photos...
                        //

                        if (SUCCEEDED(hr = _pWizInfo->GetCountOfPrintedPages( _pWizInfo->GetCurrentTemplateIndex(), &iPageCount )))
                        {
                            float fPageCount = (float)iPageCount;

                            for (INT iPage = 0; !g_bCancelPrintJob && (iPage < iPageCount); iPage++)
                            {

                                //
                                // Set which page we are on...
                                //

                                PostMessage( _hDlg, SP_MSG_UPDATE_PROGRESS_TEXT, (WPARAM)(iPage+1), (LPARAM)iPageCount );

                                //
                                // Print the page...
                                //

                                if (StartPage( hDC ) > 0)
                                {
                                    //
                                    // Ensure that ICM mode stays on.  Per MSDN docs
                                    // ICM mode gets reset after each StartPage call.
                                    //

                                    SetICMMode( hDC, ICM_ON );

                                    hr = _pWizInfo->RenderPrintedPage( _pWizInfo->GetCurrentTemplateIndex(), iPage, hDC, hwndProgress, (float)((float)100.0 / fPageCount), &fPercent );
                                    if ((hr != S_OK) && (hr != S_FALSE))
                                    {
                                        g_bCancelPrintJob = TRUE;
                                    }

                                    EndPage( hDC );
                                }
                                else
                                {
                                    _pWizInfo->ShowError( _hDlg, HRESULT_FROM_WIN32(GetLastError()), IDS_ERROR_WHILE_PRINTING );
                                    WIA_ERROR((TEXT("PrintThread: StartPage failed w/GLE=%d"),GetLastError()));
                                    g_bCancelPrintJob = TRUE;
                                }


                                if (_pWizInfo->IsWizardShuttingDown())
                                {
                                    g_bCancelPrintJob = TRUE;
                                }

                            }
                        }

                    }
                    else
                    {

                        _pWizInfo->ShowError( _hDlg, HRESULT_FROM_WIN32(GetLastError()), IDS_ERROR_WHILE_PRINTING );
                        WIA_ERROR((TEXT("PrintThread: StartDoc failed w/GLE = %d"),GetLastError()));
                        g_bCancelPrintJob = TRUE;
                    }
                }

                INT iOffset = -1;

                if (g_bCancelPrintJob)
                {
                    //
                    // If there was an error, or the job was cancelled, then abort it...
                    //

                    AbortDoc( hDC );
                }
                else
                {
                    //
                    // If printing succeeded, then end the job so it can be printed...
                    //

                    EndDoc( hDC );

                    //
                    // Set progress to 100 percent
                    //

                    if (hwndProgress)
                    {
                        PostMessage( hwndProgress, PBM_SETPOS, 100, 0 );
                        Sleep(250);
                    }

                    //
                    // Jump to next page...
                    //

                    iOffset = 1;

                }

                if (bDeleteDC)
                {
                    DeleteDC( hDC );
                }

                WIA_TRACE((TEXT("iOffset from current page %d"),iOffset));
                PostMessage( _hDlg, SP_MSG_JUMP_TO_PAGE, 0, iOffset );

            }
            else
            {
                _pWizInfo->ShowError( _hDlg, (HRESULT)GetLastError(), IDS_ERROR_CREATEDC_FAILED );

                //
                // Jump back to printer selection page... (back 2 pages, thus -2)
                //

                PostMessage( _hDlg, SP_MSG_JUMP_TO_PAGE, 0, -2 );
            }

        }
        break;

    }
}





/*****************************************************************************

   CStatusPage::_OnInitDialog

   Handle initializing the wizard page...

 *****************************************************************************/

LRESULT CStatusPage::_OnInitDialog()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_STATUS, TEXT("CStatusPage::_OnInitDialog()")));

    if (!_pWizInfo)
    {
        WIA_ERROR((TEXT("FATAL: _pWizInfo is NULL, exiting early")));
        return FALSE;
    }

    _pWizInfo->SetStatusWnd( _hDlg );
    _pWizInfo->SetStatusPageClass( this );

    return TRUE;
}


/*****************************************************************************

   CStatusPage::CancelPrinting

   Called to stop the print job...

 *****************************************************************************/

VOID CStatusPage::_CancelPrinting()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_STATUS, TEXT("CStatusPage:_CancelPrinting()")));

    //
    // Pause the worker thread while we ask about cancelling printing...
    //

    if (_hWorkerThread)
    {
        SuspendThread( _hWorkerThread );
    }

    //
    // Check to see if the user wants to cancel printing...
    //

    INT iRes;

    CSimpleString strMessage(IDS_CANCEL_PRINT_MESSAGE, g_hInst);
    CSimpleString strCaption(IDS_CANCEL_PRINT_CAPTION, g_hInst);

    iRes = MessageBox( _hDlg,
                       strMessage,
                       strCaption,
                       MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL | MB_SETFOREGROUND
                      );

    g_bCancelPrintJob = (iRes == IDYES);

    //
    // Resume the thread now that the user has responded...
    //

    if (_hWorkerThread)
    {
        ResumeThread( _hWorkerThread );
    }

}



/*****************************************************************************

   CStatusPage::_OnDestroy

   Handles WM_DESTROY for printing status page...

 *****************************************************************************/

LRESULT CStatusPage::_OnDestroy()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PAGE_STATUS, TEXT("CStatusPage::_OnDestroy()")));

    if (_hWorkerThread && _dwWorkerThreadId)
    {
        WIA_TRACE((TEXT("Sending WM_QUIT to worker thread proc")));
        PostThreadMessage( _dwWorkerThreadId, WM_QUIT, 0, 0 );
        WiaUiUtil::MsgWaitForSingleObject( _hWorkerThread, INFINITE );
        WIA_TRACE((TEXT("_hWorkerThread handle signal'd, closing handle...")));
        CloseHandle( _hWorkerThread );
        _hWorkerThread = NULL;
        _dwWorkerThreadId = 0;
    }

    return FALSE;
}


/*****************************************************************************

   CStatusPage::_OnNotify

   Handle WM_NOTIFY

 *****************************************************************************/


LRESULT CStatusPage::_OnNotify( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DLGPROC, TEXT("CStatusPage::_OnNotify()")));

    LONG_PTR lpRes = 0;

    LPNMHDR pnmh = (LPNMHDR)lParam;
    switch (pnmh->code)
    {

        case PSN_SETACTIVE:
        {
            WIA_TRACE((TEXT("CStatusPage: got PSN_SETACTIVE")));
            PropSheet_SetWizButtons( GetParent(_hDlg), 0 );

            //
            // Reset items
            //

            SendDlgItemMessage( _hDlg, IDC_PRINT_PROGRESS, PBM_SETPOS, 0, 0 );
            CSimpleString str( IDS_READY_TO_PRINT, g_hInst );
            SetDlgItemText( _hDlg, IDC_PRINT_PROGRESS_TEXT, str.String() );

            //
            // Start printing...
            //

            if (_hWorkerThread && _dwWorkerThreadId)
            {
                //
                // Start printing...
                //

                WIA_TRACE((TEXT("CStatusPage: posting PP_STATUS_PRINT message")));
                PostThreadMessage( _dwWorkerThreadId, PP_STATUS_PRINT, 0, 0 );
            }
            lpRes = 0;
        }
        break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            WIA_TRACE((TEXT("CStatusPage: got PSN_WIZBACK or PSN_WIZNEXT")));
            lpRes = -1;
            break;

        case PSN_QUERYCANCEL:
        {
            WIA_TRACE((TEXT("CStatusPage: got PSN_QUERYCANCEL")));
            _CancelPrinting();
            if (pnmh->code == PSN_QUERYCANCEL)
            {
                lpRes = (!g_bCancelPrintJob);

                if (!lpRes)
                {
                    //
                    // We're cancelling the dialog, so do cleanup...
                    //

                    if (_pWizInfo)
                    {
                        _pWizInfo->ShutDownWizard();
                    }
                }
            }
            else
            {
                lpRes = -1;
            }
        }
        break;

    }

    SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, lpRes );
    return TRUE;
}


/*****************************************************************************

   CStatusPage::DoHandleMessage

   Hanlder for messages sent to this page...

 *****************************************************************************/

INT_PTR CStatusPage::DoHandleMessage( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_DLGPROC, TEXT("CStatusPage::DoHandleMessage( uMsg = 0x%x, wParam = 0x%x, lParam = 0x%x )"),uMsg,wParam,lParam));

    static CSimpleString   strFormat(IDS_PRINTING_PROGRESS,g_hInst);
    static CSimpleString   strProgress;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            _hDlg = hDlg;
            return _OnInitDialog();

        case WM_COMMAND:
            if (LOWORD(wParam)==IDC_CANCEL_PRINTING)
            {
                if (HIWORD(wParam)==BN_CLICKED)
                {
                    _CancelPrinting();
                }
            }
            break;

        case WM_DESTROY:
            return _OnDestroy();

        case WM_NOTIFY:
            return _OnNotify(wParam,lParam);

        case SP_MSG_UPDATE_PROGRESS_TEXT:
            strProgress.Format( strFormat, wParam, lParam );
            strProgress.SetWindowText( GetDlgItem( _hDlg, IDC_PRINT_PROGRESS_TEXT ) );
            break;

        case SP_MSG_JUMP_TO_PAGE:
            {
                HWND hwndCurrent = PropSheet_GetCurrentPageHwnd( GetParent(_hDlg) );
                INT  iIndex      = PropSheet_HwndToIndex( GetParent(_hDlg), hwndCurrent );


                PropSheet_SetCurSel( GetParent(_hDlg), NULL, iIndex + (INT)lParam );
            }
            break;


    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\wizblob.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       wizblob.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/18/00
 *
 *  DESCRIPTION: Class which encapsulates the data which must be passed
 *               around from page to page in the print photos wizard...
 *
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "gphelper.h"

static const int c_nDefaultThumbnailWidth   = DEFAULT_THUMB_WIDTH;
static const int c_nDefaultThumbnailHeight  = DEFAULT_THUMB_HEIGHT;

static const int c_nMaxThumbnailWidth       = 120;
static const int c_nMaxThumbnailHeight      = 120;

static const int c_nMinThumbnailWidth       = 80;
static const int c_nMinThumbnailHeight      = 80;

static const int c_nDefaultTemplatePreviewWidth = 48;
static const int c_nDefaultTemplatePreviewHeight = 62;

Gdiplus::Color g_wndColor;

/*****************************************************************************

   Callback class for namespace walking code...

   <Notes>

 *****************************************************************************/

class CWalkCallback : public INamespaceWalkCB
{
public:
    CWalkCallback();
    ~CWalkCallback();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // INamespaceWalkCB
    STDMETHOD(FoundItem)(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHOD(EnterFolder)(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHOD(LeaveFolder)(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHOD(InitializeProgressDialog)(LPWSTR * ppszTitle, LPWSTR * ppszCancel);

    BOOL WereItemsRejected() {return _bItemsWereRejected;}

private:
    LONG            _cRef;
    BOOL            _bItemsWereRejected;
    CImageFileFormatVerifier _Verify;
};

CWalkCallback::CWalkCallback()
  : _cRef(1),
    _bItemsWereRejected(FALSE)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB,TEXT("CWalkCallback::CWalkCallback( this == 0x%x )"),this));
    DllAddRef();

}

CWalkCallback::~CWalkCallback()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB,TEXT("CWalkCallback::~CWalkCallback( this == 0x%x )"),this));
    DllRelease();
}

ULONG CWalkCallback::AddRef()
{
    ULONG ul = InterlockedIncrement(&_cRef);

    WIA_PUSH_FUNCTION_MASK((TRACE_REF_COUNTS,TEXT("CWalkCallback::AddRef( new count is %d )"), ul));

    return ul;
}

ULONG CWalkCallback::Release()
{
    ULONG ul = InterlockedDecrement(&_cRef);

    WIA_PUSH_FUNCTION_MASK((TRACE_REF_COUNTS,TEXT("CWalkCallback::Release( new count is %d )"), ul));

    if (ul)
        return ul;

    WIA_TRACE((TEXT("deleting CWalkCallback( this == 0x%x ) object"),this));
    delete this;
    return 0;
}

HRESULT CWalkCallback::QueryInterface(REFIID riid, void **ppv)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB,TEXT("CWalkCallback::QueryInterface()")));

    static const QITAB qit[] =
    {
        QITABENT(CWalkCallback, INamespaceWalkCB),
        {0, 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppv);

    WIA_RETURN_HR(hr);
}

STDAPI DisplayNameOf(IShellFolder *psf, LPCITEMIDLIST pidl, DWORD flags, LPTSTR psz, UINT cch)
{
    *psz = 0;
    STRRET sr;
    HRESULT hr = psf->GetDisplayNameOf(pidl, flags, &sr);
    if (SUCCEEDED(hr))
        hr = StrRetToBuf(&sr, pidl, psz, cch);
    return hr;
}

HRESULT CWalkCallback::FoundItem( IShellFolder * psf, LPCITEMIDLIST pidl )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB,TEXT("CWalkCallback::FoundItem()")));

    HRESULT hrRet = S_FALSE;

    if (psf && pidl)
    {
        WIA_TRACE((TEXT("FoundItem: psf & pidl are valid, binding to stream to check signature...")));

        IStream * pStream = NULL;

        HRESULT hr = psf->BindToObject( pidl, NULL, IID_IStream, (void **)&pStream );
        if (SUCCEEDED(hr) && pStream)
        {
            GUID guidType;
            BOOL bSupported = FALSE;

            WIA_TRACE((TEXT("FoundItem: checking for GDI+ decoder...")));

            bSupported = _Verify.IsSupportedImageFromStream(pStream, &guidType);

            //
            // We don't let EMF, WMF or .ico into the wizard
            //

            if (bSupported &&
                ((guidType != Gdiplus::ImageFormatWMF) &&
                 (guidType != Gdiplus::ImageFormatEMF) &&
                 (guidType != Gdiplus::ImageFormatIcon)))
            {
                WIA_TRACE((TEXT("FoundItem: GDI+ encoder found")));
                hrRet = S_OK;
            }
            else
            {
                _bItemsWereRejected = TRUE;
            }
        }

        if (pStream)
        {
            pStream->Release();
        }
    }


    if (hrRet != S_OK)
    {
        _bItemsWereRejected = TRUE;
    }

    WIA_RETURN_HR(hrRet);
}

HRESULT CWalkCallback::EnterFolder( IShellFolder * psf, LPCITEMIDLIST pidl )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB,TEXT("CWalkCallback::EnterFolder()")));
    return S_OK;
}

HRESULT CWalkCallback::LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB,TEXT("CWalkCallback::LeaveFolder()")));
    return S_OK;
}

HRESULT CWalkCallback::InitializeProgressDialog(LPWSTR * ppszTitle, LPWSTR * ppszCancel)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB,TEXT("CWalkCallback::InitializeProgressDialog()")));

    //
    // If we want to use the progress dialog, we need to specify
    // when we create the namespace walk object NSWF_SHOW_PROGRESS
    // and use CoTaskMemAlloc to create the strings...
    //

    if (ppszTitle)
    {
        *ppszTitle = NULL;
    }

    if (ppszCancel)
    {
        *ppszCancel = NULL;
    }

    return E_FAIL;
}


/*****************************************************************************

   MyItemDpaDestroyCallback

   Gets called as the HDPA is destroyed so that we can delete the objects
   stored in the DPA

 *****************************************************************************/

INT MyItemDpaDestroyCallback( LPVOID pItem, LPVOID lpData )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB,TEXT("MyItemDpaDestroyCallback( 0x%x, 0x%x )"),pItem,lpData));

    if (pItem)
    {
        delete (CListItem *)pItem;
    }

    return TRUE;
}

/*****************************************************************************

   CWizardInfoBlob -- constructor/desctructor

   <Notes>

 *****************************************************************************/

CWizardInfoBlob::CWizardInfoBlob( IDataObject * pdo, BOOL bShowUI, BOOL bOnlyUseSelection )
  : _cRef(0),
    _hdpaItems(NULL),
    _nDefaultThumbnailImageListIndex(0),
    _bGdiplusInitialized(FALSE),
    _bAllPicturesAdded(FALSE),
    _bItemsWereRejected(FALSE),
    _pGdiplusToken(NULL),
    _pPreview(NULL),
    _pStatusPage(NULL),
    _pPhotoSelPage(NULL),
    _hDevMode(NULL),
    _hfontIntro(NULL),
    _iCurTemplate(-1),
    _bPreviewsAreDirty(TRUE),
    _bRepeat(FALSE),
    _hSmallIcon(NULL),
    _hLargeIcon(NULL),
    _uItemsInInitialSelection(0),
    _bAlreadyAddedPhotos(FALSE),
    _bWizardIsShuttingDown((LONG)FALSE),
    _hPhotoSelIsDone(NULL),
    _hStatusIsDone(NULL),
    _hPreviewIsDone(NULL),
    _hwndPreview(NULL),
    _hwndStatus(NULL),
    _hGdiPlusThread(NULL),
    _dwGdiPlusThreadId(0),
    _hGdiPlusMsgQueueCreated(NULL),
    _hCachedPrinterDC(NULL),
    _hOuterDlg(NULL),
    _bShowUI(bShowUI),
    _bOnlyUseSelection(bOnlyUseSelection),
    _iNumErrorsWhileRunningWizard(0),
    _iSelectedItem(0),
    _iCopiesOfEachItem(1),
    _bMinimumMemorySystem(FALSE),
    _bLargeMemorySystem(FALSE),
    _bForceSelectAll(FALSE)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::CWizardInfoBlob()") ));

    //
    // Init the printer info stuff..
    //

    ZeroMemory( &_WizPrinterInfo, sizeof(_WizPrinterInfo) );

    //
    // Copy params and init
    //

    _pdo = pdo;
    _sizeThumbnails.cx = c_nDefaultThumbnailWidth;
    _sizeThumbnails.cy = c_nDefaultThumbnailHeight;
    _sizeTemplatePreview.cx = c_nDefaultTemplatePreviewWidth;
    _sizeTemplatePreview.cy = c_nDefaultTemplatePreviewHeight;

    _rcInitSize.left    = 0;
    _rcInitSize.right   = 0;
    _rcInitSize.bottom  = 0;
    _rcInitSize.top     = 0;

    //
    // This is disgusting -- but GDI+ needs to be initialized and shut down
    // ON THE SAME THREAD.  So, we have to create a thread just for this and have
    // it sit around so that we're garaunteed this is the thread we'll do
    // startup/shutdown on.
    //

    _hGdiPlusMsgQueueCreated = CreateEvent( NULL, FALSE, FALSE, NULL );

    WIA_TRACE((TEXT("creating s_GdiPlusStartupShutdownThreadProc...")));
    _hGdiPlusThread = CreateThread( NULL, 0, s_GdiPlusStartupShutdownThreadProc, (LPVOID)this, 0, &_dwGdiPlusThreadId );

    if (_hGdiPlusMsgQueueCreated)
    {
        if (_hGdiPlusThread && _dwGdiPlusThreadId)
        {
            WIA_TRACE((TEXT("waiting for message queue to be created in s_GdiPlusStartupShutdownThreadProc...")));
            WiaUiUtil::MsgWaitForSingleObject( _hGdiPlusMsgQueueCreated, INFINITE );
            WIA_TRACE((TEXT("GdiPlusStartupShutdown thread initialized correctly.")));
        }
        else
        {
            WIA_ERROR((TEXT("_hGdiPlusThread = 0x%x, _dwGdiPlusThreadId = 0x%x"),_hGdiPlusThread,_dwGdiPlusThreadId));
        }
        CloseHandle( _hGdiPlusMsgQueueCreated );
        _hGdiPlusMsgQueueCreated = NULL;
    }
    else
    {
        WIA_ERROR((TEXT("Couldn't create _hGdiPlusMsgQueueCreated!")));
    }

    //
    // Make sure GDI+ is initialized
    //

    WIA_TRACE((TEXT("posting WIZ_MSG_STARTUP_GDI_PLUS to s_GdiPlusStartupShutdownThreadProc...")));
    HANDLE hGdiPlusInitialized = CreateEvent( NULL, FALSE, FALSE, NULL );
    PostThreadMessage( _dwGdiPlusThreadId, WIZ_MSG_STARTUP_GDI_PLUS, 0, (LPARAM)hGdiPlusInitialized );

    if (hGdiPlusInitialized)
    {
        WIA_TRACE((TEXT("waiting for GDI+ startup to finish...")));
        WiaUiUtil::MsgWaitForSingleObject( hGdiPlusInitialized, INFINITE );
        CloseHandle( hGdiPlusInitialized );
        WIA_TRACE((TEXT("GDI+ startup completed!")));
    }

    //
    // Set up window color for use later...
    //

    DWORD dw = GetSysColor( COLOR_WINDOW );
    Gdiplus::ARGB argb = Gdiplus::Color::MakeARGB( 255, GetRValue(dw), GetGValue(dw), GetBValue(dw) );
    g_wndColor.SetValue( argb );

    //
    // Get perf info (like how much memory we have)...
    //

    NTSTATUS                 NtStatus;
    SYSTEM_BASIC_INFORMATION BasicInfo;

    NtStatus = NtQuerySystemInformation( SystemBasicInformation,
                                         &BasicInfo,
                                         sizeof(BasicInfo),
                                         NULL
                                        );

    if (NT_SUCCESS(NtStatus))
    {
        DWORD dwMemSizeInK = BasicInfo.NumberOfPhysicalPages * (BasicInfo.PageSize / 1024);

        if (dwMemSizeInK < MINIMUM_MEMORY_SIZE)
        {
            WIA_TRACE((TEXT("we are running on a minimum memory system!")));
            _bMinimumMemorySystem = TRUE;
        }

        if (dwMemSizeInK > LARGE_MINIMUM_MEMORY_SIZE)
        {
            WIA_TRACE((TEXT("we are running on a minimum memory system!")));
            _bLargeMemorySystem = TRUE;
        }
    }

    //
    // If we're in UI mode, show the UI...
    //

    if (bShowUI)
    {
        //
        // Load icons for wizard...
        //

        _hSmallIcon = reinterpret_cast<HICON>(LoadImage( g_hInst, MAKEINTRESOURCE(IDI_APP_ICON), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR ));
        _hLargeIcon = reinterpret_cast<HICON>(LoadImage( g_hInst, MAKEINTRESOURCE(IDI_APP_ICON), IMAGE_ICON, GetSystemMetrics(SM_CXICON),   GetSystemMetrics(SM_CYICON),   LR_DEFAULTCOLOR ));

        //
        // Create events for background tasks to signal when they're done...
        //

        _hPhotoSelIsDone = CreateEvent( NULL, FALSE, FALSE, NULL );
        _hStatusIsDone   = CreateEvent( NULL, FALSE, FALSE, NULL );
        _hPreviewIsDone  = CreateEvent( NULL, FALSE, FALSE, NULL );

        //
        // Initialize template info from XML...
        //

        CComPtr<IXMLDOMDocument> spXMLDoc;
        if (SUCCEEDED(LoadXMLDOMDoc(TEXT("res://photowiz.dll/tmpldata.xml"), &spXMLDoc)))
        {
            _templates.Init(spXMLDoc);
        }
    }
}

CWizardInfoBlob::~CWizardInfoBlob()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::~CWizardInfoBlob()") ));

    //
    // free the memory
    //
    if (_hDevMode)
    {
        delete [] _hDevMode;
        _hDevMode = NULL;
    }

    _csItems.Enter();
    if (_hdpaItems)
    {
        DPA_DestroyCallback( _hdpaItems, MyItemDpaDestroyCallback, NULL );
        _hdpaItems = NULL;
    }
    _csItems.Leave();

    if (_hfontIntro)
    {
        DeleteObject( (HGDIOBJ)_hfontIntro );
        _hfontIntro = NULL;
    }

    if (_hCachedPrinterDC)
    {
        DeleteDC( _hCachedPrinterDC );
    }

    //
    // Destroy icons for wizard
    //

    if (_hSmallIcon)
    {
        DestroyIcon( _hSmallIcon );
        _hSmallIcon = NULL;
    }

    if (_hLargeIcon)
    {
        DestroyIcon( _hLargeIcon );
        _hLargeIcon = NULL;
    }

    //
    // Close event handles...
    //

    if (_hPhotoSelIsDone)
    {
        CloseHandle( _hPhotoSelIsDone );
        _hPhotoSelIsDone = NULL;
    }

    if (_hStatusIsDone)
    {
        CloseHandle( _hStatusIsDone );
        _hStatusIsDone = NULL;
    }

    if (_hPreviewIsDone)
    {
        CloseHandle( _hPreviewIsDone );
        _hPreviewIsDone = NULL;
    }

    WIA_TRACE((TEXT("Attempting to shut down GDI+")));

    if (_hGdiPlusThread && _dwGdiPlusThreadId)
    {
        //
        // Lastly, shut down GDI+
        //

        WIA_TRACE((TEXT("Sending WIZ_MSG_SHUTDOWN_GDI_PLUS to s_GdiPlusStartupShutdownThreadProc")));
        PostThreadMessage( _dwGdiPlusThreadId, WIZ_MSG_SHUTDOWN_GDI_PLUS, 0, 0 );
        WIA_TRACE((TEXT("Sending WM_QUIT to s_GdiPlusStartupShutdownThreadProc")));
        PostThreadMessage( _dwGdiPlusThreadId, WM_QUIT, 0, 0 );

        //
        // Wait for thread to exit...
        //

        WIA_TRACE((TEXT("Waiting for s_GdiPlusStartupShutdownThreadProc to exit...")));
        WiaUiUtil::MsgWaitForSingleObject( _hGdiPlusThread, INFINITE );
        CloseHandle( _hGdiPlusThread );
        _hGdiPlusThread = NULL;
        _dwGdiPlusThreadId = 0;

        WIA_TRACE((TEXT("s_GdiPlusStartupShutdownThreadProc successfully shut down...")));

    }

    //
    // Keep this here (but commented out) for when I need to build
    // instrumented versions for test
    //

    //MessageBox( NULL, TEXT("Photowiz is now shut down."), TEXT("Photowiz"), MB_OK );

}


/*****************************************************************************

   CWizardInfoBlob::_DoHandleThreadMessage

   The is the subroutine that actually does the work for
   s_GdiPlusStartupShutdownThreadProc.  The whole reason for this thread
   in the first place is that GDI+ demands to be initialized and shutdown
   on the SAME THREAD.

 *****************************************************************************/



VOID CWizardInfoBlob::_DoHandleThreadMessage( LPMSG pMsg )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::_DoHandleThreadMessage()") ));

    if (!pMsg)
    {
        WIA_ERROR((TEXT("pMSG is NULL, returning early!")));
        return;
    }

    switch (pMsg->message)
    {

    case WIZ_MSG_STARTUP_GDI_PLUS:
        WIA_TRACE((TEXT("Got WIZ_MSG_STARTUP_GDI_PLUS message")));
        {
            Gdiplus::GdiplusStartupInput StartupInput;
            _bGdiplusInitialized = (Gdiplus::GdiplusStartup(&_pGdiplusToken,&StartupInput,NULL) == Gdiplus::Ok);

            //
            // Signal that we've attempted to initialize GDI+
            //

            if (pMsg->lParam)
            {
                SetEvent( (HANDLE)pMsg->lParam );
            }
        }
        break;

    case WIZ_MSG_SHUTDOWN_GDI_PLUS:
        WIA_TRACE((TEXT("Got WIZ_MSG_SHUTDOWN_GDI_PLUS message")));
        if (_bGdiplusInitialized)
        {
            Gdiplus::GdiplusShutdown(_pGdiplusToken);
            _bGdiplusInitialized = FALSE;
            _pGdiplusToken = NULL;
        }
        break;

    case WIZ_MSG_COPIES_CHANGED:
        WIA_TRACE((TEXT("Got WIZ_MSG_COPIES_CHANGED( %d ) message"),pMsg->wParam));
        {
            if (_iCopiesOfEachItem != pMsg->wParam)
            {
                //
                // Stop all the preview generation background threads...
                //

                if (_pPreview)
                {
                    _pPreview->StallBackgroundThreads();

                    //
                    // Now change number of copies of each image...
                    //

                    RemoveAllCopiesOfPhotos();
                    AddCopiesOfPhotos( (UINT)pMsg->wParam );

                    //
                    // Let the preview threads get going again...
                    //

                    _pPreview->RestartBackgroundThreads();

                }

                _iCopiesOfEachItem = (INT)pMsg->wParam;
            }

        }
        break;

    }


}


/*****************************************************************************

   CWizardInfoBlob::ShutDownWizard

   Called to close all the background thread in the wizard.

 *****************************************************************************/

VOID CWizardInfoBlob::ShutDownWizard()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::ShutDownWizard()") ));

    //
    // Get the current value of _bWizardIsShuttingDown and set to TRUE
    // in an atomic way.
    //

    BOOL bPreviousValue = (BOOL)InterlockedExchange( &_bWizardIsShuttingDown, (LONG)TRUE );

    //
    // If we weren't already shutting down, then go ahead and shut down the wizard
    //

    if (!bPreviousValue)
    {
        //
        // This method will attempt to shut down the wizard in an orderly fashion.
        // To do that, all we really need to do at this point is shut down
        // all the background threads so that they don't do any callbacks
        // or callouts after this point.
        //

        //
        // Tell the photo selection page to shut down...
        //

        if (_pPhotoSelPage)
        {
            _pPhotoSelPage->ShutDownBackgroundThreads();
        }

        //
        // Tell the preview window to shut down...
        //

        if (_pPreview)
        {
            _pPreview->ShutDownBackgroundThreads();
        }

        //
        // Tell the status window we're sutting down...
        //

        if (_pStatusPage)
        {
            _pStatusPage->ShutDownBackgroundThreads();
        }

        //
        // Now, wait for all the background threads to complete...
        //

        INT i = 0;
        HANDLE ah[ 3 ];

        if (_hPhotoSelIsDone)
        {
            ah[i++] = _hPhotoSelIsDone;
        }

        if (_hStatusIsDone)
        {
            ah[i++] = _hStatusIsDone;
        }

        if (_hPreviewIsDone)
        {
            ah[i++] = _hPreviewIsDone;
        }

        WaitForMultipleObjects( i, ah, TRUE, INFINITE );
    }

}


/*****************************************************************************

   CWizardInfoBlob::UserPressedCancel

   Called whenever the user presses the cancel button to close the wizard.
   Returns the correct result as to whether the wizard should exit.

 *****************************************************************************/

LRESULT CWizardInfoBlob::UserPressedCancel()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::UserPressedCancel()") ));

    ShutDownWizard();
    return FALSE; // allow wizard to exit
}


/*****************************************************************************

   CWizardInfoBlob -- AddRef/Release

   <Notes>

 *****************************************************************************/

VOID CWizardInfoBlob::AddRef()
{
    LONG l = InterlockedIncrement( &_cRef );
    WIA_PUSH_FUNCTION_MASK((TRACE_REF_COUNTS, TEXT("CWizardInfoBlob::AddRef( new _cRef is %d )"),l ));
}

VOID CWizardInfoBlob::Release()
{
    LONG l = InterlockedDecrement( &_cRef );
    WIA_PUSH_FUNCTION_MASK((TRACE_REF_COUNTS, TEXT("CWizardInfoBlob::Release( new _cRef is %d )"),l ));

    if (l > 0)
    {
        return;
    }

    WIA_TRACE((TEXT("Deleting CWizardInfoBlob object...")));
    delete this;

}


/*****************************************************************************

   CWizardInfoBlob::ShowError

   Unified error reporting...

 *****************************************************************************/

INT CWizardInfoBlob::ShowError( HWND hwnd, HRESULT hr, UINT idText, BOOL bAskTryAgain, LPITEMIDLIST pidl )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::ShowError( hr=0x%x, Id=%d )"),hr,idText));

    CSimpleString strTitle( IDS_ERROR_TITLE, g_hInst );
    CSimpleString strFormat;
    CSimpleString strError( TEXT("") );
    CSimpleString strMessage( TEXT("") );
    CSimpleString strFilename;


    //
    // Record that an error has occurred...
    //

    _iNumErrorsWhileRunningWizard++;

    //
    // Get an hwnd if not specified
    //

    if (!hwnd)
    {
        hwnd = _hOuterDlg;
    }

    //
    // Formulate information string
    //

    if (idText)
    {
        //
        // We were given a specific message string to display
        //

        strFormat.LoadString( idText, g_hInst );

    }
    else
    {
        //
        // Wants generic error working with file...
        //

        strFilename.LoadString( IDS_UNKNOWN_FILE, g_hInst );
        strFormat.LoadString( IDS_ERROR_WITH_FILE, g_hInst );

    }

    UINT idErrorText = 0;

    //
    // map certain hr values to strings we have...
    //

    switch (hr)
    {
    case E_OUTOFMEMORY:
        idErrorText = IDS_ERROR_NOMEMORY;
        break;

    case PPW_E_UNABLE_TO_ROTATE:
        idErrorText = IDS_ERROR_ROTATION;
        break;

    case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
        idErrorText = IDS_ERROR_FILENOTFOUND;
        break;

    case E_ACCESSDENIED:
        idErrorText = IDS_ERROR_ACCESSDENIED;
        break;

    case HRESULT_FROM_WIN32(ERROR_INVALID_PIXEL_FORMAT):
        idErrorText = IDS_ERROR_UNKNOWNFORMAT;
        break;

    case HRESULT_FROM_WIN32(ERROR_NOT_READY):
    case HRESULT_FROM_WIN32(ERROR_WRONG_DISK):
        idErrorText = IDS_ERROR_WRONG_DISK;
        break;

    case E_FAIL:
    case E_NOTIMPL:
    case E_ABORT:
    case HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER):
    case E_INVALIDARG:
        idErrorText = IDS_ERROR_GENERIC;
        break;

    }

    if (idErrorText)
    {
        strError.LoadString( idErrorText, g_hInst );
    }
    else
    {
        //
        // construct basic error string given the hr
        //

        LPTSTR  pszMsgBuf = NULL;
        FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                       NULL,
                       hr,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       (LPTSTR)&pszMsgBuf,
                       0,
                       NULL
                      );
        if (pszMsgBuf)
        {
            strError.Assign( pszMsgBuf );
            LocalFree(pszMsgBuf);
        }
    }

    if (pidl)
    {
        //
        // Get the filename for this file (if passed in)
        //

        CComPtr<IShellFolder> psfParent;
        LPCITEMIDLIST pidlLast;

        hr = SHBindToParent( pidl, IID_PPV_ARG(IShellFolder, &psfParent), &pidlLast );
        if (SUCCEEDED(hr) && psfParent)
        {
            TCHAR szName[ MAX_PATH ];

            *szName = 0;
            if SUCCEEDED(DisplayNameOf( psfParent, pidlLast, SHGDN_INFOLDER, szName, MAX_PATH ))
            {
                strFilename.Assign(szName);
            }
        }

    }

    //
    // We have all the pieces, now format the message
    //


    if (strFilename.Length())
    {
        //
        // no message string was specified, so we're expected to put the file name
        // in the message...
        //

        strMessage.Format( strFormat, strFilename.String(), strError.String() );

    }
    else
    {
        //
        // We were given a particular error string, so no file name displayed...
        //

        strMessage.Format( strFormat, strError.String() );
    }


    UINT uFlags = bAskTryAgain ? (MB_CANCELTRYCONTINUE | MB_DEFBUTTON1) : MB_OK;

    return MessageBox( hwnd, strMessage, strTitle, uFlags | MB_ICONERROR | MB_APPLMODAL | MB_SETFOREGROUND );
}



/*****************************************************************************

   CWizardInfoBlob::RemoveAllCopiesOfPhotos

   Traverses the photo list and removes all copies

 *****************************************************************************/

VOID CWizardInfoBlob::RemoveAllCopiesOfPhotos()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::RemoveAllCopiesOfPhotos()")));

    CAutoCriticalSection lock(_csItems);

    //
    // The easiest way to do this is just to create a new DPA with only
    // the root (non copies) items in it...
    //

    if (_hdpaItems)
    {
        HDPA hdpaNew = DPA_Create(DEFAULT_DPA_SIZE);

        if (hdpaNew)
        {
            INT iCount = DPA_GetPtrCount( _hdpaItems );
            CListItem * pListItem = NULL;

            for (INT i=0; i<iCount; i++)
            {
                pListItem = (CListItem *)DPA_FastGetPtr(_hdpaItems,i);

                if (pListItem)
                {
                    if (pListItem->IsCopyItem())
                    {
                        WIA_TRACE((TEXT("CWizardInfoBlob::RemoveAllCopiesOfPhotos - removing copy 0x%x"),pListItem));
                        delete pListItem;
                    }
                    else
                    {
                        //
                        // Add this page to the item list...
                        //

                        INT iRes = DPA_AppendPtr( hdpaNew, (LPVOID)pListItem );
                        if (iRes == -1)
                        {
                            WIA_TRACE((TEXT("CWizardInfoBlob::RemoveAllCopiesOfPhotos - Tried to add 0x%x to new HDPA, but got back -1, deleting..."),pListItem));
                            delete pListItem;
                        }
                        else
                        {
                            WIA_TRACE((TEXT("CWizardInfoBlob::RemoveAllCopiesOfPhotos - adding 0x%x to new HDPA"),pListItem));
                        }
                    }
                }
            }

            //
            // We've removed all the items that are core items, now
            // delete old list and keep new one. This is safe because
            // we already deleted any items that weren't moved over
            // from the old list -- so either an item has been deleted
            // or it's in the new list and will be deleted when that
            // is cleaned up...
            //

            WIA_TRACE((TEXT("CWizardInfoBlob::RemoveAllCopiesOfPhotos - destroying old list...")));
            DPA_Destroy( _hdpaItems );
            WIA_TRACE((TEXT("CWizardInfoBlob::RemoveAllCopiesOfPhotos - setting _hdpaItems to new list...")));
            _hdpaItems = hdpaNew;
        }
    }

}



/*****************************************************************************

   CWizardInfoBlob::AddCopiesOfPhotos

   Adds the specified number of copies of each photo

 *****************************************************************************/

VOID CWizardInfoBlob::AddCopiesOfPhotos( UINT uCopies )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::AddCopiesOfPhotos( %d )"),uCopies));

    CAutoCriticalSection lock(_csItems);

    //
    // This function assumes that it is getting a pure list -- i.e., only
    // root items and no copies.  This is accomplished by calling RemoveAllCopiesOfPhotos
    // before calling this routine...
    //

    //
    // Loop through all the items, and add the requested number of copies...
    //

    if (_hdpaItems)
    {
        INT iCount = DPA_GetPtrCount( _hdpaItems );

        HDPA hdpaNew = DPA_Create(DEFAULT_DPA_SIZE);

        if (hdpaNew)
        {
            CListItem * pListItem     = NULL;
            CListItem * pListItemCopy = NULL;

            for (INT i=0; i<iCount; i++)
            {
                pListItem = (CListItem *)DPA_FastGetPtr(_hdpaItems,i);

                if (pListItem)
                {
                    //
                    // Add this item to the new list...
                    //

                    INT iRes = DPA_AppendPtr( hdpaNew, (LPVOID)pListItem );
                    if (iRes != -1)
                    {
                        WIA_TRACE((TEXT("CWizardInfoBlob::AddCopiesOfPhotos -- root item 0x%x added to new list"),pListItem));


                        //
                        // Now, add n-1 copies.  We do n-1 because we've
                        // already added the root item one.
                        //

                        for (UINT uCopy = 1; uCopy < uCopies; uCopy++)
                        {
                            pListItemCopy = new CListItem( pListItem->GetSubItem(), pListItem->GetSubFrame() );
                            if (pListItemCopy)
                            {
                                //
                                // Mark this new entry as a copy so it can be deleted as necessary...
                                //

                                pListItemCopy->MarkAsCopy();

                                //
                                // Maintain the selection state
                                //

                                pListItemCopy->SetSelectionState( pListItem->SelectedForPrinting() );

                                //
                                // Add the new item to the list...
                                //

                                iRes = DPA_AppendPtr( hdpaNew, (LPVOID)pListItemCopy );
                                if (iRes == -1)
                                {
                                    WIA_TRACE((TEXT("CWizardInfoBlob::AddCopiesOfPhotos -- error adding copy %d of 0x%x to new list, deleting..."),uCopy,pListItem));
                                    delete pListItemCopy;
                                }
                                else
                                {
                                    WIA_TRACE((TEXT("CWizardInfoBlob::AddCopiesOfPhotos -- copy %d of 0x%x added to new list"),uCopy,pListItem));
                                }
                            }
                            else
                            {
                                WIA_TRACE((TEXT("CWizardInfoBlob::AddCopiesOfPhotos -- couldn't allocated copy %d of 0x%x"),uCopy,pListItem));
                            }
                        }
                    }
                    else
                    {
                        WIA_TRACE((TEXT("CWizardInfoBlob::AddCopiesOfPhotos -- error adding root item 0x%x added to new list, deleting..."),pListItem));
                        delete pListItem;
                    }

                }
            }

            //
            // Now, swap the lists...
            //

            WIA_TRACE((TEXT("CWizardInfoBlob::AddCopiesOfPhotos -- deleting old list...")));
            DPA_Destroy( _hdpaItems );
            WIA_TRACE((TEXT("CWizardInfoBlob::AddCopiesOfPhotos -- using new list...")));
            _hdpaItems = hdpaNew;

        }
    }


}




/*****************************************************************************

   CWizardInfoBlob::AddAllPhotosFromDataObject

   Runs through the data object and create CListItems for each item
   in the data object...

 *****************************************************************************/

VOID CWizardInfoBlob::AddAllPhotosFromDataObject()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::AddAllPhotosFromDataObject()") ));

    if (!_pdo || _bAlreadyAddedPhotos)
    {
        return;
    }

    _bAlreadyAddedPhotos = TRUE;

    //
    // Get an instance of the Namespace walking object...
    //

    UINT cItemsWalk;
    CComPtr<INamespaceWalk> pNSW;
    HRESULT hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pNSW));
    if (SUCCEEDED(hr))
    {
        //
        // Walk the namespace but only pull from current folder...
        //

        CWalkCallback cb;
        DWORD dwFlags;

        if (_bOnlyUseSelection)
        {
            dwFlags = 0;
        }
        else
        {
            dwFlags = (NSWF_ONE_IMPLIES_ALL | NSWF_NONE_IMPLIES_ALL);
        }

        hr = pNSW->Walk(_pdo, dwFlags, 0, &cb);
        if (SUCCEEDED(hr))
        {
            //
            // Get the list of pidls, note, when we do
            // this we own them -- in other words, we
            // have to free the pidls when we're done
            // with them...
            //

            LPITEMIDLIST *ppidls = NULL;


            hr = pNSW->GetIDArrayResult(&cItemsWalk, &ppidls);
            if (SUCCEEDED(hr) && ppidls)
            {
                WIA_TRACE((TEXT("AddAllPhotosFromDataObject: pNSW->GetIDArrayResult() returned cItemsWalk = %d"),cItemsWalk));
                for (INT i = 0; i < (INT)cItemsWalk; i++)
                {
                    AddPhoto( ppidls[i] );
                    ILFree( ppidls[i] );
                }

                CoTaskMemFree(ppidls);
            }
            else
            {
                WIA_ERROR((TEXT("AddAllPhotosFromDataObject(): pNSW->GetIDArrayResult() failed w/hr=0x%x"),hr));
            }

            //
            // If only one item was given to us, then force select all
            // on by default.  This way all frames of a multi-frame
            // image will be selected.
            //

            if (cItemsWalk == 1)
            {
                _bForceSelectAll = TRUE;
            }
        }
        else
        {
            WIA_ERROR((TEXT("AddAllPhotosFromDataObject(): pNSW->Walk() failed w/hr=0x%x"),hr));
        }

        //
        // Were any items rejected while walking the item tree?
        //

        _bItemsWereRejected = cb.WereItemsRejected();

        //
        // Now, detect the case where one item was selected, but we loaded
        // all the images in the folder.  In this case, we want to pre-select
        // only that one image.  That image will be the first pidl we got
        // back from the INamespaceWalk call...
        //

        //
        // How many items are in the dataobject?  This is will give us how
        // many items were selected in the shell view...
        //

        if (_pdo)
        {
            // Request the IDA from the data object
            FORMATETC fmt = {0};
            fmt.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
            fmt.dwAspect = DVASPECT_CONTENT;
            fmt.lindex = -1;
            fmt.tymed = TYMED_HGLOBAL;

            STGMEDIUM medium = { 0 };
            hr = _pdo->GetData(&fmt, &medium);
            if (SUCCEEDED(hr))
            {
                LPIDA pida = (LPIDA)GlobalLock( medium.hGlobal );
                if (pida)
                {
                    _uItemsInInitialSelection = pida->cidl;
                    WIA_TRACE((TEXT("_uItemsInInitialSelection = %d"),_uItemsInInitialSelection));

                    //
                    // Now check if only one item was in dataobject...
                    //

                    if (cItemsWalk < _uItemsInInitialSelection)
                    {
                        WIA_TRACE((TEXT("Some items were rejected, setting _bItemsWereRejected to TRUE!")));
                        _bItemsWereRejected = TRUE;
                    }

                    //
                    // Now check if only one item was in dataobject...
                    //

                    if (pida->cidl == 1)
                    {
                        //
                        // There are two situations where we get one object:
                        //
                        // A. When the user actually had 1 object selected.
                        //    In this case, we will get back a relative pidl
                        //    that is an item.
                        //
                        // B. When the user actually had 0 objects selected.
                        //    In this case, we will get back a relative pidl
                        //    that is a folder.
                        //
                        // We need to set the initialselection count to 1 for A
                        // and 0 for B.
                        //

                        LPITEMIDLIST pidlItem   = (LPITEMIDLIST)((LPBYTE)(pida) + pida->aoffset[1]);
                        LPITEMIDLIST pidlFolder = (LPITEMIDLIST)((LPBYTE)(pida) + pida->aoffset[0]);

                        //
                        // Build fully qualified IDList...
                        //

                        LPITEMIDLIST pidlFull = ILCombine( pidlFolder, pidlItem );

                        if (pidlFull)
                        {
                            CComPtr<IShellFolder> psfParent;
                            LPCITEMIDLIST pidlLast;

                            hr = SHBindToParent( pidlFull, IID_PPV_ARG(IShellFolder, &psfParent), &pidlLast );
                            if (SUCCEEDED(hr) && psfParent)
                            {
                                ULONG uAttr = SFGAO_FOLDER;
                                hr = psfParent->GetAttributesOf( 1, &pidlLast, &uAttr );
                                if (SUCCEEDED(hr) && (uAttr & SFGAO_FOLDER))
                                {
                                    _uItemsInInitialSelection = 0;
                                }

                            }

                            ILFree(pidlFull);
                        }


                    }

                }

                GlobalUnlock( medium.hGlobal );
                ReleaseStgMedium( &medium );

            }
        }

    }
    else
    {
        WIA_ERROR((TEXT("AddAllPhotosFromDataObject(): couldn't CoCreate( INamespaceWalk ), hr = 0x%x"),hr));
    }

    _bAllPicturesAdded = TRUE;
}

/*****************************************************************************

   CWizardInfoBlob::AddAllPhotosFromList

   Runs through the pidl array and create CListItems for each item...

 *****************************************************************************/

VOID CWizardInfoBlob::AddPhotosFromList( LPITEMIDLIST *aidl, int cidl, BOOL bSelectAll )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::AddAllPhotosFromList()") ));

    if (_bAlreadyAddedPhotos)
    {
        return;
    }

    _bAlreadyAddedPhotos = TRUE;

    for (int i=0;i<cidl;i++)
    {
        AddPhoto(aidl[i]);
    }
    _uItemsInInitialSelection = bSelectAll?0:1;

    //
    // If there was only one item passed to us, then force select
    // all on by default (even if it's a multi-frame image)
    //

    if (cidl == 1)
    {
        _bForceSelectAll = TRUE;
    }

    _bAllPicturesAdded = TRUE;
}

/*****************************************************************************

   CWizardInfoBlob::AddPhoto

   Creates a CListItem for the given fully qualified pidl to the speified photo,
   and then adds it to the HDPA.

 *****************************************************************************/

HRESULT CWizardInfoBlob::AddPhoto( LPITEMIDLIST pidlFull )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::AddPhoto()") ));

    HRESULT hr = S_OK;

    CAutoCriticalSection lock(_csItems);

    if (!_hdpaItems)
    {
        _hdpaItems = DPA_Create(DEFAULT_DPA_SIZE);
    }

    if (_hdpaItems)
    {
        //
        // Next, create CPhotoItem for this pidl.. and store in the DPA...
        //

        BOOL bItemAddedToDPA = FALSE;
        CPhotoItem * pItem = new CPhotoItem( pidlFull );

        if (pItem)
        {
            //
            // Got the photo item, now create a list item for each page...
            //

            LONG lFrames;
            hr = pItem->GetImageFrameCount(&lFrames);

            if (SUCCEEDED(hr))
            {
                //
                // Create a list item for each page...
                //

                INT iRes;
                CListItem * pListItem = NULL;

                for (LONG lCurFrame=0; lCurFrame < lFrames; lCurFrame++ )
                {
                    //
                    // NOTE: The pListItem constructor does an addref on pItem
                    //

                    pListItem = new CListItem( pItem, lCurFrame );

                    iRes = -1;
                    if (pListItem)
                    {
                        //
                        // Add this page to the item list...
                        //

                        iRes = DPA_AppendPtr( _hdpaItems, (LPVOID)pListItem );

                        WIA_TRACE((TEXT("DPA_AppendPtr returned %d"),iRes));
                    }

                    if (iRes == -1)
                    {
                        //
                        // the list item wasn't correctly added to
                        // the DPA.  So we need to delete the list
                        // item entry, but not the underlying photo item
                        // object.  To do this, we increase the
                        // reference count artificially on the item,
                        // then delete pListItem (which will cause a
                        // Release() to happen on the underlying pItem).
                        // Then we knowck down the reference count by 1
                        // to get back to the value that was there (on
                        // the underlying pItem) before the pListItem
                        // was created.
                        //

                        pItem->AddRef();
                        delete pListItem;
                        pItem->ReleaseWithoutDeleting();


                        hr = E_OUTOFMEMORY;
                        WIA_ERROR((TEXT("Couldn't create a list item for this photo item")));
                    }
                    else
                    {
                        //
                        // record that there is a legitimate outstanding
                        // reference to the pItem
                        //

                        bItemAddedToDPA = TRUE;
                    }
                }
            }

            if (!bItemAddedToDPA)
            {
                //
                // An error occurred trying to load the file, since we skip'd
                // adding the item to our list, we'll leak this pointer if we
                // don't delete it here...
                //

                delete pItem;
            }


        }
        else
        {
            WIA_ERROR((TEXT("Couldn't allocate a new CPhotoItem!")));
        }
    }
    else
    {
        WIA_ERROR((TEXT("Couldn't create _hdpaItems!")));
    }

    WIA_RETURN_HR(hr);

}



/*****************************************************************************

   CWizardInfoBlob::ToggleSelectionStateOnCopies

   Finds the root item in the list, and then toggles selection state
   to be the specified state on any copies that follow the item in the list...

 *****************************************************************************/

VOID CWizardInfoBlob::ToggleSelectionStateOnCopies( CListItem * pRootItem, BOOL bState )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::CountOfPhotos()")));

    CAutoCriticalSection lock(_csItems);


    if (_hdpaItems)
    {
        //
        // First, try to find this root item in our list...
        //

        INT iCountOfItems = DPA_GetPtrCount(_hdpaItems);
        INT iIndexOfRootItem = -1;
        CListItem * pListItem;

        for (INT i=0; i<iCountOfItems; i++)
        {
            pListItem = (CListItem *)DPA_FastGetPtr( _hdpaItems, i );
            if (pListItem == pRootItem)
            {
                iIndexOfRootItem = i;
                break;
            }
        }

        //
        // Now walk the copies, if there are any...
        //

        if (iIndexOfRootItem != -1)
        {
            INT iIndexOfFirstCopy = iIndexOfRootItem + 1;

            if (iIndexOfFirstCopy < iCountOfItems)
            {
                for (INT i=iIndexOfFirstCopy; i < iCountOfItems; i++)
                {
                    pListItem = (CListItem *)DPA_FastGetPtr( _hdpaItems, i );

                    //
                    // If we get back a NULL item, then bail...
                    //

                    if (!pListItem)
                    {
                        break;
                    }

                    //
                    // If we get a new root item, then we have traversed all the
                    // copies, so bail...
                    //

                    if (!pListItem->IsCopyItem())
                    {
                        break;
                    }

                    //
                    // This is a copy of the specified root item.  Mark it
                    // to have the correct selection state...
                    //

                    pListItem->SetSelectionState(bState);
                }
            }
        }
    }
}


/*****************************************************************************

   CWizardInfoBlob::CountOfPhotos

   Returns number of photos

 *****************************************************************************/

INT CWizardInfoBlob::CountOfPhotos( BOOL bIncludeCopies )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::CountOfPhotos()")));

    CAutoCriticalSection lock(_csItems);


    if (_hdpaItems)
    {
        if (bIncludeCopies)
        {
            return (INT)DPA_GetPtrCount( _hdpaItems );
        }
        else
        {
            //
            // actually walk the list and only count root (non-copy) items...
            //

            INT iCount = 0;
            CListItem * pListItem = NULL;

            for (INT i=0; i<(INT)DPA_GetPtrCount(_hdpaItems); i++)
            {
                pListItem = (CListItem *)DPA_FastGetPtr(_hdpaItems,i);

                if (pListItem && (!pListItem->IsCopyItem()))
                {
                    iCount++;
                }
            }

            return iCount;
        }
    }

    return 0;

}


/*****************************************************************************

   CWizardInfoBlob::CountOfSelectedPhotos

   returns the number of photos selected for printing

 *****************************************************************************/

INT CWizardInfoBlob::CountOfSelectedPhotos( BOOL bIncludeCopies )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::CountOfSelecetedPhotos()")));

    INT iCount = 0;

    CAutoCriticalSection lock(_csItems);

    if (_hdpaItems)
    {
        INT iTotal = DPA_GetPtrCount( _hdpaItems );

        CListItem * pItem = NULL;
        for (INT i = 0; i < iTotal; i++)
        {

            pItem = (CListItem *)DPA_FastGetPtr(_hdpaItems,i);

            if (pItem)
            {
                if (bIncludeCopies)
                {
                    if (pItem->SelectedForPrinting())
                    {
                        iCount++;
                    }
                }
                else
                {
                    if ((!pItem->IsCopyItem()) && pItem->SelectedForPrinting())
                    {
                        iCount++;
                    }
                }
            }
        }
    }

    return iCount;

}


/*****************************************************************************

   CWizardInfoBlob::GetIndexOfNextPrintableItem

   Starting from iStartIndex, returns the index of the next item
   that is mark as selected for printing...

 *****************************************************************************/

INT CWizardInfoBlob::GetIndexOfNextPrintableItem( INT iStartIndex )
{

    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::GetIndexOfNextPrintableItem( %d )"),iStartIndex));

    INT iIndex = -1;
    INT iCountOfAllItems = CountOfPhotos(TRUE);
    CListItem * pItem = NULL;

    if (iStartIndex != -1)
    {
        for( INT i = iStartIndex; i < iCountOfAllItems; i++ )
        {
            pItem = GetListItem( i, TRUE );
            if (pItem)
            {
                if (pItem->SelectedForPrinting())
                {
                    iIndex = i;
                    break;
                }
            }
        }
    }

    return iIndex;

}

/*****************************************************************************

   CWizardInfoBlob::GetListItem

   Returns given item from the list of photos

 *****************************************************************************/

CListItem * CWizardInfoBlob::GetListItem( INT iIndex, BOOL bIncludeCopies )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::GetListItem( %d )"),iIndex));

    CAutoCriticalSection lock(_csItems);

    if (iIndex == -1)
    {
        return NULL;
    }

    if (_hdpaItems)
    {
        if (bIncludeCopies)
        {
            if ((iIndex >= 0) && (iIndex < DPA_GetPtrCount(_hdpaItems)))
            {
                return (CListItem *)DPA_FastGetPtr(_hdpaItems,iIndex);
            }
        }
        else
        {
            //
            // If we're not including copies, then we need to walk the
            // whole list to find root items only.  This is much slower,
            // but will always find root items only.
            //

            CListItem * pListItem = NULL;
            INT iRootIndex = 0;
            for (INT i = 0; i < DPA_GetPtrCount(_hdpaItems); i++)
            {
                pListItem = (CListItem *)DPA_FastGetPtr(_hdpaItems,i);

                if (pListItem && (!pListItem->IsCopyItem()))
                {
                    if (iIndex == iRootIndex)
                    {
                        return pListItem;
                    }
                    else
                    {
                        iRootIndex++;
                    }
                }
            }
        }
    }

    return NULL;

}


/*****************************************************************************

   CWizardInfoBlob::GetTemplateByIndex

   Gets a template given the index

 *****************************************************************************/

HRESULT CWizardInfoBlob::GetTemplateByIndex(INT iIndex, CTemplateInfo ** ppTemplateInfo )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::GetTemplateByIndex( iIndex = %d )"),iIndex));

    if (ppTemplateInfo)
    {
        return _templates.GetTemplate( iIndex, ppTemplateInfo );
    }

    return E_INVALIDARG;
}


/*****************************************************************************

    CWizardInfoBlob::TemplateGetPreviewBitmap

    returns S_OK on sucess or COM error otherwise

 *****************************************************************************/

HRESULT CWizardInfoBlob::TemplateGetPreviewBitmap(INT iIndex, const SIZE &sizeDesired, HBITMAP *phBmp)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::TemplateGetPreviewBitmap( iIndex = %d )"),iIndex));

    HRESULT           hr        = E_INVALIDARG;
    IStream         * pStream   = NULL;
    Gdiplus::Bitmap * pBmp      = NULL;
    CTemplateInfo   * pTemplate = NULL;


    hr = _templates.GetTemplate( iIndex, &pTemplate );
    WIA_CHECK_HR(hr,"_templates.GetTemplate()");

    if (SUCCEEDED(hr) && pTemplate)
    {
        hr = pTemplate->GetPreviewImageStream( &pStream );
        WIA_CHECK_HR(hr,"pTemplate->GetPreviewImageStream( &pStream )");

        if (SUCCEEDED(hr) && pStream)
        {
                                            // 48             62
            hr = LoadAndScaleBmp(pStream, sizeDesired.cx, sizeDesired.cy, &pBmp);
            WIA_CHECK_HR(hr,"LoadAndScaleBmp( pStream, size.cx, size.cy, pBmp )");

            if (SUCCEEDED(hr) && pBmp)
            {
                DWORD dw = GetSysColor(COLOR_WINDOW);
                Gdiplus::Color wndClr(255, GetRValue(dw), GetGValue(dw), GetBValue(dw));
                hr = Gdiplus2HRESULT(pBmp->GetHBITMAP(wndClr, phBmp));
                WIA_CHECK_HR(hr,"pBmp->GetHBITMAP( phBmp )");
                delete pBmp;
            }

            pStream->Release();
        }
    }

    WIA_RETURN_HR(hr);
}


/*****************************************************************************

   CWizardInfoBlob::SetPrinterToUse

   Sets the name of the printer to use to print...

 *****************************************************************************/

HRESULT CWizardInfoBlob::SetPrinterToUse( LPCTSTR pszPrinterName )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::SetPrinterToUse( '%s' )"),pszPrinterName ? pszPrinterName : TEXT("NULL POINTER!")));

    if (!pszPrinterName || !(*pszPrinterName))
    {
        WIA_RETURN_HR( E_INVALIDARG );
    }

    _strPrinterName = pszPrinterName;

    return S_OK;

}

/*****************************************************************************

   CWizardInfoBlob::SetDevModeToUse

   Sets the DEVMODE pointer to use to print...

 *****************************************************************************/

HRESULT CWizardInfoBlob::SetDevModeToUse( PDEVMODE pDevMode )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::SetDevModeToUse(0x%x)"),pDevMode));

    HRESULT hr = E_INVALIDARG;

    if (_hDevMode)
    {
        delete [] _hDevMode;
        _hDevMode = NULL;
    }

    if (pDevMode)
    {
        UINT cbDevMode = (UINT)pDevMode->dmSize + (UINT)pDevMode->dmDriverExtra;

        if( _hDevMode = (PDEVMODE) new BYTE[cbDevMode] )
        {
            WIA_TRACE((TEXT("CWizardInfoBlob::SetDevModeToUse - copying pDevMode(0x%x) to _hDevMode(0x%x)"),pDevMode,_hDevMode));
            CopyMemory( _hDevMode, pDevMode, cbDevMode );
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }


    WIA_RETURN_HR(hr);

}


/*****************************************************************************

   CWizardInfoBlob::GetDevModeToUse

   Retrieves the devmode pointer to use

 *****************************************************************************/

PDEVMODE CWizardInfoBlob::GetDevModeToUse()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::GetDevModeToUse()")));

    return _hDevMode;
}


/*****************************************************************************

   CWizardInfoBlob::GetPrinterToUse

   Returns the string that represent which printer to print to...

 *****************************************************************************/

LPCTSTR CWizardInfoBlob::GetPrinterToUse()
{
    if (_strPrinterName.Length())
    {

        WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::GetPrinterToUse( returning: '%s' )"),_strPrinterName.String()));
        return _strPrinterName.String();
    }

    return NULL;
}



/*****************************************************************************

   CWizardInfoBlob::ConstructPrintToTemplate

   When the wizard is invoked for "PrintTo" functionatlity, construct
   a template that represents full page

 *****************************************************************************/

VOID CWizardInfoBlob::ConstructPrintToTemplate()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_PRINTTO, TEXT("CWizardInfoBlob::ConstructPrintToTemplate()")));

    //
    // creates 1 template that is full page print...
    //

    _templates.InitForPrintTo();

}



/*****************************************************************************

   CWizardInfoBlob::GetCountOfPrintedPages

   Returns the number of pages that will be printed with the specified
   template.

 *****************************************************************************/

HRESULT CWizardInfoBlob::GetCountOfPrintedPages( INT iTemplateIndex, INT * pPageCount )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::GetCountOfPrintedPages( iTemplateIndex = %d )"),iTemplateIndex));
    HRESULT hr = E_FAIL;

    //
    // Check for bad params...
    //

    if ( !pPageCount ||
         ((iTemplateIndex < 0) || (iTemplateIndex >= _templates.Count()))
        )
    {
        WIA_RETURN_HR( E_INVALIDARG );
    }

    //
    // Get template in question...
    //

    CTemplateInfo * pTemplate = NULL;
    hr = _templates.GetTemplate( iTemplateIndex, &pTemplate );

    if (SUCCEEDED(hr) && pTemplate)
    {
        //
        // Is this a template that wants to repeat photos?
        //

        BOOL bRepeat = FALSE;
        hr = pTemplate->GetRepeatPhotos( &bRepeat );

        if (SUCCEEDED(hr))
        {
            //
            // Get the count
            //

            if (!bRepeat)
            {
                INT iPhotosPerTemplate = pTemplate->PhotosPerPage();
                INT iCountOfPhotos     = CountOfSelectedPhotos(TRUE);
                INT PagesRequired      = iCountOfPhotos / iPhotosPerTemplate;

                if (iCountOfPhotos % iPhotosPerTemplate)
                {
                    PagesRequired++;
                }

                *pPageCount = PagesRequired;
            }
            else
            {
                *pPageCount = CountOfSelectedPhotos(TRUE);
            }

        }

    }

    WIA_RETURN_HR(hr);
}



/*****************************************************************************

   CWizardInfoBlob::SetPreviewWnd

   Stores the hwnd that is the preview and also calculates the center of
   the window so all resizes will keep it in the right place in the window.

 *****************************************************************************/

VOID CWizardInfoBlob::SetPreviewWnd( HWND hwnd )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::SetPreviewWnd( hwnd = 0x%x )"),hwnd));

    if (hwnd)
    {
        _hwndPreview = hwnd;

        GetClientRect( _hwndPreview, &_rcInitSize );
        MapWindowPoints( _hwndPreview, GetParent(_hwndPreview), (LPPOINT)&_rcInitSize, 2 );

        //
        // Find center of window
        //

        _Center.cx = MulDiv(_rcInitSize.right  - _rcInitSize.left, 1, 2) + _rcInitSize.left;
        _Center.cy = MulDiv(_rcInitSize.bottom - _rcInitSize.top,  1, 2) + _rcInitSize.top;

    }

}


/*****************************************************************************

   CWizardInfoBlob::GetIntroFont

   Creates a font to be used for the intro text in the wizard...

 *****************************************************************************/

HFONT CWizardInfoBlob::GetIntroFont(HWND hwnd)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::GetIntroFont()")));

    if ( !_hfontIntro )
    {
        TCHAR szBuffer[64];
        NONCLIENTMETRICS ncm = { 0 };
        LOGFONT lf;

        ncm.cbSize = SIZEOF(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

        lf = ncm.lfMessageFont;
        LoadString(g_hInst, IDS_TITLEFONTNAME, lf.lfFaceName, ARRAYSIZE(lf.lfFaceName));
        lf.lfWeight = FW_BOLD;

        LoadString(g_hInst, IDS_TITLEFONTSIZE, szBuffer, ARRAYSIZE(szBuffer));
        lf.lfHeight = 0 - (GetDeviceCaps(NULL, LOGPIXELSY) * StrToInt(szBuffer) / 72);

        _hfontIntro = CreateFontIndirect(&lf);
    }

    return _hfontIntro;
}



/*****************************************************************************

   CWizardInfoBlob::UpdateCachedPrinterInfo

   Update some cached information about the printer...

 *****************************************************************************/

VOID CWizardInfoBlob::UpdateCachedPrinterInfo()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::UpdateCachedPrinterInfo()")));

    CAutoCriticalSection lock(_csPrinterInfo);

    BOOL bDeleteDC = FALSE;
    HDC  hDC       = GetCachedPrinterDC();

    if (!hDC)
    {
        //
        // For some reason, we don't have a stored DC.  So, we need to create
        // one so that we can get the info...
        //

        hDC = CreateDC( TEXT("WINSPOOL"), GetPrinterToUse(), NULL, GetDevModeToUse() );
        bDeleteDC = TRUE;
    }

    if (hDC)
    {
        //
        // Get DPI information
        //

        _WizPrinterInfo.DPI.cx =  GetDeviceCaps( hDC, LOGPIXELSX );
        _WizPrinterInfo.DPI.cy = GetDeviceCaps( hDC, LOGPIXELSY );

        //
        // Get size of printable area...
        //

        _WizPrinterInfo.rcDevice.left   = 0;
        _WizPrinterInfo.rcDevice.right  = GetDeviceCaps( hDC, HORZRES );
        _WizPrinterInfo.rcDevice.top    = 0;
        _WizPrinterInfo.rcDevice.bottom = GetDeviceCaps( hDC, VERTRES );

        //
        // Get physical size of printer's page
        //

        _WizPrinterInfo.PhysicalSize.cx = GetDeviceCaps( hDC, PHYSICALWIDTH );
        _WizPrinterInfo.PhysicalSize.cy = GetDeviceCaps( hDC, PHYSICALHEIGHT );

        //
        // Get physical offset to printable area
        //

        _WizPrinterInfo.PhysicalOffset.cx = GetDeviceCaps( hDC, PHYSICALOFFSETX );
        _WizPrinterInfo.PhysicalOffset.cy = GetDeviceCaps( hDC, PHYSICALOFFSETY );

        //
        // Say that we've got valid information now...
        //

        _WizPrinterInfo.bValid = TRUE;
    }

    if (bDeleteDC)
    {
        if (hDC)
        {
            DeleteDC( hDC );
        }
    }

}


/*****************************************************************************

   CWizardInfoBlob::SetNumberOfCopies

   When the number of copies of each pictures changes, do the work
   here...

 *****************************************************************************/

VOID CWizardInfoBlob::SetNumberOfCopies( UINT uCopies )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::SetNumberOfCopies( %d )"),uCopies));

    //
    // We really want to do this on a background thread, so queue up a message
    // to the only background thread we control -- the GDI+ startup & shutdown
    // thread.  We'll overload here to handle this task...
    //

    if (_dwGdiPlusThreadId)
    {
        PostThreadMessage( _dwGdiPlusThreadId, WIZ_MSG_COPIES_CHANGED, (WPARAM)uCopies, 0 );
    }
}


/*****************************************************************************

   _SetupDimensionsForPrinting

   Computes all relevant information to printing to a page.

 *****************************************************************************/

VOID CWizardInfoBlob::_SetupDimensionsForPrinting( HDC hDC, CTemplateInfo * pTemplate, RENDER_DIMENSIONS * pDim )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::_SetupDimensionsForPrinting()")));

    if (!pDim)
    {
        WIA_ERROR((TEXT("Printer: pDim is NULL!")));
        return;
    }

    if (!pTemplate)
    {
        WIA_ERROR((TEXT("Printer: pTemplate is NULL!")));
    }

    //
    // Make sure we have good values in the cached printer info structure
    //

    GetCachedPrinterInfo();

    //
    // Flush out old values...
    //

    ZeroMemory( pDim, sizeof(RENDER_DIMENSIONS) );

    //
    // Derive multiplier for horizontal & vertical measurements
    // (NOMINAL --> printer), and compute rcDevice which is
    // the printable area available (in device units -- pixels).
    //

    pDim->DPI = _WizPrinterInfo.DPI;
    WIA_TRACE((TEXT("Printer: xDPI = %d, yDPI = %d"),pDim->DPI.cx,pDim->DPI.cy));

    pDim->rcDevice = _WizPrinterInfo.rcDevice;
    WIA_TRACE((TEXT("Printer: rcDevice( %d, %d, %d, %d )"),pDim->rcDevice.left, pDim->rcDevice.top, pDim->rcDevice.right, pDim->rcDevice.bottom ));

    //
    // Convert device coords into 1/10000 inch equivalents
    //

    pDim->NominalDevicePrintArea.cx = (INT)((DOUBLE)(((DOUBLE)pDim->rcDevice.right  / (DOUBLE)pDim->DPI.cx) * (DOUBLE)NOMINAL_MULTIPLIER));
    pDim->NominalDevicePrintArea.cy = (INT)((DOUBLE)(((DOUBLE)pDim->rcDevice.bottom / (DOUBLE)pDim->DPI.cy) * (DOUBLE)NOMINAL_MULTIPLIER));

    WIA_TRACE((TEXT("Printer: DeviceNominal ( %d, %d )"),pDim->NominalDevicePrintArea.cx,pDim->NominalDevicePrintArea.cy));

    //
    // Get physical page size (in nominal coords)
    //

    pDim->NominalPhysicalSize.cx = (INT)((DOUBLE)(((DOUBLE)_WizPrinterInfo.PhysicalSize.cx / (DOUBLE)pDim->DPI.cx) * (DOUBLE)NOMINAL_MULTIPLIER));
    pDim->NominalPhysicalSize.cy = (INT)((DOUBLE)(((DOUBLE)_WizPrinterInfo.PhysicalSize.cy / (DOUBLE)pDim->DPI.cy) * (DOUBLE)NOMINAL_MULTIPLIER));

    WIA_TRACE((TEXT("Printer: NominalPhysicalSize (%d, %d)"),pDim->NominalPhysicalSize.cx,pDim->NominalPhysicalSize.cy));

    //
    // Get physical offset to printable area (in nominal coords)
    //

    pDim->NominalPhysicalOffset.cx = (INT)((DOUBLE)(((DOUBLE)_WizPrinterInfo.PhysicalOffset.cx / (DOUBLE)pDim->DPI.cx) * (DOUBLE)NOMINAL_MULTIPLIER));
    pDim->NominalPhysicalOffset.cy = (INT)((DOUBLE)(((DOUBLE)_WizPrinterInfo.PhysicalOffset.cy / (DOUBLE)pDim->DPI.cx) * (DOUBLE)NOMINAL_MULTIPLIER));

    WIA_TRACE((TEXT("Printer: NominalPhyscialOffset (%d, %d)"),pDim->NominalPhysicalOffset.cx,pDim->NominalPhysicalOffset.cy));

    //
    // Compute offset that will center the template in the printable
    // area.  Note, this can be a negative number if the paper size
    // selected is too small to contain the template.
    //

    if (SUCCEEDED(pTemplate->GetNominalRectForImageableArea( &pDim->rcNominalTemplatePrintArea )))
    {
        if ((-1 == pDim->rcNominalTemplatePrintArea.left)   &&
            (-1 == pDim->rcNominalTemplatePrintArea.right)  &&
            (-1 == pDim->rcNominalTemplatePrintArea.top)    &&
            (-1 == pDim->rcNominalTemplatePrintArea.bottom))
        {
            WIA_TRACE((TEXT("Printer: NominalTemplateArea( use full printable area )")));

            pDim->NominalPageOffset.cx = 0;
            pDim->NominalPageOffset.cy = 0;
        }
        else
        {
            WIA_TRACE((TEXT("Printer: NominalTemplateArea(%d, %d)"),pDim->rcNominalTemplatePrintArea.right - pDim->rcNominalTemplatePrintArea.left,pDim->rcNominalTemplatePrintArea.bottom - pDim->rcNominalTemplatePrintArea.top));

            pDim->NominalPageOffset.cx = (pDim->NominalDevicePrintArea.cx - (pDim->rcNominalTemplatePrintArea.right  - pDim->rcNominalTemplatePrintArea.left)) / 2;
            pDim->NominalPageOffset.cy = (pDim->NominalDevicePrintArea.cy - (pDim->rcNominalTemplatePrintArea.bottom - pDim->rcNominalTemplatePrintArea.top))  / 2;
        }


    }

    WIA_TRACE((TEXT("Printer: NominalPageOffset(%d, %d)"),pDim->NominalPageOffset.cx,pDim->NominalPageOffset.cy));

    //
    // Compute clip rectangle for printable area on physical page (nominal coords)
    //

    pDim->rcNominalPageClip.left    = pDim->NominalPhysicalOffset.cx;
    pDim->rcNominalPageClip.top     = pDim->NominalPhysicalOffset.cy;
    pDim->rcNominalPageClip.right   = pDim->rcNominalPageClip.left + pDim->NominalDevicePrintArea.cx;
    pDim->rcNominalPageClip.bottom  = pDim->rcNominalPageClip.top  + pDim->NominalDevicePrintArea.cy;

    WIA_TRACE((TEXT("Printer: rcNominalPageClip is (%d, %d, %d, %d)"), pDim->rcNominalPageClip.left, pDim->rcNominalPageClip.top, pDim->rcNominalPageClip.right, pDim->rcNominalPageClip.bottom ));

}



/*****************************************************************************

   _SetupDimensionsForScreen

   Computes all relevant information for drawing to the screen.

 *****************************************************************************/

VOID CWizardInfoBlob::_SetupDimensionsForScreen( CTemplateInfo * pTemplate, HWND hwndScreen, RENDER_DIMENSIONS * pDim )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::_SetupDimensionsForScreen()")));

    if (!pDim)
    {
        WIA_ERROR((TEXT("Screen: pDim is NULL!")));
        return;
    }


    //
    // Before we do anything, check to see if we're in Portrait or Landscape
    // and rotate the template accordingly...
    //

    PDEVMODE pDevMode = GetDevModeToUse();
    if (pDevMode)
    {
        if (pDevMode->dmFields & DM_ORIENTATION)
        {
            if (pDevMode->dmOrientation == DMORIENT_PORTRAIT)
            {
                pTemplate->RotateForPortrait();
            }
            else if (pDevMode->dmOrientation == DMORIENT_LANDSCAPE)
            {
                pTemplate->RotateForLandscape();
            }
        }
    }


    _SetupDimensionsForPrinting( GetCachedPrinterDC(), pTemplate, pDim );

    //
    // Flush out old values, except for NominalPhysicalSize and
    // NominalPhysicalOffset and NominalPageOffset which we want to keep...
    //

    pDim->rcDevice.left              = 0;
    pDim->rcDevice.top               = 0;
    pDim->rcDevice.right             = 0;
    pDim->rcDevice.bottom            = 0;
    pDim->DPI.cx                     = 0;
    pDim->DPI.cy                     = 0;

    RECT rcWnd = _rcInitSize;
    WIA_TRACE((TEXT("Screen: _rcInitSize was (%d, %d, %d, %d)"),_rcInitSize.left,_rcInitSize.top,_rcInitSize.right,_rcInitSize.bottom));

    //
    // Get span of window to contain preview...
    //

    INT wScreen = rcWnd.right  - rcWnd.left;
    INT hScreen = rcWnd.bottom - rcWnd.top;
    WIA_TRACE((TEXT("Screen: w = %d, h = %d"),wScreen,hScreen));

    //
    // Get DPI of screen
    //

    HDC hDC = GetDC( hwndScreen );
    if (hDC)
    {
        pDim->DPI.cx = GetDeviceCaps( hDC, LOGPIXELSX );
        pDim->DPI.cy = GetDeviceCaps( hDC, LOGPIXELSY );

        ReleaseDC( hwndScreen, hDC );
    }

    //
    // Scale printable area into window
    //

    SIZE sizePreview;
    sizePreview = PrintScanUtil::ScalePreserveAspectRatio( wScreen, hScreen, pDim->NominalPhysicalSize.cx, pDim->NominalPhysicalSize.cy );

    WIA_TRACE((TEXT("Screen: scaled print page is (%d, %d)"),sizePreview.cx,sizePreview.cy));

    rcWnd.left      = _rcInitSize.left;
    rcWnd.top       = _Center.cy - (sizePreview.cy / 2);
    rcWnd.right     = rcWnd.left + sizePreview.cx;
    rcWnd.bottom    = rcWnd.top  + sizePreview.cy;

    //
    // Now change window size to be preview size...
    //

    WIA_TRACE((TEXT("Screen: moving window to (%d, %d) with size (%d, %d)"),rcWnd.left,rcWnd.top,sizePreview.cx,sizePreview.cy));
    MoveWindow( hwndScreen, rcWnd.left, rcWnd.top, sizePreview.cx, sizePreview.cy, TRUE );

}


/*****************************************************************************

   CWizardInfoBlob::_RenderFilenameOfPhoto

   Draws the filename of the photo underneath the photo

 *****************************************************************************/

VOID CWizardInfoBlob::_RenderFilenameOfPhoto( Gdiplus::Graphics * g, RECT * pPhotoDest, CListItem * pPhoto )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::_RenderFilenameOfPhoto()")));

    //
    // check for bad params
    //

    if (!pPhotoDest || !g || !pPhoto)
    {
        return;
    }

    //
    // the rectangle for the filename is the width of the photo & 2 text lines high, with a
    // .05" gap from the bottom of the photo.  All measurements are in nominal
    // sizes, which means 1/10000 of an inch.
    //


    Gdiplus::Font font( L"arial", (Gdiplus::REAL)1100.0, Gdiplus::FontStyleRegular, Gdiplus::UnitWorld, NULL );
    WIA_TRACE((TEXT("_RenderFilenameOfPhoto: height = %d pixels, emSize = %d"),(INT)font.GetHeight((Gdiplus::Graphics *)NULL), (INT)font.GetSize()));

    Gdiplus::RectF rectText( (Gdiplus::REAL)pPhotoDest->left,
                             (Gdiplus::REAL)(pPhotoDest->bottom + 500),
                             (Gdiplus::REAL)(pPhotoDest->right - pPhotoDest->left),
                             (Gdiplus::REAL)font.GetHeight((Gdiplus::Graphics *)NULL) * (Gdiplus::REAL)2.0);



    //Gdiplus::StringFormat sf( Gdiplus::StringFormatFlagsLineLimit );
    Gdiplus::StringFormat sf( 0 );
    sf.SetTrimming( Gdiplus::StringTrimmingEllipsisCharacter );
    sf.SetAlignment( Gdiplus::StringAlignmentCenter );

    CSimpleStringWide * pFilename = pPhoto->GetFilename();

    if (pFilename)
    {
        WIA_TRACE((TEXT("_RenderFilenameOfPhoto: <%s> in (%d x %d) at (%d,%d), fontsize=%d"),CSimpleStringConvert::NaturalString(*pFilename).String(),(INT)rectText.Width,(INT)rectText.Height,(INT)rectText.X,(INT)rectText.Y,font.GetSize()));
        g->DrawString( pFilename->String(), pFilename->Length(), &font, rectText, &sf, &Gdiplus::SolidBrush( Gdiplus::Color::Black ) );

        delete pFilename;
    }


}





/*****************************************************************************

   CWizardInfoBlob::RenderPrintedPage

   Draws photos to the printer according to which layout, which page and the
   given printer hDC.

 *****************************************************************************/

HRESULT CWizardInfoBlob::RenderPrintedPage( INT iTemplateIndex, INT iPage, HDC hDC, HWND hwndProgress, float fProgressStep, float * pPercent )
{

    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::RenderPrintedPage( iPage = %d, iTemplateIndex = %d, hwndProgress = 0x%x )"),iPage,iTemplateIndex,hwndProgress));

    HRESULT hr = S_OK;
    RENDER_OPTIONS ro = {0};

    //
    // Check for bad params...
    //

    if ( (!hDC) ||
         ((iTemplateIndex < 0) || (iTemplateIndex >= _templates.Count()))
        )
    {
        WIA_RETURN_HR( E_INVALIDARG );
    }

    //
    // Get the template in question...
    //

    CTemplateInfo * pTemplate = NULL;
    hr = _templates.GetTemplate( iTemplateIndex, &pTemplate );

    if (FAILED(hr))
    {
        WIA_RETURN_HR(hr);
    }

    if (!pTemplate)
    {
        WIA_RETURN_HR(E_OUTOFMEMORY);
    }


    UINT uFlagsOrientation = 0;
    //
    // Before we do anything, check to see if we're in Portrait or Landscape
    // and rotate the template accordingly...
    //

    PDEVMODE pDevMode = GetDevModeToUse();
    if (pDevMode)
    {
        if (pDevMode->dmFields & DM_ORIENTATION)
        {
            if (pDevMode->dmOrientation == DMORIENT_PORTRAIT)
            {
                pTemplate->RotateForPortrait();
            }
            else if (pDevMode->dmOrientation == DMORIENT_LANDSCAPE)
            {
                pTemplate->RotateForLandscape();
                ro.Flags = RF_ROTATE_270;
            }
        }
    }

    //
    // Is this a template that repeats photos?
    //

    BOOL bRepeat = FALSE;
    pTemplate->GetRepeatPhotos( &bRepeat );

    //
    // Does this template want the filenames printed out under each photo?
    //

    BOOL bPrintFilename = FALSE;
    pTemplate->GetPrintFilename( &bPrintFilename );

    //
    // Do we have any photos to print for this page?
    //

    INT iPhotosPerTemplate = pTemplate->PhotosPerPage();
    INT iCountOfPhotos     = CountOfSelectedPhotos(TRUE);

    if ( (iPhotosPerTemplate == 0) ||
         (iCountOfPhotos     == 0) ||
         ( (!bRepeat) && ((iCountOfPhotos - (iPage * iPhotosPerTemplate)) <= 0) )
        )
    {
        WIA_RETURN_HR( S_FALSE );
    }


    //
    // Get a handle to the printer we are going to use...
    //

    HANDLE hPrinter = NULL;
    OpenPrinter( (LPTSTR)GetPrinterToUse(), &hPrinter, NULL );

    //
    // Compute the dimensions of the drawable area...
    //

    _SetupDimensionsForPrinting( hDC, pTemplate, &ro.Dim );

    //
    // Get index of photo to start with...
    //

    INT iPhoto;

    if (!bRepeat)
    {
        iPhoto = iPage * iPhotosPerTemplate;
    }
    else
    {
        iPhoto = iPage;
    }


    //
    // We always do scale to fit
    //

    ro.Flags |= RF_SCALE_TO_FIT;


    //
    // Get the control flags from the template...
    //

    BOOL bCanRotate = TRUE;
    pTemplate->GetCanRotate( &bCanRotate );
    if (bCanRotate)
    {
        ro.Flags |= RF_ROTATE_AS_NEEDED;
    }

    BOOL bCanCrop = TRUE;
    pTemplate->GetCanCrop( &bCanCrop );
    if (bCanCrop)
    {
        ro.Flags |= RF_CROP_TO_FIT;
    }

    BOOL bUseThumbnails = FALSE;
    pTemplate->GetUseThumbnailsToPrint( &bUseThumbnails );
    if (bUseThumbnails)
    {
        ro.Flags |= RF_USE_MEDIUM_QUALITY_DATA;
    }
    else
    {
        ro.Flags |= RF_USE_FULL_IMAGE_DATA;
    }

    //
    // If we're in no UI mode, then don't fail if we can't rotate...
    //


    WIA_TRACE((TEXT("RenderPrintedPage: _bShowUI is 0x%x"),_bShowUI));
    if (!_bShowUI)
    {
        ro.Flags |= RF_NO_ERRORS_ON_FAILURE_TO_ROTATE;
        WIA_TRACE((TEXT("RenderPrintedPage: uFlags set to have RF_NO_ERRORS_ON_FAILURE (0x%x)"),ro.Flags));
    }

    //
    // Compute offset to use...
    //

    INT xOffset = ro.Dim.NominalPageOffset.cx;
    INT yOffset = ro.Dim.NominalPageOffset.cy;


    //
    // Set up GDI+ for printing...
    //

    Gdiplus::Graphics g( hDC, hPrinter );
    hr = Gdiplus2HRESULT(g.GetLastStatus());

    if (SUCCEEDED(hr))
    {
        //
        // First, set up coordinates / transform
        //

        g.SetPageUnit( Gdiplus::UnitPixel );
        hr = Gdiplus2HRESULT(g.GetLastStatus());

        if (SUCCEEDED(hr))
        {
            g.SetPageScale( 1.0 );
            hr = Gdiplus2HRESULT(g.GetLastStatus());

            if (SUCCEEDED(hr))
            {
                //
                // Set up transform so that we can draw in nominal
                // template coordinates from here on out...
                //

                Gdiplus::Rect rectDevice( ro.Dim.rcDevice.left, ro.Dim.rcDevice.top, (ro.Dim.rcDevice.right - ro.Dim.rcDevice.left), (ro.Dim.rcDevice.bottom - ro.Dim.rcDevice.top) );

                WIA_TRACE((TEXT("RenderPrintedPage: rectDevice    is (%d, %d) with size (%d, %d)"),rectDevice.X,rectDevice.Y,rectDevice.Width,rectDevice.Height));
                WIA_TRACE((TEXT("RenderPrintedPage: NominalDevicePrintArea is (%d, %d)"),ro.Dim.NominalDevicePrintArea.cx,ro.Dim.NominalDevicePrintArea.cy));

                DOUBLE xScale = (DOUBLE)((DOUBLE)rectDevice.Width / (DOUBLE)ro.Dim.NominalDevicePrintArea.cx);
                DOUBLE yScale = (DOUBLE)((DOUBLE)rectDevice.Height / (DOUBLE)ro.Dim.NominalDevicePrintArea.cy);

                g.ScaleTransform( (Gdiplus::REAL) xScale, (Gdiplus::REAL) yScale );
                hr = Gdiplus2HRESULT(g.GetLastStatus());

                if (SUCCEEDED(hr))
                {
                    #ifdef PRINT_BORDER_AROUND_PRINTABLE_AREA
                    Gdiplus::Rect rectPrintableArea( 0, 0, ro.Dim.NominalPrintArea.cx, ro.Dim.NominalPrintArea.cy );
                    Gdiplus::Color black(255,0,0,0);
                    Gdiplus::SolidBrush BlackBrush( black );
                    Gdiplus::Pen BlackPen( &BlackBrush, (Gdiplus::REAL)1.0 );
                    WIA_TRACE((TEXT("RenderPrintedPage: rectPrintableArea is (%d, %d) @ (%d, %d)"),rectPrintableArea.Width,rectPrintableArea.Height,rectPrintableArea.X,rectPrintableArea.Y));

                    g.DrawRectangle( &BlackPen, rectPrintableArea );
                    #endif


                    //
                    // Now loop through each image in the template, and draw it...
                    //

                    RECT            rcNominal;
                    CListItem *     pPhoto = NULL;;
                    INT             iPhotoIndex = 0;
                    INT             iPhotoIndexNext = 0;

                    //
                    // Get starting photo index...
                    //

                    for (INT i = iPhoto; i > 0; i--)
                    {
                        iPhotoIndex = GetIndexOfNextPrintableItem( iPhotoIndex );
                        iPhotoIndex++;
                    }

                    INT iRes = IDCONTINUE;
                    for (INT i = 0; (!IsWizardShuttingDown()) && (iRes == IDCONTINUE) && (i < iPhotosPerTemplate); i++)
                    {
                        if (SUCCEEDED(pTemplate->GetNominalRectForPhoto(i, &rcNominal)))
                        {
                            if ((-1 == rcNominal.left)  &&
                                (-1 == rcNominal.right) &&
                                (-1 == rcNominal.top)   &&
                                (-1 == rcNominal.bottom))
                            {
                                WIA_TRACE((TEXT("RenderPrintedPage: rcNominal is -1,-1,-1,-1 -- scaling to full page")));

                                rcNominal.left = 0;
                                rcNominal.top  = 0;
                                rcNominal.right  = ro.Dim.NominalDevicePrintArea.cx;
                                rcNominal.bottom = ro.Dim.NominalDevicePrintArea.cy;

                                WIA_TRACE((TEXT("RenderPrintedPage: rcNominal(%d) is ( %d, %d, %d, %d )"),i,rcNominal.left, rcNominal.top, rcNominal.right, rcNominal.bottom ));

                            }
                            else
                            {
                                WIA_TRACE((TEXT("RenderPrintedPage: rcNominal(%d) is ( %d, %d, %d, %d )"),i,rcNominal.left, rcNominal.top, rcNominal.right, rcNominal.bottom ));

                                rcNominal.left   += xOffset;
                                rcNominal.right  += xOffset;
                                rcNominal.top    += yOffset;
                                rcNominal.bottom += yOffset;
                            }

                            //
                            // Get the photo object
                            //

                            if (!bRepeat)
                            {
                                iPhotoIndex = GetIndexOfNextPrintableItem( iPhotoIndex );
                            }

                            if ((!IsWizardShuttingDown()) && (iPhotoIndex != -1))
                            {
                                pPhoto = GetListItem( iPhotoIndex, TRUE );

                                if (pPhoto)
                                {
                                    //
                                    // Set up destination rectangle to draw into
                                    //

                                    Gdiplus::Rect dest( rcNominal.left, rcNominal.top, rcNominal.right - rcNominal.left, rcNominal.bottom - rcNominal.top );
                                    WIA_TRACE((TEXT("RenderPrintedPage: rcPhotoDest(%d) is (%d x %d) a (%d, %d)"),i, dest.Width, dest.Height, dest.X, dest.Y ));

                                    //
                                    // supply the graphic objects to use...
                                    //

                                    ro.g     = &g;
                                    ro.pDest = &dest;

                                    do
                                    {
                                        //
                                        // This variable will be set to TRUE in status.cpp if the user cancels the
                                        // print job.
                                        //
                                        extern BOOL g_bCancelPrintJob;

                                        //
                                        // Draw the image!
                                        //

                                        hr = pPhoto->Render( &ro );

                                        //
                                        // Check to see if we've been cancelled.
                                        // If we have, we are going to break out
                                        // before displaying any errors.
                                        //
                                        if (g_bCancelPrintJob)
                                        {
                                            iRes = IDCANCEL;
                                            break;
                                        }

                                        if (FAILED(hr))
                                        {
                                            iRes = ShowError( NULL, hr, 0, TRUE, pPhoto->GetPIDL() );

                                            if (iRes == IDCONTINUE)
                                            {
                                                hr = S_FALSE;
                                            }
                                        }
                                        else
                                        {
                                            iRes = IDCONTINUE;
                                        }


                                    } while ( iRes == IDTRYAGAIN );

                                    //
                                    // Print the filename if warranted
                                    //

                                    if (bPrintFilename)
                                    {
                                        _RenderFilenameOfPhoto( &g, &rcNominal, pPhoto );
                                    }

                                    //
                                    // Update the percentage complete if needed
                                    //

                                    if (pPercent)
                                    {
                                        *pPercent += (float)(fProgressStep / (float)iPhotosPerTemplate);


                                        if (hwndProgress)
                                        {
                                            INT iPercent = (INT)(*pPercent);

                                            WIA_TRACE((TEXT("RenderPrinterPage: iPercent = %d"),iPercent));
                                            PostMessage( hwndProgress, PBM_SETPOS, (WPARAM)iPercent, 0 );
                                        }
                                    }
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                    break;
                                }

                                if (!bRepeat)
                                {
                                    iPhotoIndex++;
                                }

                            }
                        }
                    }
                }
            }
        }

    }
    else
    {
        WIA_ERROR((TEXT("RenderPrintedPage: couldn't create graphics, hr = 0x%x"),hr));
    }

    if (hPrinter)
    {
        ClosePrinter( hPrinter );
    }

    WIA_RETURN_HR(hr);
}


/*****************************************************************************

   CWizardInfo::RenderPreview

   Given a template index and an HWND, sizes the HWND to be aspect correct
   for the chosen printer/paper, and then returns an HBITMAP of a preview
   for this template that will fit in the window.

 *****************************************************************************/

HBITMAP CWizardInfoBlob::RenderPreview( INT iTemplateIndex, HWND hwndScreen )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_WIZ_INFO_BLOB, TEXT("CWizardInfoBlob::RenderPreview( iTemplateIndex = %d )"),iTemplateIndex));

    HBITMAP hbmp = NULL;
    RENDER_OPTIONS ro = {0};

    if ((iTemplateIndex < 0) || (iTemplateIndex > _templates.Count()))
    {
        return NULL;
    }

    //
    // Get the correct template...
    //

    CTemplateInfo * pTemplate = NULL;

    HRESULT hr = _templates.GetTemplate( iTemplateIndex, &pTemplate );
    if (FAILED(hr) || (!pTemplate))
    {
        return NULL;
    }

    //
    // Tell the render engine we're rendering to the screen
    //

    ro.Flags |= RF_SET_QUALITY_FOR_SCREEN;

    //
    // Before we do anything, check to see if we're in Portrait or Landscape
    // and rotate the template accordingly...
    //

    PDEVMODE pDevMode = GetDevModeToUse();
    if (pDevMode)
    {
        if (pDevMode->dmFields & DM_ORIENTATION)
        {
            if (pDevMode->dmOrientation == DMORIENT_PORTRAIT)
            {
                pTemplate->RotateForPortrait();
            }
            else if (pDevMode->dmOrientation == DMORIENT_LANDSCAPE)
            {
                pTemplate->RotateForLandscape();
                ro.Flags |= RF_ROTATE_270;
            }
        }
    }

    //
    // Do we have any photos to print for this page?
    //

    INT iPhotosPerTemplate = pTemplate->PhotosPerPage();
    INT iCountOfPhotos     = CountOfSelectedPhotos(TRUE);

    //
    // Compute the dimensions of the drawable area...
    //

    _SetupDimensionsForScreen( pTemplate, hwndScreen, &ro.Dim );

    //
    // Does this template want the filenames printed out under each photo?
    //

    BOOL bPrintFilename = FALSE;
    pTemplate->GetPrintFilename( &bPrintFilename );

    //
    // Get the control flags from the template...
    //

    ro.Flags |= RF_SCALE_TO_FIT;

    BOOL bCanRotate = TRUE;
    pTemplate->GetCanRotate( &bCanRotate );
    if (bCanRotate)
    {
        ro.Flags |= RF_ROTATE_AS_NEEDED;
    }

    BOOL bCanCrop = TRUE;
    pTemplate->GetCanCrop( &bCanCrop );
    if (bCanCrop)
    {
        ro.Flags |= RF_CROP_TO_FIT;
    }

    //
    // Is this a template that repeats photos?
    //

    BOOL bRepeat = FALSE;
    pTemplate->GetRepeatPhotos( &bRepeat );

    //
    // Does the template use thumbnail data for printing?  Match that for display
    //

    BOOL bUseThumbnails = TRUE;
    pTemplate->GetUseThumbnailsToPrint( &bUseThumbnails );
    if (bUseThumbnails)
    {
        ro.Flags |= RF_USE_THUMBNAIL_DATA;
    }
    else
    {
        ro.Flags |= RF_USE_FULL_IMAGE_DATA;
    }

    //
    // Compute offset to use...
    //

    INT xOffset = ro.Dim.NominalPageOffset.cx + ro.Dim.NominalPhysicalOffset.cx;
    INT yOffset = ro.Dim.NominalPageOffset.cy + ro.Dim.NominalPhysicalOffset.cy;

    WIA_TRACE((TEXT("RenderPreview: Offset is (%d, %d)"),xOffset,yOffset));

    //
    // Get clip rectangle...
    //

    Gdiplus::Rect clip( ro.Dim.rcNominalPageClip.left,
                        ro.Dim.rcNominalPageClip.top,
                        ro.Dim.rcNominalPageClip.right  - ro.Dim.rcNominalPageClip.left,
                        ro.Dim.rcNominalPageClip.bottom - ro.Dim.rcNominalPageClip.top
                       );

    //
    // Get size of preview window
    //

    RECT rcWnd = {0};
    GetClientRect( hwndScreen, &ro.Dim.rcDevice );
    Gdiplus::Rect rectWindow( 0, 0, ro.Dim.rcDevice.right - ro.Dim.rcDevice.left, ro.Dim.rcDevice.bottom - ro.Dim.rcDevice.top );
    ro.Dim.bDeviceIsScreen = TRUE;

    //
    // Need to create a new preview bitmap for this template...
    //

    BITMAPINFO BitmapInfo;
    ZeroMemory( &BitmapInfo, sizeof(BITMAPINFO) );
    BitmapInfo.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    BitmapInfo.bmiHeader.biWidth           = rectWindow.Width;
    BitmapInfo.bmiHeader.biHeight          = rectWindow.Height;
    BitmapInfo.bmiHeader.biPlanes          = 1;
    BitmapInfo.bmiHeader.biBitCount        = 24;
    BitmapInfo.bmiHeader.biCompression     = BI_RGB;

    //
    // Create the DIB section
    //
    PBYTE pBitmapData = NULL;
    HDC   hdc         = CreateCompatibleDC( NULL );

    hbmp = CreateDIBSection( hdc, &BitmapInfo, DIB_RGB_COLORS, (LPVOID*)&pBitmapData, NULL, 0 );

    if (hdc && hbmp)
    {
        //
        // Select the DIB section into the DC
        //

        SelectObject( hdc, hbmp );

        //
        // Create Graphics object around memory DC
        //

        Gdiplus::Graphics g( hdc );

        if (Gdiplus::Ok == g.GetLastStatus())
        {
            //
            // First, draw bounding rectangle
            //

            g.SetPageUnit( Gdiplus::UnitPixel );
            g.SetPageScale( 1.0 );

            Gdiplus::Color white(255,255,255,255);
            Gdiplus::SolidBrush WhiteBrush( white );

            //
            // Clear out the contents
            //

            g.FillRectangle( &WhiteBrush, rectWindow );

            //
            // Frame the outside
            //

            Gdiplus::Color OutsideColor(255,64,64,64);
            Gdiplus::Pen   OutsidePen( OutsideColor );

            rectWindow.Width--;
            rectWindow.Height--;

            g.DrawRectangle( &OutsidePen, rectWindow );

            //
            // Set up transform so that we can draw in nominal
            // template coordinates from here on out...
            //

            g.ScaleTransform( (Gdiplus::REAL)((DOUBLE)rectWindow.Width / (DOUBLE)ro.Dim.NominalPhysicalSize.cx), (Gdiplus::REAL)((DOUBLE)rectWindow.Height / (DOUBLE)ro.Dim.NominalPhysicalSize.cy) );

            //
            // Set clip rectangle...
            //

            //WIA_TRACE((TEXT("RenderPreview: setting clip rect to (%d, %d) with size (%d, %d)"),clip.X,clip.Y,clip.Width,clip.Height));
            //g.SetClip( clip, Gdiplus::CombineModeReplace );

            //
            // Now loop through each image in the template, and draw it...
            //

            RECT            rcNominal;
            INT             iPhotoIndex = 0;
            CListItem *     pPhoto      = NULL;

            if (bRepeat)
            {
                iPhotoIndex = GetIndexOfNextPrintableItem( 0 );
            }


            INT iRes = IDCONTINUE;
            hr       = S_OK;

            for (INT i = 0; (iRes == IDCONTINUE) && (!IsWizardShuttingDown()) && (i < iPhotosPerTemplate); i++)
            {

                if (SUCCEEDED(pTemplate->GetNominalRectForPhoto(i, &rcNominal)))
                {
                    if ((-1 == rcNominal.left)  &&
                        (-1 == rcNominal.right) &&
                        (-1 == rcNominal.top)   &&
                        (-1 == rcNominal.bottom))
                    {
                        WIA_TRACE((TEXT("RenderPreview: rcNominal is -1,-1,-1,-1 -- scaling to full page")));

                        rcNominal = ro.Dim.rcNominalPageClip;

                        WIA_TRACE((TEXT("RenderPreview: rcNominal(%d) is ( %d, %d, %d, %d )"),i,rcNominal.left, rcNominal.top, rcNominal.right, rcNominal.bottom ));

                    }
                    else
                    {
                        WIA_TRACE((TEXT("RenderPreview: rcNominal(%d) is ( %d, %d, %d, %d )"),i,rcNominal.left, rcNominal.top, rcNominal.right, rcNominal.bottom ));

                        rcNominal.left   += xOffset;
                        rcNominal.right  += xOffset;
                        rcNominal.top    += yOffset;
                        rcNominal.bottom += yOffset;

                    }

                    //
                    // Get the photo object
                    //

                    if (!bRepeat)
                    {
                        iPhotoIndex = GetIndexOfNextPrintableItem( iPhotoIndex );
                    }


                    if ((!IsWizardShuttingDown()) && (iPhotoIndex != -1))
                    {
                        pPhoto = GetListItem( iPhotoIndex, TRUE );

                        if (pPhoto)
                        {
                            //
                            // Set up the destination rectangle to draw into
                            //

                            Gdiplus::Rect dest( rcNominal.left, rcNominal.top, rcNominal.right - rcNominal.left, rcNominal.bottom - rcNominal.top );
                            WIA_TRACE((TEXT("RenderPreview: rcPhoto(%d) is (%d x %d) at (%d, %d)"),i, dest.Width, dest.Height, dest.X, dest.Y ));

                            //
                            // Supply the GDI/GDI+ objects to use...
                            //

                            ro.g        = &g;
                            ro.pDest    = &dest;

                            //
                            // Save the flags before trying to do throttling...
                            //

                            ULONG uFlagsSave = ro.Flags;

                            //
                            // throttle back to thumbnails if we're on a low-end system
                            // and it's a large file...
                            //

                            if (_bMinimumMemorySystem)
                            {
                                //
                                // We're on a low memory system...is this a
                                // large file?  We say anything over 1MB
                                // is large.
                                //

                                if (pPhoto->GetFileSize() > (LONGLONG)LARGE_IMAGE_SIZE)
                                {
                                    WIA_TRACE((TEXT("RenderPreview: throttling back to thumbnail data because not enough memory!")));

                                    //
                                    // Clear out old render quality flags
                                    //

                                    ro.Flags &= (~RF_QUALITY_FLAGS_MASK);
                                    ro.Flags |= RF_USE_THUMBNAIL_DATA;
                                }
                            }

                            //
                            // Is this a really large file?  We say anything
                            // greater than 5MB is really large
                            //

                            if (pPhoto->GetFileSize() > (LONGLONG)REALLY_LARGE_IMAGE_SIZE)
                            {
                                //
                                // Unless we have a really large memory
                                // system, then throttle back on this file
                                // and only show the thumbnail
                                //

                                if (!_bLargeMemorySystem)
                                {
                                    WIA_TRACE((TEXT("RenderPreview: throttling back to thumbnail data because of really large file!")));

                                    //
                                    // Clear out old render quality flags
                                    //

                                    ro.Flags &= (~RF_QUALITY_FLAGS_MASK);
                                    ro.Flags |= RF_USE_THUMBNAIL_DATA;
                                }
                            }

                            //
                            // Now that we have everything set up, try to draw the image...
                            //

                            do
                            {
                                //
                                // Draw the image!
                                //

                                hr = pPhoto->Render( &ro );

                                if (FAILED(hr))
                                {
                                    iRes = ShowError( NULL, hr, 0, TRUE, pPhoto->GetPIDL() );
                                    hr = S_FALSE;
                                }
                                else
                                {
                                    iRes = IDCONTINUE;
                                }

                            } while ( iRes == IDTRYAGAIN );

                            //
                            // Restore flags...
                            //

                            ro.Flags = uFlagsSave;

                            //
                            // Print the filename if warranted
                            //

                            if (bPrintFilename)
                            {
                                _RenderFilenameOfPhoto( &g, &rcNominal, pPhoto );
                            }

                        }
                        else
                        {

                            hr = E_FAIL;
                            break;
                        }

                        if (!bRepeat)
                        {
                            iPhotoIndex++;
                        }
                    }


                }


            }

            //
            // Last -- draw a dashed rectangle that represents
            // the printable area on the bitmap if the template
            // won't fit.
            //

            if ((ro.Dim.NominalPageOffset.cx < 0) || (ro.Dim.NominalPageOffset.cy < 0))
            {
                //Gdiplus::Pen DashedPen( black, (Gdiplus::REAL)1.0 );
                //DashedPen.SetDashStyle( Gdiplus::DashStyleDash );

                Gdiplus::Color InsideColor(255,180,180,180);
                Gdiplus::Pen   InsidePen( InsideColor );

                g.DrawRectangle( &InsidePen, clip );
            }

        }
        else
        {
            WIA_ERROR((TEXT("RenderPreview: couldn't get a Graphics from the bmp, Status = %d"),g.GetLastStatus()));
        }
    }
    else
    {
        if (hbmp)
        {
            DeleteObject(hbmp);
            hbmp = NULL;
        }

        WIA_ERROR((TEXT("RenderPreview: couldn't create DIB section")));
    }

    if (hdc)
    {
        DeleteDC( hdc );
    }

    return hbmp;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\wizblob.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       wizblob.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/18/98
 *
 *  DESCRIPTION: Defines the blob of information pass around to each
 *               page of the wizard...
 *
 *****************************************************************************/

#ifndef _PRINT_PHOTOS_WIZARD_WIZ_BLOB_
#define _PRINT_PHOTOS_WIZARD_WIZ_BLOB_

#define NOMINAL_MULTIPLIER 10000.0      // 1/10000 of inch
#define MM_PER_INCH        25.4
#define MM_TO_INCH(x)      ((DOUBLE)x / (DOUBLE)MM_PER_INCH ))
#define MM_TO_NOMINAL(x) ((INT)((DOUBLE)MM_TO_INCH(x) * (DOUBLE)NOMINAL_MULTIPLIER))
#define IN_TO_NOMINAL(x) ((INT)((DOUBLE)x * (DOUBLE)NOMINAL_MULTIPLIER))



#define WIZ_MSG_STARTUP_GDI_PLUS    (WM_USER+250)
#define WIZ_MSG_SHUTDOWN_GDI_PLUS   (WM_USER+251)
#define WIZ_MSG_COPIES_CHANGED      (WM_USER+252)  // wParam holds number of copies

#define DEFAULT_DPA_SIZE 50

#define MINIMUM_MEMORY_SIZE         140000
#define LARGE_MINIMUM_MEMORY_SIZE   400000

#define LARGE_IMAGE_SIZE            1048576
#define REALLY_LARGE_IMAGE_SIZE     5242880

class CWizardInfoBlob {

typedef struct {
    BOOL    bValid;
    SIZE    DPI;
    RECT    rcDevice;
    SIZE    PhysicalSize;
    SIZE    PhysicalOffset;
} WIZ_PRINTER_INFO, *LPWIZ_PRINTER_INFO;

public:
    CWizardInfoBlob( IDataObject * pdo, BOOL bShowUI, BOOL bOnlyUseSelection );
    ~CWizardInfoBlob();

    VOID AddRef();
    VOID Release();

    // PhotoItem stuff
    INT CountOfPhotos(BOOL bIncludeCopies);
    INT CountOfSelectedPhotos(BOOL bIncludeCopies);
    INT GetIndexOfNextPrintableItem(INT iStartIndex);
    CListItem * GetListItem(INT iIndex, BOOL bIncludeCopies);
    VOID ToggleSelectionStateOnCopies( CListItem * pRootItem, BOOL bState );

    // PhotoTemplate stuff
    HRESULT TemplateGetPreviewBitmap(INT iIndex, const SIZE &sizeDesired, HBITMAP *phBmp);
    HRESULT GetTemplateByIndex( INT iIndex, CTemplateInfo ** ppTemplateInfo );
    INT     CountOfTemplates() { return _templates.Count(); }

    // Layout stuff
    VOID    _RenderFilenameOfPhoto( Gdiplus::Graphics * g, RECT * pPhotoDest, CListItem * pPhoto );
    HBITMAP RenderPreview( INT iTemplateIndex, HWND hwndScreen );
    HRESULT RenderPrintedPage( INT iTemplateIndex, INT iPage, HDC hDC, HWND hwndProgress, float fProgressStep, float * pPercent );
    INT     PhotosPerTemplate( INT iTemplateIndex );
    VOID    _SetupDimensionsForScreen( CTemplateInfo * pTemplateInfo, HWND hwndScreen, RENDER_DIMENSIONS * pDim );
    VOID    _SetupDimensionsForPrinting( HDC hDC, CTemplateInfo * pTemplateInfo, RENDER_DIMENSIONS * pDim );

    // Printing stuff
    HRESULT SetPrinterToUse( LPCTSTR pszPrinterName );
    HRESULT SetDevModeToUse( PDEVMODE pDevMode );
    LPCTSTR GetPrinterToUse();
    PDEVMODE GetDevModeToUse();
    HRESULT GetCountOfPrintedPages( INT iTemplate, INT * pPageCount );
    VOID    UpdateCachedPrinterInfo();
    VOID    GetCachedPrinterInfo() { CAutoCriticalSection lock(_csPrinterInfo); if (!_WizPrinterInfo.bValid) {UpdateCachedPrinterInfo();} return; }
    HDC     GetCachedPrinterDC() { CAutoCriticalSection lock(_csPrinterInfo); return _hCachedPrinterDC;}
    VOID    SetCachedPrinterDC( HDC hDC ) {CAutoCriticalSection lock(_csPrinterInfo); if (_hCachedPrinterDC) {DeleteDC(_hCachedPrinterDC);} _hCachedPrinterDC = hDC; UpdateCachedPrinterInfo(); return;}
    VOID    ConstructPrintToTemplate();

    // Util stuff
    HWND    GetPreviewWnd() {return _hwndPreview;}
    VOID    SetPreviewWnd(HWND hwnd);
    VOID    SetPreviewWindowClass( CPreviewWindow * pPreview ) {if (_pPreview) {delete _pPreview;} _pPreview = pPreview;}
    VOID    InvalidateAllPreviews() {if (_pPreview) {_pPreview->InvalidateAllPreviews();} }
    VOID    GenerateStillWorkingBitmap() {if (_pPreview && _hwndPreview) {_pPreview->GenerateWorkingBitmap(_hwndPreview);} }
    VOID    SetStatusWnd(HWND hwnd) {_hwndStatus = hwnd; _hOuterDlg = GetParent( hwnd );}
    VOID    SetStatusPageClass( CStatusPage * pStatus ) { _pStatusPage = pStatus; }
    VOID    SetPhotoSelectionPageClass( CPhotoSelectionPage * pPhotoSel ) { _pPhotoSelPage = pPhotoSel; }
    HFONT   GetIntroFont(HWND hwnd);
    VOID    SetCurrentTemplateIndex(INT i) { _iCurTemplate = i; }
    INT     GetCurrentTemplateIndex() { return _iCurTemplate; }
    CPreviewWindow * GetPreviewWindowClass() {return _pPreview;}
    VOID    SetPreviewsAreDirty( BOOL b ) {_bPreviewsAreDirty = b;}
    BOOL    GetPreviewsAreDirty( ) {return _bPreviewsAreDirty;}
    BOOL    SetRepeat( BOOL b ) { if (_bRepeat == b) {return FALSE;} _bRepeat = b; return TRUE; }
    BOOL    GetRepeat( ) {return _bRepeat;}
    HICON   GetSmallIcon() {return _hSmallIcon;}
    HICON   GetLargeIcon() {return _hLargeIcon;}
    INT     ShowError( HWND hwnd, HRESULT hr, UINT idText, BOOL bTryAgain = FALSE, LPITEMIDLIST pidl = NULL );
    BOOL    AllPicturesAdded() {return _bAllPicturesAdded;}
    BOOL    ItemsWereRejected() {return _bItemsWereRejected;}
    UINT    ItemsInInitialSelection() {return _uItemsInInitialSelection;}
    VOID    ShutDownWizard();
    BOOL    IsWizardShuttingDown() {return (BOOL)_bWizardIsShuttingDown;}
    VOID    PhotoSelIsShutDown() { if (_hPhotoSelIsDone) SetEvent(_hPhotoSelIsDone); }
    VOID    StatusIsShutDown() { if (_hStatusIsDone) SetEvent(_hStatusIsDone); }
    VOID    PreviewIsShutDown() { if (_hPreviewIsDone) SetEvent(_hPreviewIsDone); }
    LRESULT UserPressedCancel();
    INT     NumberOfErrorsEncountered() { return _iNumErrorsWhileRunningWizard; }
    VOID    ResetErrorCount() { _iNumErrorsWhileRunningWizard = 0; }
    VOID    SetNumberOfCopies( UINT uCopies );
    BOOL    IsSystemMemoryLimited() { return _bMinimumMemorySystem; }
    BOOL    IsSystemMemoryLarge() { return _bLargeMemorySystem; }
    BOOL    GetForceSelectAll() { return _bForceSelectAll; }

    VOID    GdiPlusStartupShutdownThreadIsReady()
    {
        WIA_PUSH_FUNCTION_MASK((0x08000000, TEXT("CWizardInfoBlob::GdiPlusStartupShutdownThreadIsReady()")));
        if (_hGdiPlusMsgQueueCreated)
        {
            WIA_TRACE((TEXT("Setting _hGdiPlusMsgQueueCreated...")));
            SetEvent(_hGdiPlusMsgQueueCreated);
        }
    }

    VOID AddAllPhotosFromDataObject();
    VOID AddPhotosFromList(LPITEMIDLIST *aidl, int cidl, BOOL bSelectAll);
    VOID RemoveAllCopiesOfPhotos();
    VOID AddCopiesOfPhotos( UINT uCopies );


    // constants to use for wizard
    SIZE _sizeThumbnails;
    SIZE _sizeTemplatePreview;
    LONG _nDefaultThumbnailImageListIndex;

private:
    // Used to add items
    HRESULT AddPhoto( LPITEMIDLIST pidlFull );

    // thread message handlers
    VOID _DoHandleThreadMessage( LPMSG pMSG );

    // worker thread proc
    static DWORD s_GdiPlusStartupShutdownThreadProc( LPVOID lpv )
    {
        WIA_PUSH_FUNCTION_MASK((0x80, TEXT("CWizardInfoBlob::s_GdiPlusStartupShutdownThreadProc()")));
        MSG msg;
        LONG lRes = 0;
        CWizardInfoBlob * pWizInfo = (CWizardInfoBlob *)lpv;
        if (pWizInfo)
        {
            HMODULE hDll = GetThreadHMODULE( s_GdiPlusStartupShutdownThreadProc );
            HRESULT hrCo = PPWCoInitialize();

            PeekMessage( &msg, NULL, WM_USER, WM_USER, PM_NOREMOVE );
            pWizInfo->GdiPlusStartupShutdownThreadIsReady();
            do {
                lRes = GetMessage( &msg, NULL, 0, 0 );
                if (lRes > 0)
                {
                    pWizInfo->_DoHandleThreadMessage( &msg );
                }
            } while ( (lRes != 0) && (lRes != -1) );

            PPWCoUninitialize(hrCo);

            if (hDll)
            {
                WIA_TRACE((TEXT("CWizardInfoBlob::s_GdiPlusStartupShutdownThreadProc - exiting thread now via FLAET...")));
                FreeLibraryAndExitThread( hDll, 0 );
            }
        }
        WIA_TRACE((TEXT("CWizardInfoBlob::s_GdiPlusStartupShutdownThreadProc - exiting thread now...")));
        return 0;
    }

private:

    CComPtr<IDataObject>        _pdo;
    LONG                        _cRef;
    HDPA                        _hdpaItems;
    CSimpleCriticalSection      _csItems;
    CSimpleCriticalSection      _csPrinterInfo;
    CPhotoTemplates             _templates;
    PDEVMODE                    _hDevMode;
    CSimpleString               _strPrinterName;
    RECT                        _rcInitSize;
    SIZE                        _Center;
    HWND                        _hwndPreview;
    HWND                        _hwndStatus;
    CPreviewWindow *            _pPreview;
    CStatusPage *               _pStatusPage;
    CPhotoSelectionPage *       _pPhotoSelPage;
    INT                         _iCurTemplate;
    BOOL                        _bGdiplusInitialized;
    BOOL                        _bAllPicturesAdded;
    ULONG_PTR                   _pGdiplusToken;
    HFONT                       _hfontIntro;
    BOOL                        _bPreviewsAreDirty;
    BOOL                        _bRepeat;
    HICON                       _hSmallIcon;
    HICON                       _hLargeIcon;
    UINT                        _uItemsInInitialSelection;
    BOOL                        _bAlreadyAddedPhotos;
    BOOL                        _bItemsWereRejected;
    LONG                        _bWizardIsShuttingDown;
    HANDLE                      _hGdiPlusThread;
    DWORD                       _dwGdiPlusThreadId;
    HANDLE                      _hGdiPlusMsgQueueCreated;
    HDC                         _hCachedPrinterDC;
    HWND                        _hOuterDlg;
    INT                         _iNumErrorsWhileRunningWizard;
    BOOL                        _bShowUI;
    BOOL                        _bOnlyUseSelection;
    WIZ_PRINTER_INFO            _WizPrinterInfo;
    INT                         _iSelectedItem;
    INT                         _iCopiesOfEachItem;
    BOOL                        _bMinimumMemorySystem;
    BOOL                        _bLargeMemorySystem;
    BOOL                        _bForceSelectAll;

    //
    // These handles are here for each of the background threads
    // to signal so that we can know they have shut down...
    //

    HANDLE                      _hPhotoSelIsDone;
    HANDLE                      _hStatusIsDone;
    HANDLE                      _hPreviewIsDone;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by phototst.rc
//
#define IDD_PHOTOTST_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDC_RUN_WIZARD                  1000

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\test\phototst.cpp ===
#include <windows.h>
#include <commdlg.h>
#include <stdio.h>
#include <tchar.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <objbase.h>
#include "prwiziid.h"
#include "resource.h"

const GUID CLSID_PrintPhotosWizard       = {0x4c649c49, 0xc48f, 0x4222, {0x9a, 0x0d, 0xcb, 0xbf, 0x42, 0x31, 0x22, 0x1d}};
const GUID CLSID_PrintPhotosDropTarget   = {0x60fd46de, 0xf830, 0x4894, {0xa6, 0x28, 0x6f, 0xa8, 0x1b, 0xc0, 0x19, 0x0d}};
const GUID IID_ISetWaitEventForTesting   = {0xd61e2fe1, 0x4af8, 0x4dbd, {0xb8, 0xad, 0xe7, 0xe0, 0x7a, 0xdc, 0xf9, 0x0f}};

HINSTANCE g_hInstance = NULL;

INT CountItems( LPTSTR pString )
{
    INT iCount = 0;

    if (pString && *pString)
    {
        do
        {
            do
            {
                pString++;
            }
            while ( *pString );

            pString++;
            iCount++;
        }
        while ( *pString );
    }

    return iCount;
}


void RunWizard(HWND hwndOwner)
{
    #define BUFFER_SIZE 65535

    TCHAR         szBuffer[BUFFER_SIZE];
    TCHAR         szParent[MAX_PATH];
    TCHAR         szChild[MAX_PATH];
    LPCITEMIDLIST aPidl[ 512 ];
    OPENFILENAME  ofn;
    LPITEMIDLIST  pidlParent = NULL, pidlFull = NULL, pidlItem = NULL;
    HRESULT       hr;
    IDataObject   *pdo = NULL;
    INT           index = 0;


    ZeroMemory(szBuffer,BUFFER_SIZE);
    ZeroMemory(&ofn, sizeof(ofn));
    ZeroMemory(aPidl, sizeof(aPidl));


    //
    // launch the file common dialog so the user
    // can select what files to pre-populate the
    // the wizard with...
    //

    ofn.lStructSize = sizeof(ofn);
    ofn.hInstance   = g_hInstance;
    ofn.hwndOwner   = hwndOwner;
    ofn.lpstrFilter = TEXT("All Files\0*.*\0JPEG Files\0*.jpg;*.jpeg\0TIFF Files\0*.tif;*.tiff\0GIF Files\0*.gif\0Bitmap Files\0*.bmp\0PNG Files\0*.png\0DIB Files\0*.DIB\0EMF Files\0*.EMF\0WMF Files\0*.WMF\0Icon Files\0*.ICO\0\0\0\0");
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szBuffer;
    ofn.nMaxFile = BUFFER_SIZE;
    ofn.lpstrTitle = TEXT("Select files to populate Print Photos Wizard with!");
    ofn.Flags = OFN_ALLOWMULTISELECT | OFN_EXPLORER | OFN_DONTADDTORECENT | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;

    if (GetOpenFileName( &ofn ))
    {
        INT iCount = CountItems( ofn.lpstrFile );

        if (iCount == 1)
        {
            hr = SHILCreateFromPath( ofn.lpstrFile, &pidlFull, NULL );

            if (SUCCEEDED(hr))
            {
                pidlItem        = ILFindLastID( pidlFull );
                aPidl[index++]  = ILClone( pidlItem );
                ILRemoveLastID( pidlFull );
                pidlParent      = ILClone( pidlFull );

                ILFree( pidlFull );
            }


        }
        else if (iCount > 1)
        {

            LPTSTR pCur = ofn.lpstrFile;
            LPITEMIDLIST pidlTemp = NULL;
            LPITEMIDLIST pidlRel  = NULL;

            lstrcpy( szParent, pCur );
            pCur += (lstrlen(pCur) + 1);

            //
            // Create parent idlist
            //

            hr = SHILCreateFromPath( szParent, &pidlParent, NULL );

            //
            // move to first file...


            if (SUCCEEDED(hr) && pidlParent)
            {

                for ( ; pCur && (*pCur); pCur += (lstrlen(pCur)+1))
                {
                    //
                    // Now, walk through and create each child item...
                    //

                    lstrcpy( szChild, szParent );
                    lstrcat( szChild, TEXT("\\") );
                    lstrcat( szChild, pCur );

                    //
                    // Create a pidl
                    //

                    hr = SHILCreateFromPath( szChild, &pidlTemp, NULL );
                    if (SUCCEEDED(hr))
                    {
                        pidlRel = ILFindLastID( pidlTemp );

                        aPidl[index++] = ILClone( pidlRel );

                        ILFree( pidlTemp );
                    }

                }


            }
        }
        else
        {
            TCHAR szError[1024];

            wsprintf( szError, TEXT("GetOpenFileName failed, Err=%d"), CommDlgExtendedError() );

            MessageBox( hwndOwner, szError, TEXT("Unit Test Error"), MB_OK | MB_ICONWARNING );
        }





        if (index)
        {
            //
            // If there's anything in the pidl array, then create dataobject
            //

            hr = SHCreateFileDataObject( pidlParent, index, aPidl, NULL, &pdo );

            if (SUCCEEDED(hr) && pdo)
            {
                IDropTarget * pdt = NULL;

                //
                // Got a data object, now start the wizard & do drop operation...
                //

                hr = CoCreateInstance( CLSID_PrintPhotosDropTarget, NULL, CLSCTX_INPROC_SERVER, IID_IDropTarget, (LPVOID *)&pdt );
                if (SUCCEEDED(hr) && pdt)
                {

                    DWORD pdwEffect = DROPEFFECT_NONE;
                    POINTL pt;

                    pt.x = 0;
                    pt.y = 0;

                    hr = pdt->Drop( pdo, 0, pt, &pdwEffect );
                    pdt->Release();

                }

                pdo->Release();

            }

            //
            // Free pidls from aPidl
            //

            if (pidlParent)
            {
                ILFree( pidlParent );
            }

            for (INT i=0; i<index; i++)
            {
                if (aPidl[i])
                {
                    ILFree( (LPITEMIDLIST)aPidl[i] );
                }
            }
        }

    }
    else
    {
        TCHAR szError[1024];

        wsprintf( szError, TEXT("GetOpenFileName failed, Err=%d"), CommDlgExtendedError() );
        MessageBox( hwndOwner, szError, TEXT("Unit Test Error"), MB_OK | MB_ICONWARNING );
    }


}


INT_PTR CALLBACK TestDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg )
    {
    case WM_INITDIALOG:
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            EndDialog( hDlg, 0 );
            break;

        case IDC_RUN_WIZARD:
            RunWizard(hDlg);
            break;
        }
    }

    return FALSE;
}

int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    TCHAR sz[ MAX_PATH ];
    INT_PTR res;

    CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );


    g_hInstance = hInstance;
    res = DialogBox( hInstance, MAKEINTRESOURCE(IDD_PHOTOTST_DIALOG), NULL, TestDlgProc );
    if (res == -1)
    {
        wsprintf( sz, TEXT("DialogBox failed with GLE=%d"), GetLastError() );
        MessageBox( NULL, sz, TEXT("Unit Test Error"), MB_OK | MB_ICONWARNING );
    }


    CoUninitialize();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\xmltools2.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       xmltools2.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu, based on work by LazarI
 *
 *  DATE:        2/19/01
 *
 *  DESCRIPTION: Class which encapsulates reading templates from xml file, and
 *               class which encapsulates the template for use by the app.
 *
 *****************************************************************************/

#ifndef _xmltools2_h_
#define _xmltools2_h_

#define LOCAL_DEPENDENT_INDEX 0
#define LOCAL_INDEPENDENT_INDEX 1
#define NUMBER_OF_TEMPLATE_TYPES 2

class CTemplateInfo
{

public:

    // common properties
    // accessible through IDs
    enum
    {
        PROP_GUID,
        PROP_GROUP,
        PROP_TITLE,
        PROP_DESCRIPTION,
        PROP_REPEAT_PHOTOS,
        PROP_USE_THUMBNAILS_TO_PRINT,
        PROP_PRINT_FILENAME,
        PROP_CAN_ROTATE,
        PROP_CAN_CROP,

        PROP_LAST
    };


    CTemplateInfo( IXMLDOMElement * pTheTemplate ); // loads templates from XML file
    CTemplateInfo(); // creates full page template without going to XML file
    ~CTemplateInfo();

    //
    // These are the inherent properties of this template
    //

    INT PhotosPerPage()
    {
        WIA_PUSH_FUNCTION_MASK((TRACE_TEMPLATE,TEXT("CTemplateInfo::PhotosPerPage( returning %d )"),_arrLayout.Count()));
        return _arrLayout.Count();
    }

    HRESULT GetGroup( CSimpleString * pstrGroup )
    {
        WIA_PUSH_FUNCTION_MASK((TRACE_TEMPLATE,TEXT("CTemplateInfo::GetGroup( returning %s )"),_strGroup.String()));
        if (pstrGroup)
        {
            pstrGroup->Assign( _strGroup.String() );
            return S_OK;
        }

        return E_INVALIDARG;
    }

    HRESULT GetTitle( CSimpleString * pstrTitle )
    {
        WIA_PUSH_FUNCTION_MASK((TRACE_TEMPLATE,TEXT("CTemplateInfo::GetTitle( returning %s )"),_strTitle.String()));
        if (pstrTitle)
        {
            pstrTitle->Assign( _strTitle.String() );
            return S_OK;
        }

        return E_INVALIDARG;
    }


    HRESULT GetDescription( CSimpleString * pstrDescription )
    {
        WIA_PUSH_FUNCTION_MASK((TRACE_TEMPLATE,TEXT("CTemplateInfo::GetDesciption( returning %s )"),_strDescription.String()));
        if (pstrDescription)
        {
            pstrDescription->Assign( _strDescription.String() );
            return S_OK;
        }

        return E_INVALIDARG;
    }

    HRESULT GetRepeatPhotos( BOOL * pBool )
    {
        WIA_PUSH_FUNCTION_MASK((TRACE_TEMPLATE,TEXT("CTemplateInfo::GetRepeatPhotos( returning 0x%x )"),_bRepeatPhotos));
        if (pBool)
        {
            *pBool = _bRepeatPhotos;
            return S_OK;
        }

        return E_INVALIDARG;
    }

    HRESULT GetUseThumbnailsToPrint( BOOL * pBool )
    {
        WIA_PUSH_FUNCTION_MASK((TRACE_TEMPLATE,TEXT("CTemplateInfo::GetUseThumbnailsToPrint( returning 0x%x )"),_bUseThumbnailsToPrint));
        if (pBool)
        {
            *pBool = _bUseThumbnailsToPrint;
            return S_OK;
        }

        return E_INVALIDARG;
    }

    HRESULT GetPrintFilename( BOOL * pBool )
    {
        WIA_PUSH_FUNCTION_MASK((TRACE_TEMPLATE,TEXT("CTemplateInfo::GetPrintFilename( returning 0x%x )"),_bPrintFilename));
        if (pBool)
        {
            *pBool = _bPrintFilename;
            return S_OK;
        }

        return E_INVALIDARG;
    }

    HRESULT GetCanRotate( BOOL * pBool )
    {
        WIA_PUSH_FUNCTION_MASK((TRACE_TEMPLATE,TEXT("CTemplateInfo::GetCanRotate( returning 0x%x )"),_bCanRotate));
        if (pBool)
        {
            *pBool = _bCanRotate;
            return S_OK;
        }

        return E_INVALIDARG;
    }

    HRESULT GetCanCrop( BOOL * pBool )
    {
        WIA_PUSH_FUNCTION_MASK((TRACE_TEMPLATE,TEXT("CTemplateInfo::GetCanCrop( returning 0x%x )"),_bCanCrop));
        if (pBool)
        {
            *pBool = _bCanCrop;
            return S_OK;
        }

        return E_INVALIDARG;
    }

    HRESULT GetNominalRectForPhoto( INT iIndex, RECT * pRect )
    {
        WIA_PUSH_FUNCTION_MASK((TRACE_TEMPLATE,TEXT("CTemplateInfo::GetNominalRectForPhoto( )")));
        CAutoCriticalSection lock(_cs);

        if (pRect)
        {
            if (iIndex < _arrLayout.Count())
            {
                *pRect = _arrLayout[iIndex];
                return S_OK;
            }
        }

        return E_INVALIDARG;
    }

    HRESULT GetNominalRectForImageableArea( RECT * pRect )
    {
        WIA_PUSH_FUNCTION_MASK((TRACE_TEMPLATE,TEXT("CTemplateInfo::GetNominalRectForImageableArea( returning %d,%d,%d,%d )"),_rcImageableArea.left,_rcImageableArea.top,_rcImageableArea.right,_rcImageableArea.bottom));
        CAutoCriticalSection lock(_cs);

        if (pRect)
        {
            *pRect = _rcImageableArea;
            return S_OK;
        }

        return E_INVALIDARG;
    }

    HRESULT GetPreviewImageStream(IStream **pps)
    {
        WIA_PUSH_FUNCTION_MASK((TRACE_TEMPLATE,TEXT("CTemplateInfo::GetImagePreviewStream( )")));
        if (pps)
        {
            //
            // Since _pStream is an ATL CComPtr, it does
            // an addref in it's operator =, so we're returning
            // an addref'd IStream.
            //

            *pps = _pStream;

            if (*pps)
            {
                (*pps)->AddRef();
                return S_OK;
            }
        }

        return E_INVALIDARG;
    }

    //
    // These are used to set which orientation the template should be in
    //

    HRESULT RotateForLandscape();
    HRESULT RotateForPortrait();


private:

    BOOL                _bPortrait;
    CSimpleCriticalSection _cs;

    //
    // Properties from XML
    //

    RECT                _rcImageableArea;
    CSimpleArray<RECT>  _arrLayout;
    CSimpleString       _strGroup;
    CSimpleString       _strTitle;
    CSimpleString       _strDescription;
    BOOL                _bRepeatPhotos;
    BOOL                _bUseThumbnailsToPrint;
    BOOL                _bPrintFilename;
    BOOL                _bCanRotate;
    BOOL                _bCanCrop;
    IStream *           _pStream;

};


////////////////////////////
// CPhotoTemplates

class CPhotoTemplates
{
public:


    enum
    {
        MEASURE_INDEPENDENT,
        MEASURE_METRIC,
        MEASURE_US,

        MEASURE_UNKNOWN
    };

    //
    // construction/destruction
    //

    CPhotoTemplates();
    ~CPhotoTemplates();

    //
    // public interface
    //

    HRESULT Init(IXMLDOMDocument *pDoc);        // init from XML doc
    HRESULT InitForPrintTo();                   // init for PrintTo situation
    HRESULT AddTemplates(LPCTSTR pLocale);      // add the templates for the given locale
    LONG    Count();                            // number of templates
    HRESULT GetTemplate( INT iIndex, CTemplateInfo ** ppTemplateInfo );


private:

    static HRESULT _GetLocaleMeasurements(int *pMeasurements);
    static HRESULT _BuildLocaleQueryString(int Measure, LPTSTR pStr, UINT cch);
    static HRESULT _BuildGUIDQueryString(const GUID &guid, CComBSTR &bstr);

    int                          _Measure;
    CSimpleCriticalSection       _csList;
    CComPtr<IXMLDOMElement>      _pRoot;
    HDPA                         _hdpaTemplates;

};

#endif // _xmltools2_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prevwnd\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        5/12/99
 *
 *  DESCRIPTION: Precompiled header file for the preview window
 *
 *****************************************************************************/

#ifndef __PRECOMP_H_INCLUDED
#define __PRECOMP_H_INCLUDED

#include <windows.h>
#include <commctrl.h>
#include <propidl.h>
#include "uicommon.h"
#include "simcrack.h"
#include "wiadebug.h"

#include <shfusion.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\photowiz\xmltools2.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       xmltools.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DGetATE:        10/18/00
 *
 *  DESCRIPTION: Class which encapsulates XML DOM for implementing
 *               wizard templates
 *
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/////////////////////////////////
// CPhotoTemplates impl.

// global strings
static const TCHAR gszVersionGUID[]         = TEXT("{352A15C4-1D19-4e93-AF92-D939C2812491}");
static const TCHAR gszPatternDefs[]         = TEXT("template-def");
static const TCHAR gszPatternLocale[]       = TEXT("template-definitions[@measurements = \"%s\"]");
static const TCHAR gszPatternLocaleInd[]    = TEXT("template-definitions[@measurements = \"locale-independent\"]");
static const TCHAR gszPatternGUID[]         = TEXT("template-def[@guid = \"%s\"]");
static const TCHAR gszGUID[]                = TEXT("guid");

static const LPCTSTR arrCommonPropNames[CTemplateInfo::PROP_LAST] =
{
    TEXT("guid"),
    TEXT("group"),
    TEXT("title"),
    TEXT("description"),
    TEXT("repeat-photos"),
    TEXT("use-thumbnails-for-printing"),
    TEXT("print-filename"),
    TEXT("can-rotate"),
    TEXT("can-crop"),
};


/////////////////////////////////////////////////////////////////////////////////////////////////
// utility functions

template <class T>
HRESULT _GetProp(IXMLDOMElement *pElement, LPCTSTR pszName, T &value);

// number convertions
HRESULT _ConvertTo(LPCTSTR pszValue, LONG &lValue);
HRESULT _ConvertTo(LPCTSTR pszValue, double &dValue);
HRESULT _ConvertTo(LPCTSTR pszValue, BOOL &bValue);

// attributes access
HRESULT _GetAttribute(IXMLDOMElement *pElement, LPCTSTR pszAttrName, CComBSTR &bstr);

template <class T>
HRESULT _GetProp(IXMLDOMElement *pElement, LPCTSTR pszName, T &value)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_XML,TEXT("_GetProp: %s"),(pszName ? pszName : TEXT("NULL POINTER!"))));

    HRESULT hr = E_FAIL;
    CComBSTR bstr;
    if( pElement &&
        SUCCEEDED(hr = _GetAttribute(pElement, pszName, bstr)) &&
        SUCCEEDED(hr = _ConvertTo(bstr, value)) )
    {
        hr = S_OK;
    }

    WIA_RETURN_HR(hr);
}

HRESULT _ConvertTo(LPCTSTR pszValue, LONG &lValue)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_XML,TEXT("_ConvertTo(LONG): %s"),(pszValue ? pszValue : TEXT("NULL POINTER!"))));
    HRESULT hr = E_INVALIDARG;
    if( pszValue )
    {
        hr = S_OK;
        TCHAR *endptr = NULL;
        lValue = _tcstol(pszValue, &endptr, 10);
        if( ERANGE == errno || *endptr )
        {
            // conversion failed
            lValue = 0;
            hr = E_FAIL;
        }
    }
    WIA_RETURN_HR(hr);
}

HRESULT _ConvertTo(LPCTSTR pszValue, double &dValue)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_XML,TEXT("_ConvertTo(double): %s"),(pszValue ? pszValue : TEXT("NULL POINTER!"))));
    HRESULT hr = E_INVALIDARG;
    if( pszValue )
    {
        hr = S_OK;
        TCHAR *endptr = NULL;
        dValue = _tcstod(pszValue, &endptr);

        if( ERANGE == errno || *endptr )
        {
            // conversion failed
            dValue = 0.0;
            hr = E_FAIL;
        }
    }
    WIA_RETURN_HR(hr);
}

HRESULT _ConvertTo(LPCTSTR pszValue, BOOL &bValue)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_XML,TEXT("_ConvertTo(bool): %s"),(pszValue ? pszValue : TEXT("NULL POINTER!"))));
    HRESULT hr = E_INVALIDARG;
    if( pszValue )
    {
        hr = S_OK;
        // check for true first
        if( 0 == lstrcmp(pszValue, TEXT("yes")) ||
            0 == lstrcmp(pszValue, TEXT("on")) )
        {
            bValue = true;
        }
        else
        {
            // check for false next
            if( 0 == lstrcmp(pszValue, TEXT("no")) ||
                0 == lstrcmp(pszValue, TEXT("off")) )
            {
                bValue = false;
            }
            else
            {
                // not a boolean
                hr = E_FAIL;
            }
        }
    }
    WIA_RETURN_HR(hr);
}

HRESULT _GetAttribute(IXMLDOMElement *pElement, LPCTSTR pszAttrName, CComBSTR &bstr)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_XML,TEXT("_GetAttribute(BSTR): %s"),(pszAttrName ? pszAttrName : TEXT("NULL POINTER!"))));
    HRESULT hr = E_INVALIDARG;
    CComVariant strAttr;

    if( pElement && pszAttrName &&
        SUCCEEDED(hr = pElement->getAttribute(CComBSTR(pszAttrName), &strAttr)) )
    {
        if( VT_BSTR == strAttr.vt )
        {
            bstr = strAttr.bstrVal;
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    WIA_RETURN_HR(hr);
}

HRESULT _GetChildElement(IXMLDOMElement *pElement, LPCTSTR pszName, IXMLDOMElement **ppChild)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_XML,TEXT("_GetChildElement( %s )"),(pszName ? pszName : TEXT("NULL POINTER!"))));
    HRESULT hr = E_INVALIDARG;
    if( pElement && pszName && ppChild )
    {
        CComPtr<IXMLDOMNode> pNode;
        if( SUCCEEDED(hr = pElement->selectSingleNode(CComBSTR(pszName), &pNode)) && pNode)
        {
            //
            // query for IXMLDOMElement interface
            //

            hr = pNode->QueryInterface(IID_IXMLDOMElement, (void **)ppChild);
        }
    }
    WIA_RETURN_HR(hr);
}


/////////////////////////////////////////////////////////////////////////////////////////////////

    // construction/destruction
CPhotoTemplates::CPhotoTemplates():
    _Measure(MEASURE_UNKNOWN)
{
}

INT MyTemplateDestroyCallback( LPVOID pItem, LPVOID lpData )
{
    WIA_PUSH_FUNCTION_MASK((TRACE_XML,TEXT("MyTemplateDestroyCallback( 0x%x, 0x%x )"),pItem,lpData));

    if (pItem)
    {
        delete (CTemplateInfo *)pItem;
    }

    return TRUE;
}

CPhotoTemplates::~CPhotoTemplates()
{
    CAutoCriticalSection lock(_csList);

    DPA_DestroyCallback( _hdpaTemplates, MyTemplateDestroyCallback, NULL );
    _hdpaTemplates = NULL;
}

HRESULT CPhotoTemplates::AddTemplates(LPCTSTR pLocale)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_XML,TEXT("CPhotoTemplates::AddTemplates( %s )"),pLocale));

    HRESULT hr = E_INVALIDARG;
    CComPtr<IXMLDOMNodeList> pTemplates;
    CComPtr<IXMLDOMNode>     pLocaleNode;
    CComBSTR bstrGUID;

    //
    // Initialize things as needed
    //

    if (!pLocale || !_pRoot)
    {
        return hr;
    }

    CAutoCriticalSection lock(_csList);

    //
    // Select the correct locale node in the XML document
    //

    if (_pRoot)
    {
        hr = _pRoot->selectSingleNode( CComBSTR(pLocale), &pLocaleNode );
        WIA_CHECK_HR(hr,"AddTempaltes: _pRoot->selectSingleNode()");

        if (SUCCEEDED(hr) && pLocaleNode)
        {
            //
            // Select the templates sub-node
            //

            hr = pLocaleNode->selectNodes(CComBSTR(gszPatternDefs), &pTemplates);
            WIA_CHECK_HR(hr,"AddTemplates: pLocalNode->selectNodes( )");

            if (SUCCEEDED(hr) && pTemplates)
            {
                //
                // update the GUIDs of each template to be uppercase, so we can query later
                //

                GUID guid;
                TCHAR szGUID[128];

                LONG lCount = 0;

                hr = pTemplates->get_length(&lCount);
                WIA_CHECK_HR(hr,"AddTemplates: pTemplates->get_length(&lCount)");

                if (SUCCEEDED(hr) && lCount)
                {
                    //
                    // Loop through all the template and add them to the
                    // the array of templates...
                    //



                    WIA_TRACE((TEXT("AddTemplates: loaded section, adding %d templates.."),lCount));
                    for( LONG l = 0; SUCCEEDED(hr) && (l < lCount); l++ )
                    {

                        //
                        // Get the actual XML item for the template...
                        //

                        CComPtr<IXMLDOMNode> pNode;
                        hr = pTemplates->get_item(l, &pNode);
                        WIA_CHECK_HR(hr,"LoadTemplate: pTemplates->get_item( lRelativeIndex )");

                        if (SUCCEEDED(hr) && pNode)
                        {
                            //
                            // query IXMLDOMElement interface
                            //

                            CComPtr<IXMLDOMElement> pTheTemplate;
                            hr = pNode->QueryInterface(IID_IXMLDOMElement, (void **)&pTheTemplate);
                            if (SUCCEEDED(hr) && pTheTemplate)
                            {
                                //
                                // Create template for this item...
                                //

                                CTemplateInfo * pTemplateInfo = (CTemplateInfo *) new CTemplateInfo( pTheTemplate );

                                if (pTemplateInfo)
                                {
                                    INT iRes = -1;
                                    if (_hdpaTemplates)
                                    {
                                        iRes = DPA_AppendPtr( _hdpaTemplates, (LPVOID)pTemplateInfo );
                                    }

                                    if (iRes == -1)
                                    {
                                        //
                                        // The item was not added to the DPA, delete it...
                                        //

                                        delete pTemplateInfo;
                                        hr = E_FAIL;
                                    }
                                }

                            }
                        }
                    }
                }

                pTemplates = NULL;
            }

            pLocaleNode = NULL;
        }
    }

    WIA_RETURN_HR(hr);
}

// public interface
HRESULT CPhotoTemplates::Init(IXMLDOMDocument *pDoc)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_XML,TEXT("CPhotoTemplates::Init()")));
    HRESULT hr = E_INVALIDARG;
    CComBSTR bstrGUID;
    LONG lCountCommon = 0;

    CAutoCriticalSection lock(_csList);

    //
    // If the dpa of item isn't initialized, do it now...
    //

    if (!_hdpaTemplates)
    {
        _hdpaTemplates = DPA_Create(10);
    }

    //
    // if we're being called twice to initialize, make sure that works...
    //

    _pRoot = NULL;

    //
    // get the root element & the version guid
    //

    if( pDoc &&
        SUCCEEDED(hr = pDoc->get_documentElement(&_pRoot)) &&
        SUCCEEDED(hr = _GetAttribute(_pRoot, TEXT("guid"), bstrGUID)) )
    {
        // check the version
        if (0==lstrcmp(bstrGUID, gszVersionGUID))
        {
            //
            // Add the local-independent items first
            //

            hr = AddTemplates( gszPatternLocaleInd );

            //
            // Add the local-specific templates second
            //

            hr = _GetLocaleMeasurements( &_Measure );

            if (SUCCEEDED(hr))
            {
                TCHAR szLocale[MAX_PATH];

                *szLocale = 0;
                hr = _BuildLocaleQueryString(_Measure, szLocale, MAX_PATH);
                if (SUCCEEDED(hr))
                {
                    hr = AddTemplates( szLocale );
                }
            }

        }
    }

    WIA_RETURN_HR(hr);
}


HRESULT CPhotoTemplates::InitForPrintTo()
{
    WIA_PUSH_FUNCTION_MASK((TRACE_XML,TEXT("CPhotoTemplates::Init()")));

    HRESULT hr = S_OK;

    //
    // Our job here is simple -- create 1 template that is the equivalent
    // of full page.  Don't need any icons, etc., just the dimensions
    // and properties...
    //

    _hdpaTemplates = DPA_Create(1);

    if (_hdpaTemplates)
    {
        CTemplateInfo * pTemplateInfo = (CTemplateInfo *) new CTemplateInfo( );

        if (pTemplateInfo)
        {
            INT iRes = DPA_AppendPtr( _hdpaTemplates, (LPVOID)pTemplateInfo );

            if (iRes == -1)
            {
                //
                // The item was not added to the DPA, delete it...
                //

                delete pTemplateInfo;
                hr = E_FAIL;
            }
        }
    }

    WIA_RETURN_HR(hr);
}


LONG CPhotoTemplates::Count()
{
    LONG lCount = 0;

    CAutoCriticalSection lock(_csList);

    if (_hdpaTemplates)
    {
        lCount = (LONG)DPA_GetPtrCount( _hdpaTemplates );
    }

    WIA_PUSH_FUNCTION_MASK((TRACE_XML,TEXT("CPhotoTemplates::Count( returning count as %d )"),lCount));

    return lCount;
}



HRESULT CPhotoTemplates::_GetLocaleMeasurements(int *pMeasurements)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_XML,TEXT("CPhotoTemplates::_GetLocalMeasurements()")));
    TCHAR szMeasure[5];
    if( GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IMEASURE, szMeasure, ARRAYSIZE(szMeasure)) )
    {
        *pMeasurements = (TEXT('0') == szMeasure[0] ? MEASURE_METRIC : MEASURE_US);
        return S_OK;
    }
    WIA_ERROR((TEXT("GetLocaleInfo failed w/GLE = %d"),GetLastError()));
    return E_FAIL;
}

HRESULT CPhotoTemplates::_BuildLocaleQueryString(int Measure, LPTSTR pStr, UINT cch)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_XML,TEXT("CPhotoTemplates::_BuildLocaleQueryString()")));
    TCHAR szPatternString[255];
    HRESULT hr = E_INVALIDARG;

    LPCTSTR pszMeasure = MEASURE_METRIC == Measure ? TEXT("cm") :
                         MEASURE_US     == Measure ? TEXT("in") : NULL;

    WIA_TRACE((TEXT("pszMeasure = %s"),pszMeasure));

    // build simple XSL pattern query string based on the current locale measurements
    if( pszMeasure && -1 != wnsprintf(szPatternString, ARRAYSIZE(szPatternString), gszPatternLocale, pszMeasure) )
    {
        if (pStr && cch >= (UINT)(lstrlen(szPatternString)+1))
        {
            lstrcpy(pStr,szPatternString);
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    WIA_RETURN_HR(hr);
}

HRESULT CPhotoTemplates::_BuildGUIDQueryString(const GUID &guid, CComBSTR &bstr)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_XML,TEXT("CPhotoTemplates::_BuildGUIDQueryString()")));
    TCHAR szGUID[128];
    HRESULT hr = StringFromGUID2(guid, szGUID, ARRAYSIZE(szGUID));

    if( SUCCEEDED(hr) )
    {
        TCHAR szPatternString[255];
        if( -1 != wnsprintf(szPatternString, ARRAYSIZE(szPatternString), gszPatternGUID, szGUID) )
        {
            bstr = szPatternString;
            hr = bstr ? S_OK : E_OUTOFMEMORY;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    WIA_RETURN_HR(hr);
}



HRESULT CPhotoTemplates::GetTemplate(INT iIndex, CTemplateInfo ** ppTemplateInfo)
{
    WIA_PUSH_FUNCTION_MASK((TRACE_XML,TEXT("CPhotoTemplates::GetTemplate()")));
    HRESULT hr = E_INVALIDARG;

    CAutoCriticalSection lock(_csList);

    if( ppTemplateInfo )
    {
        if ( _hdpaTemplates )
        {
            if (iIndex < DPA_GetPtrCount( _hdpaTemplates ))
            {
                //
                // Note: it's only okay to hand out pointers here because
                // we know that wizblob.cpp doesn't delete the CPhotoTemplates
                // class until all the background threads have exited, etc.
                //

                *ppTemplateInfo = (CTemplateInfo *) DPA_FastGetPtr( _hdpaTemplates, iIndex );
                hr = S_OK;
            }
        }
        else
        {
            hr = E_FAIL;
        }


    }
    WIA_RETURN_HR(hr);
}


// creates full page template info
CTemplateInfo::CTemplateInfo()
  : _bRepeatPhotos(FALSE),
    _bUseThumbnailsToPrint(FALSE),
    _bPrintFilename(FALSE),
    _bCanRotate(TRUE),
    _bCanCrop(FALSE),
    _bPortrait(TRUE),
    _pStream(NULL)
{
    //
    // Set imageable area
    //

    _rcImageableArea.left   = -1;
    _rcImageableArea.top    = -1;
    _rcImageableArea.right  = -1;
    _rcImageableArea.bottom = -1;

    //
    // Set 1 item, takes up all of imageable area
    //

    RECT rcItem;
    rcItem.left     = -1;
    rcItem.top      = -1;
    rcItem.right    = -1;
    rcItem.bottom   = -1;
    _arrLayout.Append( rcItem );

    _strTitle.LoadString( IDS_FULL_PAGE_TITLE, g_hInst );
    _strDescription.LoadString( IDS_FULL_PAGE_DESC, g_hInst );
}

CTemplateInfo::CTemplateInfo( IXMLDOMElement * pTheTemplate )
  : _bRepeatPhotos(FALSE),
    _bUseThumbnailsToPrint(FALSE),
    _bPrintFilename(FALSE),
    _bCanRotate(FALSE),
    _bCanCrop(FALSE),
    _bPortrait(TRUE),
    _pStream(NULL)
{

    HRESULT hr;

    if (pTheTemplate)
    {
        //
        // Make sure backing COM object doesn't go away on us...
        //

        pTheTemplate->AddRef();

        //
        // Get all the properties so we can construct an
        // initialized template for our list...
        //


        CComBSTR bstrGroup;
        CComBSTR bstrTitle;
        CComBSTR bstrDescription;

        hr = _GetAttribute( pTheTemplate, arrCommonPropNames[PROP_GROUP], bstrGroup );
        WIA_CHECK_HR(hr,"AddTemplate: couldn't get PROP_GROUP property");
        if (SUCCEEDED(hr))
        {
            _strGroup.Assign( CSimpleStringConvert::NaturalString(CSimpleStringWide(bstrGroup)) );
        }

        hr = _GetAttribute( pTheTemplate, arrCommonPropNames[PROP_TITLE], bstrTitle );
        WIA_CHECK_HR(hr,"AddTemplate: couldn't get PROP_TITLE property");
        if (SUCCEEDED(hr))
        {
            _strTitle.Assign( CSimpleStringConvert::NaturalString(CSimpleStringWide(bstrTitle)) );
        }

        hr = _GetAttribute( pTheTemplate, arrCommonPropNames[PROP_DESCRIPTION], bstrDescription );
        WIA_CHECK_HR(hr,"AddTemplate: couldn't get PROP_DESCRIPTION property");
        if (SUCCEEDED(hr))
        {
            _strDescription.Assign( CSimpleStringConvert::NaturalString(CSimpleStringWide(bstrDescription)) );
        }

        hr = _GetProp<BOOL>( pTheTemplate, arrCommonPropNames[PROP_REPEAT_PHOTOS], _bRepeatPhotos );
        WIA_CHECK_HR(hr,"AddTemplate: couldn't get PROP_REPEAT_PHOTOS property");

        hr = _GetProp<BOOL>( pTheTemplate, arrCommonPropNames[PROP_USE_THUMBNAILS_TO_PRINT], _bUseThumbnailsToPrint );
        WIA_CHECK_HR(hr,"AddTemplate: couldn't get PROP_USE_THUMBNAILS_TO_PRINT property");

        hr = _GetProp<BOOL>( pTheTemplate, arrCommonPropNames[PROP_PRINT_FILENAME], _bPrintFilename );
        WIA_CHECK_HR(hr,"AddTemplate: couldn't get PROP_USE_THUMBNAILS_TO_PRINT property");

        hr = _GetProp<BOOL>( pTheTemplate, arrCommonPropNames[PROP_CAN_ROTATE], _bCanRotate );
        WIA_CHECK_HR(hr,"AddTemplate: couldn't get PROP_CAN_ROTATE property");

        hr = _GetProp<BOOL>( pTheTemplate, arrCommonPropNames[PROP_CAN_CROP], _bCanCrop );
        WIA_CHECK_HR(hr,"AddTemplate: couldn't get PROP_CAN_CROP property");

        //
        // Get IStream to template preview (icon)
        //

        CComPtr<IXMLDOMElement> pImageInfo;

        hr = _GetChildElement(pTheTemplate, TEXT("preview-image"), &pImageInfo);
        WIA_CHECK_HR(hr,"_GetChildElement( preview-image ) failed");

        if( SUCCEEDED(hr) && pImageInfo )
        {
            CComBSTR bstrAttr;
            hr = _GetAttribute(pImageInfo, TEXT("url"), bstrAttr);

            if(SUCCEEDED(hr))
            {
                //
                // URL is provided - this overrides everything else
                //

                hr = CreateStreamFromURL(bstrAttr, &_pStream);
                WIA_CHECK_HR(hr,"CreateStreamFromURL failed!");
            }
            else
            {
                //
                // try getting resource info (module + resource name)
                //

                hr = _GetAttribute(pImageInfo, TEXT("res-name"), bstrAttr);

                if(SUCCEEDED(hr))
                {
                    CComBSTR bstrModule, bstrType;
                    LPCTSTR pszModule = SUCCEEDED(_GetAttribute(pImageInfo, TEXT("res-module"), bstrModule)) ? bstrModule : NULL;
                    LPCTSTR pszType = SUCCEEDED(_GetAttribute(pImageInfo, TEXT("res-type"), bstrType)) ? bstrType : TEXT("HTML");

                    //
                    // filter out some of the standard resource types
                    //

                    pszType = (0 == lstrcmp(pszType, TEXT("HTML"))) ? RT_HTML :
                              (0 == lstrcmp(pszType, TEXT("ICON"))) ? RT_ICON :
                              (0 == lstrcmp(pszType, TEXT("BITMAP"))) ? RT_BITMAP : pszType;

                    //
                    // just create a memory stream on the specified resource
                    //

                    hr = CreateStreamFromResource(pszModule, pszType, bstrAttr, &_pStream);
                    WIA_CHECK_HR(hr, "CreateStreamFromResource() failed");
                }
            }
        }

        //
        // Get the layout info for this template...
        //

        CComPtr<IXMLDOMElement> pLayoutInfo;
        hr = _GetChildElement( pTheTemplate, TEXT("layout"), &pLayoutInfo );
        WIA_CHECK_HR(hr,"_GetChildElement( layout ) failed");

        if (SUCCEEDED(hr) && pLayoutInfo)
        {
            //
            // Get imageable area for template...
            //

            CComPtr<IXMLDOMElement>  pImageableArea;

            hr = _GetChildElement( pLayoutInfo, TEXT("imageable-area"), &pImageableArea );
            WIA_CHECK_HR(hr,"_GetChildElement( imageable-area ) failed");

            if (SUCCEEDED(hr) && pImageableArea)
            {
                ZeroMemory( &_rcImageableArea, sizeof(RECT) );

                hr = _GetProp<LONG>(pImageableArea, TEXT("x"), _rcImageableArea.left);
                WIA_CHECK_HR(hr,"_GetProp( _rcImageableArea.left ) failed");
                hr = _GetProp<LONG>(pImageableArea, TEXT("y"), _rcImageableArea.top);
                WIA_CHECK_HR(hr,"_GetProp( _rcImageableArea.top ) failed");
                hr = _GetProp<LONG>(pImageableArea, TEXT("w"), _rcImageableArea.right);
                WIA_CHECK_HR(hr,"_GetProp( _rcImageableArea.right ) failed");
                hr = _GetProp<LONG>(pImageableArea, TEXT("h"), _rcImageableArea.bottom);
                WIA_CHECK_HR(hr,"_GetProp( _rcImageableArea.bottom ) failed");

                //
                // Check for special case of all -1's, which
                // means to scale to full size of printable
                // area...
                //

                WIA_TRACE((TEXT("_rcImageableArea was read as (%d by %d) at (%d,%d)"),_rcImageableArea.right,_rcImageableArea.bottom,_rcImageableArea.left,_rcImageableArea.top));
                if ((-1 != _rcImageableArea.left)  ||
                    (-1 != _rcImageableArea.top)   ||
                    (-1 != _rcImageableArea.right) ||
                    (-1 != _rcImageableArea.bottom))
                {
                    //
                    // convert w, h to right & bootom
                    //

                    _rcImageableArea.right  += _rcImageableArea.left;
                    _rcImageableArea.bottom += _rcImageableArea.top;
                }
            }

            //
            // Get individual item rectangles for this template...
            //

            CComPtr<IXMLDOMNodeList> pListLayout;
            hr = pLayoutInfo->selectNodes(TEXT("image-def"), &pListLayout);
            WIA_CHECK_HR(hr,"pLayoutInfo->selectNodes( image-def ) failed");

            if (SUCCEEDED(hr) && pListLayout)
            {
                LONG length = 0;
                hr = pListLayout->get_length(&length);
                WIA_CHECK_HR(hr,"pListLayout->get_length() failed");

                if (SUCCEEDED(hr))
                {
                    if (length)
                    {
                        RECT                    rc;

                        for( long l = 0; l < length; l++ )
                        {

                            CComPtr<IXMLDOMNode>    pNode;
                            CComPtr<IXMLDOMElement> pItem;

                            hr = pListLayout->get_item(l, &pNode);
                            WIA_CHECK_HR(hr,"pListLayout->get_item() failed");

                            if (SUCCEEDED(hr) && pNode)
                            {
                                hr = pNode->QueryInterface(IID_IXMLDOMElement, (void **)&pItem);
                                WIA_CHECK_HR(hr,"pNode->QI( item XMLDOMElement )");

                                if (SUCCEEDED(hr) && pItem)
                                {
                                    ZeroMemory( &rc, sizeof(rc) );

                                    hr = _GetProp<LONG>(pItem, TEXT("x"), rc.left);
                                    WIA_CHECK_HR(hr,"_GetProp( item x ) failed");
                                    hr = _GetProp<LONG>(pItem, TEXT("y"), rc.top);
                                    WIA_CHECK_HR(hr,"_GetProp( item y ) failed");
                                    hr = _GetProp<LONG>(pItem, TEXT("w"), rc.right);
                                    WIA_CHECK_HR(hr,"_GetProp( item w ) failed");
                                    hr = _GetProp<LONG>(pItem, TEXT("h"), rc.bottom);
                                    WIA_CHECK_HR(hr,"_GetProp( item h ) failed");

                                    //
                                    // Check for special case of all -1's, which
                                    // means to scale to full size of printable
                                    // area...
                                    //

                                    if ((-1 != rc.left)  ||
                                        (-1 != rc.top)   ||
                                        (-1 != rc.right) ||
                                        (-1 != rc.bottom))
                                    {
                                        // convert w, h to right & bootom
                                        rc.right += rc.left;
                                        rc.bottom += rc.top;
                                    }


                                    //
                                    // insert the image definition
                                    //

                                    if (-1 == _arrLayout.Append( rc ))
                                    {
                                        WIA_ERROR((TEXT("Error adding item rectangle to list")));
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        WIA_ERROR((TEXT("pListLayout->get_length() returned 0 length!")));
                    }
                }
            }

        }


        //
        // Let go of backing COM object...
        //

        pTheTemplate->Release();

    }

}

CTemplateInfo::~CTemplateInfo()
{
    if (_pStream)
    {
        _pStream->Release();
        _pStream = NULL;
    }
}


static void RotateHelper(RECT * pRect, int nNewImageWidth, int nNewImageHeight, BOOL bClockwise)
{
    //
    // If we don't have a valid pointer, or all the coords are -1, then bail.
    // The -1 case denotes use all the area, and we don't want to muck with
    // that...
    //

    if (!pRect || ((pRect->left==-1) && (pRect->top==-1) && (pRect->right==-1) && (pRect->bottom==-1)))
    {
        return;
    }

    WIA_PUSH_FUNCTION_MASK((TRACE_TEMPLATE,TEXT("RotateHelper( pRect(%d,%d,%d,%d)  nNewImageWidth=%d  nImageHeight=%d  bClockwise=%d )"),pRect->left,pRect->top,pRect->right,pRect->bottom,nNewImageWidth,nNewImageHeight,bClockwise));

    //
    // The incoming data is going to be 2 points -- first is the upper left
    // coord of the original rectangle.  The second represents the
    // the width and the height.  The first coord needs to be rotated
    // 90 degrees, and then put back to the upper left of the rectangle.
    //
    //
    // The width and the height need to be flipped.
    //

    int nNewItemWidth  = pRect->bottom - pRect->top;
    int nNewItemHeight = pRect->right  - pRect->left;
    int nNewX, nNewY;

    if (bClockwise)
    {
        nNewX = nNewImageWidth - pRect->bottom;
        nNewY = pRect->left;
    }
    else
    {
        nNewX = pRect->top;
        nNewY = nNewImageHeight - pRect->right;
    }

    pRect->left   = nNewX;
    pRect->top    = nNewY;
    pRect->right  = nNewX + nNewItemWidth;
    pRect->bottom = nNewY + nNewItemHeight;

    WIA_TRACE((TEXT("On Exit: pRect(%d,%d,%d,%d)"),pRect->left,pRect->top,pRect->right,pRect->bottom));
}


HRESULT CTemplateInfo::RotateForLandscape()
{
    HRESULT hr = S_OK;

    WIA_PUSH_FUNCTION_MASK((TRACE_TEMPLATE,TEXT("CTemplateInfo::RotateForLandscape()")));

    CAutoCriticalSection lock(_cs);

    if (_bPortrait)
    {
        //
        // We only want to change this if it's a defined rect
        // (i.e, not "use all area")
        //

        if ((_rcImageableArea.left   != -1) &&
            (_rcImageableArea.top    != -1) &&
            (_rcImageableArea.right  != -1) &&
            (_rcImageableArea.bottom != -1))
        {
            //
            // The imageable area will just be a flip of width & height.
            // this relies on the fact the imageable area is always
            // described in terms of width & height (i.e., top & left
            // are always 0 in the RECT structure).
            //

            LONG oldWidth           = _rcImageableArea.right;
            _rcImageableArea.right  = _rcImageableArea.bottom;
            _rcImageableArea.bottom = oldWidth;
        }

        //
        // Now, map all the points for each item in the layout...
        //

        RECT * pRect;
        for (INT i=0; i < _arrLayout.Count(); i++)
        {
            pRect = &_arrLayout[i];
            RotateHelper( pRect, _rcImageableArea.right, _rcImageableArea.bottom, FALSE );
        }

        _bPortrait = FALSE;
    }
    else
    {
        WIA_TRACE((TEXT("Already in landscape mode, doing nothing...")));
    }

    WIA_RETURN_HR(hr);
}

HRESULT CTemplateInfo::RotateForPortrait()
{
    HRESULT hr = S_OK;

    WIA_PUSH_FUNCTION_MASK((TRACE_TEMPLATE,TEXT("CTemplateInfo::RotateForPortrait()")));

    CAutoCriticalSection lock(_cs);

    if (!_bPortrait)
    {
        //
        // The imageable area will just be a flip of width & height.
        // this relies on the fact the imageable area is always
        // described in terms of width & height (i.e., top & left
        // are always 0 in the RECT structure).
        //

        LONG oldWidth           = _rcImageableArea.right;
        _rcImageableArea.right  = _rcImageableArea.bottom;
        _rcImageableArea.bottom = oldWidth;

        //
        // Now, map all the points for each item in the layout...
        //

        RECT * pRect;
        for (INT i=0; i < _arrLayout.Count(); i++)
        {
            pRect = &_arrLayout[i];
            RotateHelper( pRect, _rcImageableArea.right, _rcImageableArea.bottom, TRUE );
        }

        _bPortrait = TRUE;
    }
    else
    {
        WIA_TRACE((TEXT("Already in portrait mode, doing nothing...")));
    }


    WIA_RETURN_HR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prevwnd\prevwnd.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       PREVWND.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/9/1998
 *
 *  DESCRIPTION: Scanner Preview Control
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "prevwnd.h"
#include "pviewids.h"
#include "simcrack.h"
#include "miscutil.h"
#include "simrect.h"
#include "waitcurs.h"
#include "comctrlp.h"
#include "dlgunits.h"
#include "simrect.h"

#define IDC_PROGRESSCONTROL 100

#undef DITHER_DISABLED_CONTROL

//
// The range of image sizes for which we will detect regions.
//
#define MIN_REGION_DETECTION_X 100
#define MIN_REGION_DETECTION_Y 100
#define MAX_REGION_DETECTION_X 1275
#define MAX_REGION_DETECTION_Y 2100

#if defined(OLD_CRAPPY_HOME_SETUP)
static HINSTANCE g_hMsImgInst=LoadLibrary( TEXT("msimg32.dll") );
static AlphaBlendFn AlphaBlend=(AlphaBlendFn)GetProcAddress( g_hMsImgInst, "AlphaBlend" );
#endif


/*
 * Mouse hit test codes
 */
#define HIT_NONE            0x0000
#define HIT_BORDER          0x0001
#define HIT_TOP             0x0002
#define HIT_BOTTOM          0x0004
#define HIT_LEFT            0x0008
#define HIT_RIGHT           0x0010
#define HIT_SELECTED        0x0020
#define HIT_TOPLEFT         (HIT_TOP|HIT_LEFT)
#define HIT_TOPRIGHT        (HIT_TOP|HIT_RIGHT)
#define HIT_BOTTOMLEFT      (HIT_BOTTOM|HIT_LEFT)
#define HIT_BOTTOMRIGHT     (HIT_BOTTOM|HIT_RIGHT)


/*
 * Defaults
 */
#define DEFAULT_ACCEL_FACTOR                   8
#define DEFAULT_HANDLE_SIZE                    6
#define DEFAULT_BORDER                         6
#define DEFAULT_BG_ALPHA                       96

#define DEFAULT_SELECTED_HANDLE_FILL_COLOR     RGB(0,128,0)
#define DEFAULT_UNSELECTED_HANDLE_FILL_COLOR   RGB(128,0,0)
#define DEFAULT_DISABLED_HANDLE_FILL_COLOR     GetSysColor(COLOR_3DSHADOW)

#define DEFAULT_SELECTED_BORDER_COLOR          RGB(0,0,0)
#define DEFAULT_UNSELECTED_BORDER_COLOR        RGB(0,0,0)
#define DEFAULT_DISABLED_BORDER_COLOR          GetSysColor(COLOR_3DSHADOW)

#define DEFAULT_SELECTION_HANDLE_SHADOW        RGB(128,128,128)
#define DEFAULT_SELECTION_HANDLE_HIGHLIGHT     RGB(255,255,255)

#define DEFAULT_HANDLE_TYPE                    (PREVIEW_WINDOW_SQUAREHANDLES|PREVIEW_WINDOW_FILLEDHANDLES)

#define DEFAULT_BORDER_STYLE                   PS_DOT

#define BORDER_SELECTION_PEN_THICKNESS         0

#define REGION_DETECTION_BORDER                1

static inline RECT CreateRect( int left, int top, int right, int bottom )
{
    RECT r;
    r.left = left;
    r.top = top;
    r.right = right;
    r.bottom = bottom;
    return(r);
}

static HBRUSH CreateDitheredPatternBrush(void)
{
    const BYTE s_GrayBitmapBits[] = {
        0xAA, 0x00,
        0x55, 0x00,
        0xAA, 0x00,
        0x55, 0x00,
        0xAA, 0x00,
        0x55, 0x00,
        0xAA, 0x00,
        0x55, 0x00
    };
    HBITMAP hBmp = CreateBitmap( 8, 8, 1, 1, s_GrayBitmapBits );
    if (hBmp)
    {
        HBRUSH hbrPatBrush = CreatePatternBrush(hBmp);
        DeleteObject(hBmp);
        return(hbrPatBrush);
    }
    return(NULL);
}


static void DitherRect( HDC hDC, RECT &rc )
{
    const DWORD ROP_DPNA = 0x000A0329;
    HBRUSH hbr = CreateDitheredPatternBrush();
    if (hbr)
    {
        HBRUSH hbrOld = (HBRUSH)SelectObject(hDC, hbr);
        PatBlt( hDC, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, ROP_DPNA );
        SelectObject( hDC, hbrOld );
        DeleteObject( hbr );
    }
}

static inline int PointInRect( const RECT &rc, const POINT &pt )
{
    return(PtInRect(&rc,pt));
}

static inline int Boundary( int val, int min, int max )
{
    if (val < min)
        return(min);
    if (val > max)
        return(max);
    return(val);
}

template <class T>
static inline T Minimum( const T &a, const T &b )
{
    return(a < b) ? a : b;
}

template <class T>
static inline T Maximum( const T &a, const T &b )
{
    return(a > b) ? a : b;
}

// Just like API UnionRect, but handles empty rects
static void TrueUnionRect( RECT *prcDest, const RECT *prcSrc1, const RECT *prcSrc2 )
{
    prcDest->left = Minimum( prcSrc1->left, prcSrc2->left );
    prcDest->right = Maximum( prcSrc1->right, prcSrc2->right );
    prcDest->top = Minimum( prcSrc1->top, prcSrc2->top );
    prcDest->bottom = Maximum( prcSrc1->bottom, prcSrc2->bottom );
}

// Constructor
CWiaPreviewWindow::CWiaPreviewWindow( HWND hWnd )
  : m_hWnd(hWnd),
    m_bDeleteBitmap(TRUE),
    m_bSizing(FALSE),
    m_bAllowNullSelection(FALSE),
    m_hBufferBitmap(NULL),
    m_hPaintBitmap(NULL),
    m_hAlphaBitmap(NULL),
    m_hPreviewBitmap(NULL),
    m_hCursorArrow(LoadCursor(NULL,IDC_ARROW)),
    m_hCursorCrossHairs(LoadCursor(NULL,IDC_CROSS)),
    m_hCursorMove(LoadCursor(NULL,IDC_SIZEALL)),
    m_hCursorSizeNS(LoadCursor(NULL,IDC_SIZENS)),
    m_hCursorSizeNeSw(LoadCursor(NULL,IDC_SIZENESW)),
    m_hCursorSizeNwSe(LoadCursor(NULL,IDC_SIZENWSE)),
    m_hCursorSizeWE(LoadCursor(NULL,IDC_SIZEWE)),
    m_MovingSel(HIT_NONE),
    m_nBorderSize(DEFAULT_BORDER),
    m_nHandleType(DEFAULT_HANDLE_TYPE),
    m_nHandleSize(DEFAULT_HANDLE_SIZE),
    m_hHalftonePalette(NULL),
    m_nCurrentRect(0),
    m_hBackgroundBrush(CreateSolidBrush(GetSysColor(COLOR_WINDOW))),
    m_bPreviewMode(false),
    m_bSuccessfulRegionDetection(false),
    m_bUserChangedSelection(false)
{
    ZeroMemory(&m_rcCurrSel,sizeof(m_rcCurrSel));
    ZeroMemory(&m_rcSavedImageRect,sizeof(m_rcSavedImageRect));
    ZeroMemory(&m_Resolution,sizeof(m_Resolution));
    ZeroMemory(&m_Delta,sizeof(m_Delta));
    ZeroMemory(&m_bfBlendFunction,sizeof(m_bfBlendFunction));
    ZeroMemory(&m_rcSavedImageRect,sizeof(m_rcSavedImageRect));

    m_bfBlendFunction.BlendOp = AC_SRC_OVER;
    m_bfBlendFunction.SourceConstantAlpha = DEFAULT_BG_ALPHA;

    m_aHandlePens[Selected]   = CreatePen( PS_SOLID|PS_INSIDEFRAME, BORDER_SELECTION_PEN_THICKNESS, DEFAULT_SELECTED_BORDER_COLOR );
    m_aHandlePens[Unselected] = CreatePen( PS_SOLID|PS_INSIDEFRAME, BORDER_SELECTION_PEN_THICKNESS, DEFAULT_UNSELECTED_BORDER_COLOR );
    m_aHandlePens[Disabled]   = CreatePen( PS_SOLID|PS_INSIDEFRAME, BORDER_SELECTION_PEN_THICKNESS, DEFAULT_DISABLED_BORDER_COLOR );

    m_aBorderPens[Selected]   = CreatePen( DEFAULT_BORDER_STYLE, BORDER_SELECTION_PEN_THICKNESS, DEFAULT_SELECTED_BORDER_COLOR );
    m_aBorderPens[Unselected] = CreatePen( DEFAULT_BORDER_STYLE, BORDER_SELECTION_PEN_THICKNESS, DEFAULT_UNSELECTED_BORDER_COLOR );
    m_aBorderPens[Disabled]   = CreatePen( DEFAULT_BORDER_STYLE, BORDER_SELECTION_PEN_THICKNESS, DEFAULT_DISABLED_BORDER_COLOR );

    m_aHandleBrushes[Selected]   = CreateSolidBrush( DEFAULT_SELECTED_HANDLE_FILL_COLOR );
    m_aHandleBrushes[Unselected] = CreateSolidBrush( DEFAULT_UNSELECTED_HANDLE_FILL_COLOR );
    m_aHandleBrushes[Disabled]   = CreateSolidBrush( DEFAULT_DISABLED_HANDLE_FILL_COLOR );

    m_hHandleShadow     = CreatePen( PS_SOLID|PS_INSIDEFRAME, BORDER_SELECTION_PEN_THICKNESS, DEFAULT_SELECTION_HANDLE_SHADOW);
    m_hHandleHighlight  = CreatePen( PS_SOLID|PS_INSIDEFRAME, BORDER_SELECTION_PEN_THICKNESS, DEFAULT_SELECTION_HANDLE_HIGHLIGHT);

}

void CWiaPreviewWindow::DestroyBitmaps(void)
{
    if (m_hPaintBitmap)
    {
        DeleteObject(m_hPaintBitmap);
        m_hPaintBitmap = NULL;
    }
    if (m_hBufferBitmap)
    {
        DeleteObject(m_hBufferBitmap);
        m_hBufferBitmap = NULL;
    }
    if (m_hAlphaBitmap)
    {
        DeleteObject(m_hAlphaBitmap);
        m_hAlphaBitmap = NULL;
    }
}


CWiaPreviewWindow::~CWiaPreviewWindow()
{
    DestroyBitmaps();

    if (m_bDeleteBitmap && m_hPreviewBitmap)
    {
        DeleteObject(m_hPreviewBitmap);
        m_hPreviewBitmap = NULL;
    }
    else
    {
        m_hPreviewBitmap = NULL;
    }

    if (m_hHalftonePalette)
    {
        DeleteObject(m_hHalftonePalette);
        m_hHalftonePalette = NULL;
    }

    // Destroy all of the handle pens
    for (int i=0;i<ARRAYSIZE(m_aHandlePens);i++)
    {
        if (m_aHandlePens[i])
        {
            DeleteObject(m_aHandlePens[i]);
            m_aHandlePens[i] = NULL;
        }
    }

    // Destroy all of the selection rectangle pens
    for (i=0;i<ARRAYSIZE(m_aBorderPens);i++)
    {
        if (m_aBorderPens[i])
        {
            DeleteObject(m_aBorderPens[i]);
            m_aBorderPens[i] = NULL;
        }
    }

    // Destroy all of the brushes
    for (i=0;i<ARRAYSIZE(m_aHandleBrushes);i++)
    {
        if (m_aHandleBrushes[i])
        {
            DeleteObject(m_aHandleBrushes[i]);
            m_aHandleBrushes[i] = NULL;
        }
    }

    if (m_hHandleHighlight)
    {
        DeleteObject(m_hHandleHighlight);
        m_hHandleHighlight = NULL;
    }

    if (m_hHandleShadow)
    {
        DeleteObject(m_hHandleShadow);
        m_hHandleShadow = NULL;
    }

    if (m_hBackgroundBrush)
    {
        DeleteObject(m_hBackgroundBrush);
        m_hBackgroundBrush = NULL;
    }

    m_hWnd = NULL;

    // Zero out all of the cursors.  No need to free them
    m_hCursorSizeNeSw = NULL;
    m_hCursorSizeNwSe = NULL;
    m_hCursorCrossHairs = NULL;
    m_hCursorMove = NULL;
    m_hCursorSizeNS = NULL;
    m_hCursorSizeWE = NULL;
    m_hCursorArrow = NULL;
}

void CWiaPreviewWindow::Repaint( PRECT pRect, bool bErase )
{
    InvalidateRect( m_hWnd, pRect, (bErase != false) );
    UpdateWindow( m_hWnd );
}

void CWiaPreviewWindow::DrawHandle( HDC dc, const RECT &r, int nState )
{
    HPEN hOldPen = (HPEN)SelectObject( dc, m_aHandlePens[nState] );
    HBRUSH hOldBrush = (HBRUSH)SelectObject( dc, m_aHandleBrushes[nState] );

    if (PREVIEW_WINDOW_HOLLOWHANDLES&m_nHandleType)
    {
        SelectObject( dc, GetStockObject(NULL_BRUSH) );
    }

    if (PREVIEW_WINDOW_ROUNDHANDLES&m_nHandleType)
    {
        Ellipse(dc,r.left,r.top,r.right,r.bottom);
        if (!(PREVIEW_WINDOW_HOLLOWHANDLES&m_nHandleType))
        {
            RECT rcHighlight = r;
            InflateRect(&rcHighlight,-1,-1);
            SelectObject(dc,GetStockObject(NULL_BRUSH));
            SelectObject(dc,m_hHandleShadow);
            Arc(dc,rcHighlight.left,rcHighlight.top,rcHighlight.right,rcHighlight.bottom,rcHighlight.left,rcHighlight.bottom,rcHighlight.right,rcHighlight.top);
            SelectObject(dc,m_hHandleHighlight);
            Arc(dc,rcHighlight.left,rcHighlight.top,rcHighlight.right,rcHighlight.bottom,rcHighlight.right,rcHighlight.top,rcHighlight.left,rcHighlight.bottom);
        }
    }
    else
    {
        Rectangle(dc,r.left,r.top,r.right,r.bottom);
        if (!(PREVIEW_WINDOW_HOLLOWHANDLES&m_nHandleType))
        {
            RECT rcHighlight = r;
            InflateRect(&rcHighlight,-1,-1);
            rcHighlight.right--;
            rcHighlight.bottom--;
            if (!IsRectEmpty(&rcHighlight))
            {
                SelectObject(dc,m_hHandleHighlight);
                MoveToEx(dc,rcHighlight.left,rcHighlight.bottom,NULL);
                LineTo(dc,rcHighlight.left,rcHighlight.top);
                LineTo(dc,rcHighlight.right,rcHighlight.top);
                SelectObject(dc,m_hHandleShadow);
                LineTo(dc,rcHighlight.right,rcHighlight.bottom);
                LineTo(dc,rcHighlight.left,rcHighlight.bottom);
            }
        }
    }

    SelectObject( dc, hOldPen );
    SelectObject( dc, hOldBrush );
}

RECT CWiaPreviewWindow::GetSizingHandleRect( const RECT &rcSelection, int iWhich )
{
    RECT rcSel;
    CopyRect(&rcSel,&rcSelection);
    NormalizeRect(rcSel);
    int sizeWidth = Minimum<int>(m_nHandleSize,WiaUiUtil::RectWidth(rcSel)/2);
    int sizeHeight = Minimum<int>(m_nHandleSize,WiaUiUtil::RectHeight(rcSel)/2);
    switch (iWhich)
    {
    case HIT_TOPLEFT:
        return(CreateRect( rcSel.left - m_nHandleSize, rcSel.top - m_nHandleSize, rcSel.left + sizeWidth, rcSel.top + sizeHeight ));
    case HIT_TOPRIGHT:
        return(CreateRect( rcSel.right - sizeWidth, rcSel.top - m_nHandleSize, rcSel.right + m_nHandleSize, rcSel.top + sizeHeight));
    case HIT_BOTTOMRIGHT:
        return(CreateRect( rcSel.right - sizeWidth, rcSel.bottom - sizeHeight, rcSel.right + m_nHandleSize, rcSel.bottom + m_nHandleSize  ));
    case HIT_BOTTOMLEFT:
        return(CreateRect( rcSel.left - m_nHandleSize, rcSel.bottom - sizeHeight, rcSel.left + sizeWidth, rcSel.bottom + m_nHandleSize ));
    default:
        return(CreateRect(0,0,0,0));
    }
}


RECT CWiaPreviewWindow::GetSelectionRect( RECT &rcSel, int iWhich )
{
    switch (iWhich)
    {
    case HIT_LEFT:
        return(CreateRect( rcSel.left-m_nHandleSize,rcSel.top-m_nHandleSize,rcSel.left+m_nHandleSize,rcSel.bottom+m_nHandleSize));
    case HIT_RIGHT:
        return(CreateRect( rcSel.right-m_nHandleSize, rcSel.top-m_nHandleSize, rcSel.right+m_nHandleSize, rcSel.bottom+m_nHandleSize ));
    case HIT_TOP:
        return(CreateRect( rcSel.left-m_nHandleSize, rcSel.top-m_nHandleSize, rcSel.right+m_nHandleSize, rcSel.top+m_nHandleSize ));
    case HIT_BOTTOM:
        return(CreateRect( rcSel.left-m_nHandleSize, rcSel.bottom-m_nHandleSize, rcSel.right+m_nHandleSize, rcSel.bottom+m_nHandleSize ));
    default:
        return(CreateRect(0,0,0,0));
    }
}


POINT CWiaPreviewWindow::GetCornerPoint( int iWhich )
{
    RECT rcTmp(m_rcCurrSel);
    NormalizeRect(m_rcCurrSel);
    POINT pt;
    pt.x = pt.y = 0;
    if (iWhich & HIT_TOP)
        pt.y = rcTmp.top;
    if (iWhich & HIT_BOTTOM)
        pt.y = rcTmp.bottom;
    if (iWhich & HIT_RIGHT)
        pt.x = rcTmp.right;
    if (iWhich & HIT_LEFT)
        pt.x = rcTmp.left;
    return(pt);
}

void CWiaPreviewWindow::DrawSizingFrame( HDC dc, RECT &rc, bool bHasFocus, bool bDisabled )
{
    RECT rcTmp;
    CopyRect(&rcTmp,&rc);
    NormalizeRect(rcTmp);

    int nState = Unselected;
    if (bDisabled)
        nState = Disabled;
    else if (bHasFocus)
        nState = Selected;

    HPEN hOldPen = (HPEN)SelectObject(dc,m_aBorderPens[nState]);
    HBRUSH  hOldBrush = (HBRUSH)SelectObject(dc,GetStockObject(NULL_BRUSH));
    COLORREF crOldColor = SetBkColor(dc,RGB(255,255,255));
    int nOldROP2 = SetROP2(dc,R2_COPYPEN);

    Rectangle(dc,rcTmp.left,rcTmp.top,rcTmp.right,rcTmp.bottom);

    DrawHandle( dc, GetSizingHandleRect( rcTmp, HIT_TOPLEFT ), nState );
    DrawHandle( dc, GetSizingHandleRect( rcTmp, HIT_TOPRIGHT ), nState );
    DrawHandle( dc, GetSizingHandleRect( rcTmp, HIT_BOTTOMLEFT ), nState );
    DrawHandle( dc, GetSizingHandleRect( rcTmp, HIT_BOTTOMRIGHT ), nState );

    SetROP2(dc,nOldROP2);
    SetBkColor(dc,crOldColor);
    SelectObject(dc,hOldBrush);
    SelectObject(dc,hOldPen);
}

bool CWiaPreviewWindow::IsAlphaBlendEnabled(void)
{
    return(m_bfBlendFunction.SourceConstantAlpha != 0xFF);
}

HPALETTE CWiaPreviewWindow::SetHalftonePalette( HDC hDC )
{
    if (m_hHalftonePalette)
    {
        HPALETTE hOldPalette = SelectPalette( hDC, m_hHalftonePalette, FALSE );
        RealizePalette( hDC );
        SetBrushOrgEx( hDC, 0,0, NULL );
        return(hOldPalette);
    }
    else
    {
        HPALETTE hOldPalette = SelectPalette( hDC, (HPALETTE)GetStockObject(DEFAULT_PALETTE), FALSE );
        RealizePalette( hDC );
        return(hOldPalette);
    }
}

void CWiaPreviewWindow::PaintWindowTitle( HDC hDC )
{
    //
    // Get the length of the caption text
    //
    int nTextLen = (int)SendMessage( m_hWnd, WM_GETTEXTLENGTH, 0, 0 );
    if (nTextLen >= 0)
    {
        //
        // Allocate a buffer to hold it
        //
        LPTSTR pszText = new TCHAR[nTextLen+1];
        if (pszText)
        {
            //
            // Get the text
            //
            if (SendMessage( m_hWnd, WM_GETTEXT, nTextLen+1, (LPARAM)pszText ))
            {
                //
                // Save the DC's state
                //
                int nDrawTextFlags = DT_CENTER|DT_NOPREFIX|DT_WORDBREAK;
                COLORREF crOldTextColor = SetTextColor( hDC, GetSysColor( COLOR_WINDOWTEXT ) );
                int nOldBkMode = SetBkMode( hDC, TRANSPARENT );

                //
                // Get the size of the image rectangle
                //
                RECT rcImage = GetImageRect();
                RECT rcAvailable = rcImage;

                //
                // Leave some space for a margin
                //
                rcAvailable.right -= 20;

                //
                // Get the control's font, if there is one
                //
                HFONT hOldFont = NULL, hWndFont = WiaUiUtil::GetFontFromWindow( m_hWnd );
                
                //
                // Set the DC's font
                //
                if (hWndFont)
                {
                    hOldFont = reinterpret_cast<HFONT>(SelectObject( hDC, hWndFont ));
                }

                //
                // Calculate the size of the text
                //
                RECT rcText = {0};
                if (DrawText( hDC, pszText, lstrlen(pszText), &rcAvailable, nDrawTextFlags|DT_CALCRECT ))
                {
                    //
                    // add the extra margin back in and form the text rectangle
                    //
                    rcAvailable.right += 20;
                    
                    //
                    // Calculate the text size
                    //
                    rcText.left = rcImage.left + (WiaUiUtil::RectWidth(rcImage) - WiaUiUtil::RectWidth(rcAvailable))/2;
                    rcText.top = rcImage.top + (WiaUiUtil::RectHeight(rcImage) - WiaUiUtil::RectHeight(rcAvailable))/2;
                    rcText.right = rcText.left + WiaUiUtil::RectWidth(rcAvailable);
                    rcText.bottom = rcText.top + WiaUiUtil::RectHeight(rcAvailable);
                }
                
                //
                // See if the progress control is active
                //
                HWND hWndProgress = GetDlgItem( m_hWnd, IDC_PROGRESSCONTROL );
                if (hWndProgress)
                {
                    //
                    // Get the window rect of the progress control
                    //
                    CSimpleRect ProgressRect( hWndProgress, CSimpleRect::WindowRect );

                    //
                    // Move the y origin of the text up
                    //
                    rcText.top = ProgressRect.ScreenToClient(m_hWnd).top - CDialogUnits(m_hWnd).Y(3) - WiaUiUtil::RectHeight(rcText);

                    //
                    // Resize the text rectangle to encompass the bottom of the progress control
                    //
                    rcText.bottom = ProgressRect.ScreenToClient(m_hWnd).bottom;
                }

                //
                // Draw the background rectangle and the text
                //
                RECT rcBorder = { rcImage.left + CDialogUnits(m_hWnd).X(7), rcText.top - CDialogUnits(m_hWnd).X(3), rcImage.right - CDialogUnits(m_hWnd).X(7), rcText.bottom + CDialogUnits(m_hWnd).X(3) };
                FillRect( hDC, &rcBorder, GetSysColorBrush(COLOR_WINDOW));
                FrameRect( hDC, &rcBorder, GetSysColorBrush(COLOR_WINDOWFRAME));
                DrawText( hDC, pszText, lstrlen(pszText), &rcText, nDrawTextFlags );

                //
                // Restore the DC to its original condition
                //
                if (hWndFont)
                {
                    SelectObject( hDC, hOldFont );
                }
                SetTextColor( hDC, crOldTextColor );
                SetBkMode( hDC, nOldBkMode );
            }
            delete[] pszText;
        }
    }
}

LRESULT CWiaPreviewWindow::OnPaint( WPARAM, LPARAM )
{
    PAINTSTRUCT ps;
    HDC hDC;
    RECT rcIntersection, rcImage = GetImageRect(), rcCurrentSelection;

    hDC = BeginPaint(m_hWnd,&ps);
    if (hDC)
    {
        if (!m_hBufferBitmap)
        {
            FillRect( hDC, &ps.rcPaint, m_hBackgroundBrush );
            PaintWindowTitle( hDC );
        }
        else
        {
            // Select the halftone palette
            HPALETTE hOldDCPalette = SetHalftonePalette( hDC );
            HDC hdcMem = CreateCompatibleDC(hDC);
            if (hdcMem)
            {
                HPALETTE hOldMemDCPalette = SetHalftonePalette( hdcMem );
                HDC hdcBuffer = CreateCompatibleDC(hDC);
                if (hdcBuffer)
                {
                    HPALETTE hOldBufferDCPalette = SetHalftonePalette( hdcBuffer );
                    HBITMAP hOldBufferDCBitmap = (HBITMAP)SelectObject(hdcBuffer,m_hBufferBitmap);

                    CopyRect(&rcCurrentSelection,&m_rcCurrSel);
                    NormalizeRect(rcCurrentSelection);
                    if (IsDefaultSelectionRect(rcCurrentSelection))
                        rcCurrentSelection = rcImage;
                    // Prepare the double buffer bitmap by painting the selected and non-selected regions
                    if (m_hAlphaBitmap && m_bfBlendFunction.SourceConstantAlpha != 0xFF && !m_bPreviewMode)
                    {
                        HBITMAP hOldMemDCBitmap = (HBITMAP)SelectObject(hdcMem,m_hAlphaBitmap);
                        BitBlt(hdcBuffer,ps.rcPaint.left,ps.rcPaint.top,WiaUiUtil::RectWidth(ps.rcPaint),WiaUiUtil::RectHeight(ps.rcPaint),hdcMem,ps.rcPaint.left,ps.rcPaint.top,SRCCOPY);
                        SelectObject(hdcMem,m_hPaintBitmap);
                        if (IntersectRect( &rcIntersection, &ps.rcPaint, &rcCurrentSelection ))
                            BitBlt(hdcBuffer,rcIntersection.left,rcIntersection.top,WiaUiUtil::RectWidth(rcIntersection),WiaUiUtil::RectHeight(rcIntersection),hdcMem,rcIntersection.left,rcIntersection.top,SRCCOPY);
                        SelectObject(hdcMem,hOldMemDCBitmap);
                    }
                    else if (m_hPaintBitmap)
                    {
                        HBITMAP hOldMemDCBitmap = (HBITMAP)SelectObject(hdcMem,m_hPaintBitmap);
                        BitBlt(hdcBuffer,ps.rcPaint.left,ps.rcPaint.top,WiaUiUtil::RectWidth(ps.rcPaint),WiaUiUtil::RectHeight(ps.rcPaint),hdcMem,ps.rcPaint.left,ps.rcPaint.top,SRCCOPY);
                        SelectObject(hdcMem,hOldMemDCBitmap);
                    }
                    else
                    {
                        FillRect( hdcBuffer, &ps.rcPaint, m_hBackgroundBrush );
                    }

                    bool bDisabled = ((GetWindowLong(m_hWnd,GWL_STYLE)&WS_DISABLED) != 0);
#if defined(DITHER_DISABLED_CONTROL)
                    if (bDisabled)
                    {
                        // paint the disabled mask
                        if (IntersectRect( &rcIntersection, &rcImage, &ps.rcPaint ))
                            DitherRect(hdcBuffer,rcIntersection);
                    }
#endif // DITHER_DISABLED_CONTROL
                    //
                    // paint the selection rectangle
                    //
                    rcCurrentSelection = m_rcCurrSel;
                    NormalizeRect(rcCurrentSelection);
                    if (!IsDefaultSelectionRect( rcCurrentSelection ) && !m_bPreviewMode)
                    {
                        DrawSizingFrame( hdcBuffer, rcCurrentSelection, (GetFocus()==m_hWnd), bDisabled );
                    }
                    PaintWindowTitle( hdcBuffer );
                    // show it!
                    BitBlt( hDC, ps.rcPaint.left, ps.rcPaint.top, WiaUiUtil::RectWidth(ps.rcPaint), WiaUiUtil::RectHeight(ps.rcPaint),hdcBuffer,ps.rcPaint.left,ps.rcPaint.top,SRCCOPY);

                    // Paint all of the area outside the buffer bitmap
                    RECT rcClient;
                    GetClientRect( m_hWnd, &rcClient );
                    BITMAP bm;
                    if (GetObject( m_hBufferBitmap, sizeof(BITMAP), &bm ))
                    {
                        if (ps.rcPaint.right > bm.bmWidth)
                        {
                            RECT rc;
                            rc.left = bm.bmWidth;
                            rc.top = ps.rcPaint.top;
                            rc.right = rcClient.right;
                            rc.bottom = rcClient.bottom;
                            FillRect( hDC, &rc, m_hBackgroundBrush );
                        }
                        if (ps.rcPaint.bottom > bm.bmHeight)
                        {
                            RECT rc;
                            rc.left = ps.rcPaint.left;
                            rc.top = bm.bmHeight;
                            rc.right = bm.bmWidth;
                            rc.bottom = rcClient.bottom;
                            FillRect( hDC, &rc, m_hBackgroundBrush );
                        }
                    }

                    SelectObject( hdcBuffer, hOldBufferDCBitmap );
                    SelectPalette( hdcBuffer, hOldBufferDCPalette, FALSE );
                    DeleteDC(hdcBuffer);
                }
                SelectPalette( hdcMem, hOldMemDCPalette, FALSE );
                DeleteDC( hdcMem );
            }
            SelectPalette( hDC, hOldDCPalette, FALSE );
        }
        EndPaint(m_hWnd,&ps);
    }
    return(LRESULT)0;
}


BOOL CWiaPreviewWindow::RegisterClass( HINSTANCE hInstance )
{
    WNDCLASS wc;
    memset( &wc, 0, sizeof(wc) );
    wc.style = CS_DBLCLKS;
    wc.cbWndExtra = sizeof(CWiaPreviewWindow*);
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszClassName = PREVIEW_WINDOW_CLASS;
    BOOL res = (::RegisterClass(&wc) != 0);
    return(res != 0);
}


RECT CWiaPreviewWindow::GetImageRect(void)
{
    RECT rcImg;
    ::GetClientRect( m_hWnd, &rcImg );
    InflateRect( &rcImg, -static_cast<int>(m_nBorderSize), -static_cast<int>(m_nBorderSize) );
    return(rcImg);
}

int CWiaPreviewWindow::GetHitArea( POINT &pt )
{
    RECT rcTmp;
    CopyRect(&rcTmp,&m_rcCurrSel);
    NormalizeRect(rcTmp);
    int Hit = 0;

    if (PointInRect(GetSelectionRect(rcTmp,HIT_TOP),pt))
        Hit |= HIT_TOP;
    else if (PointInRect(GetSelectionRect(rcTmp,HIT_BOTTOM),pt))
        Hit |= HIT_BOTTOM;

    if (PointInRect(GetSelectionRect(rcTmp,HIT_LEFT),pt))
        Hit |= HIT_LEFT;
    else if (PointInRect(GetSelectionRect(rcTmp,HIT_RIGHT),pt))
        Hit |= HIT_RIGHT;

    if (!Hit && PointInRect(rcTmp,pt))
        Hit = HIT_SELECTED;

    if (!Hit && !PointInRect(GetImageRect(),pt))
        Hit = HIT_BORDER;
    return(Hit);
}


void CWiaPreviewWindow::NormalizeRect( RECT &r )
{
    if (r.right < r.left)
    {
        int t = r.left;
        r.left = r.right;
        r.right = t;
    }
    if (r.bottom < r.top)
    {
        int t = r.top;
        r.top = r.bottom;
        r.bottom = t;
    }
}

LRESULT CWiaPreviewWindow::OnMouseMove( WPARAM wParam, LPARAM lParam )
{
    POINT point;
    if (!m_hPreviewBitmap || m_SelectionDisabled || m_bPreviewMode)
    {
        SetCursor(m_hCursorArrow);
        return(0);
    }
    point.x = (short int)LOWORD(lParam);
    point.y = (short int)HIWORD(lParam);
    RECT rcClient = GetImageRect();

    RECT rcOldSel;
    CopyRect(&rcOldSel,&m_rcCurrSel);
    if (m_MovingSel != HIT_NONE)
    {
        switch (m_MovingSel)
        {
        case HIT_SELECTED:
            {
                int Width = WiaUiUtil::RectWidth(m_rcCurrSel);
                int Height = WiaUiUtil::RectHeight(m_rcCurrSel);
                if (point.x + m_Delta.cx < rcClient.left)
                    point.x = 0 - m_Delta.cx + rcClient.left;
                else if (point.x + m_Delta.cx + Width > rcClient.right)
                    point.x = rcClient.right - Width - m_Delta.cx;
                if (point.y + m_Delta.cy < rcClient.top)
                    point.y = 0 - m_Delta.cy + rcClient.top;
                else if (point.y + m_Delta.cy + Height > rcClient.bottom)
                    point.y = rcClient.bottom - Height - m_Delta.cy;
                m_rcCurrSel.left = point.x + m_Delta.cx;
                m_rcCurrSel.right = m_rcCurrSel.left + Width;
                m_rcCurrSel.top = point.y + m_Delta.cy;
                m_rcCurrSel.bottom = m_rcCurrSel.top + Height;
            }
            break;
        default:
            if (m_MovingSel & HIT_TOP)
                m_rcCurrSel.top = Boundary(point.y + m_Delta.cy,rcClient.top,rcClient.bottom);
            if (m_MovingSel & HIT_BOTTOM)
                m_rcCurrSel.bottom = Boundary(point.y + m_Delta.cy,rcClient.top,rcClient.bottom);
            if (m_MovingSel & HIT_LEFT)
                m_rcCurrSel.left = Boundary(point.x + m_Delta.cx,rcClient.left,rcClient.right);
            if (m_MovingSel & HIT_RIGHT)
                m_rcCurrSel.right = Boundary(point.x + m_Delta.cx,rcClient.left,rcClient.right);
            break;
        }
        if (memcmp(&rcOldSel,&m_rcCurrSel,sizeof(RECT)))
        {
            RECT rcCurSel = m_rcCurrSel, rcInvalid;
            NormalizeRect(rcOldSel);
            NormalizeRect(rcCurSel);
            TrueUnionRect(&rcInvalid,&rcCurSel,&rcOldSel);
            rcInvalid.left-=m_nHandleSize;
            rcInvalid.top-=m_nHandleSize;
            rcInvalid.right+=m_nHandleSize;
            rcInvalid.bottom+=m_nHandleSize;
            SendSelChangeNotification();
            Repaint(&rcInvalid,false);
            UpdateWindow(m_hWnd);
        }
    }
    int Hit;
    if (m_MovingSel == HIT_NONE)
    {
        if (wParam & MK_CONTROL)
            Hit = HIT_NONE;
        else Hit = GetHitArea(point);
        if (Hit == HIT_SELECTED)
            SetCursor(m_hCursorMove);
        else if (Hit == HIT_NONE)
            SetCursor(m_hCursorCrossHairs);
        else if (Hit == HIT_TOPLEFT || Hit == HIT_BOTTOMRIGHT)
            SetCursor(m_hCursorSizeNwSe);
        else if (Hit == HIT_TOPRIGHT || Hit == HIT_BOTTOMLEFT)
            SetCursor(m_hCursorSizeNeSw);
        else if (Hit == HIT_TOP || Hit == HIT_BOTTOM)
            SetCursor(m_hCursorSizeNS);
        else if (Hit == HIT_BORDER)
            SetCursor(m_hCursorArrow);
        else SetCursor(m_hCursorSizeWE);
    }
    else
    {
        Hit = m_MovingSel;
        if (Hit == HIT_SELECTED)
            SetCursor(m_hCursorMove);
        else if (Hit == HIT_TOP || Hit == HIT_BOTTOM)
            SetCursor(m_hCursorSizeNS);
        else if (Hit == HIT_LEFT || Hit == HIT_RIGHT)
            SetCursor(m_hCursorSizeWE);
        else
        {
            if (m_rcCurrSel.top > m_rcCurrSel.bottom)
            {
                if (Hit & HIT_TOP)
                {
                    Hit &= ~HIT_TOP;
                    Hit |= HIT_BOTTOM;
                }
                else if (Hit & HIT_BOTTOM)
                {
                    Hit |= HIT_TOP;
                    Hit &= ~HIT_BOTTOM;
                }
            }
            if (m_rcCurrSel.left > m_rcCurrSel.right)
            {
                if (Hit & HIT_LEFT)
                {
                    Hit &= ~HIT_LEFT;
                    Hit |= HIT_RIGHT;
                }
                else if (Hit & HIT_RIGHT)
                {
                    Hit |= HIT_LEFT;
                    Hit &= ~HIT_RIGHT;
                }
            }
            if (Hit == HIT_TOPLEFT || Hit == HIT_BOTTOMRIGHT)
                SetCursor(m_hCursorSizeNwSe);
            else if (Hit == HIT_TOPRIGHT || Hit == HIT_BOTTOMLEFT)
                SetCursor(m_hCursorSizeNeSw);
        }
    }
    return(LRESULT)0;
}

LRESULT CWiaPreviewWindow::OnLButtonDown( WPARAM wParam, LPARAM lParam )
{
    if (!m_hPreviewBitmap || m_bPreviewMode || m_SelectionDisabled)
        return(0);
    if (GetFocus() != m_hWnd)
        SetFocus(m_hWnd);
    POINT point;
    point.x = LOWORD(lParam);
    point.y = HIWORD(lParam);
    int Hit = GetHitArea(point);
    if (wParam & MK_CONTROL)
        Hit = HIT_NONE;
    if (Hit == HIT_SELECTED)
    {
        m_MovingSel = HIT_SELECTED;
        POINT pt = GetCornerPoint(HIT_TOPLEFT);
        m_Delta.cx = pt.x - point.x;
        m_Delta.cy = pt.y - point.y;
        SetCapture(m_hWnd);
    }
    else if (Hit == HIT_NONE)
    {
        m_MovingSel = HIT_TOPLEFT;
        m_rcCurrSel.left = m_rcCurrSel.right = point.x;
        m_rcCurrSel.top = m_rcCurrSel.bottom = point.y;
        POINT pt = GetCornerPoint(m_MovingSel);
        m_Delta.cx = pt.x - point.x;
        m_Delta.cy = pt.y - point.y;
        SendSelChangeNotification();
        Repaint(NULL,false);
        UpdateWindow(m_hWnd);
        SetCapture(m_hWnd);
    }
    else
    {
        m_MovingSel = Hit;
        POINT pt = GetCornerPoint(Hit);
        m_Delta.cx = pt.x - point.x;
        m_Delta.cy = pt.y - point.y;
        SetCapture(m_hWnd);
    }
    return(LRESULT)0;
}

void CWiaPreviewWindow::SendSelChangeNotification( bool bSetUserChangedSelection )
{
    HWND hWndParent = GetParent(m_hWnd);
    if (hWndParent && IsWindow(hWndParent))
    {
        SendNotifyMessage(hWndParent,WM_COMMAND,MAKEWPARAM(GetWindowLongPtr(m_hWnd,GWLP_ID),PWN_SELCHANGE),reinterpret_cast<LPARAM>(m_hWnd));
    }
    if (bSetUserChangedSelection)
    {
        m_bUserChangedSelection = true;
    }
}

LRESULT CWiaPreviewWindow::OnLButtonUp( WPARAM, LPARAM )
{
    if (!m_hPreviewBitmap || m_bPreviewMode || m_SelectionDisabled)
        return(0);
    m_MovingSel = HIT_NONE;
    ReleaseCapture();
    NormalizeRect(m_rcCurrSel);
    return(LRESULT)0;
}

LRESULT CWiaPreviewWindow::OnCreate( WPARAM, LPARAM )
{
    SetWindowLong( m_hWnd, GWL_EXSTYLE, GetWindowLong(m_hWnd,GWL_EXSTYLE) & ~WS_EX_LAYOUTRTL );
    m_rcCurrSel = GetDefaultSelection();
    CreateNewBitmaps();
    return(0);
}

void CWiaPreviewWindow::CreateNewBitmaps(void)
{
    DestroyBitmaps();

    // No need to create the bitmaps if we have no bitmap to display
    if (!m_hPreviewBitmap)
        return;

    // Get client window size
    CSimpleRect rcClient( m_hWnd );

    bool bSuccess = true;

    // Get a client DC
    HDC hdcClient = GetDC(m_hWnd);
    if (hdcClient)
    {
        m_hBufferBitmap = CreateCompatibleBitmap(hdcClient,WiaUiUtil::RectWidth(rcClient),WiaUiUtil::RectHeight(rcClient));
        if (m_hBufferBitmap)
        {
            m_hPaintBitmap = CreateCompatibleBitmap(hdcClient,WiaUiUtil::RectWidth(rcClient),WiaUiUtil::RectHeight(rcClient));
            if (m_hPaintBitmap)
            {
                if (IsAlphaBlendEnabled())
                {
                    m_hAlphaBitmap = CreateCompatibleBitmap(hdcClient,WiaUiUtil::RectWidth(rcClient),WiaUiUtil::RectHeight(rcClient));
                    if (!m_hAlphaBitmap)
                        bSuccess = false;
                }
            }
            else bSuccess = false;
        }
        else bSuccess = false;
        ReleaseDC(m_hWnd,hdcClient);
    }
    else bSuccess = false;

    if (!bSuccess)
        DestroyBitmaps();
}

LRESULT CWiaPreviewWindow::OnGetImageSize( WPARAM, LPARAM lParam )
{
    if (lParam)
    {
        *reinterpret_cast<SIZE*>(lParam) = m_BitmapSize;
        return(1);
    }
    return(0);
}

bool CWiaPreviewWindow::GetOriginAndExtentInImagePixels( WORD nItem, POINT &ptOrigin, SIZE &sizeExtent )
{
    SIZE sizeSavedResolution;
    bool bResult = false;
    if (WiaPreviewControl_GetResolution(m_hWnd,&sizeSavedResolution))
    {
        WiaPreviewControl_SetResolution(m_hWnd, &m_BitmapSize);
        bResult = (WiaPreviewControl_GetSelOrigin( m_hWnd, nItem, 0, &ptOrigin ) && WiaPreviewControl_GetSelExtent( m_hWnd, nItem, 0, &sizeExtent  ));
        // Restore the old resolution
        WiaPreviewControl_SetResolution(m_hWnd, &sizeSavedResolution);
    }
    return(bResult);
}

void CWiaPreviewWindow::DrawBitmaps(void)
{
    // Don't bother painting the bitmap if we don't have an image.
    if (!m_hPreviewBitmap)
        return;

    RECT rcImage = GetImageRect();

    // Nuke old halftone palette
    if (m_hHalftonePalette)
    {
        DeleteObject(m_hHalftonePalette);
        m_hHalftonePalette = NULL;
    }

    // Get client window size
    CSimpleRect rcClient( m_hWnd );

    // Get a client DC
    HDC hdcClient = GetDC(m_hWnd);
    if (hdcClient)
    {
        // Recreate the halftone palette
        m_hHalftonePalette = CreateHalftonePalette(hdcClient);
        if (m_hHalftonePalette)
        {
            // Create a compatible dc
            HDC hdcCompat = CreateCompatibleDC(hdcClient);
            if (hdcCompat)
            {
                HBITMAP hOldBitmap = (HBITMAP)SelectObject( hdcCompat, m_hPaintBitmap );
                HPALETTE hOldPalette = SetHalftonePalette( hdcCompat );

                if (m_hPaintBitmap)
                {
                    FillRect( hdcCompat, &rcClient, m_hBackgroundBrush );

                    HDC hdcMem = CreateCompatibleDC(hdcCompat);
                    if (hdcMem)
                    {
                        HPALETTE hOldMemDCPalette = SetHalftonePalette( hdcMem );
                        HBITMAP hOldMemDCBitmap = (HBITMAP)SelectObject( hdcMem, m_hPreviewBitmap );
                        int nOldStretchMode = SetStretchBltMode(hdcCompat,STRETCH_HALFTONE);

                        POINT ptSource = { 0, 0};
                        SIZE  sizeSource = { m_BitmapSize.cx, m_BitmapSize.cy};

                        if (m_bPreviewMode)
                        {
                            POINT ptOrigin;
                            SIZE sizeExtent;
                            if (GetOriginAndExtentInImagePixels( 0, ptOrigin, sizeExtent ))
                            {
                                ptSource = ptOrigin;
                                sizeSource = sizeExtent;
                            }
                        }

                        StretchBlt(hdcCompat,rcImage.left,rcImage.top,WiaUiUtil::RectWidth(rcImage),WiaUiUtil::RectHeight(rcImage),hdcMem,ptSource.x,ptSource.y,sizeSource.cx,sizeSource.cy,SRCCOPY);

                        if (m_hAlphaBitmap)
                        {
                            SelectObject(hdcMem,m_hAlphaBitmap);
                            // First, lay down our lovely border
                            FillRect( hdcMem,&rcClient,m_hBackgroundBrush );
                            // The lay down the alpha blend background
                            FillRect( hdcMem,&rcImage,(HBRUSH)GetStockObject(WHITE_BRUSH) );
                            // Alpha blend it
                            AlphaBlend(hdcMem,rcImage.left,rcImage.top,WiaUiUtil::RectWidth(rcImage),WiaUiUtil::RectHeight(rcImage),hdcCompat,rcImage.left,rcImage.top,WiaUiUtil::RectWidth(rcImage),WiaUiUtil::RectHeight(rcImage),m_bfBlendFunction);
                        }

                        //
                        // Restore DC state and delete DC
                        //
                        SelectPalette(hdcMem,hOldMemDCPalette,FALSE);
                        SetStretchBltMode(hdcCompat,nOldStretchMode);
                        SelectObject(hdcMem,hOldMemDCBitmap);
                        DeleteDC(hdcMem);
                    }
                }
                //
                // Restore DC state and delete DC
                //
                SelectObject( hdcCompat, hOldBitmap );
                SelectPalette( hdcCompat, hOldPalette, FALSE );
                DeleteDC(hdcCompat);
            }
        }
        ReleaseDC(m_hWnd,hdcClient);
    }
}

#ifndef RECT_WIDTH
#define RECT_WIDTH(x) ((x).right - (x).left)
#endif

#ifndef RECT_HEIGHT
#define RECT_HEIGHT(x) ((x).bottom - (x).top)
#endif

RECT CWiaPreviewWindow::ScaleSelectionRect( const RECT &rcOriginalImage, const RECT &rcCurrentImage, const RECT &rcOriginalSel )
{
    RECT rcCurrentSel;
    if (IsDefaultSelectionRect(rcOriginalSel))
        return(rcOriginalSel);
    if (RECT_WIDTH(rcOriginalImage) && RECT_HEIGHT(rcOriginalImage))
    {
        rcCurrentSel.left = rcCurrentImage.left + MulDiv(rcOriginalSel.left-rcOriginalImage.left,RECT_WIDTH(rcCurrentImage),RECT_WIDTH(rcOriginalImage));
        rcCurrentSel.right = rcCurrentImage.left + MulDiv(rcOriginalSel.right-rcOriginalImage.left,RECT_WIDTH(rcCurrentImage),RECT_WIDTH(rcOriginalImage));
        rcCurrentSel.top = rcCurrentImage.top + MulDiv(rcOriginalSel.top-rcOriginalImage.top,RECT_HEIGHT(rcCurrentImage),RECT_HEIGHT(rcOriginalImage));
        rcCurrentSel.bottom = rcCurrentImage.top + MulDiv(rcOriginalSel.bottom-rcOriginalImage.top,RECT_HEIGHT(rcCurrentImage),RECT_HEIGHT(rcOriginalImage));
    }
    else rcCurrentSel = GetDefaultSelection();
    // If we're gone, start over with max selection
    if (rcCurrentSel.left >= rcCurrentSel.right || rcCurrentSel.top >= rcCurrentSel.bottom)
    {
        rcCurrentSel = GetDefaultSelection();
    }
    NormalizeRect(rcCurrentSel);
    if (rcCurrentSel.left < rcCurrentImage.left)
        rcCurrentSel.left = rcCurrentImage.left;
    if (rcCurrentSel.top < rcCurrentImage.top)
        rcCurrentSel.top = rcCurrentImage.top;
    if (rcCurrentSel.right > rcCurrentImage.right)
        rcCurrentSel.right = rcCurrentImage.right;
    if (rcCurrentSel.bottom > rcCurrentImage.bottom)
        rcCurrentSel.bottom = rcCurrentImage.bottom;
    return(rcCurrentSel);
}


LRESULT CWiaPreviewWindow::OnSize( WPARAM wParam, LPARAM )
{
    int nType = (int)wParam;
    if ((nType == SIZE_RESTORED || nType == SIZE_MAXIMIZED))
    {
        //
        // Resize the progress control if it exists
        //
        ResizeProgressBar();
        if (!m_bSizing)
        {
            RECT rcCurrentImageRect = GetImageRect();
            m_rcCurrSel = ScaleSelectionRect( m_rcSavedImageRect, rcCurrentImageRect, m_rcCurrSel );
            m_rcSavedImageRect = rcCurrentImageRect;
            CreateNewBitmaps();
            DrawBitmaps();
            Repaint(NULL,false);
            SendSelChangeNotification(false);
        }
        else Repaint(NULL,false);
    }
    return(LRESULT)0;
}

LRESULT CWiaPreviewWindow::OnSetText( WPARAM wParam, LPARAM lParam )
{
    LRESULT lResult = DefWindowProc( m_hWnd, WM_SETTEXT, wParam, lParam );
    InvalidateRect( m_hWnd, NULL, FALSE );
    UpdateWindow( m_hWnd );
    return(lResult);
}

LRESULT CWiaPreviewWindow::OnGetDlgCode( WPARAM, LPARAM )
{
    return(LRESULT)(DLGC_WANTARROWS);
}


LRESULT CWiaPreviewWindow::OnKeyDown( WPARAM wParam, LPARAM )
{
    if (!m_hPreviewBitmap || m_SelectionDisabled || m_bPreviewMode || IsDefaultSelectionRect(m_rcCurrSel))
        return(0);
    int nVirtKey = (int)wParam;
    int nAccelerate = 1;
    if (GetKeyState(VK_CONTROL) & 0x8000)
        nAccelerate = DEFAULT_ACCEL_FACTOR;
    RECT rcImage = GetImageRect(), rcOldCurrSel;
    CopyRect(&rcOldCurrSel,&m_rcCurrSel);
    // If SHIFT key is pressed, but ALT is not
    if (!(GetKeyState(VK_MENU) & 0x8000) && (GetKeyState(VK_SHIFT) & 0x8000))
    {
        switch (nVirtKey)
        {
        case VK_UP:
            if (m_rcCurrSel.bottom > m_rcCurrSel.top+nAccelerate)
                m_rcCurrSel.bottom -= nAccelerate;
            else m_rcCurrSel.bottom = m_rcCurrSel.top;
            break;
        case VK_DOWN:
            m_rcCurrSel.bottom += nAccelerate;
            if (m_rcCurrSel.bottom > rcImage.bottom)
                m_rcCurrSel.bottom = rcImage.bottom;
            break;
        case VK_RIGHT:
            m_rcCurrSel.right += nAccelerate;
            if (m_rcCurrSel.right > rcImage.right)
                m_rcCurrSel.right = rcImage.right;
            break;
        case VK_LEFT:
            if (m_rcCurrSel.right > m_rcCurrSel.left+nAccelerate)
                m_rcCurrSel.right -= nAccelerate;
            else m_rcCurrSel.right = m_rcCurrSel.left;
            break;
        }
    }
    // If SHIFT key not is pressed and ALT is not
    if (!(GetKeyState(VK_MENU) & 0x8000) && !(GetKeyState(VK_SHIFT) & 0x8000))
    {
        switch (nVirtKey)
        {
        case VK_DELETE:
            m_rcCurrSel = GetDefaultSelection();
            break;
        case VK_HOME:
            OffsetRect( &m_rcCurrSel, rcImage.left-m_rcCurrSel.left, 0 );
            break;
        case VK_END:
            OffsetRect( &m_rcCurrSel, rcImage.right-m_rcCurrSel.right, 0 );
            break;
        case VK_PRIOR:
            OffsetRect( &m_rcCurrSel, 0, rcImage.top-m_rcCurrSel.top );
            break;
        case VK_NEXT:
            OffsetRect( &m_rcCurrSel, 0, rcImage.bottom-m_rcCurrSel.bottom );
            break;
        case VK_UP:
            OffsetRect(&m_rcCurrSel,0,-nAccelerate);
            if (m_rcCurrSel.top < rcImage.top)
                OffsetRect(&m_rcCurrSel,0,-m_rcCurrSel.top+rcImage.top);
            break;
        case VK_LEFT:
            OffsetRect(&m_rcCurrSel,-nAccelerate,0);
            if (m_rcCurrSel.left < rcImage.left)
                OffsetRect(&m_rcCurrSel,-m_rcCurrSel.left+rcImage.left,0);
            break;
        case VK_DOWN:
            OffsetRect(&m_rcCurrSel,0,nAccelerate);
            if (m_rcCurrSel.bottom > rcImage.bottom)
                OffsetRect(&m_rcCurrSel,0,-(m_rcCurrSel.bottom-rcImage.bottom));
            break;
        case VK_RIGHT:
            OffsetRect(&m_rcCurrSel,nAccelerate,0);
            if (m_rcCurrSel.right > rcImage.right)
                OffsetRect(&m_rcCurrSel,-(m_rcCurrSel.right-rcImage.right),0);
            break;
        }
    }
    if (IsDefaultSelectionRect(m_rcCurrSel))
    {
        InvalidateRect( m_hWnd, NULL, FALSE );
        UpdateWindow( m_hWnd );
        SendSelChangeNotification();
    }
    else if (memcmp(&rcOldCurrSel,&m_rcCurrSel,sizeof(RECT)))
    {
        RECT rcCurSel = m_rcCurrSel, rcInvalid;
        NormalizeRect(rcOldCurrSel);
        NormalizeRect(rcCurSel);
        TrueUnionRect(&rcInvalid,&rcCurSel,&rcOldCurrSel);
        rcInvalid.left-=m_nHandleSize;
        rcInvalid.top-=m_nHandleSize;
        rcInvalid.right+=m_nHandleSize;
        rcInvalid.bottom+=m_nHandleSize;
        Repaint(&rcInvalid,false);
        UpdateWindow(m_hWnd);
        SendSelChangeNotification();
    }
    return(LRESULT)0;
}


//wParam = 0, lParam = LPSIZE lpResolution
LRESULT CWiaPreviewWindow::OnSetResolution( WPARAM, LPARAM lParam )
{
    if (lParam)
    {
        m_Resolution = *((LPSIZE)lParam);
    }
    else
    {
        m_Resolution.cx = m_Resolution.cy = 0;
    }

    return(LRESULT)0;
}

//wParam = 0, lParam = LPSIZE lpResolution
LRESULT CWiaPreviewWindow::OnGetResolution( WPARAM, LPARAM lParam )
{
    if (lParam)
    {
        *reinterpret_cast<SIZE*>(lParam) = m_Resolution;
        return(LRESULT)1;
    }
    return(LRESULT)0;
}

//wParam = 0, lParam = LPRECT lprcSelRect
LRESULT CWiaPreviewWindow::OnClearSelection( WPARAM, LPARAM )
{
    m_rcCurrSel = GetDefaultSelection();
    Repaint(NULL,false);
    return(LRESULT)0;
}

// wParam = (BOOL)MAKEWPARAM(bRepaint,bDontDestroy), lParam = (HBITMAP)hBmp
LRESULT CWiaPreviewWindow::OnSetBitmap( WPARAM wParam, LPARAM lParam )
{
    if (m_bDeleteBitmap && m_hPreviewBitmap)
        DeleteObject(m_hPreviewBitmap);

    m_hPreviewBitmap = (HBITMAP)lParam;

    m_BitmapSize.cx = m_BitmapSize.cy = 0;
    if (m_hPreviewBitmap)
    {
        BITMAP bm = {0};
        if (GetObject(m_hPreviewBitmap,sizeof(BITMAP),&bm))
        {
            m_BitmapSize.cx = bm.bmWidth;
            m_BitmapSize.cy = bm.bmHeight;
        }
    }

    m_bDeleteBitmap = !HIWORD(wParam);

    if (!m_hPaintBitmap || !m_hBufferBitmap || (!m_hAlphaBitmap && IsAlphaBlendEnabled()))
    {
        CreateNewBitmaps();
    }
    DrawBitmaps();
    if (LOWORD(wParam))
    {
        Repaint(NULL,false);
    }
    return(LRESULT)0;
}


// wParam = 0, lParam = 0
LRESULT CWiaPreviewWindow::OnGetBitmap( WPARAM wParam, LPARAM lParam )
{
    return(LRESULT)m_hPreviewBitmap;
}


LRESULT CWiaPreviewWindow::OnSetFocus( WPARAM, LPARAM )
{
    // If the rect isn't visible, recreate it.
    if (m_rcCurrSel.left == m_rcCurrSel.right || m_rcCurrSel.top == m_rcCurrSel.bottom && !IsDefaultSelectionRect(m_rcCurrSel))
    {
        m_rcCurrSel = GetDefaultSelection();
    }
    Repaint(NULL,false);
    return(LRESULT)0;
}

LRESULT CWiaPreviewWindow::OnKillFocus( WPARAM, LPARAM )
{
    Repaint(NULL,false);
    return(LRESULT)0;
}

LRESULT CWiaPreviewWindow::OnEnable( WPARAM, LPARAM )
{
    Repaint(NULL,false);
    return(LRESULT)0;
}

LRESULT CWiaPreviewWindow::OnEraseBkgnd( WPARAM, LPARAM )
{
    return(LRESULT)1;
}

LRESULT CWiaPreviewWindow::OnGetBorderSize( WPARAM, LPARAM )
{
    return(m_nBorderSize);
}

LRESULT CWiaPreviewWindow::OnGetHandleSize( WPARAM, LPARAM )
{
    return(m_nHandleSize);
}

LRESULT CWiaPreviewWindow::OnGetBgAlpha( WPARAM, LPARAM )
{
    return(m_bfBlendFunction.SourceConstantAlpha);
}

LRESULT CWiaPreviewWindow::OnGetHandleType( WPARAM, LPARAM )
{
    return(m_nHandleType);
}

LRESULT CWiaPreviewWindow::OnSetBorderSize( WPARAM wParam, LPARAM lParam )
{
    int nOldBorder = m_nBorderSize;
    m_nBorderSize = (UINT)lParam;
    if (wParam)
    {
        DrawBitmaps();
        Repaint(NULL,false);
    }
    return(nOldBorder);
}

LRESULT CWiaPreviewWindow::OnSetHandleSize( WPARAM wParam, LPARAM lParam )
{
    int nOldHandleSize = m_nHandleSize;
    m_nHandleSize = (int)lParam;
    if (wParam)
        Repaint(NULL,false);
    return(nOldHandleSize);
}

LRESULT CWiaPreviewWindow::OnSetBgAlpha( WPARAM wParam, LPARAM lParam )
{
    int nOldBgAlpha = m_bfBlendFunction.SourceConstantAlpha;
    m_bfBlendFunction.SourceConstantAlpha = (BYTE)lParam;
    if (wParam)
    {
        DrawBitmaps();
        Repaint(NULL,false);
    }
    return(nOldBgAlpha);
}

LRESULT CWiaPreviewWindow::OnSetHandleType( WPARAM wParam, LPARAM lParam )
{
    int nOldHandleType = m_nHandleType;
    m_nHandleType = (int)lParam;
    if (wParam)
        Repaint(NULL,false);
    return(nOldHandleType);
}

LRESULT CWiaPreviewWindow::OnEnterSizeMove( WPARAM, LPARAM )
{
    m_bSizing = true;
    return(0);
}

LRESULT CWiaPreviewWindow::OnExitSizeMove( WPARAM, LPARAM )
{
    if (m_bSizing)
    {
        m_bSizing = false;
        RECT rcCurrentImageRect = GetImageRect();
        if (memcmp(&rcCurrentImageRect,&m_rcSavedImageRect,sizeof(RECT)))
        {
            m_rcCurrSel = ScaleSelectionRect( m_rcSavedImageRect, rcCurrentImageRect, m_rcCurrSel );
            m_rcSavedImageRect = rcCurrentImageRect;
            CreateNewBitmaps();
            DrawBitmaps();
            SendSelChangeNotification(false);
        }
        Repaint(NULL,false);
    }
    return(0);
}

// wParam = (BOOL)MAKEWPARAM((WORD)nItem,(BOOL)bPhysical), lParam = (PPOINT)pOrigin
LRESULT CWiaPreviewWindow::OnGetSelOrigin( WPARAM wParam, LPARAM lParam )
{
    int nCount = static_cast<int>(SendMessage( m_hWnd, PWM_GETSELCOUNT, 0, 0 ));
    int nItem = (int)LOWORD(wParam);
    BOOL bPhysical = (BOOL)HIWORD(wParam);
    PPOINT pOrigin = (PPOINT)lParam;
    RECT rcImage = GetImageRect();
    if (nCount <= 0 || nItem < 0 || nItem >= nCount || !pOrigin)
        return(0);
    RECT rcSel = m_rcCurrSel;
    NormalizeRect(rcSel);
    if (IsRectEmpty(&rcSel))
        rcSel = rcImage;
    if (bPhysical)
    {
        pOrigin->x = rcSel.left - rcImage.left;
        pOrigin->y = rcSel.top - rcImage.top;
        return(1);
    }
    else if (RECT_WIDTH(rcImage) && RECT_HEIGHT(rcImage))  // Make sure we get no divide by zero errors
    {
        pOrigin->x = WiaUiUtil::MulDivNoRound(m_Resolution.cx,rcSel.left-rcImage.left,RECT_WIDTH(rcImage));
        pOrigin->y = WiaUiUtil::MulDivNoRound(m_Resolution.cy,rcSel.top-rcImage.top,RECT_HEIGHT(rcImage));
        return(1);
    }
    else return(0);
}

// wParam = (BOOL)MAKEWPARAM((WORD)nItem,(BOOL)bPhysical), lParam = (PSIZE)pExtent
LRESULT CWiaPreviewWindow::OnGetSelExtent( WPARAM wParam, LPARAM lParam )
{
    int nCount = static_cast<int>(SendMessage( m_hWnd, PWM_GETSELCOUNT, 0, 0 ));
    int nItem = (int)LOWORD(wParam);
    BOOL bPhysical = (BOOL)HIWORD(wParam);
    PSIZE pExtent = (PSIZE)lParam;
    RECT rcImage = GetImageRect();
    if (nCount <= 0 || nItem < 0 || nItem >= nCount || !pExtent)
        return(0);
    RECT rcSel = m_rcCurrSel;
    NormalizeRect(rcSel);
    if (IsRectEmpty(&rcSel))
        rcSel = rcImage;
    if (bPhysical)
    {
        pExtent->cx = RECT_WIDTH(rcSel);
        pExtent->cy = RECT_HEIGHT(rcSel);
        return(1);
    }
    else if (RECT_WIDTH(rcImage) && RECT_HEIGHT(rcImage))  // Make sure we get no divide by zero errors
    {
        pExtent->cx = WiaUiUtil::MulDivNoRound(m_Resolution.cx,RECT_WIDTH(rcSel),RECT_WIDTH(rcImage));
        pExtent->cy = WiaUiUtil::MulDivNoRound(m_Resolution.cy,RECT_HEIGHT(rcSel),RECT_HEIGHT(rcImage));
        return(1);
    }
    else return(0);
}


// wParam = (BOOL)MAKEWPARAM((WORD)nItem,(BOOL)bPhysical), lParam = (PPOINT)pOrigin
LRESULT CWiaPreviewWindow::OnSetSelOrigin( WPARAM wParam, LPARAM lParam )
{
    int nCount = static_cast<int>(SendMessage( m_hWnd, PWM_GETSELCOUNT, 0, 0 ));
    int nItem = (int)LOWORD(wParam);
    BOOL bPhysical = (BOOL)HIWORD(wParam);
    PPOINT pOrigin = (PPOINT)lParam;
    RECT rcImage = GetImageRect();
    if (nCount <= 0 || nItem < 0 || nItem >= nCount)
    {
        return(0);
    }
    else if (!pOrigin)
    {
        m_rcCurrSel = rcImage;
        Repaint( NULL, FALSE );
        return(1);
    }
    else if (bPhysical)
    {
        m_rcCurrSel.left = rcImage.left + pOrigin->x;
        m_rcCurrSel.top = rcImage.top + pOrigin->y;
        Repaint( NULL, FALSE );
        return(1);
    }
    else if (m_Resolution.cx && m_Resolution.cy)  // Make sure we get no divide by zero errors
    {
        m_rcCurrSel.left = rcImage.left + MulDiv(pOrigin->x,RECT_WIDTH(rcImage),m_Resolution.cx);
        m_rcCurrSel.top = rcImage.top + MulDiv(pOrigin->y,RECT_HEIGHT(rcImage),m_Resolution.cy);
        Repaint( NULL, FALSE );
        return(1);
    }
    else return(0);
}

// wParam = (BOOL)MAKEWPARAM((WORD)nItem,(BOOL)bPhysical), lParam = (PSIZE)pExtent
LRESULT CWiaPreviewWindow::OnSetSelExtent( WPARAM wParam, LPARAM lParam )
{
    int nCount = static_cast<int>(SendMessage( m_hWnd, PWM_GETSELCOUNT, 0, 0 ));
    int nItem = static_cast<int>(LOWORD(wParam));
    BOOL bPhysical = (BOOL)HIWORD(wParam);
    PSIZE pExtent = (PSIZE)lParam;
    RECT rcImage = GetImageRect();
    if (nCount <= 0 || nItem < 0 || nItem >= nCount)
    {
        return(0);
    }
    else if (!pExtent)
    {
        m_rcCurrSel = rcImage;
        Repaint( NULL, FALSE );
        return(1);
    }
    else if (bPhysical)
    {
        m_rcCurrSel.right = m_rcCurrSel.left + pExtent->cx;
        m_rcCurrSel.bottom = m_rcCurrSel.top + pExtent->cy;
        Repaint(NULL,FALSE);
        return(1);
    }
    else if (m_Resolution.cx && m_Resolution.cy)  // Make sure we get no divide by zero errors
    {
        m_rcCurrSel.right = m_rcCurrSel.left + MulDiv(pExtent->cx,RECT_WIDTH(rcImage),m_Resolution.cx);
        m_rcCurrSel.bottom = m_rcCurrSel.top + MulDiv(pExtent->cy,RECT_HEIGHT(rcImage),m_Resolution.cy);
        Repaint( NULL, FALSE );
        return(1);
    }
    else return(0);
}


LRESULT CWiaPreviewWindow::OnGetSelCount( WPARAM wParam, LPARAM lParam )
{
    return(GetSelectionRectCount());  // For now...
}

BOOL CWiaPreviewWindow::IsDefaultSelectionRect( const RECT &rc )
{
    if (!m_bAllowNullSelection)
        return(FALSE);
    RECT rcSel = rc;
    NormalizeRect(rcSel);
    RECT rcDefault = GetDefaultSelection();
    return(rcSel.left == rcDefault.left &&
           rcSel.top == rcDefault.top &&
           rcSel.right == rcDefault.right &&
           rcSel.bottom == rcDefault.bottom);
}

RECT CWiaPreviewWindow::GetDefaultSelection(void)
{
    if (m_bAllowNullSelection)
    {
        RECT r = {-100,-100,-100,-100};
        return(r);
    }
    else return(GetImageRect());
}

LRESULT CWiaPreviewWindow::OnGetAllowNullSelection( WPARAM, LPARAM )
{
    return(m_bAllowNullSelection != FALSE);
}

// wParam = (BOOL)bAllowNullSelection, lParam = 0
LRESULT CWiaPreviewWindow::OnSetAllowNullSelection( WPARAM wParam, LPARAM )
{
    BOOL bOldAllowNullSelection = m_bAllowNullSelection;
    if (wParam)
        m_bAllowNullSelection = TRUE;
    else m_bAllowNullSelection = FALSE;
    return(bOldAllowNullSelection);
}

LRESULT CWiaPreviewWindow::OnGetDisableSelection( WPARAM, LPARAM )
{
    return(m_SelectionDisabled != FALSE);
}

// wParam = (BOOL)bDisableSelection, lParam = 0
LRESULT CWiaPreviewWindow::OnSetDisableSelection( WPARAM wParam, LPARAM )
{
    BOOL bReturn = (m_SelectionDisabled != FALSE);
    m_SelectionDisabled = (wParam != 0);
    Repaint(NULL,false);
    return(bReturn);
}


int CWiaPreviewWindow::GetSelectionRectCount(void)
{
    return(1);
}

// wParam = 0, lParam = 0
LRESULT CWiaPreviewWindow::OnGetBkColor( WPARAM, LPARAM )
{
    LOGBRUSH lb = { 0};
    GetObject(m_hBackgroundBrush,sizeof(LOGBRUSH),&lb);
    return(lb.lbColor);
}

// wParam = (BOOL)bRepaint, lParam = (COLORREF)color
LRESULT CWiaPreviewWindow::OnSetBkColor( WPARAM wParam, LPARAM lParam )
{
    HBRUSH hBrush = CreateSolidBrush( static_cast<int>(lParam) );
    if (hBrush)
    {
        if (m_hBackgroundBrush)
        {
            DeleteObject(m_hBackgroundBrush);
            m_hBackgroundBrush = NULL;
        }
        m_hBackgroundBrush = hBrush;
        if (wParam)
        {
            DrawBitmaps();
            Repaint(NULL,false);
        }
        return(1);
    }
    return(0);
}

LRESULT  CWiaPreviewWindow::OnSetPreviewMode( WPARAM, LPARAM lParam )
{
    m_bPreviewMode = (lParam != FALSE);
    DrawBitmaps();
    Repaint(NULL,false);
    return(0);
}

LRESULT  CWiaPreviewWindow::OnRefreshBitmap( WPARAM, LPARAM )
{
    DrawBitmaps();
    Repaint(NULL,false);
    return(0);
}

LRESULT  CWiaPreviewWindow::OnGetPreviewMode( WPARAM, LPARAM )
{
    return(m_bPreviewMode != false);
}

void CWiaPreviewWindow::SetCursor( HCURSOR hCursor )
{
    m_hCurrentCursor = hCursor;
    ::SetCursor(m_hCurrentCursor);
}

LRESULT CWiaPreviewWindow::OnSetCursor( WPARAM wParam, LPARAM lParam )
{
    if (reinterpret_cast<HWND>(wParam) == m_hWnd && m_hCurrentCursor)
    {
        ::SetCursor(m_hCurrentCursor);
        return(TRUE);
    }
    else return(DefWindowProc( m_hWnd, WM_SETCURSOR, wParam, lParam ));
}

// wParam = MAKEWPARAM(bRepaint,0), lParam = MAKELPARAM(nBorderStyle,nBorderThickness)
LRESULT CWiaPreviewWindow::OnSetBorderStyle( WPARAM wParam, LPARAM lParam )
{
    // Recreate the handle border pens.  Don't apply the line style, just the thickness.
    for (int i=0;i<ARRAYSIZE(m_aHandlePens);i++)
    {
        LOGPEN LogPen;
        ZeroMemory(&LogPen,sizeof(LOGPEN));
        if (GetObject( m_aHandlePens[i], sizeof(LOGPEN), &LogPen ))
        {
            LogPen.lopnWidth.x = HIWORD(lParam);
            if (m_aHandlePens[i])
                DeleteObject(m_aHandlePens[i]);
            m_aHandlePens[i] = CreatePenIndirect(&LogPen);
        }
    }

    // Recreate the selection border pens.  Apply the line style, just the thickness.
    for (i=0;i<ARRAYSIZE(m_aBorderPens);i++)
    {
        LOGPEN LogPen;
        ZeroMemory(&LogPen,sizeof(LOGPEN));
        if (GetObject( m_aBorderPens[i], sizeof(LOGPEN), &LogPen ))
        {
            LogPen.lopnWidth.x = (UINT)HIWORD(lParam);
            LogPen.lopnStyle = LOWORD(lParam);
            if (m_aBorderPens[i])
                DeleteObject(m_aBorderPens[i]);
            m_aBorderPens[i] = CreatePenIndirect(&LogPen);
        }
    }

    if (LOWORD(wParam))
    {
        Repaint(NULL,FALSE);
    }
    return(0);
}

// wParam = MAKEWPARAM(bRepaint,nState), lParam = (COLORREF)crColor
LRESULT CWiaPreviewWindow::OnSetBorderColor( WPARAM wParam, LPARAM lParam )
{
    int nState = static_cast<int>(HIWORD(wParam));
    if (nState >= 0 && nState < 3)
    {
        LOGPEN LogPen;
        ZeroMemory(&LogPen,sizeof(LOGPEN));
        if (GetObject( m_aHandlePens[nState], sizeof(LOGPEN), &LogPen ))
        {
            LogPen.lopnColor = static_cast<COLORREF>(lParam);
            if (m_aHandlePens[nState])
                DeleteObject(m_aHandlePens[nState]);
            m_aHandlePens[nState] = CreatePenIndirect(&LogPen);
        }
        ZeroMemory(&LogPen,sizeof(LOGPEN));
        if (GetObject( m_aBorderPens[nState], sizeof(LOGPEN), &LogPen ))
        {
            LogPen.lopnColor = static_cast<COLORREF>(lParam);
            if (m_aBorderPens[nState])
                DeleteObject(m_aBorderPens[nState]);
            m_aBorderPens[nState] = CreatePenIndirect(&LogPen);
        }
    }
    if (LOWORD(wParam))
    {
        Repaint(NULL,FALSE);
    }
    return(0);
}

// wParam = MAKEWPARAM(bRepaint,nState), lParam = (COLORREF)crColor
LRESULT CWiaPreviewWindow::OnSetHandleColor( WPARAM wParam, LPARAM lParam )
{
    int nState = static_cast<int>(HIWORD(wParam));
    if (nState >= 0 && nState < 3)
    {
        if (m_aHandleBrushes[nState])
        {
            DeleteObject(m_aHandleBrushes[nState]);
            m_aHandleBrushes[nState] = NULL;
        }
        m_aHandleBrushes[nState] = CreateSolidBrush( static_cast<COLORREF>(lParam) );
    }
    if (LOWORD(wParam))
    {
        Repaint(NULL,FALSE);
    }
    return(0);
}

void CWiaPreviewWindow::ResizeProgressBar()
{
    HWND hWndProgress = GetDlgItem( m_hWnd, IDC_PROGRESSCONTROL );
    if (hWndProgress)
    {
        //
        // Resize the progress control to fill the client
        //
        RECT rcImage = GetImageRect();

        CDialogUnits DialogUnits( m_hWnd );

        SIZE sizeProgress = { WiaUiUtil::RectWidth(rcImage) - DialogUnits.X(28), DialogUnits.Y(14) };
        POINT ptProgress = { rcImage.left + (WiaUiUtil::RectWidth(rcImage) - sizeProgress.cx) / 2, rcImage.top + (WiaUiUtil::RectHeight(rcImage) - sizeProgress.cy) / 2 };

        MoveWindow( hWndProgress, ptProgress.x, ptProgress.y, sizeProgress.cx, sizeProgress.cy, TRUE );
    }
}

//
// wParam = bShow
//
LRESULT CWiaPreviewWindow::OnSetProgress( WPARAM wParam, LPARAM lParam )
{
    //
    // Assume failure
    //
    LRESULT lResult = FALSE;

    //
    // If wParam is true, create the control
    //
    if (wParam)
    {
        //
        // See if the control is already created.  
        //
        HWND hWndProgress = GetDlgItem( m_hWnd, IDC_PROGRESSCONTROL );
        if (!hWndProgress)
        {
            //
            // If it isn't, create it.
            //
            hWndProgress = CreateWindow( PROGRESS_CLASS, TEXT(""), WS_CHILD|WS_VISIBLE|PBS_MARQUEE, 0, 0, 0, 0, m_hWnd, reinterpret_cast<HMENU>(IDC_PROGRESSCONTROL), NULL, NULL );
            if (hWndProgress)
            {
                //
                // Put it in marquee mode
                //
                SendMessage( hWndProgress, PBM_SETMARQUEE, TRUE, 100 );

                //
                // Resize it
                //
                ResizeProgressBar();
            }
        }
        
        //
        // Success = we have a progress bar
        //
        lResult = (hWndProgress != NULL);
    }
    //
    // Otherwise, destroy the control if it exists
    //
    else
    {
        HWND hWndProgress = GetDlgItem( m_hWnd, IDC_PROGRESSCONTROL );
        if (hWndProgress)
        {
            //
            // Nuke it
            //
            DestroyWindow(hWndProgress);

        }
        
        lResult = true;
    }

    //
    // Force a repaint
    //
    InvalidateRect( m_hWnd, NULL, FALSE );
    UpdateWindow(m_hWnd);

    return lResult;
}

LRESULT CWiaPreviewWindow::OnGetProgress( WPARAM, LPARAM )
{
    return (NULL != GetDlgItem( m_hWnd, IDC_PROGRESSCONTROL ));
}

LRESULT CWiaPreviewWindow::OnCtlColorStatic( WPARAM wParam, LPARAM )
{
    SetBkColor( reinterpret_cast<HDC>( wParam ), GetSysColor( COLOR_WINDOW ) );
    return reinterpret_cast<LRESULT>(GetSysColorBrush(COLOR_WINDOW));
}

LRESULT  CWiaPreviewWindow::OnSetUserChangedSelection( WPARAM wParam, LPARAM )
{
    LRESULT lRes = m_bUserChangedSelection;
    m_bUserChangedSelection = (wParam != 0);
    return lRes;
}

LRESULT  CWiaPreviewWindow::OnGetUserChangedSelection( WPARAM, LPARAM )
{
    return static_cast<LRESULT>(m_bUserChangedSelection);
}

LRESULT CALLBACK CWiaPreviewWindow::WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_MESSAGE_HANDLERS(CWiaPreviewWindow)
    {
        SC_HANDLE_MESSAGE( WM_CREATE, OnCreate );
        SC_HANDLE_MESSAGE( WM_ERASEBKGND, OnEraseBkgnd );
        SC_HANDLE_MESSAGE( WM_PAINT, OnPaint );
        SC_HANDLE_MESSAGE( WM_MOUSEMOVE, OnMouseMove );
        SC_HANDLE_MESSAGE( WM_LBUTTONDOWN, OnLButtonDown );
        SC_HANDLE_MESSAGE( WM_LBUTTONUP, OnLButtonUp );
        SC_HANDLE_MESSAGE( WM_LBUTTONDBLCLK , OnLButtonDblClk );
        SC_HANDLE_MESSAGE( WM_SIZE, OnSize );
        SC_HANDLE_MESSAGE( WM_GETDLGCODE, OnGetDlgCode );
        SC_HANDLE_MESSAGE( WM_KEYDOWN, OnKeyDown );
        SC_HANDLE_MESSAGE( WM_SETFOCUS, OnSetFocus );
        SC_HANDLE_MESSAGE( WM_KILLFOCUS, OnKillFocus );
        SC_HANDLE_MESSAGE( WM_ENABLE, OnEnable );
        SC_HANDLE_MESSAGE( WM_SETTEXT, OnSetText );
        SC_HANDLE_MESSAGE( WM_SETCURSOR, OnSetCursor );
        SC_HANDLE_MESSAGE( WM_CTLCOLORSTATIC, OnCtlColorStatic );
        SC_HANDLE_MESSAGE( PWM_CLEARSELECTION, OnClearSelection );
        SC_HANDLE_MESSAGE( PWM_SETRESOLUTION, OnSetResolution );
        SC_HANDLE_MESSAGE( PWM_GETRESOLUTION, OnGetResolution );
        SC_HANDLE_MESSAGE( PWM_SETBITMAP, OnSetBitmap );
        SC_HANDLE_MESSAGE( PWM_GETBITMAP, OnGetBitmap );
        SC_HANDLE_MESSAGE( PWM_GETBORDERSIZE, OnGetBorderSize );
        SC_HANDLE_MESSAGE( PWM_GETHANDLESIZE, OnGetHandleSize );
        SC_HANDLE_MESSAGE( PWM_GETBGALPHA, OnGetBgAlpha );
        SC_HANDLE_MESSAGE( PWM_GETHANDLETYPE, OnGetHandleType );
        SC_HANDLE_MESSAGE( PWM_SETBORDERSIZE, OnSetBorderSize );
        SC_HANDLE_MESSAGE( PWM_SETHANDLESIZE, OnSetHandleSize );
        SC_HANDLE_MESSAGE( PWM_SETBGALPHA, OnSetBgAlpha );
        SC_HANDLE_MESSAGE( PWM_SETHANDLETYPE, OnSetHandleType );
        SC_HANDLE_MESSAGE( PWM_GETSELCOUNT, OnGetSelCount );
        SC_HANDLE_MESSAGE( PWM_GETSELORIGIN, OnGetSelOrigin );
        SC_HANDLE_MESSAGE( PWM_GETSELEXTENT, OnGetSelExtent );
        SC_HANDLE_MESSAGE( PWM_SETSELORIGIN, OnSetSelOrigin );
        SC_HANDLE_MESSAGE( PWM_SETSELEXTENT, OnSetSelExtent );
        SC_HANDLE_MESSAGE( WM_ENTERSIZEMOVE, OnEnterSizeMove );
        SC_HANDLE_MESSAGE( WM_EXITSIZEMOVE, OnExitSizeMove );
        SC_HANDLE_MESSAGE( PWM_GETALLOWNULLSELECTION, OnGetAllowNullSelection );
        SC_HANDLE_MESSAGE( PWM_SETALLOWNULLSELECTION, OnSetAllowNullSelection );
        SC_HANDLE_MESSAGE( PWM_SELECTIONDISABLED, OnGetDisableSelection );
        SC_HANDLE_MESSAGE( PWM_DISABLESELECTION, OnSetDisableSelection );
        SC_HANDLE_MESSAGE( PWM_DETECTREGIONS, OnDetectRegions);
        SC_HANDLE_MESSAGE( PWM_GETBKCOLOR, OnGetBkColor );
        SC_HANDLE_MESSAGE( PWM_SETBKCOLOR, OnSetBkColor );
        SC_HANDLE_MESSAGE( PWM_SETPREVIEWMODE, OnSetPreviewMode );
        SC_HANDLE_MESSAGE( PWM_GETPREVIEWMODE, OnGetPreviewMode );
        SC_HANDLE_MESSAGE( PWM_GETIMAGESIZE, OnGetImageSize );
        SC_HANDLE_MESSAGE( PWM_SETBORDERSTYLE, OnSetBorderStyle );
        SC_HANDLE_MESSAGE( PWM_SETBORDERCOLOR, OnSetBorderColor );
        SC_HANDLE_MESSAGE( PWM_SETHANDLECOLOR, OnSetHandleColor );
        SC_HANDLE_MESSAGE( PWM_REFRESHBITMAP, OnRefreshBitmap );
        SC_HANDLE_MESSAGE( PWM_SETPROGRESS, OnSetProgress );
        SC_HANDLE_MESSAGE( PWM_GETPROGRESS, OnGetProgress );
        SC_HANDLE_MESSAGE( PWM_SETUSERCHANGEDSELECTION, OnSetUserChangedSelection );
        SC_HANDLE_MESSAGE( PWM_GETUSERCHANGEDSELECTION, OnGetUserChangedSelection );
    }
    SC_END_MESSAGE_HANDLERS();
}

// Detects regions using the CRegionDetector class
// The region detection class is designed to detect
// multiple regions, but OnDetectRegions merges all of the regions
// down to one region which it saves as m_rcCurrSel
LRESULT CWiaPreviewWindow::OnDetectRegions( WPARAM, LPARAM )
{
    WIA_PUSH_FUNCTION((TEXT("CWiaPreviewWindow::OnDetectRegions")));

    //
    // We are going to assume we can't detect a region
    //
    m_bSuccessfulRegionDetection = false;

    //
    // This could take a while
    //
    CWaitCursor wc;

    //
    // m_hPreviewBitmap holds the bitmap we wish to detect regions on.
    //
    if (m_hBufferBitmap && m_hPreviewBitmap)
    {
        //
        // Get the bitmap info associated with m_hPreviewBitmap
        //
        BITMAP bitmap = {0};
        if (GetObject(m_hPreviewBitmap,sizeof(BITMAP),&bitmap))
        {
            //
            // Unless the preview image is of a reasonable size
            // We are not only wasting the users time, but we are risking
            // crashing his system with too large a file
            //
            if ((bitmap.bmWidth>MIN_REGION_DETECTION_X && bitmap.bmWidth<=MAX_REGION_DETECTION_X) && 
                (bitmap.bmHeight>MIN_REGION_DETECTION_Y && bitmap.bmHeight<=MAX_REGION_DETECTION_Y))
            {
                //
                // Create a region detector
                //
                CRegionDetector *pRegionDetector = new CRegionDetector(bitmap);
                if (pRegionDetector)
                {
                    pRegionDetector->FindSingleRegion();

                    //
                    // findRegions stores coordinates in a system that
                    // is a mirror image of the coordinate system used
                    // in CWiaPreviewWindow
                    //
                    pRegionDetector->m_pRegions->FlipVertically();

                    if (pRegionDetector->m_pRegions->m_validRects>0)
                    {
                        pRegionDetector->ConvertToOrigionalCoordinates();
                        m_rectSavedDetected=pRegionDetector->m_pRegions->unionAll();

                        //
                        // we do not call grow regions because the FindSingleRegion algorithm uses edge enhancement
                        // which makes GrowRegion unncessary
                        //

                        //
                        // there may not always be a 1-1 correlation between preview pixels and image pixels
                        // so to be on the safe side, grow the preview rect out by a couple of pixels
                        //
                        m_rectSavedDetected=GrowRegion(m_rectSavedDetected,REGION_DETECTION_BORDER);
                        m_rcCurrSel=m_rectSavedDetected;                                             

                        //
                        // we also have to worry about the extra rounding error factor from converting to
                        // screen coordinates
                        //
                        m_rcSavedImageRect = GetImageRect();

                        //
                        // CWiaPreviewWindow stores the selection rectangle in terms of screen coordinates instead of bitmap coordinates
                        //
                        m_rcCurrSel=ConvertToScreenCoords(m_rcCurrSel);

                        //
                        // redisplay the window with the new selection rectangle
                        //
                        InvalidateRect( m_hWnd, NULL, FALSE );  
                        UpdateWindow( m_hWnd );
                        SendSelChangeNotification(false);

                        //
                        // We were successful at detecting a region
                        //
                        m_bSuccessfulRegionDetection = true;
                    }
                    else
                    {
                        WIA_TRACE((TEXT("pRegionDetector->m_pRegions->m_validRects was <= 0")));
                    }

                    //
                    // free CRegionDetector
                    //
                    delete pRegionDetector; 
                }
                else
                {
                    WIA_TRACE((TEXT("new pRegionDetector returned NULL")));
                }
            }
            else
            {
                WIA_TRACE((TEXT("Bitmap is too large for region detection to work efficiently (bitmap.bmWidth: %d, bitmap.bmHeight: %d)"), bitmap.bmWidth, bitmap.bmHeight));
            }
        }
        else
        {
            WIA_TRACE((TEXT("Unable to get the BITMAP for the hBitmap")));
        }
    }
    else
    {
        WIA_TRACE((TEXT("No bitmap")));
    }
    return (m_bSuccessfulRegionDetection ? TRUE : FALSE);
}

RECT CWiaPreviewWindow::GrowRegion(RECT r, int border)
{
    r.left-=border;
    r.top-=border;
    r.right+=border;
    r.bottom+=border;

    if (r.left<0) r.left=0;
    if (r.right>=m_BitmapSize.cx) r.right=m_BitmapSize.cx-1;

    if (r.top<0) r.top=0;
    if (r.top>=m_BitmapSize.cy) r.top=m_BitmapSize.cy-1;
    return(r);
}

int CWiaPreviewWindow::XConvertToBitmapCoords(int x)
{
    return((x-m_rcSavedImageRect.left)*m_BitmapSize.cx)/WiaUiUtil::RectWidth(m_rcSavedImageRect);
}

int CWiaPreviewWindow::XConvertToScreenCoords(int x)
{
    return(x*WiaUiUtil::RectWidth(m_rcSavedImageRect))/m_BitmapSize.cx+m_rcSavedImageRect.left;
}

int CWiaPreviewWindow::YConvertToBitmapCoords(int y)
{
    return((y-m_rcSavedImageRect.top)*m_BitmapSize.cy)/WiaUiUtil::RectHeight(m_rcSavedImageRect);
}
int CWiaPreviewWindow::YConvertToScreenCoords(int y)
{
    return(y*WiaUiUtil::RectHeight(m_rcSavedImageRect))/m_BitmapSize.cy+m_rcSavedImageRect.top;
}


// Convert between bitmap coordinates and screen coordinates
POINT CWiaPreviewWindow::ConvertToBitmapCoords(POINT p)
{
    p.x=XConvertToBitmapCoords(p.x);
    p.y=YConvertToBitmapCoords(p.y);
    return(p);
}

POINT CWiaPreviewWindow::ConvertToScreenCoords(POINT p)
{
    p.x=XConvertToScreenCoords(p.x);
    p.y=YConvertToScreenCoords(p.y);
    return(p);
}

RECT CWiaPreviewWindow::ConvertToBitmapCoords(RECT r)
{
    r.left=XConvertToBitmapCoords(r.left);
    r.top=YConvertToBitmapCoords(r.top);
    r.right=XConvertToBitmapCoords(r.right);
    r.bottom=YConvertToBitmapCoords(r.bottom);
    return(r);
}

RECT CWiaPreviewWindow::ConvertToScreenCoords(RECT r)
{
    RECT newRect;
    newRect.left=XConvertToScreenCoords(r.left);
    newRect.top=YConvertToScreenCoords(r.top);
    newRect.right=XConvertToScreenCoords(r.right);
    newRect.bottom=YConvertToScreenCoords(r.bottom);
    return(newRect);
}


LRESULT CWiaPreviewWindow::OnLButtonDblClk( WPARAM wParam, LPARAM lParam )
{
    if (!m_hPreviewBitmap || m_bPreviewMode || m_SelectionDisabled)
    {
        return(0);
    }
    if (GetFocus() != m_hWnd)
    {
        SetFocus(m_hWnd);
    }
    
    POINT point;
    point.x = LOWORD(lParam);
    point.y = HIWORD(lParam);
    int Hit = GetHitArea(point);
    if (wParam & MK_CONTROL)
    {
        Hit = HIT_NONE;
    }
    if (Hit != HIT_NONE && m_bSuccessfulRegionDetection)
    {
        m_rcCurrSel = m_rectSavedDetected; // reset to saved rectangle
        m_rcSavedImageRect = GetImageRect();
        m_rcCurrSel=ConvertToScreenCoords(m_rcCurrSel); // CWiaPreviewWindow stores the selection rectangle in terms of screen coordinates instead of bitmap coordinates

        SendSelChangeNotification(false);
        Repaint(NULL,false);
        UpdateWindow(m_hWnd);
        return(1);
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prevwnd\sources.inc ===
#
# Builds the WIA Preview Window static library, PREVWND.LIB
#

!include $(PROJECT_ROOT)\ui\uienv.inc

TARGETPATH=$(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)
TARGETNAME=prevwnd
TARGETTYPE=LIBRARY

SOURCES=..\prevwnd.cpp \
        ..\pwframe.cpp

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prevwnd\pwframe.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       PWFRAME.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        8/12/1999
 *
 *  DESCRIPTION: Preview frame class definition
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "pwframe.h"
#include "simrect.h"
#include "miscutil.h"
#include "pviewids.h"
#include "prevwnd.h"
#include "simcrack.h"

void WINAPI RegisterWiaPreviewClasses( HINSTANCE hInstance )
{
    CWiaPreviewWindowFrame::RegisterClass( hInstance );
    CWiaPreviewWindow::RegisterClass( hInstance );
}


CWiaPreviewWindowFrame::CWiaPreviewWindowFrame( HWND hWnd )
  : m_hWnd(hWnd),
    m_nSizeBorder(DEFAULT_BORDER_SIZE),
    m_hBackgroundBrush(CreateSolidBrush(GetSysColor(COLOR_WINDOW))),
    m_bEnableStretch(true),
    m_bHideEmptyPreview(false),
    m_nPreviewAlignment(MAKELPARAM(PREVIEW_WINDOW_CENTER,PREVIEW_WINDOW_CENTER))
{
    ZeroMemory( &m_sizeAspectRatio, sizeof(m_sizeAspectRatio) );
    ZeroMemory( &m_sizeDefAspectRatio, sizeof(m_sizeDefAspectRatio) );
}


CWiaPreviewWindowFrame::~CWiaPreviewWindowFrame(void)
{
    if (m_hBackgroundBrush)
    {
        DeleteObject(m_hBackgroundBrush);
        m_hBackgroundBrush = NULL;
    }
}


LRESULT CWiaPreviewWindowFrame::OnCreate( WPARAM, LPARAM lParam )
{
    //
    // Turn off RTL for this window
    //
    SetWindowLong( m_hWnd, GWL_EXSTYLE, GetWindowLong(m_hWnd,GWL_EXSTYLE) & ~WS_EX_LAYOUTRTL );
    LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;
    CWiaPreviewWindow::RegisterClass(lpcs->hInstance);
    HWND hWndPreview = CreateWindowEx( 0, PREVIEW_WINDOW_CLASS, TEXT(""), WS_CHILD|WS_VISIBLE|WS_BORDER|WS_CLIPCHILDREN, 0, 0, 0, 0, m_hWnd, (HMENU)IDC_INNER_PREVIEW_WINDOW, lpcs->hInstance, NULL );
    if (!hWndPreview)
        return(-1);
    return(0);
}


LRESULT CWiaPreviewWindowFrame::OnSize( WPARAM wParam, LPARAM )
{
    if ((SIZE_MAXIMIZED==wParam || SIZE_RESTORED==wParam))
        AdjustWindowSize();
    return(0);
}


LRESULT CWiaPreviewWindowFrame::OnSetFocus( WPARAM, LPARAM )
{
    SetFocus( GetDlgItem(m_hWnd,IDC_INNER_PREVIEW_WINDOW) );
    return(0);
}


LRESULT CWiaPreviewWindowFrame::OnEnable( WPARAM wParam, LPARAM )
{
    EnableWindow( GetDlgItem(m_hWnd,IDC_INNER_PREVIEW_WINDOW), (BOOL)wParam );
    return(0);
}


int CWiaPreviewWindowFrame::FillRect( HDC hDC, HBRUSH hBrush, int x1, int y1, int x2, int y2 )
{
    RECT rc;
    rc.left = x1;
    rc.top = y1;
    rc.right = x2;
    rc.bottom = y2;
    return(::FillRect( hDC, &rc, hBrush ));
}


LRESULT CWiaPreviewWindowFrame::OnEraseBkgnd( WPARAM wParam, LPARAM )
{
    // Only paint the regions around the preview control
    RECT rcClient;
    GetClientRect(m_hWnd,&rcClient);
    HDC hDC = (HDC)wParam;
    if (hDC)
    {
        HWND hWndPreview = GetDlgItem(m_hWnd,IDC_INNER_PREVIEW_WINDOW);
        if (!hWndPreview || !IsWindowVisible(hWndPreview))
        {
            ::FillRect( hDC, &rcClient, m_hBackgroundBrush );
        }
        else
        {
            CSimpleRect rcPreviewWnd = CSimpleRect(hWndPreview,CSimpleRect::WindowRect).ScreenToClient(m_hWnd);
            FillRect( hDC, m_hBackgroundBrush, 0, 0, rcClient.right, rcPreviewWnd.top );  // top
            FillRect( hDC, m_hBackgroundBrush, 0, rcPreviewWnd.top, rcPreviewWnd.left, rcPreviewWnd.bottom ); // left
            FillRect( hDC, m_hBackgroundBrush, rcPreviewWnd.right, rcPreviewWnd.top, rcClient.right, rcPreviewWnd.bottom );  // right
            FillRect( hDC, m_hBackgroundBrush, 0, rcPreviewWnd.bottom, rcClient.right, rcClient.bottom ); // bottom
        }
    }
    return(1);
}


LRESULT CWiaPreviewWindowFrame::OnGetBorderSize( WPARAM wParam, LPARAM lParam )
{
    if (!wParam)
    {
        return SendDlgItemMessage( m_hWnd, IDC_INNER_PREVIEW_WINDOW, PWM_GETBORDERSIZE, wParam, lParam );
    }
    else
    {
        return m_nSizeBorder;
    }
}

LRESULT CWiaPreviewWindowFrame::OnSetBorderSize( WPARAM wParam, LPARAM lParam )
{
    if (!HIWORD(wParam))
    {
        return SendDlgItemMessage( m_hWnd, IDC_INNER_PREVIEW_WINDOW, PWM_SETBORDERSIZE, wParam, lParam );
    }
    else
    {
        m_nSizeBorder = static_cast<UINT>(lParam);
        if (LOWORD(wParam))
        {
            SendMessage( m_hWnd, WM_SETREDRAW, 0, 0 );
            ResizeClientIfNecessary();
            SendMessage( m_hWnd, WM_SETREDRAW, 1, 0 );
            // Make sure the border of the preview control is drawn correctly.
            // This is a workaround for a weird bug that causes the resized border to not be redrawn
            SetWindowPos( GetDlgItem( m_hWnd, IDC_INNER_PREVIEW_WINDOW ), NULL, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER|SWP_DRAWFRAME );
            InvalidateRect( GetDlgItem( m_hWnd, IDC_INNER_PREVIEW_WINDOW ), NULL, FALSE );
            UpdateWindow( GetDlgItem( m_hWnd, IDC_INNER_PREVIEW_WINDOW ) );
            InvalidateRect( m_hWnd, NULL, TRUE );
            UpdateWindow( m_hWnd );
        }
    }
    return 0;
}

LRESULT CWiaPreviewWindowFrame::OnHideEmptyPreview( WPARAM, LPARAM lParam )
{
    m_bHideEmptyPreview = (lParam != 0);
    AdjustWindowSize();
    return 0;
}

// This gets the exact maximum image size that could be displayed in the preview control
LRESULT CWiaPreviewWindowFrame::OnGetClientSize( WPARAM, LPARAM lParam )
{
    bool bSuccess = false;
    SIZE *pSize = reinterpret_cast<SIZE*>(lParam);
    if (pSize)
    {
        HWND hWndPreview = GetDlgItem(m_hWnd,IDC_INNER_PREVIEW_WINDOW);
        if (hWndPreview)
        {
            // This will be used to take into account the size of the internal border and frame, so we will
            // have *EXACT* aspect ratio calculations
            UINT nAdditionalBorder = WiaPreviewControl_GetBorderSize(hWndPreview,0) * 2;
            // Add in the size of the border, calculated by comparing the window rect with the client rect
            // I am assuming the border will be same size in pixels on all sides
            nAdditionalBorder += CSimpleRect( hWndPreview, CSimpleRect::WindowRect ).Width() - CSimpleRect( hWndPreview, CSimpleRect::ClientRect ).Width();

            // Get the client rect for our window
            CSimpleRect rcClient( m_hWnd, CSimpleRect::ClientRect );

            if (rcClient.Width() && rcClient.Height())
            {
                pSize->cx = rcClient.Width() - nAdditionalBorder - m_nSizeBorder * 2;
                pSize->cy = rcClient.Height() - nAdditionalBorder - m_nSizeBorder * 2;
                bSuccess = (pSize->cx > 0 && pSize->cy > 0);
            }
        }
    }
    return (bSuccess != false);
}

LRESULT CWiaPreviewWindowFrame::OnSetPreviewAlignment( WPARAM wParam, LPARAM lParam )
{
    m_nPreviewAlignment = lParam;
    if (wParam)
        AdjustWindowSize();
    return 0;
}

void CWiaPreviewWindowFrame::AdjustWindowSize(void)
{
    HWND hWndPreview = GetDlgItem(m_hWnd,IDC_INNER_PREVIEW_WINDOW);
    if (hWndPreview)
    {
        if (!m_bHideEmptyPreview || WiaPreviewControl_GetBitmap(hWndPreview))
        {
            // Make sure the window is visible
            if (!IsWindowVisible(hWndPreview))
            {
                ShowWindow(hWndPreview,SW_SHOW);
            }

            // Get the window's client size and shrink it by the border size
            CSimpleRect rcClient(m_hWnd);
            rcClient.Inflate(-(int)m_nSizeBorder,-(int)m_nSizeBorder);

            // This will be used to take into account the size of the internal border and frame, so we will
            // have *EXACT* aspect ratio calculations
            UINT nAdditionalBorder = WiaPreviewControl_GetBorderSize(hWndPreview,0) * 2;

            // I am assuming the border will be same size in pixels on all sides
            nAdditionalBorder += GetSystemMetrics( SM_CXBORDER ) * 2;

            // Normally, we will allow stretching.
            // Assume we won't be doing a proportional resize
            POINT ptPreviewWndOrigin = { rcClient.left, rcClient.top };
            SIZE  sizePreviewWindowExtent = { rcClient.Width(), rcClient.Height() };

            // Don't want any divide by zero errors
            if (m_sizeAspectRatio.cx && m_sizeAspectRatio.cy)
            {
                SIZE sizePreview = m_sizeAspectRatio;
                if (m_bEnableStretch ||
                    sizePreview.cx > (int)(rcClient.Width()-nAdditionalBorder) ||
                    sizePreview.cy > (int)(rcClient.Height()-nAdditionalBorder))
                {
                    sizePreview = WiaUiUtil::ScalePreserveAspectRatio( rcClient.Width()-nAdditionalBorder, rcClient.Height()-nAdditionalBorder, m_sizeAspectRatio.cx, m_sizeAspectRatio.cy );
                }

                // Make sure it won't be invisible
                if (sizePreview.cx && sizePreview.cy)
                {
                    // Decide where to place it in the x direction
                    if (LOWORD(m_nPreviewAlignment) & PREVIEW_WINDOW_RIGHT)
                        ptPreviewWndOrigin.x = m_nSizeBorder + rcClient.Width() - sizePreview.cx - nAdditionalBorder;
                    else if (LOWORD(m_nPreviewAlignment) & PREVIEW_WINDOW_LEFT)
                        ptPreviewWndOrigin.x = m_nSizeBorder;
                    else ptPreviewWndOrigin.x = ((rcClient.Width() + m_nSizeBorder*2) - sizePreview.cx - nAdditionalBorder) / 2;

                    // Decide where to place it in the y direction
                    if (HIWORD(m_nPreviewAlignment) & PREVIEW_WINDOW_BOTTOM)
                        ptPreviewWndOrigin.y = m_nSizeBorder + rcClient.Height() - sizePreview.cy - nAdditionalBorder;
                    else if (HIWORD(m_nPreviewAlignment) & PREVIEW_WINDOW_TOP)
                        ptPreviewWndOrigin.y = m_nSizeBorder;
                    else ptPreviewWndOrigin.y = ((rcClient.Height() + m_nSizeBorder*2) - sizePreview.cy - nAdditionalBorder) / 2;

                    sizePreviewWindowExtent.cx = sizePreview.cx + nAdditionalBorder;
                    sizePreviewWindowExtent.cy = sizePreview.cy + nAdditionalBorder;
                }
            }

            // Now get the current size to make sure we don't resize the window unnecessarily
            CSimpleRect rcPreview( hWndPreview, CSimpleRect::WindowRect );
            rcPreview.ScreenToClient( m_hWnd );

            if (rcPreview.left != ptPreviewWndOrigin.x ||
                rcPreview.top != ptPreviewWndOrigin.y ||
                rcPreview.Width() != sizePreviewWindowExtent.cx ||
             rcPreview.Height() != sizePreviewWindowExtent.cy)
            {
                SetWindowPos( hWndPreview, NULL, ptPreviewWndOrigin.x, ptPreviewWndOrigin.y, sizePreviewWindowExtent.cx, sizePreviewWindowExtent.cy, SWP_NOZORDER|SWP_NOACTIVATE );
            }
        }
        else
        {
            // Hide the preview window if we're supposed to
            ShowWindow(hWndPreview,SW_HIDE);
        }
    }
}

void CWiaPreviewWindowFrame::ResizeClientIfNecessary(void)
{
    HWND hWndPreview = GetDlgItem( m_hWnd, IDC_INNER_PREVIEW_WINDOW );
    if (hWndPreview)
    {
        SIZE sizePreviousAspectRatio = m_sizeAspectRatio;
        m_sizeAspectRatio.cx = m_sizeAspectRatio.cy = 0;
        if (WiaPreviewControl_GetPreviewMode(hWndPreview))
        {
            SIZE sizeCurrResolution;
            if (WiaPreviewControl_GetResolution( hWndPreview, &sizeCurrResolution ))
            {
                SIZE sizePixelResolution;
                if (WiaPreviewControl_GetImageSize( hWndPreview, &sizePixelResolution ))
                {
                    WiaPreviewControl_SetResolution( hWndPreview, &sizePixelResolution );
                    SIZE sizeSelExtent;
                    if (WiaPreviewControl_GetSelExtent( hWndPreview, 0, 0, &sizeSelExtent ))
                    {
                        m_sizeAspectRatio = sizeSelExtent;
                    }
                    WiaPreviewControl_SetResolution( hWndPreview, &sizeCurrResolution );
                }
            }
        }
        else
        {
            if (m_sizeDefAspectRatio.cx || m_sizeDefAspectRatio.cy)
            {
                m_sizeAspectRatio = m_sizeDefAspectRatio;
            }
            else
            {
                SIZE sizeImage;
                if (WiaPreviewControl_GetImageSize( hWndPreview, &sizeImage ))
                {
                    m_sizeAspectRatio = sizeImage;
                }
            }
        }

        if (!m_sizeAspectRatio.cx || !m_sizeAspectRatio.cy)
        {
            m_sizeAspectRatio = m_sizeDefAspectRatio;
        }

        if (m_sizeAspectRatio.cx != sizePreviousAspectRatio.cx || m_sizeAspectRatio.cy != sizePreviousAspectRatio.cy)
        {
            AdjustWindowSize();
        }
    }
}

LRESULT CWiaPreviewWindowFrame::OnGetEnableStretch( WPARAM, LPARAM )
{
    return (m_bEnableStretch != false);
}

LRESULT CWiaPreviewWindowFrame::OnSetEnableStretch( WPARAM, LPARAM lParam )
{
    m_bEnableStretch = (lParam != FALSE);
    ResizeClientIfNecessary();
    return 0;
}


LRESULT CWiaPreviewWindowFrame::OnSetBitmap( WPARAM wParam, LPARAM lParam )
{
    SendMessage( m_hWnd, WM_SETREDRAW, 0, 0 );
    SendDlgItemMessage( m_hWnd, IDC_INNER_PREVIEW_WINDOW, PWM_SETBITMAP, wParam, lParam );
    ResizeClientIfNecessary();
    SendMessage( m_hWnd, WM_SETREDRAW, 1, 0 );
    // Make sure the border of the preview control is drawn correctly.
    // This is a workaround for a weird bug that causes the resized border to not be redrawn
    SetWindowPos( GetDlgItem( m_hWnd, IDC_INNER_PREVIEW_WINDOW ), NULL, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER|SWP_DRAWFRAME );
    InvalidateRect( GetDlgItem( m_hWnd, IDC_INNER_PREVIEW_WINDOW ), NULL, FALSE );
    UpdateWindow( GetDlgItem( m_hWnd, IDC_INNER_PREVIEW_WINDOW ) );
    InvalidateRect( m_hWnd, NULL, TRUE );
    UpdateWindow( m_hWnd );
    return 0;
}


// wParam = MAKEWPARAM((BOOL)bOuterBorder,0), lParam = 0
LRESULT CWiaPreviewWindowFrame::OnGetBkColor( WPARAM wParam, LPARAM )
{
    if (!LOWORD(wParam))
    {
        // Meant for the inner window
        return (SendMessage( GetDlgItem( m_hWnd, IDC_INNER_PREVIEW_WINDOW ), PWM_GETBKCOLOR, 0, 0 ));
    }
    else
    {
        LOGBRUSH lb = {0};
        GetObject(m_hBackgroundBrush,sizeof(LOGBRUSH),&lb);
        return (lb.lbColor);
    }
}

// wParam = MAKEWPARAM((BOOL)bOuterBorder,(BOOL)bRepaint), lParam = (COLORREF)color
LRESULT CWiaPreviewWindowFrame::OnSetBkColor( WPARAM wParam, LPARAM lParam )
{
    if (!LOWORD(wParam))
    {
        // Meant for the inner window
        SendMessage( GetDlgItem( m_hWnd, IDC_INNER_PREVIEW_WINDOW ), PWM_SETBKCOLOR, HIWORD(wParam), lParam );
    }
    else
    {
        HBRUSH hBrush = CreateSolidBrush( static_cast<COLORREF>(lParam) );
        if (hBrush)
        {
            if (m_hBackgroundBrush)
            {
                DeleteObject(m_hBackgroundBrush);
                m_hBackgroundBrush = NULL;
            }
            m_hBackgroundBrush = hBrush;
            if (HIWORD(wParam))
            {
                InvalidateRect( m_hWnd, NULL, TRUE );
                UpdateWindow( m_hWnd );
            }
        }
    }
    return (0);
}


LRESULT CWiaPreviewWindowFrame::OnCommand( WPARAM wParam, LPARAM lParam )
{
    // Forward notifications to the parent
    return (SendNotifyMessage( GetParent(m_hWnd), WM_COMMAND, MAKEWPARAM(GetWindowLongPtr(m_hWnd,GWLP_ID),HIWORD(wParam)), reinterpret_cast<LPARAM>(m_hWnd) ));
}


LRESULT CWiaPreviewWindowFrame::OnSetDefAspectRatio( WPARAM wParam, LPARAM lParam )
{
    SIZE *pNewDefAspectRatio = reinterpret_cast<SIZE*>(lParam);
    if (pNewDefAspectRatio)
    {
        m_sizeDefAspectRatio = *pNewDefAspectRatio;
    }
    else
    {
        m_sizeDefAspectRatio.cx = m_sizeDefAspectRatio.cy = 0;
    }

    ResizeClientIfNecessary();

    return (0);
}


BOOL CWiaPreviewWindowFrame::RegisterClass( HINSTANCE hInstance )
{
    WNDCLASS wc;
    memset( &wc, 0, sizeof(wc) );
    wc.style = CS_DBLCLKS;
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.hbrBackground = NULL;
    wc.lpszClassName = PREVIEW_WINDOW_FRAME_CLASS;
    BOOL res = (::RegisterClass(&wc) != 0);
    return(res != 0);
}

LRESULT CWiaPreviewWindowFrame::OnSetPreviewMode( WPARAM wParam, LPARAM lParam )
{
    SendMessage( m_hWnd, WM_SETREDRAW, 0, 0 );
    LRESULT lRes = SendDlgItemMessage( m_hWnd, IDC_INNER_PREVIEW_WINDOW, PWM_SETPREVIEWMODE, wParam, lParam );
    ResizeClientIfNecessary();
    SendMessage( m_hWnd, WM_SETREDRAW, 1, 0 );
    // Make sure the border of the preview control is drawn correctly.
    // This is a workaround for a weird bug that causes the resized border to not be redrawn
    SetWindowPos( GetDlgItem( m_hWnd, IDC_INNER_PREVIEW_WINDOW ), NULL, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER|SWP_DRAWFRAME );
    InvalidateRect( GetDlgItem( m_hWnd, IDC_INNER_PREVIEW_WINDOW ), NULL, FALSE );
    UpdateWindow( GetDlgItem( m_hWnd, IDC_INNER_PREVIEW_WINDOW ) );
    InvalidateRect( m_hWnd, NULL, TRUE );
    UpdateWindow( m_hWnd );
    return lRes;
}

LRESULT CALLBACK CWiaPreviewWindowFrame::WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_MESSAGE_HANDLERS(CWiaPreviewWindowFrame)
    {
        // Handle these messages
        SC_HANDLE_MESSAGE( WM_CREATE, OnCreate );
        SC_HANDLE_MESSAGE( WM_SIZE, OnSize );
        SC_HANDLE_MESSAGE( WM_SETFOCUS, OnSetFocus );
        SC_HANDLE_MESSAGE( WM_ENABLE, OnEnable );
        SC_HANDLE_MESSAGE( WM_ERASEBKGND, OnEraseBkgnd );
        SC_HANDLE_MESSAGE( PWM_SETBITMAP, OnSetBitmap );
        SC_HANDLE_MESSAGE( WM_COMMAND, OnCommand );
        SC_HANDLE_MESSAGE( PWM_GETBKCOLOR, OnGetBkColor );
        SC_HANDLE_MESSAGE( PWM_SETBKCOLOR, OnSetBkColor );
        SC_HANDLE_MESSAGE( PWM_SETDEFASPECTRATIO, OnSetDefAspectRatio );
        SC_HANDLE_MESSAGE( PWM_SETPREVIEWMODE, OnSetPreviewMode );
        SC_HANDLE_MESSAGE( PWM_GETCLIENTSIZE, OnGetClientSize );
        SC_HANDLE_MESSAGE( PWM_GETENABLESTRETCH, OnGetEnableStretch );
        SC_HANDLE_MESSAGE( PWM_SETENABLESTRETCH, OnSetEnableStretch );
        SC_HANDLE_MESSAGE( PWM_SETBORDERSIZE, OnSetBorderSize );
        SC_HANDLE_MESSAGE( PWM_GETBORDERSIZE, OnGetBorderSize );
        SC_HANDLE_MESSAGE( PWM_HIDEEMPTYPREVIEW, OnHideEmptyPreview );
        SC_HANDLE_MESSAGE( PWM_SETPREVIEWALIGNMENT, OnSetPreviewAlignment );

        // Forward all of these standard messages to the control
        SC_FORWARD_MESSAGE( WM_ENTERSIZEMOVE, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( WM_EXITSIZEMOVE, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( WM_SETTEXT, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );

        // Forward all of these private messages to the control
        SC_FORWARD_MESSAGE( PWM_SETRESOLUTION, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_GETRESOLUTION, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_CLEARSELECTION, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_GETIMAGESIZE, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_GETBITMAP, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_GETHANDLESIZE, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_GETBGALPHA, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_GETHANDLETYPE, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_SETBGALPHA, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_SETHANDLETYPE, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_GETSELCOUNT, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_GETSELORIGIN, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_GETSELEXTENT, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_SETSELORIGIN, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_SETSELEXTENT, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_GETALLOWNULLSELECTION, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_SETALLOWNULLSELECTION, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_SELECTIONDISABLED, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_SETHANDLESIZE, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_DISABLESELECTION, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_DETECTREGIONS, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_GETPREVIEWMODE, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_SETBORDERSTYLE, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_SETBORDERCOLOR, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_SETHANDLECOLOR, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_REFRESHBITMAP, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_SETPROGRESS, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_GETPROGRESS, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_GETUSERCHANGEDSELECTION, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
        SC_FORWARD_MESSAGE( PWM_SETUSERCHANGEDSELECTION, GetDlgItem( hWnd, IDC_INNER_PREVIEW_WINDOW ) );
    }
    SC_END_MESSAGE_HANDLERS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prevwnd\pwframe.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       PWFRAME.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        8/12/1999
 *
 *  DESCRIPTION: Preview window frame declaration
 *
 *******************************************************************************/
#ifndef __PWFRAME_H_INCLUDED
#define __PWFRAME_H_INCLUDED

#include <windows.h>

class CWiaPreviewWindowFrame
{
private:

    // Constants
    enum
    {
        DEFAULT_BORDER_SIZE = 4
    };

    HWND   m_hWnd;
    SIZE   m_sizeAspectRatio;
    SIZE   m_sizeDefAspectRatio;
    UINT   m_nSizeBorder;
    HBRUSH m_hBackgroundBrush;
    bool   m_bEnableStretch;
    bool   m_bHideEmptyPreview;
    LPARAM m_nPreviewAlignment;

private:
    // No implementation
    CWiaPreviewWindowFrame(void);
    CWiaPreviewWindowFrame( const CWiaPreviewWindowFrame & );
    CWiaPreviewWindowFrame &operator=( const CWiaPreviewWindowFrame & );

private:
    explicit CWiaPreviewWindowFrame( HWND hWnd );
    ~CWiaPreviewWindowFrame(void);

    static int FillRect( HDC hDC, HBRUSH hBrush, int x1, int y1, int x2, int y2 );
    void AdjustWindowSize(void);
    void ResizeClientIfNecessary(void);

    LRESULT OnCreate( WPARAM, LPARAM lParam );
    LRESULT OnSize( WPARAM wParam, LPARAM );
    LRESULT OnSetFocus( WPARAM, LPARAM );
    LRESULT OnEnable( WPARAM wParam, LPARAM );
    LRESULT OnEraseBkgnd( WPARAM wParam, LPARAM );
    LRESULT OnSetBitmap( WPARAM wParam, LPARAM lParam );
    LRESULT OnSetPreviewMode( WPARAM wParam, LPARAM lParam );
    LRESULT OnGetBkColor( WPARAM wParam, LPARAM );
    LRESULT OnSetBkColor( WPARAM wParam, LPARAM lParam );
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam );
    LRESULT OnSetDefAspectRatio( WPARAM wParam, LPARAM lParam );
    LRESULT OnGetClientSize( WPARAM, LPARAM );
    LRESULT OnGetEnableStretch( WPARAM, LPARAM );
    LRESULT OnSetEnableStretch( WPARAM, LPARAM );
    LRESULT OnSetBorderSize( WPARAM, LPARAM );
    LRESULT OnGetBorderSize( WPARAM, LPARAM );
    LRESULT OnHideEmptyPreview( WPARAM, LPARAM );
    LRESULT OnSetPreviewAlignment( WPARAM, LPARAM );

public:
    static BOOL RegisterClass( HINSTANCE hInstance );
    static LRESULT CALLBACK WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prevwnd\prevwnd.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       PREVWND.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        8/12/1999
 *
 *  DESCRIPTION: Preview window class declaration
 *
 *******************************************************************************/
#ifndef _PREVWND_H
#define _PREVWND_H

#include <windows.h>
#include "regionde.h"

#if defined(OLD_CRAPPY_HOME_SETUP)
    extern "C"
    {
    typedef struct _BLENDFUNCTION
    {
        BYTE   BlendOp;
        BYTE   BlendFlags;
        BYTE   SourceConstantAlpha;
        BYTE   AlphaFormat;
    }BLENDFUNCTION;
    #define AC_SRC_OVER                 0x00
    typedef BOOL (WINAPI *AlphaBlendFn)( HDC, int, int, int, int, HDC, int, int, int, int, BLENDFUNCTION);
    };
#endif //OLD_CRAPPY_HOME_SETUP

class CWiaPreviewWindow
{
private:
    HWND          m_hWnd;
    BLENDFUNCTION m_bfBlendFunction;
    BOOL          m_bDeleteBitmap;
    BOOL          m_bSizing;
    BOOL          m_bAllowNullSelection;
    BOOL          m_SelectionDisabled;

    HBITMAP       m_hBufferBitmap;      // The double buffer bitmap
    HBITMAP       m_hPaintBitmap;       // The scaled image
    HBITMAP       m_hAlphaBitmap;       // The alpha blended bitmap
    HBITMAP       m_hPreviewBitmap;     // This is the actual full size image
    SIZE          m_BitmapSize;         // Actual size of the bitmap

    HCURSOR       m_hCurrentCursor;     // Used when windows sends us a WM_SETCURSOR message

    HCURSOR       m_hCursorArrow;
    HCURSOR       m_hCursorCrossHairs;
    HCURSOR       m_hCursorMove;
    HCURSOR       m_hCursorSizeNS;
    HCURSOR       m_hCursorSizeNeSw;
    HCURSOR       m_hCursorSizeNwSe;
    HCURSOR       m_hCursorSizeWE;
    HPEN          m_aHandlePens[3];
    HPEN          m_aBorderPens[3];
    HBRUSH        m_aHandleBrushes[3];
    HPEN          m_hHandleHighlight;
    HPEN          m_hHandleShadow;
    RECT          m_rcCurrSel;
    RECT          m_rectSavedDetected; // the user can double click to snap back to the selected region
    SIZE          m_Delta;
    SIZE          m_ImageSize;
    SIZE          m_Resolution;
    int           m_MovingSel;
    UINT          m_nBorderSize;
    int           m_nHandleType;
    UINT          m_nHandleSize;
    HPALETTE      m_hHalftonePalette;
    RECT          m_rcSavedImageRect;
    int           m_nCurrentRect;
    bool          m_bSuccessfulRegionDetection;  // have we succesfully detected regions for this scan?
    HBRUSH        m_hBackgroundBrush;
    bool          m_bPreviewMode;
    bool          m_bUserChangedSelection;

    // We store all of the pens and brushes we use in arrays.  These serve as mnemonic indices.
    enum
    {
        Selected      = 0,
        Unselected    = 1,
        Disabled      = 2,
    };

protected:
    void     DestroyBitmaps(void);
    void     DrawHandle( HDC hDC, const RECT &r, int nState );
    RECT     GetSizingHandleRect( const RECT &rcSel, int iWhich );
    RECT     GetSelectionRect( RECT &rcSel, int iWhich );
    POINT    GetCornerPoint( int iWhich );
    void     DrawSizingFrame( HDC hDC, RECT &rc, bool bFocus, bool bDisabled );
    int      GetHitArea( POINT &pt );
    void     NormalizeRect( RECT &r );
    void     SendSelChangeNotification( bool bSetUserChangedSelection=true );
    void     GenerateNewBitmap(void);
    RECT     GetImageRect(void);
    void     Repaint( PRECT pRect, bool bErase );
    bool     IsAlphaBlendEnabled(void);
    HPALETTE SetHalftonePalette( HDC hDC );
    RECT     ScaleSelectionRect( const RECT &rcOriginalImage, const RECT &rcCurrentImage, const RECT &rcOriginalSel );
    RECT     GetDefaultSelection(void);
    BOOL     IsDefaultSelectionRect( const RECT &rc );
    int      GetSelectionRectCount(void);
    void     PaintWindowTitle( HDC hDC );

    void     SetCursor( HCURSOR hCursor );
    bool     GetOriginAndExtentInImagePixels( WORD nItem, POINT &ptOrigin, SIZE &sizeExtent );
    void     CreateNewBitmaps(void);
    void     DrawBitmaps(void);
    void     ResizeProgressBar();

    // Region detection helper functions:
    int      XConvertToBitmapCoords(int x);
    int      XConvertToScreenCoords(int x);
    int      YConvertToBitmapCoords(int y);
    int      YConvertToScreenCoords(int y);

    POINT    ConvertToBitmapCoords(POINT p);
    POINT    ConvertToScreenCoords(POINT p);
    RECT     ConvertToBitmapCoords(RECT r);
    RECT     ConvertToScreenCoords(RECT r);

    RECT     GrowRegion(RECT r, int border);

private:
    // No implementation
    CWiaPreviewWindow(void);
    CWiaPreviewWindow( const CWiaPreviewWindow & );
    CWiaPreviewWindow &operator=( const CWiaPreviewWindow & );

public:
    explicit CWiaPreviewWindow( HWND hWnd );
    virtual  ~CWiaPreviewWindow(void);

    static   BOOL RegisterClass( HINSTANCE hInstance );
    static   LRESULT CALLBACK WndProc( HWND, UINT, WPARAM, LPARAM );

protected:
    // Standard windows messages
    LRESULT  OnPaint( WPARAM, LPARAM );
    LRESULT  OnSetCursor( WPARAM, LPARAM );
    LRESULT  OnMouseMove( WPARAM, LPARAM );
    LRESULT  OnLButtonDown( WPARAM, LPARAM );
    LRESULT  OnLButtonUp( WPARAM, LPARAM );
    LRESULT  OnLButtonDblClk( WPARAM, LPARAM );
    LRESULT  OnCreate( WPARAM, LPARAM );
    LRESULT  OnSize( WPARAM, LPARAM );
    LRESULT  OnGetDlgCode( WPARAM, LPARAM );
    LRESULT  OnKeyDown( WPARAM, LPARAM );
    LRESULT  OnSetFocus( WPARAM, LPARAM );
    LRESULT  OnKillFocus( WPARAM, LPARAM );
    LRESULT  OnEnable( WPARAM, LPARAM );
    LRESULT  OnEraseBkgnd( WPARAM, LPARAM );
    LRESULT  OnEnterSizeMove( WPARAM, LPARAM );
    LRESULT  OnExitSizeMove( WPARAM, LPARAM );
    LRESULT  OnSetText( WPARAM, LPARAM );

    // Our messages
    LRESULT  OnClearSelection( WPARAM, LPARAM );
    LRESULT  OnSetResolution( WPARAM, LPARAM );
    LRESULT  OnGetResolution( WPARAM, LPARAM );
    LRESULT  OnSetBitmap( WPARAM, LPARAM );
    LRESULT  OnGetBitmap( WPARAM, LPARAM );
    LRESULT  OnGetBorderSize( WPARAM, LPARAM );
    LRESULT  OnGetHandleSize( WPARAM, LPARAM );
    LRESULT  OnGetBgAlpha( WPARAM, LPARAM );
    LRESULT  OnGetHandleType( WPARAM, LPARAM );
    LRESULT  OnSetBorderSize( WPARAM, LPARAM );
    LRESULT  OnSetHandleSize( WPARAM, LPARAM );
    LRESULT  OnSetBgAlpha( WPARAM, LPARAM );
    LRESULT  OnSetHandleType( WPARAM, LPARAM );
    LRESULT  OnGetSelOrigin( WPARAM, LPARAM );
    LRESULT  OnGetSelExtent( WPARAM, LPARAM );
    LRESULT  OnSetSelOrigin( WPARAM, LPARAM );
    LRESULT  OnSetSelExtent( WPARAM, LPARAM );
    LRESULT  OnGetSelCount( WPARAM, LPARAM );
    LRESULT  OnGetAllowNullSelection( WPARAM, LPARAM );
    LRESULT  OnSetAllowNullSelection( WPARAM, LPARAM );
    LRESULT  OnGetDisableSelection( WPARAM, LPARAM );
    LRESULT  OnSetDisableSelection( WPARAM, LPARAM );
    LRESULT  OnDetectRegions( WPARAM, LPARAM );
    LRESULT  OnGetBkColor( WPARAM, LPARAM );
    LRESULT  OnSetBkColor( WPARAM, LPARAM );
    LRESULT  OnSetPreviewMode( WPARAM, LPARAM );
    LRESULT  OnGetPreviewMode( WPARAM, LPARAM );
    LRESULT  OnGetImageSize( WPARAM, LPARAM );
    LRESULT  OnSetBorderStyle( WPARAM, LPARAM );
    LRESULT  OnSetBorderColor( WPARAM, LPARAM );
    LRESULT  OnSetHandleColor( WPARAM, LPARAM );
    LRESULT  OnRefreshBitmap( WPARAM, LPARAM );
    LRESULT  OnSetProgress( WPARAM, LPARAM );
    LRESULT  OnGetProgress( WPARAM, LPARAM );
    LRESULT  OnCtlColorStatic( WPARAM, LPARAM );
    LRESULT  OnGetUserChangedSelection( WPARAM, LPARAM );
    LRESULT  OnSetUserChangedSelection( WPARAM, LPARAM );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\archlv.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998
All rights reserved.

Module Name:

    archlv.hxx

Abstract:

    Driver Architecture List View 

Author:

    Steve Kiraly (SteveKi) 19-Nov-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "psetup.hxx"
#include "drvsetup.hxx"
#include "drvver.hxx"
#include "archlv.hxx"

/********************************************************************

    Arch List - static data.

********************************************************************/

//
// disable MIPS & PPC drivers, since they are not supported from setup
//
static TArchLV::ArchEncode aArchEncode[] = 
{
    {IDS_ARCH_IA64,      IDS_VERSION_51,         L"Windows IA64",          L"3",   DRIVER_IA64_3  },

    {IDS_ARCH_INTEL,     IDS_VERSION_WINDOWS_ME, L"Windows 4.0",           L"0",   DRIVER_WIN95   },

    {IDS_ARCH_INTEL,     IDS_VERSION_40_50,      L"Windows NT x86",        L"2",   DRIVER_X86_2   },
    {IDS_ARCH_INTEL,     IDS_VERSION_50_51,      L"Windows NT x86",        L"3",   DRIVER_X86_3   },

    {IDS_ARCH_ALPHA,     IDS_VERSION_40,         L"Windows NT Alpha_AXP",  L"2",   DRIVER_ALPHA_2 },

#if FALSE 
    {IDS_ARCH_INTEL,     IDS_VERSION_NT_31,      L"Windows NT x86",        L"1",   DRIVER_X86_0   },
    {IDS_ARCH_INTEL,     IDS_VERSION_35X,        L"Windows NT x86",        L"1",   DRIVER_X86_1   },

    {IDS_ARCH_MIPS,      IDS_VERSION_NT_31,      L"Windows NT R4000",      L"1",   DRIVER_MIPS_0  },
    {IDS_ARCH_MIPS,      IDS_VERSION_35X,        L"Windows NT R4000",      L"1",   DRIVER_MIPS_1  },
    {IDS_ARCH_MIPS,      IDS_VERSION_40,         L"Windows NT R4000",      L"2",   DRIVER_MIPS_2  },

    {IDS_ARCH_ALPHA,     IDS_VERSION_NT_31,      L"Windows NT Alpha_AXP",  L"1",   DRIVER_ALPHA_0 },
    {IDS_ARCH_ALPHA,     IDS_VERSION_35X,        L"Windows NT Alpha_AXP",  L"1",   DRIVER_ALPHA_1 },

    {IDS_ARCH_POWERPC,   IDS_VERSION_351,        L"Windows NT PowerPC",    L"1",   DRIVER_PPC_1   },
    {IDS_ARCH_POWERPC,   IDS_VERSION_40,         L"Windows NT PowerPC",    L"2",   DRIVER_PPC_2   }, 
#endif
};

// use this aliases for the driver version string, so we don't break 
// admin scripts written for Win2k.
static DWORD aVersionAliases[] = 
{
    IDS_VERSION_WINDOWS_95,     IDS_VERSION_WINDOWS_ME,
    IDS_VERSION_40,             IDS_VERSION_40_50,
    IDS_VERSION_50,             IDS_VERSION_50_51,
};

/********************************************************************

    Arch List view class.

********************************************************************/

TArchLV::
TArchLV(
    VOID
    ) : _hwnd( NULL ),
        _hwndLV( NULL ),
        _ColumnSortState( kMaxColumns ),
        _wmDoubleClickMsg( 0 ),
        _wmSingleClickMsg( 0 ),
        _uCurrentColumn( 0 ),
        _bNoItemCheck( FALSE )
{
    DBGMSG( DBG_TRACE, ( "TArchLV::ctor\n" ) );
    ArchDataList_vReset();
}

TArchLV::
~TArchLV(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TArchLV::dtor\n" ) );
    vRelease();
}

BOOL
TArchLV::
bSetUI(
    IN HWND     hwnd,
    IN WPARAM   wmDoubleClickMsg,
    IN WPARAM   wmSingleClickMsg
    )
{
    DBGMSG( DBG_TRACE, ( "TArchLV::bSetUI\n" ) );

    SPLASSERT( hwnd );
    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;

    //
    // Save the parent window handle.
    //
    _hwnd               = hwnd;
    _wmDoubleClickMsg   = wmDoubleClickMsg;
    _wmSingleClickMsg   = wmSingleClickMsg;                                 

    //
    // Get the driver list view handle.
    //
    _hwndLV = GetDlgItem( _hwnd, IDC_ARCHITECTURE_LIST );

    //
    // Add check boxes.
    //
    HIMAGELIST himlState = ImageList_Create( 16, 16, TRUE, 3, 0 );

    //
    // !! LATER !!
    // Should be created once then shared.
    //
    if( !himlState )
    {
        DBGMSG( DBG_ERROR, ( "ArchLV.bSetUI: ImageList_Create failed %d\n", GetLastError( )));
        return FALSE;
    }

    //
    // Load the bitmap for the check states.
    //
    HBITMAP hbm =  LoadBitmap( ghInst, MAKEINTRESOURCE( IDB_CHECKSTATES ));

    if( !hbm )
    {
        DBGMSG( DBG_ERROR, ( "ArchLV.bSetUI: LoadBitmap failed %d\n", GetLastError( )));
        return FALSE;
    }

    //
    // Add the bitmaps to the image list.
    //
    ImageList_AddMasked( himlState, hbm, RGB( 255, 0, 0 ));

    //
    // Set the new image list.
    //
    SendMessage( _hwndLV, LVM_SETIMAGELIST, LVSIL_STATE, (WPARAM)himlState );

    //
    // Remember to release the bitmap handle.
    //
    DeleteObject( hbm );

    //
    // Initialize the LV_COLUMN structure.
    //
    LV_COLUMN lvc;
    lvc.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt     = LVCFMT_LEFT;
    lvc.cx      = kDefaultHeaderWidth;

    //
    // Calculate the header column width.
    //
    RECT rc;
    if( !GetClientRect( _hwndLV, &rc ))
    {
        DBGMSG( DBG_WARN, ( "ArchLV.bSetUI: GetClientRect failed %d\n", GetLastError( )));
        return FALSE;
    }

    //
    // Get the total size of list view header, less the scroll bar.
    //
    LONG Interval = ( rc.right - rc.left ) - GetSystemMetrics( SM_CYVSCROLL );

    //
    // Column with array.
    //
    DWORD ColumnWidth [] = { Interval * 25, Interval * 55, Interval * 20 };

    //
    // Set the column header text.
    //
    TString strHeader;
    for( INT iCol = 0; iCol < kHeaderMax; ++iCol )
    {
        bStatus DBGCHK  = strHeader.bLoadString( ghInst, IDS_DRIVER_HEAD_ENVIRONMENT + iCol );
        lvc.pszText     = const_cast<LPTSTR>( static_cast<LPCTSTR>( strHeader ) );
        lvc.iSubItem    = iCol;
        lvc.cx          = ColumnWidth[iCol] / 100;

        if( ListView_InsertColumn( _hwndLV, iCol, &lvc ) == -1 )
        {
            DBGMSG( DBG_WARN, ( "ArchLV.bSetUI: LV_Insert failed %d\n", GetLastError( )));
            bStatus DBGCHK = FALSE;
        }
    }

    //
    // Enable full row selection and check boxes.
    //
    if( bStatus )
    {
        DWORD dwExStyle = ListView_GetExtendedListViewStyle( _hwndLV );
    	ListView_SetExtendedListViewStyle( _hwndLV, dwExStyle | LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP | LVS_EX_LABELTIP );
    }

    return bStatus;
}

BOOL
TArchLV::
bRefreshListView(
    IN LPCTSTR pszServerName,
    IN LPCTSTR pszDriverName
    )
{
    DBGMSG( DBG_TRACE, ( "TArchLV::bRefreshListView\n" ) );

    SPLASSERT( pszDriverName );

    //
    // Release current list view items.
    //
    vRelease();

    //
    // Reset the sort order 
    //
    _ColumnSortState.vResetAll();
    
    //
    // Fill the list view and sort it.
    //        
    BOOL bReturn = bFillListView( pszServerName, pszDriverName );
    
    //
    // Sort the list view         
    (VOID)bListViewSort( kVersionColumn );
    (VOID)bListViewSort( kArchitectureColumn );

    //
    // Reset the sort order 
    //
    _ColumnSortState.vResetAll();
    
    return bReturn;
}


BOOL
TArchLV::
bSetCheckDefaultArch(
    IN LPCTSTR pszServerName
    )
{
    TStatusB bStatus;
    DWORD dwCurrentEncode;
    TArchData *pArchData;

    //
    // Get the current machines architecture.
    //
    bStatus DBGCHK = bGetCurrentDriver( pszServerName, &dwCurrentEncode );

    if( bStatus )
    {
        bStatus DBGNOCHK = FALSE;

        DWORD cItems = ListView_GetItemCount( _hwndLV );

        for( UINT i = 0; i < cItems; i++ )
        {
            if( bGetItemData( i, &pArchData ) )
            {
                if( dwCurrentEncode == pArchData->_Encode )
                {
                    if( ( ListView_GetItemState( _hwndLV, i, kStateMask ) & kStateChecked ) && pArchData->_bInstalled )
                    {
                        vCheckItem( i, 2 );
                    }
                    else
                    {
                        vCheckItem( i, TRUE );
                    }

                    bStatus DBGNOCHK = TRUE;
                    break;
                }
            }
        }
    }
    return bStatus;
}

BOOL
TArchLV::
bHandleNotifyMessage(
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    BOOL bStatus = TRUE;

    UNREFERENCED_PARAMETER( wParam );

    switch( uMsg )
    {
    case WM_NOTIFY:
        {
            if( (INT)wParam == GetDlgCtrlID( _hwndLV ) )
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;

                switch( pnmh->code )
                {
                case NM_DBLCLK:
                    DBGMSG( DBG_TRACE, ("ArchLV::NM_DBLCLK\n" ) );
                    vCheckItemClicked( (LPNMHDR)lParam );
                    if( _wmDoubleClickMsg )                                 
                    {
                        PostMessage( _hwnd, WM_COMMAND, _wmDoubleClickMsg, 0 );
                    }
                    break;

                case NM_CLICK:
                    DBGMSG( DBG_TRACE, ("ArchLV::NM_CLICK\n" ) );
                    vCheckItemClicked( (LPNMHDR)lParam );
                    if( _wmSingleClickMsg )                                 
                    {
                        PostMessage( _hwnd, WM_COMMAND, _wmSingleClickMsg, 0 );
                    }
                    break;

                case LVN_COLUMNCLICK:
                    DBGMSG( DBG_TRACE, ("ArchLV::LVN_COLUMNCLICK\n" ) );
                    {
                        NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;
                        (VOID)bListViewSort( pNm->iSubItem );
                    }
                    break;

                case LVN_KEYDOWN:
                    DBGMSG( DBG_TRACE, ("ArchLV::LVN_KEYDOWN\n" ) );
                    {
                        if( bListVeiwKeydown( lParam ) )
                        {                            
                            if( _wmDoubleClickMsg )                                 
                            {
                                PostMessage( _hwnd, WM_COMMAND, _wmDoubleClickMsg, 0 );
                            }
                        }
                    }
                    break;

                default:
                    bStatus = FALSE;
                    break;
                }
            }
            else
            {
                bStatus = FALSE;
            }
        }
        break;

    //
    // Message not handled.
    //
    default:
        bStatus = FALSE;
        break;
    }

    return bStatus;
}

VOID
TArchLV::
vSelectItem(
    IN UINT iIndex
    )
{ 
    //
    // Select the specified item.
    //
    if( iIndex != -1 )
    {
        ListView_SetItemState( _hwndLV, iIndex, LVIS_SELECTED | LVIS_FOCUSED, 0x000F );
        ListView_EnsureVisible( _hwndLV, iIndex, FALSE );
    }
}

VOID
TArchLV::
vNoItemCheck(
    VOID
    )
{
    _bNoItemCheck = TRUE;
}

BOOL
TArchLV::
bEncodeToArchAndVersion(
    IN  DWORD    dwEncode,
    OUT TString &strArch,
    OUT TString &strVersion
    )
{
    TStatusB bStatus;
    bStatus DBGNOCHK = FALSE;

    for( UINT i = 0; i < COUNTOF( aArchEncode ); i++ )
    {
        if( aArchEncode[i].Encode == dwEncode )
        {
            bStatus DBGCHK = strArch.bLoadString( ghInst, aArchEncode[i].ArchId );
            bStatus DBGCHK = strVersion.bLoadString( ghInst, aArchEncode[i].VersionId );
            break;
        }
    }
    return bStatus;
}

BOOL
TArchLV::
bArchAndVersionToEncode(
    OUT DWORD       *pdwEncode,
    IN  LPCTSTR     pszArchitecture,
    IN  LPCTSTR     pszVersion,
    IN  BOOL        bUseNonLocalizedStrings
    )
{
    BOOL        bReturn         = FALSE;
    TString     strArch;
    TString     strVersion;
    TStatusB    bStatus;
    
    if (pdwEncode && pszArchitecture && pszVersion) 
    {
        if (bUseNonLocalizedStrings) 
        {
            for (UINT i = 0; i < COUNTOF(aArchEncode); i++)
            {
                if (!_tcsicmp(aArchEncode[i].NonLocalizedEnvironment, pszArchitecture) && 
                    !_tcsicmp(aArchEncode[i].NonLocalizedVersion, pszVersion))
                {
                    *pdwEncode = aArchEncode[i].Encode;
                    bReturn = TRUE;
                    break;
                }
            }            
        }
        else
        {
            UINT i;
            TString strMappedVersion;

            // check to remap the version string if necessary. 
            for (i = 0; (i+1) < COUNTOF( aVersionAliases ); i+=2)
            {
                bStatus DBGCHK = strMappedVersion.bLoadString(ghInst, aVersionAliases[i]);
                if( bStatus && 0 == lstrcmp(strMappedVersion, pszVersion) )
                {
                    // this version string was remapped, map to the new string.
                    bStatus DBGCHK = strMappedVersion.bLoadString(ghInst, aVersionAliases[i+1]);
                    if( bStatus )
                    {
                        pszVersion = strMappedVersion;
                    }
                }
            }

            // find the arch & version, and do the encode
            for (i = 0; i < COUNTOF( aArchEncode ); i++)
            {
                bStatus DBGCHK = strArch.bLoadString(ghInst, aArchEncode[i].ArchId);
                bStatus DBGCHK = strVersion.bLoadString(ghInst, aArchEncode[i].VersionId);
        
                if (!_tcsicmp(strArch, pszArchitecture) && !_tcsicmp(strVersion, pszVersion))
                {
                    *pdwEncode = aArchEncode[i].Encode;
                    bReturn = TRUE;
                    break;
                }
            }
        }
    }
    
    return bReturn;                     
}

BOOL
TArchLV::
bGetEncodeFromIndex( 
    IN  UINT    uIndex, 
    OUT DWORD   *pdwEncode 
    ) 
{
    BOOL bReturn = FALSE;

    //
    // Validate the passed in index.
    //
    if( uIndex < COUNTOF( aArchEncode ) )
    {
        //
        // Return back the encode for the given index.
        //
        *pdwEncode = aArchEncode[uIndex].Encode;
        bReturn = TRUE;
    }
    return bReturn;
}

/********************************************************************

    Private member functions.

********************************************************************/
BOOL
TArchLV::
vCheckItemClicked(
    IN LPNMHDR pnmh
    )
{
    BOOL bReturn = FALSE;

    DWORD dwPoints = GetMessagePos();
    POINTS &pt = MAKEPOINTS( dwPoints );
    LV_HITTESTINFO lvhti;

    lvhti.pt.x = pt.x;
    lvhti.pt.y = pt.y;

    MapWindowPoints( HWND_DESKTOP, _hwndLV, &lvhti.pt, 1 );

    INT iItem = ListView_HitTest( _hwndLV, &lvhti );

    //
    // Allow either a double click, or a single click on the
    // check box to toggle the check mark.
    //
    if( pnmh->code == NM_DBLCLK || lvhti.flags & LVHT_ONITEMSTATEICON )
    {
        vItemClicked( iItem );
        bReturn = TRUE;
    }

    return bReturn;
}


BOOL
TArchLV::
bListVeiwKeydown( 
    IN LPARAM lParam 
    )
{
    BOOL bReturn = FALSE;

    LV_KEYDOWN* plvnkd = (LV_KEYDOWN *)lParam;

    //
    // !! LATER !!
    //
    // Is this the best way to check whether the ALT
    // key is _not_ down?
    //
    if( plvnkd->wVKey == TEXT( ' ' ) &&
        !( GetKeyState( VK_LMENU ) & 0x80000000 ) &&
        !( GetKeyState( VK_RMENU ) & 0x80000000 ))
    {
        //
        // Get the selected item index.
        //
        INT iIndex = ListView_GetNextItem( _hwndLV, -1, LVNI_SELECTED );
         
        if( iIndex != -1 )
        {                            
            vItemClicked( iIndex );
            bReturn = TRUE;
        }
    }

    return bReturn;
}

VOID
TArchLV::
vRelease(
    VOID
    )
{
    //
    // Release all the list view items.
    //
    ListView_DeleteAllItems( _hwndLV );

    // 
    // Release the data from the architecture data list.
    //
    TIter Iter;
    TArchData *pArchData;

    for( ArchDataList_vIterInit( Iter ), Iter.vNext(); Iter.bValid(); ){

        pArchData = ArchDataList_pConvert( Iter );
        Iter.vNext();

        delete pArchData;
    }
}

BOOL
TArchLV::
bFillListView(
    IN LPCTSTR pszServerName,
    IN LPCTSTR pszDriverName
    )
{
    DBGMSG( DBG_TRACE, ( "TArchLV::bFillListView\n" ) );

    //
    // Fill the list view.
    //
    TStatusB bStatus;
    bStatus DBGNOCHK = FALSE;

    TPrinterDriverInstallation Di( pszServerName );
    
    if( VALID_OBJ( Di ) )
    {
        TString strArchitecture;
        TString strVersion;
        TString strInstalled;
        TString strNotInstalled;
        LPCTSTR pszInstalled;
        BOOL    bInstalled;

        //
        // Tell the driver installation class the driver name.
        //
        bStatus DBGCHK = Di.bSetDriverName( pszDriverName );

        //
        // Load the string "(installed)" from the resource file.
        //
        bStatus DBGCHK = strInstalled.bLoadString( ghInst, IDS_DRIVER_INSTALLED );
        bStatus DBGCHK = strNotInstalled.bLoadString( ghInst, IDS_DRIVER_NOTINSTALLED );

        for( UINT i = 0; i < COUNTOF( aArchEncode ); i++ )
        {
            //
            // some of the new env (like "Windows IA64") are not supported
            // in the old versions of the OS, so we need to check explicitly
            //
            if( IDS_ARCH_IA64 == aArchEncode[i].ArchId )
            {
                DWORD cbBuffer = 0;
                DWORD cDrivers = 0;
                CAutoPtrSpl<DRIVER_INFO_3> spDI1;

                if( !VDataRefresh::bEnumDrivers(pszServerName, aArchEncode[i].NonLocalizedEnvironment, 1,
                                                spDI1.GetPPV(), &cbBuffer, &cDrivers) )
                {
                    // this environment is not supported from the (remote) spooler - just skip it!
                    continue;
                }
            }

            //
            // Load the string driver name string from the resource file.
            //
            bStatus DBGCHK = strArchitecture.bLoadString( ghInst, aArchEncode[i].ArchId );
            bStatus DBGCHK = strVersion.bLoadString( ghInst, aArchEncode[i].VersionId );

            //
            // If the driver is installed, tell the user.
            //
            bInstalled = Di.bIsDriverInstalled( aArchEncode[i].Encode );

            //
            // Set the installed string.
            //
            pszInstalled = bInstalled ? static_cast<LPCTSTR>( strInstalled ) : static_cast<LPCTSTR>( strNotInstalled );

            //
            // Allocate the architecture data.
            //
            TArchData *pArchData = new TArchData( strArchitecture, strVersion, pszInstalled, aArchEncode[i].Encode, bInstalled );

            //
            // If valid 
            //
            if( VALID_PTR( pArchData ) )
            {
                //
                // Add the architecture data to the linked list.
                //
                ArchDataList_vAppend( pArchData );

                //
                // Add the string to the list view.
                //
                LRESULT iIndex = iAddToListView( strArchitecture, strVersion, pszInstalled, (LPARAM)pArchData );

                //
                // Check this item if the driver is installed.
                //
                if( bInstalled && (iIndex != -1) )
                {
                    vCheckItem( iIndex,  2 );
                }
            }
            else
            {
                //
                // The object may have been allocated, however failed construction.
                //
                delete pArchData;
            }
        }
    }

    return bStatus;
}

LRESULT
TArchLV::
iAddToListView(
    IN LPCTSTR  pszArchitecture,
    IN LPCTSTR  pszVersion,
    IN LPCTSTR  pszInstalled,
    IN LPARAM   lParam
    )
{
    DBGMSG( DBG_TRACE, ( "TArchLV::AddToListView\n" ) );

    SPLASSERT( pszArchitecture );
    SPLASSERT( pszVersion );
    SPLASSERT( pszInstalled );

    LV_ITEM lvi = { 0 };

    //
    // Add driver information to the listview.
    //
    lvi.mask        = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE | LVIF_STATE;
    lvi.iItem       = ListView_GetItemCount( _hwndLV );
    lvi.pszText     = const_cast<LPTSTR>( pszArchitecture );
    lvi.lParam      = lParam;
    lvi.state       = kStateUnchecked;

    LRESULT iIndex = ListView_InsertItem( _hwndLV, &lvi );
    if( -1 != iIndex )
    {
        ListView_SetItemText( _hwndLV, iIndex, 1, const_cast<LPTSTR>( pszVersion ) );
        ListView_SetItemText( _hwndLV, iIndex, 2, const_cast<LPTSTR>( pszInstalled ) );
    }

    return iIndex;
}

BOOL
TArchLV::
bListViewSort(
    UINT uColumn
    )
{
    //
    // Set the surrent column number.
    //
    _uCurrentColumn = uColumn;

    //
    // Tell the list view to sort.
    //
    TStatusB bStatus;
    bStatus DBGCHK = ListView_SortItems( _hwndLV, iCompareProc, (LPARAM)this );

    //
    // Toggle the specified column sort state.
    //
    _ColumnSortState.bToggle( uColumn );

    return bStatus;
}

INT 
CALLBACK 
TArchLV::
iCompareProc(
    IN LPARAM lParam1, 
    IN LPARAM lParam2, 
    IN LPARAM RefData
    )
{
    TArchData   *pArchData1 = reinterpret_cast<TArchData *>( lParam1 );
    TArchData   *pArchData2 = reinterpret_cast<TArchData *>( lParam2 );
    TArchLV     *pArchLV    = reinterpret_cast<TArchLV *>( RefData );
    INT         iResult     = 0;
    LPCTSTR     strName1    = NULL;
    LPCTSTR     strName2    = NULL;

    if( pArchLV && pArchData1 && pArchData2 )
    {
        BOOL bStatus = TRUE;

        switch( pArchLV->_uCurrentColumn )
        {

        case kArchitectureColumn:
            strName1 = pArchData1->_strArchitecture;
            strName2 = pArchData2->_strArchitecture;
            break;

        case kVersionColumn:
            strName1 = pArchData1->_strVersion;
            strName2 = pArchData2->_strVersion;
            break;

        case kInstalledColumn:
            strName1 = pArchData1->_strInstalled;
            strName2 = pArchData2->_strInstalled;
            break;

        default:
            bStatus = FALSE;
            break;
    
        }

        if( bStatus )
        {
            if( pArchLV->_ColumnSortState.bRead( pArchLV->_uCurrentColumn ) )
                iResult = _tcsicmp( strName2, strName1 );
            else
                iResult = _tcsicmp( strName1, strName2 );
        }
    }

    return iResult;
}

UINT
TArchLV::
uGetCheckedItemCount(
    VOID
    )
{
    DWORD cItems = ListView_GetItemCount( _hwndLV );

    UINT uItemCount = 0;

    for( UINT i = 0; i < cItems; i++ )
    {
        if( ListView_GetItemState( _hwndLV, i, kStateMask ) & kStateChecked )
        {
            uItemCount++;
        }
    }
    return uItemCount;
}

BOOL
TArchLV::
bGetCheckedItems(
    IN UINT   uIndex,
    IN BOOL  *pbInstalled,
    IN DWORD *pdwEncode
    )
{   
    TArchData *pArchData;
    UINT uItemCount = 0;
    BOOL bReturn = FALSE;

    DWORD cItems = ListView_GetItemCount( _hwndLV );

    for( UINT i = 0; i < cItems; i++ )
    {
        if( ListView_GetCheckState( _hwndLV, i ) )
        {
            if( uItemCount++ == uIndex )
            {
                if( bGetItemData( i, &pArchData ) )
                {
                    *pdwEncode      = pArchData->_Encode;
                    *pbInstalled    = pArchData->_bInstalled;
                    bReturn         = TRUE;
                    break;
                }                    
            }
        }
    }
    return bReturn;
}

BOOL
TArchLV::
bGetItemData(
    IN INT          iItem,
    IN TArchData  **ppArchData
    ) const
{
    BOOL bStatus;

    LV_ITEM lvItem  = { 0 };
    lvItem.mask     = LVIF_PARAM;
    lvItem.iItem    = iItem; 
    
    bStatus = ListView_GetItem( _hwndLV, &lvItem );

    if( bStatus )
    {
        *ppArchData = reinterpret_cast<TArchData *>( lvItem.lParam );
    }

    return bStatus;         
}

/*++

Name:
    
    vItemClicked

Routine Description:

    User clicked in listview.  Check if item state should
    be changed.

    The item will also be selected.

Arguments:

    iItem - Item that has been clicked.

Return Value:

    Nothing.

--*/
VOID
TArchLV::
vItemClicked(
    IN INT iItem
    )
{
    TStatusB bStatus;
    TArchData *pArchData;

    //
    // Do nothing when an invalid index is passed.
    //
    if( iItem != -1 &&  !_bNoItemCheck )
    {
        //
        // Retrieve the old state, toggle it, then set it.
        //
        DWORD dwState = ListView_GetItemState( _hwndLV, iItem, kStateMask );

        //
        // Get the item data.
        //
        bStatus DBGCHK = bGetItemData( iItem, &pArchData );

        //
        // If item data was fetched.
        //
        if( bStatus && pArchData )
        {
            //
            // Only allow checking of the item that are not installed.
            //
            if( !pArchData->_bInstalled )
            {
                //
                // Toggle the current state.
                //
                vCheckItem( iItem,  dwState != kStateChecked );
            }
        }
    }
}

/*++

Name:
    
    vCheckItem

Routine Description:

    Change the specified items check state.

Arguments:

    iItem       - Item index to change the check state for.
    bCheckState - The new item check state, TRUE check, FALSE uncheck.

Return Value:

    Nothing.

--*/
VOID
TArchLV::
vCheckItem(
    IN INT      iItem,
    IN BOOL     bCheckState
    )
{
    //
    // Do nothing when an invalid index is passed.
    //
    if( iItem != -1 )
    {
        if( bCheckState == 2 )
        {
            //
            // Set the new check state.
            //
            ListView_SetItemState( _hwndLV, iItem, kStateDisabled, kStateMask | LVIS_SELECTED | LVIS_FOCUSED );
            return;
        }

        //
        // Set the item check state.
        //
        DWORD dwState = bCheckState ? kStateChecked | LVIS_SELECTED | LVIS_FOCUSED : kStateUnchecked | LVIS_SELECTED | LVIS_FOCUSED;

        //
        // Set the new check state.
        //
        ListView_SetItemState( _hwndLV, iItem, dwState, kStateMask | LVIS_SELECTED | LVIS_FOCUSED );
    }
}

/********************************************************************

    Architecure data.

********************************************************************/
TArchLV::TArchData::
TArchData(
    IN LPCTSTR pszArchitecture,
    IN LPCTSTR pszVersion,
    IN LPCTSTR pszInstalled,
    IN DWORD   Encode,
    IN BOOL    bInstalled
    ) : _strArchitecture( pszArchitecture ),
        _strVersion( pszVersion ),
        _strInstalled( pszInstalled ),
        _Encode( Encode ),
        _bInstalled( bInstalled )
{
    DBGMSG( DBG_TRACE, ( "TArchLV::TArchData::ctor\n" ) );
}

TArchLV::TArchData::
~TArchData(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TArchLV::TArchData::dtor\n" ) );

    //
    // If we are linked then remove ourself.
    //
    if( ArchData_bLinked() )
    {
        ArchData_vDelinkSelf();
    }
}

BOOL
TArchLV::TArchData::
bValid(
    VOID
    )
{
    return VALID_OBJ( _strArchitecture ) &&
           VALID_OBJ( _strVersion ) &&
           VALID_OBJ( _strInstalled );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\asyncdlg.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998
All rights reserved.

Module Name:

    asyncdlg.cxx

Abstract:

    Asynchronous Dialog.

Author:

    Steve Kiraly (SteveKi)  10-Feb-1997

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "asyncdlg.hxx"

/*++

Routine Name:

    TAsyncDlg

Routine Description:

    Asychronous dialog.  This is a dialog which starts a
    worker thread to do its work.  Note because a thread
    is started and this class is reference counted it must
    be instantiated from the heap.

Arguments:

    Nothing.

Return Value:

    Nothing.

--*/

TAsyncDlg::
TAsyncDlg(
    IN HWND             hwnd,
    IN TAsyncData      *pData,
    IN UINT             uResourceId
    ) : _pData( pData ),
        _hWnd( hwnd ),
        _uResourceId( uResourceId ),
        _bActive( FALSE )

{
    DBGMSG( DBG_TRACE, ( "TAsyncDlg::ctor.\n" ) );
}

TAsyncDlg::
~TAsyncDlg(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TAsyncDlg::dtor.\n" ) );
}

BOOL
TAsyncDlg::
bDoModal(
    VOID
    )
{
    //
    // Create a modal dialog.
    //
    return (BOOL)DialogBoxParam( ghInst,
                                 MAKEINTRESOURCE( _uResourceId ),
                                 _hWnd,
                                 MGenericDialog::SetupDlgProc,
                                 (LPARAM)this );

}

VOID
TAsyncDlg::
vSetTitle(
    IN LPCTSTR pszTitle
    )
{
    if( pszTitle && *pszTitle )
    {
        //
        // Update the dialog title.
        //
        TStatusB bStatus;
        bStatus DBGCHK = _strTitle.bUpdate( pszTitle );

        //
        // If the window is currently active then post
        // our special set title message.
        //
        if( _bActive )
        {
            PostMessage( _hDlg, WM_COMMAND, WM_APP, 0 );
        }
    }
}

BOOL
TAsyncDlg::
bIsActive(
    VOID
    ) const
{
    return _bActive;
}

BOOL
TAsyncDlg::
bHandle_InitDialog(
    VOID
    )
{
    BOOL bRetval = FALSE;

    //
    // Indicate the dialog is active.
    //
    _bActive = TRUE;

    //
    // Start the animation.
    //
    HWND hwndAni = GetDlgItem( _hDlg, IDD_STATUS );
    Animate_Open(hwndAni, MAKEINTRESOURCE( IDA_SEARCH ) );
    Animate_Play(hwndAni, 0, -1, -1);

    //
    // Set the window title.
    //
    SetWindowText( _hDlg, _strTitle );

    //
    //
    // Start the asynchronous thread.
    //
    bRetval = bStartAsyncThread();

    if( !bRetval )
    {
        vTerminate( IDCANCEL );
    }

    return bRetval;
}

BOOL
TAsyncDlg::
bHandle_Destroy(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TAsyncDlg::bHandle_Destroy.\n" ) );

    Animate_Stop( GetDlgItem( _hDlg, IDD_STATUS ) );

    _bActive = FALSE;

    return TRUE;
}

BOOL
TAsyncDlg::
bHandleMessage(
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    BOOL bStatus = TRUE;

    switch( uMsg )
    {
    case WM_INITDIALOG:
        bStatus = bHandle_InitDialog();
        break;

    case WM_COMMAND:
        bStatus = bHandle_Command( GET_WM_COMMAND_ID( wParam, lParam ), wParam, lParam );
        break;

    case WM_DESTROY:
        bStatus = bHandle_Destroy();
        break;

    default:
        bStatus = FALSE;
        break;
    }

    bStatus &= _pData->bHandleMessage( this, uMsg, wParam, lParam );

    return bStatus;
}

/*++

Routine Name:

    bHandle_Command

Routine Description:

    Handles WM_COMMAND messages from the dialog
    box procedure.

Arguments:

    uMsg    - Command message( control ID )
    wParam  - dialog procedure passed wParam
    lParam  - dialog procedure passed lParam

Return Value:

    TRUE message handled, otherwise false.

--*/
BOOL
TAsyncDlg::
bHandle_Command(
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    BOOL bStatus = TRUE;

    switch( uMsg )
    {
        case IDOK:
        case IDCANCEL:
            EndDialog( _hDlg, uMsg );
            break;

        case IDC_CANCEL:
            vTerminate( IDCANCEL );
            break;

        case WM_APP:
            SetWindowText( _hDlg, _strTitle );
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}

/*++

Routine Name:

    bRefZeroed

Routine Description:

    Called when the reference count drops to zero.

Arguments:

    Nothing.

Return Value:

    Nothing.

--*/
VOID
TAsyncDlg::
vRefZeroed(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TAsyncDlg::vRefZeroed.\n" ) );

    //
    // Since we are reference counting the printer data object
    // we know that it is safe to delete ourselves now.
    //
    delete this;
}


VOID
TAsyncDlg::
vTerminate(
    IN WPARAM wParam
    )
{
    PostMessage( _hDlg, WM_COMMAND, wParam, 0 );
}

BOOL
TAsyncDlg::
bStartAsyncThread(
    VOID
    )
{
    BOOL bStatus = FALSE;
    HANDLE hThread;
    DWORD dwIgnore;

    //
    // Ensure we bump the reference count.
    //
    vIncRef();

    //
    // Create a save printui thread.
    //
    hThread = TSafeThread::Create( NULL,
                                   0,
                                   reinterpret_cast<LPTHREAD_START_ROUTINE>( iProc ),
                                   this,
                                   0,
                                   &dwIgnore );
    //
    // Close the handle to the new thread if it was created.
    //
    if( hThread )
    {
        CloseHandle( hThread );
        bStatus = TRUE;
    }

    return bStatus;
}

INT
TAsyncDlg::
iProc(
    IN TAsyncDlg *pDlg
    )
{
    //
    // Execute the callback.
    //
    pDlg->_pData->bAsyncWork( pDlg );

    //
    // Terminate the async dialog.
    //
    pDlg->vTerminate( IDOK );

    //
    // Release our reference to the async dialog.
    //
    pDlg->cDecRef();

    return ERROR_SUCCESS;
}


/********************************************************************

    TAsynchronous data class.

********************************************************************/

TAsyncData::
TAsyncData(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TAsyncData::ctor.\n" ) );
}

TAsyncData::
~TAsyncData(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TAsyncData::dtor.\n" ) );
}

BOOL
TAsyncData::
bHandleMessage(
    IN TAsyncDlg    *pDlg,
    IN UINT         uMsg,
    IN WPARAM       wParam,
    IN LPARAM       lParam
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\addprn.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999
All rights reserved.

Module Name:

    addprn.cxx

Abstract:

    Add Printer Connection UI

Author:

    Steve Kiraly (SteveKi)  10-Feb-1997

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "asyncdlg.hxx"
#include "addprn.hxx"
#include "browse.hxx"

/*++

Name:

    PrintUIGetPrinterInformation

Routine Description:

    This function gets the information from a connected network printer,
    which includes: 

    1. The real printer name
    2. The printer comment
    3. The printer location
    4. The printer share name

Arguments:

    hPrinter            - Handle to a valid printer conenction
    pstrPrinterName     - Where to place the real printer name
    pstrComment         - Where to place the comment
    pstrLocation        - Where to place the location
    pstrShareName       - Where to place the share name

Return Value:

    TRUE the information is extracted. 
    FALSE if an error occurred.

--*/
BOOL
PrintUIGetPrinterInformation(
    IN HANDLE   hPrinter,
    IN TString *pstrPrinterName,
    IN TString *pstrComment,
    IN TString *pstrLocation,
    IN TString *pstrShareName
    )
{
    TStatusB bStatus;
    bStatus DBGNOCHK = FALSE;

    //
    // If the printer connection is ok
    // name string pointer.  
    //
    if( hPrinter )
    {
        PPRINTER_INFO_2 pInfo2  = NULL;
        DWORD           cbInfo2 = 0;

        //
        // Get the current printer info 2.
        //
        bStatus DBGCHK = VDataRefresh::bGetPrinter( hPrinter, 2, (PVOID*)&pInfo2, &cbInfo2 );

        if( bStatus )
        {
            if( pstrPrinterName )
                bStatus DBGCHK = pstrPrinterName->bUpdate( pInfo2->pPrinterName );

            if( pstrLocation )
                bStatus DBGCHK = pstrLocation->bUpdate( pInfo2->pLocation );

            if( pstrComment )
                bStatus DBGCHK = pstrComment->bUpdate( pInfo2->pComment );

            if( pstrShareName )
                bStatus DBGCHK = pstrShareName->bUpdate( pInfo2->pShareName );
        }

        //
        // Release the printer info 2 structure.
        //
        FreeMem( pInfo2 );
    }

    return bStatus;
}

/*++

Name:

    PrintUIAddPrinterConnectionUIEx

Routine Description:

    This function adds a printer connection on this machine
    to the specified printer.  This routine will return the real
    printer name if the connection is established.  Note a printer
    connection can be added using the share name, thus this routine
    will build the connection and then convert the share name to
    the real printer name.

Arguments:

    hWnd            - Parent window for any error UI.
    pszPrinter      - Printer name (e.g., "\\test\My HP LaserJet IIISi").
    pstrPrinterName - Where to place the real printer name
                      This is used when a user connects using a share name
                      but the caller needs the real printer name to set
                      the default printer.  This parameter can be NULL if the
                      real printer name is not needed.
    pstrComment     - Where to place the comment
    pstrLocation    - Where to place the location
    pstrShareName   - Where to place the share name

Return Value:

    TRUE the printer connection was added. FALSE if an error occurred.

--*/
BOOL
PrintUIAddPrinterConnectionUIEx(
    IN HWND     hwnd,
    IN LPCTSTR  pszPrinter,
    IN TString *pstrPrinterName,
    IN TString *pstrComment,
    IN TString *pstrLocation,
    IN TString *pstrShareName
    )
{
    DBGMSG( DBG_TRACE, ( "PrintUIAddPrinterConnectionUI\n" ) );
    DBGMSG( DBG_TRACE, ( "PrintUIAddPrinterConnectionUI pszPrinter " TSTR "\n", DBGSTR( pszPrinter ) ) );

    SPLASSERT( pszPrinter );

    BOOL bReturn    = FALSE;
    BOOL bDummy     = FALSE;
    HANDLE hPrinter = NULL;

    //
    // Currently just call the add printer connection UI
    //
    hPrinter = AddPrinterConnectionUI( hwnd, pszPrinter, &bDummy );

    //
    // If the connection was built and the called passed a valid printer
    // name string pointer.  If we cannot fetch the real printer name
    // we do not fail this call.
    //
    if( hPrinter )
    {
        //
        // Extract the printer information
        //
        PrintUIGetPrinterInformation( hPrinter, pstrPrinterName, pstrComment, pstrLocation, pstrShareName );

        //
        // Release the printer handle.
        //
        ClosePrinter( hPrinter );
        bReturn = TRUE;
    }

    return bReturn;
}


/*++

Name:

    PrintUIAddPrinterConnectionUI

Routine Description:

    This function adds a printer connection on this machine
    to the specified printer.  This function will bring up the
    up progress UI while the printer connection is being added.

Arguments:

    hWnd                - Parent window for progress UI.
    pszPrinter          - Printer name (e.g., "\\test\My HP LaserJet IIISi").
    bShowConnectionUI   - TRUE show connection UI, FALSE do not show connection UI.

Return Value:

    TRUE the printer connection was added. FALSE if progress UI was canceled or
    the printer connection could not be added.

Note:

    The last error is set on failure if the dialog was canceled.

--*/

BOOL
PrintUIAddPrinterConnectionUI(
    IN HWND    hwnd,
    IN LPCTSTR pszPrinter,
    IN BOOL    bShowConnectionUI
    )
{
    //
    // Assume failure.
    //
    BOOL bReturn = FALSE;

    //
    // Allocate the add printer connection data.
    //
    auto_ptr<TAddPrinterConnectionData> pInfo = new TAddPrinterConnectionData;

    //
    // If add printer connection data was returned.
    //
    if( pInfo.get() )
    {
        pInfo->_strPrinter.bUpdate( pszPrinter );
        pInfo->_bShowConnectionUI = bShowConnectionUI;

        //
        // Create the asynchrnous dialog.
        //
        TAsyncDlg *pDlg = new TAsyncDlg( hwnd, pInfo.get(), DLG_ASYNC );

        if( pDlg )
        {
            //
            // Aquire the refrence lock this will increment the refrence count
            // of the async dialog.  The refrence lock will then be decremented
            // when the reflock fall out of scope.
            //
            TRefLock<TAsyncDlg> pAsyncDlg( pDlg );

            //
            // Create the dialog title.
            //
            TString strTitle;
            TCHAR szText[kStrMax+kPrinterBufMax];
            UINT nSize = COUNTOF( szText );
            strTitle.bLoadString( ghInst, IDS_CONNECTING_TO_PRINTER );
            ConstructPrinterFriendlyName( pszPrinter, szText, &nSize );
            strTitle.bCat( szText );

            //
            // Set the dialog title.
            //
            pDlg->vSetTitle( strTitle );

            //
            // Display the dialog.
            //
            INT iRetval = pDlg->bDoModal();

            //
            // If the dialog exited normally,
            // The use did not cancel the dialog then set the return
            // value.
            //
            if( iRetval == IDOK )
            {
                bReturn = pInfo.get()->_ReturnValue;
            }

            //
            // If the user cancel the dialog set the last error.
            //
            if( iRetval == IDCANCEL )
            {
                SetLastError( ERROR_CANCELLED );
            }

            //
            // Release the pinfo stucture to the Asynchronous dialog class.
            //
            pInfo.release();

        }
    }
    return bReturn;
}


/*++

Name:

    PrintUIAddPrinterConnection

Routine Description:

    This routine is very similar to the AddPrinterConnection in the clien
    side of spooler, however if the users current domain is the same
    as the domain name in the printer name then the short printer name is
    used.  If this routine returns success then the printer new printer
    name is returned in pstrConnection.

Arguments:

    pszConnection - pointer to full printer connection name (UNC name)
    pstrConnection - optional pointer to string object where to return
                    the new printer name if it was shortened.

Return Value:

    TRUE success, FALSE error occurred.

--*/

BOOL
PrintUIAddPrinterConnection(
    IN LPCTSTR  pszConnection,
    IN TString  *pstrConnection OPTIONAL
    )
{
    SPLASSERT( pszConnection );

    TStatusB    bStatus;
    TString     strConnection;

    //
    // Do a quick check to see if the printer name has a minimal potential
    // of containing a domain name.
    //
    if( _tcschr( pszConnection, _T('.') ) )
    {
        TString strDomainName;

        //
        // Get the current users domain name, we do not fail if the domain
        // name cannot be fetched, just add the connection. Maybe we are not
        // logged on to a domain.
        //
        bStatus DBGCHK = GetDomainName( strDomainName );

        //
        // Convert the printer domain name to a short name.
        //
        bStatus DBGCHK = ConvertDomainNameToShortName( pszConnection, strDomainName, strConnection );

        //
        // Get a pointer to the printer name, the name may have been shortened.
        //
        if( bStatus )
        {
            pszConnection = strConnection;
        }
    }

    //
    // Display a debug message see what the printer name really is.
    //
    DBGMSG( DBG_TRACE, ("PrintUIAddPrinterConnection " TSTR "\n", pszConnection ) );

    //
    // Add the printer connection.
    //
    bStatus DBGCHK = AddPrinterConnection( const_cast<LPTSTR>( pszConnection ) );

    if( bStatus && pstrConnection )
    {
        //
        // Copy back the printer name if a string object pointer was provided.
        //
        bStatus DBGCHK = pstrConnection->bUpdate( pszConnection );

        //
        // We were unable to make a copy of the connection string,
        // remove the printer connection and fail the call.  This
        // should never happen.
        //
        SPLASSERT( bStatus );

        if( !bStatus )
        {
            (VOID)DeletePrinterConnection( const_cast<LPTSTR>( pszConnection ) );
        }
    }

    return bStatus;
}


/*++

Name:

    ConvertDomainNameToShortName

Routine Description:

    Give a fully qualified DNS printer name convert it to a short name
    if the domain part of the printer name is identical to the domain
    name of the user is currently logged on to.  Example:
    \\server1.dns.microsoft.com\test dns.microsoft.com resultant printer
    name \\server1\test.

Arguments:

    pszPrinter - pointer to fully qualified DNS printer name.
    pszDomain  - pointer to the users domain name.
    strShort   - refrence to string where to return the short printer name.

Return Value:

    TRUE short name returned, FALSE error occurred.

--*/

BOOL
ConvertDomainNameToShortName(
    IN      LPCTSTR pszPrinter,
    IN      LPCTSTR pszDomain,
    IN OUT  TString &strShort
    )
{
    SPLASSERT( pszPrinter );
    SPLASSERT( pszDomain );

    TStatusB bStatus;

    //
    // If a valid domain and unc printer name were provided then continue
    // checking for a domain name match.
    //
    bStatus DBGNOCHK = pszDomain && *pszDomain && pszPrinter && *(pszPrinter+0) == _T('\\') && *(pszPrinter+1) == _T('\\');

    if( bStatus )
    {
        //
        // Assume failure, until we actually build a short name.
        //
        bStatus DBGNOCHK = FALSE;

        //
        // Find the first '.' this will be the start of the domain name if
        // present.  The domain name is from the first . to the first \
        //
        LPTSTR pszShort = _tcschr( pszPrinter, _T('.') );

        if( pszShort )
        {
            //
            // Allocate a printer name buffer, I simplify the is case by just allocating
            // a buffer large enought for the printer name.  I know the name will potentialy
            // smaller, but it not worth figuring out how much smaller.
            //
            LPTSTR pszBuffer = (LPTSTR)AllocMem( (_tcslen( pszPrinter ) + 1) * sizeof(TCHAR) );

            if( pszBuffer )
            {
                LPTSTR p = pszShort+1;
                LPTSTR d = pszBuffer;

                //
                // Copy the domain name from the full printer name to the allocated buffer.
                //
                while( *p && *p != _T('\\') )
                {
                    *d++ = *p++;
                }

                //
                // Null terminate the destination buffere.
                //
                *d = 0;

                //
                // Check if the domain name in the printer name match the provided domain name.
                //
                if( !_tcsicmp( pszBuffer, pszDomain ) )
                {
                    //
                    // Build the short printer name less the domain name.
                    //
                    memmove( pszBuffer, pszPrinter, sizeof(TCHAR) * (size_t)(pszShort-pszPrinter) );
                    _tcscpy( pszBuffer+(pszShort-pszPrinter), p );

                    //
                    // Copy back the short printer name to the provided string object.
                    //
                    bStatus DBGCHK = strShort.bUpdate( pszBuffer );
                }

                //
                // Release the temp printer name buffer.
                //
                FreeMem( pszBuffer );
            }
        }
    }

    return bStatus;
}

/********************************************************************

    Add Printer Connection class

********************************************************************/

/*++

Name:

    TAddPrinterConnectionData

Routine Description:

    This function is the derived add printer connection data class
    constructure that is used to pass data to an asynchronous worker
    thread.  The worker thread is call after the progress UI is displayed.

Arguments:

    None

Return Value:

    Nothing.

--*/

TAddPrinterConnectionData::
TAddPrinterConnectionData(
    VOID
    ) : _bShowConnectionUI( TRUE )
{
    DBGMSG( DBG_TRACE, ( "TAddPrinterConnectionData::ctor\n" ) );
}

/*++

Name:

    ~TAddPrinterConnectionData

Routine Description:

    Destructor.

Arguments:

    None

Return Value:

    Nothing.

Note:

    The last error is not set on failure.

--*/

TAddPrinterConnectionData::
~TAddPrinterConnectionData(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TAddPrinterConnectionData::dtor\n" ) );
}

/*++

Name:

    bAsyncWork

Routine Description:

    This routine is the worker thread call back routine.  It is called after the
    progress UI has been started and is currently being displayed.  Because this
    function is a virtual within the TAsyncData class any specific data needed
    by this routine must be fully contained within the derived class.  This routine
    accepts on argument a pointer to the progress dialog pointer.  If needed this
    pointer should be used to stop the progress UI if any UI must be displayed.
    The hwnd of the progress UI should be used as the parent of any windows
    this routine may need to created.

Arguments:

    Pointer to TAsyncDlg class.

Return Value:

    TRUE function completed successfully, FALSE error occurred.

--*/

BOOL
TAddPrinterConnectionData::
bAsyncWork(
    IN TAsyncDlg *pDlg
    )
{
    //
    // Print some debugging information.
    //
    DBGMSG( DBG_TRACE, ( "pszPrinter " TSTR "\n", DBGSTR( (LPCTSTR)_strPrinter ) ) );

    //
    // Currently just call the add printer connection UI in winspool.drv
    //
    if( _bShowConnectionUI )
    {
        BOOL bDummy = FALSE;

        //
        // Call add printer connection UI, note the add printer connection UI sill
        // will display UI if an error occurred or if the driver was needed in the
        // masq printer case.
        //
        HANDLE  hHandle = AddPrinterConnectionUI( pDlg->_hDlg, _strPrinter, &bDummy );

        //
        // Handle is not needed, just release it if a valid handle was returned.
        //
        if( hHandle )
        {
            ClosePrinter( hHandle );
            _ReturnValue = TRUE;
        }
        else
        {
            _ReturnValue = FALSE;
        }
    }
    else
    {
        //
        // Add printer connection will just try and make an RPC connection to the printer
        // this call will not handle the masq printer case.
        //
        _ReturnValue = PrintUIAddPrinterConnection( _strPrinter, NULL );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\browse.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999
All rights reserved

Module Name:

    browse.cxx

Abstract:

    Handles the browse dialog for printer connections.

Author:

    Created by AndrewBe on 1 Dec 1992
    Steve Kiraly (SteveKi) 1 May 1998

Environment:

    User Mode Win32

Revision History:

    1 May 1998 moved from winspool.drv to printui.dll

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "result.hxx"
#include "asyncdlg.hxx"
#include "addprn.hxx"
#include "browse.hxx"
#include "persist.hxx"

#define SECURITY_WIN32
#include <wincred.h>
#include <wincrui.h>

//
// Global variables used only in this file.
//
static HDC     hdcBitmap               = NULL;
static HBITMAP hbmBitmap               = NULL;
static HBITMAP hbmDefault              = NULL;
static HANDLE  hRes                    = NULL;

static DWORD   SysColorHighlight       = 0;
static DWORD   SysColorWindow          = 0;

static INT     iBackground             = 0;
static INT     iBackgroundSel          = 0;
static INT     iButtonFace             = 0;
static INT     iButtonShadow           = 0;
static BOOL    ColorIndicesInitialised = FALSE;


/*++

ConnectTo objects

In the ConnectTo dialog, we initially call EnumPrinters with Flags == 0.
This returns an array of top-level objects represented by a PrinterInfo
structure, e.g:

    LanMan Windows NT

    Banyan

    etc...

We create a chain of ConnectTo objects, each of which points to a PrinterInfo
structure.  Initially, pSubObject is NULL.

The Flags field in the PrinterInfo structure indicates whether we can enumerate
on the object.  If so, this is indicated to the user through the display of
an appropriate icon in the list box.

If the  user clicks on such an enumerable object, we call
EnumPrinters( PRINTER_ENUM_NAME, pName, ... ), which returns a further buffer
of PrinterInfo structures.  These may represent servers on the network,
which may in turn be enumerated on to give the names of printers.

Each time an object is enumerated on, we create a new array of ConnectTo objects
which pSubObject points to:


                    pPrinterInfo[n]            pPrinterInfo[n+1]
                   +-----------------+        +-----------------+
                   | FLAG_ENUMERABLE |        | FLAG_ENUMERABLE |
                   | <description>   |        | <description>   |
                   | "LanMan NT"     |  ....  | "Banyan"        |
                   | "local network" |        | "other network" |
                   +-----------------+        +-----------------+
                           A                          A
                           |                          |
         +--------------+  |        +--------------+  |
         | pPrinterInfo |--+        | pPrinterInfo |--+
         +--------------+   .....   +--------------+
      +--| pSubObject   |           | (NULL)       |
      |  +--------------+           +--------------+
      |  | sizeof(Inf)*2|           | 0            |
      |  +--------------+           +--------------+
      |
      |  =======================================================================
      |
      |             pPrinterInfo[n+m]          pPrinterInfo[n+m+1]
      |            +-----------------+        +-----------------+
      |            | FLAG_ENUMERABLE |        | FLAG_ENUMERABLE |
      |            | "LanMan Server" |        | "LanMan Server" |
      |            | "Server A"      |  ....  | "Server B"      |
      |            | "daft comment"  |        | "other comment" |
      |            +-----------------+        +-----------------+
      |                    A                          A
      |                    |                          |
      |  +--------------+  |        +--------------+  |
      +->| pPrinterInfo |--+        | pPrinterInfo |--+
         +--------------+           +--------------+
      +--| pSubObject   |           | (NULL)       |
      |  +--------------+   .....   +--------------+
      |  | sizeof(Inf)*2|           | 0            |
      |  +--------------+           +--------------+
      |
      |  =======================================================================
      |
      |             pPrinterInfo[n+m+k]        pPrinterInfo[n+m+k+1]
      |            +-----------------+        +-----------------+
      |            | 0               |        | 0               |
      |            | "HP Laserjet"   |        | "Epson"         |
      |            | "Fave Printer"  |  ....  | "Epson Printer" |
      |            | "good quality"  |        | "Epson thingy"  |
      |            +-----------------+        +-----------------+
      |                    A                          A
      |                    |                          |
      |  +--------------+  |        +--------------+  |
      +->| pPrinterInfo |--+        | pPrinterInfo |--+
         +--------------+           +--------------+
         | (NULL)       |           | (NULL)       |
         +--------------+   .....   +--------------+
         | 0            |           | 0            |
         +--------------+           +--------------+


In the list box, the name of each object is displayed, with icon and indentation
to indicate enumerations possible.  The simple example above would look like this:

      +----------------------+-+
      | - LanMan NT          |A|
      |     * Fave Printer   + +
      |     * Epson Printer  | |
      | + Banyan             | |
      |                      | |
      |                      + +
      |                      |V|
      +----------------------+-+


--*/


/* ConnectToPrinterDlg
 *
 * Initializes bitmaps, fonts and cursors the first time it is invoked,
 * then calls the ConnectTo dialog.
 *
 * Parameters:
 *
 *     hwnd - Owner window handle
 *
 * Returns:
 *
 *     The handle of the printer connected to,
 *     NULL if no printer was selected or an error occurred.
 *
 * Author: andrewbe, August 1992
 */
HANDLE
WINAPI
ConnectToPrinterDlg(
    HWND    hwnd,
    DWORD   Flags
    )
{
    PBROWSE_DLG_DATA    pBrowseDlgData  = new BROWSE_DLG_DATA;
    HANDLE              hPrinter        = NULL;

    if( pBrowseDlgData )
    {
        pBrowseDlgData->vIncRef();

        if( pBrowseDlgData->bValid() )
        {
            pBrowseDlgData->hwndParent    = hwnd;
            pBrowseDlgData->Flags         = Flags;

            //
            // Make sure COM is initialized first.
            //
            COleComInitializer com;

            //
            // Show up the dialog box now.
            //
            INT_PTR iResult = DialogBoxParam( ghInst,
                                              MAKEINTRESOURCE(DLG_CONNECTTO),
                                              hwnd,
                                              (DLGPROC)ConnectToDlg,
                                              (LPARAM)pBrowseDlgData );
            if( iResult == IDOK )
            {
                hPrinter = pBrowseDlgData->hPrinter;
            }
        }

        pBrowseDlgData->cDecRef();
    }

    return hPrinter;
}

UINT CALLBACK PropSheetPageCallBack(
    IN      HWND hwnd,
    IN      UINT uMsg,
    IN      LPPROPSHEETPAGE ppsp
    )
/*++

Routine Description:

    This function gets called when the property sheet
    returned from ConnectToPrinterPropertyPage() gets
    created/released

Arguments:

    hwnd -  reserved; must be NULL
    uMsg -  PSPCB_CREATE  - when the page gets created
            (return TRUE to allow page creation)

            PSPCB_RELEASE - when the page is being destroyed
            (return value is ignored)
    ppsp -  Address of a PROPSHEETPAGE structure that defines
            the page being created or destroyed.

Return Value:

    Depends on the message - see above.

--*/
{
    UINT uReturn = TRUE;

    switch( uMsg )
    {
        case PSPCB_CREATE:
            {
                //
                // Just allow page creation. Do nothing
                // but return TRUE
                //
            }
            break;

        case PSPCB_RELEASE:
            {
                //
                // We must unhook the UI from the page here
                //
                PBROWSE_DLG_DATA pBrowseDlgData = reinterpret_cast<PBROWSE_DLG_DATA>( ppsp->lParam );
                pBrowseDlgData->cDecRef( );
            }
            break;

        default:
            {
                //
                // This message is not processed.
                //
                uReturn = FALSE;
            }
            break;
    }

    return uReturn;
}

/*
 *
 */
HRESULT
ConnectToPrinterPropertyPage(
    OUT     HPROPSHEETPAGE   *phPsp,
    OUT     UINT             *puPageID,
    IN      IPageSwitch      *pPageSwitchController
    )
/*++

Routine Description:

    Creates a property page, which is identical to the
    ConnectToPrinterDlg dialog box

Arguments:

    phpsp - Pointer to handle of property sheet page created
    ppageID - The resource identifier of the created page
    nNextPageID - Page ID to switch if next is pressed
    nPrevPageID - Page ID to switch if prev is pressed

Return Value:

    S_OK - if everything is fine
    E_FAIL (or other error code) if something goes wrong

--*/
{
    //
    // Assume success
    //
    HRESULT hResult = S_OK;

    //
    // Create the dialog data structure
    //
    PBROWSE_DLG_DATA pBrowseDlgData = NULL;
    pBrowseDlgData = new BROWSE_DLG_DATA;

    if( pBrowseDlgData )
    {
        pBrowseDlgData->bInPropertyPage = TRUE;
        pBrowseDlgData->pPageSwitchController = pPageSwitchController;

        pBrowseDlgData->vIncRef( );

        if( pBrowseDlgData->bValid() )
        {
            //
            // Create a property page and return a handle to it.
            //
            PROPSHEETPAGE psp   = {0};
            psp.dwSize          = sizeof( psp );
            psp.hInstance       = ghInst;
            psp.pfnDlgProc      = reinterpret_cast<DLGPROC>( ConnectToPropertyPage );
            psp.dwFlags         = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | PSP_USECALLBACK;
            psp.pfnCallback     = PropSheetPageCallBack;

            //
            // Set the title and subtitle.
            //
            TStatusB bStatus;
            TString strTitle;
            TString strSubTitle;
            bStatus DBGCHK = strTitle.bLoadString( ghInst, IDS_WIZ_BROWSE_TITLE );
            bStatus DBGCHK = strSubTitle.bLoadString( ghInst, IDS_WIZ_BROWSE_SUBTITLE );

            psp.pszHeaderTitle      = strTitle;
            psp.pszHeaderSubTitle   = strSubTitle;
            psp.pszTemplate         = MAKEINTRESOURCE( DLG_WIZ_BROWSE );
            psp.lParam              = reinterpret_cast<LPARAM>( pBrowseDlgData );

            //
            // Create the property page handle
            //
            *phPsp                  = CreatePropertySheetPage( &psp );

            if( NULL == *phPsp )
            {
                bStatus DBGCHK = FALSE;
                hResult = E_FAIL;
            }
            else
            {
                //
                // Everything looks fine - so return the page ID
                //
                *puPageID = DLG_WIZ_BROWSE;
            }
        }
        else
        {
            //
            // An error occured ...
            //
            hResult = E_FAIL;
        }
    }
    else
    {
        //
        // Memory allocation failure
        //
        hResult = E_OUTOFMEMORY;
    }

    //
    // Check if something failed to prevent
    // leaking the BROWSE_DLG_DATA structure
    //
    if( FAILED( hResult ) )
    {
        if( pBrowseDlgData )
        {
            pBrowseDlgData->cDecRef();
        }
    }

    return hResult;
}

/*
 *
 */
LRESULT
WINAPI
ConnectToPropertyPage(
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

    The window proc for the ConnectToPrinter property page.
    Just cracks the lParam to point to PBROWSE_DLG_DATA
    structure and pass the control to the ConnectTo proc.

Arguments:

    Standard window procedure parameters -
    see WindowProc for more details

Return Value:

--*/
{
    BOOL bProcessed = TRUE;

    //
    // Message processing switch
    //
    switch( uMsg )
    {
        case WM_INITDIALOG:
            {
                //
                // Crack the lParam parameter, so we could leverage
                // the original ConnectToDlg dialog proc for initialization
                //
                lParam = ( (LPPROPSHEETPAGE )lParam )->lParam;

                //
                // Impersonate message is not processed
                //
                bProcessed = FALSE;
            }
            break;

        case WM_DESTROY:
            {
                //
                // Just send a message to the background thread to terminate
                // and unhook from the data.
                //
                ConnectToDestroy( hWnd );
                SET_BROWSE_DLG_DATA( hWnd, static_cast<PBROWSE_DLG_DATA>(NULL) );
            }
            break;

        case WM_NOTIFY:
            {
                //
                // Assume we didn't process the message until
                // otherwise happened
                //
                bProcessed = FALSE;

                PBROWSE_DLG_DATA pBrowseDlgData = GET_BROWSE_DLG_DATA( hWnd );
                SPLASSERT( pBrowseDlgData );

                //
                // Check if we are in a property page
                //
                if( pBrowseDlgData->bInPropertyPage )
                {
                    LPNMHDR pnmh = (LPNMHDR)lParam;
                    switch( pnmh->code )
                    {
                        case PSN_WIZBACK:
                            {
                                bProcessed = PropertyPageWizardBack( hWnd );
                            }
                            break;

                        case PSN_WIZNEXT:
                            {
                                bProcessed = ConnectToOK( hWnd, TRUE );
                            }
                            break;

                        case PSN_QUERYCANCEL:
                            {
                                bProcessed = ConnectToCancel( hWnd );
                            }
                            break;
                    }
                }
            }
            break;

        default:
            {
                //
                // Pass the message for standard
                // processing to ConnectToDlg( ... )
                //
                bProcessed = FALSE;
            }
            break;
    }

    if( !bProcessed )
    {
        //
        // Transfer the control to the ConnectToDlg( ... ) proc
        //
        bProcessed = (BOOL)ConnectToDlg( hWnd, uMsg, wParam, lParam );
    }

    return bProcessed;
}

/*
 *
 */
BOOL
PropertyPageWizardBack( HWND hWnd )
/*++

Routine Description:

    This function moves the property sheet wizard
    by one page back

Arguments:

    hWnd - handle to the property page

Return Value:

    TRUE    - if the message is processed
    FALSE   - otherwise

--*/
{
    PBROWSE_DLG_DATA pBrowseDlgData = GET_BROWSE_DLG_DATA( hWnd );
    SPLASSERT( pBrowseDlgData );

    BOOL bProcessed = TRUE;

    //
    // Check if there is page switch controller provided
    //
    if( pBrowseDlgData->pPageSwitchController )
    {
        UINT uPrevPage;
        HRESULT hr = pBrowseDlgData->pPageSwitchController->GetPrevPageID( &uPrevPage );

        //
        // if S_OK == hr then just go to the provided
        // prev page (no problem)
        //
        if( S_OK == hr )
        {
            SetWindowLong( hWnd, DWLP_MSGRESULT, uPrevPage );
        }
        else
        {
            //
            // Don't switch the page - or per client request
            // or in case of an error
            //
            SetWindowLong( hWnd, DWLP_MSGRESULT, -1 );
        }
    }
    else
    {
        //
        // There is no page switch controller provided -
        // just go to the natural prev page ...
        //
        SetWindowLong( hWnd, DWLP_MSGRESULT, 0 );
    }

    return bProcessed;
}

/*
 *
 */
BOOL SetDevMode( HANDLE hPrinter )
{
    PPRINTER_INFO_2 pPrinter = NULL;
    DWORD           cbPrinter = 0;
    LONG            cbDevMode;
    PDEVMODE        pNewDevMode;
    BOOL            Success = FALSE;

    //
    // Gather the information.
    //
    if( VDataRefresh::bGetPrinter( hPrinter,
                                   2,
                                   (PVOID*)&pPrinter,
                                   &cbPrinter ) )
    {
        cbDevMode = DocumentProperties(NULL,
                                       hPrinter,
                                       pPrinter->pPrinterName,
                                       NULL,
                                       pPrinter->pDevMode,
                                       0);
        if (cbDevMode > 0)
        {
            if (pNewDevMode = (PDEVMODE)AllocSplMem(cbDevMode))
            {
                if (DocumentProperties(NULL,
                                       hPrinter,
                                       pPrinter->pPrinterName,
                                       pNewDevMode,
                                       pPrinter->pDevMode,
                                       DM_COPY) == IDOK)
                {
                    pPrinter->pDevMode = pNewDevMode;

                    if( SetPrinter( hPrinter, 2, (LPBYTE)pPrinter, 0 ) )
                        Success = TRUE;
                }

                FreeSplMem(pNewDevMode);
                pPrinter->pDevMode = NULL;
            }
        }

        FreeMem( pPrinter );
    }
    else
    {
        DBGMSG( DBG_WARN, ( "GetPrinter failed: Error %d\n", GetLastError( ) ) );
    }

    return Success;
}


/////////////////////////////////////////////////////////////////////////////
//
//  ConnectToDlg
//
//   This is the window procedure manages the ConnectTo dialog which allows
//   for the selection and creation of a new printer for use by the system.
//
// TO DO:
//      error checking for spooler api calls
//      IDOK - creating/saving new Printer settings
//      Limit text on editbox input fields ???
//      Implement
//          case IDD_AP_HELP
//
//
//
/////////////////////////////////////////////////////////////////////////////


LRESULT
WINAPI
ConnectToDlg(
   HWND   hWnd,
   UINT   usMsg,
   WPARAM wParam,
   LPARAM lParam
   )
{
    PBROWSE_DLG_DATA pBrowseDlgData = NULL;

    switch (usMsg)
    {
    case WM_INITDIALOG:
        return ConnectToInitDialog( hWnd, (PBROWSE_DLG_DATA)lParam );

    case WM_DRAWITEM:
        if( ConnectToDrawItem( hWnd, (LPDRAWITEMSTRUCT)lParam ) )
            return TRUE;
        break;

    case WM_CHARTOITEM:
        //
        // If the key entered is space, well will not do the search;
        // instead, we send a fake double click message to the list
        // box to expand/collaps the selected item.
        //
        if( LOWORD( wParam ) == VK_SPACE )
        {
            HWND hListbox = NULL;

            if( hListbox = GetDlgItem( hWnd, IDD_BROWSE_SELECT_LB ))
            {
                SendMessage( hWnd,
                             WM_COMMAND,
                             MAKEWPARAM(GetDlgCtrlID(hListbox), LBN_DBLCLK),
                             (LPARAM)hListbox );
            }
            return -1;
        }
        else
        {
            return ConnectToCharToItem( hWnd, LOWORD( wParam ) );
        }

    case WM_VKEYTOITEM:
        switch (LOWORD(wParam))
        {
        case VK_RETURN:
            ConnectToSelectLbDblClk( hWnd, (HWND)lParam );
            /* fall through ... */
        default:
            return -1;
        }

    case WM_DESTROY:
        ConnectToDestroy( hWnd );
        return 0;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDD_BROWSE_SELECT_LB:
            switch (HIWORD(wParam))
            {
            case LBN_SELCHANGE:
                ConnectToSelectLbSelChange( hWnd );
                break;

            case LBN_DBLCLK:
                ConnectToSelectLbDblClk( hWnd, (HWND)lParam );
                break;
            }
            break;

        case IDOK:
            return ConnectToOK( hWnd, FALSE );

        case IDCANCEL:
            return ConnectToCancel( hWnd );

        case IDD_BROWSE_DEFAULTEXPAND:
            {
                //
                // Imediately save the checkbox state in the registry
                //
                return SetRegShowLogonDomainFlag( (BOOL )SendDlgItemMessage(hWnd,IDD_BROWSE_DEFAULTEXPAND, BM_GETCHECK, 0, 0L) );
            }
        }
        break;

    case WM_MOUSEMOVE:
        ConnectToMouseMove( hWnd, (LONG)LOWORD( lParam ), (LONG)HIWORD( lParam ) );
        break;

    case WM_SETCURSOR:
        return ConnectToSetCursor( hWnd );

    case WM_ENUM_OBJECTS_COMPLETE:

        pBrowseDlgData = (PBROWSE_DLG_DATA)lParam;
        ConnectToEnumObjectsComplete( hWnd,
                                      (PCONNECTTO_OBJECT)pBrowseDlgData->wParam );
        break;

    case WM_GET_PRINTER_COMPLETE:

        pBrowseDlgData = (PBROWSE_DLG_DATA)lParam;
        ConnectToGetPrinterComplete( hWnd,
                                     (LPTSTR)pBrowseDlgData->wParam,
                                     (PPRINTER_INFO_2)pBrowseDlgData->lParam,
                                     NO_ERROR );

        break;


    case WM_GET_PRINTER_ERROR:

        pBrowseDlgData = (PBROWSE_DLG_DATA)lParam;
        ConnectToGetPrinterComplete( hWnd,
                                     (LPTSTR)pBrowseDlgData->wParam,
                                     NULL,
                                     (DWORD)pBrowseDlgData->lParam );

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        PrintUIHelp( usMsg, hWnd, wParam, lParam );
        break;
    }

    return FALSE;
}

/*
 *
 */
BOOL ConnectToInitDialog( HWND hWnd, PBROWSE_DLG_DATA pBrowseDlgData )
{
    //
    // Start the initial browse request.
    //
    DBGMSG( DBG_TRACE, ( "Sending initial browse request\n" ) );

    if( !pBrowseDlgData->bInitializeBrowseThread( hWnd ) )
    {
        iMessage( hWnd,
                  IDS_CONNECTTOPRINTER,
                  IDS_COULDNOTSTARTBROWSETHREAD,
                  MB_OK | MB_ICONSTOP,
                  kMsgNone,
                  NULL );

        if( pBrowseDlgData->bInPropertyPage )
        {
            PropSheet_PressButton( GetParent( hWnd ), PSBTN_CANCEL );
        }
        else
        {
            EndDialog( hWnd, IDCANCEL );
        }

        return FALSE;
    }

    //
    // Set up the initial UI.
    //
    SET_BROWSE_DLG_DATA( hWnd, pBrowseDlgData );

    SendDlgItemMessage(hWnd, IDD_BROWSE_PRINTER, EM_LIMITTEXT, kPrinterBufMax-1, 0L );

    if( pBrowseDlgData->Status & BROWSE_STATUS_INITIAL )
    {
        SETLISTCOUNT(hWnd, 1);
        DISABLE_LIST(hWnd);

        if( !pBrowseDlgData->bInPropertyPage )
        {
            //
            // When we are in a property page this checkbox
            // will not exist at all.
            //
            SendDlgItemMessage( hWnd, IDD_BROWSE_DEFAULTEXPAND, BM_SETCHECK, 1, 0L );
        }
    }

    /* Set focus initially to the Printer entry field;
     * when enumeration is complete (if we're enumerating)
     * we'll set it to the list:
     */
    SetFocus( GetDlgItem( hWnd, IDD_BROWSE_PRINTER ) );

    //
    // Enable autocomplete for the printer share/name edit box
    //
    ShellServices::InitPrintersAutoComplete(GetDlgItem(hWnd, IDD_BROWSE_PRINTER));

    return FALSE; /* FALSE == don't set default keyboard focus */
}


/*
 *
 */
BOOL ConnectToDrawItem( HWND hwnd, LPDRAWITEMSTRUCT pdis )
{
    PBROWSE_DLG_DATA  pBrowseDlgData;
    PCONNECTTO_OBJECT pConnectToData;
    PCONNECTTO_OBJECT pConnectToObject;
    TCHAR             Working[255];  /* String to display when we're expanding initially */
    DWORD             ObjectsFound = 0;
    DWORD             Depth = 0;
    RECT              LineRect;
    BOOL              Selected;
    int               xIcon;  // Coordinates of icon
    int               yIcon;  // in the resource bitmap

    if( !( pBrowseDlgData = GET_BROWSE_DLG_DATA(hwnd) ) )
        return FALSE;

    pConnectToData = GET_CONNECTTO_DATA(hwnd);

    if( !pConnectToData || ( pdis->itemID == (UINT)-1 ) )
        return FALSE;

    /* If this is the first item when we're expanding,
     * put "Working..." in the list box:
     */
    if( ( pBrowseDlgData->Status & BROWSE_STATUS_INITIAL ) && pdis->itemID == 0 )
    {
        LoadString( ghInst, IDS_WORKING, Working,
                    COUNTOF(Working));

        pdis->rcItem.left += 3;

        DrawLine( pdis->hDC, &pdis->rcItem, Working, FALSE );
        return TRUE;
    }

    LineRect = pdis->rcItem;

    Selected = ( pdis->itemState & ODS_SELECTED );

    pConnectToObject = GetConnectToObject( pConnectToData->pSubObject,
                                           pConnectToData->cSubObjects,
                                           pdis->itemID,
                                           NULL,
                                           &ObjectsFound,
                                           &Depth );

    if( pConnectToObject )
    {
        DWORD Flags;

        //
        // If the object is not a container and it is a provider do not
        // display this provider, because there is nothing underneath it
        // we should not show it.
        //
        if( pConnectToObject->pPrinterInfo->Flags & PRINTER_ENUM_HIDE )
        {
            return FALSE;
        }

        if (Selected) {
           SetBkColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHT) );
           SetTextColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT) );
        } else {
           SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW) );
           SetTextColor(pdis->hDC, GetSysColor(COLOR_WINDOWTEXT) );
        }

        /* Draw the indentation:
         */
        LineRect.right = ( LineRect.left + ( Depth * STATUS_BITMAP_SPACE / 4 ) );
        DrawLine( pdis->hDC, &LineRect, TEXT(""), Selected );

        LineRect.left = LineRect.right;


        /* We need to handle 8 different types of icon here:
         */
        Flags = pConnectToObject->pPrinterInfo->Flags;

        /* Find out the x-coordinate of the icon we need
         * to display in the listbox:
         */
        switch( Flags & PRINTER_ENUM_ICONMASK )
        {
        case PRINTER_ENUM_ICON1:
            xIcon = ( STATUS_BITMAP_WIDTH * 0 );
            break;

        case PRINTER_ENUM_ICON2:
            xIcon = ( STATUS_BITMAP_WIDTH * 1 );
            break;

        case PRINTER_ENUM_ICON3:
            xIcon = ( STATUS_BITMAP_WIDTH * 2 );
            break;

        case PRINTER_ENUM_ICON4:
            xIcon = ( STATUS_BITMAP_WIDTH * 3 );
            break;

        case PRINTER_ENUM_ICON5:
            xIcon = ( STATUS_BITMAP_WIDTH * 4 );
            break;

        case PRINTER_ENUM_ICON6:
            xIcon = ( STATUS_BITMAP_WIDTH * 5 );
            break;

        case PRINTER_ENUM_ICON7:
            xIcon = ( STATUS_BITMAP_WIDTH * 6 );
            break;

        case PRINTER_ENUM_ICON8:
        default:
            xIcon = ( STATUS_BITMAP_WIDTH * 7 );
            break;
        }


        /* If there are enumerated subobjects, pick the appropriate icon:
         */
        if( pConnectToObject->pSubObject )
            yIcon = BM_IND_CONNECTTO_DOMEXPAND;
        else
            yIcon = BM_IND_CONNECTTO_DOMPLUS;


        /* Ensure that the highlight will extend right across:
         */
        LineRect.right = pdis->rcItem.right;

        DisplayStatusIcon( pdis->hDC, &LineRect, xIcon, yIcon, Selected );


        if( pConnectToObject->pPrinterInfo->Flags & PRINTER_ENUM_CONTAINER )
        {
            /* Draw the description as is for containers:
             */
            DrawLine( pdis->hDC, &LineRect,
                      pConnectToObject->pPrinterInfo->pDescription,
                      Selected );
        }
        else
        {
            /* ... but insert tabs for the printers:
             */
            DrawLineWithTabs( pdis->hDC, &LineRect,
                              pConnectToObject->pPrinterInfo->pDescription,
                              Selected );
        }
    }

    if( Selected && ( pdis->itemState & ODS_FOCUS ) )
        DrawFocusRect( pdis->hDC, &pdis->rcItem );

    return TRUE;
}



/* Need to define LBS_WANTKEYBOARDINPUT for this to work
 *
 */
LONG ConnectToCharToItem( HWND hWnd, WORD Key )
{
    PBROWSE_DLG_DATA  pBrowseDlgData;
    PCONNECTTO_OBJECT pConnectToData;
    PCONNECTTO_OBJECT pConnectToObject;
    LONG_PTR           CurSel;
    LONG_PTR           i;
    LONG_PTR           ListCount;
    DWORD             ObjectsFound;
    DWORD             Depth;
    BOOL              Found = FALSE;
    TCHAR             Char[2];

    CurSel = SendDlgItemMessage(hWnd, IDD_BROWSE_SELECT_LB, LB_GETCURSEL, 0, 0L );

    if( !( pBrowseDlgData = GET_BROWSE_DLG_DATA(hWnd) ) )
        return FALSE;

    ENTER_CRITICAL( pBrowseDlgData );

    pConnectToData = GET_CONNECTTO_DATA(hWnd);

    if( pConnectToData )
    {
        /* Ensure character is upper case:
         */
        Char[0] = (TCHAR)Key;
        Char[1] = (TCHAR)0;
        CharUpper( Char );


        ListCount = SendDlgItemMessage( hWnd, IDD_BROWSE_SELECT_LB, LB_GETCOUNT, 0, 0 );

        i = ( CurSel + 1 );

        while( !Found && ( i < ListCount ) )
        {
            ObjectsFound = 0;
            Depth        = 0;

            pConnectToObject = GetConnectToObject( pConnectToData->pSubObject,
                                                   pConnectToData->cSubObjects,
                                                   (DWORD)i,
                                                   NULL,
                                                   &ObjectsFound,
                                                   &Depth );

            if( pConnectToObject
              &&( *pConnectToObject->pPrinterInfo->pDescription == *Char ) )
                Found = TRUE;
            else
                i++;
        }

        if( !Found )
            i = 0;

        while( !Found && ( i < CurSel ) )
        {
            ObjectsFound = 0;
            Depth        = 0;

            pConnectToObject = GetConnectToObject( pConnectToData->pSubObject,
                                                   pConnectToData->cSubObjects,
                                                   (DWORD)i,
                                                   NULL,
                                                   &ObjectsFound,
                                                   &Depth );

            if( pConnectToObject
              &&( *pConnectToObject->pPrinterInfo->pDescription == *Char ) )
                Found = TRUE;
            else
                i++;
        }
    }

    LEAVE_CRITICAL( pBrowseDlgData );

    if( Found )
        return (LONG)i;
    else
        return -1;
}

/*
 *
 */
VOID ConnectToMouseMove( HWND hWnd, LONG x, LONG y )
{
    PBROWSE_DLG_DATA  pBrowseDlgData;
    POINT             pt;

    if( !( pBrowseDlgData = GET_BROWSE_DLG_DATA(hWnd) ) )
        return;

    if( GetCursor() != pBrowseDlgData->hcursorArrow && GetCursor() != pBrowseDlgData->hcursorWait )
    {
        return;
    }

    if( pBrowseDlgData->Status & BROWSE_STATUS_EXPAND )
    {
        pt.x = x;
        pt.y = y;

        if( ChildWindowFromPoint( hWnd, pt ) == GetDlgItem( hWnd, IDD_BROWSE_SELECT_LB ) )
        {
            SetCursor( pBrowseDlgData->hcursorWait );
        }
        else
            SetCursor( pBrowseDlgData->hcursorArrow );
    }
    else
        SetCursor( pBrowseDlgData->hcursorArrow );
}


/* Return TRUE if we want control of the cursor.
 * This will be the case if we're over the browse list and
 * currently expanding the list.
 */
BOOL ConnectToSetCursor( HWND hWnd )
{
    PBROWSE_DLG_DATA  pBrowseDlgData;
    POINT             pt;
    BOOL              rc = FALSE;

    if( !( pBrowseDlgData = GET_BROWSE_DLG_DATA(hWnd) ) )
        return rc;

    if( pBrowseDlgData->Status & BROWSE_STATUS_EXPAND )
    {
        if( !GetCursorPos( &pt ) )
        {
            DBGMSG( DBG_WARN, ( "GetCursorPos failed in ConnectToSetCursor: Error %d\n", GetLastError( ) ) );
        }

        ScreenToClient( hWnd, &pt );
        if( ChildWindowFromPoint( hWnd, pt ) == GetDlgItem( hWnd, IDD_BROWSE_SELECT_LB ) )
            rc = TRUE;
    }

    return rc;
}


/*
 *
 */
VOID SetCursorShape( HWND hWnd )
{
    POINT CursorPos;

    if( !GetCursorPos( &CursorPos ) )
    {
        DBGMSG( DBG_WARN, ( "GetCursorPos failed in SetCursorShape: Error %d\n", GetLastError( ) ) );
    }

    ScreenToClient( hWnd, &CursorPos );
    ConnectToMouseMove( hWnd, CursorPos.x, CursorPos.y );
}


/*
 *
 */
VOID ConnectToEnumObjectsComplete(
    HWND              hWnd,
    PCONNECTTO_OBJECT pConnectToObject )
{
    PBROWSE_DLG_DATA  pBrowseDlgData;
    PCONNECTTO_OBJECT pDefaultExpand;
    DWORD             Index;
    TCHAR             PrinterName[10];
    DWORD             ObjectsAdded;

    DWORD             dwExtent;
    INT               iLevel;
    PCONNECTTO_OBJECT pConnectToData;
    DWORD             Depth = 0;
    DWORD             DepthExtent = 0;
    DWORD             ObjectsFound = 0;
    HDC               hDC;
    LPTSTR            pszLine;
    LPTSTR            pszPrevLine;
    SIZE              size;
    DWORD             dwCurExtent;
    PCONNECTTO_OBJECT pConnectToObjectChild;

    DBGMSG( DBG_TRACE, ( "EnumObjectsComplete\n" ) );

    if( !( pBrowseDlgData = GET_BROWSE_DLG_DATA(hWnd) ) )
        return;

    ObjectsAdded = pConnectToObject->cSubObjects;

    //
    // Before entering critical section, calculated extents
    //

    hDC = GetDC(NULL);

    if (hDC)
    {
        pConnectToData = GET_CONNECTTO_DATA(hWnd);

        if (pConnectToData)
        {

            dwExtent = pBrowseDlgData->dwExtent;

            GetConnectToObject(pConnectToData->pSubObject,
                               pConnectToData->cSubObjects,
                               0,
                               pConnectToObject,
                               &ObjectsFound,
                               &Depth);

            DepthExtent = (Depth + 2) * STATUS_BITMAP_SPACE / 4 +
                          STATUS_BITMAP_SPACE;

            for (Index = 0, pConnectToObjectChild = pConnectToObject->pSubObject;
                 Index < ObjectsAdded;
                 Index++, pConnectToObjectChild++)
            {
                pszLine = pConnectToObjectChild->pPrinterInfo->pDescription;

                for (iLevel = 0; pszLine;) {
                    pszPrevLine = pszLine;
                    pszLine = _tcschr(pszLine, TEXT(','));

                    if (pszLine) {
                        iLevel++;
                        pszLine++;
                    }
                }

                if (GetTextExtentPoint32(hDC,
                                         pszPrevLine,
                                         _tcslen(pszPrevLine),
                                         &size))
                {
                    dwCurExtent = size.cx +
                                  iLevel * (COLUMN_WIDTH + COLUMN_SEPARATOR_WIDTH) +
                                  DepthExtent;

                    dwExtent = dwExtent > dwCurExtent ? dwExtent : dwCurExtent;
                }
            }

            if (pBrowseDlgData->dwExtent != dwExtent)
            {
                SendDlgItemMessage(hWnd,
                                   IDD_BROWSE_SELECT_LB,
                                   LB_SETHORIZONTALEXTENT,
                                   dwExtent,
                                   0L);

                pBrowseDlgData->dwExtent = dwExtent;
            }
        }

        ReleaseDC(NULL, hDC);
    }


    ENTER_CRITICAL( pBrowseDlgData );

    if( pBrowseDlgData->Status & BROWSE_STATUS_INITIAL )
    {
        pBrowseDlgData->cExpandObjects += ObjectsAdded;

        pDefaultExpand = GetDefaultExpand( pConnectToObject->pSubObject,
                                           pConnectToObject->cSubObjects,
                                           &Index );

        if( pDefaultExpand )
        {
            DBGMSG( DBG_TRACE, ( "Expanding next level @08%x\n", pDefaultExpand ) );

            pBrowseDlgData->ExpandSelection += ( Index + 1 );

            SEND_BROWSE_THREAD_REQUEST( pBrowseDlgData,
                                        BROWSE_THREAD_ENUM_OBJECTS,
                                        pDefaultExpand->pPrinterInfo->pName,
                                        pDefaultExpand );
        }

        else
        {
            DBGMSG( DBG_TRACE, ( "No more levels to expand: Count = %d; Selection = %d\n",
                                 pBrowseDlgData->cExpandObjects,
                                 pBrowseDlgData->ExpandSelection ) );

            /* Put the selection on the name of the last enumerated node,
             * not the first printer under that node:
             */
            pBrowseDlgData->ExpandSelection--;

            SendDlgItemMessage( hWnd, IDD_BROWSE_SELECT_LB, WM_SETREDRAW, 0, 0L );
            SETLISTCOUNT( hWnd, pBrowseDlgData->cExpandObjects );
            SETLISTSEL( hWnd, pBrowseDlgData->ExpandSelection );
            SendDlgItemMessage( hWnd, IDD_BROWSE_SELECT_LB, LB_SETTOPINDEX,
                                pBrowseDlgData->ExpandSelection, 0 );
            SendDlgItemMessage( hWnd, IDD_BROWSE_SELECT_LB, WM_SETREDRAW, 1, 0L );

            ENABLE_LIST( hWnd );

            SetCursorShape( hWnd );

            /* If the user hasn't typed into the printer name field,
             * set the focus to the list:
             */
            if( !GetDlgItemText( hWnd, IDD_BROWSE_PRINTER,
                                 PrinterName, COUNTOF(PrinterName) ) )
            {
                //
                // Check if the window is visible or not.
                // This is a workaround for the case when we are in a property page
                // where the property page may not be visible at
                // this moment and we didn't want the current control
                // to lose the focus because the background thread has finished
                // its job.
                //
                if( IsWindowVisible(hWnd) )
                {
                    SetFocus( GetDlgItem( hWnd, IDD_BROWSE_SELECT_LB ) );
                }
            }

            pBrowseDlgData->Status &= ~BROWSE_STATUS_INITIAL;
            pBrowseDlgData->Status &= ~BROWSE_STATUS_EXPAND;
        }
    }

    else
    {
        UpdateList( hWnd, (INT)pConnectToObject->cSubObjects );

        if( GETLISTSEL( hWnd ) == LB_ERR )
            SETLISTSEL( hWnd, 0 );

        ENABLE_LIST( hWnd );
        pBrowseDlgData->Status &= ~BROWSE_STATUS_EXPAND;
        SetCursor( pBrowseDlgData->hcursorArrow );

        //
        // If no one has focus, set it to the list box.
        // (Common case: double click on machine, listbox
        // is disabled, updated, enabled)
        //
        if ( !GetFocus() )
            SetFocus( GetDlgItem( hWnd, IDD_BROWSE_SELECT_LB ) );
    }

    LEAVE_CRITICAL( pBrowseDlgData );
}



VOID ConnectToGetPrinterComplete(
    HWND            hWnd,
    LPTSTR          pPrinterName,
    PPRINTER_INFO_2 pPrinter,
    DWORD           Error )
{
    PBROWSE_DLG_DATA  pBrowseDlgData;
    PCONNECTTO_OBJECT pConnectToData;
    PCONNECTTO_OBJECT pConnectToObject;
    LONG_PTR           i;
    DWORD             ObjectsFound = 0;
    DWORD             Depth = 0;

    DBGMSG( DBG_TRACE, ( "GetPrinterComplete\n" ) );

    i = GETLISTSEL(hWnd);

    if( !( pBrowseDlgData = GET_BROWSE_DLG_DATA(hWnd) ) )
        return;

    pConnectToData = GET_CONNECTTO_DATA(hWnd);

    ENTER_CRITICAL( pBrowseDlgData );

    if( pConnectToData )
    {
        pConnectToObject = GetConnectToObject( pConnectToData->pSubObject,
                                               pConnectToData->cSubObjects,
                                               (DWORD)i,
                                               NULL,
                                               &ObjectsFound,
                                               &Depth );

        if( !pConnectToObject || !pPrinterName ||
            !pConnectToObject->pPrinterInfo->pName ||
            _tcscmp( pConnectToObject->pPrinterInfo->pName, pPrinterName ) ) {

              pPrinter = NULL;
        }
    }

    UpdateError( hWnd, Error );

    if( Error == NO_ERROR )
        SetInfoFields( hWnd, pPrinter );

    LEAVE_CRITICAL( pBrowseDlgData );
}


VOID ConnectToDestroy( HWND hWnd )
{
    PBROWSE_DLG_DATA  pBrowseDlgData;

    if( !( pBrowseDlgData = GET_BROWSE_DLG_DATA(hWnd) ) )
        return;

    DBGMSG( DBG_TRACE, ( "Terminating browse thread\n" ) );

    ENTER_CRITICAL( pBrowseDlgData );

    DBGMSG( DBG_TRACE, ( "Entered critical section\n" ) );

    SEND_BROWSE_THREAD_REQUEST( pBrowseDlgData,
                                BROWSE_THREAD_TERMINATE,
                                NULL, NULL );

    DBGMSG( DBG_TRACE, ( "Sent BROWSE_THREAD_TERMINATE\n" ) );

    LEAVE_CRITICAL( pBrowseDlgData );

    DBGMSG( DBG_TRACE, ( "Left critical section\n" ) );

    FreeBitmaps( );
}



/*
 *
 */
VOID ConnectToSelectLbSelChange( HWND hWnd )
{
    PBROWSE_DLG_DATA  pBrowseDlgData;
    PCONNECTTO_OBJECT pConnectToData;
    PCONNECTTO_OBJECT pConnectToObject;
    LONG_PTR           i;
    DWORD             ObjectsFound = 0;
    DWORD             Depth = 0;

    i = GETLISTSEL(hWnd);

    if( !( pBrowseDlgData = GET_BROWSE_DLG_DATA(hWnd) ) )
        return;

    pConnectToData = GET_CONNECTTO_DATA(hWnd);

    ENTER_CRITICAL( pBrowseDlgData );

    SetInfoFields( hWnd, NULL );

    if( pConnectToData )
    {
        pConnectToObject = GetConnectToObject( pConnectToData->pSubObject,
                                               pConnectToData->cSubObjects,
                                               (DWORD)i,
                                               NULL,
                                               &ObjectsFound,
                                               &Depth );

        if( pConnectToObject )
        {
            DBGMSG( DBG_TRACE, ( "Selection: " TSTR "\n", pConnectToObject->pPrinterInfo->pName ) );

            if( !( pConnectToObject->pPrinterInfo->Flags & PRINTER_ENUM_CONTAINER ) )
            {
                SetDlgItemText(hWnd, IDD_BROWSE_PRINTER,
                               pConnectToObject->pPrinterInfo->pName);

                SEND_BROWSE_THREAD_REQUEST( pBrowseDlgData,
                                            BROWSE_THREAD_GET_PRINTER,
                                            pConnectToObject->pPrinterInfo->pName,
                                            pConnectToObject );
            }
            else
            {
                SetDlgItemText(hWnd, IDD_BROWSE_PRINTER, TEXT(""));
            }
        }
    }

    LEAVE_CRITICAL( pBrowseDlgData );
}



/*
 *
 */
VOID ConnectToSelectLbDblClk( HWND hwnd, HWND hwndListbox )
{
    PBROWSE_DLG_DATA  pBrowseDlgData;
    PCONNECTTO_OBJECT pConnectToData;
    PCONNECTTO_OBJECT pConnectToObject;
    LONG_PTR           CurSel;
    DWORD             ObjectsFound = 0;
    DWORD             Depth = 0;

    CurSel = SendMessage(hwndListbox, LB_GETCURSEL, 0, 0L );

    if( !( pBrowseDlgData = GET_BROWSE_DLG_DATA( hwnd ) ) )
        return;

    ENTER_CRITICAL( pBrowseDlgData );

    pConnectToData = GET_CONNECTTO_DATA(hwnd);

    if( pConnectToData )
    {
        pConnectToObject = GetConnectToObject( pConnectToData->pSubObject,
                                               pConnectToData->cSubObjects,
                                               (DWORD)CurSel,
                                               NULL,
                                               &ObjectsFound,
                                               &Depth );

        if( pConnectToObject )
        {
            /* If this object is a container, and has not yet been enumerated,
             * call EnumPrinters on this node.  If the node has already been
             * expanded, close the subtree:
             */
            if( pConnectToObject->pPrinterInfo->Flags & PRINTER_ENUM_CONTAINER )
                ToggleExpandConnectToObject( hwnd, pConnectToObject );
            else
            {
                //
                // Check if we are in a property page force the
                // wizard to advance to the next page - not only
                // to create the printer connection
                //
                if( pBrowseDlgData->bInPropertyPage )
                {
                    PropSheet_PressButton( GetParent( hwnd ), PSBTN_NEXT );
                }
                else
                {
                    ConnectToOK( hwnd, TRUE );
                }
            }
        }
    }

    LEAVE_CRITICAL( pBrowseDlgData );
}


BOOL
ConnectToOK(
    HWND hWnd,
    BOOL ForceClose
    )
/*++

Routine Description:

    We have a remote printer name, try and form the connection.  We
    may need to create a local printer (the masq case) if the print
    providor doesn't support AddPrinterConnection.

Arguments:

Return Value:

--*/
{
    PBROWSE_DLG_DATA  pBrowseDlgData;
    TCHAR            szPrinter[kPrinterBufMax];
    LPPRINTER_INFO_1 pPrinter=NULL;
    LPTSTR           pListName=NULL;  // The name selected in the list
    LPTSTR           pConnectToName=NULL; // The name we try to connect to
    DWORD            ObjectsFound = 0;
    DWORD            Depth = 0;
    BOOL             bAdded;
    BOOL             bStatus = FALSE;

    if( !( pBrowseDlgData = GET_BROWSE_DLG_DATA(hWnd) ) )
        return FALSE;

    SetCursor( pBrowseDlgData->hcursorWait );

    //
    // Fake a double-click if the focus is on the list box:
    //
    if( !ForceClose &&
        ( GetFocus( ) == GetDlgItem( hWnd, IDD_BROWSE_SELECT_LB ) ) ) {

        SendMessage( hWnd, WM_COMMAND,
                     MAKEWPARAM( IDD_BROWSE_SELECT_LB, LBN_DBLCLK ),
                     (LPARAM)GetDlgItem( hWnd, IDD_BROWSE_SELECT_LB ) );
        return 0;
    }

    //
    // Get the name from the edit box:
    //
    if( !GetDlgItemText(hWnd, IDD_BROWSE_PRINTER, szPrinter, COUNTOF(szPrinter)) )
    {
        //
        // Check if we are in a property page -
        // to prevent closing
        //
        BOOL bResult = TRUE;
        if( pBrowseDlgData->bInPropertyPage )
        {
            //
            // Display a messge to the user and prevent
            // advancing to the next page
            //
            iMessage( hWnd,
                      IDS_ERR_ADD_PRINTER_TITLE,
                      IDS_ERR_MISSING_PRINTER_NAME,
                      MB_OK|MB_ICONHAND,
                      kMsgNone,
                      NULL );
            SetWindowLong( hWnd, DWLP_MSGRESULT, -1 );
        }
        else
        {
            //
            // This is the dialog case -
            // just close the dialog
            //
            bResult = ConnectToCancel( hWnd );
        }

        return bResult;
    }

    //
    // Printer names cannot have trailing white spaces.
    //
    vStripTrailWhiteSpace( szPrinter );

    //
    // Add the printer connection, also displaying progress UI.
    //
    pBrowseDlgData->hPrinter = AddPrinterConnectionUI( hWnd,
                                                       szPrinter,
                                                       &bAdded );

    //
    // Check if the printer connection has been sucessfully
    // created/added - this covers also the case if the printer
    // connection already exist (so we don't add new connection)
    //
    if( pBrowseDlgData->hPrinter )
        bStatus = HandleSuccessfulPrinterConnection( hWnd, pBrowseDlgData );

    return bStatus;
}


BOOL
HandleSuccessfulPrinterConnection(
    HWND hWnd,
    PBROWSE_DLG_DATA  pBrowseDlgData
    )
/*++

Routine Description:

    Handles the situation when successful printer
    connection has been established

Arguments:

    hWnd - Handle to the dialog/property page
    pBrowseDlgData - The already extracted dialog data

Return Value:

    TRUE  - the message is proccessed fine
    FALSE - an error occured

--*/
{
    SPLASSERT( pBrowseDlgData );

    //
    // Assume success
    //
    BOOL bStatus = TRUE;

    //
    // Check if we are in a property page ...
    //
    if( pBrowseDlgData->bInPropertyPage )
    {
        if( pBrowseDlgData->pPageSwitchController )
        {
            //
            // Extract the printer information
            //
            TString strPrinterName, strLocation, strComment, strShareName;
            bStatus = PrintUIGetPrinterInformation( pBrowseDlgData->hPrinter, &strPrinterName, &strLocation, &strComment, &strShareName );

            if( bStatus )
            {
                //
                // Notify the client for the extracted printer information
                //
                pBrowseDlgData->pPageSwitchController->SetPrinterInfo( strPrinterName, strLocation, strComment, strShareName );
            }
        }

        //
        // Prevent the user from leaking the printer handle
        // when going to the next page
        //
        ClosePrinter( pBrowseDlgData->hPrinter );
        pBrowseDlgData->hPrinter = NULL;
    }

    //
    // Perform the actual message processing here
    //
    if( bStatus )
    {
        //
        // Check if we are in a propery page
        //
        if( pBrowseDlgData->bInPropertyPage )
        {
            //
            // Is there a page switch controller provided
            //
            if( pBrowseDlgData->pPageSwitchController )
            {
                UINT uNextPage;
                HRESULT hr = pBrowseDlgData->pPageSwitchController->GetNextPageID( &uNextPage );

                //
                // if S_OK == hr then go to the next page provided
                //
                if( S_OK == hr )
                {
                    SetWindowLong( hWnd, DWLP_MSGRESULT, uNextPage );
                }
                else
                {
                    //
                    // Disable advancing to the next page here
                    // per client request (S_FALSE) or in case
                    // of an error
                    //
                    SetWindowLong( hWnd, DWLP_MSGRESULT, -1 );
                }
            }
            else
            {
                //
                // There is no page switch controller provided -
                // just go to the natural next page in the wizard
                //
                SetWindowLong( hWnd, DWLP_MSGRESULT, 0 );
            }
        }
        else
        {
            //
            // This is the dialog case ...
            // just close the dialog
            //
            EndDialog( hWnd, IDOK );
        }
    }

    return bStatus;
}

/////////////////////////////////////////////////////////
// CredUI prototypes

typedef
CREDUIAPI
DWORD
(WINAPI *PFN_CredUIPromptForCredentialsW)(
    PCREDUI_INFOW pUiInfo,
    PCWSTR pszTargetName,
    PCtxtHandle pContext,
    DWORD dwAuthError,
    PWSTR pszUserName,
    ULONG ulUserNameMaxChars,
    PWSTR pszPassword,
    ULONG ulPasswordMaxChars,
    BOOL *save,
    DWORD dwFlags
    );

typedef
CREDUIAPI
void
(WINAPI *PFN_CredUIConfirmCredentialsW)(
    PCWSTR pszTargetName,
    BOOL  bConfirm
    );

/////////////////////////////////////////////////////////
// CCredUILoader

class CCredUILoader: public CDllLoader
{
public:
    CCredUILoader():
        CDllLoader(TEXT("credui.dll")),
        m_pfnCredUIPromptForCredentials(NULL),
        m_pfnCredUIConfirmCredentials(NULL)
    {
        if (CDllLoader::operator BOOL())
        {
            // if the DLL is loaded then do GetProcAddress to the functions we care about
            m_pfnCredUIPromptForCredentials =
                (PFN_CredUIPromptForCredentialsW )GetProcAddress("CredUIPromptForCredentialsW");
            m_pfnCredUIConfirmCredentials =
                (PFN_CredUIConfirmCredentialsW)GetProcAddress("CredUIConfirmCredentialsW");
        }
    }

    operator BOOL () const
    {
        return
            ((CDllLoader::operator BOOL()) &&
            m_pfnCredUIPromptForCredentials &&
            m_pfnCredUIConfirmCredentials);
    }

    PFN_CredUIPromptForCredentialsW m_pfnCredUIPromptForCredentials;
    PFN_CredUIConfirmCredentialsW m_pfnCredUIConfirmCredentials;
};

/////////////////////////////////////////////////////////
// OpenPrinter_CredUI

inline static BOOL
IsRPC_SMB(LPTSTR pszPrinter)
{
    // should have 2 leading slashes
    return (
        lstrlen(pszPrinter) > 2 &&
        TEXT('\\') == pszPrinter[0] &&
        TEXT('\\') == pszPrinter[1]);
}

static BOOL
OpenPrinter_CredUI(HWND hwnd, LPTSTR pszPrinter, LPHANDLE phPrinter, LPPRINTER_DEFAULTS pDefault)
{
    ASSERT(phPrinter);
    BOOL bRet = FALSE;

    // open the printer to see if we have access to it.
    bRet = OpenPrinter(pszPrinter, phPrinter, pDefault);
    DWORD dwError = GetLastError();

    if (IsRPC_SMB(pszPrinter) && (!bRet && ERROR_ACCESS_DENIED == dwError))
    {
        // OpenPrinter failed because of insufficient permissions.
        // in this case we should call credui to obtain credentials.
        // then we should call WNetAddConnection2. WNetAddConnection2
        // can fail with ERROR_SESSION_CREDENTIAL_CONFLICT if there
        // is existing set of credentials which are in conflict with
        // ours in which case we should offer the user to overwrite
        // the credentials or it can fail with any aother error in the
        // case where pszPrinter is not a share name. in this case we
        // should try \\server\ipc$ to auth the RPC chanell over named
        // pipes and apply the same rules. if WNetAddConnection2 succeeds
        // we make another OpenPrinter attempt and if the credentials
        // are still not sufficient we inform the user and ask if he
        // wants to enter new credentials.

        TCHAR szBuffer[PRINTER_MAX_PATH];
        LPCTSTR pszServerName = NULL, pszPrinterName = NULL;

        // split the full qualified printer name into its components
        HRESULT hr = PrinterSplitFullName(pszPrinter, szBuffer, ARRAYSIZE(szBuffer),
            &pszServerName, &pszPrinterName);

        if (NULL == pszServerName || 0 == pszServerName[0])
        {
            // this is the case where the user passed a server name (like: '\\servername')
            // in this case PrinterSplitFullName succeeds and returns the server name in
            // pszPrinterName.
            pszServerName = pszPrinterName;
        }

        if (SUCCEEDED(hr))
        {
            // load credui.dll
            CCredUILoader credUI;

            if (credUI)
            {
                // in case we need to connect through \\server\ipc$
                BOOL bAskForCredentials = TRUE;
                BOOL bTriedDownlevel = FALSE;
                BOOL bSavePassword = TRUE;
                BOOL bMustConfirmCredentials = FALSE;

                TString strShareIPC;
                if (strShareIPC.bFormat(TEXT("%s\\ipc$"), pszServerName))
                {
                    // the server name without slashes
                    LPCTSTR pszServer = pszServerName + 2;

                    // credui
                    DWORD dwCreduiFlags = CREDUI_FLAGS_EXPECT_CONFIRMATION |
                                          CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX |
                                          CREDUI_FLAGS_SERVER_CREDENTIAL;
                    CREDUI_INFO credUIInfo = { sizeof(CREDUI_INFO), hwnd, NULL, NULL, NULL };

                    WCHAR szUserName[CREDUI_MAX_USERNAME_LENGTH + 1];
                    WCHAR szPassword[CREDUI_MAX_PASSWORD_LENGTH + 1];
                    szUserName[0] = 0;
                    szPassword[0] = 0;

                    // NETRESOURCE passed to WNetAddConnection2
                    NETRESOURCE nr;
                    ZeroMemory(&nr, sizeof(nr));

                    nr.dwScope = RESOURCE_GLOBALNET;
                    nr.dwType = RESOURCETYPE_ANY;
                    nr.lpRemoteName = const_cast<LPTSTR>(static_cast<LPCTSTR>(strShareIPC));

                    for (;;)
                    {
                        // try to obtain credentials from cred UI. since
                        // we pass in buffers for the username and password
                        // credui will *NOT* persist the credentials until
                        // we confirm they are fine by calling
                        // CredUIConfirmCredentials

                        if (bAskForCredentials)
                        {
                            if (bMustConfirmCredentials)
                            {
                                // if bMustConfirmCredentials is TRUE and we're here this
                                // means the credentials are fake and we need to call
                                // CredUIConfirmCredentials(FALSE) to prevent leaking memory.
                                credUI.m_pfnCredUIConfirmCredentials(pszServer, FALSE);
                                bMustConfirmCredentials = FALSE;
                            }

                            // ask the user for credentails....
                            dwError = credUI.m_pfnCredUIPromptForCredentials(
                                &credUIInfo,                // PCREDUI_INFOW pUiInfo,
                                pszServer,                  // PCWSTR pszTargetName,
                                NULL,                       // PCtxtHandle pContext,
                                dwError,                    // DWORD dwAuthError,
                                szUserName,                 // PWSTR pszUserName,
                                ARRAYSIZE(szUserName),      // ULONG ulUserNameMaxChars,
                                szPassword,                 // PWSTR pszPassword,
                                ARRAYSIZE(szPassword),      // ULONG ulPasswordMaxChars,
                                &bSavePassword,             // BOOL *save,
                                dwCreduiFlags               // DWORD dwFlags
                                );

                            // any further attemts should not ask for credentials unless
                            // we explicitly say so!
                            bMustConfirmCredentials = TRUE;
                            bAskForCredentials = FALSE;
                        }
                        else
                        {
                            // assume sucecss if we don't have to ask for credentials
                            dwError = ERROR_SUCCESS;
                        }

                        if (dwError == ERROR_SUCCESS)
                        {
                            // try the remote name directly assuming it is a printer share
                            dwError = WNetAddConnection2(&nr, szPassword, szUserName, 0);

                            // handle the possible cases:
                            //
                            // 1. ERROR_SUCCESS -- the success case. in this case we make another
                            //    OpenPrinter attempt and in the case the credentials are not yet
                            //    suffucient we should offer the user to enter new credentials.
                            //
                            // 2. ERROR_SESSION_CREDENTIAL_CONFLICT -- there is an existing
                            //    connection with different set of credentials. offer the user
                            //    to overwrite the credentials with the new ones.
                            //    this may break some running applications, which rely on the
                            //    existing connection but we'll leave that up to the user (to decide).
                            //
                            // 3. [any other error] -- nr.lpRemoteName is not a valid net resource.
                            //    try using the \\server\ipc$ if not tried already. if tried then
                            //    just fail silently and propagate the error

                            if (ERROR_SUCCESS == dwError)
                            {
                                // WNetAddConnection2 has succeeded -- let's make
                                // another OpenPrinter attempt
                                bRet = OpenPrinter(pszPrinter, phPrinter, pDefault);
                                dwError = GetLastError();

                                if (!bRet && ERROR_ACCESS_DENIED == dwError)
                                {
                                    // got access denied again -- inform the user
                                    // that the supplied credentials are not sufficient
                                    // and ask if he wants to try different credentials
                                    if (IDYES == iMessage(hwnd, IDS_CONNECTTOPRINTER,
                                            IDS_CREDUI_QUESTION_INSUFFICIENT_CREDENTIALS,
                                            MB_YESNO|MB_ICONEXCLAMATION, kMsgNone, NULL))
                                    {
                                        // delete the connection (force) and try again
                                        dwError = WNetCancelConnection2(nr.lpRemoteName,
                                            CONNECT_UPDATE_PROFILE, TRUE);

                                        if (ERROR_SUCCESS == dwError)
                                        {
                                            // the connection was deleted successfuly -- try again
                                            // asking the user for *new* credentials...
                                            bAskForCredentials = TRUE;
                                            continue;
                                        }
                                        else
                                        {
                                            // WNetCancelConnection2 failed -- this could be
                                            // because of lack of permissions or something else
                                            // show UI and cancel the whole operation...
                                            iMessage(hwnd, IDS_CONNECTTOPRINTER, IDS_CREDUI_CANNOT_DELETE_CREDENTIALS,
                                                MB_OK|MB_ICONSTOP, dwError, NULL);
                                        }
                                    }

                                    // if we are here cancel the whole operation
                                    dwError = ERROR_CANCELLED;
                                }

                                if (bRet && bMustConfirmCredentials)
                                {
                                    // we successfully opened the printer -- we need to
                                    // confirm the credentials, so they can be saved.
                                    credUI.m_pfnCredUIConfirmCredentials(pszServer, TRUE);
                                    bMustConfirmCredentials = FALSE;
                                }
                            }
                            else if (ERROR_SESSION_CREDENTIAL_CONFLICT == dwError)
                            {
                                // there is a credentials conflict -- ask the user
                                // if he wants to force and overwrite the existing
                                // credentials -- this may break some running
                                // applications but the message box will warn about that.

                                if (IDYES == iMessage(hwnd, IDS_CONNECTTOPRINTER,
                                        IDS_CREDUI_QUESTION_OWERWRITE_CREDENTIALS,
                                        MB_YESNO|MB_ICONEXCLAMATION, kMsgNone, NULL))
                                {
                                    // delete the connection (force) and try again
                                    dwError = WNetCancelConnection2(nr.lpRemoteName,
                                        CONNECT_UPDATE_PROFILE, TRUE);

                                    if (ERROR_SUCCESS == dwError)
                                    {
                                        // the previous connection was deleted successfuly --
                                        // try again now.
                                        continue;
                                    }
                                    else
                                    {
                                        // WNetCancelConnection2 failed -- this could be
                                        // because of lack of permissions or something else
                                        // show UI and cancel the whole operation...
                                        iMessage(hwnd, IDS_CONNECTTOPRINTER,
                                            IDS_CREDUI_CANNOT_DELETE_CREDENTIALS,
                                            MB_OK |MB_ICONSTOP, dwError, NULL);
                                    }
                                }

                                // if we are here cancel the whole operation
                                dwError = ERROR_CANCELLED;
                            }
                            else if (!bTriedDownlevel)
                            {
                                // something else failed. in this case we assume that
                                // teh remote machine is downlevel server (not NT) and
                                // the passed in name is a print share name

                                nr.dwType = RESOURCETYPE_PRINT;
                                nr.lpRemoteName = pszPrinter;
                                bTriedDownlevel = TRUE;

                                // let's try again now
                                continue;
                            }
                        }

                        if (bMustConfirmCredentials)
                        {
                            // if bMustConfirmCredentials is TRUE and we're here this
                            // means the credentials are fake and we need to call
                            // CredUIConfirmCredentials(FALSE) to prevent leaking memory.
                            credUI.m_pfnCredUIConfirmCredentials(pszServer, FALSE);
                            bMustConfirmCredentials = FALSE;
                        }

                        // exit the infinite loop here...
                        break;
                    }
                }
                else
                {
                    // the only possible reason bFormat can fail
                    dwError = ERROR_OUTOFMEMORY;
                }
            }
            else
            {
                // just preserve the last error
                dwError = GetLastError();
            }
        }
        else
        {
            // convert to Win32 error (if possible)
            dwError = SCODE_CODE(GetScode(hr));
        }
    }

    if (bRet)
    {
        // make sure the last error is correct
        dwError = ERROR_SUCCESS;
    }
    else
    {
        // just in case OpenPrinter has trashed
        // the handle (unlikely, but...)
        *phPrinter = NULL;
    }

    // make sure the last error is set!
    SetLastError(dwError);
    return bRet;
}

HANDLE
AddPrinterConnectionUI(
    HWND    hwnd,
    LPCTSTR pszPrinterIn,
    PBOOL   pbAdded
    )
/*++

Routine Description:

    Add a printer connection with UI. See AddPrinterConnectionUIQuery.

Arguments:

    hwd - Parent window.

    pszPrinter - Printer to add.

    pbAdded - Indicates whether pszPrinter was added.  FALSE = printer
        already existed in some form.

Return Value:

    HANDLE - hPrinter from pszPrinter.

--*/
{
    HANDLE hPrinter = NULL;
    HANDLE hServer;
    TString strPrinter;

    PRINTER_DEFAULTS PrinterDefaults = { NULL, NULL, SERVER_ACCESS_ADMINISTER };

    DWORD dwPrinterAttributes = 0;
    BOOL  bNetConnectionAdded = FALSE;
    BOOL  bUserDenied         = FALSE;
    BOOL  bMasq = FALSE;
    BOOL  bUnavailableDriver;
    DWORD dwError;

    LPWSTR pszArchLocal  = NULL;
    LPWSTR pszArchRemote = NULL;

    LPTSTR pszDriverNew = NULL;
    LPTSTR pszDriver = NULL;
    LPTSTR pszPrinter = (LPTSTR)pszPrinterIn;
    LPTSTR pszPrinterName = NULL;

    *pbAdded = FALSE;

    if( !OpenPrinter_CredUI(hwnd, pszPrinter, &hPrinter, NULL) ){

        DBGMSG( DBG_WARN, ( "OpenPrinter( "TSTR" ) failed: Error = %d\n", pszPrinter, GetLastError( ) ) );

        if (GetLastError() != ERROR_CANCELLED){

            ReportFailure( hwnd,
                           IDS_CONNECTTOPRINTER,
                           IDS_COULDNOTCONNECTTOPRINTER );
        }

        goto Fail;
    }

    if( !PrinterExists( hPrinter, &dwPrinterAttributes, &pszDriver, &pszPrinterName )){
        DBGMSG( DBG_WARN, ( "Attempt to connect to a non-existent printer.\n" ) );

        //
        // Check for an http*:// prefix.
        //
        if( GetLastError () == ERROR_ACCESS_DENIED &&
            (!_tcsnicmp( pszPrinterIn, gszHttpPrefix0, _tcslen(gszHttpPrefix0))  ||
             !_tcsnicmp( pszPrinterIn, gszHttpPrefix1, _tcslen(gszHttpPrefix1)))) {

            // This is an HTTP printer, we need to give user another chance to enter
            // a different username and password

            if (!ConfigurePort( NULL, hwnd, (LPTSTR) pszPrinterIn)) {

                ReportFailure( hwnd,
                               IDS_CONNECTTOPRINTER,
                               IDS_COULDNOTCONNECTTOPRINTER );
                goto Fail;

            } else {

                //
                // Retry GetPrinter
                //
                if( !PrinterExists( hPrinter, &dwPrinterAttributes, &pszDriver, &pszPrinterName )){
                    DBGMSG( DBG_WARN, ( "2nd Attempt to connect to a non-existent printer.\n" ) );
                    goto Fail;
                }
            }
        }
        else {

            ReportFailure( hwnd,
                           IDS_CONNECTTOPRINTER,
                           IDS_COULDNOTCONNECTTOPRINTER );
            goto Fail;
        }
    }

    if( dwPrinterAttributes & PRINTER_ATTRIBUTE_LOCAL ){
        //
        // This means the printer is a local pseudo-connection
        // probably created when the user tried to connect
        // on a previous occasion.
        //
        goto Done;
    }

    if (AddPrinterConnectionAndPrompt(hwnd, pszPrinter, &bUserDenied, &strPrinter)) {

        //
        // This could be refused by the user,
        //
        if (bUserDenied) {
            goto Fail;
        }
        else {
            goto Done;
        }
    }

    dwError = GetLastError();

    //
    // If this is a KM block issue, display the KM block message and
    // go to Fail
    //
    if( dwError == ERROR_KM_DRIVER_BLOCKED ||
        dwError == ERROR_PRINTER_DRIVER_BLOCKED )
    {
        ReportFailure( hwnd,
                       IDS_CONNECTTOPRINTER,
                       IDS_COULDNOTCONNECTTOPRINTER );

        goto Fail;
    }

    if (dwError == ERROR_ACCESS_DISABLED_BY_POLICY)
    {
        DisplayMessageFromOtherResourceDll(hwnd,
                                           IDS_CONNECTTOPRINTER,
                                           L"xpsp1res.dll",
                                           IDS_TEXT_POINTANDPRINT_POLICY_PRINTUI_DLL,
                                           MB_OK | MB_ICONERROR);

        goto Fail;
    }

    bUnavailableDriver = ( dwError == ERROR_UNKNOWN_PRINTER_DRIVER );

    //
    // We failed to add the printer connection.  This may occur if
    //
    // 1. This is a mini-print provider, or
    // 2. The driver is not installed on the client or server.
    //
    // In both cases, we need to install the driver locally, so check
    // if we have admin privleges.
    //
    // If the driver was already installed, then AddPrinterConnection
    // would have succeeded.  If it wasn't installed, then we need
    // admin privilege to install it, or create the local printer
    // in the masq case, so it's ok to check for admin access here.
    //
    if( !OpenPrinter( NULL, &hServer, &PrinterDefaults )){

        if( GetLastError() == ERROR_ACCESS_DENIED ){

            iMessage( hwnd,
                      IDS_CONNECTTOPRINTER,
                      IDS_INSUFFPRIV_CREATEPRINTER,
                      MB_OK | MB_ICONINFORMATION,
                      kMsgNone,
                      NULL );
        } else {

            iMessage( hwnd,
                      IDS_CONNECTTOPRINTER,
                      IDS_CANNOTOPENPRINTER,
                      MB_OK | MB_ICONSTOP,
                      kMsgNone,
                      NULL );
        }

        goto Fail;
    }
    else
    {
        pszArchLocal = GetArch(hServer);
    }

    ClosePrinter( hServer );

    {
        //
        // Create this special scope
        // for SplSetupData var
        //

        SPLSETUP_DATA SplSetupData;

        if( !SplSetupData.bValid )
        {
            DBGMSG( DBG_ERROR, ("AddPrinterConnectionUI: can't initialize SplSetupData -- error %d\n", GetLastError() ) );
            goto Fail;
        }

        //
        // If we have the driver name, we don't need to prompt for it.
        // We may still have true or false connections.
        //
        if( pszDriver && pszDriver[0] ){

            //
            // Check if the reason we failed is because the driver
            // isn't available on the client or server.
            //
            if( bUnavailableDriver ){

                BOOL             bSamePlatform = TRUE;
                DWORD            dwNeeded      = 0;
                LPPRINTER_INFO_2 pPrinterInfo2 = NULL;

                if( pszArchLocal )
                {
                    if( !GetPrinter( hPrinter, 2, NULL, 0, &dwNeeded )                        &&
                        GetLastError() == ERROR_INSUFFICIENT_BUFFER                           &&
                        NULL != ( pPrinterInfo2 = ( LPPRINTER_INFO_2 ) AllocMem( dwNeeded ) ) &&
                        GetPrinter( hPrinter, 2, ( LPBYTE ) pPrinterInfo2, dwNeeded, &dwNeeded ) )
                    {
                        PRINTER_DEFAULTS PrinterDef = { NULL, NULL, SERVER_READ };

                        if( OpenPrinter( pPrinterInfo2->pServerName, &hServer, &PrinterDef ) )
                        {
                            pszArchRemote = GetArch(hServer);

                            if( pszArchRemote )
                            {
                                bSamePlatform = ( lstrcmpi( pszArchRemote, pszArchLocal ) == 0 );
                            }
                        }

                        ClosePrinter( hServer );
                    }

                    if( pPrinterInfo2 )
                    {
                        FreeMem( pPrinterInfo2 );
                    }
                }

                //
                // Add the driver.
                //
                if( !AddKnownDriver( &SplSetupData, hwnd, pszDriver, bSamePlatform )){

                    //
                    // Handles Error UI.
                    //
                    SplSetupData.ReportErrorMessage( hwnd );
                    goto Fail;
                }

                //
                // The only problem was that the driver was not installed, then
                // install the driver and try the AddPrinterConnection again.
                //
                if( !PrintUIAddPrinterConnection( pszPrinter, &strPrinter )){

                    ReportFailure( hwnd,
                                   IDS_CONNECTTOPRINTER,
                                   IDS_COULDNOTCONNECTTOPRINTER );

                    goto Fail;
                }

            } else {

                //
                // We failed, but not becuase the driver is unavailable.
                // It's very likely we have a mini-provider, so
                // create the masq case: we have a local printer that
                // pretends it's network printer.  Of course, it's not
                // per-user anymore...
                //
                // Note that our driver may already be installed.
                //

                //
                // The current hPrinter is a handle to the remote printer.
                // We want a handle to the local masq printer instead.
                //
                ClosePrinter( hPrinter );

                bMasq = TRUE;

                hPrinter = CreateLocalPrinter( pszPrinterName,
                                               pszDriver,
                                               pszPrinter,
                                               bMasq,
                                               NULL );

                if( !hPrinter ){

                    //
                    // If we failed because we didn't have the driver,
                    // then let the user select it and we'll install again.
                    //
                    dwError = GetLastError();

                    if( dwError == ERROR_UNKNOWN_PRINTER_DRIVER ){

                        //
                        // Add the driver, but don't prompt user if the printer
                        // to add is an http printer - just install from local resources.
                        // Also, don't prompt the user if we were asked not not show UI
                        // in the first place (obviously).
                        //
                        BOOL bPromptUser = _tcsnicmp( pszPrinter, gszHttpPrefix0, _tcslen(gszHttpPrefix0) ) &&
                                           _tcsnicmp( pszPrinter, gszHttpPrefix1, _tcslen(gszHttpPrefix1) );

                        if( !AddDriver( &SplSetupData,
                                        hwnd,
                                        pszDriver,
                                        bPromptUser,
                                        &pszDriverNew ) ){

                            //
                            // Handles Error UI.
                            //
                            SplSetupData.ReportErrorMessage( hwnd );

                            goto Fail;
                        }

                        hPrinter = CreateLocalPrinter( pszPrinterName,
                                                       pszDriverNew,
                                                       pszPrinter,
                                                       bMasq,
                                                       NULL );
                    }

                    if( !hPrinter ){

                        ReportFailure( hwnd,
                                       IDS_CONNECTTOPRINTER,
                                       IDS_COULDNOTCONNECTTOPRINTER );

                        goto Fail;
                    }
                }
            }

        } else {

            //
            // The driver is not known; we need to prompt the user for it.
            //
            bMasq = TRUE;

            FreeSplStr( pszDriver );
            pszDriver = NULL;

            if( !AddDriver( &SplSetupData,
                            hwnd,
                            NULL,
                            TRUE,
                            &pszDriverNew )){
                //
                // Handles Error UI.
                //
                SplSetupData.ReportErrorMessage( hwnd );
                goto Fail;
            }

            //
            // Create the masq case: we have a local printer that
            // pretends it's network printer.  Of course, it's not
            // per-user anymore...
            //
            // Close the current handle since it refers to the remote printer,
            // and we want a handle to the local masq printer.
            //
            ClosePrinter( hPrinter );

            hPrinter = CreateLocalPrinter(pszPrinterName,
                                          pszDriverNew,
                                          pszPrinter,
                                          bMasq,
                                          NULL);

            if( !hPrinter ){

                ReportFailure( hwnd,
                               IDS_CONNECTTOPRINTER,
                               IDS_COULDNOTCONNECTTOPRINTER );
                goto Fail;
            }
        }

        if(hPrinter && SplSetupData.bDriverAdded){

            //
            // Let the class installer know we have just
            // added a local printer drivers.
            //
            SplSetupData.pfnProcessPrinterAdded(SplSetupData.hDevInfo,
                                                SplSetupData.pSetupLocalData,
                                                pszPrinter,
                                                hwnd);
        }
    }

Done:

    if( bMasq ){

        SetDevMode( hPrinter );
    }

    *pbAdded = TRUE;

    //
    // If the handle is valid and the connected printer name is not empty
    // and it is not equal to the original name then reopen the printer handle
    // using the actual printer name.  This is necessary for callers to have
    // a handle to the printer that was opened with the real printer name.
    //
    if( hPrinter && !strPrinter.bEmpty() && _tcsicmp( strPrinter, pszPrinter ) )
    {
        HANDLE hNewPrinter = NULL;

        if( OpenPrinter( const_cast<LPTSTR>( static_cast<LPCTSTR>( strPrinter ) ), &hNewPrinter, NULL ) )
        {
            ClosePrinter( hPrinter );
            hPrinter = hNewPrinter;
        }
    }

Fail:

    if( pszArchLocal )
    {
        FreeMem( pszArchLocal );
    }

    if( pszArchRemote )
    {
        FreeMem( pszArchRemote );
    }

    if( !*pbAdded ){

        if( hPrinter ){

            ClosePrinter( hPrinter );
            hPrinter = NULL;
        }
    }

    //
    // Free strings.
    //
    FreeSplStr(pszDriver);
    FreeSplStr(pszDriverNew);
    FreeSplStr(pszPrinterName);

    return hPrinter;
}

/*++

Routine Name:

    AddPrinterConnectionAndPrompt

Routine Description:

    This checks to see whether the provider supports opening just the server name
    (which implies that it is the win32spl provider),

Arguments:

    hWnd            -   The window handle
    pszPrinterName  -   The name of the printer to which we are adding the connection.
    pbUserDenied    -   If TRUE, the user decided not to connect to the given printer.
    pstrNewName     -   The new, possibly shortened, name of the printer.

Return Value:

    BOOL    - If TRUE, the connection was added or the user refused the connection.

--*/
BOOL
AddPrinterConnectionAndPrompt(
    IN      HWND                hWnd,
    IN      PCWSTR              pszPrinterName,
        OUT BOOL                *pbUserDenied,
        OUT TString             *pstrNewName
    )
{
    TStatusB    bRet;
    TString     strServerName;
    TString     strServerUNC;
    BOOL        bOnDomain = FALSE;
    HANDLE      hServer = NULL;

    if (!hWnd || !pszPrinterName || !pbUserDenied || !pstrNewName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);

        bRet DBGCHK = FALSE;
    }
    else
    {
        bRet DBGNOCHK = TRUE;
    }

    //
    // Are we on a Domain?
    //
    if (bRet)
    {
        bRet DBGCHK = AreWeOnADomain(&bOnDomain);
    }

    if (bRet && !bOnDomain)
    {
        //
        // Let's check if this is a remote NT server. For this we need the server
        // part of the queue name.
        //
        if (pszPrinterName[0] == L'\\' && pszPrinterName[1] == L'\\')
        {
            bRet DBGCHK = strServerName.bUpdate(&pszPrinterName[2]);
        }
        else
        {
            SetLastError(ERROR_INVALID_PRINTER_NAME);

            bRet DBGCHK = FALSE;
        }

        if (bRet)
        {
            PWSTR  pszSlash = const_cast<PWSTR>(wcschr(strServerName, L'\\'));

            if (pszSlash)
            {
                *pszSlash = L'\0';
            }
            else
            {
                SetLastError(ERROR_INVALID_PRINTER_NAME);

                bRet DBGCHK = FALSE;
            }
        }

        //
        // OK, we have the server name part, lets get a UNC name.
        //
        if (bRet)
        {
            bRet DBGCHK = strServerUNC.bFormat(L"\\\\%s", static_cast<PCWSTR>(strServerName));
        }

        //
        // Bit of a hack here, if we can open the server name, then this implies we
        // are talking to an NT Server.
        //
        if (bRet)
        {
            bRet DBGCHK = OpenPrinter(const_cast<PWSTR>(static_cast<PCWSTR>(strServerUNC)), &hServer, NULL);
        }

        if (bRet)
        {
            int Result = DisplayMessageFromOtherResourceDll(hWnd,
                                                            IDS_CONNECTTOPRINTER,
                                                            L"xpsp1res.dll",
                                                            IDS_TEXT_POINTANDPRINT_WARNING_PRINTUI_DLL,
                                                            MB_YESNO | MB_ICONWARNING,
                                                            static_cast<PCWSTR>(strServerName));

            bRet DBGNOCHK = Result == IDYES || Result == IDNO;

            *pbUserDenied = Result == IDNO;
        }
    }

    //
    // If we are on a domain, then the user did not deny us the connection (
    // although, we didn't ask).
    //
    if (bRet && bOnDomain)
    {
        *pbUserDenied = FALSE;
    }

    if (bRet && !*pbUserDenied)
    {
        bRet DBGCHK = PrintUIAddPrinterConnection(pszPrinterName, pstrNewName);
    }

    if (hServer)
    {
        ClosePrinter(hServer);
    }

    return bRet;
}


HANDLE
AddPrinterConnectionNoUI(
    LPCTSTR pszPrinterIn,
    PBOOL   pbAdded
    )
/*++

Routine Description:

    Add a printer connection silently, this routine will never show UI to the user.
    Since the installation doesn't show UI, we can't make a normal RPC printer
    connection to the remote side since this will refresh the printer driver from
    the remote server. So we create a local printer with a redirected port rather.

Arguments:

    pszPrinter - Printer to add.

    pbAdded - Indicates whether pszPrinter was added.

Return Value:

    HANDLE - hPrinter from pszPrinter.

--*/
{
    HANDLE              hPrinter    = NULL;
    BOOL                bAdded      = FALSE;
    HANDLE              hServer     = NULL;
    PORT_INFO_1         *pPorts     = NULL;
    PRINTER_DEFAULTS    Defaults    = { NULL, NULL, SERVER_ACCESS_ADMINISTER };
    DWORD               cbPorts     = 0;
    DWORD               cPorts      = 0;
    TStatusB            bContinue;

    if (!pszPrinterIn || !pbAdded)
    {
        SetLastError(ERROR_INVALID_PARAMETER);

        bContinue DBGCHK = FALSE;
    }

    //
    // First, does the user have local administrator rights on this machine?
    //
    if (bContinue)
    {
        bContinue DBGCHK = OpenPrinter(NULL, &hServer, &Defaults);
    }

    //
    // Get all the port names of the local machine. If this port already exists,
    // we just try and open the printer.
    //
    if (bContinue)
    {
        bContinue DBGCHK = VDataRefresh::bEnumPorts(NULL, 1, reinterpret_cast<VOID **>(&pPorts), &cbPorts, &cPorts);
    }

    //
    // Check to see if a port with the same name that we are already adding
    // exists.
    //
    for(UINT i = 0; bContinue && i < cPorts; i++)
    {
        //
        // The port names match.
        //
        if (!_tcsicmp(pPorts[i].pName, pszPrinterIn))
        {
            //
            // Open the printer and return this is the handle. If it can't
            // open, this is considered a failure, but we don't add the
            // printer.
            //
            (VOID)OpenPrinter(const_cast<PWSTR>(pszPrinterIn), &hPrinter, NULL);

            bContinue DBGNOCHK = FALSE;

            SetLastError(ERROR_ALREADY_EXISTS);
        }
    }

    //
    // The port name does not exist yet. Create the redirected or Masq printer.
    //
    if (bContinue)
    {
        hPrinter = CreateRedirectedPrinter(pszPrinterIn);

        bAdded = hPrinter != NULL;
    }

    //
    // Cleanup any resources used.
    //
    FreeMem(pPorts);

    if (hServer)
    {
        ClosePrinter(hServer);
    }

    if (pbAdded)
    {
        *pbAdded = bAdded;
    }

    return hPrinter;
}

/*++

Routine Name:

    CreateRedirectedPrinter

Routine Description:

    Create either a local printer with a redirected port to Windows NT or a
    masq printer to a 9x box.

Arguments:

    pszPrinter - Printer to add.

Return Value:

    HANDLE - hPrinter from pszPrinter.

--*/
HANDLE
CreateRedirectedPrinter(
    IN      PCWSTR      pszPrinterIn
    )
{
    HANDLE          hNewPrinter     =   NULL;
    HANDLE          hPrinter        =   NULL;
    PRINTER_INFO_2  *pPrinterInfo   =   NULL;
    DWORD           cbBuffer        =   0;
    BOOL            bWinNT          =   FALSE;
    PWSTR           pszPrinterName  =   NULL;
    PWSTR           pszMappedDriver =   NULL;
    BOOL            bDriverMapped   =   FALSE;
    BOOL            bPortAdded      =   FALSE;
    DWORD           dwLastError     =   ERROR_SUCCESS;
    TStatusB        bSucceeded;

    {
        SPLSETUP_DATA   SplSetupData;

        bSucceeded DBGCHK = SplSetupData.bValid;

        if (!bSucceeded)
        {
            DBGMSG(DBG_ERROR, ("CreateRedirectedPrinter: can't initialize SplSetupData -- error %d\n", GetLastError()));
        }

        if (bSucceeded)
        {
            bSucceeded DBGCHK = OpenPrinter(const_cast<PWSTR>(pszPrinterIn), &hPrinter, NULL);
        }

        //
        // Get the printer info for the remote printer. From this we can determine
        // the required driver and we can get the devmode for applying to the printer
        // later.
        //
        if (bSucceeded)
        {
            bSucceeded DBGCHK = VDataRefresh::bGetPrinter(hPrinter,
                                                          2,
                                                          reinterpret_cast<VOID **>(&pPrinterInfo),
                                                          &cbBuffer);
        }

        //
        // We need the driver name, or we can't add the local printer.
        //
        if (bSucceeded)
        {
            bSucceeded DBGNOCHK = pPrinterInfo->pDriverName && *pPrinterInfo->pDriverName;

            if (!bSucceeded)
            {
                SetLastError(ERROR_UNKNOWN_PRINTER_DRIVER);
            }
        }

        if (bSucceeded)
        {
            //
            // If we are being asked to make a connection to ourselves, the server
            // name we retrieve from the spooler will be NULL. Since unlike
            // AddPrinterConnection this will result in a printer in the desktop,
            // kill this attempt now.
            //
            if (pPrinterInfo->pServerName && *pPrinterInfo->pServerName)
            {
                //
                // Determine whether we are talking to a Win9X or an NT server.
                //
                if (bSucceeded)
                {
                    HRESULT hr = IsNTServer(pPrinterInfo->pServerName);

                    if (hr == S_OK)
                    {
                        bWinNT = TRUE;
                    }
                    else if (FAILED(hr))
                    {
                        SetLastError(HRESULT_CODE(hr));

                        bSucceeded DBGCHK = FALSE;
                    }
                }

                //
                // If we are talking to an NT server, then create a name rather like a
                // connection name for the printer and create a local port to represent
                // it.
                //
                if (bSucceeded)
                {
                    if (bWinNT)
                    {
                        bSucceeded DBGCHK = BuildNTPrinterName(pPrinterInfo, &pszPrinterName);
                    }
                    else
                    {
                        BuildMasqPrinterName(pPrinterInfo, &pszPrinterName);

                        bSucceeded DBGCHK = pszPrinterName != NULL;
                    }
                }

                //
                // Check to see whether we have a mapping for the printer driver.
                //
                if (bSucceeded)
                {
                    bSucceeded DBGCHK = SplSetupData.pfnFindMappedDriver(bWinNT,
                                                                         pPrinterInfo->pDriverName,
                                                                         &pszMappedDriver,
                                                                         &bDriverMapped);
                }

                //
                // If we are talking to an NT Server, create the local redirected port.
                //
                if (bSucceeded && bWinNT)
                {
                    bSucceeded DBGCHK = CreateLocalPort(pszPrinterIn);

                    bPortAdded = bSucceeded;
                }

                //
                // Try to Create the local printer.
                //
                if (bSucceeded)
                {
                    hNewPrinter = CreateLocalPrinter(pszPrinterName,
                                                     pszMappedDriver,
                                                     pszPrinterIn,
                                                     !bWinNT,
                                                     pPrinterInfo->pDevMode);

                    bSucceeded DBGCHK = hNewPrinter != NULL;

                    //
                    // We couldn't create the local printer because the driver wasn't there.
                    // Or, somehow a version 2 driver was put on the machine, and the
                    // corresponding V3 driver isn't there. In this case, try to add the
                    // driver ourselves.
                    //
                    if (!bSucceeded &&
                            (GetLastError() == ERROR_UNKNOWN_PRINTER_DRIVER ||
                             GetLastError() == ERROR_KM_DRIVER_BLOCKED))
                    {
                        //
                        // Add the in-box printer driver silently.
                        //
                        DWORD Status = SplSetupData.pfnInstallInboxDriverSilently(pszMappedDriver);

                        if (Status != ERROR_SUCCESS)
                        {
                            SetLastError(Status);

                            bSucceeded DBGCHK = FALSE;
                        }
                        else
                        {
                            bSucceeded DBGCHK = TRUE;
                        }

                        if (bSucceeded)
                        {
                            hNewPrinter = CreateLocalPrinter(pszPrinterName,
                                                             pszMappedDriver,
                                                             pszPrinterIn,
                                                             !bWinNT,
                                                             pPrinterInfo->pDevMode);

                            bSucceeded DBGCHK = hNewPrinter != NULL;
                        }
                    }
                }
            }
        }

        //
        // If we added the port, but failed to add the printer, delete the port.
        //
        if (!bSucceeded && bPortAdded)
        {
            DeletePort(NULL, NULL, const_cast<PWSTR>(pszPrinterIn));
        }

        //
        // The SplSetupData class overwrites the last error when it is
        // destructed. So, save the last error here,
        //
        dwLastError = GetLastError();

        //
        // Clean up all of our local resources.
        //
        if (hPrinter)
        {
            ClosePrinter(hPrinter);
        }

        FreeMem(pPrinterInfo);

        FreeSplStr(pszPrinterName);

        if (pszMappedDriver)
        {
            (VOID)SplSetupData.pfnFreeMem(pszMappedDriver);
        }
    }

    SetLastError(dwLastError);

    return hNewPrinter;
}

/*++

Routine Name:

    GetArch

Routine Description:

    Return the architecture of the given server.

Arguments:

    hServer -   The server whose architecture to retrieve,

Return Value:

    An allocated string with the architecture.

--*/
LPWSTR
GetArch(
    HANDLE hServer
    )
{
    LPWSTR pszRetArch      = NULL;
    WCHAR  szArch[kStrMax] = {0};
    DWORD  dwNeeded        = 0;

    if( ERROR_SUCCESS == GetPrinterData( hServer,
                                         SPLREG_ARCHITECTURE,
                                         NULL,
                                         (PBYTE)szArch,
                                         sizeof( szArch ),
                                         &dwNeeded ) )
    {
        if( NULL != ( pszRetArch = (LPWSTR)AllocMem(dwNeeded*sizeof(*szArch)) ) )
        {
            lstrcpyn( pszRetArch, szArch, dwNeeded );
        }
    }

    return pszRetArch;
}


/* BuildMasqPrinterName
 *
 * generates a proper printer name for masq printers
 */
VOID
BuildMasqPrinterName(
    IN      PPRINTER_INFO_2     pPrinter,
        OUT PWSTR               *ppszPrinterName
    )
{
    ASSERT(pPrinter);
    ASSERT(ppszPrinterName);

    // if this is an http printer, we need to take the server name (http://server) from pPrinter->pPortName
    // if this is downlevel printer then the pPrinter->pPortName is NULL
    TCHAR *p = NULL;
    if( pPrinter->pPortName )
    {
        // check if the server is http://server
        if( !p && !_tcsnicmp(pPrinter->pPortName, gszHttpPrefix0, _tcslen(gszHttpPrefix0)) )
        {
            p = pPrinter->pPortName + _tcslen(gszHttpPrefix0);
        }

        // check if the server is https://server
        if( !p && !_tcsnicmp(pPrinter->pPortName, gszHttpPrefix1, _tcslen(gszHttpPrefix1)) )
        {
            p = pPrinter->pPortName + _tcslen(gszHttpPrefix1);
        }
    }

    if( p )
    {
        // this is http printer, we need to build the name in the following format
        // \\http://server\printer
        LPCTSTR pszServer;
        LPCTSTR pszPrinter;
        TCHAR szScratch[kPrinterBufMax];

        // split the full printer name into its components.
        vPrinterSplitFullName(szScratch, pPrinter->pPrinterName, &pszServer, &pszPrinter);

        // go to the end of the server name & terminate p
        for( ; *p && *p != _T('/'); p++ ) { } *p = 0;

        // now pPrinter->pPortName now should be "http://server" or "https://server"
        pszServer = pPrinter->pPortName;

        if( pszServer && *pszServer )
        {
            // build the masq printer name here (i.e. "\\http://server\printer")
            TString strPrinterName;
            if( strPrinterName.bFormat(_T("\\\\%s\\%s"), pszServer, pszPrinter) )
            {
                *ppszPrinterName = AllocSplStr(strPrinterName);
            }
        }
    }
    else
    {
        // the friendly name is the same as pPrinter->pPrinterName
        *ppszPrinterName = AllocSplStr(pPrinter->pPrinterName);
    }
}

/* PrinterExists
 *
 * check if the printer exists & return some of its
 * attributes/data.
 */
BOOL
PrinterExists(
    HANDLE hPrinter,
    PDWORD pAttributes,
    LPTSTR *ppszDriver,
    LPTSTR *ppszPrinterName
    )
{
    BOOL bReturn = FALSE;
    DWORD cb = 0;
    CAutoPtrSpl<PRINTER_INFO_2> spPI2;

    ASSERT(ppszDriver);
    ASSERT(ppszPrinterName);
    *ppszDriver = NULL;
    *ppszPrinterName = NULL;

    bReturn = VDataRefresh::bGetPrinter(hPrinter, 2, spPI2.GetPPV(), &cb);
    if( bReturn )
    {
        // return the driver & attributes
        *pAttributes = spPI2->Attributes;
        *ppszDriver = AllocSplStr(spPI2->pDriverName);

        // generate a friendly name - i.e.
        // "printer or server" or "printer on http://server"
        BuildMasqPrinterName(spPI2, ppszPrinterName);
    }
    else
    {
        // this is a bit of a hack:
        //
        // OpenPrinter returns a valid handle if the name of a server is passed in.
        // we need to call GetPrinter with that handle to check that it's a printer.
        // if this call fails, the error will have been set to ERROR_INVALID_HANDLE,
        // whereas it really should be ERROR_INVALID_PRINTER_NAME.
        if( ERROR_INVALID_HANDLE == GetLastError() )
        {
            SetLastError( ERROR_INVALID_PRINTER_NAME );
        }
    }

    return bReturn;
}

/*++

Routine Name:

    BuildNTPrinterName

Routine Description:

    This builds the name of the NT printer, if the name is \\Foo\Bar, we will
    call it Auto Foo on Bar. This will be the real printer name to ensure that the
    UI does not confuse it with a printer connection which causes problems in
    the shell folder.

Arguments:

    pPrinter        -   The printer info for the printer
    ppszPrinterName -   The returned

Return Value:

    An allocated string with the architecture.

--*/
BOOL
BuildNTPrinterName(
    IN      PRINTER_INFO_2      *pPrinter,
        OUT PWSTR               *ppszPrinterName
    )
{
    PCWSTR  pszPrinterName = NULL;
    PCWSTR  pszServerName  = NULL;
    WCHAR   szScratch[kPrinterBufMax];
    TString strNtConnectName;
    TStatusB bRet;

    if (!pPrinter || !pPrinter->pPrinterName || !ppszPrinterName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet DBGCHK = FALSE;
    }
    else
    {
        bRet DBGCHK = TRUE;
    }

    //
    // Split the printer name into a server name and printer name. Then we will
    // load the resource and format the message string.
    //
    if (bRet)
    {
        vPrinterSplitFullName(szScratch, pPrinter->pPrinterName, &pszServerName, &pszPrinterName);

        //
        // Strip the leading \\ from the server name.
        //
        if(pszServerName[0] == L'\\' && pszServerName[1] == L'\\')
        {
            pszServerName = pszServerName + 2;
        }

        bRet DBGCHK = bConstructMessageString(ghInst, strNtConnectName, IDS_DSPTEMPLATE_NETCRAWLER, pszPrinterName, pszServerName);
    }

    //
    // If this succeeds, allocate a copy a string back. We do this so the caller
    // can free the string just as it does with BuildMasqPrinterName.
    //
    if (bRet)
    {
        *ppszPrinterName = AllocSplStr(strNtConnectName);

        bRet DBGCHK = *ppszPrinterName != NULL;
    }

    return bRet;
}

/* CreateLocalPrinter
 *
 * creates a local masq printer with the specified
 * name, driver & port.
 */
HANDLE
CreateLocalPrinter(
    IN      LPCTSTR     pPrinterName,
    IN      LPCTSTR     pDriverName,
    IN      LPCTSTR     pPortName,
    IN      BOOL        bMasqPrinter,
    IN      DEVMODE     *pDevMode           OPTIONAL
    )
{
    // make sure the name is unique
    TCHAR szPrinterName[kPrinterBufMax];

    if( NewFriendlyName(NULL, pPrinterName, szPrinterName) )
    {
        pPrinterName = szPrinterName;
    }

    // set the printer info fields to actually create the masq printer.
    PRINTER_INFO_2 pi2 = {0};
    pi2.pPrinterName    = const_cast<PTSTR>(pPrinterName);
    pi2.pDriverName     = const_cast<PTSTR>(pDriverName);
    pi2.pPortName       = const_cast<PTSTR>(pPortName);
    pi2.pPrintProcessor = (LPTSTR)gszDefaultPrintProcessor;
    pi2.pDevMode        = pDevMode;
    pi2.Attributes = PRINTER_ATTRIBUTE_LOCAL;

    if (bMasqPrinter)
    {
        pi2.Attributes |= PRINTER_ATTRIBUTE_NETWORK;
    }

    // ask the spooler to create a masq printer for us
    // (i.e. attributes should be local + network).
    return AddPrinter(NULL, 2, (LPBYTE)&pi2 );
}

/*
 *
 */
BOOL ConnectToCancel( HWND hWnd )
{
    PBROWSE_DLG_DATA pBrowseDlgData = GET_BROWSE_DLG_DATA( hWnd );
    SPLASSERT( pBrowseDlgData );

    //
    // Check if we are in property page
    //
    if( pBrowseDlgData->bInPropertyPage )
    {
        BOOL bEnableClose = TRUE;
        //
        // Check if there is page switch controller provided
        //
        if( pBrowseDlgData->pPageSwitchController )
        {
            if( S_OK == pBrowseDlgData->pPageSwitchController->QueryCancel( ) )
            {
                //
                // We must prevent closing in this case
                //
                bEnableClose = FALSE;
            }
        }

        if( bEnableClose )
        {
            //
            // Allow closing operation
            //
            SetWindowLong( hWnd, DWLP_MSGRESULT, FALSE );
        }
        else
        {
            //
            // Prevent closing operation
            //
            SetWindowLong( hWnd, DWLP_MSGRESULT, TRUE );
        }
    }
    else
    {
        //
        // We are in dialog box -
        // Just close dialog with IDCANCEL
        //
        EndDialog( hWnd, IDCANCEL );
    }

    //
    // Always processing this message
    //
    return TRUE;
}


/* GetConnectToObject
 *
 * Does a recursive search down the ConnectTo object tree to find the Nth
 * object, where Index == N.
 * On the top-level call, *pObjectsFound must be initialised to zero,
 * and this value is incremented each time an object in the tree is encountered.
 * On any given level, if *pObjectsFound equals the index being sought,
 * then a pointer to the corresponding ConnectTo object is returned.
 * If the index hasn't yet been reached, the function is called recursively
 * on any subobjects.
 *
 * Arguments:
 *
 *     pFirstConnectToObject - Pointer to the first ConnectTo object
 *         in the array of objects at a given level.
 *
 *     cThisLevelObjects - The number of objects in the array at this level.
 *
 *     Index - Which object is requested.  E.g. if the top item in the printers
 *         list box is being drawn, this will be 0.
 *
 *     pObjectsFound - A pointer to the number of objects encountered so far in
 *         the search.  This must be initialised to zero by the top-level caller.
 *
 *     pDepth - A pointer to the depth of the object found in the search.
 *         This value is zero-based and must be initialised to zero
 *         by the top-level caller.
 *
 * Return:
 *
 *     A pointer to the CONNECTTO_OBJECT if found, otherwise NULL.
 *
 *
 * Author: andrewbe July 1992
 *
 *
 */
PCONNECTTO_OBJECT GetConnectToObject(
    IN  PCONNECTTO_OBJECT pFirstConnectToObject,
    IN  DWORD             cThisLevelObjects,
    IN  DWORD             Index,
    IN  PCONNECTTO_OBJECT pFindObject,
    OUT PDWORD            pObjectsFound,
    OUT PDWORD            pDepth )
{
    PCONNECTTO_OBJECT pConnectToObject = NULL;
    DWORD             i = 0;

    while( !pConnectToObject && ( i < cThisLevelObjects ) )
    {
        if (&pFirstConnectToObject[i] == pFindObject ||
            (!pFindObject && *pObjectsFound == Index))
        {
            pConnectToObject = &pFirstConnectToObject[i];
        }

        /* Make a recursive call on any objects which have subobjects:
         */
        else if( pFirstConnectToObject[i].pSubObject )
        {
            (*pObjectsFound)++; // Add the current object to the total count

            pConnectToObject = GetConnectToObject(
                                   pFirstConnectToObject[i].pSubObject,
                                   pFirstConnectToObject[i].cSubObjects,
                                   Index,
                                   pFindObject,
                                   pObjectsFound,
                                   pDepth );

            if( pConnectToObject )
                (*pDepth)++;
        }
        else
            (*pObjectsFound)++; // Add the current object to the total count

        i++; // Increment to the next object at this level
    }

    return pConnectToObject;
}


/* GetDefaultExpand
 *
 * Searches one level of enumerated objects to find the first one with the
 * PRINTER_ENUM_EXPAND flag set.
 * This flag should have been set by the spooler to guide us to the user's
 * logon domain, so we can show the printers in that domain straight away.
 * The user can disable this behaviour by unchecking the box in the ConnectTo
 * dialog.  If this has been done, this function will return NULL immediately.
 *
 * Arguments:
 *
 *     pFirstConnectToObject - Pointer to the first ConnectTo object
 *         in the array of objects at a given level.
 *
 *     cThisLevelObjects - The number of objects in the array at this level.
 *
 *     pIndex - A pointer to a DWORD which will receive the index of the
 *         object found in the array.
 *
 * Return:
 *
 *     A pointer to the CONNECTTO_OBJECT if found, otherwise NULL.
 *
 *
 * Author: andrewbe December 1992 (based on GetConnectToObject)
 *
 *
 */
PCONNECTTO_OBJECT GetDefaultExpand(
    IN  PCONNECTTO_OBJECT pFirstConnectToObject,
    IN  DWORD             cThisLevelObjects,
    OUT PDWORD            pIndex )
{
    PCONNECTTO_OBJECT pDefaultExpand = NULL;
    DWORD             i = 0;

    while( !pDefaultExpand && ( i < cThisLevelObjects ) )
    {
        if( pFirstConnectToObject[i].pPrinterInfo->Flags & PRINTER_ENUM_EXPAND )
            pDefaultExpand = &pFirstConnectToObject[i];
        else
            i++; // Increment to the next object at this level
    }

    *pIndex = i;

    return pDefaultExpand;
}


/* FreeConnectToObjects
 *
 * Frees the array of objects on the current level, after making a recursive
 * call on any subobjects of members of the array.
 *
 * Arguments:
 *
 *     pFirstConnectToObject - Pointer to the first ConnectTo object in the array
 *              of objects at a given level.
 *
 *     cThisLevelObjects - The number of objects in the array at this level.
 *
 *     cbThisLevelObjects - The size of the the array at this level.
 *
 * Return:
 *
 *     The number of objects actually removed, regardless of errors.
 *
 *
 * Author: andrewbe July 1992
 */
DWORD FreeConnectToObjects(
    IN PCONNECTTO_OBJECT pFirstConnectToObject,
    IN DWORD             cThisLevelObjects,
    IN DWORD             cbPrinterInfo )
{
    DWORD i;
    DWORD SubObjectsFreed = 0;

    if( ( cThisLevelObjects > 0 ) && pFirstConnectToObject->pPrinterInfo )
        FreeSplMem( pFirstConnectToObject->pPrinterInfo );

    for( i = 0; i < cThisLevelObjects; i++ )
    {
        /* Make a recursive call on any objects which have subobjects:
         */
        if( pFirstConnectToObject[i].pSubObject )
        {
            SubObjectsFreed = FreeConnectToObjects(
                               pFirstConnectToObject[i].pSubObject,
                               pFirstConnectToObject[i].cSubObjects,
                               pFirstConnectToObject[i].cbPrinterInfo );
        }
    }

    if( cThisLevelObjects > 0 )
        FreeSplMem( pFirstConnectToObject );

    return ( SubObjectsFreed + cThisLevelObjects );
}


/* ToggleExpandConnectToObject
 *
 * Expands or collapses the node accordingly.
 *
 * Arguments:
 *
 *     hwndListbox - Handle of the listbox containing the printer info.
 *
 *     pConnectToObject - The node to be expanded or collapsed.
 *         If it has already been expanded, collapse it, otherwise expand it.
 *
 * Return:
 *
 *     TRUE if no error occurred.
 *
 */
BOOL ToggleExpandConnectToObject(
    HWND              hwnd,
    PCONNECTTO_OBJECT pConnectToObject )
{
    PBROWSE_DLG_DATA  pBrowseDlgData;
    DWORD             ObjectsRemoved = 0;

    if( !( pBrowseDlgData = GET_BROWSE_DLG_DATA(hwnd) ) )
        return FALSE;

    ASSERT( pBrowseDlgData->csLock.bInside() );

    if( pConnectToObject->pSubObject )
    {
        ObjectsRemoved = FreeConnectToObjects(
                             &pConnectToObject->pSubObject[0],
                             pConnectToObject->cSubObjects,
                             pConnectToObject->cbPrinterInfo );

        pConnectToObject->pSubObject    = NULL;
        pConnectToObject->cSubObjects   = 0;
        pConnectToObject->cbPrinterInfo = 0;

        UpdateList( hwnd, ( - (INT)ObjectsRemoved ) );

        SetCursor( pBrowseDlgData->hcursorArrow );
    }
    else
    {
        pBrowseDlgData->Status |= BROWSE_STATUS_EXPAND;
        SetCursorShape( hwnd );

        DISABLE_LIST(hwnd);

        SEND_BROWSE_THREAD_REQUEST( pBrowseDlgData,
                                    BROWSE_THREAD_ENUM_OBJECTS,
                                    pConnectToObject->pPrinterInfo->pName,
                                    pConnectToObject );
    }

    return TRUE;
}


BOOL UpdateList(
    HWND hwnd,
    INT  Increment )
{
    HWND              hwndListbox;
    LONG_PTR          CurSel;
    LONG_PTR          OldCount;
    DWORD             ObjectsRemoved = 0;
    LONG_PTR          NewObjectsOutOfView;
    ULONG_PTR         TopIndex;
    ULONG_PTR         BottomIndex;
    RECT              CurrentSelectionRect;
    RECT              ListboxRect;
    DWORD             Error = 0;

    ASSERT( GET_BROWSE_DLG_DATA(hwnd)->csLock.bInside() );

    hwndListbox = GetDlgItem( hwnd, IDD_BROWSE_SELECT_LB );

    CurSel = SendMessage( hwndListbox, LB_GETCURSEL, 0, 0L );

    SendMessage( hwndListbox, WM_SETREDRAW, 0, 0L );

    TopIndex = SendMessage( hwndListbox, LB_GETTOPINDEX, 0, 0 );

    OldCount = SendMessage( hwndListbox, LB_GETCOUNT, 0, 0 );

    DBGMSG( DBG_TRACE, ( "Setting list count to %d\n", OldCount + Increment ) );

    SendMessage( hwndListbox, LB_SETCOUNT, OldCount + Increment, 0 );

    if( Increment > 0 )
    {
        GetClientRect( hwndListbox, &ListboxRect );
        BottomIndex = ( TopIndex +
                        ( ListboxRect.bottom / STATUS_BITMAP_HEIGHT ) - 1 );

        NewObjectsOutOfView = ( CurSel + Increment - BottomIndex );

        if( NewObjectsOutOfView > 0 )
        {
            TopIndex = min( CurSel, (LONG_PTR) ( TopIndex + NewObjectsOutOfView ) );
        }
    }

    SendMessage( hwndListbox, LB_SETCURSEL, CurSel, 0L );

    SendMessage( hwndListbox, LB_SETTOPINDEX, TopIndex, 0 );

    SendMessage( hwndListbox, WM_SETREDRAW, 1, 0L );

    SendMessage( hwndListbox, LB_GETITEMRECT, CurSel,
                 (LPARAM)&CurrentSelectionRect );

    InvalidateRect( hwndListbox, NULL, FALSE );

    return TRUE;
}

/* GetPrinterStatusString
 *
 * Loads the resource string corresponding to the supplied status code.
 *
 * andrewbe wrote it - April 1992
 */
int GetPrinterStatusString( DWORD Status, LPTSTR string )
{
    int stringID = -1;

    if( Status & PRINTER_STATUS_ERROR )
        stringID = IDS_ERROR;
    else
    if( Status & PRINTER_STATUS_PAUSED )
        stringID = IDS_PAUSED;
    else
    if( Status & PRINTER_STATUS_PENDING_DELETION )
        stringID = IDS_PENDING_DELETION;
    else
        stringID = IDS_READY;

    if( stringID != -1 )
    {
        return LoadString( ghInst, stringID, string, MAX_PATH );
    }

    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
//
//  SetInfoFields
//
//   This routine sets the Printer Information and selected printer textbox
//   fields to the currently selected item in the Select Printer listbox.
//
// TO DO:
//      error checking for win api calls
//      get strings from resource file
//
//
/////////////////////////////////////////////////////////////////////////////

BOOL SetInfoFields (
    HWND              hWnd,
    LPPRINTER_INFO_2  pPrinter
)
{
    TCHAR   PrinterStatus[MAX_PATH];
    BOOL    BufferAllocated = FALSE;

    ASSERT( GET_BROWSE_DLG_DATA(hWnd)->csLock.bInside() );

    if( !pPrinter )
    {
        SetDlgItemText(hWnd, IDD_BROWSE_DESCRIPTION, TEXT(""));
        SetDlgItemText(hWnd, IDD_BROWSE_STATUS,      TEXT(""));
        SetDlgItemText(hWnd, IDD_BROWSE_DOCUMENTS,   TEXT(""));
    }

    else
    {
        SetDlgItemText(hWnd, IDD_BROWSE_PRINTER, pPrinter->pPrinterName);

        SetDlgItemText(hWnd, IDD_BROWSE_DESCRIPTION, pPrinter->pComment); // !!!???

        if(GetPrinterStatusString(pPrinter->Status, PrinterStatus))
            SetDlgItemText(hWnd, IDD_BROWSE_STATUS, PrinterStatus);
        else
            SetDlgItemText(hWnd, IDD_BROWSE_STATUS, TEXT(""));

        SetDlgItemInt(hWnd, IDD_BROWSE_DOCUMENTS, (UINT)pPrinter->cJobs, FALSE);
    }

    return TRUE;
}


/* --- Function: DrawLine() -------------------------------------------------
 *
 */
void
DrawLine(
   HDC     hDC,
   LPRECT  pRect,
   LPTSTR  pStr,
   BOOL    bInvert
)
{
   ExtTextOut(hDC, pRect->left, pRect->top, ETO_OPAQUE, (CONST RECT *)pRect,
              pStr, _tcslen(pStr), NULL);
}


/* DrawLineWithTabs
 *
 * Accepts a zero-terminated buffer containing strings delimited by commas
 * in the following format: <string> [,<string>[,<string> ... ]]
 * where <string> may be zero characters in length,
 * e.g.:
 *       \\ntprint\LASER,HP Laserjet Series II,,other stuff
 *
 * It takes a copy of the string, and converts any commas into NULLs,
 * ensuring that the new buffer has a double NULL termination,
 * then steps through calling DrawLine on each NULL-terminated substring.
 */
void
DrawLineWithTabs(
    HDC     hDC,
    LPRECT  pRect,
    LPTSTR  pStr,
    BOOL    bInvert
)
{
    DWORD ColumnWidth = COLUMN_WIDTH;  // Arbitrary column width for now
    RECT  ColumnRect;
    TCHAR *pBuffer;
    TCHAR *pBufferEnd;
    TCHAR OutputBuffer[OUTPUT_BUFFER_LENGTH+2];  // Allow for double null terminator
    DWORD StringLength;     // Number of TCHARs in string;
    DWORD BytesToCopy;      // Number of BYTEs in OutputBuffer;
    DWORD BufferLength;     // NUMBER of TCHARs in OutputBuffer;
#ifdef _HYDRA_
    SIZE StrSize;
    DWORD ColSize, StrWidth;
#endif

    /* Make a copy of the input string so we can mess with it
     * without any worries.
     * Just in case it's longer than our buffer, copy no more than
     * buffer length:
     */
    StringLength = _tcslen( pStr );

    BytesToCopy = min( ( StringLength * sizeof( TCHAR ) ), OUTPUT_BUFFER_LENGTH );

    memcpy( OutputBuffer, pStr, BytesToCopy );

    BufferLength = ( BytesToCopy / sizeof( TCHAR ) );

    pBufferEnd = &OutputBuffer[BufferLength];

    OutputBuffer[BufferLength] = (TCHAR)0;   // Ensure double
    OutputBuffer[BufferLength+1] = (TCHAR)0; // null terminated


    /* Convert commas to nulls:
     */
    pBuffer = OutputBuffer;

    while( *pBuffer )
    {
        if( *pBuffer == (TCHAR)',' )
            *pBuffer = (TCHAR)0;

        pBuffer++;
    }


    CopyRect( &ColumnRect, (CONST RECT *)pRect );

    /* Tokenise the buffer delimited by commas:
     */
    pBuffer = OutputBuffer;

    while( pBuffer < pBufferEnd )
    {
#ifdef _HYDRA_
        // For long strings, expand the column size.  This prevents
        // columns from aligning.  But that is better than the alternatives
        // which are to truncate the text or to make super wide columns
        // that force the user to scroll.

        ColSize = ColumnWidth;
        if (GetTextExtentPoint32(hDC, pBuffer, _tcslen(pBuffer),
            &StrSize) != 0)
           {
           StrWidth = (DWORD) StrSize.cx;
           while (ColSize < StrWidth && ColSize < 8 * ColumnWidth)
                 ColSize += ColumnWidth / 2;
           }
        ColumnRect.right = ColumnRect.left + ColSize;
#else
        ColumnRect.right = ( ColumnRect.left + ColumnWidth );
#endif
        DrawLine( hDC, &ColumnRect, pBuffer, bInvert );
        ColumnRect.left = ColumnRect.right;

        /* Draw a column separator:
         */
        ColumnRect.right = ( ColumnRect.left + COLUMN_SEPARATOR_WIDTH );
        DrawLine( hDC, &ColumnRect, TEXT(""), bInvert );
        ColumnRect.left = ColumnRect.right;

        /* Find and step over the next null:
         */
        while( *pBuffer++ )
            ;
    }

    ColumnRect.right = pRect->right;

    DrawLine( hDC, &ColumnRect, TEXT(""), bInvert );
}


/* DisplayStatusIcon
 *
 * andrewbe - May 1992
 */
BOOL DisplayStatusIcon( HDC hdc, PRECT prect, int xBase, int yBase,  BOOL Highlight )
{
    BOOL  OK;
    int   right;

    right = prect->right;

    if( ( SysColorWindow != GetSysColor(COLOR_WINDOW))
      ||( SysColorHighlight != GetSysColor(COLOR_HIGHLIGHT)))
        FixupBitmapColours( );

    OK = BitBlt( hdc, prect->left + STATUS_BITMAP_MARGIN,
                 prect->top,
                 STATUS_BITMAP_WIDTH,
                 STATUS_BITMAP_HEIGHT,
                 hdcBitmap,
                 xBase,
                 Highlight ? ( yBase + STATUS_BITMAP_HEIGHT ) : yBase,
                 SRCCOPY );

    if( OK )
    {
        /* Draw around it so we don't get a flashing effect on the highlight line:
         */
        prect->right = ( prect->left + STATUS_BITMAP_MARGIN );
        DrawLine( hdc, prect, TEXT(""), Highlight );

        prect->left += STATUS_BITMAP_MARGIN + STATUS_BITMAP_WIDTH;
        prect->right = prect->left + STATUS_BITMAP_MARGIN;
        DrawLine( hdc, prect, TEXT(""), Highlight );

        prect->left += STATUS_BITMAP_MARGIN;
    }

    else
    {
        prect->right = STATUS_BITMAP_SPACE;
        DrawLine( hdc, prect, TEXT(""), Highlight );

        prect->left += STATUS_BITMAP_SPACE;
    }

    /* Restore the right coordinate (left has now been updated to the new position):
     */
    prect->right = right;

    return OK;
}


/////////////////////////////////////////////////////////////////////////////
//
//  LoadBitmaps
//
// this routine loads DIB bitmaps, and "fixes up" their color tables
// so that we get the desired result for the device we are on.
//
// this routine requires:
//        the DIB is a 16 color DIB authored with the standard windows colors
//        bright green   (00 FF 00) is converted to the background color!
//        bright magenta (FF 00 FF) is converted to the background color!
//        light grey     (C0 C0 C0) is replaced with the button face color
//        dark grey      (80 80 80) is replaced with the button shadow color
//
// this means you can't have any of these colors in your bitmap
//
/////////////////////////////////////////////////////////////////////////////


DWORD FlipColor(DWORD rgb)
{
   return RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb));
}


BOOL LoadBitmaps()
{
    HDC           hdc;
    HANDLE        h;
    DWORD FAR    *pColorTable;
    LPBYTE        lpBits;
    LPBITMAPINFOHEADER        lpBitmapInfo;
    int           i;
    UINT   cbBitmapSize;
    LPBITMAPINFOHEADER        lpBitmapData;

    h = FindResource(ghInst, MAKEINTRESOURCE(IDB_BROWSE), RT_BITMAP);

    if( !h )
        return FALSE;

    hRes = LoadResource(ghInst, (HRSRC)h);

    if( !hRes )
        return FALSE;

    /* Lock the bitmap and get a pointer to the color table. */
    lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

    if (!lpBitmapInfo)
        return FALSE;

    cbBitmapSize = SizeofResource(ghInst, (HRSRC)h);
    if (!(lpBitmapData = (LPBITMAPINFOHEADER)LocalAlloc(LMEM_FIXED, cbBitmapSize))) {
       FreeResource( hRes );
       return FALSE;
    }

    CopyMemory((PBYTE)lpBitmapData, (PBYTE)lpBitmapInfo, cbBitmapSize);

    pColorTable = (DWORD FAR *)((LPBYTE)(lpBitmapData) + lpBitmapData->biSize);

    /* Search for the Solid Blue entry and replace it with the current
     * background RGB.
     */
    if( !ColorIndicesInitialised )
    {
        for( i = 0; i < 16; i++ )
        {
            switch( pColorTable[i] )
            {
            case BACKGROUND:
                iBackground = i;
                break;

            case BACKGROUNDSEL:
                iBackgroundSel = i;
                break;

            case BUTTONFACE:
                iButtonFace = i;
                break;

            case BUTTONSHADOW:
                iButtonShadow = i;
                break;
            }
        }

        ColorIndicesInitialised = TRUE;
    }

    pColorTable[iBackground]    = FlipColor(GetSysColor(COLOR_WINDOW));
    pColorTable[iBackgroundSel] = FlipColor(GetSysColor(COLOR_HIGHLIGHT));
    pColorTable[iButtonFace]    = FlipColor(GetSysColor(COLOR_BTNFACE));
    pColorTable[iButtonShadow]  = FlipColor(GetSysColor(COLOR_BTNSHADOW));


    UnlockResource(hRes);


    /* First skip over the header structure */
    lpBits = (LPBYTE)(lpBitmapData + 1);

    /* Skip the color table entries, if any */
    lpBits += (1 << (lpBitmapData->biBitCount)) * sizeof(RGBQUAD);

    /* Create a color bitmap compatible with the display device */
    BOOL bResult = FALSE;
    hdc = GetDC(NULL);

    if( hdc && (hdcBitmap = CreateCompatibleDC(hdc)) )
    {
        if (hbmBitmap = CreateDIBitmap (hdc, lpBitmapData, (DWORD)CBM_INIT,
                        lpBits, (LPBITMAPINFO)lpBitmapData, DIB_RGB_COLORS))
        {
            hbmDefault = (HBITMAP)SelectObject(hdcBitmap, hbmBitmap);
            bResult = TRUE;
        }
    }

    if( hdc )
    {
        ReleaseDC(NULL, hdc);
    }

    GlobalUnlock(hRes);
    FreeResource(hRes);

    LocalFree(lpBitmapData);

    return bResult;
}


/* I'm sure there's a better way to do this.
 * We should be able to modify the colour palette,
 * but I haven't managed to make it work...
 */
BOOL FixupBitmapColours( )
{
    FreeBitmaps( );
    LoadBitmaps( );

    return TRUE;
}


INT  APIENTRY GetHeightFromPointsString(DWORD Points)
{
    HDC hdc;
    INT height = Points;

    hdc = GetDC(NULL);
    if( hdc )
    {
        height = MulDiv( -(LONG)(Points), GetDeviceCaps(hdc, LOGPIXELSY), 72 );
        ReleaseDC(NULL, hdc);
    }

    return height;
}

VOID FreeBitmaps( )
{
    SelectObject( hdcBitmap, hbmDefault );

    DeleteObject( hbmBitmap );
    DeleteDC( hdcBitmap );
}



/* GetRegShowLogonDomainFlag
 *
 * Checks to see whether the current user has disabled the ShowLogonDomain
 * flag to stop the default domain being expanded.
 *
 * If the flag is not there or an error occurs, defaults to TRUE.
 *
 */
BOOL GetRegShowLogonDomainFlag( )
{
    TStatusB bStatus;
    BOOL bShowLogonDomain = FALSE;

    //
    // Read the show logon domain flag from the registry.
    //
    TPersist Persist( gszRegPrinters, TPersist::kOpen|TPersist::kRead );

    bStatus DBGCHK = VALID_OBJ( Persist );

    if( bStatus )
    {
        bStatus DBGCHK = Persist.bRead( gszShowLogonDomain, bShowLogonDomain );
    }

    return bShowLogonDomain;
}


/* SetRegShowLogonDomainFlag
 *
 *
 */
BOOL SetRegShowLogonDomainFlag( BOOL bShowLogonDomain )
{
    TStatusB bStatus;

    //
    // Write the show logon domain flag to the registry.
    //
    TPersist Persist( gszRegPrinters, TPersist::kCreate|TPersist::kWrite );

    bStatus DBGCHK = VALID_OBJ( Persist );

    if( bStatus )
    {
        bStatus DBGCHK = Persist.bWrite( gszShowLogonDomain, bShowLogonDomain );
    }

    return bStatus;
}

/* Strip out carriage return and linefeed characters,
 * and convert them to spaces:
 */
VOID RemoveCrLf( LPTSTR pString )
{
    while( *pString )
    {
        if( ( 0x0d == *pString ) || ( 0x0a == *pString ) )
            *pString = ' ';

        pString++;
    }
}


VOID UpdateError( HWND hwnd, DWORD Error )
{
    TCHAR ErrorTitle[20] = TEXT("");
    TCHAR  ErrorText[1048];
    LPTSTR pErrorString;

    if( Error == NO_ERROR )
    {
        ShowWindow( GetDlgItem( hwnd, IDD_BROWSE_DESCRIPTION_TX ), SW_SHOW );
        ShowWindow( GetDlgItem( hwnd, IDD_BROWSE_DESCRIPTION ), SW_SHOW );
        ShowWindow( GetDlgItem( hwnd, IDD_BROWSE_STATUS_TX ), SW_SHOW );
        ShowWindow( GetDlgItem( hwnd, IDD_BROWSE_STATUS ), SW_SHOW );
        ShowWindow( GetDlgItem( hwnd, IDD_BROWSE_DOCUMENTS_TX ), SW_SHOW );
        ShowWindow( GetDlgItem( hwnd, IDD_BROWSE_DOCUMENTS ), SW_SHOW );
        ShowWindow( GetDlgItem( hwnd, IDD_BROWSE_ERROR ), SW_HIDE );
        SetDlgItemText(hwnd, IDD_BROWSE_ERROR, TEXT(""));
    }
    else
    {
        ShowWindow( GetDlgItem( hwnd, IDD_BROWSE_DESCRIPTION_TX ), SW_HIDE );
        ShowWindow( GetDlgItem( hwnd, IDD_BROWSE_DESCRIPTION ), SW_HIDE );
        ShowWindow( GetDlgItem( hwnd, IDD_BROWSE_STATUS_TX ), SW_HIDE );
        ShowWindow( GetDlgItem( hwnd, IDD_BROWSE_STATUS ), SW_HIDE );
        ShowWindow( GetDlgItem( hwnd, IDD_BROWSE_DOCUMENTS_TX ), SW_HIDE );
        ShowWindow( GetDlgItem( hwnd, IDD_BROWSE_DOCUMENTS ), SW_HIDE );
        ShowWindow( GetDlgItem( hwnd, IDD_BROWSE_ERROR ), SW_SHOW );

        if( !*ErrorTitle )
            LoadString( ghInst, IDS_ERROR, ErrorTitle, COUNTOF(ErrorTitle));

        if( *ErrorTitle )
        {
            TString strErrorString;
            TResult Result( Error );

            Result.bGetErrorString( strErrorString );

            pErrorString = (LPTSTR)(LPCTSTR)strErrorString;

            if( pErrorString )
            {
                RemoveCrLf( pErrorString );

                _stprintf( ErrorText,
                          TEXT("%s: %s"),
                          ErrorTitle,
                          pErrorString );

                SetDlgItemText(hwnd, IDD_BROWSE_ERROR, ErrorText);
            }
        }
    }
}

/*++

Routine Name:

    SPLSETUP_DATA

Routine Description:

    Constructor/Destructor

Arguments:


Return Value:


--*/
SPLSETUP_DATA::
SPLSETUP_DATA(
    VOID
    ) : hModule(NULL),
        hDevInfo(INVALID_HANDLE_VALUE),
        pSetupLocalData(NULL),
        pfnCreatePrinterDeviceInfoList(NULL),
        pfnDestroyPrinterDeviceInfoList(NULL),
        pfnSelectDriver(NULL),
        pfnGetSelectedDriverInfo(NULL),
        pfnDestroySelectedDriverInfo(NULL),
        pfnInstallPrinterDriver(NULL),
        pfnThisPlatform(NULL),
        pfnDriverInfoFromName(NULL),
        pfnGetPathToSearch(NULL),
        pfnBuildDriversFromPath(NULL),
        pfnIsDriverInstalled(NULL),
        pfnGetLocalDataField(NULL),
        pfnFreeDrvField(NULL),
        pfnProcessPrinterAdded(NULL),
        pfnFindMappedDriver(NULL),
        pfnInstallInboxDriverSilently(NULL),
        pfnFreeMem(NULL),
        bValid(FALSE),
        bDriverAdded(FALSE),
        dwLastError(ERROR_SUCCESS)
{
    if ( (hModule = LoadLibrary(TEXT("ntprint.dll")))  &&
         (pfnCreatePrinterDeviceInfoList
                = (pfPSetupCreatePrinterDeviceInfoList)GetProcAddress(hModule, "PSetupCreatePrinterDeviceInfoList")) &&
         (pfnDestroyPrinterDeviceInfoList
               = (pfPSetupDestroyPrinterDeviceInfoList)GetProcAddress(hModule, "PSetupDestroyPrinterDeviceInfoList")) &&
         (pfnSelectDriver
                = (pfPSetupSelectDriver)GetProcAddress(hModule, "PSetupSelectDriver")) &&
         (pfnGetSelectedDriverInfo
                = (pfPSetupGetSelectedDriverInfo)GetProcAddress(hModule, "PSetupGetSelectedDriverInfo")) &&
         (pfnDestroySelectedDriverInfo
                = (pfPSetupDestroySelectedDriverInfo)GetProcAddress(hModule, "PSetupDestroySelectedDriverInfo")) &&
         (pfnInstallPrinterDriver
                = (pfPSetupInstallPrinterDriver)GetProcAddress(hModule, "PSetupInstallPrinterDriver")) &&
         (pfnThisPlatform
                = (pfPSetupThisPlatform)GetProcAddress(hModule, "PSetupThisPlatform")) &&
         (pfnDriverInfoFromName
                = (pfPSetupDriverInfoFromName)GetProcAddress(hModule, "PSetupDriverInfoFromName")) &&
         (pfnGetPathToSearch
                = (pfPSetupGetPathToSearch)GetProcAddress(hModule, "PSetupGetPathToSearch")) &&
         (pfnBuildDriversFromPath
                = (pfPSetupBuildDriversFromPath)GetProcAddress(hModule, "PSetupBuildDriversFromPath")) &&
         (pfnIsDriverInstalled
                = (pfPSetupIsDriverInstalled)GetProcAddress(hModule, "PSetupIsDriverInstalled"))   &&
         (pfnGetLocalDataField
                = (pfPSetupGetLocalDataField)GetProcAddress(hModule, "PSetupGetLocalDataField"))   &&
         (pfnFreeDrvField
                = (pfPSetupFreeDrvField)GetProcAddress(hModule, "PSetupFreeDrvField"))    &&
         (pfnProcessPrinterAdded
                = (pfPSetupProcessPrinterAdded)GetProcAddress(hModule, "PSetupProcessPrinterAdded")) &&
         (pfnFindMappedDriver
                = (pfPSetupFindMappedDriver)GetProcAddress(hModule, "PSetupFindMappedDriver")) &&
         (pfnInstallInboxDriverSilently
                = (pfPSetupInstallInboxDriverSilently)GetProcAddress(hModule, "PSetupInstallInboxDriverSilently")) &&
         (pfnFreeMem
                = (pfPSetupFreeMem)GetProcAddress(hModule, "PSetupFreeMem"))
       )
    {
        bValid = TRUE;
    }
}

SPLSETUP_DATA::
~SPLSETUP_DATA(
    VOID
    )
{
    //
    // Free up the alocated resources.
    //
    FreeDriverInfo( );

    if( hModule )
    {
        FreeLibrary( hModule );
    }
}

VOID
SPLSETUP_DATA::
FreeDriverInfo(
    VOID
    )
{
    if( hDevInfo != INVALID_HANDLE_VALUE )
    {
        pfnDestroyPrinterDeviceInfoList( hDevInfo );
        hDevInfo = INVALID_HANDLE_VALUE;
    }

    if( pSetupLocalData )
    {
        pfnDestroySelectedDriverInfo( pSetupLocalData );
        pSetupLocalData = NULL;
    }
}

BOOL
SPLSETUP_DATA::
LoadDriverInfo(
    IN  HWND    hwnd,
    IN  LPWSTR  pszDriver
    )
{
    FreeDriverInfo( );

    //
    // Put up the Model/Manf dialog and install the printer driver selected
    // by the user
    //
    hDevInfo = pfnCreatePrinterDeviceInfoList( hwnd );

    if ( hDevInfo == INVALID_HANDLE_VALUE )
    {
        return FALSE;
    }

    //
    // If we know the driver name we will see if it is found in the infs on
    // the system
    //
    if( pszDriver )
    {
        pSetupLocalData = pfnDriverInfoFromName( hDevInfo, pszDriver );
    }

    //
    // If we do not know the driver name or if the driver is not found in
    // the infs we will prompt and let the user select a driver
    //
    if( !pSetupLocalData )
    {
        if( !pfnSelectDriver( hDevInfo ) )
        {
            return FALSE;
        }

        pSetupLocalData = pfnGetSelectedDriverInfo( hDevInfo );

        if( !pSetupLocalData )
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
SPLSETUP_DATA::
LoadKnownDriverInfo(
    IN  HWND    hwnd,
    IN  LPWSTR  pszDriver
    )
{
    TString strFormat;
    TString strTitle;
    TCHAR   szInfDir[MAX_PATH];

    FreeDriverInfo( );

    hDevInfo = pfnCreatePrinterDeviceInfoList( hwnd );

    if( hDevInfo == INVALID_HANDLE_VALUE )
    {
        return FALSE;
    }

    pSetupLocalData = pfnDriverInfoFromName( hDevInfo, pszDriver );

    if( !pSetupLocalData )
    {
        if( !strFormat.bLoadString( ghInst, IDS_PROMPTFORINF ) ||
            !strTitle.bFormat( strFormat, pszDriver ) )
        {
            return FALSE;
        }

        szInfDir[0] = TEXT('\0');

        if( pfnGetPathToSearch( hwnd, strTitle, NULL, TEXT("*.INF"), FALSE, szInfDir )  &&
            pfnBuildDriversFromPath(hDevInfo, szInfDir, FALSE) )
        {
            pSetupLocalData = pfnDriverInfoFromName( hDevInfo, pszDriver );
        }
    }

    if( !pSetupLocalData )
    {
        return FALSE;
    }

    return TRUE;
}

VOID
SPLSETUP_DATA::
ReportErrorMessage(
    IN  HWND    hwnd
    )
{
    if( dwLastError != ERROR_SUCCESS )
    {

        switch( dwLastError )
        {
            case ERROR_UNKNOWN_PRINTER_DRIVER:
                {
                    iMessage( hwnd,
                              IDS_INSTALLDRIVER,
                              IDS_ERROR_UNKNOWN_DRIVER,
                              MB_OK | MB_ICONSTOP,
                              kMsgNone,
                              NULL );
                }
                break;

            case ERROR_CANCELLED:
                // do nothing
                break;

            default:
                {
                    iMessage( hwnd,
                              IDS_INSTALLDRIVER,
                              IDS_ERRORRUNNINGSPLSETUP,
                              MB_OK | MB_ICONSTOP,
                              dwLastError,
                              NULL );
                }
                break;
        }
    }
}

inline static BOOL
IsNULLDriver(LPWSTR pszDriver)
{
    // the spooler is setting the driver name to "NULL" for downlevel
    // print servers, so applications don't crash. pretty weird, but
    // that's how it is.
    return (
        NULL == pszDriver ||
        0 == pszDriver[0] ||
        0 == lstrcmpi(pszDriver, TEXT("NULL"))
        );
}

BOOL
AddDriver(
    IN  SPLSETUP_DATA  *pSplSetupData,
    IN  HWND            hwnd,
    IN  LPWSTR          pszDriver,
    IN  BOOL            bPromptUser,
    OUT LPWSTR          *ppszDriverOut
    )
/*++

Routine Description:

    Verifies the user wants to install a driver, then puts up UI to
    select the driver (pre-selects based on pszDriver), then invokes
    install code.

Arguments:

    pSplSetupData   - The setup data used for the driver installation from
                      ntprint.dll.
    hwnd            - Parent window.
    pszDriver       - The driver from the remote printer provider (if known).
    bPromptUser     - If TRUE, the user should be prompted before installation.
    ppszDriverOut - Driver selected by user, must be freed by callee
        when this call succeeds.

Return Value:

    TRUE = success, FALSE = FAILURE.

Notes:

    Doesn't allow third party infs.

--*/

{
    BOOL                bRet = FALSE;
    DRIVER_FIELD        DrvField;

    // Put up a message box to confirm that the user wants
    // to install a driver locally:
    //
    if (bPromptUser)
    {
        if( iMessage( hwnd,
                      IDS_CONNECTTOPRINTER,
                      IsNULLDriver(pszDriver) ? IDS_CONFIRMINSTALLDRIVER : IDS_CONFIRMINSTALLKNOWNDRIVER,
                      MB_OKCANCEL | MB_ICONEXCLAMATION,
                      kMsgNone,
                      NULL,
                      pszDriver ) != IDOK )
        {
            return FALSE;
        }
    }

    DrvField.Index          = DRIVER_NAME;
    DrvField.pszDriverName  = NULL;

    SPLASSERT( pSplSetupData );

    if ( pSplSetupData->LoadDriverInfo( hwnd, pszDriver ) &&
         pSplSetupData->pfnGetLocalDataField(
            pSplSetupData->pSetupLocalData,
            pSplSetupData->pfnThisPlatform(),
            &DrvField) &&
         (pSplSetupData->pfnIsDriverInstalled(NULL,
                                            DrvField.pszDriverName,
                                            pSplSetupData->pfnThisPlatform(),
                                            KERNEL_MODE_DRIVER_VERSION) ||
         ERROR_SUCCESS == (pSplSetupData->dwLastError = pSplSetupData->pfnInstallPrinterDriver(
                                        pSplSetupData->hDevInfo,
                                        pSplSetupData->pSetupLocalData,
                                        NULL,
                                        pSplSetupData->pfnThisPlatform(),
                                        SPOOLER_VERSION,
                                        NULL,
                                        hwnd,
                                        NULL,
                                        NULL,
                                        0,
                                        APD_COPY_NEW_FILES,
                                        NULL))) )
    {
        pSplSetupData->bDriverAdded = TRUE;

        *ppszDriverOut = AllocSplStr( DrvField.pszDriverName );
        if ( *ppszDriverOut )
        {
            // success here
            bRet = TRUE;
        }
    }

    if( DrvField.pszDriverName )
    {
        pSplSetupData->pfnFreeDrvField(&DrvField);
    }

    if( !bRet && ERROR_SUCCESS == pSplSetupData->dwLastError )
    {
        pSplSetupData->dwLastError = GetLastError();

        //
        // If ntprint.dll fails, but doesn't set the last error then
        // we will set a bizarre last error here, so the UI will end
        // up displaying a generic error message instead of silence.
        //
        if( ERROR_SUCCESS == pSplSetupData->dwLastError )
        {
            pSplSetupData->dwLastError = ERROR_INVALID_FUNCTION;
        }
    }

    return bRet;
}

BOOL
AddKnownDriver(
    IN  SPLSETUP_DATA  *pSplSetupData,
    IN  HWND            hwnd,
    IN  LPWSTR          pszDriver,
    IN  BOOL            bSamePlatform
    )
/*++

Routine Description:

    Adds a known driver.  Doesn't prompt for printer name or driver
    selection; calls setup directly.

Arguments:

    hwnd - Parent hwnd.

    pszDriver - Driver to install.

Return Value:

    TRUE = success, FALSE = failure.

--*/
{
    ASSERT(pSplSetupData);
    BOOL bRet = FALSE;

    //
    // Put up a message box to confirm that the user wants
    // to install a driver locally:
    //
    if (iMessage(hwnd,
                 IDS_CONNECTTOPRINTER,
                 IDS_CONFIRMINSTALLKNOWNDRIVER,
                 MB_OKCANCEL | MB_ICONEXCLAMATION,
                 kMsgNone,
                 NULL,
                 pszDriver) != IDOK)
    {
        return FALSE;
    }

    // don't offer replacement inbox driver in the AddPrinterConnection case
    DWORD dwInstallFlags = DRVINST_DONT_OFFER_REPLACEMENT;

    if( pSplSetupData->LoadKnownDriverInfo( hwnd, pszDriver ) )
    {
        pSplSetupData->dwLastError = pSplSetupData->pfnInstallPrinterDriver(
                                        pSplSetupData->hDevInfo,
                                        pSplSetupData->pSetupLocalData,
                                        NULL,
                                        pSplSetupData->pfnThisPlatform(),
                                        SPOOLER_VERSION,
                                        NULL,
                                        hwnd,
                                        NULL,
                                        NULL,
                                        dwInstallFlags,
                                        APD_COPY_NEW_FILES,
                                        NULL );

        if ( ERROR_SUCCESS == pSplSetupData->dwLastError )
        {
            pSplSetupData->bDriverAdded = TRUE;
            bRet = TRUE;
        }
    }

    if( !bRet && ERROR_SUCCESS == pSplSetupData->dwLastError )
    {
        pSplSetupData->dwLastError = GetLastError();

        //
        // If ntprint.dll fails, but doesn't set the last error then
        // we will set a bizarre last error here, so the UI will end
        // up displaying a generic error message instead of silence.
        //
        if( ERROR_SUCCESS == pSplSetupData->dwLastError )
        {
            pSplSetupData->dwLastError = ERROR_INVALID_FUNCTION;
        }
    }

    return bRet;
}

/*++

Routine Name:

    IsNTServer

Routine Description:

    Returns whether the given server is a windows nt server or not.

Arguments:

    pszServerName -

Return Value:

    An HRESULT  -  S_OK     - It is an NT server.
                   S_FALSE  - It is not an NT server.
                   E_X      - There was an error.

--*/
HRESULT
IsNTServer(
    IN      PCWSTR              pszServerName
    )
{
    HANDLE           hServer    =   NULL;
    PRINTER_DEFAULTS PrinterDef = { NULL, NULL, SERVER_READ };
    TStatusH hRetval;

    //
    // If we can open the remote server, then this is an NT box.
    //
    hRetval DBGCHK = OpenPrinter(const_cast<PWSTR>(pszServerName), &hServer, &PrinterDef) ? S_OK : CreateHRFromWin32();

    if (hServer)
    {
        ClosePrinter(hServer);
    }

    return SUCCEEDED(hRetval) ? S_OK : S_FALSE;
}

/*++

Routine Name:

    CreateLocalPort

Routine Description:

    This creates a local port of the given name by communicating with the
    local monitor.

Arguments:

    pszPortName -   The port name to add.

Return Value:

    TRUE - Success, FALSE - Failure.

--*/
BOOL
CreateLocalPort(
    IN      PCWSTR              pszPortName
    )
{
    HANDLE           hXcv     = NULL;
    PRINTER_DEFAULTS Defaults = { NULL, NULL, SERVER_ACCESS_ADMINISTER };
    TStatusB         bRet;

    if (pszPortName == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);

        bRet DBGCHK = FALSE;
    }

    //
    // Open a Xcv handle to the local monitor.
    //
    if (bRet)
    {
        bRet DBGCHK = OpenPrinter(const_cast<PWSTR>(gszXvcLocalMonitor), &hXcv, &Defaults);
    }

    //
    // Ask it to add a port for us.
    //
    if (bRet)
    {
        DWORD   cbOutputNeeded = 0;
        DWORD   Status         = ERROR_SUCCESS;

        bRet DBGCHK = XcvData(hXcv,
                              gszAddPort,
                              reinterpret_cast<BYTE *>(const_cast<PWSTR>(pszPortName)),
                              (wcslen(pszPortName) + 1) * sizeof(WCHAR),
                              NULL,
                              0,
                              &cbOutputNeeded,
                              &Status);

        if (bRet)
        {
            //
            // If it succeeded, or the port already exists, we are OK.
            //
            if (Status != ERROR_SUCCESS && Status != ERROR_ALREADY_EXISTS)
            {
                SetLastError(Status);

                bRet DBGCHK = FALSE;
            }
        }
    }

    if (hXcv)
    {
        ClosePrinter(hXcv);
    }

    return bRet;
}

LPVOID
AllocSplMem(
    DWORD cb
    )
{
    LPVOID pReturn = AllocMem( cb );

    if( pReturn )
    {
        memset( pReturn, 0, cb );
    }

    return pReturn;
}

BOOL
FreeSplMem(
    LPVOID pMem
    )
{
    FreeMem( pMem );
    return TRUE;
}

LPVOID
ReallocSplMem(
    LPVOID  pOldMem,
    DWORD   cbOld,
    DWORD   cbNew
    )
{
    LPVOID pNewMem = AllocSplMem( cbNew );

    if (pOldMem && pNewMem)
    {
        if (cbOld)
        {
            memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        }

        FreeSplMem(pOldMem);
    }

    return pNewMem;
}

LPTSTR
AllocSplStr(
    LPCTSTR pStr
    )
{
    LPTSTR pMem = NULL;

    if( pStr )
    {
        pMem = (LPTSTR)AllocSplMem( _tcslen(pStr) * sizeof(TCHAR) + sizeof(TCHAR) );

        if( pMem )
        {
            _tcscpy( pMem, pStr );
        }
    }

    return pMem;
}

BOOL
FreeSplStr(
    LPTSTR pStr
    )
{
    FreeSplMem( pStr );
    return TRUE;
}

static MSG_HLPMAP MsgHelpTable [] =
{
    { ERROR_KM_DRIVER_BLOCKED, IDS_NULLSTR, gszHelpTroubleShooterURL},
    { 0, 0, 0}
};

DWORD
ReportFailure(
    HWND  hwndParent,
    DWORD idTitle,
    DWORD idDefaultError
    )
{
    DWORD dwLastError = GetLastError();

    if( dwLastError == ERROR_KM_DRIVER_BLOCKED )
    {
        iMessageEx ( hwndParent,
                     idTitle,
                     IDS_COULDNOTCONNECTTOPRINTER_BLOCKED_HELP,
                     MB_OK | MB_ICONSTOP,
                     dwLastError,
                     NULL,
                     dwLastError,
                     MsgHelpTable);
    }
    else
    {
        iMessageEx( hwndParent,
                    idTitle,
                    idDefaultError,
                    MB_OK | MB_ICONSTOP,
                    dwLastError,
                    NULL,
                    bGoodLastError(dwLastError) ? -1 : idDefaultError,
                    NULL );
    }

    return dwLastError;
}

BROWSE_DLG_DATA::
BROWSE_DLG_DATA(
    VOID
    ) : hPrinter( NULL ),
        Request( NULL ),
        RequestComplete( NULL ),
        pConnectToData( NULL ),
        Status( 0 ),
        cExpandObjects( 0 ),
        ExpandSelection( NULL ),
        dwExtent( 0 ),
        pEnumerateName( NULL ),
        pEnumerateObject( NULL ),
        Message( 0 ),
        wParam( 0 ),
        lParam( 0 ),
        pPrinterInfo( NULL ),
        cbPrinterInfo( 0 ),
        hwndDialog( NULL ),
        _bValid( FALSE ),
        pPageSwitchController( NULL ),
        bInPropertyPage( FALSE )
{
    DBGMSG( DBG_TRACE, ( "BROWSE_DLG_DATA::ctor\n") );\

    hcursorArrow  = LoadCursor(NULL, IDC_ARROW);
    hcursorWait   = LoadCursor(NULL, IDC_WAIT);

    //
    // Leave _bValid = FALSE if cursors are *not* loaded properly
    //
    if( hcursorArrow && hcursorWait )
    {
        _bValid = MRefCom::bValid();
    }
}

BROWSE_DLG_DATA::
~BROWSE_DLG_DATA(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "BROWSE_DLG_DATA::dtor\n") );

    if( pPrinterInfo )
        FreeSplMem( pPrinterInfo );

    if (pConnectToData)
        FreeSplMem(pConnectToData);

    if (RequestComplete)
        CloseHandle(RequestComplete);

    if (Request)
        CloseHandle(Request);
}

VOID
BROWSE_DLG_DATA::
vRefZeroed(
    VOID
    )
{
    delete this;
}

BOOL
BROWSE_DLG_DATA::
bValid(
    VOID
    )
{
    return _bValid;
}

BOOL
BROWSE_DLG_DATA::
bInitializeBrowseThread(
    HWND hWnd
    )
{
    if( !LoadBitmaps() )
    {
        DBGMSG( DBG_WARN, ( "Bitmaps are not loaded properly" ) );
        return FALSE;
    }

    DWORD  ThreadId;
    HANDLE hThread;

    //
    // !! WARNING !!
    // Assumes ->Request, ->RequestComplete, ->pConnectToData zero initialized!
    //
    Request = CreateEvent( NULL,
                           EVENT_RESET_AUTOMATIC,
                           EVENT_INITIAL_STATE_NOT_SIGNALED,
                           NULL );

    RequestComplete = CreateEvent( NULL,
                                   EVENT_RESET_AUTOMATIC,
                                   EVENT_INITIAL_STATE_NOT_SIGNALED,
                                   NULL );

    if( !RequestComplete || !Request )
    {
        DBGMSG( DBG_WARN, ( "CreateEvent failed: Error %d\n", GetLastError( ) ) );
        return FALSE;
    }

    if( !( pConnectToData = (PCONNECTTO_OBJECT)AllocSplMem( sizeof( CONNECTTO_OBJECT ) ) ) )
    {
        return FALSE;
    }

    vIncRef();

    hThread = TSafeThread::Create( NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)BrowseThread,
                                   this,
                                   0,
                                   &ThreadId );

    if( !hThread )
    {
        DBGMSG( DBG_WARN, ( "CreateThread of BrowseThread failed: Error %d\n", GetLastError( ) ) );
        cDecRef();
        return FALSE;
    }

    CloseHandle( hThread );

    if( bInPropertyPage || GetRegShowLogonDomainFlag( ) )
        Status |= BROWSE_STATUS_INITIAL | BROWSE_STATUS_EXPAND;

    ENTER_CRITICAL( this );

    SEND_BROWSE_THREAD_REQUEST( this,
                                BROWSE_THREAD_ENUM_OBJECTS,
                                NULL,
                                pConnectToData );

    LEAVE_CRITICAL( this );

    hwndDialog = hWnd;

    SetCursorShape( hwndDialog );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\compinfo.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997
All rights reserved.

Module Name:

    compinfo.hxx

Abstract:

    Local and remote computer information detection.

Author:

    10/17/95 <adamk> created.
    Steve Kiraly (SteveKi)  21-Jan-1996 used for downlevel server detection

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "compinfo.hxx"
#include "persist.hxx"

TCHAR const PROCESSOR_ARCHITECTURE_NAME_INTEL[]     = TEXT("Intel");
TCHAR const PROCESSOR_ARCHITECTURE_NAME_MIPS[]      = TEXT("MIPS");
TCHAR const PROCESSOR_ARCHITECTURE_NAME_ALPHA[]     = TEXT("Alpha");
TCHAR const PROCESSOR_ARCHITECTURE_NAME_POWERPC[]   = TEXT("PowerPC");
TCHAR const PROCESSOR_ARCHITECTURE_NAME_UNKNOWN[]   = TEXT("(unknown)");

TCHAR const ENVIRONMENT_IA64[]                      = TEXT("Windows IA64");
TCHAR const ENVIRONMENT_INTEL[]                     = TEXT("Windows NT x86");
TCHAR const ENVIRONMENT_MIPS[]                      = TEXT("Windows NT R4000");
TCHAR const ENVIRONMENT_ALPHA[]                     = TEXT("Windows NT Alpha_AXP");
TCHAR const ENVIRONMENT_POWERPC[]                   = TEXT("Windows NT PowerPC");
TCHAR const ENVIRONMENT_WINDOWS[]                   = TEXT("Windows 4.0");
TCHAR const ENVIRONMENT_UNKNOWN[]                   = TEXT("(unknown)");
TCHAR const ENVIRONMENT_NATIVE[]                    = TEXT("");

TCHAR const c_szProductOptionsPath[]                = TEXT( "System\\CurrentControlSet\\Control\\ProductOptions" );
TCHAR const c_szProductOptions[]                    = TEXT( "ProductType" );
TCHAR const c_szWorkstation[]                       = TEXT( "WINNT" );
TCHAR const c_szServer1[]                           = TEXT( "SERVERNT" );
TCHAR const c_szServer2[]                           = TEXT( "LANMANNT" );
TCHAR const c_szNetApi32Dll[]                       = TEXT( "netapi32.dll" );

CHAR const c_szNetServerGetInfo[]                   = "NetServerGetInfo";
CHAR const c_szNetApiBufferFree[]                   = "NetApiBufferFree";

CComputerInfo::
CComputerInfo(
    IN LPCTSTR pComputerName
    ) : ComputerName( pComputerName),
        ProductOption( kNtUnknown ),
        OSIsDebugVersion( FALSE ),
        ProcessorArchitecture( 0 ),
        ProcessorCount( 0 )
{
    DBGMSG( DBG_TRACE, ( "CComputerInfo::ctor\n" ) );
    memset( &OSInfo, 0, sizeof( OSInfo ) );
}

CComputerInfo::~CComputerInfo()
{
    DBGMSG( DBG_TRACE, ( "CComputerInfo::dtor\n" ) );
}

LPCTSTR CComputerInfo::GetProcessorArchitectureName() const
{
    SPLASSERT(IsInfoValid());

    switch (ProcessorArchitecture)
    {
        case PROCESSOR_ARCHITECTURE_INTEL:
        {
            return PROCESSOR_ARCHITECTURE_NAME_INTEL;
        }
        case PROCESSOR_ARCHITECTURE_MIPS:
        {
            return PROCESSOR_ARCHITECTURE_NAME_MIPS;
        }
        case PROCESSOR_ARCHITECTURE_ALPHA:
        {
            return PROCESSOR_ARCHITECTURE_NAME_ALPHA;
        }
        case PROCESSOR_ARCHITECTURE_PPC:
        {
            return PROCESSOR_ARCHITECTURE_NAME_POWERPC;
        }
        default:
        {
            return PROCESSOR_ARCHITECTURE_NAME_UNKNOWN;
        }
    }
}

LPCTSTR CComputerInfo::GetProcessorArchitectureDirectoryName() const
{
    SPLASSERT(IsInfoValid());

    switch (ProcessorArchitecture)
    {
        case PROCESSOR_ARCHITECTURE_INTEL:
        {
            return TEXT("i386");
        }
        case PROCESSOR_ARCHITECTURE_MIPS:
        {
            return TEXT("mips");
        }
        case PROCESSOR_ARCHITECTURE_ALPHA:
        {
            return TEXT("alpha");
        }
        case PROCESSOR_ARCHITECTURE_PPC:
        {
            return TEXT("ppc");
        }
        default:
        {
            return PROCESSOR_ARCHITECTURE_NAME_UNKNOWN;
        }
    }
}

LPCTSTR CComputerInfo::GetNativeEnvironment() const
{
    SPLASSERT(IsInfoValid());

    switch (ProcessorArchitecture)
    {
        case PROCESSOR_ARCHITECTURE_INTEL:
        {
            if (IsRunningWindows95())
            {
                return ENVIRONMENT_WINDOWS;
            }
            else
            {
                return ENVIRONMENT_INTEL;
            }
        }
        case PROCESSOR_ARCHITECTURE_MIPS:
        {
            return ENVIRONMENT_MIPS;
        }
        case PROCESSOR_ARCHITECTURE_ALPHA:
        {
            return ENVIRONMENT_ALPHA;
        }
        case PROCESSOR_ARCHITECTURE_PPC:
        {
            return ENVIRONMENT_POWERPC;
        }
        default:
        {
            SPLASSERT(FALSE);
            return ENVIRONMENT_UNKNOWN;
        }
    }
}

BOOL CComputerInfo::IsInfoValid() const
{
    // if OSInfo.dwOSVersionInfoSize is not zero, then the info has been retrieved
    return (BOOL) (OSInfo.dwOSVersionInfoSize != 0);
}

BOOL CComputerInfo::IsRunningWindowsNT() const
{
    return (OSInfo.dwPlatformId & VER_PLATFORM_WIN32_NT);
}

BOOL CComputerInfo::IsRunningWindows95() const
{
    return (OSInfo.dwPlatformId & VER_PLATFORM_WIN32_WINDOWS);
}

DWORD CComputerInfo::GetOSBuildNumber() const
{
    // Build number is the low word of dwBuildNumber
    return (OSInfo.dwBuildNumber & 0xFFFF);
}

WORD CComputerInfo::GetProcessorArchitecture() const
{
    return ProcessorArchitecture;
}

DWORD CComputerInfo::GetSpoolerVersion() const
{
    DWORD BuildNumber = GetOSBuildNumber();
    DWORD SpoolerVersion;

    // Windows NT 4.0 (and beyond)
    if (BuildNumber > 1057)
    {
        SpoolerVersion = 2;
    }
    // Windows NT 3.5 and 3.51
    else if (BuildNumber > 511)
    {
        SpoolerVersion = 1;
    }
    // Windows NT 3.1
    else
    {
        SpoolerVersion = 0;
    }

    return SpoolerVersion;
}

BOOL CComputerInfo::GetInfo()
{
    // NOTE: OSInfo.dwOSVersionInfoSize must be non-zero after the info is retrieved.
    DWORD ErrorCode = ERROR_SUCCESS;
    LPTSTR pCPUName = NULL;
    LPTSTR pBuildNumberText = NULL;
    LPTSTR pVersionText = NULL;
    LPTSTR pCSDVersionText = NULL;
    LPTSTR pOSTypeText = NULL;

    // set size of version info structure
    OSInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if( ComputerName.bEmpty() )
    {
        SYSTEM_INFO SystemInfo;

        // get operating system info
        if (!GetVersionEx(&OSInfo))
        {
            ErrorCode = GetLastError();
            goto CleanUp;
        }

        // get hardware info
        GetSystemInfo(&SystemInfo);
        ProcessorArchitecture = SystemInfo.wProcessorArchitecture;
        ProcessorCount = SystemInfo.dwNumberOfProcessors;
    }
    else
    {
        REGISTRY_KEY_INFO RegistryKeyInfo;

        // determine operating system
        // if this key is found, then the OS is Windows NT
        // if this key cannot be found, then the OS is Windows 95
        // otherwise, it is an error
        pBuildNumberText = AllocateRegistryString(ComputerName, HKEY_LOCAL_MACHINE,
            TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"),
            TEXT("CurrentBuildNumber"));
        if (GetLastError() == ERROR_CANTOPEN)
        {
            // operating system is Windows 95
            OSInfo.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS;

            // get OS version
            pVersionText = AllocateRegistryString(ComputerName, HKEY_LOCAL_MACHINE,
                TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"),
                TEXT("Version"));
            if (GetLastError() != ERROR_SUCCESS)
            {
                ErrorCode = GetLastError();
                goto CleanUp;
            }

            // parse OS version
            OSInfo.dwMajorVersion = 0;
            OSInfo.dwMinorVersion = 0;
            OSInfo.dwBuildNumber  = 0;

            //
            // The version string is of the form "X.X" The following
            // code is used to isolate the major and minor verison
            // to place in dwords respectivly.
            //
            LPTSTR p;
            OSInfo.dwMajorVersion = _tcstoul( pVersionText, &p, 10);

            //
            // We know the conversion will stop at the '.' if it did
            // skip past the '.' and do the minor version conversion.
            //
            if( *p == TEXT('.') )
            {
                p++;
                OSInfo.dwMinorVersion = _tcstoul(p, &p, 10);
            }

            //
            // We know the conversion will stop at the '.' if it did
            // skip past the '.' and do the build number conversion.
            //
            if( *p == TEXT('.') )
            {
                p++;
                OSInfo.dwBuildNumber = _tcstoul(p, NULL, 10);
            }

            // get CSD version
            OSInfo.szCSDVersion[0] = TEXT('\0');

            // processor must be Intel
            ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;

            // processor count must be 1
            ProcessorCount = 1;
        }
        else if (GetLastError() == ERROR_SUCCESS)
        {
            // operating system is Windows NT
            OSInfo.dwPlatformId = VER_PLATFORM_WIN32_NT;

            // parse build number (which was just retrieved)
            OSInfo.dwBuildNumber = _tcstoul(pBuildNumberText, NULL, 10);

            // get OS version
            pVersionText = AllocateRegistryString(ComputerName, HKEY_LOCAL_MACHINE,
                TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"),
                TEXT("CurrentVersion"));
            if (GetLastError() != ERROR_SUCCESS)
            {
                ErrorCode = GetLastError();
                goto CleanUp;
            }

            //
            // parse OS version
            //
            OSInfo.dwMajorVersion = 0;
            OSInfo.dwMinorVersion = 0;

            //
            // The version string is of the form "X.X" The following
            // code is used to isolate the major and minor verison
            // to place in dwords respectivly.
            //
            LPTSTR p;
            OSInfo.dwMajorVersion = _tcstoul( pVersionText, &p, 10);

            //
            // We know the conversion will stop at the '.' if it did
            // skip past the '.' and do the minor version conversion.
            //
            if( *p == TEXT('.') )
            {
                p++;
                OSInfo.dwMinorVersion = _tcstoul(p, NULL, 10);
            }

            // get CSD version
            OSInfo.szCSDVersion[0] = TEXT('\0');
            pCSDVersionText = AllocateRegistryString(ComputerName, HKEY_LOCAL_MACHINE,
                TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"),
                TEXT("CSDVersion"));
            if (GetLastError() == ERROR_SUCCESS)
            {
                _tcsncpy(OSInfo.szCSDVersion, pCSDVersionText, 127);
            }

            // get name of cpu
            pCPUName = AllocateRegistryString(ComputerName, HKEY_LOCAL_MACHINE,
                TEXT("HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0"),
                TEXT("Identifier"));
            if (GetLastError() != ERROR_SUCCESS)
            {
                ErrorCode = GetLastError();
                goto CleanUp;
            }

            // determine processor architecture from cpu name
            if (!_tcsnicmp(pCPUName, TEXT("80386-"), 6)
                || !_tcsnicmp(pCPUName, TEXT("80486-"), 6)
                || !_tcsnicmp(pCPUName, TEXT("x86 "), 4))
            {
                ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
            }
            else if (!_tcsnicmp(pCPUName, TEXT("MIPS-"), 5)
                || !_tcsnicmp(pCPUName, TEXT("Tyne"), 4))
            {
                ProcessorArchitecture = PROCESSOR_ARCHITECTURE_MIPS;
            }
            else if (!_tcsnicmp(pCPUName, TEXT("DEC-"), 4))
            {
                ProcessorArchitecture = PROCESSOR_ARCHITECTURE_ALPHA;
            }
            else if(!_tcsnicmp(pCPUName, TEXT("PowerPC"), 7))
            {
                ProcessorArchitecture = PROCESSOR_ARCHITECTURE_PPC;
            }
            else if(!_tcsnicmp(pCPUName, TEXT("IA64"), 4))
            {
                ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
            }
            else
            {
                SPLASSERT(FALSE);
                ProcessorArchitecture = 0;
            }

            // get processor count
            // On Windows NT, this can be determined by the number of subkeys of the following
            // registry key.
            if (!GetRegistryKeyInfo(ComputerName, HKEY_LOCAL_MACHINE,
                TEXT("HARDWARE\\DESCRIPTION\\System\\CentralProcessor"),
                &RegistryKeyInfo))
            {
                ErrorCode = GetLastError();
                goto CleanUp;
            }
            ProcessorCount = RegistryKeyInfo.NumSubKeys;
        }
        else
        {
            ErrorCode = GetLastError();
            goto CleanUp;
        }
    }

    // determine whether OS is retail or debug
    OSIsDebugVersion = FALSE;
    if (OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        // get OS type
        pOSTypeText = AllocateRegistryString(ComputerName,
            HKEY_LOCAL_MACHINE,
            TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"),
            TEXT("CurrentType"));
        if (GetLastError() != ERROR_SUCCESS)
        {
            ErrorCode = GetLastError();
            goto CleanUp;
        }

        // if the type text contains the word "Checked",
        // then it is a debug build
        OSIsDebugVersion = (_tcsstr(pOSTypeText, TEXT("Checked")) != NULL);
    }

CleanUp:

    if (pCPUName)
    {
        GlobalFree(pCPUName);
    }

    if (pBuildNumberText)
    {
        GlobalFree(pBuildNumberText);
    }

    if (pVersionText)
    {
        GlobalFree(pVersionText);
    }

    if (pCSDVersionText)
    {
        GlobalFree(pCSDVersionText);
    }

    if (pOSTypeText)
    {
        GlobalFree(pOSTypeText);
    }

    if (ErrorCode)
    {
        SetLastError(ErrorCode);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

BOOL
CComputerInfo::
GetProductInfo(
    VOID
    )
{
    //
    // If the request is for the local machine, do not access the net.
    //
    if( ComputerName.bEmpty() )
    {
        ProductOption = GetLocalProductInfo();
    }
    else
    {
        ProductOption = GetRemoteProductInfo();
    }

    DBGMSG( DBG_TRACE, ("CComputerInfo::GetPoductInfo %d\n", ProductOption ) );

    return ProductOption != kNtUnknown;
}

BOOL
CComputerInfo::
IsRunningNtServer(
    VOID
    ) const
{
    return ProductOption == kNtServer;
}

BOOL
CComputerInfo::
IsRunningNtWorkstation(
    VOID
    ) const
{
    return ProductOption == kNtWorkstation;
}

CComputerInfo::ProductType
CComputerInfo::
GetLocalProductInfo(
    VOID
    )
{
    TStatusB bStatus;
    TString strProduct;
    ProductType Option = kNtUnknown;

    TPersist Product( c_szProductOptionsPath, TPersist::kOpen|TPersist::kRead, HKEY_LOCAL_MACHINE );

    bStatus DBGCHK = VALID_OBJ( Product );

    if( bStatus )
    {
        bStatus DBGCHK = Product.bRead( c_szProductOptions, strProduct );

        if( bStatus )
        {
            if( !_tcsicmp( c_szWorkstation, strProduct ) )
            {
                Option = kNtWorkstation;
            }
            else if( !_tcsicmp( c_szServer1, strProduct ) || !_tcsicmp( c_szServer2, strProduct ) )
            {
                Option = kNtServer;
            }
            else
            {
                Option = kNtUnknown;
            }
        }
    }
    return Option;
}

CComputerInfo::ProductType
CComputerInfo::
GetRemoteProductInfo(
    VOID
    )
{
    ProductType Option = kNtUnknown;

    TLibrary Lib( c_szNetApi32Dll );

    if( VALID_OBJ( Lib ) )
    {
        typedef NET_API_STATUS (*pf_NetServerGetInfo)(LPCTSTR servername,DWORD level,LPBYTE *bufptr);
        typedef NET_API_STATUS (*pf_NetApiBufferFree)(LPVOID Buffer);

        pf_NetServerGetInfo pfNetServerGetInfo = (pf_NetServerGetInfo)Lib.pfnGetProc( c_szNetServerGetInfo );
        pf_NetApiBufferFree pfNetApiBufferFree = (pf_NetApiBufferFree)Lib.pfnGetProc( c_szNetApiBufferFree );
        PSERVER_INFO_101    si101              = NULL;

        if( pfNetServerGetInfo && pfNetApiBufferFree )
        {
            //
            // Get the server info
            //
            if( pfNetServerGetInfo( ComputerName, 101, (LPBYTE *)&si101 ) == NERR_Success )
            {
                DBGMSG( DBG_TRACE, ("Server_Info_101.sv101_type %x\n", si101->sv101_type ) );

                DWORD dwType = si101->sv101_type;

                //
                // If the server type is NT and a server.
                //
                if( dwType & ( SV_TYPE_SERVER_NT | SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL ) )
                {
                    Option = kNtServer;
                }
                //
                // If the server type is NT and a workstation.
                //
                else if( (dwType & ( SV_TYPE_NT | SV_TYPE_WORKSTATION )) == ( SV_TYPE_NT | SV_TYPE_WORKSTATION ) )
                {
                    Option = kNtWorkstation;
                }
                else
                {
                    Option = kNtUnknown;
                }

                //
                // Release the server info structure.
                //
                pfNetApiBufferFree( si101 );
            }

        }
    }
    return Option;
}

////////////////////////////////////////////////////////////////////////////////
//
// AllocateRegistryString returns a copy of the string value stored at the
// specified registry key.  The registry can be on either a remote machine or
// the local machine.
//
// Parameter     Description
// -----------------------------------------------------------------------------
// pServerName   Name of server on which registry resides.
// hRegistryRoot Registry root (i.e. HKEY_LOCAL_MACHINE).  See RegConnectRegistry
//               for acceptable values.
// pKeyName      Name of registry key.
// pValueName    Name of registry value.  The value must be of type REG_SZ.
//
// Returns:
//   If successful, the function returns a pointer to a copy of the string.
// If the function fails, GetLastError() will return an error code other than
// ERROR_SUCCESS, and NULL is returned from the function.

// Revision History:
//   10/17/95 <adamk> created.
//
LPTSTR
CComputerInfo::
AllocateRegistryString(
    LPCTSTR     pServerName,
    HKEY        hRegistryRoot,
    LPCTSTR     pKeyName,
    LPCTSTR     pValueName
    )
{
    DWORD ErrorCode  = 0;
    HKEY hRegistry = 0;
    HKEY hRegistryKey = 0;
    DWORD RegistryValueType;
    DWORD RegistryValueSize;
    LPTSTR pString = NULL;

    // connect to the registry of the specified machine
    if (ErrorCode = RegConnectRegistry((LPTSTR) pServerName, hRegistryRoot, &hRegistry))
    {
        goto CleanUp;
    }

    // open the registry key
    if (ErrorCode = RegOpenKeyEx(hRegistry, pKeyName, 0, KEY_QUERY_VALUE, &hRegistryKey))
    {
        goto CleanUp;
    }

    // query the value's type and size
    if(ErrorCode = RegQueryValueEx(hRegistryKey, pValueName, NULL, &RegistryValueType, NULL,
        &RegistryValueSize))
    {
        goto CleanUp;
    }

    // make sure the value is a string
    if (RegistryValueType != REG_SZ)
    {
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }

    if (!(pString = (LPTSTR) GlobalAlloc(GMEM_FIXED, RegistryValueSize)))
    {
        ErrorCode = GetLastError();
        goto CleanUp;
    }

    if (ErrorCode = RegQueryValueEx(hRegistryKey, pValueName, NULL, &RegistryValueType,
        (LPBYTE) pString, &RegistryValueSize))
    {
        ErrorCode = GetLastError();
        goto CleanUp;
    }

CleanUp:

    if (hRegistryKey)
    {
        RegCloseKey(hRegistryKey);
    }

    if (hRegistry)
    {
        RegCloseKey(hRegistry);
    }

    if (ErrorCode && pString)
    {
        GlobalFree(pString);
        pString = NULL;
    }

    SetLastError (ErrorCode);
    return pString;
}


////////////////////////////////////////////////////////////////////////////////
//
// GetRegistrySubKeyCount returns the number of subkeys that the specified
// registry key contains.  The registry can be on either a remote machine or
// the local machine.
//
// Parameter     Description
// -----------------------------------------------------------------------------
// pServerName   Name of server on which registry resides.
// hRegistryRoot Registry root (i.e. HKEY_LOCAL_MACHINE).  See RegConnectRegistry
//               for acceptable values.
// pKeyName      Name of registry key.
//
// Returns:
//   If successful, the function returns the number of subkeys and GetLastError()
// will return ERROR_SUCCESS.  Otherwise, GetLastError() return the error code
// indicating the reason for the failure.

// Revision History:
//   10/23/95 <adamk> created.
//
BOOL
CComputerInfo::
GetRegistryKeyInfo(
    LPCTSTR             pServerName,
    HKEY                hRegistryRoot,
    LPCTSTR             pKeyName,
    REGISTRY_KEY_INFO *pKeyInfo
    )
{
    DWORD ErrorCode = 0;
    HKEY hRegistry = 0;
    HKEY hRegistryKey = 0;

    // connect to the registry of the specified machine
    if (ErrorCode = RegConnectRegistry((LPTSTR) pServerName, hRegistryRoot, &hRegistry))
    {
        goto CleanUp;
    }

    // open the registry key
    if (ErrorCode = RegOpenKeyEx(hRegistry, pKeyName, 0, KEY_QUERY_VALUE, &hRegistryKey))
    {
        goto CleanUp;
    }

    // get the key info
    if (ErrorCode = RegQueryInfoKey(hRegistryKey, NULL, 0, 0, &pKeyInfo->NumSubKeys,
        &pKeyInfo->MaxSubKeyLength, &pKeyInfo->MaxClassLength, &pKeyInfo->NumValues,
        &pKeyInfo->MaxValueNameLength, &pKeyInfo->MaxValueDataLength,
        &pKeyInfo->SecurityDescriptorLength, &pKeyInfo->LastWriteTime))
    {
        goto CleanUp;
    }

CleanUp:

    if (hRegistryKey)
    {
        RegCloseKey(hRegistryKey);
    }

    if (hRegistry)
    {
        RegCloseKey(hRegistry);
    }

    if (ErrorCode)
    {
        SetLastError(ErrorCode);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\data.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1998
All rights reserved.

Module Name:

    data.cxx

Abstract:

    Holds VData functions.

    Currently hold static pNew function that determines which concrete
    VData class should be instantiated (determined at runtime).

    Also holds MNotifyWork virtual definition.

Author:

    Albert Ting (AlbertT)  12-Jun-1995

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop


STATEVAR
VData::
svNew(
    MDataClient* pDataClient,
    STATEVAR StateVar,
    VData*& pData
    )

/*++

Routine Description:

    The VData tree uses the abstract class factory idiom.  Clients
    create a class derived from MDataClient which support pNewNotify
    and pNewRefresh.  Both these virtual fuctions create derived objects
    that are stored as base pointers in this class.

    This specific creation of derived VData classes without polluting
    VData or it's internals with switch statements or flags to determine
    which concrete class should be used.

    Create the data object.  This will first create a TDataNotify;
    if that fails because it's a downlevel server, it will create
    a TDataRefresh.

Arguments:

    StateVar - Current state of printer.

    pDataClient - Interface to data client.

Return Value:

    VData* on success, NULL on failure.

    StateVar - State of printer, either:

        kExecReopen | kExecDelay if everything failed or,
        0 if everything succeded (refresh already done).

--*/

{
    STATEVAR StateVarOrg = StateVar;

    //
    // First attempt an uplevel connection by instantiating a
    // TDataNotify.  If that fails, then use downlevel.
    //
    pData = pDataClient->pNewNotify( pDataClient );

    //
    // If the object failed to initialize, reopen the printer.
    // We don't want to try the downlevel case, since we may have
    // failed due to lack of memory.
    //
    if( !VALID_PTR( pData )){

        //
        // Error, delay and put error message up.
        //
        goto Fail;
    }

    //
    // Attempt a refresh if the refresh is successful, then we are
    // talking to an uplevel server.
    //
    StateVar = pData->svNotifyStart( StateVar );

    //
    // If it's an access denied, then we can't open the printer.
    // (The open may succeed because of the spooler's caching.)
    //
    if( StateVar & TPrinter::kExecDelay &&
        GetLastError() == ERROR_ACCESS_DENIED ){

        return StateVar;
    }

    //
    // If a Reopen was not requested, continue trying to use it.
    //
    if( !( StateVar & TPrinter::kExecReopen )){

        StateVar = pData->svRefresh( StateVar );

        //
        // If a Reopen was not requested, then we succeeded and we can
        // use the newly created pData.
        //
        if( !( StateVar & TPrinter::kExecReopen )){
            return StateVar;
        }
    }

    //
    // The uplevel case failed; now assume it is downlevel and
    // create a TDataRefresh.
    //

    StateVar = StateVarOrg;

    //
    // Close notification and delete the notification.
    //
    pData->svNotifyEnd( StateVar );

    delete pData;

    pData = pDataClient->pNewRefresh( pDataClient );

    if( !VALID_PTR( pData )){
        goto Fail;
    }

    return pData->svNotifyStart( StateVar );

Fail:

    delete pData;
    pData = NULL;

    return StateVar | TPrinter::kExecReopen | TPrinter::kExecDelay;
}

VOID
VData::
vDelete(
    VOID
    )

/*++

Routine Description:

    Delete the pData.  We create a separate utility function to mirror
    svNew.

Arguments:

Return Value:

--*/

{
    SPLASSERT( !m_shNotify );

    delete this;
}

/********************************************************************

    VData ctr, dtr.

********************************************************************/

VData::
VData(
    MDataClient* pDataClient,
    PFIELD_TABLE pFieldTable
    ) : _pDataClient( pDataClient ),
        _pFieldTable( pFieldTable )
{
    SPLASSERT( _pFieldTable );
    SPLASSERT( _pDataClient );

    UIGuard._cItems = 0;

    TStatusB bStatus;
    bStatus DBGCHK = pDataClient->bGetPrintLib(_pPrintLib);

    if( !bStatus ){
        DBGMSG( DBG_WARN, ( "VData::ctor bGetSingleton::ctor Failed %d\n", GetLastError( )));
    }
}

VData::
~VData(
    VOID
    )

/*++

Routine Description:

    Destroy the VData object.

Arguments:

Return Value:

--*/

{
    //
    // Remove all items from the UI now that we are about to delete
    // pData.  We have shut down the notifications and cleared the
    // UI windows message queue, so this is safe.
    //
    _pDataClient->vContainerChanged( kContainerClearItems, kInfoNull );
}

BOOL
VData::
bValid(
    VOID
    ) const
{
    //
    // Valid _pPrintLib pointer is our valid check.
    //
    return _pPrintLib.pGet() != NULL;
}

/********************************************************************

    Add and retrieve hBlocks.

********************************************************************/

VData::
TBlock::
TBlock(
    IN DWORD dwParam1,
    IN DWORD dwParam2,
    IN HANDLE hBlock
    ) : _dwParam1( dwParam1 ), _dwParam2( dwParam2 ), _hBlock( hBlock )
{
}

VData::
TBlock::
~TBlock(
    VOID
    )
{
}

VOID
VData::
vBlockAdd(
    IN DWORD dwParam1,
    IN DWORD dwParam2,
    IN HANDLE hBlock ADOPT
    )

/*++

Routine Description:

    Add block to linked list.

Arguments:

    dwParam1 - dwParam to add.

    dwParam2 - dwParam to add.

    hBlock - hBlock to add.

Return Value:

--*/

{
    TBlock* pBlock = new TBlock( dwParam1, dwParam2, hBlock );

    if( !VALID_PTR( pBlock )){

        delete pBlock;

        INFO Info;
        Info.dwData = TPrinter::kExecRefresh;

        //
        // Request a refresh with a delay, then delete the adopted hBlock.
        //
        _pDataClient->vContainerChanged( kContainerStateVar, Info );
        vBlockDelete( hBlock );

        return;
    }

    {
        CCSLock::Locker CSL( csData( ));
        Block_vAppend( pBlock );
    }

    //
    // Notify UI thread that there is more data.
    //
    _pDataClient->vContainerChanged( kContainerNewBlock, kInfoNull );
}

VOID
VData::
vBlockProcess(
    VOID
    )

/*++

Routine Description:

    Retrieve a block from our linked list.  Only called from UI thread,
    or within a protective critical section.

Arguments:

Return Value:

--*/

{
    TBlock* pBlock;

    for( ; ; ){

        {
            CCSLock::Locker CSL( csData( ));

            pBlock = Block_pHead();

            if( pBlock ){
                Block_vDelink( pBlock );
            }
        }

        if( !pBlock ){
            break;
        }

        vBlockProcessImp( pBlock->_dwParam1,
                          pBlock->_dwParam2,
                          pBlock->_hBlock );
        delete pBlock;
    }
}


/********************************************************************

    MNotifyWork virtual functions.

********************************************************************/

HANDLE
VData::
hEvent(
    VOID
    ) const

/*++

Routine Description:

    Virtual function to return the hNotify object back to MNotifyWork.

Arguments:

Return Value:

--*/

{
    return m_shNotify;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\ctl.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1996
All rights reserved.

Module Name:

    ctl.cxx

Abstract:

    Dialog control code.

Author:

    Albert Ting (AlbertT)  26-Aug-1995

Revision History:

    Lazar Ivanov (LazarI)  Oct-2000 - added vEnableControls

--*/

#include "precomp.hxx"
#pragma hdrstop

BOOL
bSetEditText(
    HWND hDlg,
    UINT uControl,
    LPCTSTR pszString
    )
{
    SPLASSERT( hDlg );
    SPLASSERT( uControl );

    SendDlgItemMessage( hDlg,
                        uControl,
                        WM_SETTEXT,
                        0,
                        (LPARAM)(pszString ?
                                    pszString :
                                    gszNULL ));

    return TRUE;
}

/*++

Routine Name:

    bSetEditTextFormat

Routine Description:
    
    Sets the text of an edit control using a printf style format 
    string.  Note the format string and any following string 
    arguments must be TCHARS.
    
Arguments:
    hDlg        - handle to dialog which contains the edit control
    uControl    - edit control ID
    pszString   - pointer to printf style format string.
    Arguments   - variable number of arguments matching the format string


Return Value:

    TRUE if format string was created and updated to control,
    FALSE if error occured allocating format buffer or setting
    control value.

--*/
BOOL
bSetEditTextFormat(
    HWND hDlg,
    UINT uControl,
    LPCTSTR pszString,
    ...
    )
{

    SPLASSERT( hDlg );
    SPLASSERT( uControl );

    LPTSTR pszBuffer = new TCHAR [kMaxEditText];

    if( !pszBuffer )
        return FALSE;

    va_list pArgs;

    va_start( pArgs, pszString );

    wvsprintf( pszBuffer, pszString, pArgs );

    bSetEditText( hDlg, uControl, pszBuffer );

    delete [] pszBuffer;

    va_end( pArgs );

    return TRUE;
}

BOOL
bGetEditText(
    IN     HWND hDlg,
    IN     UINT uControl,
       OUT TString& strDest
    )

/*++

Routine Description:

    Retrieves the edit text from a control.  If the edit control is
    empty, the string holds szNULL.

Arguments:

    hDlg - Dlg that owns the control.

    uControl - Control ID.

    strDest - TString to receive string.

Return Value:

    TRUE = success, FALSE = fail.

--*/

{
    TCHAR szString[kStrMax*2];
    szString[0] = 0;

    SendDlgItemMessage( hDlg,
                        uControl,
                        WM_GETTEXT,
                        COUNTOF( szString ),
                        (LPARAM)szString );

    return strDest.bUpdate( szString );
}

VOID
vEnableCtl(
    HWND hDlg,
    UINT uControl,
    BOOL bEnable
    )
{
    EnableWindow( GetDlgItem( hDlg, uControl ), bEnable );
}

VOID
vSetCheck(
    HWND hDlg,
    UINT uControl,
    BOOL bSet
    )

/*++

Routine Description:

    Sets a checkbox control on or off.

Arguments:

    hDlg - Owning dialog control.

    uControl - Checkbox to modify.

    bSet - 0 indicates uncheck, non-zero indicates check.  (Note this
        is not a strict BOOL, _any_ non-zero value is TRUE.)

Return Value:

    None

--*/

{
    CheckDlgButton( hDlg,
                    uControl,
                    bSet ? BST_CHECKED : BST_UNCHECKED );
}

BOOL
bGetCheck(
    IN HWND hDlg,
    IN UINT uControl
    )
{
    return IsDlgButtonChecked( hDlg, uControl );
}


VOID
vEnableControls(
    IN HWND hDlg,
    IN BOOL bEnable,
    IN UINT arrIDs[],
    IN UINT uCount
    )
{
    HWND hwnd = NULL;
    for( UINT u = 0; u < uCount; u++ )
    {
        hwnd = GetDlgItem(hDlg, arrIDs[u]);
        if( hwnd )
        {
            EnableWindow(hwnd, bEnable);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\datan.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    datan.cxx

Abstract:

    vDataNotify class, handles communication with uplevel (3.51+)
    clients.  Data is returned with each notification, so it
    is unnecessary to call refresh.

Author:

    Albert Ting (AlbertT)  07-11-95

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#if DBG
//#define DBG_DATANINFO                  DBG_INFO
#define DBG_DATANINFO                    DBG_NONE
#endif

#define DEFINE( field, attrib, table, y, z )\
    table,

TABLE aTableJob[] = {
#include "ntfyjob.h"
    0 };

TABLE aTablePrinter[] = {
#include "ntfyprn.h"
    0 };

#undef DEFINE

TABLE* aaTable[2] = {
    aTablePrinter,
    aTableJob
};

/********************************************************************

    Hard code the notification structure for uplevel clients.
    Later this can be changed for dynamic creation in case the
    user wants to change the columns.

********************************************************************/


/********************************************************************

    Jobs.

********************************************************************/

//
// Index -> Field translation.  Used by TData*, and also
// in the PRINTER_NOTIFY_OPTIONS_TYPE structure for FFPCN.
//
FIELD_TABLE
TDataNJob::gFieldTable = {
    TDataNJob::kFieldTableSize,
    TDataNJob::gaFields
};

FIELD
TDataNJob::gaFields[TDataNJob::kFieldTableSize+1] = {
    JOB_COLUMN_FIELDS,
    JOB_INDEX_EXTRA_FIELDS,
    kInvalidFieldValue
};


FIELD
TDataNJob::gaFieldOther[TDataNJob::kFieldOtherSize] = {
    PRINTER_NOTIFY_FIELD_STATUS,
    PRINTER_NOTIFY_FIELD_SERVER_NAME,
    PRINTER_NOTIFY_FIELD_PRINTER_NAME,
    PRINTER_NOTIFY_FIELD_ATTRIBUTES
};

PRINTER_NOTIFY_OPTIONS_TYPE
TDataNJob::gaNotifyOptionsType[TDataNJob::kTypeSize] = {
    {
        JOB_NOTIFY_TYPE,
        0,
        0,
        0,
        TDataNJob::kFieldTableSize,
        TDataNJob::gaFields
    },
    {
        PRINTER_NOTIFY_TYPE,
        0,
        0,
        0,
        COUNTOF( TDataNJob::gaFieldOther ),
        TDataNJob::gaFieldOther
    }
};

PRINTER_NOTIFY_OPTIONS
TDataNJob::gNotifyOptions = {
    2,
    0,
    COUNTOF( TDataNJob::gaNotifyOptionsType ),
    TDataNJob::gaNotifyOptionsType
};

/********************************************************************

    Printers.

********************************************************************/

//
// Index -> Field translation.  Used by TData*, and also
// in the PRINTER_NOTIFY_OPTIONS_TYPE structure for FFPCN.
//
FIELD_TABLE
TDataNPrinter::gFieldTable = {
    TDataNPrinter::kFieldTableSize,
    TDataNPrinter::gaFields
};

FIELD
TDataNPrinter::gaFields[TDataNPrinter::kFieldTableSize+1] = {
    PRINTER_COLUMN_FIELDS,
    PRINTER_INDEX_EXTRA_FIELDS,
    kInvalidFieldValue
};

PRINTER_NOTIFY_OPTIONS_TYPE
TDataNPrinter::gaNotifyOptionsType[TDataNPrinter::kTypeSize] = {
    {
        PRINTER_NOTIFY_TYPE,
        0,
        0,
        0,
        TDataNPrinter::kFieldTableSize,
        TDataNPrinter::gaFields
    }
};

PRINTER_NOTIFY_OPTIONS
TDataNPrinter::gNotifyOptions = {
    2,
    0,
    COUNTOF( TDataNPrinter::gaNotifyOptionsType ),
    TDataNPrinter::gaNotifyOptionsType
};

/********************************************************************

    VDataNotify

    Used in uplevel (NT 3.51+) connections

********************************************************************/

VDataNotify::
VDataNotify(
    IN MDataClient* pDataClient,
    IN PFIELD_TABLE pFieldTable,
    IN DWORD TypeItem
    ) : VData( pDataClient, pFieldTable ), _TypeItem( TypeItem )

/*++

Routine Description:

    Create the DataNotify Object.

Arguments:

Return Value:

--*/

{
}

VDataNotify::
~VDataNotify(
    VOID
    )

/*++

Routine Description:

    Delete the DataNotifyObject.

Arguments:

Return Value:

--*/

{
    vDeleteAllItemData();
    SPLASSERT( !m_shNotify );
}

/********************************************************************


********************************************************************/

VOID
VDataNotify::
vProcessNotifyWork(
    IN TNotify* pNotify
    )

/*++

Routine Description:

    Our event was signaled, so we need to pickup any notifications.

    This must execute quickly, since it runs in the notification
    thread.

Arguments:

    pNotify - Notification manager object.

Return Value:

--*/

{
    UNREFERENCED_PARAMETER( pNotify );

    DWORD dwChange;
    PPRINTER_NOTIFY_INFO pInfo = NULL;

    //
    // Notification caught.  We must signal that caught it before
    // issuing the Notify, since there may be notifications between
    // the Notify and the FNPCN, which would be lost.
    //
    BOOL bSuccess = FindNextPrinterChangeNotification( m_shNotify,
                                                       &dwChange,
                                                       0,
                                                       (PVOID*)&pInfo );

    if( !bSuccess || dwChange & PRINTER_CHANGE_FAILED_CONNECTION_PRINTER ){

        DBGMSG( DBG_WARN,
                ( "DataNotify.vProcessNotifyWork: %x FNPCN %x dwChange %d failed: %d\n",
                  this,
                  static_cast<HANDLE>(m_shNotify),
                  dwChange,
                  GetLastError( )));
    }

    //
    // Check for a discard.
    //
    if( !pInfo || (pInfo->Flags & PRINTER_NOTIFY_INFO_DISCARDED )){

        DBGMSG( DBG_NOTIFY,
                ( "DataNotify.vProcessNotifyWork: %x discard %x pInfo %x %x\n",
                  this,
                  static_cast<HANDLE>(m_shNotify),
                  pInfo,
                  pInfo ?
                      pInfo->Flags :
                      0 ));

        INFO Info;
        Info.dwData = TPrinter::kExecRefresh;

        _pDataClient->vContainerChanged( kContainerStateVar, Info );

    } else {

#if DBG
        vDbgOutputInfo( pInfo );
#endif

        //
        // Post the work to the message thread.  If pInfo is NULL, then
        // a reopen will be requested.
        //
        vBlockAdd( kProcessIncremental, dwChange, (HBLOCK)pInfo );

        //
        // vBlockAdd has adopted pInfo; set it to NULL
        // so we don't free it.
        //
        pInfo = NULL;
    }

    //
    // Since we adopted pInfo, free it now if we haven't passed it to
    // some other function.
    //
    if( pInfo ){
        FreePrinterNotifyInfo( pInfo );
    }
}

/********************************************************************

    Data interface for Notify.

********************************************************************/

HITEM
VDataNotify::
GetItem(
    IN NATURAL_INDEX NaturalIndex
    ) const

/*++

Routine Description:

    Retrieve a handle to the item based on the NaturalIndex.

    The data is stored as a linked list, so walk the list
    and return a pointer to TItemData*.

Arguments:

    NaturalIndex - Index of printing order for index to retrieve.

Return Value:

    HITEM, of NULL if ItemData not found.

--*/

{
    SPLASSERT( NaturalIndex < VData::UIGuard._cItems );

    TIter Iter;

    for( UIGuard.ItemData_vIterInit( Iter ), Iter.vNext();
         Iter.bValid();
         Iter.vNext(), --NaturalIndex ){

        if( !NaturalIndex ){
            return (HITEM)UIGuard.ItemData_pConvert( Iter );
        }
    }

    DBGMSG( DBG_ERROR,
            ( "DataNotify.GetItem: NI %d not found %x\n", this ));

    return NULL;
}

HITEM
VDataNotify::
GetNextItem(
    IN HITEM hItem
    ) const

/*++

Routine Description:

    Gets the next item based on the one passed in.

    There is no runtime checking to ensure that client doesn't walk
    off the end of the list.

Arguments:

    hItem - Handle to item immediately before the one returned.
        If NULL, returns first item.

Return Value:

    Next item after hItem.

--*/

{
    TItemData* pItemData = (TItemData*)hItem;

    //
    // NULL passed in, return first item.
    //
    if( !hItem ){
        SPLASSERT( VData::UIGuard._cItems > 0 );
        return UIGuard.ItemData_pHead();
    }

    //
    // Ensure we are not walking off the end of the list.
    //
    SPLASSERT( UIGuard.ItemData_bValid( pItemData->ItemData_pdlNext( )));

    return (HITEM)( pItemData->ItemData_pNext( ));
}

INFO
VDataNotify::
GetInfo(
    IN HITEM hItem,
    IN DATA_INDEX DataIndex
    ) const

/*++

Routine Description:

    Returns information about a item based on the index.

Arguments:

    hItem - Item to get information about.

    DataIndex - Index into pFieldTable->pFields, indicating type of
        information requested.

Return Value:

    INFO - Information about item.

--*/

{
    TItemData* pItemData = (TItemData*)hItem;

    //
    // We don't need to do a translation since they are stored in
    // index format anyway.
    //
    SPLASSERT( DataIndex < _pFieldTable->cFields );

    return pItemData->_aInfo[DataIndex];
}

IDENT
VDataNotify::
GetId(
    IN HANDLE hItem
    ) const

/*++

Routine Description:

    Retrieves JobId from hItem.

Arguments:

    hItem - Item to retrieve Id from.

Return Value:

    ID.

--*/

{
    TItemData* pItemData = (TItemData*)hItem;
    return pItemData->_Id;
}

NATURAL_INDEX
VDataNotify::
GetNaturalIndex(
    IN     IDENT Id,
       OUT HITEM* phItem OPTIONAL
    ) const

/*++

Routine Description:

    Retrieves NaturalIndex, and optionally hItem based on Id.

Arguments:

    Id - Job Id to search for.

    phItem - Optional, receives handle to Job matching Job Id.

Return Value:

    NATURAL_INDEX.

--*/

{
    //
    // Scan through linked list looking for the right ID.
    //
    TIter Iter;

    NATURAL_INDEX NaturalIndex;
    TItemData* pItemData;

    if( phItem ){
        *phItem = NULL;
    }

    for( NaturalIndex = 0, UIGuard.ItemData_vIterInit( Iter ), Iter.vNext();
         Iter.bValid();
         ++NaturalIndex, Iter.vNext( )){

        pItemData = UIGuard.ItemData_pConvert( Iter );

        if( Id == pItemData->Id( )){
            if( phItem ){
                *phItem = (PHITEM)pItemData;
            }
            return NaturalIndex;
        }
    }

    DBGMSG( DBG_DATANINFO,
            ( "DataNotify.GetNaturalIndex: ItemData id %x not found %x\n", Id, this ));

    return kInvalidNaturalIndexValue;
}



/********************************************************************

    VDataNotify::TItemData

********************************************************************/

VDataNotify::TItemData*
VDataNotify::TItemData::
pNew(
    IN VDataNotify* pDataNotify,
    IN IDENT Id
    )

/*++

Routine Description:

    Allocate a new TItemData* structure.  Note that this is not a first-
    class C++ object; it is a variable size structure.  Consequently,
    it must be allocated and freed using pNew and vDelete.

    Note: if the pData->pPrinter->pFieldsFromIndex changes, the
    TItemData* members must be deleted first, since we need to
    delete strings.

    We could implement deletion of data members using an
    abc, but this would require storing a vtbl with each field.
    A better way would be to implement singleton classes where the
    data is passed in explicitly.

Arguments:

    pDataNotify - Owning pDataNotify.  We need this to determine
        how bit the aInfo array should be.

    Id - Job Id.

Return Value:

    TItemData* or NULL on failure.

--*/

{
    UINT uSize = sizeof( TItemData ) +
                 ( pDataNotify->_pFieldTable->cFields - 1 ) * sizeof( INFO );
    TItemData* pItemData = (TItemData*)AllocMem( uSize );

    if( !pItemData ){
        return NULL;
    }

    ZeroMemory( pItemData, uSize );
    pItemData->_pDataNotify = pDataNotify;
    pItemData->_Id = Id;

    return pItemData;
}

VOID
VDataNotify::TItemData::
vDelete(
    VOID
    )

/*++

Routine Description:

    Delete the TItemData.  This routine must be called instead of using
    the delete operator.

Arguments:

Return Value:

--*/

{
    PFIELD pFields = _pDataNotify->_pFieldTable->pFields;
    COUNT cItemData = _pDataNotify->_pFieldTable->cFields;
    PINFO pInfo;
    UINT i;

    for( i= 0, pInfo = _aInfo;
         i < cItemData;
         ++i, ++pInfo, ++pFields ){

        if( aaTable[_pDataNotify->_TypeItem][*pFields] != TABLE_DWORD ){
            FreeMem( pInfo->pvData );
        }
    }

    FreeMem( this );
}




/********************************************************************

    Worker thread functions for Notify.

********************************************************************/

STATEVAR
VDataNotify::
svNotifyStart(
    IN STATEVAR StateVar
    )

/*++

Routine Description:

    Begin uplevel notifcations.

Arguments:

Return Value:

--*/

{
    TStatus Status;

    //
    // Get the notification handle.
    //
    m_shNotify = FindFirstPrinterChangeNotification(
                   _pDataClient->hPrinter(),
                   0,
                   0,
                   pNotifyOptions( ));

    if( !m_shNotify )
    {
        DBGMSG( DBG_WARN,
                ( "DataNotify.svNotifyStart: FFPCN failed %d\n",
                   GetLastError( )));
        goto Fail;
    }

    DBGMSG( DBG_NOTIFY,
            ( "DataNotify.svNotifyStart: %x FFPCN success returns 0x%x\n",
              _pDataClient->hPrinter(),
              static_cast<HANDLE>(m_shNotify) ));

    //
    // Successfully opened, request that it be registered and then
    // refresh.
    //
    return (StateVar & ~TPrinter::kExecNotifyStart) |
               TPrinter::kExecRegister | TPrinter::kExecRefresh;

Fail:

    //
    // Force a reopen.  Everything gets reset (handles closed, etc.) when
    // the reopen occurs.
    //
    return StateVar | TPrinter::kExecDelay | TPrinter::kExecReopen;
}

STATEVAR
VDataNotify::
svNotifyEnd(
    IN STATEVAR StateVar
    )

/*++

Routine Description:

    Stop downlevel notifications.

Arguments:

Return Value:

--*/

{
    DBGMSG( DBG_NOTIFY, ( "DataNotify.svNotifyEnd: handle %x\n", static_cast<HANDLE>(m_shNotify) ));
    //
    // Unregister from TNotify.
    //
    _pPrintLib->pNotify()->sUnregister( this );

    //
    // If we have a notification event, close it.
    //
    m_shNotify = NULL;

    return StateVar & ~TPrinter::kExecNotifyEnd;
}

STATEVAR
VDataNotify::
svRefresh(
    IN STATEVAR StateVar
    )

/*++

Routine Description:

    Refresh the printer data object.

Arguments:

Return Value:

--*/

{
    PRINTER_NOTIFY_OPTIONS Options;
    PPRINTER_NOTIFY_INFO pInfo;
    BOOL bReturn;
    DWORD dwChange;

    //
    // We must unregister ourselves to guarantee that there
    // are no synchronization problems:
    //
    // There are two threads: this one is requesting a refresh,
    // while the other one is waiting for notifications about a
    // printer.  When the notify thread gets a change, it puts
    // it on a linked list.
    //
    // If you are still registered, then there is a window where
    // you can get a notification, and put it on your linked list
    // before you call FNPCN to do the refresh.  When you call
    // FNPCN, the spooler will clear out any stale data in its
    // datastructure, but not our internal linked list.
    //
    // The fix is to remove ourselves from the notification list
    // (via sUnregister). handle the refresh, then add ourselves back
    // to the list (sRegister), thus preventing any stale data
    // from coming from the notification thread.
    //

    _pPrintLib->pNotify()->sUnregister( this );

    Options.Version = 2;
    Options.Flags = PRINTER_NOTIFY_OPTIONS_REFRESH;
    Options.Count = 0;
    Options.pTypes = NULL;

    bReturn = FindNextPrinterChangeNotification(
                  m_shNotify,
                  &dwChange,
                  &Options,
                  (PVOID*)&pInfo);

    if( !bReturn || !pInfo ){

        DBGMSG( DBG_WARN,
                ( "DataNotify.svRefresh Failed %d\n", GetLastError( )));

        return StateVar | TPrinter::kExecReopen | TPrinter::kExecDelay;
    }

    vBlockAdd( kProcessRefresh, 0, (HBLOCK)pInfo );

    TStatus Status;
    Status DBGCHK = _pPrintLib->pNotify()->sRegister( this );

    if( Status != ERROR_SUCCESS ){

        //
        // Failed to register; delay then reopen printer.  We could
        // just try and re-register later, but this should be a very
        // rare event, so do the least amount of work.
        //
        DBGMSG( DBG_WARN,
                ( "DataNotify.svRefresh: sRegister %x failed %d\n",
                  this, Status ));

        StateVar |= TPrinter::kExecDelay | TPrinter::kExecReopen;
    }

    return StateVar & ~TPrinter::kExecRefreshAll;
}

/********************************************************************

    UI Thread interaction routines.

********************************************************************/

VOID
VDataNotify::
vBlockProcessImp(
    IN DWORD dwParam1,
    IN DWORD dwParam2,
    IN HBLOCK hBlock ADOPT
    )

/*++

Routine Description:

    Take a job block and update the internal data structure.  This
    function will call back into _pDataClient to Notify the screen.

Arguments:

    dwParam1 - job count

    dwParam2 - Change flags.

    hBlock - PJOB_INFO_2 block

Return Value:

--*/

{
    UNREFERENCED_PARAMETER( dwParam2 );
    SPLASSERT( hBlock );

    BOOL bRestoreSelections = FALSE;

    //
    // If this is a complete refresh, then clear everything.
    //
    if( dwParam1 == kProcessRefresh ){

        //
        // Save the selections since we are refreshing jobs.
        //
        _pDataClient->vSaveSelections();
        bRestoreSelections = TRUE;

        //
        // Clear out all jobs.  Below in pInfo processing,
        // we will add them back in.
        //
        _pDataClient->vContainerChanged( kContainerReloadItems, kInfoNull );

        //
        // Delete our data structure.
        //
        vDeleteAllItemData();

        DBGMSG( DBG_DATANINFO,
                ( "DataNotify.vBlockProcessImp: DataN %x P:%x %x Refresh\n",
                  this, _pDataClient, hBlock ));
    }

    //
    // No need to grab any critical sections since we are in
    // the UI thread.
    //
    PPRINTER_NOTIFY_INFO_DATA pData;
    PPRINTER_NOTIFY_INFO pInfo = (PPRINTER_NOTIFY_INFO)hBlock;
    COUNT i;

    CACHE Cache;

    Cache.pItemData = NULL;
    Cache.Id = kInvalidIdentValue;
    Cache.NaturalIndex = kInvalidNaturalIndexValue;
    Cache.bNew = FALSE;

#if DBG
    vDbgOutputInfo( pInfo );
#endif

    for( pData = pInfo->aData, i = pInfo->Count; i; --i, ++pData ){

        //
        // Switch based on type.
        //
        if( pData->Type != _TypeItem ){

            //
            // Looks for changes in status, attributes, or name.
            //
            vContainerProcess( pData );

        } else {

            //
            // Process changes in jobs.  We cache the latest Id->
            // NaturalIndex mapping since they tend to come in clumps.
            //
            if( !bItemProcess( pData, Cache )){

                INFO Info;
                Info.dwData = TPrinter::kExecRefresh | TPrinter::kExecDelay;

                _pDataClient->vContainerChanged( kContainerStateVar, Info );
            }
        }
    }

    //
    // Notify the client that the refresh block has been processed.
    // When processing a refresh, the folder does not want to send
    // notification for each item.  Instead, it will refresh everything
    // once the refresh is complete.
    //
    if( dwParam1 == kProcessRefresh ){
        _pDataClient->vContainerChanged( kContainerRefreshComplete, kInfoNull );
    }

    FreePrinterNotifyInfo( (PPRINTER_NOTIFY_INFO)hBlock );
    if( bRestoreSelections ){
        _pDataClient->vRestoreSelections();
    }
}


VOID
VDataNotify::
vBlockDelete(
    IN OUT HBLOCK hBlock ADOPT
    )

/*++

Routine Description:

    Free a Block.  Called when the PostMessage fails and the
    job block needs to be destroyed.

Arguments:

    hBlock - Job block to delete.

Return Value:

--*/

{
    FreePrinterNotifyInfo( (PPRINTER_NOTIFY_INFO)hBlock );
}


VOID
VDataNotify::
vContainerProcess(
    IN const PPRINTER_NOTIFY_INFO_DATA pData
    )

/*++

Routine Description:

    Process printer specific change information.

Arguments:

    pData - Data about the printer change.

Return Value:

--*/

{
    INFO Info;
    CONTAINER_CHANGE ContainerChange = kContainerNull;

    //
    // Processes changes in printer.
    //
    switch( pData->Field ){
    case PRINTER_NOTIFY_FIELD_STATUS:

        ContainerChange = kContainerStatus;
        Info.dwData = pData->NotifyData.adwData[0];
        break;

    case PRINTER_NOTIFY_FIELD_ATTRIBUTES:

        ContainerChange = kContainerAttributes;
        Info.dwData = pData->NotifyData.adwData[0];
        break;

    case PRINTER_NOTIFY_FIELD_SERVER_NAME:

        ContainerChange = kContainerServerName;
        Info.pszData = (LPTSTR)pData->NotifyData.Data.pBuf;
        break;

    case PRINTER_NOTIFY_FIELD_PRINTER_NAME:

        ContainerChange = kContainerName;
        Info.pszData = (LPTSTR)pData->NotifyData.Data.pBuf;
        break;

    default:

        DBGMSG( DBG_ERROR,
                ( "DataNotify.vPrinterProcess: Unknown field %d\n",
                  pData->Field ));
        return;
    }

    _pDataClient->vContainerChanged( ContainerChange, Info );
}


BOOL
VDataNotify::
bItemProcess(
    IN const PPRINTER_NOTIFY_INFO_DATA pData,
    IN CACHE& Cache CHANGE
    )
{
    //
    // Process a single Item change.
    //

    TItemData* pItemData;
    NATURAL_INDEX NaturalIndex = kInvalidNaturalIndexValue;
    FIELD Field = pData->Field;

    //
    // Try and match Id with TItemData.
    //
    if( pData->Id != Cache.Id ){

        //
        // ItemData has not been cached.
        //
        NaturalIndex = GetNaturalIndex( pData->Id, (PHITEM)&pItemData );

        //
        // Now cache it.
        //
        Cache.Id           = pData->Id;
        Cache.NaturalIndex = NaturalIndex;
        Cache.pItemData    = pItemData;

    } else {

        //
        // Retrieve data from cache.
        //
        NaturalIndex = Cache.NaturalIndex;
        pItemData    = Cache.pItemData;

        SPLASSERT( pItemData );
    }

    //
    // Check if the ItemData is new and should be created.
    //
    if( !pItemData ){

        //
        // Create Item now, and append to end of linked list.
        //
        pItemData = pNewItemData( this, pData->Id );

        if( !pItemData ){
            Cache.Id = kInvalidIdentValue;
            return FALSE;
        }

        //
        // Update the cache.  The Item is always initally added
        // to the end of the list view, so NaturalIndex = current
        // Item count.
        //
        NaturalIndex =
        Cache.NaturalIndex = VData::UIGuard._cItems;

        Cache.pItemData = pItemData;
        Cache.bNew      = TRUE;
        ++VData::UIGuard._cItems;

        UIGuard.ItemData_vAppend( pItemData );

        SPLASSERT( pItemData == (TItemData*)GetItem( NaturalIndex ));
    }

    //
    // Match the pData->Field with our field column.
    //
    PFIELD pField;
    DATA_INDEX DataIndex;

    for( pField = _pFieldTable->pFields, DataIndex = 0;
         *pField != kInvalidFieldValue;
         ++pField, ++DataIndex ){

        if( Field == *pField ){

            //
            // Found field -- update it.  If the return value is TRUE,
            // then the item must be deleted.
            //
            if( bUpdateInfo( pData, DataIndex, Cache )){

                DBGMSG( DBG_TRACE,
                        ( "DataNotify.bItemProcess: delete %x Id %x NI %d cItems %d\n",
                          pItemData, Cache.Id, Cache.NaturalIndex,
                          VData::UIGuard._cItems - 1 ));

                pItemData->ItemData_vDelinkSelf();
                pItemData->vDelete();

                SPLASSERT( VData::UIGuard._cItems );
                --VData::UIGuard._cItems;

                //
                // The cache is now invalid.
                //
                Cache.Id = kInvalidIdentValue;
            }
            break;
        }
    }

    SPLASSERT( *pField != kInvalidFieldValue );

    return TRUE;
}


VOID
VDataNotify::
vUpdateInfoData(
    IN const PPRINTER_NOTIFY_INFO_DATA pData,
    IN TABLE Table,
    IN PINFO pInfo
    )

/*++

Routine Description:

    Update the VDataNotify internal data structure, and issue
    a vItemChanged to the queue UI to keep it in sync.

Arguments:

    pData - Data item that changed.

    Table - Type of data stored in pData.

    pInfo - Pointer to INFO receiving new data.  Old data freed if
        necessary.

Return Value:

--*/

{
    switch( Table ){
    case TABLE_DWORD:

        pInfo->dwData = pData->NotifyData.adwData[0];
        break;

    default:

        SPLASSERT( pData->NotifyData.Data.cbBuf );

        FreeMem( pInfo->pvData );

        pInfo->pvData = AllocMem( pData->NotifyData.Data.cbBuf );

        if( pInfo->pvData ){

            CopyMemory( pInfo->pvData,
                        pData->NotifyData.Data.pBuf,
                        pData->NotifyData.Data.cbBuf );
        }
        break;
    }
}

VOID
VDataNotify::
vDeleteAllItemData(
    VOID
    )

/*++

Routine Description:

    Delete all TItemData* jobs.  Normally there should be an assert
    to check whether this is called from the UI thread, but
    the final delete case calls this from a worker thread.

Arguments:

Return Value:

--*/

{
    //
    // Optimization: instead of delinking each individually, just
    // free them then reset the whole list.
    //
    TIter Iter;
    TItemData* pItemData;

    for( UIGuard.ItemData_vIterInit( Iter ), Iter.vNext();
         Iter.bValid(); ){

        //
        // Get a pointer to the next object, then increment the iter.
        // We must increment before deleting, since once the object
        // has been deleted, the next pointer is trash.
        //
        pItemData = UIGuard.ItemData_pConvert( Iter );
        Iter.vNext();

        pItemData->vDelete();
    }

    //
    // Now that all ItemData have been deleted, reset the head link.
    //
    UIGuard.ItemData_vReset();
    VData::UIGuard._cItems = 0;
}

/********************************************************************

    TDataNJob

********************************************************************/

TDataNJob::
TDataNJob(
    IN MDataClient* pDataClient
    ) : VDataNotify( pDataClient,
                     &TDataNJob::gFieldTable,
                     JOB_NOTIFY_TYPE )
{
}

TDataNJob::
~TDataNJob(
    VOID
    )
{
}

BOOL
TDataNJob::
bUpdateInfo(
    IN const PPRINTER_NOTIFY_INFO_DATA pData,
    IN DATA_INDEX DataIndex,
    IN CACHE& Cache CHANGE
    )
{
    SPLASSERT( DataIndex < _pFieldTable->cFields );
    SPLASSERT( Cache.NaturalIndex < VData::UIGuard._cItems );

    TItemData* pItemData = Cache.pItemData;
    FIELD Field = pData->Field;
    INFO Info;
    INFO InfoNew;
    ITEM_CHANGE ItemChange = kItemInfo;

    Info.NaturalIndex = Cache.NaturalIndex;
    InfoNew.NaturalIndex = kInvalidNaturalIndexValue;

    TABLE Table = pData->Reserved & 0xffff;
    PINFO pInfo = &pItemData->_aInfo[DataIndex];

    if( Cache.bNew ){

        //
        // This is a new item; inform the client to create a new item.
        //
        _pDataClient->vItemChanged( kItemCreate,
                                    (HITEM)pItemData,
                                    Info,
                                    Info );
        Cache.bNew = FALSE;
    }

    switch( Field ){
    case JOB_NOTIFY_FIELD_POSITION:

        //
        // Special case MOVED.
        //
        // Move the ItemData to the correct place in the linked list.
        //

        ItemChange = kItemPosition;

        //
        // Valid range is from 1 -> VData::UIGuard._cItems.
        //
        SPLASSERT( pData->NotifyData.adwData[0] );

        //
        // Start with base instead of head, since position 2 =
        // second element, not third.
        //
        InfoNew.NaturalIndex = pData->NotifyData.adwData[0] - 1;

        DBGMSG( DBG_DATANINFO,
                ( "DataNotify.vUpdateInfo: Position changed id %d ni %d->%d\n",
                  pData->Id,
                  Info.NaturalIndex,
                  InfoNew.NaturalIndex ));

        if( InfoNew.NaturalIndex >= VData::UIGuard._cItems ){

            DBGMSG( DBG_WARN,
                    ( "DataNotify.vUpdateInfo: %x %d %d, moving past end Item.\n",
                      this,
                      InfoNew.NaturalIndex,
                      VData::UIGuard._cItems ));

            return FALSE;
        }

        //
        // Remove ourselves and traverse until we get to the
        // right ItemData.  Then add ourselves back in.
        //

        pItemData->ItemData_vDelinkSelf();

        NATURAL_INDEX i;
        TIter Iter;

        for( i = InfoNew.NaturalIndex, UIGuard.ItemData_vIterInit( Iter ),
                Iter.vNext();
             i;
             --i, Iter.vNext( )){
            SPLASSERT( UIGuard.ItemData_bValid( Iter ));
        }

        //
        // Insert before appropriate element.
        //
        UIGuard.ItemData_vInsertBefore( Iter, pItemData );

        if( InfoNew.NaturalIndex != Info.NaturalIndex ){

            DBGMSG( DBG_DATANINFO,
                    ( "DataNotify.vUpdateInfo: ItemData %x (%d) moved from %d to %d\n",
                      pItemData, pItemData->_Id, Info.NaturalIndex,
                      InfoNew.NaturalIndex ));
        } else {

            //
            // If the Item didn't move, don't do anything.  This occurs the
            // first time a Item comes in since the refresh returns the
            // position, even though it really didn't move.
            //
            DBGMSG( DBG_DATANINFO,
                    ( "DataNotify.vUpdateInfo: ItemData %x (%d) did not move %d\n",
                      pItemData, pItemData->_Id, Info.NaturalIndex ));

            return FALSE;
        }

        //
        // Update cache.
        //
        Cache.NaturalIndex = InfoNew.NaturalIndex;
        break;

    case JOB_NOTIFY_FIELD_STATUS:

        if (pData->NotifyData.adwData[0] & JOB_STATUS_DELETED ){

            //
            // Special case deletion.
            //

            //
            // Ensure Item we are deleting matches NaturalIndex.
            //
            SPLASSERT( GetItem( Info.NaturalIndex ) == (HITEM)pItemData );

            //
            // Now inform the UI that something changed.
            //
            _pDataClient->vItemChanged( kItemDelete,
                                       (HITEM)pItemData,
                                       Info,
                                       InfoNew );

            return TRUE;
        }
        goto DefaultAction;

    case JOB_NOTIFY_FIELD_DOCUMENT:

        //
        // Item disposition is slightly different: it still
        // is an INFO, but we need to change the width of
        // the first field (document name).
        //
        ItemChange = kItemName;

        //
        // The name really didn't change (job ids never change) but
        // the function specifies that the old and new names are
        // placed in Info and InfoNew.
        //
        InfoNew = Info;

        //
        // Fall through to default:
        //

    default:

DefaultAction:

        //
        // Update the standard data item.
        //
        vUpdateInfoData( pData, Table, pInfo );
        break;
    }

    //
    // Now inform the UI that something changed.
    //
    _pDataClient->vItemChanged( ItemChange,
                                (HITEM)pItemData,
                                Info,
                                InfoNew );
    return FALSE;
}



/********************************************************************

    TDataNPrinter

********************************************************************/

TDataNPrinter::
TDataNPrinter(
    IN MDataClient* pDataClient
    ) : VDataNotify( pDataClient,
                     &TDataNPrinter::gFieldTable,
                     PRINTER_NOTIFY_TYPE )
{
}

TDataNPrinter::
~TDataNPrinter(
    VOID
    )
{
}

VDataNotify::TItemData*
TDataNPrinter::
pNewItemData(
    VDataNotify* pDataNotify,
    IDENT Id
    )

/*++

Routine Description:

    Override the standard definition of allocating a new TItemData.

    Normally this is a simple zero-initialized structure, but in
    the printer case, we need to initialized the CJobs field to be
    non-zero.

    This fixes the case where a printer is pending deletion and has
    >0 jobs.  Otherwise, when the status notification comes in,
    we see that the printer is pending deletion and has zero jobs
    (since the CJobs field hasn't been parsed yet) so we delete the
    printer.  Then the other notifications about this printer come in,
    causing us to recreate it.  However, now the name is lost (since
    it came in first) and when someone tries to enumerate, the will
    AV because there's no string.

Arguments:

    pDataNotify - Owning pDataNotify.

    Id - Id of new ItemData.

Return Value:

    TItemData*; NULL in case of failure.

--*/

{
    TItemData* pItemData = TItemData::pNew( pDataNotify, Id );

    if( pItemData ){
        pItemData->_aInfo[kIndexCJobs].dwData = (DWORD)-1;
    }
    return pItemData;
}

BOOL
TDataNPrinter::
bUpdateInfo(
    IN const PPRINTER_NOTIFY_INFO_DATA pData,
    IN DATA_INDEX DataIndex,
    IN CACHE& Cache CHANGE
    )
{
    ITEM_CHANGE ItemChange;

    TABLE Table = pData->Reserved & 0xffff;
    TItemData* pItemData = Cache.pItemData;
    PINFO pInfo = &pItemData->_aInfo[DataIndex];
    INFO Info;
    INFO InfoNew;

    switch( pData->Field ){
    case PRINTER_NOTIFY_FIELD_PRINTER_NAME: {

        //
        // The printer name is changing.  Pass in the old name to
        // the client, along with the old.
        //
        Info = pItemData->_aInfo[kIndexPrinterName];
        InfoNew.pvData = pData->NotifyData.Data.pBuf;

        //
        // The folder code has an interesting problem: it always
        // identifies items by string names instead of IDs, so when
        // a new item is created, we must have a printer name.
        // We solve this problem by using the sending an kItemCreate
        // only when we have the printer name.  Note this relies
        // on the fact that the name is always sent as the first
        // change field, a hack.
        //
        if( Cache.bNew ){

            //
            // This is a creation event since bNew is set.  The old
            // name is NULL (since it's new), but the SHChangeNotify
            // requires the name, so set the "old" name to be the
            // new one.  Then mark that the item is no longer new.
            //
            ItemChange = kItemCreate;
            Info = InfoNew;
            Cache.bNew = FALSE;

        } else {
            ItemChange = kItemName;
        }

        //
        // Now inform the UI that the name has changed.  We can safely
        // send the notification before updating our internal data
        // (by calling vUpdateInfoData) since the client guarantees
        // thread synchronization.
        //
        // We called vItemChanged before vUpdateInfoData since we
        // need both the old and new name.
        //
        _pDataClient->vItemChanged( ItemChange,
                                    (HITEM)pItemData,
                                    Info,
                                    InfoNew );

        vUpdateInfoData( pData, Table, pInfo );
        return FALSE;
    }

    default:

        //
        // Update the standard data item.
        //
        vUpdateInfoData( pData, Table, pInfo );

        //
        // Problem: we don't know when the printer should be removed,
        // since there is no "PRINTER_STATUS_DELETED" message that
        // indicates there will be no more printer notifications.
        //
        // Normally we'd just look for a printer that is pending
        // deletion and has zero jobs, but this won't work since
        // we get printer status _before_ CJobs.  Therefore, we
        // must pre-initialize CJobs to be some large value like -1.
        //
        // Determine whether an item should be deleted from the UI.
        // If it's pending deletion and has no jobs, it should be removed.
        //
        if( pItemData->_aInfo[kIndexStatus].dwData &
                PRINTER_STATUS_PENDING_DELETION &&
            pItemData->_aInfo[kIndexCJobs].dwData == 0 ){

            ItemChange = kItemDelete;

        } else {

            //
            // Distinguish between an info change (affects icon/list view)
            // vs. an attribute change (affects report view, but not icon/
            // list view).
            //
            ItemChange = ( pData->Field == PRINTER_NOTIFY_FIELD_ATTRIBUTES ) ?
                kItemInfo :
                kItemAttributes;

            //
            // Make the port name change an info change similar to the
            // sharing attribute change.  ( affects icon/list view )
            //
            if( pData->Field == PRINTER_NOTIFY_FIELD_PORT_NAME )
                ItemChange = kItemInfo;

            //
            // If this is a security notification then map to the correct
            // kItemSecurity id.
            //
            if( pData->Field == PRINTER_NOTIFY_FIELD_SECURITY_DESCRIPTOR )
                ItemChange = kItemSecurity;
        }

        //
        // Now inform the UI that something changed.
        //
        Info.NaturalIndex = Cache.NaturalIndex;
        _pDataClient->vItemChanged( ItemChange,
                                    (HITEM)pItemData,
                                    Info,
                                    Info );
        break;
    }
    return ItemChange == kItemDelete;
}


/********************************************************************

    Debug support

********************************************************************/

#if DBG

//
// Define debug tables.
//
UINT aFieldMax[2] = {
    I_PRINTER_END,
    I_JOB_END
};

//
// Define debug strings for fields.
//
#define DEFINE( field, attrib, table, y, z )\
    #field,

LPSTR aszFieldJob[] = {
#include "ntfyjob.h"
    NULL
};

LPSTR aszFieldPrinter[] = {
#include "ntfyprn.h"
    NULL
};

#undef DEFINE

LPSTR* aaszField[2] = {
    aszFieldPrinter,
    aszFieldJob
};

PCSTR acszType[2] = {
    "Printer: ",
    "Job    : "
};

VOID
VDataNotify::
vDbgOutputInfo(
    IN const PPRINTER_NOTIFY_INFO pInfo
    )

/*++

Routine Description:

    Dump out the pInfo data to the debugger.

Arguments:

    pInfo - Info to dump.

Return Value:

--*/

{
    PPRINTER_NOTIFY_INFO_DATA pData;
    DWORD i, j;

    DWORD Type;
    DWORD Field;

    BOOL bFound = FALSE;

    for( i = 0, pData = pInfo->aData; i < pInfo->Count; i++, pData++ ){

        Type = pData->Type;
        Field = pData->Field;

        //
        // Match field to I_ index.
        //
        for( j=0; j< aFieldMax[Type]; j++ ){

            if( j == Field ) {
                bFound = TRUE;
                break;
            }
        }

        if( !bFound ){

            DBGMSG( DBG_MIN, ( "[?Field 0x%x not found (Type=%d)\n", Field, Type ));
            continue;
        }

        switch( aaTable[Type][j] ){
        case TABLE_STRING:

            DBGMSG( DBG_MIN,
                    ( "> %hs Id = 0x%x | %hs = "TSTR"\n",
                      acszType[Type], pData->Id, aaszField[Type][j],
                      pData->NotifyData.Data.pBuf ));

            if( !((LPTSTR)pData->NotifyData.Data.pBuf)[0] ){
                DBGMSG( DBG_MIN|DBG_NOHEAD, ( "\n" ));
            }

            break;

        case TABLE_DWORD:

            DBGMSG( DBG_MIN,
                    ( "> %hs Id = 0x%x | %hs = 0x%x = %d\n",
                      acszType[Type], pData->Id, aaszField[Type][j],
                      pData->NotifyData.adwData[0],
                      pData->NotifyData.adwData[0] ));
            break;

        case TABLE_TIME:
        {
            SYSTEMTIME LocalTime;
            TCHAR szTime[80];
            TCHAR szDate[80];
            LCID lcid = GetUserDefaultLCID();

            if ( !SystemTimeToTzSpecificLocalTime(
                     NULL,
                     (PSYSTEMTIME)pData->NotifyData.Data.pBuf,
                     &LocalTime )) {

                DBGMSG( DBG_MIN,
                        ( "[SysTimeToTzSpecLocalTime failed %d]\n",
                          GetLastError( )));
                break;
            }

            if( !GetTimeFormat( lcid,
                                0,
                                &LocalTime,
                                NULL,
                                szTime,
                                COUNTOF( szTime ))){

                DBGMSG( DBG_MIN,
                        ( "[No Time %d], ", GetLastError( )));
                break;
            }

            if( !GetDateFormat( lcid,
                                0,
                                &LocalTime,
                                NULL,
                                szDate,
                                COUNTOF( szDate ))) {

                DBGMSG( DBG_MIN, ( "[No Date %d]\n", GetLastError( )));
                break;
            }

            DBGMSG( DBG_MIN,
                    ( "> %hs Id = 0x%x | %hs = "TSTR" "TSTR"\n",
                      acszType[Type], pData->Id, aaszField[Type][j],
                      szTime,
                      szDate ));
            break;
        }
        default:
            DBGMSG( DBG_MIN,
                    ( "[?tab %d: t_0x%x f_0x%x %x, %x]\n",
                      aaTable[Type][j],
                      Type,
                      Field,
                      pData->NotifyData.adwData[0],
                      pData->NotifyData.adwData[1] ));
            break;
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\debug.c ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    debug.h

Abstract:

    PrintUI core debugging macros/tools.

Author:

    Lazar Ivanov (LazarI)  Jul-05-2000

Revision History:

--*/

#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <shlwapi.h>

#include "debug.h"

#if DBG

// globals - print & break only for errors
// DWORD MODULE_DEBUG = MODULE_DEBUG_INIT(DBG_ERROR|DBG_INFO, DBG_ERROR);
DWORD MODULE_DEBUG = MODULE_DEBUG_INIT(DBG_ERROR, DBG_ERROR);

// private globals
static CRITICAL_SECTION g_csDebug;
static BOOL g_csDebugInitialized = FALSE;

//////////////////////////////////////
// single thread checking routines
//

VOID
_DbgSingleThread(
    const DWORD *pdwThreadId
    )
{
    SPLASSERT(g_csDebugInitialized);
    EnterCriticalSection(&g_csDebug);

    if( 0 == *pdwThreadId )
        *((DWORD*)(pdwThreadId)) = (DWORD)GetCurrentThreadId();
    SPLASSERT(*pdwThreadId == (DWORD)GetCurrentThreadId());

    LeaveCriticalSection(&g_csDebug);
}

VOID
_DbgSingleThreadReset(
    const DWORD *pdwThreadId
    )
{
    SPLASSERT(g_csDebugInitialized);
    EnterCriticalSection(&g_csDebug);

    *((DWORD*)(pdwThreadId)) = 0;

    LeaveCriticalSection(&g_csDebug);
}

VOID
_DbgSingleThreadNot(
    const DWORD *pdwThreadId
    )
{
    SPLASSERT(g_csDebugInitialized);
    EnterCriticalSection(&g_csDebug);

    SPLASSERT(*pdwThreadId != (DWORD)GetCurrentThreadId());

    LeaveCriticalSection(&g_csDebug);
}

//////////////////////////////
// generic error logging API
//

VOID
_DbgMsg(
    LPCSTR pszMsgFormat,
    ...
    )
{
    va_list vargs;
    CHAR szBuffer[1024]; // 1K buffer should be enough

    SPLASSERT(g_csDebugInitialized);
    EnterCriticalSection(&g_csDebug);

    va_start(vargs, pszMsgFormat);
    wvnsprintfA(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), pszMsgFormat, vargs);
    va_end(vargs);
    OutputDebugStringA(szBuffer);

    LeaveCriticalSection(&g_csDebug);
}

VOID
_DbgWarnInvalid(
    PVOID pvObject,
    UINT uDbg,
    UINT uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA
    )
{
    DBGMSG(DBG_WARN, ("Invalid Object LastError = %d\nLine %d, %hs\n", GetLastError(), uLine, pszFileA));
}

HRESULT
_DbgInit(
    VOID
    )
{
    HRESULT hr = S_OK;
    __try
    {
        InitializeCriticalSection(&g_csDebug);
        g_csDebugInitialized = TRUE;

    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    { 
        hr = E_OUTOFMEMORY; 
    }
    return hr;
}

HRESULT
_DbgDone(
    VOID
    )
{
    if( g_csDebugInitialized )
    {
        DeleteCriticalSection(&g_csDebug);
    }
    return S_OK;
}

VOID
_DbgBreak(
    VOID
    )
{
    // since we don't want to break in kd, we should
    // break only if a user mode debugger is present.
    if( IsDebuggerPresent() )
    {
        DebugBreak();
    }
    else
    {
        // take the process down
        int *p = NULL;
        *p = 42;
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\datar.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1998
All rights reserved.

Module Name:

    datar.cxx

Abstract:

    VDataRefresh routines.  Handles talking to downlevel clients
    (NT 3.5, wfw, lm, win95) which do not support full notifications.

    Note that the spooler simulates all single DWORD notifications
    for down-down level clients (wfw, lm, win95) so we don't have
    to handle polling.

Author:

    Albert Ting (AlbertT)  07-12-95

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#if DBG
//#define DBG_DATARINFO                  DBG_INFO
#define DBG_DATARINFO                    DBG_NONE
#endif

/********************************************************************

    VDataRefresh handling: downlevel case.

********************************************************************/

VDataRefresh::
VDataRefresh(
    IN MDataClient* pDataClient,
    IN PFIELD_TABLE pFieldTable,
    IN DWORD fdwWatch
    ) : VData( pDataClient, pFieldTable ), _fdwWatch( fdwWatch )
{
    ExecGuard._hPrinterWait = NULL;
}

VDataRefresh::
~VDataRefresh(
    VOID
    )
{
    SPLASSERT( !ExecGuard._hPrinterWait );
}

VOID
VDataRefresh::
vProcessNotifyWork(
    IN TNotify* pNotify
    )
{
    UNREFERENCED_PARAMETER( pNotify );
    DWORD dwChange;

    //
    // Notification caught.  We must signal that caught it before
    // issuing the refresh, since there may be notifications between
    // the refresh and the FNPCN, which would be lost.
    //
    // Just issue a refresh since we don't support hot notifications.
    //
    BOOL bSuccess = FindNextPrinterChangeNotification( m_shNotify,
                                                       &dwChange,
                                                       0,
                                                       NULL );

    if( !bSuccess ){

        DBGMSG( DBG_WARN,
                ( "DataRefresh.vProcessNotifyWork: %x FNPCN %x failed: %d\n",
                  this,
                  static_cast<HANDLE>(m_shNotify),
                  GetLastError( )));

        INFO Info;
        Info.dwData = TPrinter::kExecReopen | TPrinter::kExecDelay;

        _pDataClient->vContainerChanged( kContainerStateVar, Info );
        return;
    }

    //
    // Filter out any extranous watch flags that were set.  This
    // may happen when the printer goes down and all flags are set.
    //
    if( dwChange & ~_fdwWatch ){
        DBGMSG( DBG_WARN,
                ( "VDataRefresh:vProcessNotifyWork: extra flags %x: %x %x\n",
                  this, dwChange, _fdwWatch ));
    }
    dwChange &= _fdwWatch;

    CONTAINER_CHANGE ContainerChange = kContainerNull;
    INFO Info;

    Info.dwData = TPrinter::kExecRefresh;

    if( dwChange & PRINTER_CHANGE_PRINTER ){
        Info.dwData |= TPrinter::kExecRefreshContainer;
    }
    if( dwChange & PRINTER_CHANGE_JOB ){
        Info.dwData |= TPrinter::kExecRefreshItem;
    }

    _pDataClient->vContainerChanged( kContainerStateVar, Info );
}

/********************************************************************

    Worker thread functions for Refresh.

********************************************************************/

STATEVAR
VDataRefresh::
svNotifyStart(
    IN STATEVAR StateVar
    )

/*++

Routine Description:

    Begin downlevel notifications.

    HACK: To support downlevel providers that don't support
    F*PCN calls, we must open a separate handle.

Arguments:

Return Value:

--*/

{
    TStatus Status;
    TStatusB bStatus;

    ExecGuard._hPrinterWait = _pDataClient->hPrinterNew();

    if( !ExecGuard._hPrinterWait ){
        goto Fail;
    }

    //
    // Get the notification handle.
    //
    m_shNotify = FindFirstPrinterChangeNotification(
                   ExecGuard._hPrinterWait,
                   _fdwWatch,
                   0,
                   0 );

    if( !m_shNotify )
    {
        DBGMSG( DBG_WARN, ( "DataRefresh.svNotifyStart: FFPCN failed %d\n", GetLastError( )));
        goto Fail;
    }

    DBGMSG( DBG_NOTIFY,
            ( "DataRefresh.svNotifyStart: %x FFPCN success returns 0x%x\n",
              _pDataClient, static_cast<HANDLE>(m_shNotify) ));

    //
    // Successfully opened, request that it be registered and then
    // refresh.
    //
    return (StateVar & ~TPrinter::kExecNotifyStart) |
               TPrinter::kExecRegister | TPrinter::kExecRefreshAll;

Fail:

    //
    // Force a reopen.  Everything gets reset (handles closed, etc.) when
    // the reopen occurs.
    //
    return StateVar | TPrinter::kExecDelay | TPrinter::kExecReopen;
}

STATEVAR
VDataRefresh::
svNotifyEnd(
    IN STATEVAR StateVar
    )

/*++

Routine Description:

    Stop downlevel notifications.

Arguments:

Return Value:

--*/

{
    TStatusB bStatus;

    DBGMSG( DBG_NOTIFY, ( "DataRefresh.svNotifyEnd: handle %x\n", static_cast<HANDLE>(m_shNotify) ));
    //
    // Unregister from TNotify.
    //
    _pPrintLib->pNotify()->sUnregister( this );

    //
    // If we have a notification event, close it.
    //
    m_shNotify = NULL;

    //
    // Close our separate printer.
    //
    if( ExecGuard._hPrinterWait ){
        bStatus DBGCHK = ClosePrinter( ExecGuard._hPrinterWait );
        ExecGuard._hPrinterWait = NULL;
    }

    return StateVar & ~TPrinter::kExecNotifyEnd;
}


/********************************************************************

    Static services.

********************************************************************/

BOOL
VDataRefresh::
bGetPrinter(
    IN     HANDLE hPrinter,
    IN     DWORD dwLevel,
    IN OUT PVOID* ppvBuffer, CHANGE
    IN OUT PDWORD pcbBuffer
    )

/*++

Routine Description:

    Gets printer information, reallocing as necessary.

Arguments:

    hPrinter - Printer to query.

    dwLevel - PRINTER_INFO_x level to retrieve.

    ppvBuffer - Buffer to store information.  If *ppvBuffer is
        NULL, then it is allocated.  On failure, this buffer is
        freed and NULLed

    pcbBuffer - Initial buffer size.  On exit, actual.

Return Value:

    TRUE = success, FALSE = fail.

--*/

{
    DWORD cbNeeded;

    //
    // Pre-initialize *pcbPrinter if it's not set.
    //
    if( !*pcbBuffer ){
        *pcbBuffer = kMaxPrinterInfo2;
    }

Retry:

    SPLASSERT( *pcbBuffer < 0x100000 );

    if( !( *ppvBuffer )){

        *ppvBuffer = (PVOID)AllocMem( *pcbBuffer );
        if( !*ppvBuffer ){
            *pcbBuffer = 0;
            return FALSE;
        }
    }

    if( !GetPrinter( hPrinter,
                     dwLevel,
                     (PBYTE)*ppvBuffer,
                     *pcbBuffer,
                     &cbNeeded )){

        FreeMem( *ppvBuffer );
        *ppvBuffer = NULL;

        if( GetLastError() != ERROR_INSUFFICIENT_BUFFER ){
            *pcbBuffer = 0;
            return FALSE;
        }

        *pcbBuffer = cbNeeded + kExtraPrinterBufferBytes;
        SPLASSERT( *pcbBuffer < 0x100000 );

        goto Retry;
    }
    return TRUE;
}

BOOL
VDataRefresh::
bGetJob(
    IN     HANDLE hPrinter,
    IN     DWORD dwJobId,
    IN     DWORD dwLevel,
    IN OUT PVOID* ppvBuffer, CHANGE
    IN OUT PDWORD pcbBuffer
    )

/*++

Routine Description:

    Gets printer job information, reallocing as necessary.

Arguments:

    hPrinter - Printer to query.

    dwLevel - JOB_INFO_x level to retrieve.

    ppvBuffer - Buffer to store information.  If *ppvBuffer is
        NULL, then it is allocated.  On failure, this buffer is
        freed and NULLed

    pcbBuffer - Initial buffer size.  On exit, actual.

Return Value:

    TRUE = success, FALSE = fail.

--*/

{
    DWORD cbNeeded;

    //
    // Pre-initialize *pcbPrinter if it's not set.
    //
    if( !*pcbBuffer ){
        *pcbBuffer = kInitialJobHint;
    }

Retry:

    SPLASSERT( *pcbBuffer < 0x100000 );

    if( !( *ppvBuffer )){

        *ppvBuffer = (PVOID)AllocMem( *pcbBuffer );
        if( !*ppvBuffer ){
            *pcbBuffer = 0;
            return FALSE;
        }
    }

    if( !GetJob( hPrinter,
                 dwJobId,
                 dwLevel,
                 (PBYTE)*ppvBuffer,
                 *pcbBuffer,
                 &cbNeeded )){

        FreeMem( *ppvBuffer );
        *ppvBuffer = NULL;

        if( GetLastError() != ERROR_INSUFFICIENT_BUFFER ){
            *pcbBuffer = 0;
            return FALSE;
        }

        *pcbBuffer = cbNeeded + kExtraPrinterBufferBytes;
        SPLASSERT( *pcbBuffer < 0x100000 );

        goto Retry;
    }
    return TRUE;
}

BOOL
VDataRefresh::
bGetPrinterDriver(
    IN     HANDLE hPrinter,
    IN     LPCTSTR pszEnvironment,
    IN     DWORD dwLevel,
    IN OUT PVOID* ppvBuffer, CHANGE
    IN OUT PDWORD pcbBuffer
    )

/*++

Routine Description:

    Gets printer driver information, reallocing as necessary.

Arguments:

    hPrinter - Printer to query.

    pszEnvironment - Environment.

    dwLevel - DRIVER_INFO_x level to retrieve.

    ppvBuffer - Buffer to store information.  If *ppvBuffer is
        NULL, then it is allocated.  On failure, this buffer is
        freed and NULLed

    pcbBuffer - Initial buffer size.  On exit, actual.

Return Value:

    TRUE = success, FALSE = fail.

--*/

{
    DWORD cbNeeded;

    //
    // Pre-initialize *pcbPrinter if it's not set.
    //
    if( !*pcbBuffer ){
        *pcbBuffer = kInitialDriverInfo3Hint;
    }

Retry:

    if( !( *ppvBuffer )){

        *ppvBuffer = (PVOID)AllocMem( *pcbBuffer );
        if( !*ppvBuffer ){
            *pcbBuffer = 0;
            return FALSE;
        }
    }

    if( !GetPrinterDriver( hPrinter,
                           (LPTSTR)pszEnvironment,
                           dwLevel,
                           (PBYTE)*ppvBuffer,
                           *pcbBuffer,
                           &cbNeeded )){

        FreeMem( *ppvBuffer );
        *ppvBuffer = NULL;

        if( GetLastError() != ERROR_INSUFFICIENT_BUFFER ){
            *pcbBuffer = 0;
            return FALSE;
        }

        *pcbBuffer = cbNeeded;
        goto Retry;
    }
    return TRUE;
}


BOOL
VDataRefresh::
bEnumJobs(
    IN     HANDLE hPrinter,
    IN     DWORD dwLevel,
    IN OUT PVOID* ppvBuffer, CHANGE
    IN OUT PDWORD pcbBuffer,
       OUT PDWORD pcJobs
    )

/*++

Routine Description:

    Enumerates job information, reallocing as necessary.

Arguments:

    hPrinter - Printer to query.

    dwLevel - JOB_INFO_x level to retrieve.

    ppvBuffer - Buffer to store information.  If *ppvBuffer is
        NULL, then it is allocated.  On failure, this buffer is
        freed and NULLed

    pcbBuffer - Initial buffer size.  On exit, actual.

    pcJobs - Number of jobs returned.

Return Value:

    TRUE = success, FALSE = fail.

--*/

{
    DWORD cbNeeded;

    //
    // Pre-initialize *pcbPrinter if it's not set.
    //
    if( !*pcbBuffer ){
        *pcbBuffer = kInitialJobHint;
    }

Retry:

    if( !( *ppvBuffer )){

        *ppvBuffer = (PVOID)AllocMem( *pcbBuffer );
        if( !*ppvBuffer ){
            *pcbBuffer = 0;
            *pcJobs = 0;
            return FALSE;
        }
    }

    if( !EnumJobs( hPrinter,
                   0,
                   (DWORD)-1,
                   dwLevel,
                   (PBYTE)*ppvBuffer,
                   *pcbBuffer,
                   &cbNeeded,
                   pcJobs )){

        FreeMem( *ppvBuffer );
        *ppvBuffer = NULL;

        if( GetLastError() != ERROR_INSUFFICIENT_BUFFER ){
            *pcbBuffer = 0;
            *pcJobs = 0;
            return FALSE;
        }

        *pcbBuffer = cbNeeded + kExtraJobBufferBytes;
        goto Retry;
    }
    return TRUE;
}

BOOL
VDataRefresh::
bEnumPrinters(
    IN     DWORD dwFlags,
    IN     LPCTSTR pszServer,
    IN     DWORD dwLevel,
    IN OUT PVOID* ppvBuffer, CHANGE
    IN OUT PDWORD pcbBuffer,
       OUT PDWORD pcPrinters
    )

/*++

Routine Description:

    Enumerates printer information, reallocing as necessary.

Arguments:

    dwFlags - Scope of query.

    pszServer - Server to query.

    dwLevel - PRINTER_INFO_x level to retrieve.

    ppvBuffer - Buffer to store information.  If *ppvBuffer is
        NULL, then it is allocated.  On failure, this buffer is
        freed and NULLed

    pcbBuffer - Initial buffer size.  On exit, actual.

    pcPrinters - Number of printers returned.

Return Value:

    TRUE = success, FALSE = fail.

--*/

{
    DWORD cbNeeded;

    //
    // Pre-initialize *pcbPrinter if it's not set.
    //
    if( !*pcbBuffer ){
        *pcbBuffer = kInitialPrinterHint;
    }

Retry:

    if( !( *ppvBuffer )){

        *ppvBuffer = (PVOID)AllocMem( *pcbBuffer );
        if( !*ppvBuffer ){
            *pcbBuffer = 0;
            *pcPrinters = 0;
            return FALSE;
        }
    }

    if( !EnumPrinters( dwFlags,
                       (LPTSTR)pszServer,
                       dwLevel,
                       (PBYTE)*ppvBuffer,
                       *pcbBuffer,
                       &cbNeeded,
                       pcPrinters )){

        FreeMem( *ppvBuffer );
        *ppvBuffer = NULL;

        if( GetLastError() != ERROR_INSUFFICIENT_BUFFER ){
            *pcbBuffer = 0;
            *pcPrinters = 0;
            return FALSE;
        }

        *pcbBuffer = cbNeeded;
        goto Retry;
    }
    return TRUE;
}

BOOL
VDataRefresh::
bEnumDrivers(
    IN     LPCTSTR  pszServer,
    IN     LPCTSTR  pszEnvironment,
    IN     DWORD    dwLevel,
    IN OUT PVOID   *ppvBuffer, CHANGE
    IN OUT PDWORD   pcbBuffer,
       OUT PDWORD   pcDrivers
    )

/*++

Routine Description:

    Enumerates driver information, reallocing as necessary.

Arguments:

    dwFlags - Scope of query.

    pszServer - Server to query.

    dwLevel - DRIVER_INFO_x level to retrieve.

    ppvBuffer - Buffer to store information.  If *ppvBuffer is
        NULL, then it is allocated.  On failure, this buffer is
        freed and NULLed

    pcbBuffer - Initial buffer size.  On exit, actual.

    pcPrinters - Number of printers returned.

Return Value:

    TRUE = success, FALSE = fail.

--*/

{
    DWORD cbNeeded;

    //
    // Pre-initialize *pcbPrinter if it's not set.
    //
    if( !*pcbBuffer ){
        *pcbBuffer = kInitialDriverHint;
    }

Retry:

    if( !( *ppvBuffer )){

        *ppvBuffer = (PVOID)AllocMem( *pcbBuffer );
        if( !*ppvBuffer ){
            *pcbBuffer = 0;
            *pcDrivers = 0;
            return FALSE;
        }
    }

    if( !EnumPrinterDrivers( (LPTSTR)pszServer,
                             (LPTSTR)pszEnvironment,
                              dwLevel,
                              (PBYTE)*ppvBuffer,
                              *pcbBuffer,
                              &cbNeeded,
                              pcDrivers )){

        FreeMem( *ppvBuffer );
        *ppvBuffer = NULL;

        if( GetLastError() != ERROR_INSUFFICIENT_BUFFER ){
            *pcbBuffer = 0;
            *pcDrivers = 0;
            return FALSE;
        }

        *pcbBuffer = cbNeeded;
        goto Retry;
    }
    return TRUE;
}

/*++

Routine Name:

    bGetDefaultDevMode

Routine Description:

    Allocates the buffer needed to hold the dev mode.

Arguments:

    hPrinter            - Opened printer handle
    pszPrinterName      - Pointer to printer name
    ppDevMode           - Pointer where to return devmode
    bFillWithDefault    - Flag indicates to fill dev mode with default information.
                          TRUE fill allocated dev mode, FALSE do not fill

Return Value:

    TRUE success, FALSE error occurred.

--*/
BOOL
VDataRefresh::
bGetDefaultDevMode(
    IN      HANDLE      hPrinter,
    IN      LPCTSTR     pszPrinterName,
        OUT PDEVMODE   *ppDevMode,
    IN      BOOL        bFillWithDefault
    )
{
    LONG        lResult     = 0;
    PDEVMODE    pDevMode    = NULL;

    //
    // Call document properties to get the size of the dev mode.
    //
    lResult = DocumentProperties( NULL,
                                  hPrinter,
                                  (LPTSTR)pszPrinterName,
                                  NULL,
                                  NULL,
                                  0 );
    //
    // If the size of the dev mode was returned.
    //
    if( lResult > 0 )
    {
        pDevMode = (PDEVMODE)AllocMem( lResult );
    }

    //
    // If allocated then copy back the pointer.
    //
    if( pDevMode )
    {
        if( bFillWithDefault )
        {
            //
            // Call document properties to get the default dev mode.
            //
            lResult = DocumentProperties( NULL,
                                          hPrinter,
                                          (LPTSTR)pszPrinterName,
                                          pDevMode,
                                          NULL,
                                          DM_OUT_BUFFER );

        }

          if( lResult >= 0 )
        {
            *ppDevMode = pDevMode;
        }
        else
        {
            FreeMem( pDevMode );
        }
    }

    return *ppDevMode != NULL;
}

/*++

Routine Name:

    bEnumPorts

Routine Description:

    Enumerates the ports on the specified machine.

Arguments:

    pszServer   - Server to query.
    dwLevel     - PORT_INFOX level to retrieve.
    ppvPorts    - Buffer to store information.  If *ppvBuffer is
                  NULL, then it is allocated.  On failure, this buffer is
                  freed and NULLed
    pcbPorts    - Initial buffer size.  On exit, actual.
    pcPorts     - Number of ports returned.

Return Value:

    TRUE success, FALSE error occurred.

--*/

BOOL
VDataRefresh::
bEnumPorts(
    IN     LPCTSTR  pszServer,
    IN     DWORD    dwLevel,
    IN OUT PVOID   *ppvPorts, CHANGE
    IN OUT PDWORD   pcbPorts,
       OUT PDWORD   pcPorts
    )
{
    DWORD cbNeeded;

    //
    // Pre-initialize *pcbPorts if it's not set.
    //
    if( !*pcbPorts ){
        *pcbPorts = kEnumPortsHint;
    }

Retry:

    if( !(*ppvPorts)){

        *ppvPorts = (PVOID)AllocMem( *pcbPorts );

        if( !*ppvPorts ){
            *pcbPorts = 0;
            *pcPorts = 0;
            DBGMSG( DBG_WARN,( "VDataRefresh::bEnumPorts can't alloc %d %d\n", *pcbPorts, GetLastError( )));
            return FALSE;
        }
    }

    if( !EnumPorts( (LPTSTR)pszServer,
                    dwLevel,
                    (PBYTE)*ppvPorts,
                    *pcbPorts,
                    &cbNeeded,
                    pcPorts ) ){

        FreeMem( *ppvPorts );
        *ppvPorts = NULL;

        if( GetLastError() != ERROR_INSUFFICIENT_BUFFER ){
            *pcbPorts = 0;
            *pcPorts = 0;
            return FALSE;
        }

        *pcbPorts = cbNeeded;
        goto Retry;
    }

    return TRUE;

}

/*++

Routine Name:

    bEnumPortsMaxLevel

Routine Description:

    Enumerates the ports on the specified machine. With maximum level
    specified.

Arguments:

    pszServer   - Server to query.
    dwLevel     - Max PORT_INFOX level to retrieve.  We try this level and
                  decrement until dwLevel is zero.
    ppvPorts    - Buffer to store information.  If *ppvBuffer is
                  NULL, then it is allocated.  On failure, this buffer is
                  freed and NULLed
    pcbPorts    - Initial buffer size.  On exit, actual.
    pcPorts     - Number of ports returned.

Return Value:

    TRUE success, FALSE error occurred.

--*/

BOOL
VDataRefresh::
bEnumPortsMaxLevel(
    IN     LPCTSTR  pszServer,
    IN     PDWORD   pdwLevel,
    IN OUT PVOID   *ppvPorts, CHANGE
    IN OUT PDWORD   pcbPorts,
       OUT PDWORD   pcPorts
    )
{
    BOOL bStatus = FALSE;

    //
    // Try all levels to level zero.
    //
    for( ; *pdwLevel; (*pdwLevel)-- )
    {
        bStatus = bEnumPorts( pszServer,
                              *pdwLevel,
                              ppvPorts,
                              pcbPorts,
                              pcPorts );
        //
        // If the call succeeded then we are done.
        //
        if( bStatus )
        {
            break;
        }
        else
        {
            //
            // The call failed and it is not invalid level then
            // exit with error.
            //
            if( GetLastError() != ERROR_INVALID_LEVEL )
            {
                break;
            }
        }
    }

    return bStatus;
}

/*++

Routine Name:

    bEnumPorts

Routine Description:

    Enumerates the ports on the specified machine.

Arguments:

    pszServer   - Server to query.
    dwLevel     - PORT_INFOX level to retrieve.
    ppvPorts    - Buffer to store information.  If *ppvBuffer is
                  NULL, then it is allocated.  On failure, this buffer is
                  freed and NULLed
    pcbPorts    - Initial buffer size.  On exit, actual.
    pcPorts     - Number of ports returned.

Return Value:

    TRUE success, FALSE error occurred.

--*/

BOOL
VDataRefresh::
bEnumMonitors(
    IN     LPCTSTR  pszServer,
    IN     DWORD    dwLevel,
    IN OUT PVOID   *ppvMonitors, CHANGE
    IN OUT PDWORD   pcbMonitors,
       OUT PDWORD   pcMonitors
    )
{
    DWORD cbNeeded;

    //
    // Pre-initialize *pcbMonitors if it's not set.
    //
    if( !*pcbMonitors ){
        *pcbMonitors = kEnumMonitorsHint;
    }

Retry:

    if( !(*ppvMonitors)){

        *ppvMonitors = (PVOID)AllocMem( *pcbMonitors );

        if( !*ppvMonitors ){
            *pcbMonitors = 0;
            *pcMonitors = 0;
            DBGMSG( DBG_WARN,( "VDataRefresh::bEnumMonitors can't alloc %d %d\n", *pcbMonitors, GetLastError( )));
            return FALSE;
        }
    }

    if( !EnumMonitors( (LPTSTR)pszServer,
                    dwLevel,
                    (PBYTE)*ppvMonitors,
                    *pcbMonitors,
                    &cbNeeded,
                    pcMonitors ) ){

        FreeMem( *ppvMonitors );
        *ppvMonitors = NULL;

        if( GetLastError() != ERROR_INSUFFICIENT_BUFFER ){
            *pcbMonitors = 0;
            *pcMonitors = 0;
            return FALSE;
        }

        *pcbMonitors = cbNeeded;
        goto Retry;
    }

    return TRUE;

}

/********************************************************************

    TDataRJob

********************************************************************/

TDataRJob::
TDataRJob(
    IN MDataClient* pDataClient
    ) : VDataRefresh( pDataClient, &TDataNJob::gFieldTable, kfdwWatch )
{
    ExecGuard._cbJobHint = kInitialJobHint;
    UIGuard._pJobs = NULL;
}

TDataRJob::
~TDataRJob(
    VOID
    )
{
    FreeMem( UIGuard._pJobs );
}

/********************************************************************

    Data interface for Refresh.

********************************************************************/

HITEM
TDataRJob::
GetItem(
    IN NATURAL_INDEX NaturalIndex
    ) const
{
    SPLASSERT( UIGuard._pJobs );
    SPLASSERT( NaturalIndex < VData::UIGuard._cItems );

    return (HITEM)&UIGuard._pJobs[NaturalIndex];
}

HITEM
TDataRJob::
GetNextItem(
    IN HITEM hItem
    ) const
{
    SPLASSERT( UIGuard._pJobs );

    //
    // NULL passed in, return first item.
    //
    if( !hItem ){
        return &UIGuard._pJobs[0];
    }

    PJOB_INFO_2 pJob2 = (PJOB_INFO_2)hItem;
    return (HITEM)( pJob2 + 1 );
}

INFO
TDataRJob::
GetInfo(
    IN HITEM hItem,
    IN DATA_INDEX DataIndex
    ) const
{
    SPLASSERT( hItem );
    SPLASSERT( DataIndex < _pFieldTable->cFields );

    INFO Info = kInfoNull;
    PJOB_INFO_2 pJob2 = (PJOB_INFO_2)hItem;
    BOOL bString = FALSE;

    //
    // Translate the index into the appropriate field.
    //
    FIELD Field = _pFieldTable->pFields[DataIndex];

    switch( Field ){

    case JOB_NOTIFY_FIELD_DOCUMENT:
        Info.pszData = pJob2->pDocument;
        bString = TRUE;
        break;

    case JOB_NOTIFY_FIELD_STATUS:
        Info.dwData = pJob2->Status;
        break;

    case JOB_NOTIFY_FIELD_STATUS_STRING:
        Info.pszData = pJob2->pStatus;
        bString = TRUE;
        break;

    case JOB_NOTIFY_FIELD_USER_NAME:
        Info.pszData = pJob2->pUserName;
        bString = TRUE;
        break;

    case JOB_NOTIFY_FIELD_TOTAL_PAGES:
        Info.dwData = pJob2->TotalPages;
        break;

    case JOB_NOTIFY_FIELD_PAGES_PRINTED:

        //
        // In chicago, PagesPrinted is overloaded so that if
        // TotalPages is zero, PagesPrinted is actually BytesPrinted.
        //
        Info.dwData = pJob2->TotalPages ?
                          pJob2->PagesPrinted :
                          0;
        break;

    case JOB_NOTIFY_FIELD_TOTAL_BYTES:
        Info.dwData = pJob2->Size;
        break;

    case JOB_NOTIFY_FIELD_BYTES_PRINTED:

        //
        // In chicago, PagesPrinted is overloaded so that if
        // TotalPages is zero, PagesPrinted is actually BytesPrinted.
        //
        Info.dwData = !pJob2->TotalPages ?
                          pJob2->PagesPrinted :
                          0;
        break;

    case JOB_NOTIFY_FIELD_SUBMITTED:
        Info.pSystemTime = &pJob2->Submitted;
        break;

    case JOB_NOTIFY_FIELD_PORT_NAME:

        Info.pszData = gszNULL;
        break;

    default:

        DBGMSG( DBG_ERROR,
                ( "DataRJob.GetInfo: Unimplemented field %d\n", Field ));
        break;
    }

    if( bString && !Info.pszData ){
        Info.pszData = gszNULL;
    }

    return Info;
}

IDENT
TDataRJob::
GetId(
    IN HITEM hItem
    ) const
{
    SPLASSERT( hItem );

    PJOB_INFO_2 pJob2 = (PJOB_INFO_2)hItem;
    return pJob2->JobId;
}

NATURAL_INDEX
TDataRJob::
GetNaturalIndex(
    IN     IDENT Id,
       OUT PHITEM phItem OPTIONAL
    ) const
{
    COUNT cItems = VData::UIGuard._cItems;
    PJOB_INFO_2 pJob2 = UIGuard._pJobs;

    if( phItem ){
        *phItem = NULL;
    }

    //
    // If no _pJobs, return 0.  This may happen if during a refresh,
    // the selected item is deleted.
    //
    if( pJob2 ){

        //
        // Look for a JobId that matches ours.
        //

        COUNT i;

        for( i = 0; i < cItems; ++i ){
            if( pJob2[i].JobId == Id ){

                if( phItem ){
                    *phItem = (HITEM)&pJob2[i];
                }
                return i;
            }
        }
    }

    DBGMSG( DBG_DATARINFO,
            ( "DataRefresh.GetNaturalIndex: Item %d not found (cItems = %d, pJob2 = %x) %x\n",
              Id, cItems, pJob2, this ));

    return kInvalidNaturalIndexValue;
}


STATEVAR
TDataRJob::
svRefresh(
    IN STATEVAR StateVar
    )

/*++

Routine Description:

    Refresh the printer data object.

Arguments:

Return Value:

--*/

{
    if( !m_shNotify )
    {
        return TPrinter::kExecReopen;
    }

    //
    // !! HACK !!
    //
    // Nuke extraneous refreshes by resetting m_shNotify.
    //
    if( !ResetEvent( m_shNotify ))
    {
        DBGMSG( DBG_ERROR, ( "DataRefresh.svRefresh: reset %x failed %d\n",
                static_cast<HANDLE>(m_shNotify), GetLastError( )));
    }

    //
    // Check if jobs need to be refreshed.
    //
    if( StateVar & TPrinter::kExecRefreshItem ){

        //
        // Attempt an enum of approximately the same size as last time.
        //
        DWORD cJobs = 0;
        DWORD cbJobs = ExecGuard._cbJobHint;
        PJOB_INFO_2 pJobs = (PJOB_INFO_2)AllocMem( cbJobs );

        if( !pJobs ){
            goto Fail;
        }

        TStatusB bStatus( DBG_WARN,
                          RPC_S_SERVER_UNAVAILABLE,
                          RPC_S_SERVER_TOO_BUSY,
                          RPC_S_CALL_FAILED_DNE );

        bStatus DBGCHK = bEnumJobs( _pDataClient->hPrinter(),
                                    2,
                                    (PVOID*)&pJobs,
                                    &cbJobs,
                                    &cJobs );

        if( bStatus ){
            ExecGuard._cbJobHint = cbJobs;

            //
            // Inform the printer that we have new data.
            // vRequestBlockProcess adopts pJobs, so we don't free it here.
            //
            vBlockAdd( cJobs, 0, (HBLOCK)pJobs );
            pJobs = NULL;
        }

        FreeMem( pJobs );

        if( !bStatus ){

            //
            // Failed; delay then reopen.
            //
            goto Fail;
        }
    }

    //
    // Check if the printer needs to be refreshed.
    //
    if( StateVar & TPrinter::kExecRefreshContainer ){

        //
        // Update printer name.
        //
        PPRINTER_INFO_2 pPrinter2 = NULL;
        DWORD cbPrinter2 = kMaxPrinterInfo2;

        TStatusB bStatus( DBG_WARN );

        bStatus DBGCHK = TDataRJob::bGetPrinter( _pDataClient->hPrinter(),
                                                 2,
                                                 (PVOID*)&pPrinter2,
                                                 &cbPrinter2 );

        if( bStatus ){

            //
            // Inform the printer that we have new data.
            // vRequestBlockProcess adopts pPrinter2, so we don't free it here.
            //
            vBlockAdd( kInvalidCountValue, 0, (HBLOCK)pPrinter2 );
            pPrinter2 = NULL;
        }

        FreeMem( pPrinter2 );

        if( !bStatus ){
            goto Fail;
        }

    }

    return StateVar & ~TPrinter::kExecRefreshAll;

Fail:

    //
    // If we get NERR_QNotFound, then this is a masq case where
    // the printer is no longer shared.  Don't bother retrying.
    //
    DWORD dwError = GetLastError();

    if( dwError == NERR_QNotFound ){

        INFO Info;
        Info.dwData = kConnectStatusInvalidPrinterName;

        _pDataClient->vContainerChanged( kContainerConnectStatus, Info );

        return TPrinter::kExecError;
    }

    //
    // !! LATER !!
    //
    // Put error in status bar.
    //
    SPLASSERT( dwError );

    return StateVar | TPrinter::kExecReopen | TPrinter::kExecDelay;
}

/********************************************************************

    UI Thread interaction routines.

********************************************************************/

VOID
TDataRJob::
vBlockProcessImp(
    IN DWORD dwParam1,
    IN DWORD dwParam2,
    IN HBLOCK hBlock ADOPT
    )

/*++

Routine Description:

    Take a job block and update the internal data structure.  This
    function will call back into _pPrinter to refresh the screen.

Arguments:

    dwParam1 - job count

    hBlock - PJOB_INFO_2 block

Return Value:

--*/

{
    UNREFERENCED_PARAMETER( dwParam2 );

    //
    // If dwParam is an invalid count value, then we have printer
    // information.  Else it is job information.
    //
    if( dwParam1 == kInvalidCountValue ){

        PPRINTER_INFO_2 pPrinter2 = (PPRINTER_INFO_2)hBlock;
        INFO Info;

        //
        // Update all printer information.
        //

        //
        // Note: We do not update strServer, because the printer
        // name in PRINTER_INFO_2 already includes the server name!
        //
        Info.pszData = pPrinter2->pPrinterName;
        _pDataClient->vContainerChanged( kContainerName, Info );

        Info.dwData = pPrinter2->Status;
        _pDataClient->vContainerChanged( kContainerStatus, Info );

        Info.dwData = pPrinter2->Attributes;
        _pDataClient->vContainerChanged( kContainerAttributes, Info );

        FreeMem( pPrinter2 );

    } else {

        //
        // Must save the selections since we are deleting and
        // re-adding them.
        //
        _pDataClient->vSaveSelections();

        //
        // No need to grab any critical sections since we are in
        // the UI thread.
        //
        FreeMem( UIGuard._pJobs );
        UIGuard._pJobs = (PJOB_INFO_2)hBlock;
        VData::UIGuard._cItems = dwParam1;

        //
        // Job count is stored in dwParm; pass to vContainerChanged.
        //
        INFO Info;
        Info.dwData = dwParam1;
        _pDataClient->vContainerChanged( kContainerReloadItems, Info );
        _pDataClient->vContainerChanged( kContainerRefreshComplete, kInfoNull );

        _pDataClient->vRestoreSelections();
    }
}

VOID
TDataRJob::
vBlockDelete(
    IN HBLOCK hBlock
    )

/*++

Routine Description:

    Free a Block.  Called when the PostMessage fails and the
    job block needs to be destroyed.

Arguments:

    hBlock - Job block to delete.

Return Value:

--*/

{
    FreeMem( hBlock );
}



/********************************************************************

    TDataRPrinter

********************************************************************/


TDataRPrinter::
TDataRPrinter(
    IN MDataClient* pDataClient
    ) : VDataRefresh( pDataClient, &TDataNPrinter::gFieldTable, kfdwWatch )
{
    ExecGuard._cbPrinterHint = kInitialPrinterHint;
    UIGuard._pPrinters = NULL;

    //
    // Determine whether this is a printer or a server.
    //
    TCHAR szDataSource[kPrinterBufMax];
    LPTSTR pszDataSource = _pDataClient->pszPrinterName( szDataSource );

    _bSinglePrinter = TDataRPrinter::bSinglePrinter( pszDataSource );
}

TDataRPrinter::
~TDataRPrinter(
    VOID
    )
{
    FreeMem( UIGuard._pPrinters );
}

BOOL
TDataRPrinter::
bSinglePrinter(
    LPCTSTR pszDataSource
    )
{
    BOOL bReturn = FALSE;

    //
    // Check if it's a single printer vs. a server.  The only
    // way I can think of doing this is to look for the format
    // "\\server."  This works fine for Win9x downlevel printers
    // however fails for internet connected printers.
    //
    // So adding to the hack we will do a little more checking
    // and look if the printer name has a prfix string of
    // http:// or https://.  So what we are saying is that printer
    // names of this form are considered a masq printers.
    //
    if( pszDataSource )
    {
        bReturn = pszDataSource[0] == TEXT( '\\' ) &&
                  pszDataSource[1] == TEXT( '\\' ) &&
                  _tcschr( &pszDataSource[2], TEXT( '\\' ));

        if( !bReturn )
        {
           bReturn = !_tcsnicmp( pszDataSource, gszHttpPrefix0, _tcslen(gszHttpPrefix0) ) ||
                     !_tcsnicmp( pszDataSource, gszHttpPrefix1, _tcslen(gszHttpPrefix1) );

        }
    }

    return bReturn;
}

/********************************************************************

    Data interface for Refresh.

********************************************************************/

HITEM
TDataRPrinter::
GetItem(
    IN NATURAL_INDEX NaturalIndex
    ) const
{
    SPLASSERT( UIGuard._pPrinters );
    SPLASSERT( NaturalIndex < VData::UIGuard._cItems );

    return (HITEM)&UIGuard._pPrinters[NaturalIndex];
}

HITEM
TDataRPrinter::
GetNextItem(
    IN HITEM hItem
    ) const
{
    SPLASSERT( UIGuard._pPrinters );

    //
    // Requesting first item.
    //
    if( !hItem ){
        SPLASSERT( VData::UIGuard._cItems > 0 );
        return (HITEM)&UIGuard._pPrinters[0];
    }

    PPRINTER_INFO_2 pPrinter2 = (PPRINTER_INFO_2)hItem;
    return (HITEM)( pPrinter2 + 1 );
}

INFO
TDataRPrinter::
GetInfo(
    IN HITEM hItem,
    IN DATA_INDEX DataIndex
    ) const
{
    SPLASSERT( hItem );
    SPLASSERT( DataIndex < _pFieldTable->cFields );

    INFO Info = kInfoNull;
    PPRINTER_INFO_2 pPrinter2 = (PPRINTER_INFO_2)hItem;

    //
    // Translate the index into the appropriate field.
    //
    FIELD Field = _pFieldTable->pFields[DataIndex];
    BOOL bString = FALSE;

    switch( Field ){

    case PRINTER_NOTIFY_FIELD_PRINTER_NAME:
        SPLASSERT( pPrinter2->pPrinterName );

        //
        // Skip the server prefix and extra backslash.
        //
        Info.pszData = pPrinter2->pPrinterName +
                       (pPrinter2->pServerName ? _tcslen( pPrinter2->pServerName ) + 1 : 0);
        break;

    case PRINTER_NOTIFY_FIELD_CJOBS:

        Info.dwData = pPrinter2->cJobs;
        break;

    case PRINTER_NOTIFY_FIELD_ATTRIBUTES:

        Info.dwData = pPrinter2->Attributes;
        break;

    case PRINTER_NOTIFY_FIELD_STATUS:

        Info.dwData = pPrinter2->Status;
        break;

    case PRINTER_NOTIFY_FIELD_COMMENT:

        Info.pszData = pPrinter2->pComment;
        bString = TRUE;
        break;

    case PRINTER_NOTIFY_FIELD_LOCATION:

        Info.pszData = pPrinter2->pLocation;
        bString = TRUE;
        break;

    case PRINTER_NOTIFY_FIELD_DRIVER_NAME:

        Info.pszData = pPrinter2->pDriverName;
        bString = TRUE;
        break;

    case PRINTER_NOTIFY_FIELD_PORT_NAME:

        Info.pszData = pPrinter2->pPortName;
        bString = TRUE;
        break;

    default:

        DBGMSG( DBG_ERROR,
                ( "DataRPrinter.GetInfo: Unimplemented field %d\n", Field ));
        break;
    }

    if( bString && !Info.pszData ){
        Info.pszData = gszNULL;
    }

    return Info;
}

IDENT
TDataRPrinter::
GetId(
    IN HITEM hItem
    ) const
{
    SPLASSERT( hItem );

    return kInvalidIdentValue;
}

NATURAL_INDEX
TDataRPrinter::
GetNaturalIndex(
    IN     IDENT Id,
       OUT PHITEM phItem OPTIONAL
    ) const
{
    UNREFERENCED_PARAMETER( Id );
    UNREFERENCED_PARAMETER( phItem );

    return kInvalidNaturalIndexValue;
}


STATEVAR
TDataRPrinter::
svRefresh(
    IN STATEVAR StateVar
    )

/*++

Routine Description:

    Refresh the printer data object.

Arguments:

Return Value:

--*/

{
    //
    // !! HACK !!
    //
    // Nuke extraneous refreshes by resetting m_shNotify.
    //
    if( !ResetEvent( m_shNotify ))
    {
        DBGMSG( DBG_ERROR, ( "DataRefresh.svRefresh: reset %x failed %d\n",
                static_cast<HANDLE>(m_shNotify), GetLastError( )));
    }

    //
    // Attempt an enum of approximately the same size as last time.
    //
    DWORD cPrinters = 0;
    DWORD cbPrinters = ExecGuard._cbPrinterHint;
    PPRINTER_INFO_2 pPrinters = (PPRINTER_INFO_2)AllocMem( cbPrinters );

    if( pPrinters ){

        TStatusB bStatus;

        if( _bSinglePrinter ){

            cPrinters = 1;
            bStatus DBGCHK = TDataRJob::bGetPrinter( _pDataClient->hPrinter(),
                                                     2,
                                                     (PVOID*)&pPrinters,
                                                     &cbPrinters );


        } else {

            //
            // It's a server, but it's stored in the printer name string
            // since that's where we put the datasource.
            //
            TCHAR szServerBuffer[kPrinterBufMax];
            LPTSTR pszServer = _pDataClient->pszPrinterName( szServerBuffer );

            bStatus DBGCHK = bEnumPrinters( PRINTER_ENUM_NAME,
                                            pszServer,
                                            2,
                                            (PVOID*)&pPrinters,
                                            &cbPrinters,
                                            &cPrinters );
        }

        if( bStatus ){

            ExecGuard._cbPrinterHint = cbPrinters;

            //
            // Inform the printer that we have new data.
            // vRequestBlockProcess adopts pJobs, so we don't free it here.
            //
            vBlockAdd( cPrinters, 0, (HBLOCK)pPrinters );

            return StateVar & ~TPrinter::kExecRefreshAll;

        } else {

            //
            // If we get NERR_QNotFound, then this is a masq case where
            // the printer is no longer shared.  Don't bother retrying.
            //
            DWORD dwError = GetLastError();

            INFO Info;

            if( dwError == ERROR_ACCESS_DENIED ){

                Info.dwData = kConnectStatusAccessDenied;

            } else {

                Info.dwData = kConnectStatusInvalidPrinterName;
            }

            _pDataClient->vContainerChanged( kContainerConnectStatus, Info );

            return TPrinter::kExecError;
        }
    }

    //
    // !! LATER !!
    //
    // Put error in status bar.
    //
    SPLASSERT( GetLastError( ));

    return StateVar | TPrinter::kExecReopen | TPrinter::kExecDelay;
}

/********************************************************************

    UI Thread interaction routines.

********************************************************************/

VOID
TDataRPrinter::
vBlockProcessImp(
    IN DWORD dwParam1,
    IN DWORD dwParam2,
    IN HBLOCK hBlock ADOPT
    )

/*++

Routine Description:

    Take a item block and update the internal data structure.  This
    function will call back into _pPrinter to refresh the screen.

Arguments:

    dwParam1 - Item count

    hBlock - PJOB_INFO_2 block

Return Value:

--*/

{
    UNREFERENCED_PARAMETER( dwParam2 );

    //
    // No need to grab any critical sections since we are in
    // the UI thread.
    //
    FreeMem( UIGuard._pPrinters );
    UIGuard._pPrinters = (PPRINTER_INFO_2)hBlock;
    VData::UIGuard._cItems = dwParam1;

    //
    // Item count is stored in dwParm; pass to vContainerChanged.
    //
    INFO Info;
    Info.dwData = dwParam1;
    _pDataClient->vContainerChanged( kContainerReloadItems, Info );
    _pDataClient->vContainerChanged( kContainerRefreshComplete, kInfoNull );
}

VOID
TDataRPrinter::
vBlockDelete(
    IN HBLOCK hBlock
    )

/*++

Routine Description:

    Free a Block.  Called when the PostMessage fails and the
    Item block needs to be destroyed.

Arguments:

    hBlock - Item block to delete.

Return Value:

--*/

{
    FreeMem( hBlock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\defprn.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1997
All rights reserved.

Module Name:

    defprn.cxx

Abstract:

    Default printer.

Author:

    Steve Kiraly (SteveKi)  06-Feb-1997

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "defprn.hxx"

/********************************************************************

    PrintUI specific default printer manipulation code.

********************************************************************/

DEFAULT_PRINTER
CheckDefaultPrinter(
    IN LPCTSTR pszPrinter OPTIONAL
    )

/*++

Routine Description:

    Determines the default printer status.

Arguments:

    pszPrinter - Check if this printer is the default (optional).

Return Value:

    kNoDefault      - No default printer exists.

    kDefault        - pszPrinter is the default printer.

    kOtherDefault   - Default printer exists, but it's not pszPrinter
                      (or pszPrinter was not passed in).

--*/

{
    DEFAULT_PRINTER bRetval         = kNoDefault;
    DWORD           dwDefaultSize   = kPrinterBufMax;
    TStatusB        bStatus;
    TCHAR           szDefault[kPrinterBufMax];

    //
    // Get the default printer.
    //
    bStatus DBGCHK = GetDefaultPrinter( szDefault, &dwDefaultSize );

    if( bStatus )
    {
        if( pszPrinter )
        {
            //
            // Check for a match using the printer name that 
            // was passed to this routine.
            //
            if( !_tcsicmp( szDefault, pszPrinter ) )   
            {
                bRetval = kDefault;
            }
            else
            {
                //
                // Printer specified by pszPrinter is not the default
                // printer, i.e. some other printer is the default.
                //
                bRetval = kOtherDefault;
            }
        }
        else
        {
            //
            // A specific printer name was not passed therefore the 
            // printer is not the default some other printer is the 
            // default.
            //
            bRetval = kOtherDefault;
        }
    }
    else
    {
        //
        // We could not get the default printer no printer is the 
        // set as the default.
        //
        bRetval = kNoDefault;
    }

    return bRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\detect.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    detect.cxx

Abstract:

    PnP printer autodetection.

Author:

    Lazar Ivanov (LazarI)  May-06-1999

Revision History:

                         May-06-1999 - Created.
    Larry Zhu (LZhu)     Mar-12-2000 - Rewrote PnP detection code.

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "detect.hxx"

#include <initguid.h>
#include <ntddpar.h> // for GUID_PARALLEL_DEVICE
#include <regstr.h>

#if DBG

#define DBGCHKMSG(bShowMessage, MsgAndArgs)    \
{                                              \
    if (bShowMessage)                          \
    {                                          \
        DBGMSG(DBG_ERROR, MsgAndArgs);         \
    }                                          \
}                                              \

#else  // DBG

#define DBGCHKMSG(bShowMessage, MsgAndArgs)

#endif // DBG

/********************************************************************

    PnP private stuff

********************************************************************/
//
// current 1394 printers are enumerated under LPTENUM
//
#define szParallelClassEnumerator               TEXT("LPTENUM")
#define szParallelDot4PrintClassEnumerator      TEXT("DOT4PRT")
#define szUsbPrintClassEnumerator               TEXT("USBPRINT")
#define szInfraRedPrintClassEnumerator          TEXT("IRENUM")

// This timeout is per recommendation of the PnP guys
// 1 second should be enough
#define DELAY_KICKOFF_TIMEOUT           1000 

extern "C" {

//
// config mgr privates
//
DWORD
CMP_WaitNoPendingInstallEvents(
    IN DWORD dwTimeout
    );

}

/********************************************************************

    Global functions

********************************************************************/

#if FALSE // comment out the old enum code
#define szParalelPortDevNodePath                TEXT("Root\\ParallelClass\\0000")
BOOL
PnP_Enum_KickOff(
    VOID
    )
/*++

Routine Description:

    Kicks off the PNP enumeration event over the 
    LPT ports only.

Arguments:

    None

Return Value:

    TRUE  - on success
    FALSE - if a failure occurs

Notes:

--*/
{
    BOOL bReturn;
    DEVINST hLPTDevInst;
    CONFIGRET result;

    //
    // Find the root dev node
    //
    result = CM_Locate_DevNode_Ex( &hLPTDevInst, 
        szParalelPortDevNodePath, CM_LOCATE_DEVNODE_NORMAL, NULL );

    if( result == CR_SUCCESS )
    {
        //
        // Reenumerate from the root of the devnode tree
        //
        result = CM_Reenumerate_DevNode_Ex( hLPTDevInst, CM_REENUMERATE_NORMAL, NULL );

        if( result == CR_SUCCESS )
        {
            bReturn = TRUE;
        }
    }

    return bReturn;
}
#endif // comment out the old enum code

BOOL
PnP_Enum_KickOff(
    VOID
    )
/*++

Routine Description:

    Kicks off the PNP enumeration event.

Arguments:

    None

Return Value:

    TRUE  - on success
    FALSE - if a failure occurs

Notes:

--*/
{
    DWORD   crStatus = CR_DEFAULT;
    DEVINST devRoot  = {0}; 
  
    crStatus = CM_Locate_DevNode(&devRoot, NULL, CM_LOCATE_DEVNODE_NORMAL);    
    DBGCHKMSG((CR_SUCCESS != crStatus), ("CM_Locate_Devnode failed with 0x%x\n", crStatus));

    if (CR_SUCCESS == crStatus) 
    {
        crStatus = CM_Reenumerate_DevNode(devRoot, CM_REENUMERATE_RETRY_INSTALLATION);
        DBGCHKMSG((CR_SUCCESS != crStatus), ("CM_Reenumerate_DevNode failed with 0x%x\n", crStatus));
    }
    
    //
    // There is no point to return CR_XXX code
    //
    SetLastError(CR_SUCCESS == crStatus ? ERROR_SUCCESS : ERROR_INVALID_DATA);
    return CR_SUCCESS == crStatus;    
}

VOID
PnP_Enumerate_Sync( 
    VOID
    )
/*++

Routine Description:

    Enumerates the LPT devices sync.

Arguments:

    None

Return Value:

    None

Notes:

--*/
{
    //
    // Kick off PnP enumeration
    //
    if( PnP_Enum_KickOff( ) )
    {
        for( ;; )
        {
            //
            // We must wait about 1 sec (DELAY_KICKOFF_TIMEOUT) to make sure the enumeration 
            // event has been kicked off completely, so we can wait successfully use the
            // CMP_WaitNoPendingInstallEvents() private API. This is by LonnyM recommendation.
            // This delay also solves the problem with multiple installs like DOT4 printers.
            //
            Sleep( DELAY_KICKOFF_TIMEOUT );

            //
            // Check to see if there are pending install events
            //
            if( WAIT_TIMEOUT != CMP_WaitNoPendingInstallEvents( 0 ) )
                break;

            //
            // Wait untill no more pending install events
            //
            CMP_WaitNoPendingInstallEvents( INFINITE );
        }
    }
}

/********************************************************************

    TPnPDetect - PnP printer detector class

********************************************************************/

TPnPDetect::
TPnPDetect(
    VOID
    ) 
 :
    _bDetectionInProgress( FALSE ),
    _pInfo4Before( NULL ),
    _cInfo4Before( 0 ),
    _hEventDone( NULL )
/*++

Routine Description:

    TPnPDetect constructor

Arguments:

    None

Return Value:

    None

Notes:

--*/
{
}

TPnPDetect::
~TPnPDetect(
    VOID
    )
/*++

Routine Description:

    TPnPDetect destructor

Arguments:

    None

Return Value:

    None

Notes:

--*/
{
    //
    // Check to free memory
    //
    Reset( );
}

typedef bool PI4_less_type(const PRINTER_INFO_4 p1, const PRINTER_INFO_4 p2);
static  bool PI4_less(const PRINTER_INFO_4 p1, const PRINTER_INFO_4 p2)
{
    return (lstrcmp(p1.pPrinterName, p2.pPrinterName) < 0);
}

BOOL 
TPnPDetect::
bKickOffPnPEnumeration(
    VOID
    )
/*++

Routine Description:

    Kicks off PnP enumeration event on the LPT ports.

Arguments:

    None

Return Value:

    TRUE  - on success
    FALSE - if a failure occurs

Notes:

--*/
{
    DWORD cbInfo4Before = 0;
    TStatusB bStatus;

    bStatus DBGNOCHK = FALSE;

    //
    // Check to free memory
    //
    Reset( );

    //
    // Enumerate the printers before PnP enumeration
    //
    bStatus DBGCHK = VDataRefresh::bEnumPrinters( 
        PRINTER_ENUM_LOCAL, NULL, 4, reinterpret_cast<PVOID *>( &_pInfo4Before ), 
        &cbInfo4Before, &_cInfo4Before );

    if( bStatus )
    {
        //
        // Sort out the PRINTER_INFO_4 structures here
        //
        std::sort<PRINTER_INFO_4*, PI4_less_type*>(
            _pInfo4Before, 
            _pInfo4Before + _cInfo4Before, 
            PI4_less);

        //
        // Kick off the PnP enumeration
        //
        _hEventDone = CreateEvent( NULL, TRUE, FALSE, NULL );

        if( _hEventDone )
        {
            HANDLE hEventOut = NULL;
            const HANDLE hCurrentProcess = GetCurrentProcess();
            bStatus DBGCHK = DuplicateHandle( hCurrentProcess,
                                              _hEventDone,
                                              hCurrentProcess,
                                              &hEventOut,
                                              0,
                                              TRUE,
                                              DUPLICATE_SAME_ACCESS );

            if( bStatus )
            {
                //
                // Kick off the enumeration thread.
                //
                DWORD dwThreadId;
                HANDLE hThread = TSafeThread::Create( NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)TPnPDetect::EnumThreadProc,
                    hEventOut,
                    0,
                    &dwThreadId );

                if( hThread )
                {
                    //
                    // We don't need the thread handle any more.
                    //
                    CloseHandle( hThread );

                    //
                    // Detection initiated successfully.
                    //
                    _bDetectionInProgress = TRUE;
                }
                else
                {
                    //
                    // Failed to create the thread. Close the event.
                    //
                    CloseHandle( hEventOut );
                }
            }
        }

        //
        // Check to free the allocated resources if something has failed.
        //
        if( !_bDetectionInProgress )
        {
            Reset();
        }
    }

    return bStatus;
}

BOOL 
TPnPDetect::
bDetectionInProgress(
    VOID
    )
/*++

Routine Description:

    Checks whether there is pending detection/installation 
    process.

Arguments:

    None

Return Value:

    TRUE  - yes there is pending detect/install process.
    FALSE - otherwise.

Notes:

--*/
{
    return _bDetectionInProgress;
}

BOOL 
TPnPDetect::
bFinished(
    DWORD dwTimeout
    )
/*++

Routine Description:

    Checks whether there is no more pending detect/install events
    after the last PnP enumeration event.

Arguments:

    dwTimeout - Time to wait. By default is zero (no wait - just ping)

Return Value:

    TRUE  - on success
    FALSE - if a failure occurs

Notes:

--*/
{
    //
    // Check to see if the enum process has been kicked off at all.
    //
    if( _bDetectionInProgress && _pInfo4Before && _hEventDone )
    {
        //
        // Ping to see whether the PnP detect/install process has finished
        //
        if( WAIT_OBJECT_0 == WaitForSingleObject( _hEventDone, 0 ) )
        {
            _bDetectionInProgress = FALSE;
        }
    }

    //
    // We must check for all the three conditions below as _bDetectionInProgress 
    // may be FALSE, but the enum process has never kicked off. We want to make 
    // sure we are in the case _bDetectionInProgress is set to FALSE after the enum 
    // process is finished.
    //
    return ( !_bDetectionInProgress && _pInfo4Before && _hEventDone );
}

BOOL
TPnPDetect::
bGetDetectedPrinterName( 
    TString *pstrPrinterName 
    )
/*++

Routine Description:

    Enum the printers after the PnP enumeration has finished to 
    check whether new local (LPT) printers have been detected.

Arguments:

    None

Return Value:

    TRUE  - on success
    FALSE - if a failure occurs

Notes:

--*/
{
    TStatusB bStatus;
    bStatus DBGNOCHK = FALSE;

    if( pstrPrinterName && !_bDetectionInProgress && _pInfo4Before )
    {
        //
        // The detection is done here. Enum the printers after the PnP 
        // detect/install to see whether new printer has been detected.
        //
        PRINTER_INFO_4 *pInfo4After     = NULL;
        DWORD           cInfo4After     = 0;
        DWORD           cbInfo4After    = 0;

        bStatus DBGCHK = VDataRefresh::bEnumPrinters( 
            PRINTER_ENUM_LOCAL, NULL, 4, reinterpret_cast<PVOID *>( &pInfo4After ), 
            &cbInfo4After, &cInfo4After );

        if( bStatus && cInfo4After > _cInfo4Before )
        {
            for( UINT uAfter = 0; uAfter < cInfo4After; uAfter++ )
            {
                if( !std::binary_search<PRINTER_INFO_4*, PRINTER_INFO_4, PI4_less_type*>(
                        _pInfo4Before, 
                        _pInfo4Before + _cInfo4Before, 
                        pInfo4After[uAfter],
                        PI4_less) )
                {
                    //
                    // This printer hasn't been found in the before list
                    // so it must be the new printer detected. I know this is partial 
                    // solution because we are not considering the case we detect more 
                    // than one local PnP printer, but it is not our intention for now.
                    //
                    bStatus DBGCHK = pstrPrinterName->bUpdate( pInfo4After[uAfter].pPrinterName );
                    break;
                }
            }
        }
        else
        {
            bStatus DBGNOCHK = FALSE;
        }

        FreeMem( pInfo4After );
    }

    return bStatus;
}

DWORD WINAPI 
TPnPDetect::
EnumThreadProc(
    LPVOID lpParameter
    )
/*++

Routine Description:

    Invokes the PnP enumeration routine

Arguments:

    lpParameter - Standard (see MSDN)

Return Value:

    Standard (see MSDN)

Notes:

--*/
{
    DWORD    dwStatus     = EXIT_FAILURE;
    HANDLE   hEventDone   = (HANDLE )lpParameter;

    dwStatus = hEventDone ? ERROR_SUCCESS : EXIT_FAILURE;

    //
    // If there is a NULL driver (meaning no driver) associated with a devnode, 
    // we want to set CONFIGFLAG_FINISH_INSTALL flag so that PnP manager will 
    // try to reinstall a driver for this device.
    //
    if (ERROR_SUCCESS == dwStatus)
    {
        dwStatus = ProcessDevNodesWithNullDriversAll();
    }

    //
    // Invokes the enumeration routine. It executes syncroniously.
    //
    if (ERROR_SUCCESS == dwStatus) 
    {
        (void)PnP_Enumerate_Sync();
    }

    //
    // Notify the client we are done.
    //
    if (hEventDone)
    {
        SetEvent( hEventDone );

        //
        // We own the event handle, so we must close it now.
        //
        CloseHandle( hEventDone );
    }
    
    return dwStatus;
}

DWORD WINAPI 
TPnPDetect::
ProcessDevNodesWithNullDriversForOneEnumerator(
    IN     PCTSTR pszEnumerator
    )
/*++

Routine Description:

    This routine enumerates devnodes of one enumerator and it sets 
    CONFIGFLAG_FINISH_INSTALL for devnode that has no driver (or NULL driver)
    so that this device will be re-detected by PnP manager.

Arguments:

    pszEnumerator        - The enumerator for a particular bus, this can be 
                           "LPTENUM", "USBPRINT", "DOT4PRT" etc.

Return Value:

    Standard (see MSDN)

Notes:

*/
{
    DWORD           dwStatus         = ERROR_SUCCESS;
    HDEVINFO        hDevInfoSet      = INVALID_HANDLE_VALUE;
    TCHAR           buffer[MAX_PATH] = {0};
    DWORD           dwDataType       = REG_NONE;
    SP_DEVINFO_DATA devInfoData      = {0};
    DWORD           cbRequiredSize   = 0;
    DWORD           dwConfigFlags    = 0;

    hDevInfoSet = SetupDiGetClassDevs(NULL, pszEnumerator, NULL, DIGCF_ALLCLASSES);    
    dwStatus = (INVALID_HANDLE_VALUE != hDevInfoSet) ? ERROR_SUCCESS : GetLastError();

    if (ERROR_SUCCESS == dwStatus)
    {
        devInfoData.cbSize = sizeof(devInfoData);       
        for (DWORD cDevIndex = 0; ERROR_SUCCESS == dwStatus; cDevIndex++)
        {    
            dwStatus = SetupDiEnumDeviceInfo(hDevInfoSet, cDevIndex, &devInfoData) ? ERROR_SUCCESS : GetLastError(); 
            
            //
            // When SPDRP_DRIVER is not present, this devnode is associated 
            // with no driver or, in the other word, NULL driver 
            //
            // For devnodes with NULL drivers, we will set CONFIGFLAG_FINISH_INSTALL 
            // so that the device will be re-detected
            //
            // Notes on the error code: internally SetupDiGetDeviceRegistryProperty 
            // first returns CR_NO_SUCH_VALUE, but this error code is remapped 
            // to ERROR_INVALID_DATA by setupapi
            //
            if (ERROR_SUCCESS == dwStatus) 
            {
                dwStatus = SetupDiGetDeviceRegistryProperty(hDevInfoSet, 
                                                            &devInfoData, 
                                                            SPDRP_DRIVER, 
                                                            &dwDataType,
                                                            reinterpret_cast<PBYTE>(buffer), 
                                                            sizeof(buffer), &cbRequiredSize) ? ERROR_SUCCESS : GetLastError();

                if (ERROR_INVALID_DATA == dwStatus) 
                {
                    dwConfigFlags = 0;
                    dwStatus = SetupDiGetDeviceRegistryProperty(hDevInfoSet,
                                                                &devInfoData,
                                                                SPDRP_CONFIGFLAGS,
                                                                &dwDataType,
                                                                reinterpret_cast<PBYTE>(&dwConfigFlags),
                                                                sizeof(dwConfigFlags),
                                                                &cbRequiredSize) ? (REG_DWORD == dwDataType ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER) : GetLastError();                   

                    if ((ERROR_SUCCESS == dwStatus) && (!(dwConfigFlags & CONFIGFLAG_FINISH_INSTALL))) 
                    {
                        dwConfigFlags |= CONFIGFLAG_FINISH_INSTALL;
                        dwStatus = SetupDiSetDeviceRegistryProperty(hDevInfoSet,
                                                                    &devInfoData,
                                                                    SPDRP_CONFIGFLAGS,
                                                                    reinterpret_cast<PBYTE>(&dwConfigFlags),
                                                                    sizeof(dwConfigFlags)) ? ERROR_SUCCESS : GetLastError();
                    }
                }
            }
        }

        dwStatus = ERROR_NO_MORE_ITEMS == dwStatus ? ERROR_SUCCESS : dwStatus; 
    }
    else 
    {  
        dwStatus = ERROR_INVALID_DATA == dwStatus ? ERROR_SUCCESS : dwStatus; 
    }

    if (INVALID_HANDLE_VALUE != hDevInfoSet)
    {
        SetupDiDestroyDeviceInfoList(hDevInfoSet);
    }

    return dwStatus;
}

DWORD WINAPI 
TPnPDetect::
ProcessDevNodesWithNullDriversAll(
    VOID
    )
/*++

Routine Description:

    This routine enumerates a subset of devnodes and it sets 
    CONFIGFLAG_FINISH_INSTALL for devnodes that have no driver (or NULL driver)
    so that these devices will be re-detected by PnP manager.

Arguments:

    None
    
Return Value:

    Standard (see MSDN)

Notes:

*/
{
    DWORD dwStatus = ERROR_SUCCESS;
        
    //
    // The following enumerators can have printers attached
    //
    static PCTSTR acszEnumerators[] =
    {
        szParallelClassEnumerator,
        szParallelDot4PrintClassEnumerator,
        szUsbPrintClassEnumerator,
        szInfraRedPrintClassEnumerator,
    };

    for (UINT i = 0; (ERROR_SUCCESS == dwStatus) && (i < COUNTOF(acszEnumerators)); i++)
    {
        dwStatus = ProcessDevNodesWithNullDriversForOneEnumerator(acszEnumerators[i]);
    }

    return dwStatus;
}

VOID
TPnPDetect::
Reset(
    VOID
    )
/*++

Routine Description:

    Resets the PnP detector class, so you can kick off the 
    PnP enumeration event again. Release the memory allocated
    from calling EnumPrinters() before kicking off PnP enum.

Arguments:

    None

Return Value:

    None

Notes:

--*/
{
    if( _hEventDone )
    {
        CloseHandle( _hEventDone );
        _hEventDone = NULL;
    }

    if( _pInfo4Before )
    {
        FreeMem( _pInfo4Before );
        _pInfo4Before = NULL;
    }

    _bDetectionInProgress = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\docdata.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1998
All rights reserved.

Module Name:

    docdata.cxx

Abstract:

    Document Data Property Sheet Data Set

Author:

    Steve Kiraly (SteveKi)  10/25/95

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "docdata.hxx"

/*++

Routine Name:

    TDocumentData

Routine Description:

    Document data property sheet constructor.

Arguments:

    pszPrinterName  - Name of printer or queue where jobs reside.
    JobId           - Job id to display properties of.
    iCmdShow        - Show dialog style.
    lParam          - Indicates which page to display initialy

Return Value:

    Nothing.

--*/

TDocumentData::
TDocumentData(
    IN LPCTSTR  pszPrinterName,
    IN IDENT    JobId,
    IN INT      iCmdShow,
    IN LPARAM   lParam
    ) : MSingletonWin( pszPrinterName ),
        _JobId( JobId ),
        _iCmdShow( iCmdShow ),
        _strNotifyName( TEXT( "" ) ),
        _uStartPage( (UINT)lParam ),
        _bIsDataStored( FALSE ),
        _bErrorSaving( TRUE ),
        _bAdministrator( TRUE ),
        _pJobInfo( NULL ),
        _hPrinter( NULL ),
        _dwAccess( 0 )
{

//    DBGMSG( DBG_TRACE, ( "TDocumentData::ctor\n") );

    _bValid = MSingletonWin::bValid() && VALID_OBJ( _strNotifyName );
}

/*++

Routine Name:

    ~TDocumentData

Routine Description:

    Stores the document data back to the server.

Arguments:

    None.

Return Value:

    Nothing.

--*/

TDocumentData::
~TDocumentData(
    VOID
    )
{
//    DBGMSG( DBG_TRACE, ( "TDocumentData::dtor\n") );

    //
    // If we have allocated the job info structure, release it.
    //
    if( _pJobInfo ){
        delete [] _pJobInfo;
    }

    //
    // If we have valid printer handle, close printer.
    //
    if( _hPrinter ){
        ClosePrinter( _hPrinter );
    }
}

/*++

Routine Name:

    bLoad

Routine Description:

    Loads all the document property specific data.

Arguments:

    None.

Return Value:

    TRUE - Document data loaded successfully,
    FALSE - if document data was not loaded.

--*/

BOOL
TDocumentData::
bLoad(
    VOID
    )
{

//    DBGMSG( DBG_TRACE, ( "TDocumentData::bLoad\n") );

    //
    // Open the specified printer.
    //
    TStatus Status( DBG_WARN );

    Status DBGCHK = TPrinter::sOpenPrinter( _strPrinterName, &_dwAccess, &_hPrinter );

    if( Status ){
        return FALSE;
    }

    //
    // Release any old job information.
    //
    if( _pJobInfo ) {
        delete _pJobInfo;
    }

    //
    // Get the job specific information.
    //
    BOOL bStatus;

    bStatus = bGetJobInfo( _hPrinter, _JobId, &_pJobInfo );

    if( !bStatus ){
        return FALSE;
    }

    //
    // Make a copy of the job info - apply button.
    //
    bStatus = _JobInfo.bUpdate( _pJobInfo );

    if( !bStatus ) {
        return FALSE;
    }

    return TRUE;
}

/*++

Routine Name:

    bStore

Routine Description:

    Stores the document data from back to the printer system.

Arguments:

    None.

Return Value:

    TRUE - Document data stored successfully,
    FALSE - if document data was not stored.

--*/

BOOL
TDocumentData::
bStore(
    VOID
    )
{
    SPLASSERT( _JobId );
    SPLASSERT( _pJobInfo );
    SPLASSERT( _hPrinter );

//    DBGMSG( DBG_TRACE, ( "TDocumentData::bStore\n") );

    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;

    //
    // Only do a set job is the data has changed.
    //
    if( bCheckForChange() )
    {
        //
        // Attempt to set the document data.
        //
        bStatus DBGCHK = bSetJobInfo( _hPrinter, _JobId, _pJobInfo );
        
        if( bStatus ) {
            //
            // Update the copy of the job info - apply button.
            //
            (VOID)_JobInfo.bUpdate( _pJobInfo );
        }

        //
        // Indicate the data has now been stored.
        //
        _bIsDataStored = TRUE;
    }

    return bStatus;

}


/*++

Routine Name:

    bGetJobInfo

Routine Description:

    Read the job information from the specified printer.

Arguments:

    hPrinter    - Opened printer handle.
    JobId       - Job Id of job to get info level 2 information
    pJob        - Pointer where to return pointer to job info level 2.

Return Value:

    TRUE valid information and pJop points to JOB_INFO_2 structure.
    FALSE failure reading job information.

--*/
BOOL
TDocumentData::
bGetJobInfo(
    HANDLE       hPrinter,
    DWORD        JobId,
    LPJOB_INFO_2 *xpJob
    )
{
    DWORD cbNeeded      = 0;
    BOOL  bStatus       = FALSE;
    LPJOB_INFO_2 pJob   = NULL;

    SPLASSERT( JobId );

//    DBGMSG( DBG_TRACE, ( "TDocumentData::bGetJobInfo\n") );

    //
    // Attempt to retrieve the buffer needed for the job info.
    //
    if( !GetJob( hPrinter, JobId, 2, NULL, 0, &cbNeeded ) ){

        //
        // If error is too small buffer contine.
        //
        if( GetLastError() == ERROR_INSUFFICIENT_BUFFER ){

            //
            // Allocate job info buffer
            //
            pJob = (LPJOB_INFO_2)new BYTE [cbNeeded];

            //
            // If buffer allocated
            //
            if( pJob ){
                //
                // Fill in the job info buffer.
                //
                if( GetJob( hPrinter, JobId, 2, (LPBYTE)pJob, cbNeeded, &cbNeeded ) ){
                    bStatus = TRUE;
                }

            //
            // Buffer allocation failure.
            //
            } else {
                bStatus = FALSE;
            }

        //
        // Some other get job error occurred.
        //
        } else {
            bStatus = FALSE;
        }
    }

    //
    // If error occurred clean up.
    //
    if( !bStatus ){

        if( pJob ){
            delete [] pJob;
        }

    //
    // Success copy back the job info buffer.
    //
    } else {
        *xpJob = pJob;
    }

    return bStatus;

}

/*++

Routine Name:

    bSetJobInfo

Routine Description:

    Write the job informationto the specified printer.

Arguments:

    hPrinter    - Opened printer handle.
    JobId       - Job Id of job to get info level 2 information
    pJob        - Pointer where to return pointer to job info level 2.

Return Value:

    TRUE if job informaton was set, FALSE error writing job information.

--*/
BOOL
TDocumentData::
bSetJobInfo(
    HANDLE       hPrinter,
    DWORD        JobId,
    LPJOB_INFO_2 pJob
)
{

//   DBGMSG( DBG_TRACE, ( "TDocumentData::bSetJobInfo\n") );

    //
    // Attempt to set the job information.
    //
    return SetJob( hPrinter, JobId, 2, (LPBYTE)pJob, 0 );

}

/*++

Routine Name:

    bCheckForChange

Routine Description:

    Checks if anything changed on the dialog.

Arguments:

    None.

Return Value:

    FALSE something changed, TRUE no change.

--*/
BOOL
TDocumentData::
bCheckForChange(
    VOID
    ) 
{
    if( !_tcscmp( _strNotifyName, _JobInfo._strNotifyName )   &&
         _pJobInfo->Priority  == _JobInfo._dwPriority         &&
         _pJobInfo->StartTime == _JobInfo._dwStartTime        &&
         _pJobInfo->UntilTime == _JobInfo._dwUntilTime  )
    {
        return FALSE;
    }

#if DBG
    DBGMSG( DBG_TRACE, ("Item changed:\n" ));

    if( _tcscmp( _strNotifyName, _JobInfo._strNotifyName ) )
        DBGMSG( DBG_TRACE, ("NotifyName:   "TSTR " " TSTR "\n", (LPCTSTR)_strNotifyName,   (LPCTSTR)_JobInfo._strNotifyName ));

    if( _pJobInfo->Priority != _JobInfo._dwPriority )
        DBGMSG( DBG_TRACE, ("Priority:   %x %x\n",  _pJobInfo->Priority, _JobInfo._dwPriority ));

    if( _pJobInfo->StartTime != _JobInfo._dwStartTime )
        DBGMSG( DBG_TRACE, ("StartTime:   %x %x\n",  _pJobInfo->StartTime, _JobInfo._dwStartTime ));

    if( _pJobInfo->UntilTime != _JobInfo._dwUntilTime )
        DBGMSG( DBG_TRACE, ("UntilTime:   %x %x\n",  _pJobInfo->UntilTime, _JobInfo._dwUntilTime ));
#endif

    return TRUE;
}

/********************************************************************

    Job info class used for the apply button.

********************************************************************/

TDocumentData::TJobInfo::
TJobInfo(
    VOID
    ) : _dwPriority( 0 ),
        _dwStartTime( 0 ),
        _dwUntilTime( 0 )
{
}

TDocumentData::TJobInfo::
~TJobInfo(
    VOID
    )
{
}

BOOL
TDocumentData::TJobInfo::
bUpdate(
    IN LPJOB_INFO_2 pJobInfo
    )
{
    SPLASSERT( pJobInfo );

    TStatusB bStatus; 
    bStatus DBGNOCHK = FALSE;

    if( pJobInfo ) {

        bStatus DBGCHK = _strNotifyName.bUpdate( pJobInfo->pNotifyName );

        _dwPriority   = pJobInfo->Priority;
        _dwStartTime  = pJobInfo->StartTime;
        _dwUntilTime  = pJobInfo->UntilTime;
    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\debug.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    debug.h

Abstract:

    PrintUI core debugging macros/tools.

Author:

    Lazar Ivanov (LazarI)  Jul-05-2000

Revision History:

--*/

#ifndef _DEBUG_H
#define _DEBUG_H

// open C code brace
#ifdef __cplusplus
extern "C" {
#endif

///////////////////////
// core debug macros &
// functions
//

#define DBG_NONE      0x0000
#define DBG_INFO      0x0001
#define DBG_WARN      0x0002
#define DBG_WARNING   0x0002
#define DBG_ERROR     0x0004
#define DBG_TRACE     0x0008
#define DBG_SECURITY  0x0010
#define DBG_EXEC      0x0020
#define DBG_PORT      0x0040
#define DBG_NOTIFY    0x0080
#define DBG_PAUSE     0x0100

#define DBG_THREADM   0x0400
#define DBG_MIN       0x0800
#define DBG_TIME      0x1000
#define DBG_FOLDER    0x2000
#define DBG_NOHEAD    0x8000

#if DBG

VOID
_DbgSingleThreadReset(
    const DWORD *pdwThreadId
    );

VOID
_DbgSingleThread(
    const DWORD *pdwThreadId
    );

VOID
_DbgSingleThreadNot(
    const DWORD *pdwThreadId
    );

VOID
_DbgMsg(
    LPCSTR pszMsgFormat,
    ...
    );

VOID
_DbgWarnInvalid(
    PVOID pvObject,
    UINT uDbg,
    UINT uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA
    );

HRESULT
_DbgInit(
    VOID
    );

HRESULT
_DbgDone(
    VOID
    );

VOID
_DbgBreak(
    VOID
    );

#define DBG_PRINT_MASK      0xffff
#define DBG_BREAK_SHIFT     16

#define DBG_PRINT(x) (x)
#define DBG_BREAK(x) (((x) << DBG_BREAK_SHIFT)|(x))

#ifndef MODULE
#define MODULE "PRINTUI:"
#endif

extern DWORD MODULE_DEBUG;
#define MODULE_DEBUG_INIT(printMask, breakMask) \
    (DBG_PRINT(printMask) | DBG_BREAK(breakMask))

#ifdef UNICODE
#define TSTR "%ws"
#else
#define TSTR "%s"
#endif

#define DBGSTR(str) \
    ((str) ? (str) : TEXT("(NULL)"))

#define DBGMSG(Level, MsgAndArgs)                   \
do                                                  \
{                                                   \
    if( ( (Level) & 0xFFFF ) & MODULE_DEBUG ){      \
        _DbgMsg MsgAndArgs;                         \
    }                                               \
    if( ( (Level) << 16 ) & MODULE_DEBUG )          \
        _DbgBreak();                                \
}                                                   \
while (FALSE)                                       \

#define SPLASSERT(expr)                                                             \
do                                                                                  \
{                                                                                   \
    if (!(expr))                                                                    \
    {                                                                               \
        _DbgMsg("Failed: %s\nLine %d, %s\n", #expr, __LINE__, __FILE__);            \
        _DbgBreak();                                                                \
    }                                                                               \
}                                                                                   \
while (FALSE)                                                                       \

#define SINGLETHREAD_VAR(var) \
    DWORD dwSingleThread_##var;

#define SINGLETHREAD(var) \
    _DbgSingleThread(&dwSingleThread_##var);

#define SINGLETHREADNOT(var) \
    _DbgSingleThreadNot(&dwSingleThread_##var);

#define SINGLETHREADRESET(var) \
    _DbgSingleThreadReset(&dwSingleThread_##var);

#define VALID_PTR(x)                                                \
    ((( x ) && (( x )->bValid( ))) ?                                \
        TRUE :                                                      \
        ( _DbgWarnInvalid( (PVOID)(x), MODULE_DEBUG, __LINE__, __FILE__, MODULE ), FALSE ))

#define VALID_OBJ(x)                                                \
    ((( x ).bValid( )) ?                                            \
        TRUE :                                                      \
        ( _DbgWarnInvalid( (PVOID)&(x), MODULE_DEBUG, __LINE__, __FILE__, MODULE ), FALSE ))

#define VALID_BASE(x)                                               \
    (( x::bValid( )) ?                                              \
        TRUE :                                                      \
        ( _DbgWarnInvalid( (PVOID)this, MODULE_DEBUG, __LINE__, __FILE__, MODULE ), FALSE ))

#else // DBG not defined - expand all debug code appropriately (i.e. to nothing)

#define MODULE_DEBUG_INIT(printMask, breakMask)
#define DBGMSG(Level, MsgAndArgs)
#define SPLASSERT(exp)
#define SINGLETHREAD_VAR(var)
#define SINGLETHREAD(var)
#define SINGLETHREADNOT(var)
#define SINGLETHREADRESET(var)

#define VALID_PTR(x) \
    (( x ) && (( x )->bValid()))
#define VALID_OBJ(x) \
    (( x ).bValid())
#define VALID_BASE(x) \
    ( x::bValid( ))

#endif // DBG

// close C code brace
#ifdef __cplusplus
}
#endif

#endif // _DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\docdef.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1998
All rights reserved.

Module Name:

    docdef.cxx

Abstract:

    Document defaults

Author:

    Albert Ting (AlbertT)  29-Sept-1995

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "time.hxx"
#include "psetup.hxx"
#include "drvsetup.hxx"
#include "instarch.hxx"
#include "portslv.hxx"
#include "dsinterf.hxx"
#include "prtprop.hxx"
#include "propmgr.hxx"
#include "docdef.hxx"

/********************************************************************

    Public interface to this module.

********************************************************************/

VOID
vDocumentDefaultsWOW64(
    IN HWND     hwnd,
    IN LPCTSTR  pszPrinterName,
    IN INT      nCmdShow,
    IN LPARAM   lParam
    )

/*++

Routine Description:

    WOW64 version. see vDocumentDefaults below.

Arguments:

    see vDocumentDefaults below.

Return Value:

--*/

{
    //
    // This function potentially may load the driver UI so we call a private API 
    // exported by winspool.drv, which will RPC the call to a special 64 bit surrogate 
    // process where the 64 bit driver can be loaded.
    //
    CDllLoader dll(TEXT("winspool.drv"));
    ptr_PrintUIDocumentDefaults pfnPrintUIDocumentDefaults = 
        (ptr_PrintUIDocumentDefaults )dll.GetProcAddress(ord_PrintUIDocumentDefaults);

    if( pfnPrintUIDocumentDefaults )
    {
        pfnPrintUIDocumentDefaults( hwnd, pszPrinterName, nCmdShow, lParam );
    }
}

VOID
vDocumentDefaultsNative(
    IN HWND     hwnd,
    IN LPCTSTR  pszPrinterName,
    IN INT      nCmdShow,
    IN LPARAM   lParam
    )

/*++

Routine Description:

    Native version. see vDocumentDefaults below.

Arguments:

    see vDocumentDefaults below.

Return Value:

--*/

{
    (VOID)dwDocumentDefaultsInternal( hwnd,
                                      pszPrinterName,
                                      nCmdShow,
                                      LOWORD( lParam ),
                                      HIWORD( lParam ),
                                      FALSE );
}

VOID
vDocumentDefaults(
    IN HWND     hwnd,
    IN LPCTSTR  pszPrinterName,
    IN INT      nCmdShow,
    IN LPARAM   lParam
    )

/*++

Routine Description:

    Public entrypoint to bring up document defaults.

Arguments:

    hwnd - Parent hwnd.

    pszPrinterName - Printer name.

    nCmdShow - Show command.

    lParam - lParam, currently unused.

Return Value:

--*/

{
    if( IsRunningWOW64() )
    {
        vDocumentDefaultsWOW64( hwnd, pszPrinterName, nCmdShow, lParam );
    }
    else
    {
        vDocumentDefaultsNative( hwnd, pszPrinterName, nCmdShow, lParam );
    }
}

DWORD
dwDocumentDefaultsInternal(
    IN HWND     hwnd,
    IN LPCTSTR  pszPrinterName,
    IN INT      nCmdShow,
    IN DWORD    dwSheet,
    IN BOOL     bModal,
    IN BOOL     bGlobal
    )
/*++

Routine Description:

    Private internal entry point to bring up document defaults.

Arguments:

    hwnd - Parent hwnd.

    pszPrinterName - Printer name.

    nCmdShow - Show command.

    dwSheet - Sheet index of initial sheet to display.

    bModal - Display modal version of dialog.

Return Value:

    ERROR_SUCCESS if dialog displayed, GetLastError() on error.

--*/

{
    //
    // Construct the printer data.
    //
    TPrinterData* pPrinterData = new TPrinterData( pszPrinterName,
                                                   nCmdShow,
                                                   NULL,
                                                   dwSheet,
                                                   hwnd,
                                                   bModal );

    if( !VALID_PTR( pPrinterData )){
        goto Fail;
    }

    //
    // Set the Global dev mode flag.
    //
    pPrinterData->bGlobalDevMode() = bGlobal;

    //
    // If dialog is modal.
    //
    if( bModal ){
        TDocumentDefaultPropertySheetManager::iDocumentDefaultsProc( pPrinterData );
        return ERROR_SUCCESS;

    }

    //
    // Create the thread which handles the UI.  vPrinterPropPages adopts
    // pPrinterData.
    //
    DWORD dwIgnore;
    HANDLE hThread;

    hThread = TSafeThread::Create( NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)TDocumentDefaultPropertySheetManager::iDocumentDefaultsProc,
                                   pPrinterData,
                                   0,
                                   &dwIgnore );

    if( !hThread ){
        goto Fail;
    }

    CloseHandle( hThread );

    return ERROR_SUCCESS;

Fail:

    if( !pPrinterData ){
        vShowResourceError( hwnd );

    } else {
        iMessage( hwnd,
                  IDS_ERR_DOC_PROP_TITLE,
                  IDS_ERR_DOCUMENT_PROP,
                  MB_OK|MB_ICONSTOP,
                  kMsgGetLastError,
                  NULL );
    }

    delete pPrinterData;

    return ERROR_ACCESS_DENIED;
}

/********************************************************************

    Private support routines.

********************************************************************/

INT
TDocumentDefaultPropertySheetManager::
iDocumentDefaultsProc(
    IN TPrinterData* pPrinterData ADOPT
    )

/*++

Routine Description:

    Bring up the document defaults dialog.

Arguments:

    pPrinterData - Data about the printer.

Return Value:

--*/

{
    DBGMSG( DBG_TRACE, ( "iDocumentDefaultsProc\n") );

    //
    // Increment our reference count.
    //
    pPrinterData->vIncRef();

    //
    // Set the pidl type for the correct dialog type.  The
    // all users document defaults and the my document defaults
    // are the same dialog just started differently.
    //
    DWORD dwPidlType = pPrinterData->bGlobalDevMode() ? PRINTER_PIDL_TYPE_ALL_USERS_DOCDEF : PRINTER_PIDL_TYPE_DOCUMENTDEFAULTS;

    //
    // Register this property sheet window.
    //
    BOOL bStatus = pPrinterData->bRegisterWindow( dwPidlType );

    if( bStatus ){

        //
        // Check if the window is already present.  If it is, then
        // exit immediately.
        //
        if( pPrinterData->bIsWindowPresent() ){
            DBGMSG( DBG_TRACE, ( "iDocumentDefaultsProc: currently running.\n" ) );
            bStatus = FALSE;
        }

    }

    if( bStatus ){

        //
        // Load the printer data.
        //
        bStatus = pPrinterData->bLoad();

        if( !bStatus ){

            iMessage( NULL,
                      IDS_ERR_DOC_PROP_TITLE,
                      IDS_ERR_DOCUMENT_PROP,
                      MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
                      kMsgGetLastError,
                      NULL );
        } else {

            //
            // Create the ducument property sheet windows.
            //
            TDocumentDefaultPropertySheetManager DocDefPropSheetManger( pPrinterData );

            //
            // Were the document windows create
            //
            if( !VALID_OBJ( DocDefPropSheetManger ) ){
                vShowResourceError( pPrinterData->hwnd() );
                bStatus = FALSE;
            }

            //
            // If we do not have access, don't bring up the
            // device sheets with incorrect dev mode data.  Just
            // inform the use they don't have access.
            //
            if( pPrinterData->bNoAccess( ) ){

                SetLastError( ERROR_ACCESS_DENIED );

                iMessage( pPrinterData->hwnd(),
                          IDS_ERR_DOC_PROP_TITLE,
                          IDS_ERR_DOCUMENT_PROP,
                          MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
                          kMsgGetLastError,
                          NULL );

                bStatus = FALSE;
            }

            //
            // Display the property pages.
            //
            if( bStatus ){
                if( !DocDefPropSheetManger.bDisplayPages( pPrinterData->hwnd() ) ){
                    vShowResourceError( pPrinterData->hwnd() );
                    bStatus = FALSE;
                }
            }
        }
    }

    //
    // Ensure we release the printer data.
    //
    pPrinterData->cDecRef();

    return bStatus;
}

/********************************************************************

    Document Default Property Sheet Manager.

********************************************************************/

/*++

Routine Description:

    Document default property sheet manager

Arguments:

    pPrinterData - PrinterData to display.

Return Value:

    TRUE - Success, FALSE - failure.

--*/

TDocumentDefaultPropertySheetManager::
TDocumentDefaultPropertySheetManager(
    TPrinterData *pPrinterData
    ) : _pPrinterData( pPrinterData )
{
    DBGMSG( DBG_TRACE, ( "TDocumentDefaultPropertySheetManager ctor\n") );
}

TDocumentDefaultPropertySheetManager::
~TDocumentDefaultPropertySheetManager(
    )
{
    DBGMSG( DBG_TRACE, ( "TDocumentDefaultPropertySheetManager dtor\n") );
}

BOOL
TDocumentDefaultPropertySheetManager::
bValid(
    VOID
    )
{
    return _pPrinterData != NULL;
}

/*++

Routine Name:

    bBuildPages

Routine Description:

    Builds the document property windows.

Arguments:

    None - class specific.

Return Value:

    TRUE pages built ok, FALSE failure building pages.

--*/

BOOL
TDocumentDefaultPropertySheetManager::
bBuildPages(
    IN PPROPSHEETUI_INFO pCPSUIInfo
    )
{
    DBGMSG( DBG_TRACE, ( "TDocumentDefaultPropertySheetManager::bBuildPages\n") );

    BOOL bStatus = TRUE;

    //
    // If we have a null dev mode here, get printer must not have a dev mode
    // associated to this printer ( this should not happen ), then get the
    // default devmode.
    //
    if( !_pPrinterData->pDevMode() )
    {
        bStatus = VDataRefresh::bGetDefaultDevMode( _pPrinterData->hPrinter(),
                                                    (LPTSTR)(LPCTSTR)_pPrinterData->strPrinterName(),
                                                    &_pPrinterData->_pDevMode,
                                                    TRUE );
    }

    if( bStatus )
    {
        //
        // Set the default activation context to be V6 prior calling into
        // compstui to create the pages. This will force V6 context unless
        // the callbacks which create the compstui pages specify otherwise
        // on a per page basis.
        //
        bStatus = (BOOL)pCPSUIInfo->pfnComPropSheet(
                pCPSUIInfo->hComPropSheet, 
                CPSFUNC_SET_FUSION_CONTEXT, 
                reinterpret_cast<LPARAM>(g_hActCtx),
                static_cast<LPARAM>(0));

        if( bStatus )
        {
            //
            // Set the default dev mode flags.
            //
            DWORD dwFlag = DM_IN_BUFFER | DM_OUT_BUFFER | DM_PROMPT | DM_USER_DEFAULT;

            ZeroMemory( &_dph, sizeof( _dph ) );

            _dph.cbSize         = sizeof( _dph );
            _dph.hPrinter       = _pPrinterData->hPrinter();
            _dph.pszPrinterName = (LPTSTR)(LPCTSTR)_pPrinterData->strPrinterName();
            _dph.pdmOut         = _pPrinterData->pDevMode();
            _dph.pdmIn          = _pPrinterData->pDevMode();
            _dph.fMode          = dwFlag;

            //
            // Tell compstui to load the driver and start the ui.
            //
            if( pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                             CPSFUNC_ADD_PFNPROPSHEETUI,
                                             (LPARAM)DocumentPropertySheets,
                                             (LPARAM)&_dph ) <= 0 )
            {
                DBGMSG( DBG_TRACE, ( "CPSFUNC_ADD_PFNPROPSHEETUI failed.\n") );
                bStatus = FALSE;
            }
        }
    } 
    else 
    {
        DBGMSG( DBG_TRACE, ( "Failed to allocate devmode buffer with %d.\n", GetLastError () ) );
        bStatus = FALSE;
    }

    return bStatus;
}


/*++

Routine Name:

    bCreatePropertySheetTitle.

Routine Description:

    Creates the property sheet title.

Arguments:

   Nothing.

Return Value:

   TRUE success, FALSE error occurred.

--*/
BOOL
TDocumentDefaultPropertySheetManager::
bCreateTitle(
    VOID
    )
{
    //
    // Create the formatted property sheet title.
    //
    TStatusB bStatus;
    TString strPostFix;
    TCHAR szBuffer[kStrMax+kPrinterBufMax];
    UINT nSize = COUNTOF( szBuffer );

    //
    // Create the printer friendly name.
    //
    bStatus DBGCHK = ConstructPrinterFriendlyName( _pPrinterData->strPrinterName(), szBuffer, &nSize );

    //
    // Change the title post fix based on whether we are displaying
    // the per user or per printer document defaults settings.
    //
    if( _pPrinterData->bGlobalDevMode() )
    {
        bStatus DBGCHK = strPostFix.bLoadString( ghInst, IDS_PRINTER_PREFERENCES_DEFAULT );
    }
    else
    {
        bStatus DBGCHK = strPostFix.bLoadString( ghInst, IDS_PRINTER_PREFERENCES );
    }

    //
    // Construct the property sheet title.
    //
    bStatus DBGCHK = bConstructMessageString( ghInst, _strTitle, IDS_DOCUMENT_DEFAULT_TITLE_FORMAT, szBuffer, (LPCTSTR)strPostFix );

    return bStatus;
}

BOOL
TDocumentDefaultPropertySheetManager::
bSetHeader(
    IN PPROPSHEETUI_INFO pCPSUIInfo,
    IN PPROPSHEETUI_INFO_HEADER pPSUIInfoHdr
    )
{
    DBGMSG( DBG_TRACE, ( "TDocumentDefaultPropertySheetManager::bSetHeader\n") );

    UNREFERENCED_PARAMETER( pCPSUIInfo );

    bCreateTitle();

    pPSUIInfoHdr->cbSize     = sizeof( PROPSHEETUI_INFO_HEADER );
    pPSUIInfoHdr->Flags      = PSUIHDRF_EXACT_PTITLE;
    pPSUIInfoHdr->pTitle     = (LPTSTR)(LPCTSTR)_strTitle;
    pPSUIInfoHdr->hInst      = ghInst;
    pPSUIInfoHdr->IconID     = IDI_PRINTER;
    pPSUIInfoHdr->hWndParent = _pPrinterData->hwnd();

    return TRUE;
}

/*++

Routine Name:

    bSaveResult

Routine Description:

    Save the result from the previous handler to our parent.

Arguments:

   pCPSUIInfo - Pointer to commonui property sheet info header,
   pSetResultInfo - Pointer to result info header

Return Value:

    TRUE success, FALSE error occurred.

--*/
BOOL
TDocumentDefaultPropertySheetManager::
bSaveResult(
    IN PPROPSHEETUI_INFO pCPSUIInfo,
    IN PSETRESULT_INFO pSetResultInfo
    )
{
    DBGMSG( DBG_TRACE, ( "TDocumentDefaultPropertySheetManager::bSaveResult\n") );

    TStatusB bStatus;

    bStatus DBGNOCHK = FALSE;

    if( pSetResultInfo->Result == CPSUI_OK )
    {
        //
        // Attempt to save the printer data, if an error occurrs
        // display a message.
        //
        bStatus DBGCHK = _pPrinterData->bSave( TRUE );

        if( !bStatus )
        {
            //
            // Display the error message.
            //
            iMessage( _pPrinterData->hwnd(),
                      IDS_ERR_DOC_PROP_TITLE,
                      IDS_ERR_SAVE_PRINTER,
                      MB_OK|MB_ICONSTOP,
                      kMsgGetLastError,
                      NULL );
        }
        else
        {
            pCPSUIInfo->Result = pSetResultInfo->Result;
        }
    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\devmgrpp.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1998
All rights reserved.

Module Name:

    devmgrpp.cxx

Abstract:

    Holds Device Manager Printer properties.

Author:

    Steve Kiraly (SteveKi)  01-Jan-1999

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "devmgrpp.hxx"

/*++

Name:

    PrinterPropPageProvider

Routine Description: 

    Entry-point for adding additional device manager property
    sheet pages.  This entry-point gets called only when the Device
    Manager asks for additional property pages.

Arguments:

    pinfo  - points to PROPSHEETPAGE_REQUEST, see setupapi.h
    pfnAdd - function ptr to call to add sheet.
    lParam - add sheet functions private data handle.

Return Value:

    BOOL: FALSE if pages could not be added, TRUE on success

--*/
BOOL APIENTRY 
PrinterPropPageProvider(
    LPVOID               pInfo,
    LPFNADDPROPSHEETPAGE pfnAdd,
    LPARAM               lParam
    )
{
    DBGMSG( DBG_TRACE, ( "PrinterPropPageProvider.\n" ) );
    
    TStatusB bStatus;
    PSP_PROPSHEETPAGE_REQUEST pReq = (PSP_PROPSHEETPAGE_REQUEST)pInfo;

    //
    // Tell the device manager we have already added our driver 
    // page.  This is just a hack to get device manager from
    // adding the default device page, which make no sense 
    // for printers.
    //
    TDevInfo DevInfo( pReq->DeviceInfoSet );

    bStatus DBGCHK = DevInfo.TurnOnDiFlags( pReq->DeviceInfoData, DI_DRIVERPAGE_ADDED );

    //
    // Bring up the property pages.
    //
    return bCreateDevMgrPrinterPropPages( pfnAdd, lParam );
}

/*++

Name:

    bCreateDevMgrPrinterPropPages

Routine Description: 

    Creates the device manager printer property pages.

Arguments:

    pfnAdd - function ptr to call to add sheet.
    lParam - add sheet functions private data handle.

Return Value:

    FALSE if pages could not be added, TRUE on success

--*/
BOOL
bCreateDevMgrPrinterPropPages(
    IN LPFNADDPROPSHEETPAGE pfnAdd,
    IN LPARAM               lParam
    )
{
    TStatusB bStatus;
    bStatus DBGNOCHK = FALSE;

    HPROPSHEETPAGE  hPage = NULL;

    TDevMgrPrinterProp *pProp = new TDevMgrPrinterProp;

    if( VALID_PTR( pProp ) )
    {
        PROPSHEETPAGE psp   = {0};

        psp.dwSize         = sizeof(PROPSHEETPAGE);
        psp.dwFlags        = PSP_USECALLBACK; 
        psp.hInstance      = ghInst;
        psp.pszTemplate    = MAKEINTRESOURCE(DLG_DEVMGR_SETTINGS);
        psp.pfnDlgProc     = MGenericProp::SetupDlgProc;
        psp.lParam         = reinterpret_cast<LPARAM>( reinterpret_cast<MGenericProp*>( pProp ) );
        psp.pfnCallback    = MGenericProp::CallbackProc;

        hPage              = CreatePropertySheetPage( &psp );
        
        bStatus DBGCHK     = pfnAdd( hPage, lParam );

    }

    //
    // Cleanup if something failed.
    //
    if( !bStatus )
    {
        if( hPage )
        {
            DestroyPropertySheetPage( hPage );
        }

        delete pProp;
    }

    return bStatus;
}

/********************************************************************

    Device Manager printer property pages class.

********************************************************************/

TDevMgrPrinterProp::
TDevMgrPrinterProp(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TDevMgrPrinterProp::ctor.\n" ) );
}

TDevMgrPrinterProp::
~TDevMgrPrinterProp(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TDevMgrPrinterProp::dtor.\n" ) );
}

BOOL
TDevMgrPrinterProp::
bHandleMessage(
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    BOOL bRetval = TRUE;

    switch( uMsg )
    {
    case WM_INITDIALOG:
        DBGMSG( DBG_TRACE, ( "TDevMgrPrinterProp::bHandleMessage WM_INITDIALOG.\n" ) );
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        bRetval = PrintUIHelp( uMsg, _hDlg, wParam, lParam );
        break;


    case WM_COMMAND:

        switch( GET_WM_COMMAND_ID( wParam, lParam ))
        {
        case IDC_PRINTERS_FOLDER:
            vStartPrintersFolder( _hDlg );
            break;

        default:
            bRetval = FALSE;
            break;
        }
        break;

    default:
        bRetval = FALSE;
        break;
    }

    return bRetval;
}

BOOL
TDevMgrPrinterProp::
bCreate(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TDevMgrPrinterProp::bCreate.\n" ) );
    return TRUE;
}

VOID
TDevMgrPrinterProp::
vDestroy(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TDevMgrPrinterProp::vDestroy.\n" ) );

    delete this;
}


VOID
TDevMgrPrinterProp::
vStartPrintersFolder(
    IN HWND hwnd
    )
{
    DBGMSG( DBG_TRACE, ( "TDevMgrPrinterProp::vStartPrintersFolder.\n" ) );

    LPITEMIDLIST pidl = NULL;
    
    HRESULT hres = SHGetSpecialFolderLocation( hwnd, CSIDL_PRINTERS, &pidl );
    if (SUCCEEDED(hres))
    {
        SHELLEXECUTEINFO ei = {0};

        ei.cbSize   = sizeof(SHELLEXECUTEINFO);
        ei.fMask    = SEE_MASK_IDLIST;
        ei.hwnd     = hwnd;
        ei.lpIDList = (LPVOID)pidl;
        ei.nShow    = SW_SHOWNORMAL;

        ShellExecuteEx(&ei);
    }
}


/********************************************************************

    Device info class simplifies calling setup apis.

********************************************************************/


TDevInfo::
TDevInfo(
    HDEVINFO  hDevInfo
    ) : _hDevInfo( hDevInfo ),
        _pfDiSetDeviceInstallParams ( NULL ),
        _pfDiGetDeviceInstallParams( NULL ),
        _pLib( NULL ),
        _bValid( FALSE )
{
    DBGMSG( DBG_TRACE, ( "TDevInfo::ctor.\n" ) );

#ifdef UNICODE
    const CHAR cszSetupDiGetDeviceInstallParams [] = "SetupDiGetDeviceInstallParamsW";
    const CHAR cszSetupDiSetDeviceInstallParams [] = "SetupDiSetDeviceInstallParamsW";
#else
    const CHAR cszSetupDiGetDeviceInstallParams [] = "SetupDiGetDeviceInstallParamsA";
    const CHAR cszSetupDiSetDeviceInstallParams [] = "SetupDiSetDeviceInstallParamsA";
#endif

    _pLib = new TLibrary( TEXT("setupapi.dll") );

    if( VALID_PTR( _pLib ) )
    {
        _pfDiGetDeviceInstallParams = reinterpret_cast<pfSetupDiGetDeviceInstallParams>( _pLib->pfnGetProc( cszSetupDiGetDeviceInstallParams ) );
        _pfDiSetDeviceInstallParams = reinterpret_cast<pfSetupDiSetDeviceInstallParams>( _pLib->pfnGetProc( cszSetupDiSetDeviceInstallParams ) );

        if( _pfDiGetDeviceInstallParams && _pfDiSetDeviceInstallParams )
        {
            _bValid = TRUE;
        }
    }
}

TDevInfo::
~TDevInfo(
    VOID
    ) 
{
    DBGMSG( DBG_TRACE, ( "TDevInfo::dtor.\n" ) );
    delete _pLib;
}

BOOL
TDevInfo::
bValid(
    VOID
    ) 
{
    DBGMSG( DBG_TRACE, ( "TDevInfo::bValid.\n" ) );
    return _bValid;
}

BOOL
TDevInfo::
TurnOnDiFlags(
    IN PSP_DEVINFO_DATA DevData,
    IN DWORD            dwDiFlags
    ) 
{
    DBGMSG( DBG_TRACE, ( "TDevInfo::TurnOnDiFlags.\n" ) );
    
    BOOL bRetval = FALSE;        

    if( bValid() )
    {
        SP_DEVINSTALL_PARAMS dip = {0};

        dip.cbSize = sizeof(dip);

        bRetval = _pfDiGetDeviceInstallParams( _hDevInfo, DevData, &dip );

        if( bRetval )
        {
            dip.Flags |= dwDiFlags;
        }

        bRetval = _pfDiSetDeviceInstallParams( _hDevInfo, DevData, &dip );
    }

    return bRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\docprop.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    docprop.cxx

Abstract:

    Job Properties

Author:

    Steve Kiraly (SteveKi)  10/19/95

Revision History:
    
    Lazar Ivanov (LazarI) - added DocumentPropertiesWrap (Nov-03-2000)

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "time.hxx"
#include "docdata.hxx"
#include "propmgr.hxx"
#include "docprop.hxx"


/*++

Routine Name:

    vDocPropSelections

Routine Description:

    Displays Document property sheets for multiple selections.

Arguments:

    TSelection - pointer to a list of document selections.

Return Value:

    Nothing.

--*/

VOID
vDocumentPropSelections(
    IN HWND         hWnd,
    IN LPCTSTR      pszPrinterName,
    IN TSelection  *pSelection
    )
{

    //
    // Get the selection information.  We are in a loop to
    // handle the selection of multiple jobs.
    //
    for( UINT i = 0; i < pSelection->_cSelected; ++i ){
        //
        // Display the document property pages.
        //
        vDocumentPropPages(
            hWnd,
            pszPrinterName,
            pSelection->_pid[i],
            SW_SHOWNORMAL,
            0 );
    }

}

/*++

Routine Description:

    This function opens the property sheet of specified document.

    We can't guarentee that this propset will perform all lengthy
    operations in a worker thread (we synchronously call things like
    ConfigurePort).  Therefore, we spawn off a separate thread to
    handle document properties.

Arguments:

    hWnd        - Specifies the parent window (optional).
    pszPrinter  - Specifies the printer name
    nCmdShow    - Initial show state
    lParam      - May spcify a sheet specifc index to directly open.

Return Value:

--*/
VOID
vDocumentPropPages(
    IN HWND     hWnd,
    IN LPCTSTR  pszPrinterName,
    IN IDENT    JobId,
    IN INT      iCmdShow,
    IN LPARAM   lParam
    )

{
    HANDLE hThread;

    //
    // Create the document specific data
    //
    TDocumentData* pDocumentData = new TDocumentData( pszPrinterName,
                                                      JobId,
                                                      iCmdShow,
                                                      lParam );
    //
    // If errors were encountered creating document data.
    //
    if( !VALID_PTR( pDocumentData )){
        goto Fail;
    }

    //
    // Create the thread which handles the UI.  vPrinterPropPages adopts
    // pPrinterData, therefore only on thread creation failure do we
    // releae the document data back to the heap.
    //
    DWORD dwIgnore;
    hThread = TSafeThread::Create( NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)iDocumentPropPagesProc,
                                   pDocumentData,
                                   0,
                                   &dwIgnore );

    //
    // Check thread creation.
    //
    if( !hThread ){

        //
        // Display error message, and release document data.
        //
        vShowResourceError( hWnd );
        delete pDocumentData;

    } else {

        CloseHandle( hThread );
    }

    return;

Fail:

    //
    // Display the error message.
    //
    iMessage( hWnd,
              IDS_ERR_DOC_JOB_PROPERTY_TITLE,
              IDS_ERR_DOC_JOB_PROPERTY_JOB_NA,
              MB_OK|MB_ICONSTOP,
              kMsgGetLastError,
              NULL );

    delete pDocumentData;
}

/*++

Routine Name:

    iDocumentPropPagesProc

Routine Description:

    This is the routine called by the create thread call to display the
    document property sheets.

Arguments:

    pDocumentData - Pointer to the document data needed for all property sheets.

Return Value:

    TRUE - if the property sheets were displayed.
    FALSE - error creating and displaying property sheets.

--*/

INT
iDocumentPropPagesProc(
    IN TDocumentData *pDocumentData ADOPT
    )
{
    DBGMSG( DBG_TRACE, ( "iDocumentPropPagesProc\n") );

    BOOL bStatus;
    bStatus = pDocumentData->bRegisterWindow( PRINTER_PIDL_TYPE_JOBID |
                                                  pDocumentData->JobId( ));
    if( bStatus ){

        //
        // Check if the window is already present.  If it is, then
        // exit immediately.
        //
        if( !pDocumentData->hwnd( )){
            delete pDocumentData;
            return 0;
        }

        bStatus = pDocumentData->bLoad();
    }

    if( !bStatus ){

        iMessage( pDocumentData->hwnd(),
                  IDS_ERR_DOC_JOB_PROPERTY_TITLE,
                  IDS_ERR_DOC_JOB_PROPERTY_JOB_NA,
                  MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
                  kMsgGetLastError,
                  NULL );

        delete pDocumentData;
        return 0;
    }

    //
    // Create the ducument property sheet windows.
    //
    TDocumentWindows DocumentWindows( pDocumentData );

    //
    // Were the document windows create
    //
    if( !VALID_OBJ( DocumentWindows ) ){
        vShowResourceError( pDocumentData->hwnd() );
        bStatus = FALSE;
    }

    //
    // Display the property pages.
    //
    if( bStatus ){
        if( !DocumentWindows.bDisplayPages( pDocumentData->hwnd() ) ){
            vShowResourceError( pDocumentData->hwnd() );
            bStatus = FALSE;
        }
    }

    //
    // Ensure we release the document data.
    // We have adopted pPrinterData, so we must free it.
    //
    delete pDocumentData;
    return bStatus;

}

/********************************************************************

    Document Prop Base Class

********************************************************************/
/*++

Routine Name:

    TDocumentProp

Routine Description:

    Initialized the document property sheet base class

Arguments:

    pDocumentData - Pointer to the document data needed for all property sheets.

Return Value:

    None.

--*/
TDocumentProp::
TDocumentProp(
    TDocumentData* pDocumentData
    ) : _pDocumentData( pDocumentData ),
        _bApplyData( FALSE )
{
}

/*++

Routine Name:

    ~TDocumentProp

Routine Description:

    Base class desctuctor.

Arguments:

    None.

Return Value:

    Nothing.

--*/
TDocumentProp::
~TDocumentProp(
    )
{
}

/*++

Routine Name:

    bHandleMessage

Routine Description:

    Base class message handler.  This routine is called by
    derived classes who do not want to handle the message.


Arguments:

    uMsg    - Windows message
    wParam  - Word parameter
    lParam  - Long parameter


Return Value:

    TRUE if message was handled, FALSE if message not handled.

--*/
BOOL
TDocumentProp::
bHandleMessage(
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL bStatus = TRUE;

    switch( uMsg ){

    //
    // Set the values on the UI.
    //
    case WM_INITDIALOG:
        bStatus = bSetUI();
        break;

    //
    // Handle help and context help.
    //
    case WM_HELP:
    case WM_CONTEXTMENU:
        bStatus = PrintUIHelp( uMsg, _hDlg, wParam, lParam );
        break;

    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam)->code )
        {
            //
            // User switched to the next page.
            //
            case PSN_KILLACTIVE:
                bStatus = bReadUI();
                vSetDlgMsgResult( !bStatus ? TRUE : FALSE );
                break;

            //
            // User chiose the apply button.
            //
            case PSN_APPLY:
                _bApplyData = TRUE;
                bStatus = ( _bApplyData ) ? bSaveUI() : FALSE;
                if( !bStatus )
                {
                    //
                    // Switch to page with the error.
                    //
                    PropSheet_SetCurSelByID( GetParent( _hDlg ), DLG_DOC_JOB_GENERAL );
                }
                vSetDlgMsgResult( !bStatus ? PSNRET_INVALID_NOCHANGEPAGE : PSNRET_NOERROR );
                break;

            //
            // Indicate the use canceled the dialog.
            //
            case PSN_QUERYCANCEL:
                _bApplyData = FALSE;
                break;

            default:
                bStatus = FALSE;
                break;
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }

    if( !bStatus )
    {
        //
        // Allow the derived classes to handle the message.
        //
        bStatus = _bHandleMessage( uMsg, wParam, lParam );
    }

    //
    // If the message was handled check if the 
    // apply button should be enabled.
    //
    if( bStatus )
    {
        if( _pDocumentData->bCheckForChange() )
        {
            PropSheet_Changed( GetParent( _hDlg ), _hDlg );
        }
        else
        {
            PropSheet_UnChanged( GetParent( _hDlg), _hDlg );
        }
    }

    return bStatus;
}


/********************************************************************

    General Document Property Sheet.

********************************************************************/

/*++

Routine Name:

    TDocumentGeneral

Routine Description:

    Document property sheet derived class.

Arguments:

    None.

Return Value:

    Nothing.

--*/
TDocumentGeneral::
TDocumentGeneral(
    IN TDocumentData* pDocumentData
    ) : TDocumentProp( pDocumentData ),
        _bSetUIDone( FALSE )
{
}

/*++

Routine Name:

    ~TDocumentGeneral

Routine Description:

    Document derived class destructor.

Arguments:

    None.

Return Value:

    Nothing.

--*/

TDocumentGeneral::
~TDocumentGeneral(
    )
{
}

/*++

Routine Name:

    bValid

Routine Description:

    Document property sheet derived class valid object indicator.

Arguments:

    None.

Return Value:

    Returns the status of the base class.

--*/
BOOL
TDocumentGeneral::
bValid(
    VOID
    )
{
    return TDocumentProp::bValid();
}

/*++

Routine Name:

    bSetStartAndUntilTime

Routine Description:

    Initialized the start and until time.

Arguments:

    None.

Return Value:

    TRUE time controls initialized, FALSE error occured.

--*/
BOOL
TDocumentGeneral::
bSetStartAndUntilTime(
    VOID
    )
{
    TString strFormatString;
    TStatusB bStatus;

    //
    // Get the time format string without seconds.
    //
    bStatus DBGCHK = bGetTimeFormatString( strFormatString );

    //
    // If we have retrived a valid time format string then use it, 
    // else use the default format string implemented by common control.
    //
    if( bStatus )
    {
        DateTime_SetFormat(GetDlgItem( _hDlg, IDC_DOC_JOB_START_TIME ), static_cast<LPCTSTR>( strFormatString ) );
        DateTime_SetFormat(GetDlgItem( _hDlg, IDC_DOC_JOB_UNTIL_TIME ), static_cast<LPCTSTR>( strFormatString ) );
    }

    //
    // If the printer is always available.
    //
    BOOL bAlways = ( _pDocumentData->pJobInfo()->StartTime == _pDocumentData->pJobInfo()->UntilTime );

    //
    // Set the start time.
    //
    SYSTEMTIME  StartTime           = { 0 };
    DWORD       dwLocalStartTime    = 0;

    GetLocalTime( &StartTime );

    dwLocalStartTime = ( !bAlways ) ? SystemTimeToLocalTime( _pDocumentData->pJobInfo()->StartTime ) : 0;

    StartTime.wHour     = static_cast<WORD>( dwLocalStartTime / 60 );
    StartTime.wMinute   = static_cast<WORD>( dwLocalStartTime % 60 );

    DateTime_SetSystemtime(GetDlgItem( _hDlg, IDC_DOC_JOB_START_TIME ), GDT_VALID, &StartTime );

    //
    // Set the until time.
    //
    SYSTEMTIME  UntilTime           = { 0 };
    DWORD       dwLocalUntilTime    = 0;

    GetLocalTime( &UntilTime );

    dwLocalUntilTime = ( !bAlways ) ? SystemTimeToLocalTime( _pDocumentData->pJobInfo()->UntilTime ) : 0;

    UntilTime.wHour     = static_cast<WORD>( dwLocalUntilTime / 60 );
    UntilTime.wMinute   = static_cast<WORD>( dwLocalUntilTime % 60 );

    DateTime_SetSystemtime(GetDlgItem( _hDlg, IDC_DOC_JOB_UNTIL_TIME ), GDT_VALID, &UntilTime );

    return TRUE;
}

/*++

Routine Name:

    bSetUI

Routine Description:

    Loads the property sheet dialog with the document data
    information.

Arguments:

    None.

Return Value:

    TRUE if data loaded successfully, FALSE if error occurred.

--*/
BOOL
TDocumentGeneral::
bSetUI(
    VOID
    )

{
    //
    // Get the flag if always availble.
    //
    BOOL bAlways = ( _pDocumentData->pJobInfo()->StartTime ==
                     _pDocumentData->pJobInfo()->UntilTime );

    //
    // Initialize the stat and until time controls.
    //
    if( !bSetStartAndUntilTime() )
    {
        DBGMSG( DBG_TRACE, ( "TDocumentGeneral::bSetStartAndUntilTime failed %d\n", GetLastError( )));
    }

    //
    // Read the job size format string.
    //
    TString strFormat;
    if( strFormat.bLoadString( ghInst, IDS_JOB_SIZE ) ){

        //
        // Set the size in byes of the job.
        //
        bSetEditTextFormat( _hDlg,
                            IDC_DOC_JOB_SIZE,
                            strFormat,
                            _pDocumentData->pJobInfo()->Size );
    }

    //
    // Set the Number of pages in the job.
    //
    bSetEditTextFormat( _hDlg,
                        IDC_DOC_JOB_PAGES,
                        TEXT( "%d" ),
                        _pDocumentData->pJobInfo()->TotalPages );

    //
    // Set the document text.
    //
    bSetEditText( _hDlg, IDC_DOC_JOB_TITLE,      _pDocumentData->pJobInfo()->pDocument );
    bSetEditText( _hDlg, IDC_DOC_JOB_DATATYPE,   _pDocumentData->pJobInfo()->pDatatype );
    bSetEditText( _hDlg, IDC_DOC_JOB_PROCCESSOR, _pDocumentData->pJobInfo()->pPrintProcessor );
    bSetEditText( _hDlg, IDC_DOC_JOB_OWNER,      _pDocumentData->pJobInfo()->pUserName );
    bSetEditText( _hDlg, IDC_DOC_JOB_NOTIFY,     _pDocumentData->pJobInfo()->pNotifyName );

    //
    // Set the Priority indicator.
    //
    bSetEditTextFormat( _hDlg,
                        IDC_DOC_JOB_PRIORITY,
                        TEXT( "%d" ),
                        _pDocumentData->pJobInfo()->Priority );

    SendDlgItemMessage( _hDlg,
                        IDC_DOC_JOB_PRIORITY_CONTROL,
                        TBM_SETRANGE,
                        FALSE,
                        MAKELONG( TDocumentData::kPriorityLowerBound, TDocumentData::kPriorityUpperBound ));

    SendDlgItemMessage( _hDlg,
                        IDC_DOC_JOB_PRIORITY_CONTROL,
                        TBM_SETPOS,
                        TRUE,
                        _pDocumentData->pJobInfo()->Priority );

    //
    // Format the submitted time field.
    //
    TStatusB bStatus = FALSE;
    TCHAR szBuff[kStrMax] = {0};
    SYSTEMTIME LocalTime;

    //
    // Convert to local time.
    //
    bStatus DBGCHK = SystemTimeToTzSpecificLocalTime(
                        NULL,
                        &_pDocumentData->pJobInfo()->Submitted,
                        &LocalTime );
    if( !bStatus ){
        DBGMSG( DBG_MIN, ( "SysTimeToTzSpecLocalTime failed %d\n", GetLastError( )));
    }

    if( bStatus ){

        //
        // Convert using local format information.
        //
        bStatus DBGCHK = GetTimeFormat( LOCALE_USER_DEFAULT,
                            0,
                            &LocalTime,
                            NULL,
                            szBuff,
                            COUNTOF( szBuff ));
        if( !bStatus ){
            DBGMSG( DBG_MIN, ( "No Time %d, ", GetLastError( )));
        }
    }

    if( bStatus ){

        //
        // Tack on space between time and date.
        //
        lstrcat( szBuff, TEXT("  ") );

        //
        // Get data format.
        //
        bStatus DBGCHK = GetDateFormat( LOCALE_USER_DEFAULT,
                            0,
                            &LocalTime,
                            NULL,
                            szBuff + lstrlen( szBuff ),
                            COUNTOF( szBuff ) - lstrlen( szBuff ) );

        if( !bStatus ){
            DBGMSG( DBG_MIN, ( "No Date %d\n", GetLastError( )));
        }
    }

    //
    // Set the submitted  field
    //
    bStatus DBGCHK = bSetEditText( _hDlg, IDC_DOC_JOB_AT, szBuff );

    //
    // Set schedule radio buttons.
    //
    CheckRadioButton( _hDlg, IDC_DOC_JOB_START, IDC_DOC_JOB_ALWAYS,
        bAlways ? IDC_DOC_JOB_ALWAYS : IDC_DOC_JOB_START );

    vEnableAvailable( !bAlways );

    //
    // Disable all the controls if not an administrator.
    //
    if( !_pDocumentData->bAdministrator( )){

        //
        // Disable the time controls.
        //
        vEnableAvailable( FALSE );

        //
        // Disable things if not administrator.
        //
        static UINT auAvailable[] = {
            IDC_DOC_JOB_NOTIFY,
            IDC_DOC_JOB_PRIORITY_CONTROL,
            IDC_DOC_JOB_ALWAYS,
            IDC_DOC_JOB_START,
        };

        COUNT i;
        for( i = 0; i < COUNTOF( auAvailable ); ++i ){
            vEnableCtl( _hDlg, auAvailable[i], FALSE );
        }
    }

    _bSetUIDone = TRUE;

    return TRUE;
}

/*++

Routine Name:

    bReadUI

Routine Description:

    Stores the property information to the print server.

Arguments:

    Nothing data is contained with in the class.

Return Value:

    TRUE if data is stores successfully, FALSE if error occurred.

--*/
BOOL
TDocumentGeneral::
bReadUI(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TDocumentGeneral::bReadUI\n") );

    //
    // Attempt to validate any UI changeable data.
    // Currently not much can be validated, since all the
    // controls have set constraints.
    //

    //
    // Extract the UI and save it into the Document Data.
    //
    _pDocumentData->pJobInfo()->Priority = (DWORD)SendDlgItemMessage( _hDlg,
                        IDC_DOC_JOB_PRIORITY_CONTROL,
                        TBM_GETPOS,
                        0,
                        0 );
    //
    // Get the notify name.
    //
    bGetEditText( _hDlg, IDC_DOC_JOB_NOTIFY, _pDocumentData->strNotifyName() );
    _pDocumentData->pJobInfo()->pNotifyName = (LPTSTR)(LPCTSTR)_pDocumentData->strNotifyName();

    //
    // If the Job always is set then indicate
    // not time restriction in the start time and until time.
    //
    if( bGetCheck( _hDlg, IDC_DOC_JOB_ALWAYS ) ){

        _pDocumentData->pJobInfo()->StartTime = 0;
        _pDocumentData->pJobInfo()->UntilTime = 0;

    } else {

        //
        // Get the Start time.
        //
        SYSTEMTIME StartTime;
        DateTime_GetSystemtime( GetDlgItem( _hDlg, IDC_DOC_JOB_START_TIME ), &StartTime );
        _pDocumentData->pJobInfo()->StartTime = LocalTimeToSystemTime( StartTime.wHour * 60 + StartTime.wMinute );

        //
        // Get the Until time.
        //
        SYSTEMTIME UntilTime;
        DateTime_GetSystemtime( GetDlgItem( _hDlg, IDC_DOC_JOB_UNTIL_TIME ), &UntilTime );
        _pDocumentData->pJobInfo()->UntilTime = LocalTimeToSystemTime( UntilTime.wHour * 60 + UntilTime.wMinute );

        //
        // If the printer start and until time are the same this is 
        // exactly the same as always available.
        //
        if( _pDocumentData->pJobInfo()->StartTime == _pDocumentData->pJobInfo()->UntilTime )
        {
            _pDocumentData->pJobInfo()->StartTime = 0;
            _pDocumentData->pJobInfo()->UntilTime = 0;
        }
    }

    //
    // Set the job position to unspecified it may 
    // have changed while this dialog was up.
    //
    _pDocumentData->pJobInfo()->Position =  JOB_POSITION_UNSPECIFIED;

    return TRUE;
}

/*++

Routine Name:

    bSaveUI

Routine Description:

    Saves the UI data to some API call or print server.

Arguments:

    Nothing data is contained with in the class.

Return Value:

    TRUE if data is stores successfully, FALSE if error occurred.

--*/
BOOL
TDocumentGeneral::
bSaveUI(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TDocumentGeneral::bSaveUI\n") );

    //
    // Clear the error saving flag.
    // 
    _pDocumentData->bErrorSaving() = TRUE;

    //
    // Save the document data.
    //
    if( !_pDocumentData->bStore() ){

        DWORD dwLastError = GetLastError ();

        if( dwLastError == ERROR_INVALID_TIME ){
            _pDocumentData->iErrorMsgId() = IDS_ERR_DOC_JOB_PROPERTY_TIME;
        } else {
            _pDocumentData->iErrorMsgId() = IDS_ERR_DOC_JOB_PROPERTY_MODIFY;
        }
        _pDocumentData->bErrorSaving() = FALSE;
    }

    //
    // If there was an error saving the document data.
    //
    if( !_pDocumentData->bErrorSaving() ){

        //
        // Display the error message.
        //
        iMessage( _hDlg,
                  IDS_ERR_DOC_JOB_PROPERTY_TITLE,
                  _pDocumentData->iErrorMsgId(),
                  MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
                  kMsgNone,
                  NULL );

        return FALSE;
    }

    return TRUE;
}

/*++

Routine Name:

    vEanbleAvailablity

Routine Description:

    Enables the time availabilty of the job

Arguments:

    TRUE enable the availablity, FALSE disable time availablity.

Return Value:

    Nothing.

--*/
VOID
TDocumentGeneral::
vEnableAvailable(
    IN BOOL bEnable
    )
{
    vEnableCtl( _hDlg, IDC_DOC_JOB_START_TIME, bEnable );
    vEnableCtl( _hDlg, IDC_DOC_JOB_UNTIL_TIME, bEnable );
}

/*++

Routine Name:

    bReadUI

Routine Description:

    Stores the property information to the print server.

Arguments:

    Nothing data is contained with in the class.

Return Value:

    TRUE if data is stores successfully, FALSE if error occurred.

--*/
VOID
TDocumentGeneral::
vSetActive(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TDocumentGeneral::vSetActive\n") );
    (VOID)bSetStartAndUntilTime();
}

/*++

Routine Name:

    bHandleMessage

Routine Description:

    Document property sheet message handler.  This handler only
    handles events it wants and the base class handle will do the
    standard message handling.

Arguments:

    uMsg    - Windows message
    wParam  - Word parameter
    lParam  - Long parameter


Return Value:

    TRUE if message was handled, FALSE if message not handled.

--*/

BOOL
TDocumentGeneral::
_bHandleMessage(
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL bStatus = TRUE;

    switch( uMsg )
    {
    case WM_HSCROLL:

        //
        // Check for slider notification.
        //
        if( GET_WM_HSCROLL_HWND( wParam, lParam ) == GetDlgItem(_hDlg, IDC_DOC_JOB_PRIORITY_CONTROL ) ){
            bSetEditTextFormat( _hDlg,
                               IDC_DOC_JOB_PRIORITY,
                               TEXT("%d"),
                               SendDlgItemMessage( _hDlg,
                                                   IDC_DOC_JOB_PRIORITY_CONTROL,
                                                   TBM_GETPOS,
                                                   0,
                                                   0 ) );
        }
        break;

    case WM_COMMAND:
        switch( GET_WM_COMMAND_ID( wParam, lParam ))
        {
        case IDC_DOC_JOB_ALWAYS:
            vEnableAvailable( FALSE );
            PropSheet_Changed( GetParent( _hDlg ), _hDlg );
            break;

        case IDC_DOC_JOB_START:
            vEnableAvailable( TRUE );
            PropSheet_Changed( GetParent( _hDlg ), _hDlg );
            break;

        case IDC_DOC_JOB_NOTIFY:
            bStatus = GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE;
            break;

        default:
            bStatus = FALSE;
            break;
        }
        break;

    case WM_WININICHANGE:
        vSetActive();
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( wParam )
            {
            case 0:
                {
                    switch( pnmh->code )
                    {
                    case PSN_SETACTIVE:
                        vSetActive();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                    }
                }
                break;
                
            case IDC_DOC_JOB_START_TIME:
            case IDC_DOC_JOB_UNTIL_TIME:
                {
                    switch( pnmh->code )
                    {
                    case DTN_DATETIMECHANGE:
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                    }
                }
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;
    
    default:
        bStatus = FALSE;
        break;
    }

    //
    // If message handled look for change.
    //
    if( bStatus && _bSetUIDone )
    {
        (VOID)bReadUI();
    }

    return bStatus;
}

/********************************************************************

    Document property windows.

********************************************************************/

/*++

Routine Description:

    Document property windows.

Arguments:

    pDocumentData - Document data to display.

Return Value:

    TRUE - Success, FALSE - failure.

--*/

TDocumentWindows::
TDocumentWindows(
    TDocumentData* pDocumentData
    ) : _pDocumentData( pDocumentData ),
        _General( pDocumentData )
{
    DBGMSG( DBG_TRACE, ( "TDocumentWindows ctor\n") );
}

TDocumentWindows::
~TDocumentWindows(
    )
{
    DBGMSG( DBG_TRACE, ( "TDocumentWindows dtor\n") );
}

/*++

Routine Name:

    bBuildPages

Routine Description:

    Builds the document property windows.

Arguments:

    None - class specific.

Return Value:

    TRUE pages built ok, FALSE failure building pages.

--*/

BOOL
TDocumentWindows::
bBuildPages(
    IN PPROPSHEETUI_INFO pCPSUIInfo
    )
{
    TStatusB bStatus;
    DBGMSG( DBG_TRACE, ( "TDocumentWindows bBuildPages\n") );

    //
    // Set the default activation context to be V6 prior calling into
    // compstui to create the pages. This will force V6 context unless
    // the callbacks which create the compstui pages specify otherwise
    // on a per page basis.
    //
    bStatus DBGCHK = (BOOL)pCPSUIInfo->pfnComPropSheet(
            pCPSUIInfo->hComPropSheet, 
            CPSFUNC_SET_FUSION_CONTEXT, 
            reinterpret_cast<LPARAM>(g_hActCtx),
            static_cast<LPARAM>(0));

    if (bStatus)
    {
        PROPSHEETPAGE  psp;
        ZeroMemory( &psp, sizeof( psp ) );

        psp.dwSize          = sizeof( psp );
        psp.dwFlags         = PSP_DEFAULT;
        psp.hInstance       = ghInst;
        psp.pfnDlgProc      = MGenericProp::SetupDlgProc;
        psp.pszTemplate     = MAKEINTRESOURCE( DLG_DOC_JOB_GENERAL );
        psp.lParam          = (LPARAM)(MGenericProp*)&_General;

        if( pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                    CPSFUNC_ADD_PROPSHEETPAGE,
                                    (LPARAM)&psp,
                                    NULL ) <= 0 ) 
        {
            DBGMSG( DBG_TRACE, ( "CPSFUNC_ADD_PROPSHEETPAGE failed.\n") );
            bStatus DBGCHK = FALSE;
        }

        if (bStatus)
        {
            //
            // If the dev mode is null don't display the
            // device property sheets.
            //
            if( _pDocumentData->pJobInfo()->pDevMode )
            {
                ZeroMemory( &_dph, sizeof( _dph ) );

                _dph.cbSize         = sizeof( _dph );
                _dph.hPrinter       = _pDocumentData->hPrinter();
                _dph.pszPrinterName = (LPTSTR)(LPCTSTR)_pDocumentData->strPrinterName();
                _dph.pdmOut         = _pDocumentData->pJobInfo()->pDevMode;
                _dph.pdmIn          = _pDocumentData->pJobInfo()->pDevMode;
                _dph.fMode          = DM_IN_BUFFER | DM_PROMPT | DM_NOPERMISSION;

                if( pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                                 CPSFUNC_ADD_PFNPROPSHEETUI,
                                                 (LPARAM)DocumentPropertySheets,
                                                 (LPARAM)&_dph ) <= 0 )
                {
                    DBGMSG( DBG_TRACE, ( "CPSFUNC_ADD_PFNPROPSHEETUI failed.\n") );
                    bStatus DBGCHK = FALSE;
                }
            }
        }
    }

    return bStatus;
}


BOOL
TDocumentWindows::
bSetHeader(
    IN PPROPSHEETUI_INFO pCPSUIInfo,
    IN PPROPSHEETUI_INFO_HEADER pPSUIInfoHdr
    )
{
    DBGMSG( DBG_TRACE, ( "TDocumentWindows bSetHeader\n") );

    UNREFERENCED_PARAMETER( pCPSUIInfo );

    pPSUIInfoHdr->pTitle     = _pDocumentData->pJobInfo()->pDocument;
    pPSUIInfoHdr->Flags      = PSUIHDRF_PROPTITLE;
    pPSUIInfoHdr->hWndParent = _pDocumentData->hwnd();
    pPSUIInfoHdr->hInst      = ghInst;
    pPSUIInfoHdr->IconID     = IDI_DOCUMENT;

    return TRUE;
}

BOOL
TDocumentWindows::
bValid(
    VOID
    )
{
    return _General.bValid();
}

/********************************************************************

    Document properties UI (driver UI)

********************************************************************/

TDocumentProperties::
TDocumentProperties(
    IN  HWND hwnd,
    IN  HANDLE hPrinter,
    IN  LPCTSTR pszPrinter,
    IN  PDEVMODE pDevModeIn,
    OUT PDEVMODE pDevModeOut,
    IN  DWORD dwHideBits,
    IN  DWORD dwFlags
    ):
        _hwnd(hwnd),
        _hPrinter(hPrinter),
        _pszPrinter(pszPrinter),
        _pDevModeIn(pDevModeIn),
        _pDevModeOut(pDevModeOut),
        _dwHideBits(dwHideBits),
        _dwFlags(dwFlags),
        _lResult(-1)
{
    // nothing
}

LONG
TDocumentProperties::
lGetResult(
    VOID
    ) const
{
    return _lResult;
}

BOOL
TDocumentProperties::
bBuildPages(
    IN PPROPSHEETUI_INFO pCPSUIInfo
    )
{
    BOOL bRet = FALSE;

    if( bValid() )
    {
        //
        // Set the default activation context to be V6 prior calling into
        // compstui to create the pages. This will force V6 context unless
        // the callbacks which create the compstui pages specify otherwise
        // on a per page basis.
        //
        bRet = (BOOL)pCPSUIInfo->pfnComPropSheet(
                pCPSUIInfo->hComPropSheet, 
                CPSFUNC_SET_FUSION_CONTEXT, 
                reinterpret_cast<LPARAM>(g_hActCtx),
                static_cast<LPARAM>(0));

        if( bRet )
        {
            ZeroMemory(&_dph, sizeof(_dph));

            _dph.cbSize         = sizeof(_dph);
            _dph.hPrinter       = _hPrinter;
            _dph.pszPrinterName = const_cast<LPTSTR>(_pszPrinter);
            _dph.pdmIn          = _pDevModeIn;
            _dph.pdmOut         = _pDevModeOut;
            _dph.fMode          = _dwFlags;

            if( _dwHideBits )
            {
                _lResult = pCPSUIInfo->pfnComPropSheet(pCPSUIInfo->hComPropSheet, 
                    CPSFUNC_SET_DMPUB_HIDEBITS, static_cast<LPARAM>(_dwHideBits), 0);
            }
            else
            {
                //
                // If no bit is hided, The result value should be valid.
                //
                _lResult = 1;
            }

            if( _lResult > 0 )
            {
                _lResult = pCPSUIInfo->pfnComPropSheet(pCPSUIInfo->hComPropSheet, 
                    CPSFUNC_ADD_PFNPROPSHEETUI, reinterpret_cast<LPARAM>(DocumentPropertySheets), 
                    reinterpret_cast<LPARAM>(&_dph));
            }
        }
    }

    return (_lResult > 0);
}

BOOL
TDocumentProperties::
bSetHeader(
    IN PPROPSHEETUI_INFO pCPSUIInfo, 
    IN PPROPSHEETUI_INFO_HEADER pPSUInfoHeader
    )
{
    // construct the title & setup the header
    UNREFERENCED_PARAMETER(pCPSUIInfo);

    if( 0 == _strTitle.uLen() )
    {
        _strTitle.bLoadString(ghInst, IDS_PRINTER_PREFERENCES);
    }

    pPSUInfoHeader->pTitle     = const_cast<LPTSTR>(static_cast<LPCTSTR>(_strTitle));
    pPSUInfoHeader->Flags      = PSUIHDRF_EXACT_PTITLE | PSUIHDRF_NOAPPLYNOW;
    pPSUInfoHeader->hWndParent = _hwnd;
    pPSUInfoHeader->hInst      = ghInst;
    pPSUInfoHeader->IconID     = IDI_PRINTER;

    return TRUE;
}

// table to remap the devmode field selections to DMPUB_* ids.
static DWORD arrDmFlagMap[] = 
{ 
    DM_ORIENTATION,        MAKE_DMPUB_HIDEBIT( DMPUB_ORIENTATION ),
    DM_PAPERSIZE  ,        MAKE_DMPUB_HIDEBIT( 0 ),
    DM_PAPERLENGTH,        MAKE_DMPUB_HIDEBIT( 0 ),
    DM_PAPERWIDTH ,        MAKE_DMPUB_HIDEBIT( 0 ),
    DM_SCALE      ,        MAKE_DMPUB_HIDEBIT( DMPUB_SCALE ),
    DM_COPIES     ,        MAKE_DMPUB_HIDEBIT( DMPUB_COPIES_COLLATE ),
    DM_DEFAULTSOURCE,      MAKE_DMPUB_HIDEBIT( DMPUB_DEFSOURCE ),
    DM_PRINTQUALITY,       MAKE_DMPUB_HIDEBIT( DMPUB_PRINTQUALITY ),
    DM_COLOR      ,        MAKE_DMPUB_HIDEBIT( DMPUB_COLOR ),
    DM_DUPLEX     ,        MAKE_DMPUB_HIDEBIT( DMPUB_DUPLEX ),
    DM_YRESOLUTION,        MAKE_DMPUB_HIDEBIT( 0 ),
    DM_TTOPTION   ,        MAKE_DMPUB_HIDEBIT( DMPUB_TTOPTION ),
    DM_COLLATE    ,        MAKE_DMPUB_HIDEBIT( DMPUB_COPIES_COLLATE ),
    DM_FORMNAME   ,        MAKE_DMPUB_HIDEBIT( DMPUB_FORMNAME ),
    DM_LOGPIXELS  ,        MAKE_DMPUB_HIDEBIT( 0 ),
    DM_BITSPERPEL ,        MAKE_DMPUB_HIDEBIT( 0 ),
    DM_PELSWIDTH  ,        MAKE_DMPUB_HIDEBIT( 0 ),
    DM_PELSHEIGHT ,        MAKE_DMPUB_HIDEBIT( 0 ),
    DM_DISPLAYFLAGS,       MAKE_DMPUB_HIDEBIT( 0 ),
    DM_DISPLAYFREQUENCY,   MAKE_DMPUB_HIDEBIT( 0 ),
    DM_ICMMETHOD  ,        MAKE_DMPUB_HIDEBIT( DMPUB_ICMMETHOD ),
    DM_ICMINTENT  ,        MAKE_DMPUB_HIDEBIT( DMPUB_ICMINTENT ),
    DM_MEDIATYPE  ,        MAKE_DMPUB_HIDEBIT( DMPUB_MEDIATYPE ),
    DM_DITHERTYPE ,        MAKE_DMPUB_HIDEBIT( DMPUB_DITHERTYPE ),
    DM_PANNINGWIDTH,       MAKE_DMPUB_HIDEBIT( 0 ),
    DM_PANNINGHEIGHT,      MAKE_DMPUB_HIDEBIT( 0 ) 
};

static DWORD 
RemapExclusionFlags(DWORD fExclusionFlags)
{
    // walk through to collect the exclusion bits from the table above.
    DWORD dwFlags = 0;
    for( UINT i = 0; i < ARRAYSIZE(arrDmFlagMap); i += 2 )
    {
        if( fExclusionFlags & arrDmFlagMap[i] )
        {
            dwFlags |= arrDmFlagMap[i+1];
        }
    }
    return dwFlags;
}

LONG 
DocumentPropertiesWrapNative(
    HWND hwnd,                  // handle to parent window 
    HANDLE hPrinter,            // handle to printer object
    LPTSTR pDeviceName,         // device name
    PDEVMODE pDevModeOutput,    // modified device mode
    PDEVMODE pDevModeInput,     // original device mode
    DWORD fMode,                // mode options
    DWORD fExclusionFlags       // exclusion flags
    )
{
    // lResult <= 0 means error, for more information see
    // the description of DocumentProperties in SDK.
    LONG lResult = (-1);

    if( hPrinter && pDeviceName && pDevModeOutput && pDevModeInput )
    {
        if (fMode & DM_PROMPT)
        {
            // invoke compstui to show up the driver UI
            TDocumentProperties props(hwnd, hPrinter, pDeviceName, pDevModeInput, pDevModeOutput, 
                RemapExclusionFlags(fExclusionFlags), fMode);

            if( props.bDisplayPages(hwnd, &lResult) )
            {
                // convert the result to IDOK/IDCANCEL
                lResult = (lResult == CPSUI_OK) ? IDOK : IDCANCEL;
            }
            else
            {
                // error occured.
                lResult = (-1);
            }
        }
        else
        {
            // this is no UI call - just invoke DocumentProperties.
            lResult = DocumentProperties(hwnd, hPrinter, pDeviceName, pDevModeOutput, pDevModeInput, fMode);
        }
    }

    return lResult;
}

LONG 
DocumentPropertiesWrapWOW64(
    HWND hwnd,                  // handle to parent window 
    HANDLE hPrinter,            // handle to printer object
    LPTSTR pDeviceName,         // device name
    PDEVMODE pDevModeOutput,    // modified device mode
    PDEVMODE pDevModeInput,     // original device mode
    DWORD fMode,                // mode options
    DWORD fExclusionFlags       // exclusion flags
    )
{
    CDllLoader dll(TEXT("winspool.drv"));
    ptr_PrintUIDocumentPropertiesWrap pfnPrintUIDocumentPropertiesWrap =
        (ptr_PrintUIDocumentPropertiesWrap )dll.GetProcAddress(ord_PrintUIDocumentPropertiesWrap);

    LONG lResult = (-1);
    if( pfnPrintUIDocumentPropertiesWrap )
    {
        lResult = pfnPrintUIDocumentPropertiesWrap(hwnd, hPrinter, pDeviceName, pDevModeOutput, pDevModeInput, fMode, fExclusionFlags);
    }
    return lResult;
}

LONG 
DocumentPropertiesWrap(
    HWND hwnd,                  // handle to parent window 
    HANDLE hPrinter,            // handle to printer object
    LPTSTR pDeviceName,         // device name
    PDEVMODE pDevModeOutput,    // modified device mode
    PDEVMODE pDevModeInput,     // original device mode
    DWORD fMode,                // mode options
    DWORD fExclusionFlags       // exclusion flags
    )
{
    // if running in WOW64 environment we need to call winspool.drv to remote the 
    // call into the surrogate 64bit process where the driver UI can be displayed.
    LONG lResult = IsRunningWOW64() ?
        DocumentPropertiesWrapWOW64(hwnd, hPrinter, pDeviceName, pDevModeOutput, pDevModeInput, fMode, fExclusionFlags) :
        DocumentPropertiesWrapNative(hwnd, hPrinter, pDeviceName, pDevModeOutput, pDevModeInput, fMode, fExclusionFlags);
    
    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\dragdrop.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    dragdrop.hxx

Abstract:

    Print queue drag & drop related stuff

Author:

    Lazar Ivanov (LazarI)  10-Mar-2000

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "dragdrop.hxx"

#include <initguid.h>
#include "guids.h"

/////////////////////////////////////////////////////
// CPrintQueueDT - print queue drop target impl.
//
QITABLE_DECLARE(CPrintQueueDT)
class CPrintQueueDT: public CUnknownMT<QITABLE_GET(CPrintQueueDT)>,         // MT impl. of IUnknown
                     public IDropTarget,
                     public IPrintQueueDT,
                     public CSimpleWndSubclass<CPrintQueueDT>
{
private:
    // private members
    void DrawVisualFeedBack() const;
    void VisualFeedBack(const POINTL &ptl, BOOL bRemove = FALSE);
    int GetTargetItem(const POINTL &ptl) const;
    HRESULT DropMoveJob(const DragDrop::JOBINFO &job, POINTL ptl);
    HRESULT DropPrintFiles(IDataObject *pDataObj);
    DWORD RightClickChooseEffect(const POINTL &ptl, DWORD dwEffectIn);
    HRESULT GetPrinterName(LPTSTR pszName, UINT nMaxLength);

    // static services
    static DWORD WINAPI ThreadProc_PrintFiles(LPVOID lpParameter);

public:
    // construction/destruction
    CPrintQueueDT();
    ~CPrintQueueDT();

    //////////////////
    // IUnknown
    //
    IMPLEMENT_IUNKNOWN()

    ///////////////////
    // IPrintQueueDT
    //
    STDMETHODIMP RegisterDragDrop(HWND hwndLV, TPrinter *pPrinter);
    STDMETHODIMP RevokeDragDrop();

    ///////////////////
    // IDropTarget
    //
    virtual HRESULT STDMETHODCALLTYPE DragEnter(
        /* [unique][in] */ IDataObject *pDataObj,
        /* [in] */ DWORD grfKeyState,
        /* [in] */ POINTL pt,
        /* [out][in] */ DWORD *pdwEffect);

    virtual HRESULT STDMETHODCALLTYPE DragOver(
        /* [in] */ DWORD grfKeyState,
        /* [in] */ POINTL pt,
        /* [out][in] */ DWORD *pdwEffect);

    virtual HRESULT STDMETHODCALLTYPE DragLeave( void);

    virtual HRESULT STDMETHODCALLTYPE Drop(
        /* [unique][in] */ IDataObject *pDataObj,
        /* [in] */ DWORD grfKeyState,
        /* [in] */ POINTL pt,
        /* [out][in] */ DWORD *pdwEffect);

    // implement CSimpleWndSubclass<CPrintQueueDT>
    LRESULT WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    // private data
    LONG                m_cRef;                 // ref count
    TPrinter           *m_pPrinter;             // target print queue
    COleComInitializer  m_ole2;                 // make sure OLE2 is initialized.
    AUTO_SCROLL_DATA    m_asd;                  // drag & drop autoscroll stuff (declared in shlobjp.h)
    DWORD               m_grfKeyStateLast;      // we need this to implement IDropTarget::Drop correctly
    DWORD               m_dwEffect;             // save the last effect to implement IDropTarget::DragOver 
    int                 m_iLastItem;            // last item selected (visual feedback)
};

// QueryInterface table
QITABLE_BEGIN(CPrintQueueDT)
     QITABENT(CPrintQueueDT, IDropTarget),      // IID_IDropTarget
     QITABENT(CPrintQueueDT, IPrintQueueDT),    // IID_IPrintQueueDT
QITABLE_END()

///////////////////
// CPrintQueueDT
//
void CPrintQueueDT::DrawVisualFeedBack() const
{
    ASSERT(IsAttached());
    int iCount = ListView_GetItemCount(m_hwnd);
    ASSERT(iCount && m_iLastItem <= iCount && m_iLastItem >= 0);

    RECT rc;
    if( m_iLastItem < ListView_GetItemCount(m_hwnd) )
    {
        ListView_GetItemRect(m_hwnd, m_iLastItem, &rc, LVIR_BOUNDS);
    }
    else
    {
        ListView_GetItemRect(m_hwnd, m_iLastItem-1, &rc, LVIR_BOUNDS);
        InflateRect(&rc, 0, -abs(rc.bottom - rc.top));
    }

    // draw a standard XOR line
    HDC hDC = GetDC(m_hwnd);

    if( hDC )
    {
        CAutoHandlePen shPen = CreatePen(PS_SOLID, 2, GetSysColor(COLOR_WINDOW));

        if( shPen )
        {
            HGDIOBJ hObjOld = SelectObject(hDC, shPen);

            SetROP2(hDC, R2_XORPEN);
            MoveToEx(hDC, rc.left+1, rc.top+1, NULL);
            LineTo(hDC, rc.right-1, rc.top+1);

            SelectObject(hDC, hObjOld);
        }

        ReleaseDC(m_hwnd, hDC);
    }
}

void CPrintQueueDT::VisualFeedBack(const POINTL &ptl, BOOL bRemove)
{
    ASSERT(IsAttached());
    if( bRemove && -1 != m_iLastItem )
    {
        // hide the latest visual feedback
        DrawVisualFeedBack();
        m_iLastItem = -1;
    }
    else
    {
        int iItem = GetTargetItem(ptl);
        if( iItem != -1 && iItem != m_iLastItem )
        {
            if( -1 != m_iLastItem )
            {
                // hide the latest visual feedback
                DrawVisualFeedBack();
                m_iLastItem = -1;
            }

            // save the lastest item and draw the new 
            // visual feedback
            m_iLastItem = iItem;
            DrawVisualFeedBack();
        }
        else
        {
            if( -1 == iItem && -1 != m_iLastItem )
            {
                // hide the latest visual feedback
                DrawVisualFeedBack();
                m_iLastItem = -1;
            }
        }
    }
}

int CPrintQueueDT::GetTargetItem(const POINTL &ptl) const
{
    ASSERT(IsAttached());
    LV_HITTESTINFO info = {0};
    int iItem = -1;

    // find the item on this point
    info.pt.x = ptl.x;
    info.pt.y = ptl.y;
    ScreenToClient(m_hwnd, &info.pt);
    iItem = ListView_HitTest(m_hwnd, &info);

    if( (info.flags & LVHT_ONITEM) && iItem != -1 )
    {
        // get the header RECT here
        RECT rcHeader;
        HWND hwndHeader = ListView_GetHeader(m_hwnd);
        ASSERT(hwndHeader);
        GetWindowRect(hwndHeader, &rcHeader);
        MapWindowPoints(NULL, m_hwnd, reinterpret_cast<LPPOINT>(&rcHeader), 2);

        // check if the point is inside the header.
        if( PtInRect(&rcHeader, info.pt) )
        {
            // this item is partially covered from the header -
            // not a valid item.
            iItem = -1;
        }
        else
        {
            RECT rcItem;
            ListView_GetItemRect(m_hwnd, iItem, &rcItem, LVIR_BOUNDS);
            if( abs(rcItem.top - info.pt.y) > (abs(rcItem.bottom - rcItem.top)/2) )
            {
                // this point is in the lower half of the item rect - 
                // go to the next item (not a problem if iItem == count
                iItem ++;
            }
        }
    }

    return iItem;
}

HRESULT CPrintQueueDT::DropMoveJob(const DragDrop::JOBINFO &job, POINTL ptl)
{
    ASSERT(IsAttached());
    IDENT jobID = -1;
    int iItem = GetTargetItem(ptl);
    HRESULT hr = S_OK;

    // get the position of the job we are mving in front of
    if( iItem < ListView_GetItemCount(m_hwnd) )
    {
        LVITEM lvi = {0};
        lvi.iItem = iItem;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_PARAM;

        if( ListView_GetItem(m_hwnd, &lvi) )
        {
            jobID = m_pPrinter->pData()->GetId((HITEM)lvi.lParam);
        }
    }

    // calculate the new & old position of the job moved
    NATURAL_INDEX uNewPos = (-1 == jobID) ? iItem : m_pPrinter->pData()->GetNaturalIndex(jobID, NULL);
    NATURAL_INDEX uOldPos = (-1 == job.dwJobID) ? job.iItem : m_pPrinter->pData()->GetNaturalIndex(job.dwJobID, NULL);

    if( uNewPos > uOldPos )
    {
        uNewPos--;
    }

    if( uNewPos != uOldPos )
    {
        CAutoHandlePrinter shPrinter = NULL;
        DWORD dwAccess = 0;

        if( ERROR_SUCCESS == TPrinter::sOpenPrinter(job.szPrinterName, &dwAccess, &shPrinter) )
        {
            DWORD cbJob2 = 0;
            CAutoPtrSpl<JOB_INFO_2> spJob2 = NULL;

            if( VDataRefresh::bGetJob(shPrinter, job.dwJobID, 2, spJob2.GetPPV(), &cbJob2) )
            {
                // set the new position and call SetJob to reorder.
                spJob2->Position = uNewPos+1;
                if( !SetJob(shPrinter, job.dwJobID, 2, spJob2.GetPtrAs<LPBYTE>(), 0) )
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    MessageBeep((UINT)-1);
                }
            }
        }
    }

    return hr;
}

HRESULT CPrintQueueDT::DropPrintFiles(IDataObject *pDataObj)
{
    HRESULT hr = E_UNEXPECTED;
    CRefPtrCOM<IStream> spStream;

    // we create a background therad which will attempt to print 
    // documents in pDataObj
    hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pDataObj, &spStream);

    if( SUCCEEDED(hr) )
    {
        CAutoPtr<CCookiesHolder> spThreadInfo = new CCookiesHolder;
        if( spThreadInfo && spThreadInfo->SetCount(2) )
        {
            // as we pass pointer to ourselves to the thread proc 
            // we need to AddRef ourselves here
            AddRef();

            // setup the cookie holder
            spThreadInfo->SetCookie<IStream*>(0, spStream);
            spThreadInfo->SetCookie<CPrintQueueDT*>(1, this);

            // spin the background thread here
            DWORD dwThreadId;
            CAutoHandleNT shThread = TSafeThread::Create(NULL, 0, 
                (LPTHREAD_START_ROUTINE)CPrintQueueDT::ThreadProc_PrintFiles, 
                spThreadInfo, 0, &dwThreadId);

            if( shThread )
            {
                // the thread will take care to free this memory 
                spThreadInfo.Detach();
                spStream.Detach();
                hr = S_OK;
            }
            else
            {
                // thread creation failed. setup appropriate HRESULT from 
                // last error
                hr = HRESULT_FROM_WIN32(GetLastError());

                // compensate the AddRef above
                Release();
            }
        }
        else
        {
            // new CCookiesHolder has failed
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT CPrintQueueDT::GetPrinterName(LPTSTR pszName, UINT nMaxLength)
{
    HRESULT hr = E_INVALIDARG;
    TCHAR szCurrentPrinterName[kPrinterBufMax];
    
    if( pszName )
    {
        if( m_pPrinter )
        {
            m_pPrinter->pszPrinterName(szCurrentPrinterName);
            lstrcpyn(pszName, szCurrentPrinterName, nMaxLength);
            hr = S_OK;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

DWORD WINAPI CPrintQueueDT::ThreadProc_PrintFiles(LPVOID lpParameter)
{
    TCHAR szPrinterName[kPrinterBufMax];
    HRESULT hr = E_UNEXPECTED;
    CAutoPtr<CCookiesHolder> spThreadInfo = (CCookiesHolder *)lpParameter;

    if( spThreadInfo )
    {
        // make sure OLE2 is initialized.
        COleComInitializer ole2(TRUE);

        // get the cookies
        CAutoPtrCOM<IStream> spStream = spThreadInfo->GetCookie<IStream*>(0);
        CAutoPtrCOM<CPrintQueueDT> spPrintQueueDT = spThreadInfo->GetCookie<CPrintQueueDT*>(1);

        if( ole2 && spStream && spPrintQueueDT )
        {
            UINT uCount = 0;
            CAutoPtrPIDL pidlPrinter;
            CRefPtrCOM<IShellFolder> spLocalPrnFolder;
            CRefPtrCOM<IDropTarget> spPrinterDT;

            for( ;; )
            {
                // attempt to get IDropTarget for the printer name
                
                if( SUCCEEDED(hr = spPrintQueueDT->GetPrinterName(szPrinterName, ARRAYSIZE(szPrinterName))) &&
                    SUCCEEDED(hr = ShellServices::CreatePrinterPIDL(NULL, szPrinterName,
                        &spLocalPrnFolder, &pidlPrinter)) &&
                    SUCCEEDED(hr = spLocalPrnFolder->GetUIObjectOf(NULL, 1, pidlPrinter.GetPPCT(),
                        IID_IDropTarget, &uCount, spPrinterDT.GetPPV())) )
                {
                    // unmarshal the data object from the stream
                    CRefPtrCOM<IDataObject> spDataObj;
                    hr = CoGetInterfaceAndReleaseStream(spStream, IID_IDataObject, spDataObj.GetPPV());

                    if( SUCCEEDED(hr) )
                    {
                        // CoGetInterfaceAndReleaseStream relases  the stream -
                        // make sure we don't release twice
                        spStream.Detach();

                        // simulate drag & drop over the printer object here
                        DWORD dwEffect = DROPEFFECT_COPY;
                        hr = SHSimulateDrop(spPrinterDT, spDataObj, MK_LBUTTON, NULL, &dwEffect);
                    }
                }

                if( FAILED(hr) && ERROR_INVALID_PRINTER_NAME == SCODE_CODE(GetScode(hr)) )
                {
                    // this printer is probably a remote printer which the user is not connected to.
                    // he must be connected to the printer in order to be able to print. show up 
                    // appropriate message to inform the user about this case and ask if he wants to 
                    // connect to this printer and then print.
                    if( IDYES == iMessage(NULL, IDS_PRINTERS_TITLE, IDS_PRINT_NOTCONNECTED,
                                          MB_YESNO|MB_ICONQUESTION, kMsgNone, NULL) )
                    {
                        // make a printer connection here.
                        UINT uLen = COUNTOF(szPrinterName);

                        // attempt to connect to this printer. if this fails it shows up the 
                        // appropriate error message, so don't bother to show up UI here.
                        if( bPrinterSetup(NULL, MSP_NETPRINTER, uLen, szPrinterName, &uLen, NULL) )
                        {
                            // release/reset the smart pointers and try to print again.
                            spLocalPrnFolder = NULL;
                            spPrinterDT = NULL;
                            pidlPrinter = NULL;
                            continue;
                        }
                    }
                }

                break;
            }
        }
    }

    // setup the return value here
    if( SUCCEEDED(hr) )
    {
        return ERROR_SUCCESS;
    }
    else
    {
        DWORD dwErr = HRESULT_CODE(hr);
        SetLastError(dwErr);
        return dwErr;
    }
}

// implement CSimpleWndSubclass<CPrintQueueDT>
LRESULT CPrintQueueDT::WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg )
    {
        case WM_VSCROLL:
        case WM_HSCROLL:
            {
                // make sure the feedback is hidden when scrolling
                POINTL ptl = {0};
                VisualFeedBack(ptl, TRUE);
            }
            break;

        default:
            break;
    }

    // allways call the default processing
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

DWORD CPrintQueueDT::RightClickChooseEffect(const POINTL &ptl, DWORD dwEffectIn)
{
    HMENU hMenu = NULL;

    // pop up a menu to choose from.
    if( dwEffectIn == DROPEFFECT_MOVE )
    {
        // we're moving a job
        hMenu = ShellServices::LoadPopupMenu(ghInst, POPUP_DRAGDROP_MOVE);
        SetMenuDefaultItem(hMenu, POPUP_DRAGDROP_MOVE, MF_BYCOMMAND);
    }
    else if( dwEffectIn == DROPEFFECT_COPY )
    {
        // we are printing files
        hMenu = ShellServices::LoadPopupMenu(ghInst, POPUP_DRAGDROP_PRINT);
        SetMenuDefaultItem(hMenu, POPUP_DRAGDROP_PRINT, MF_BYCOMMAND);
    }

    if( hMenu )
    {
        // show up the context menu
        BOOL bReturn = TrackPopupMenu(hMenu, 
            TPM_RETURNCMD|TPM_RIGHTBUTTON|TPM_LEFTALIGN,
            ptl.x, ptl.y, 0, m_hwnd, NULL);

        // modify the dwEffectIn according the user choise
        switch( bReturn )
        {
            case IDM_DRAGDROP_PRINT:
                dwEffectIn = DROPEFFECT_COPY;
                break;

            case IDM_DRAGDROP_MOVE:
                dwEffectIn = DROPEFFECT_MOVE;
                break;

            case IDM_DRAGDROP_CANCEL:
                dwEffectIn = DROPEFFECT_NONE;
                break;

            default:
                dwEffectIn = DROPEFFECT_NONE;
        }

        DestroyMenu(hMenu);
    }
    else
    {
        // if hMenu is NULL (i.e. LoadMenu has falied) then 
        // cancel the whole operation
        dwEffectIn = DROPEFFECT_NONE;
    }

    // return modified dwEffectIn.
    return dwEffectIn;
}

CPrintQueueDT::CPrintQueueDT()
    : m_cRef(1),
      m_pPrinter(NULL),
      m_ole2(TRUE),
      m_grfKeyStateLast(0),
      m_dwEffect(0),
      m_iLastItem(-1)
{
    // nothing
}

CPrintQueueDT::~CPrintQueueDT()
{
    if( IsAttached() )
    {
        RevokeDragDrop();
    }
}

/////////////////////////////////////////////////////
// IPrintQueueDT members
//
STDMETHODIMP CPrintQueueDT::RegisterDragDrop(HWND hwndLV, TPrinter *pPrinter)
{
    HRESULT hr = E_FAIL;

    if( !IsAttached() && m_ole2 && hwndLV && pPrinter )
    {
        // register this window for OLE2 drag & drop
        hr = ::RegisterDragDrop(GetParent(hwndLV), static_cast<IDropTarget*>(this));

        if( SUCCEEDED(hr) && Attach(hwndLV) )
        {
            // make sure shell icon cache is initialized, so
            // DAD_* functions behave correctly.
            FileIconInit(FALSE);

            m_pPrinter = pPrinter;
        }
    }

    return hr;
}

STDMETHODIMP CPrintQueueDT::RevokeDragDrop()
{
    HRESULT hr = E_FAIL;

    if( IsAttached() && m_ole2 && m_pPrinter )
    {
        // unregister this window for OLE2 drag & drop
        hr = ::RevokeDragDrop(GetParent(m_hwnd));

        Detach();
        m_pPrinter = NULL;
    }

    return hr;
}

// this API is supposed to be declared in shlobjp.h, and exported from shell32.dll, 
// but for some reason it isn't. duplicate the code here.
STDAPI_(BOOL) DAD_DragEnterEx3(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtobj)
{
    RECT rc;
    GetWindowRect(hwndTarget, &rc);

    // If hwndTarget is RTL mirrored, then measure the
    // the client point from the visual right edge
    // (near edge in RTL mirrored windows). [samera]
    POINT pt;
    if( GetWindowLong(hwndTarget, GWL_EXSTYLE) & WS_EX_LAYOUTRTL )
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;

    pt.y = ptStart.y - rc.top;
    return DAD_DragEnterEx2(hwndTarget, pt, pdtobj);
}

///////////////////
// IDropTarget
//
HRESULT STDMETHODCALLTYPE CPrintQueueDT::DragEnter(
    /* [unique][in] */ IDataObject *pDataObj,
    /* [in] */ DWORD grfKeyState,
    /* [in] */ POINTL pt,
    /* [out][in] */ DWORD *pdwEffect)
{
    ASSERT(IsAttached());

    // save the last key state
    m_grfKeyStateLast = grfKeyState;

    // by default - none
    *pdwEffect = DROPEFFECT_NONE;

    STGMEDIUM medium;
    FORMATETC fmte = {DragDrop::g_cfPrintJob, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    // try to get DragDrop::g_cfPrintJob data first.
    if( SUCCEEDED(pDataObj->GetData(&fmte, &medium)) )
    {
        // aquire the JOBINFO
        DragDrop::JOBINFO *pJobInfo = (DragDrop::JOBINFO *)GlobalLock(medium.hGlobal);

        if( pJobInfo && pJobInfo->hwndLV == m_hwnd )
        {
            // this is a print job from our window, accept this
            *pdwEffect = DROPEFFECT_MOVE;
        }

        // release medium
        GlobalUnlock(medium.hGlobal);
        ReleaseStgMedium(&medium);
    }
    else
    {
        // try to get CF_HDROP data.
        FORMATETC fmte2 = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        if( SUCCEEDED(pDataObj->QueryGetData(&fmte2)) )
        {
            // we also accept files for printing
            *pdwEffect = DROPEFFECT_COPY;
        }
    }

    // store dwEffect for DragOver
    m_dwEffect = *pdwEffect;

    // invoke shell to do the standard stuff
    DAD_DragEnterEx3(m_hwnd, pt, pDataObj);
    DAD_InitScrollData(&m_asd);

    return S_OK;

}

HRESULT STDMETHODCALLTYPE CPrintQueueDT::DragOver(
    /* [in] */ DWORD grfKeyState,
    /* [in] */ POINTL pt,
    /* [out][in] */ DWORD *pdwEffect)
{
    ASSERT(IsAttached());

    // effect was stored in DragEnter
    *pdwEffect = m_dwEffect;

    // convert to local coords
    POINT pts = {pt.x, pt.y};
    ScreenToClient(m_hwnd, &pts);

    // assume coords of our window match listview
    if( DAD_AutoScroll(m_hwnd, &m_asd, &pts) )
    {
        *pdwEffect |= DROPEFFECT_SCROLL;
    }

    if( DROPEFFECT_MOVE & (*pdwEffect) ) 
    {
        // draw visual feedback if necessary
        VisualFeedBack(pt, FALSE);
    }

    // invoke shell to do the standard stuff
    DAD_DragMove(pts);

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPrintQueueDT::DragLeave( void)
{
    ASSERT(IsAttached());

    // remove the visual feedback if any
    POINTL ptl = {0};
    VisualFeedBack(ptl, TRUE);

    // invoke shell to do the standard stuff
    DAD_DragLeave();

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPrintQueueDT::Drop(
    /* [unique][in] */ IDataObject *pDataObj,
    /* [in] */ DWORD grfKeyState,
    /* [in] */ POINTL pt,
    /* [out][in] */ DWORD *pdwEffect)
{
    ASSERT(IsAttached());
    HRESULT hr = E_UNEXPECTED;

    if( m_grfKeyStateLast & MK_LBUTTON )
    {
        *pdwEffect = m_dwEffect;
    }
    else
    {
        *pdwEffect = RightClickChooseEffect(pt, m_dwEffect);
    }

    // do the drop here

    if( DROPEFFECT_COPY == *pdwEffect )
    {
        // we're printing the file(s) pDataObj to the printer
        DropPrintFiles(pDataObj);
    }
    else if( DROPEFFECT_MOVE == *pdwEffect )
    {
        // we are reordering jobs withing this print queue
        STGMEDIUM medium = {0};
        FORMATETC fmte = {DragDrop::g_cfPrintJob, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        hr = pDataObj->GetData(&fmte, &medium);

        if( SUCCEEDED(hr) )
        {
            DragDrop::JOBINFO *pJobInfo = (DragDrop::JOBINFO *)GlobalLock(medium.hGlobal);

            if( pJobInfo )
            {
                hr = DropMoveJob(*pJobInfo, pt);
                GlobalUnlock(medium.hGlobal);
            }

            ReleaseStgMedium(&medium);
        }
    }

    // make sure to unlock the window for updating
    DragLeave();

    return hr;

}

/////////////////////////////////////////////////////
// common drag & drop APIs & data structures
//
namespace DragDrop
{

// print job clipboard format (JOBINFO)
CLIPFORMAT g_cfPrintJob = 0;

// registers the clipboard format for a print job (JOBINFO)
void RegisterPrintJobClipboardFormat()
{
    if( !g_cfPrintJob )
    {
        g_cfPrintJob = static_cast<CLIPFORMAT>(
            RegisterClipboardFormat(TEXT("PrintJob32")));
    }
}

// creates IDataObject & IDropSource for a printer job objec
HRESULT CreatePrintJobObject(const JOBINFO &jobInfo, REFIID riid, void **ppv)
{
    HRESULT hr = E_INVALIDARG;

    if( ppv )
    {
        *ppv = NULL; // reset this

        // make sure print job data type is registered first
        RegisterPrintJobClipboardFormat();

        // instantiate CSimpleDataObjImpl template for JOBINFO
        CAutoPtrCOM< CDataObj<> > spDataObj = new CDataObj<>;
        CAutoPtrCOM< CSimpleDataObjImpl<JOBINFO> > spJobObj = new CSimpleDataObjImpl<JOBINFO>(jobInfo, g_cfPrintJob, spDataObj);

        if( spDataObj && spJobObj )
        {
            hr = spJobObj->QueryInterface(riid, ppv);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

// instantiate a IPrintQueueDT implementation
HRESULT CreatePrintQueueDT(REFIID riid, void **ppv)
{
    HRESULT hr = E_INVALIDARG;

    if( ppv )
    {
        *ppv = NULL; // reset this

        // instantiate CPrintQueueDT 
        CAutoPtrCOM<CPrintQueueDT> spObj = new CPrintQueueDT;

        if( spObj )
        {
            hr = spObj->QueryInterface(riid, ppv);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

} // namespace DragDrop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\driverdt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998
All rights reserved.

Module Name:

    driverdt.cxx

Abstract:

    Driver details dialog

Author:

    Steve Kiraly (SteveKi)  23-Jan-1997

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "driverif.hxx"
#include "driverlv.hxx"
#include "driverdt.hxx"

/********************************************************************

    Server Drivers Details Dialog.

********************************************************************/
TDriverDetails::
TDriverDetails(
    IN HWND hwnd,
    IN TDriverInfo *pDriverInfo
    ) : _hWnd( hwnd ),
        _bValid( TRUE ),
        _pDriverInfo( pDriverInfo ),
        _hwndLV( NULL ),
        _ColumnSortState( kMaxColumns ),
        _uCurrentColumn( 0 )
{
}

TDriverDetails::
~TDriverDetails(
    VOID
    )
{
}

BOOL
TDriverDetails::
bValid(
    VOID
    )
{
    return _bValid;
}

BOOL
TDriverDetails::
bDoModal(
    VOID
    )
{
    BOOL bReturn = FALSE;
    UINT iMsg = 0;

    if( _pDriverInfo->vGetInfoState() == TDriverInfo::kInstalled )
    {
        bReturn = (BOOL)DialogBoxParam( ghInst,
                                        MAKEINTRESOURCE( DLG_DRIVER_DETAILS ),
                                        _hWnd,
                                        MGenericDialog::SetupDlgProc,
                                        (LPARAM)this );
    }
    else if( _pDriverInfo->vGetInfoState() == TDriverInfo::kAdd )
    {
        iMsg = IDS_DRIVER_ADD_NEEDS_APPLY;
    }
    else if( _pDriverInfo->vGetInfoState() == TDriverInfo::kUpdate )
    {
        iMsg = IDS_DRIVER_UPDATE_NEEDS_APPLY;
    }

    if( iMsg )
    {
        bReturn = iMessage( _hWnd,
                            IDS_DRIVER_DETAILS_TITLE,
                            iMsg,
                            MB_OK|MB_ICONSTOP,
                            kMsgNone,
                            NULL );
    }

    return bReturn;
}

BOOL
TDriverDetails::
bSetUI(
    VOID
    )
{
    SPLASSERT( _pDriverInfo );

    //
    // Get handle to the driver file list view.
    //
    _hwndLV = GetDlgItem( _hDlg, IDC_DRIVER_FILE_LIST_VIEW );

    TStatusB bStatus;
    TString strString;
    LPCTSTR pszFile;
    LPCTSTR pszPath;
    LPCTSTR pszExt;
    TCHAR szScratch[MAX_PATH];
    TString strTemp;

    //
    // Build the list view header.
    //
    bStatus DBGCHK = bBuildListViewHeader();

    //
    // Save a flag that indicates this is a win9x printer driver.
    //
    bStatus DBGCHK = strTemp.bLoadString( ghInst, IDS_ENVIRONMENT_WIN95 );
    BOOL bIsWindows9xDriver = !_tcsicmp( _pDriverInfo->strEnv(), strTemp );

    //
    // Set the edit controls.
    //
    bStatus DBGCHK = bSetEditText( _hDlg, IDC_DRIVER_DETAIL_NAME,       _pDriverInfo->strName() );
    bStatus DBGCHK = bSetEditText( _hDlg, IDC_DRIVER_VERSION,           _pDriverInfo->strVersion() );
    bStatus DBGCHK = bSetEditText( _hDlg, IDC_DRIVER_ENVIRONMENT,       _pDriverInfo->strEnvironment() );
    bStatus DBGCHK = bSetEditText( _hDlg, IDC_DRIVER_LANGUAGE_MONITOR,  _pDriverInfo->strMonitorName() );
    bStatus DBGCHK = bSetEditText( _hDlg, IDC_DRIVER_DEFAULT_DATA_TYPE, _pDriverInfo->strDefaultDataType() );

    bStatus DBGCHK = bSplitPath( szScratch, NULL, &pszPath, NULL, _pDriverInfo->strDriverPath() );
    bStatus DBGCHK = bSetEditText( _hDlg, IDC_DRIVER_PATH, pszPath );

    UINT uCount = 0;

    bStatus DBGCHK = bSplitPath( szScratch, &pszFile, NULL, NULL, _pDriverInfo->strHelpFile() );
    bStatus DBGCHK = bAddListViewItem( IDS_DRIVER_HELP_FILE, pszFile, &uCount );

    bStatus DBGCHK = bSplitPath( szScratch, &pszFile, NULL, NULL, _pDriverInfo->strConfigFile() );
    bStatus DBGCHK = bAddListViewItem( IDS_DRIVER_CONFIG_FILE, pszFile, &uCount );

    bStatus DBGCHK = bSplitPath( szScratch, &pszFile, NULL, NULL, _pDriverInfo->strDataFile() );
    bStatus DBGCHK = bAddListViewItem( IDS_DRIVER_DATA_FILE, pszFile, &uCount );

    bStatus DBGCHK = bSplitPath( szScratch, &pszFile, NULL, NULL, _pDriverInfo->strDriverPath() );
    bStatus DBGCHK = bAddListViewItem( IDS_DRIVER_PATH, pszFile, &uCount );

    for( LPCTSTR psz = _pDriverInfo->strDependentFiles(); psz && *psz; psz += _tcslen( psz ) + 1 )
    {
        bStatus DBGCHK = bSplitPath( szScratch, &pszFile, NULL, &pszExt, psz );

        if( bIsWindows9xDriver && pszExt && ( !_tcsicmp( pszExt, TEXT("ICM" ) ) || !_tcsicmp( pszExt, TEXT("ICC" ) ) ) )
        {
            bStatus DBGCHK = strTemp.bFormat( TEXT("%s\\%s"), TEXT("Color"), pszFile );
        }
        else
        {
            bStatus DBGCHK = strTemp.bUpdate( pszFile );
        }

        bStatus DBGCHK = bAddListViewItem( IDS_DRIVER_DEPENDENT_FILE, strTemp, &uCount );
    }

    //
    // Default is the properties disabled, until an item is selected.
    //
    vEnableCtl( _hDlg, IDC_DRIVER_PROPERTIES, FALSE );

    //
    // Select the first item in the list view.
    //
    ListView_SetItemState( _hwndLV, 0, LVIS_SELECTED | LVIS_FOCUSED, 0x000F );
    ListView_EnsureVisible( _hwndLV, 0, FALSE );

    return TRUE;
}

BOOL
TDriverDetails::
bBuildListViewHeader(
    VOID
    )
{
    //
    // Initialize the LV_COLUMN structure.
    //
    LV_COLUMN lvc;
    lvc.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt     = LVCFMT_LEFT;
    lvc.cx      = kDefaultHeaderWidth;

    //
    // Calculate the header column width.
    //
    RECT rc;
    if( GetClientRect( _hwndLV, &rc ))
    {
        lvc.cx = rc.right / kHeaderMax;
    }

    //
    // Set the column header text.
    //
    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;
    TString strHeader;
    for( INT iCol = 0; iCol < kHeaderMax; ++iCol )
    {
        bStatus DBGCHK  = strHeader.bLoadString( ghInst, IDS_DRIVER_FILE_HEAD_NAME + iCol );
        lvc.pszText     = const_cast<LPTSTR>( static_cast<LPCTSTR>( strHeader ) );
        lvc.iSubItem    = iCol;

        if( ListView_InsertColumn( _hwndLV, iCol, &lvc ) == -1 )
        {
            DBGMSG( DBG_WARN, ( "DriverFileLV.bSetUI: LV_Insert failed %d\n", GetLastError( )));
            bStatus DBGCHK = FALSE;
        }
    }

    //
    // Enable full row selection.
    //
    if( bStatus )
    {
        LRESULT dwExStyle = SendMessage( _hwndLV, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0 );
    	SendMessage( _hwndLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, dwExStyle | LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP );
    }
    return bStatus;
}

BOOL
TDriverDetails::
bAddListViewItem(
    IN UINT      uDescription,
    IN LPCTSTR   pszFileName,
    IN UINT     *pcItems
    )
{
    //
    // All aguments must be valid.
    //
    if( !uDescription || !pszFileName || !*pszFileName || !pcItems )
    {
        return TRUE;
    }

    TStatusB bStatus;
    TString strDescription;

    //
    // Load the description resource string.
    //
    bStatus DBGCHK = strDescription.bLoadString( ghInst, uDescription );

    //
    // Allocate the detail data.
    //
    DetailData *pDetailData = new DetailData;
    if( pDetailData )
    {
        DBGMSG( DBG_TRACE, ( "New Item %x\n", pDetailData ) );

        bStatus DBGCHK = pDetailData->strDescription.bUpdate( strDescription );
        bStatus DBGCHK = pDetailData->strFileName.bUpdate( pszFileName );
    }

    //
    // Add information to the listview.
    //
    LV_ITEM lvi     = { 0 };
    lvi.mask        = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem       = *pcItems;
    lvi.pszText     = const_cast<LPTSTR>( static_cast<LPCTSTR>( strDescription ) );
    lvi.lParam      = (LPARAM)pDetailData;

    ListView_InsertItem( _hwndLV, &lvi );
    ListView_SetItemText( _hwndLV, *pcItems, 1, const_cast<LPTSTR>( pszFileName ) );

    *pcItems = *pcItems + 1;

    return TRUE;
}

BOOL
TDriverDetails::
bHandleProperties(
    VOID
    )
{
    TStatusB bStatus;
    bStatus DBGNOCHK = FALSE;

    //
    // Get the selected item.
    //
    INT iItem = ListView_GetNextItem( _hwndLV, -1, LVNI_SELECTED );

    if( iItem != -1 )
    {
        TCHAR szFileName[MAX_PATH];

        //
        // Retrieve the selected item text.
        //
        ListView_GetItemText( _hwndLV, iItem, 1, szFileName, COUNTOF( szFileName ) );

        //
        // Build the fully qualified file path.
        //
        TString strFullName;

        bStatus DBGCHK = bGetEditText( _hDlg, IDC_DRIVER_PATH, strFullName );
        bStatus DBGCHK = strFullName.bCat( gszWack );
        bStatus DBGCHK = strFullName.bCat( szFileName );

        //
        // Show the shell file object properties.
        //
        TLibrary Lib( gszShellDllName );

        if( VALID_OBJ( Lib ) )
        {
            typedef BOOL ( WINAPI *pfSHObjectProperties)(HWND hwndOwner, DWORD dwType, LPCTSTR lpObject, LPCTSTR lpPage);

            pfSHObjectProperties pSHObjectProperties = reinterpret_cast<pfSHObjectProperties>( Lib.pfnGetProc( 178 ) );

            if( pSHObjectProperties )
            {
                pSHObjectProperties( _hDlg, 2, strFullName, 0 );
            }
        }

        bStatus DBGNOCHK = TRUE;
    }

    return bStatus;
}

BOOL
TDriverDetails::
bSortListView(
    IN LPARAM lParam
    )
{
    //
    // Get the column number.
    //
    _uCurrentColumn = ((NM_LISTVIEW *)lParam)->iSubItem;

    //
    // Sort the list view items.
    //
    TStatusB bStatus;
    bStatus DBGCHK = ListView_SortItems( _hwndLV, iCompareProc, (LPARAM)this );

    //
    // Toggle the specified column sort state.
    //
    _ColumnSortState.bToggle( _uCurrentColumn );

    return bStatus;
}

VOID
TDriverDetails::
vDeleteItems(
    VOID
    )
{
    //
    // Delete all the items.  This is done one at a time
    // inorder to see delete item notifications.
    //
    for( ; ; )
    {
        if( !ListView_DeleteItem( _hwndLV, 0 ) )
            break;
    }
}

INT
CALLBACK
TDriverDetails::
iCompareProc(
    IN LPARAM lParam1,
    IN LPARAM lParam2,
    IN LPARAM RefData
    )
{
    TDriverDetails *pDetails = reinterpret_cast<TDriverDetails *>( RefData );
    DetailData *pDetail1 = reinterpret_cast<DetailData *>( lParam1 );
    DetailData *pDetail2 = reinterpret_cast<DetailData *>( lParam2 );

    LPCTSTR psz1 = NULL;
    LPCTSTR psz2 = NULL;
    BOOL bStatus = TRUE;
    INT iResult  = 0;

    if( pDetails && pDetail1 && pDetail2 )
    {
        switch ( pDetails->_uCurrentColumn )
        {
        case 0:
            psz1 = pDetail1->strDescription;
            psz2 = pDetail2->strDescription;
            break;

        case 1:
            psz1 = pDetail1->strFileName;
            psz2 = pDetail2->strFileName;
            break;

        default:
            bStatus = FALSE;
            break;
        }

        if( bStatus )
        {
            if( pDetails->_ColumnSortState.bRead( pDetails->_uCurrentColumn ) )
                iResult = _tcsicmp( psz1, psz2 );
            else
                iResult = _tcsicmp( psz2, psz1 );
        }
    }

    return iResult;
}

BOOL
TDriverDetails::
bDeleteDetailData(
    IN LPARAM lParam
    )
{
    NM_LISTVIEW *pnmv = (NM_LISTVIEW *) lParam;

    LV_ITEM lvItem  = { 0 };
    lvItem.mask     = LVIF_PARAM;
    lvItem.iItem    = pnmv->iItem;

    BOOL bStatus;

    bStatus = ListView_GetItem( _hwndLV, &lvItem );

    if( bStatus )
    {
        DetailData *pDetailData = reinterpret_cast<DetailData *>( lvItem.lParam );

        DBGMSG( DBG_TRACE, ( "Delete Item %x\n", pDetailData ) );

        delete pDetailData;
    }

    return bStatus;
}

BOOL
TDriverDetails::
bHandleItemSelected(
    VOID
    ) const
{
    BOOL bState = ListView_GetNextItem( _hwndLV, -1, LVNI_SELECTED | LVNI_FOCUSED ) != -1 ? TRUE : FALSE;

    vEnableCtl( _hDlg, IDC_DRIVER_PROPERTIES, bState );

    return TRUE;
}

BOOL
TDriverDetails::
bHandleMessage(
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    BOOL bStatus = TRUE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        bSetUI();
        break;

    //
    // Handle help and context help.
    //
    case WM_HELP:
    case WM_CONTEXTMENU:
        bStatus = PrintUIHelp( uMsg, _hDlg, wParam, lParam );
        break;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {
        case IDOK:
        case IDCANCEL:
            vDeleteItems();
            EndDialog( _hDlg, LOWORD( wParam ) );
            break;

        case IDC_DRIVER_PROPERTIES:
            bStatus = bHandleProperties();
            break;

        default:
            bStatus = FALSE;
            break;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code )
            {
            case NM_CLICK:
                bStatus = bHandleItemSelected();
                break;

            case NM_DBLCLK:
                bStatus = bHandleProperties();
                break;

            case LVN_COLUMNCLICK:
                bStatus = bSortListView( lParam );
                break;

            case LVN_DELETEITEM:
                bStatus = bDeleteDetailData( lParam );
                break;

            case LVN_ITEMCHANGED:
                bStatus = bHandleItemSelected();
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\driverif.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1997
All rights reserved.

Module Name:

    driverif.hxx

Abstract:

    Driver Info Class

Author:

    Steve Kiraly (SteveKi) 23-Jan-1997

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "psetup.hxx"
#include "drvsetup.hxx"
#include "driverif.hxx"
#include "compinfo.hxx"

/********************************************************************

    Server Driver Information.

********************************************************************/
TDriverInfo::
TDriverInfo( 
    IN EType     eType,
    IN UINT      uLevel,
    IN PVOID     pInfo
    ) : _uLevel( uLevel ),
        _eType( eType ),
        _dwVersion ( 0 ),
        _pszDependentFiles( NULL )
{
    DBGMSG( DBG_NONE, ( "TDriverInfo::ctor\n" ) );

    TStatusB bStatus;

    //
    // Copy the driver info level 2 information.
    //
    if( _uLevel >= 2 )
    {
        //
        // Convert pointer to a usable pointer.
        //
        PDRIVER_INFO_2 pInfo2 = reinterpret_cast<PDRIVER_INFO_2>( pInfo );

        _dwVersion     = pInfo2->cVersion; 
        bStatus DBGCHK = _strName.bUpdate( pInfo2->pName );
        bStatus DBGCHK = _strEnv.bUpdate( pInfo2->pEnvironment );
        bStatus DBGCHK = _strDriverPath.bUpdate( pInfo2->pDriverPath );
        bStatus DBGCHK = _strDataFile.bUpdate( pInfo2->pDataFile );
        bStatus DBGCHK = _strConfigFile.bUpdate( pInfo2->pConfigFile );

        //
        // Build the environment and verison string.
        //
        bStatus DBGCHK = bEnvironmentToString( _strEnv, _strEnvironment );
        bStatus DBGCHK = bVersionToString( _dwVersion, _strVersion );
    }

    if( _uLevel == 3 )
    {
        //
        // Convert pointer to a usable pointer.
        //
        PDRIVER_INFO_3 pInfo3 = reinterpret_cast<PDRIVER_INFO_3>( pInfo );

        //
        // Copy the info level 3 specific code.
        //
        bStatus DBGCHK = _strHelpFile.bUpdate( pInfo3->pHelpFile );
        bStatus DBGCHK = _strMonitorName.bUpdate( pInfo3->pMonitorName );
        bStatus DBGCHK = _strDefaultDataType.bUpdate( pInfo3->pDefaultDataType );

        //
        // Copy the dependent files.
        //
        bStatus DBGCHK = bCopyMultizString( &_pszDependentFiles, pInfo3->pDependentFiles );
    }
}

TDriverInfo::
TDriverInfo( 
    const TDriverInfo &rhs
    ) : _uLevel( 0 ),
        _eType( kError ),
        _dwVersion ( 0 ),
        _pszDependentFiles( NULL )
{
    (VOID)bClone( rhs );
}

const TDriverInfo &
TDriverInfo::
operator=(
    const TDriverInfo &rhs
    )
{
    (VOID)bClone( rhs );
    return *this;
}

TDriverInfo::
~TDriverInfo(
    VOID
    )
{
    DBGMSG( DBG_NONE, ( "TDriverInfo::dtor\n" ) );

    //
    // If we are linked then remove ourself.
    //
    if( DriverInfo_bLinked() )
    {
        DriverInfo_vDelinkSelf();
    }

    delete [] _pszDependentFiles;
}

BOOL
TDriverInfo::
bValid(
    VOID
    ) const
{
    BOOL bStatus;

    //
    // Check if the object is valid.
    //
    if( ( _uLevel == 2 || _uLevel == 3 )&& 
        VALID_OBJ( _strVersion )        && 
        VALID_OBJ( _strName )           && 
        VALID_OBJ( _strEnvironment )    && 
        VALID_OBJ( _strDriverPath )     && 
        VALID_OBJ( _strDataFile )       && 
        VALID_OBJ( _strConfigFile )     && 
        VALID_OBJ( _strHelpFile )       && 
        VALID_OBJ( _strMonitorName )    && 
        VALID_OBJ( _strDefaultDataType )&&  
        VALID_OBJ( _strInfName )        &&  
        VALID_OBJ( _strEnv ) )
    {
        bStatus = TRUE;
    }
    else
    {
        bStatus = FALSE;
    }

    return bStatus;
}


VOID
TDriverInfo::
vPrint( 
    VOID
    ) const
{
#if DBG
    DBGMSG( DBG_NONE, ( "DriverInfo %x\n", this ) );

    if( !bValid() )
    {
        DBGMSG( DBG_NONE, ( "DriverInfo object is invalid %x\n", this ) );
    }
    else
    {
        DBGMSG( DBG_TRACE, ( "uLevel             %d\n",         _uLevel ) );
        DBGMSG( DBG_TRACE, ( "eType              %d\n",         _eType ) );
        DBGMSG( DBG_TRACE, ( "dwVerison          %d\n",         _dwVersion ) );
        DBGMSG( DBG_TRACE, ( "_strEnv            " TSTR "\n",   (LPCTSTR)_strEnv ) );
        DBGMSG( DBG_TRACE, ( "strVersion         " TSTR "\n",   (LPCTSTR)_strVersion ) );
        DBGMSG( DBG_TRACE, ( "strName            " TSTR "\n",   (LPCTSTR)_strName ) );
        DBGMSG( DBG_TRACE, ( "strEnvironment     " TSTR "\n",   (LPCTSTR)_strEnvironment ) );
        DBGMSG( DBG_TRACE, ( "strDriverPath      " TSTR "\n",   (LPCTSTR)_strDriverPath ) );
        DBGMSG( DBG_TRACE, ( "strDataFile        " TSTR "\n",   (LPCTSTR)_strDataFile ) );
        DBGMSG( DBG_TRACE, ( "strConfigFile      " TSTR "\n",   (LPCTSTR)_strConfigFile ) );
        DBGMSG( DBG_TRACE, ( "strHelpFile        " TSTR "\n",   (LPCTSTR)_strHelpFile ) );
        DBGMSG( DBG_TRACE, ( "strMonitorName     " TSTR "\n",   (LPCTSTR)_strMonitorName ) );
        DBGMSG( DBG_TRACE, ( "strDefaultDataType " TSTR "\n",   (LPCTSTR)_strDefaultDataType ) );
        DBGMSG( DBG_TRACE, ( "strInfName         " TSTR "\n",   (LPCTSTR)_strInfName ) );

        for( LPCTSTR psz = _pszDependentFiles; psz && *psz; psz += _tcslen( psz ) + 1 )
        {
            DBGMSG( DBG_TRACE, ( "_pszDependentFiles " TSTR "\n", psz ) );
        }
    }
#endif
}

VOID
TDriverInfo::
vSetInfoState(
    EType eType 
    )
{
    _eType = eType;
}

TDriverInfo::EType
TDriverInfo::
vGetInfoState(
    VOID
    ) const
{
    return _eType;
}

LPCTSTR
TDriverInfo::
strDependentFiles(
    VOID
    )
{
    return _pszDependentFiles ? _pszDependentFiles : gszNULL;
}

INT 
TDriverInfo::
operator==(
    const TDriverInfo &rhs
    ) const
{
    DBGMSG( DBG_NONE, ( "TDriverInfo::operator ==\n" ) );
    return _strName    == rhs._strName    &&
           _strEnv     == rhs._strEnv     &&
           _dwVersion  == rhs._dwVersion;
}

INT 
TDriverInfo::
operator>(
    const TDriverInfo &rhs
    ) const
{
    DBGMSG( DBG_TRACE, ( "TDriverInfo::operator >\n" ) );

    BOOL bRetval = 0;

    if( _eType > rhs._eType )
    {
        bRetval = 1;
    }
    else if( _eType == rhs._eType )
    {
        if( _dwVersion > rhs._dwVersion )
        {
            bRetval = 1;
        }
        else if( _dwVersion == rhs._dwVersion )
        {
            //
            // The environment string check is case sensitive.
            //
            INT iResult = _tcscmp( _strEnv, rhs._strEnv );

            if( iResult > 0 )
            {
                bRetval = 1;
            }
            else if( iResult == 0 )
            {
                iResult = _tcsicmp( _strName, rhs._strName );

                if( iResult > 0 )
                {
                    bRetval = 1;
                }
            }
        }
    }
    return bRetval;
}

/********************************************************************

    Drivers Info - private member functions.

********************************************************************/

BOOL
TDriverInfo::
bClone(
    const TDriverInfo &rhs
    )
{
    DBGMSG( DBG_NONE, ( "TDriverInfo::bClone\n" ) );
    TStatusB bStatus;

    if( this == &rhs )
    {
        DBGMSG( DBG_WARN, ( "Clone of self\n" ) );
        bStatus DBGNOCHK = TRUE;
    }
    else
    {
        //
        // Initialize the simple types.
        //
        _uLevel     = rhs._uLevel;
        _eType      = rhs._eType;
        _dwVersion  = rhs._dwVersion; 

        //
        // If we are linked then remove ourself.
        //
        if( DriverInfo_bLinked() )
        {
            DriverInfo_vDelinkSelf();
        }

        //
        // Release any existing dependent file pointer.
        //
        if( _pszDependentFiles )
        {
            delete _pszDependentFiles;
            _pszDependentFiles = NULL;
        }

        //
        // Make a copy of the dependent file multiz string.  A null dependent file
        // pointer only indicates there is not any dependent file information.
        //
        bStatus DBGCHK = bCopyMultizString( &_pszDependentFiles, rhs._pszDependentFiles );

        //
        // Copy the other information strings.
        //
        bStatus DBGCHK  = _strName.bUpdate( rhs._strName ); 
        bStatus DBGCHK  = _strVersion.bUpdate( rhs._strVersion );
        bStatus DBGCHK  = _strEnvironment.bUpdate( rhs._strEnvironment ); 
        bStatus DBGCHK  = _strDriverPath.bUpdate( rhs._strDriverPath ); 
        bStatus DBGCHK  = _strDataFile.bUpdate( rhs._strDataFile ); 
        bStatus DBGCHK  = _strConfigFile.bUpdate( rhs._strConfigFile ); 
        bStatus DBGCHK  = _strHelpFile.bUpdate( rhs._strHelpFile ); 
        bStatus DBGCHK  = _strMonitorName.bUpdate( rhs._strMonitorName ); 
        bStatus DBGCHK  = _strDefaultDataType.bUpdate( rhs._strDefaultDataType );
        bStatus DBGCHK  = _strEnv.bUpdate( rhs._strEnv );
    }

    return bValid();
}

BOOL
TDriverInfo::
bVersionToString( 
    IN      DWORD   dwVersion,
    IN OUT  TString &strVersion 
    ) const
{
    BOOL bStatus = FALSE;
    UINT uVersionResourceId;

    switch( dwVersion )
    {
    case kDriverVersion0:
        if( !_tcscmp( _strEnv, ENVIRONMENT_WINDOWS ) )
            uVersionResourceId = IDS_VERSION_WINDOWS_ME;
        else 
            uVersionResourceId = IDS_VERSION_NT_31;
        break;
                
    case kDriverVersion1:
        if( !_tcscmp( _strEnv, ENVIRONMENT_POWERPC ) )
            uVersionResourceId = IDS_VERSION_351;
        else
            uVersionResourceId = IDS_VERSION_35X;
        break;

    case kDriverVersion2:
        if( !_tcscmp( _strEnv, ENVIRONMENT_POWERPC ) || !_tcscmp( _strEnv, ENVIRONMENT_MIPS ) || !_tcscmp( _strEnv, ENVIRONMENT_ALPHA ) )
            uVersionResourceId = IDS_VERSION_40;
        else
            uVersionResourceId = IDS_VERSION_40_50;
        break;

    case kDriverVersion3:
        if( !_tcscmp( _strEnv, ENVIRONMENT_IA64 ) )
            uVersionResourceId = IDS_VERSION_51;
        else
            uVersionResourceId = IDS_VERSION_50_51;
        break;

    default:
        uVersionResourceId = IDS_ARCH_UNKNOWN;
        break;
    }

    bStatus = strVersion.bLoadString( ghInst, uVersionResourceId );

    return bStatus;
}

BOOL
TDriverInfo::
bEnvironmentToString( 
    IN      LPCTSTR pszEnv,
    IN OUT  TString &strVersion 
    ) const 
{
    TStatusB bStatus;

    if( !_tcscmp( ENVIRONMENT_INTEL, pszEnv ) ) 
        bStatus DBGCHK = strVersion.bLoadString( ghInst, IDS_ARCH_INTEL );
    else if( !_tcscmp( ENVIRONMENT_MIPS, pszEnv ) ) 
        bStatus DBGCHK = strVersion.bLoadString( ghInst, IDS_ARCH_MIPS );
    else if( !_tcscmp( ENVIRONMENT_ALPHA, pszEnv ) ) 
        bStatus DBGCHK = strVersion.bLoadString( ghInst, IDS_ARCH_ALPHA );
    else if( !_tcscmp( ENVIRONMENT_POWERPC, pszEnv ) ) 
        bStatus DBGCHK = strVersion.bLoadString( ghInst, IDS_ARCH_POWERPC );
    else if( !_tcscmp( ENVIRONMENT_WINDOWS, pszEnv ) ) 
        bStatus DBGCHK = strVersion.bLoadString( ghInst, IDS_ARCH_INTEL );
    else if( !_tcscmp( ENVIRONMENT_IA64, pszEnv ) ) 
        bStatus DBGCHK = strVersion.bLoadString( ghInst, IDS_ARCH_IA64 );
    else 
        bStatus DBGCHK = strVersion.bLoadString( ghInst, IDS_ARCH_UNKNOWN );

    return bStatus;
}


/********************************************************************

    DriverTransfer class.

********************************************************************/

TDriverTransfer::
TDriverTransfer(
    VOID
    ) : _cDriverInfo( 0 )
{
    DBGMSG( DBG_NONE, ( "TDriverTransfer::ctor\n" ) );
    DriverInfoList_vReset();
}

TDriverTransfer::
~TDriverTransfer(
    VOID
    )
{
    DBGMSG( DBG_NONE, ( "TDriverTransfer::dtor\n" ) );

    //
    // Release everything from the driver info list.
    //
    TIter Iter;
    TDriverInfo *pDriverInfo;
    DriverInfoList_vIterInit( Iter );

    for( Iter.vNext(); Iter.bValid(); )
    {
        pDriverInfo = DriverInfoList_pConvert( Iter );
        Iter.vNext();
        delete pDriverInfo;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\driverlv.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999
All rights reserved.

Module Name:

    driverlv.hxx

Abstract:

    Driver List View

Author:

    Steve Kiraly (SteveKi) 19-Nov-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "driverif.hxx"
#include "driverlv.hxx"
#include "compinfo.hxx"

/********************************************************************

    Drivers List view class.

********************************************************************/

TDriversLV::
TDriversLV(
    VOID
    ) : _hwnd( NULL ),
        _hwndLV( NULL ),
        _cLVDrivers( 0 ),
        _ColumnSortState( kMaxColumn ),
        _uCurrentColumn( 0 )
{
    DBGMSG( DBG_TRACE, ( "TDriversLV::ctor\n" ) );
    DriverInfoList_vReset();
}

TDriversLV::
~TDriversLV(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TDriversLV::dtor\n" ) );
    vRelease();
}

BOOL
TDriversLV::
bSetUI(
    IN LPCTSTR  pszServerName,
    IN HWND     hwnd,
    IN WPARAM   wmDoubleClickMsg,
    IN WPARAM   wmSingleClickMsg,
    IN WPARAM   wmDeleteKeyMsg
    )
{
    SPLASSERT( hwnd );

    //
    // Save the parent window handle.
    //
    _strServerName.bUpdate( pszServerName );
    _hwnd               = hwnd;
    _wmDoubleClickMsg   = wmDoubleClickMsg;
    _wmSingleClickMsg   = wmSingleClickMsg;
    _wmDeleteKeyMsg     = wmDeleteKeyMsg;

    //
    // Get the driver list view handle.
    //
    _hwndLV = GetDlgItem( _hwnd, IDC_DRIVERS );

    //
    // Initialize the LV_COLUMN structure.
    //
    LV_COLUMN lvc;
    lvc.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt     = LVCFMT_LEFT;
    lvc.cx      = kDriverDefaultHeaderWidth;

    //
    // Set the column header text.
    //
    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;
    TString strHeader;

    for( INT iCol = 0; iCol < kDriverHeaderMax; ++iCol )
    {
        bStatus DBGCHK  = strHeader.bLoadString( ghInst, IDS_DRIVER_HEAD_NAME + iCol );
        lvc.pszText     = const_cast<LPTSTR>( static_cast<LPCTSTR>( strHeader ) );
        lvc.iSubItem    = iCol;

        if( ListView_InsertColumn( _hwndLV, iCol, &lvc ) == -1 )
        {
            DBGMSG( DBG_WARN, ( "DriversLV.bSetUI: LV_Insert failed %d\n", GetLastError( )));
            bStatus DBGCHK = FALSE;
        }
    }

    //
    // Enable full row selection.
    //
    if( bStatus )
    {
        DWORD dwExStyle = ListView_GetExtendedListViewStyle( _hwndLV );
        ListView_SetExtendedListViewStyle( _hwndLV, dwExStyle | LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP | LVS_EX_LABELTIP );
    }

    return bStatus;
}

UINT
TDriversLV::
uGetListViewItemCount(
    VOID
    ) const
{
    return _cLVDrivers;
}

BOOL
TDriversLV::
bIsAnyItemSelcted(
    VOID
    ) const
{
    INT iIndex = -1;
    return bGetSelectedItem( &iIndex );
}

VOID
TDriversLV::
vSelectItem(
    IN UINT iIndex
    )
{
    //
    // Select the specified item.
    //
    if( iIndex != -1 )
    {
        ListView_SetItemState( _hwndLV, iIndex, LVIS_SELECTED | LVIS_FOCUSED, 0x000F );
        ListView_EnsureVisible( _hwndLV, iIndex, FALSE );
    }
}

BOOL
TDriversLV::
bRefresh(
    VOID
    )
{
    TStatusB bStatus;
    //
    // Release all the list view items.
    //
    vDeleteAllListViewItems();

    //
    // Load the new list view data.
    //
    bStatus DBGCHK = bLoadDrivers();

    //
    // This array of numbers represents the percentages of
    // each column width from the total LV width. The sum
    // of all numbers in the array should be equal to 100
    // (100% = the total LV width)
    //
    UINT arrColumnWidths[] = { 38, 22, 40 };

    //
    // Adjust the header column widths here
    //
    vAdjustHeaderColumns( _hwndLV, COUNTOF(arrColumnWidths), arrColumnWidths );

    return bStatus;
}

BOOL
TDriversLV::
bAddDriverInfoToListView(
    TDriverInfo *pDriverInfo,       ADOPT
    BOOL         bCheckForDuplicates
    )
{
    SPLASSERT( pDriverInfo );

    //
    // Should we check for duplicates before adding the driver.
    //
    if( bCheckForDuplicates )
    {
        TDriverInfo *pDrvInfo = NULL;

        if( bFindDriverInfo( pDriverInfo, &pDrvInfo ) )
        {
            //
            // A duplicate was found release the duplicatate,
            // the new one has precedence.
            //
            if( pDrvInfo )
            {
                vDeleteDriverInfoFromListView( pDrvInfo );
                delete pDrvInfo;
            }
        }
    }

    //
    // Append the driver info to the list.
    //
    vAddInSortedOrder( pDriverInfo );

    //
    // Add the driver info to the list view.
    //
    vAddDriverToListView( pDriverInfo );

    return TRUE;
}

BOOL
TDriversLV::
bAddDriverInfoToListView(
    IN TDriverTransfer &DriverTransfer
    )
{
    TIter Iter;
    TDriverInfo *pDriverInfo;

    DriverTransfer.DriverInfoList_vIterInit( Iter );

    for( Iter.vNext(); Iter.bValid(); )
    {
        pDriverInfo = DriverTransfer.DriverInfoList_pConvert( Iter );
        Iter.vNext();

        //
        // If the driver info is linked then unlink it.
        //
        if( pDriverInfo->DriverInfo_bLinked() )
        {
            pDriverInfo->DriverInfo_vDelinkSelf();
        }

        //
        // Add driver to the list view UI.
        //
        (VOID)bAddDriverInfoToListView( pDriverInfo, TRUE );
    }
    return TRUE;
}

BOOL
TDriversLV::
bGetSelectedDriverInfo(
    IN TDriverInfo        **ppDriverInfo,
    IN TDriversLV::THandle &Handle
    ) const
{
    SPLASSERT( ppDriverInfo );

    BOOL    bStatus = FALSE;
    INT     iIndex  = Handle.Index();

    if( bGetSelectedItem( &iIndex ) )
    {
        if( bGetItemData( iIndex, ppDriverInfo ) )
        {
            if( *ppDriverInfo )
            {
                Handle.Index( iIndex );

                bStatus = TRUE;
            }
        }
    }
    return bStatus;
}

BOOL
TDriversLV::
bGetSelectedDriverInfo(
    IN TDriverTransfer &DriverTransfer,
    IN UINT            *pnCount         OPTIONAL
    )
{
    TDriverInfo *pDriverInfo;
    TDriversLV::THandle Handle;
    TStatusB bStatus;
    UINT nCount = 0;

    for( bStatus DBGNOCHK = TRUE; bStatus ; )
    {
        //
        // Remove the selected items from the list.
        //
        bStatus DBGNOCHK = bGetSelectedDriverInfo( &pDriverInfo, Handle );

        if( bStatus )
        {
            //
            // Tallay the selected item count.
            //
            nCount++;

            //
            // If the driver info is linked then unlink it.
            //
            if( pDriverInfo->DriverInfo_bLinked() )
            {
                pDriverInfo->DriverInfo_vDelinkSelf();
            }

            //
            // Append the driver info to the transfer list.
            //
            DriverTransfer.DriverInfoList_vAppend( pDriverInfo );
        }
    }

    //
    // If the caller wants the count of the number of
    // elements placed on the transfer list.
    //
    if( pnCount )
    {
        *pnCount = nCount;
    }

    //
    // If any items were placed on the transfer list then return success.
    //
    return nCount ? TRUE : FALSE;
}

UINT
TDriversLV::
uGetSelectedDriverInfoCount(
    VOID
    ) const
{
    TDriverInfo *pDriverInfo;
    TDriversLV::THandle Handle;
    TStatusB bStatus;
    UINT nCount = 0;

    for( bStatus DBGNOCHK = TRUE; bStatus ; )
    {
        //
        // Remove the selected items from the list.
        //
        bStatus DBGCHK = bGetSelectedDriverInfo( &pDriverInfo, Handle );

        if( bStatus )
        {
            //
            // Tallay the selected item count.
            //
            nCount++;
        }
    }
    return nCount;
}

VOID
TDriversLV::
vDeleteDriverInfoFromListView(
    IN TDriverInfo *pDriverInfo
    )
{
    SPLASSERT( pDriverInfo );

    //
    // Locate the driver name in the list view.
    //
    INT iItem = iFindDriver ( pDriverInfo );

    if( iItem != -1 )
    {
        //
        // Adjust the list view item count.
        //
        _cLVDrivers--;

        //
        // Delete the item.
        //
        ListView_DeleteItem( _hwndLV, iItem );

        //
        // Get the list view item count.
        //
        INT iItemCount = ListView_GetItemCount( _hwndLV );

        //
        // Select next item.  If the item we just deleted is the last item,
        // we need to select the previous one.
        //
        // If we deleted the last item, leave it as is.
        //
        if( iItemCount == iItem && iItem > 0 )
        {
            --iItem;
        }

        //
        // Select the adjacent item.
        //
        vSelectItem( iItem );

        //
        // If there is no items in the list veiw send click notification.
        // The client may need to disable buttons that apply to selected
        // items.
        //
        if( iItemCount == 0 )
        {
            PostMessage( _hwnd, WM_COMMAND, _wmSingleClickMsg, 0 );
        }
    }
}

VOID
TDriversLV::
vDeleteDriverInfoFromListView(
    IN TDriverTransfer &DriverTransfer
    )
{
    TIter Iter;
    TDriverInfo *pDriverInfo;

    DriverTransfer.DriverInfoList_vIterInit( Iter );

    for( Iter.vNext(); Iter.bValid(); )
    {
        pDriverInfo = DriverTransfer.DriverInfoList_pConvert( Iter );
        Iter.vNext();

        //
        // If the driver info is linked then unlink it.
        //
        if( pDriverInfo->DriverInfo_bLinked() )
        {
            pDriverInfo->DriverInfo_vDelinkSelf();
        }

        //
        // Append the driver info to the list no UI.
        //
        vAddInSortedOrder( pDriverInfo );

        //
        // Delete this driver from the UI part of the list view.
        //
        vDeleteDriverInfoFromListView( pDriverInfo );
    }
}

VOID
TDriversLV::
vReturnDriverInfoToListView(
    IN TDriverInfo *pDriverInfo
    )
{
    SPLASSERT( pDriverInfo );

    if( pDriverInfo )
    {
        //
        // If the driver info is linked then unlink it.
        //
        if( pDriverInfo->DriverInfo_bLinked() )
        {
            pDriverInfo->DriverInfo_vDelinkSelf();
        }

        //
        // Append the driver info to the list no UI.
        //
        vAddInSortedOrder( pDriverInfo );
    }
}

VOID
TDriversLV::
vReturnDriverInfoToListView(
    IN TDriverTransfer &DriverTransfer
    )
{
    TIter Iter;
    TDriverInfo *pDriverInfo;

    DriverTransfer.DriverInfoList_vIterInit( Iter );

    for( Iter.vNext(); Iter.bValid(); )
    {
        pDriverInfo = DriverTransfer.DriverInfoList_pConvert( Iter );
        Iter.vNext();

        //
        // If the driver info is linked then unlink it.
        //
        if( pDriverInfo->DriverInfo_bLinked() )
        {
            pDriverInfo->DriverInfo_vDelinkSelf();
        }

        //
        // Append the driver info to the list no UI.
        //
        vAddInSortedOrder( pDriverInfo );
    }
}

BOOL
TDriversLV::
bHandleMessage(
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    BOOL bStatus = TRUE;

    UNREFERENCED_PARAMETER( wParam );

    switch( uMsg )
    {
    case WM_NOTIFY:
        {
            if( (INT)wParam == GetDlgCtrlID( _hwndLV ) )
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;

                switch( pnmh->code )
                {
                case NM_DBLCLK:
                    DBGMSG( DBG_NONE, ("DriversLV::NM_DBLCLK\n" ) );
                    if( _wmDoubleClickMsg )
                    {
                        PostMessage( _hwnd, WM_COMMAND, _wmDoubleClickMsg, 0 );
                    }
                    break;

                case NM_CLICK:
                    DBGMSG( DBG_NONE, ("DriversLV::NM_CLICK\n" ) );
                    if( _wmSingleClickMsg )
                    {
                        PostMessage( _hwnd, WM_COMMAND, _wmSingleClickMsg, 0 );
                    }
                    break;

                case LVN_COLUMNCLICK:
                    DBGMSG( DBG_NONE, ("DriversLV::LVN_COLUMNCLICK\n" ) );
                    {
                        NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;
                        (VOID)bDriverListViewSort( pNm->iSubItem );
                    }
                    break;

                case LVN_ITEMCHANGED:
                    DBGMSG( DBG_NONE, ( "DriversLV::LVN_ITEMCHANGED\n" ) );
                    {
                        NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;
                        if( pNm->uNewState & LVIS_SELECTED )
                        {
                            PostMessage( _hwnd, WM_COMMAND, _wmSingleClickMsg, 0 );
                        }
                    }
                    break;

                case LVN_KEYDOWN:
                    DBGMSG( DBG_NONE, ("DriversLV::LVN_KEYDOWN\n" ) );
                    if( ((LPNMLVKEYDOWN)pnmh)->wVKey == VK_DELETE )
                    {
                        if( _wmDeleteKeyMsg )
                        {
                            PostMessage( _hwnd, WM_COMMAND, _wmDeleteKeyMsg, 0 );
                        }
                    }
                    break;

                default:
                    bStatus = FALSE;
                    break;
                }
            }
            else
            {
                bStatus = FALSE;
            }
        }
        break;

    //
    // Message not handled.
    //
    default:
        bStatus = FALSE;
        break;
    }

    return bStatus;
}

VOID
TDriversLV::
vDeleteAllListViewItems(
    VOID
    )
{
    //
    // Clear the item count.
    //
    _cLVDrivers = 0;

    //
    // Reset the column sort state.
    //
    _ColumnSortState.vResetAll();

    //
    // Delete all the items from the UI control.
    //
    ListView_DeleteAllItems( _hwndLV );

    //
    // Release all the list view data.
    //
    vRelease();
}

BOOL
TDriversLV::
bSortColumn(
    IN const EColumns Column,
    IN const EOrder Order
    )
{
    //
    // Set the sort order.
    //
    if( Order == kAscending )
    {
        _ColumnSortState.bSet( Column );
    }
    else
    {
        _ColumnSortState.bReset( Column );
    }

    //
    // Sort the driver list.
    //
    return bDriverListViewSort( static_cast<UINT>( Column ) );
}

BOOL
TDriversLV::
bSendDriverInfoNotification(
    IN TDriversLVNotify &Notify
    ) const
{
    BOOL bStatus = TRUE;
    TDriverInfo *pDriverInfo;
    //
    // Initialize the list iterator.
    //
    TIter Iter;
    DriverInfoList_vIterInit( Iter );

    //
    // Iterate the added drivers.
    //
    for( Iter.vNext(); bStatus && Iter.bValid();  )
    {
        pDriverInfo = DriverInfoList_pConvert( Iter );

        Iter.vNext();

        SPLASSERT( pDriverInfo );

        if( !Notify.bNotify( pDriverInfo ) )
        {
            bStatus = FALSE;
            break;
        }
    }

    return bStatus;
}

BOOL
TDriversLV::
bGetFullDriverList(
    IN TDriverTransfer &DriverTransfer,
    IN UINT            *pnCount         OPTIONAL
    )
{
    TDriverInfo *pDriverInfo    = NULL;
    UINT         nCount         = 0;

    //
    // Initialize the list iterator.
    //
    TIter Iter;
    DriverInfoList_vIterInit( Iter );

    //
    // Iterate the added drivers.
    //
    for( Iter.vNext(); Iter.bValid();  )
    {
        pDriverInfo = DriverInfoList_pConvert( Iter );

        SPLASSERT( pDriverInfo );

        Iter.vNext();

        //
        // If the driver info is linked then unlink it.
        //
        if( pDriverInfo->DriverInfo_bLinked() )
        {
            pDriverInfo->DriverInfo_vDelinkSelf();
        }

        //
        // Tally the number of drivers.
        //
        nCount++;

        //
        // Append the driver info to the transfer list.
        //
        DriverTransfer.DriverInfoList_vAppend( pDriverInfo );
    }

    //
    // If the caller wants the count of the number of
    // elements placed on the transfer list.
    //
    if( pnCount )
    {
        *pnCount = nCount;
    }

    //
    // If any items were placed on the transfer list then return success.
    //
    return nCount ? TRUE : FALSE;
}

VOID
TDriversLV::
vDumpList(
    VOID
    )
{
#if DBG
    //
    // Release everything from the driver info list.
    //
    TIter Iter;
    TDriverInfo *pDriverInfo;
    DriverInfoList_vIterInit( Iter );

    for( Iter.vNext(); Iter.bValid(); Iter.vNext() )
    {
        pDriverInfo = DriverInfoList_pConvert( Iter );

        DBGMSG( DBG_TRACE, ( "N " TSTR " E " TSTR " V %d T %d\n", (LPCTSTR)pDriverInfo->strName(), (LPCTSTR)pDriverInfo->strEnv(), pDriverInfo->dwVersion(), pDriverInfo->vGetInfoState() ) );
    }
#endif
}


/********************************************************************

    Private member functions.

********************************************************************/

VOID
TDriversLV::
vRelease(
    VOID
    )
{
    //
    // Release everything from the driver info list.
    //
    TIter Iter;
    TDriverInfo *pDriverInfo;

    for( DriverInfoList_vIterInit( Iter ), Iter.vNext(); Iter.bValid(); )
    {
        pDriverInfo = DriverInfoList_pConvert( Iter );
        Iter.vNext();
        delete pDriverInfo;
    }
}

BOOL
TDriversLV::
bLoadDrivers(
    VOID
    )
{
    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;

    LPCTSTR aEnv[] = { { ENVIRONMENT_INTEL },
                       { ENVIRONMENT_MIPS },
                       { ENVIRONMENT_ALPHA },
                       { ENVIRONMENT_POWERPC },
                       { ENVIRONMENT_WINDOWS },
                       { ENVIRONMENT_IA64 } };

    for( UINT index = 0; index < COUNTOF( aEnv ); ++index )
    {
        TDriverInfo    *pDriverInfo     = NULL;
        PDRIVER_INFO_3  pDriverEnumInfo = NULL;
        DWORD           cbBuffer        = 0;
        DWORD           cDrivers        = 0;
        PVOID           pInfo           = NULL;
        UINT            uLevel          = kEnumDriversLevel;

        for( bStatus DBGNOCHK = TRUE ; bStatus; uLevel = 2 )
        {
            //
            // Enumerate all the available drivers.
            //
            bStatus DBGCHK = VDataRefresh::bEnumDrivers( _strServerName,
                                                         const_cast<LPTSTR>( aEnv[index] ),
                                                         uLevel,
                                                         (VOID **)&pDriverEnumInfo,
                                                         &cbBuffer,
                                                         &cDrivers );

            //
            // If the call failed because of an invalid level then try another level.
            //
            if( !bStatus && GetLastError() == ERROR_INVALID_LEVEL && uLevel > 2 )
            {
                bStatus DBGNOCHK = TRUE;
            }
            else
            {
                //
                // In the remote case all environments may not be supported.
                //
                if( !bStatus && GetLastError() == ERROR_INVALID_ENVIRONMENT )
                {
                    bStatus DBGNOCHK = TRUE;
                    break;
                }
                else
                {
                    break;
                }
            }
        }

        if( bStatus )
        {
            LPCTSTR pszDrvName = NULL;

            if( cDrivers )
            {
                for( UINT i = 0; i < cDrivers; ++i )
                {
                    //
                    // Index to the next driver info structure using the level as a guide.
                    //
                    switch( uLevel )
                    {
                    case 2:
                        pInfo = (PCHAR)pDriverEnumInfo + ( sizeof( DRIVER_INFO_2 ) * i );
                        pszDrvName = reinterpret_cast<DRIVER_INFO_2*>(pInfo)->pName;
                        break;

                    case 3:
                        pInfo = (PCHAR)pDriverEnumInfo + ( sizeof( DRIVER_INFO_3 ) * i );
                        pszDrvName = reinterpret_cast<DRIVER_INFO_3*>(pInfo)->pName;
                        break;

                    default:
                        pInfo = NULL;
                        pszDrvName = NULL;
                        break;
                    }

                    if( pInfo && pszDrvName && 0 != lstrcmp(pszDrvName, FAX_DRIVER_NAME) )
                    {
                        //
                        // Create a driver info structure.
                        //
                        pDriverInfo = new TDriverInfo( TDriverInfo::kInstalled, uLevel, pInfo );

                        if( VALID_PTR( pDriverInfo ) )
                        {
                            //
                            // Add the driver information to the list view.  This will orphan the
                            // driver info class to the driver info list which TDriverLV maintains.
                            //
                            bStatus DBGCHK = bAddDriverInfoToListView( pDriverInfo, FALSE );
                        }
                        else
                        {
                            //
                            // The object may have been allocated, however failed construction.
                            //
                            delete pDriverInfo;
                        }
                    }
                }
            }

            //
            // We release the enumeration structure because the driver info data is
            // duplicated in the TDriverInfo class.
            //
            FreeMem( pDriverEnumInfo );
        }
    }

    return bStatus;
}

VOID
TDriversLV::
vAddDriverToListView(
    IN TDriverInfo *pDriverInfo
    )
{
    DBGMSG( DBG_TRACE, ( "TDriversLV::AddDriverToListView\n" ) );

    SPLASSERT( pDriverInfo );

    //
    // Add driver information to the listview.
    //
    LV_ITEM lvi = {0};
    lvi.mask        = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem       = _cLVDrivers;
    lvi.pszText     = const_cast<LPTSTR>( static_cast<LPCTSTR>( pDriverInfo->strName() ) );
    lvi.lParam      = reinterpret_cast<LPARAM>( pDriverInfo );

    ListView_InsertItem( _hwndLV, &lvi );
    ListView_SetItemText( _hwndLV, _cLVDrivers, 1, const_cast<LPTSTR>( static_cast<LPCTSTR>( pDriverInfo->strEnvironment() ) ) );
    ListView_SetItemText( _hwndLV, _cLVDrivers, 2, const_cast<LPTSTR>( static_cast<LPCTSTR>( pDriverInfo->strVersion() ) ) );

    ++_cLVDrivers;
}

BOOL
TDriversLV::
bGetItemData(
    IN INT           iItem,
    IN TDriverInfo **ppDriverInfo
    ) const
{
    SPLASSERT( ppDriverInfo );

    BOOL bStatus;

    LV_ITEM lvItem  = { 0 };
    lvItem.mask     = LVIF_PARAM;
    lvItem.iItem    = iItem;

    bStatus = ListView_GetItem( _hwndLV, &lvItem );

    if( bStatus )
    {
        *ppDriverInfo = reinterpret_cast<TDriverInfo *>( lvItem.lParam );
    }

    return bStatus;
}

BOOL
TDriversLV::
bDriverListViewSort(
    UINT uColumn
    )
{
    //
    // Set the current column.
    //
    _uCurrentColumn = uColumn;

    //
    // Tell the list view to sort.
    //
    TStatusB bStatus;
    bStatus DBGCHK = ListView_SortItems( _hwndLV, iCompareProc, (LPARAM)this );

    //
    // Toggle the specified column sort state.
    //
    _ColumnSortState.bToggle( uColumn );

    return bStatus;
}

BOOL
TDriversLV::
bGetSelectedItem(
    IN INT *pIndex
    ) const
{
    BOOL bStatus = FALSE;

    INT iItem = ListView_GetNextItem( _hwndLV, *pIndex, LVNI_SELECTED );

    if( iItem != -1 )
    {
        bStatus = TRUE;
        *pIndex = iItem;
    }

    return bStatus;
}

INT
CALLBACK
TDriversLV::
iCompareProc(
    IN LPARAM lParam1,
    IN LPARAM lParam2,
    IN LPARAM RefData
    )
{
    TDriversLV *pDriversLV = reinterpret_cast<TDriversLV *>( RefData );

    TDriverInfo *pDriverInfo1 = reinterpret_cast<TDriverInfo *>( lParam1 );
    TDriverInfo *pDriverInfo2 = reinterpret_cast<TDriverInfo *>( lParam2 );
    INT     iResult     = 0;
    DWORD   dwNumber1   = 0;
    DWORD   dwNumber2   = 0;
    LPCTSTR strName1    = NULL;
    LPCTSTR strName2    = NULL;
    BOOL    bNumeric    = FALSE;

    if( pDriversLV && pDriverInfo1 && pDriverInfo2 )
    {
        BOOL bStatus = TRUE;

        switch( pDriversLV->_uCurrentColumn )
        {
        case kDriverNameColumn:
            strName1 = pDriverInfo1->strName();
            strName2 = pDriverInfo2->strName();
            break;

        case kEnvironmentColumn:
            strName1 = pDriverInfo1->strEnvironment();
            strName2 = pDriverInfo2->strEnvironment();
            break;

        case kVersionColumn:
            dwNumber1 = pDriverInfo1->dwVersion();
            dwNumber2 = pDriverInfo2->dwVersion();
            bNumeric = TRUE;
            break;

        default:
            bStatus = FALSE;
            break;

        }

        if( bStatus )
        {
            if( pDriversLV->_ColumnSortState.bRead( pDriversLV->_uCurrentColumn ) )
            {
                if( bNumeric )
                    iResult = dwNumber1 - dwNumber2;
                else
                    iResult = _tcsicmp( strName1, strName2 );
            }
            else
            {
                if( bNumeric )
                    iResult = dwNumber2 - dwNumber1;
                else
                    iResult = _tcsicmp( strName2, strName1 );
            }
        }
    }

    return iResult;
}

/*++

Name:

    iFindDriver

Routine Description:

    Located the specified driver info structure in the list view.

Arguments:

    pDriverInfo - pointer to driver info structure to find.

Return Value:

    iItem id if found, -1 if item was not found.

--*/
INT
TDriversLV::
iFindDriver(
    IN TDriverInfo *pDriverInfo
    ) const
{
    SPLASSERT( pDriverInfo );

    LV_FINDINFO lvfi    = { 0 };
    lvfi.flags          = LVFI_PARAM;
    lvfi.lParam         = (LPARAM)pDriverInfo;

    //
    // Locate the driver item.
    //
    INT iItem = ListView_FindItem( _hwndLV, -1, &lvfi );

    if( iItem == -1 )
    {
        DBGMSG( DBG_WARN, ( "DriverLV.iFindDriver: failed not found\n" ) );
    }
    return iItem;
}


BOOL
TDriversLV::
bFindDriverInfo(
    IN      TDriverInfo *pDriverInfo,
    IN OUT  TDriverInfo **ppDriverInfo
    ) const
{
    BOOL bStatus = FALSE;
    TIter Iter;
    TDriverInfo *pDrvInfo;

    for( DriverInfoList_vIterInit( Iter ), Iter.vNext(); Iter.bValid(); Iter.vNext() )
    {
        pDrvInfo = DriverInfoList_pConvert( Iter );

        if( *pDriverInfo == *pDrvInfo )
        {
            *ppDriverInfo = pDrvInfo;
            bStatus = TRUE;
            break;
        }
    }
    return bStatus;
}

VOID
TDriversLV::
vAddInSortedOrder(
    IN      TDriverInfo *pDriverInfo
    )
{
    BOOL bInserted = FALSE;
    TIter Iter;
    TDriverInfo *pDrvInfo;

    DriverInfoList_vIterInit( Iter );

    for( Iter.vNext(); Iter.bValid(); Iter.vNext() )
    {
        pDrvInfo = DriverInfoList_pConvert( Iter );

        if( *pDrvInfo > *pDriverInfo )
        {
            DriverInfoList_vInsertBefore( Iter, pDriverInfo );
            bInserted = TRUE;
            break;
        }
    }

    if( !bInserted )
    {
        DriverInfoList_vAppend( pDriverInfo );
    }
}

/********************************************************************

    Drivers List View Notify class.

********************************************************************/
TDriversLVNotify::
TDriversLVNotify(
    VOID
    )
{
}

TDriversLVNotify::
~TDriversLVNotify(
    VOID
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\drvsetup.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    drvsetup.cxx

Abstract:

    Printer Driver Setup class.  This class is used to do various
    types of printer driver installations.

Author:

    Steve Kiraly (SteveKi)  01-Nov-1996

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "psetup.hxx"
#include "drvver.hxx"
#include "splapip.h"
#include "compinfo.hxx"
#include "drvsetup.hxx"

/********************************************************************

    Printer Driver installation class.

********************************************************************/

TPrinterDriverInstallation::
TPrinterDriverInstallation(
    IN LPCTSTR pszServerName,
    IN HWND hwnd
    ) : _strServerName( pszServerName ),
        _bValid( FALSE ),
        _hwnd( hwnd ),
        _hSetupDrvSetupParams( INVALID_HANDLE_VALUE ),
        _hSelectedDrvInfo( INVALID_HANDLE_VALUE ),
        _pszServerName( NULL ),
        _dwDriverVersion( (DWORD)kDefault ),
        _dwInstallFlags( 0 )
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::ctor\n" ) );

    //
    // Initialize the os version info structure.
    //
    memset( &_OsVersionInfo, 0, sizeof( _OsVersionInfo ) );

    //
    // Check if the setup library is valid.
    //
    if( !VALID_OBJ( _PSetup ) || !VALID_OBJ( _strServerName ) )
    {
        return;
    }

    //
    // A null server name is the local machine.
    //
    if( pszServerName )
    {
        DBGMSG( DBG_WARN, ( "Remote machine specified.\n" ) );
        _pszServerName = const_cast<LPTSTR>( static_cast<LPCTSTR>( _strServerName ) );
    }

    //
    // Get the setup driver parameter handle.
    //
    _hSetupDrvSetupParams = _PSetup.PSetupCreatePrinterDeviceInfoList( _hwnd );
    if( _hSetupDrvSetupParams == INVALID_HANDLE_VALUE )
    {
        DBGMSG( DBG_WARN, ( "PSetup.PSetupCreatePrinterDeviceInfoList failed.\n" ) );
        return;
    }

    //
    // Get the current platform / driver version.
    //
    if( !bGetCurrentDriver( pszServerName, &_dwDriverVersion ) )
    {
        DBGMSG( DBG_WARN, ( "GetCurrentDriver failed with %d.\n", GetLastError() ) );

        //
        // If we are talking to a remote machine and the get current driver failed
        // then instead of failing construnction use this platforms driver version.
        //
        if( !pszServerName )
        {
            //
            // Unable to get the platform / driver version
            // from the local spooler.
            //
            return;
        }

        //
        // Try to get the driver version from the local spooler
        //
        if( !bGetCurrentDriver( NULL, &_dwDriverVersion ) )
        {
            DBGMSG( DBG_WARN, ( "GetCurrentDriver failed with %d.\n", GetLastError() ) );
            return;
        }
    }

    //
    // We have a valid object.
    //
    _bValid = TRUE;
}

TPrinterDriverInstallation::
~TPrinterDriverInstallation(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::dtor\n" ) );

    //
    // Release the selected driver information.
    //
    vReleaseSelectedDriver();

    //
    // Release the driver setup parameter handle.
    //
    if( _hSetupDrvSetupParams != INVALID_HANDLE_VALUE )
    {
        _PSetup.PSetupDestroyPrinterDeviceInfoList( _hSetupDrvSetupParams );
    }

}

BOOL
TPrinterDriverInstallation::
bValid(
    VOID
    ) const
{
    return _bValid;
}

TPrinterDriverInstallation::EStatusCode
TPrinterDriverInstallation::
ePromptForDriverSelection(
    VOID
    )
{
    SPLASSERT( bValid() );

    TPrinterDriverInstallation::EStatusCode Retval = kError;

    //
    // Release any selected driver information.
    //
    vReleaseSelectedDriver();

    //
    // Display UI for the user to select a driver.
    //
    if( _PSetup.PSetupSelectDriver( _hSetupDrvSetupParams, _hwnd ) )
    {
        //
        // Refresh the driver name with the currently selected driver.
        //
        if( bGetSelectedDriver() )
        {
            DBGMSG( DBG_TRACE, ( "Selected Driver " TSTR "\n", (LPCTSTR)_strDriverName ) );
            Retval = kSuccess;
        }
    }
    else
    {
        //
        // Check if the user hit cancel, this is not
        // an error just normal cancel request.
        //
        if( GetLastError() == ERROR_CANCELLED )
        {
            DBGMSG( DBG_TRACE, ( "Select driver user cancel request.\n" ) );
            Retval = kCancel;
        }
        else
        {
            DBGMSG( DBG_TRACE, ( "PSetupSelectDriver failed %d\n", GetLastError() ) );
            Retval = kError;
        }
    }
    return Retval;
}

BOOL
TPrinterDriverInstallation::
bSetDriverName(
    IN const TString &strDriverName
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::bSetDriverName\n" ) );
    SPLASSERT( bValid() );
    return _strDriverName.bUpdate( strDriverName );
}

BOOL
TPrinterDriverInstallation::
bGetDriverName(
    IN TString &strDriverName
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::bGetDriverName\n" ) );
    SPLASSERT( bValid() );
    return strDriverName.bUpdate( _strDriverName );
}


BOOL
TPrinterDriverInstallation::
bIsDriverInstalled(
    IN const DWORD     xdwDriverVersion,
    IN const BOOL      bKernelModeCompatible
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::bIsDriverInstalled\n" ) );

    SPLASSERT( bValid() );

    TStatusB    bStatus;
    PLATFORM    DriverPlatform;
    DWORD       dwDriverVersion;

    //
    // If the default was passed then then use the pre-fetched version value.
    //
    if( xdwDriverVersion == kDefault )
    {
        DriverPlatform  = GetDriverPlatform( _dwDriverVersion );
        dwDriverVersion = GetDriverVersion( _dwDriverVersion );
    }
    else
    {
        DriverPlatform  = GetDriverPlatform( xdwDriverVersion );
        dwDriverVersion = GetDriverVersion( xdwDriverVersion );
    }

    //
    // If we want to check if this a kernel mode compatible driver
    // then the printer setup api's will accept the kKernelModeDriver
    // value and do the compatiblity check.  Note if the driver version is
    // less than version 2 the kernel mode compatibiltiy flag does not apply.
    //
    if( bKernelModeCompatible && ( _dwDriverVersion >= 2 ) )
    {
        dwDriverVersion = KERNEL_MODE_DRIVER_VERSION;
    }

    //
    // Check if the selected printer is currently installed.
    //
    bStatus DBGNOCHK = _PSetup.PSetupIsDriverInstalled( _pszServerName,
                                                        _strDriverName,
                                                        DriverPlatform,
                                                        dwDriverVersion );
    return bStatus;
}

INT
TPrinterDriverInstallation::
IsDriverInstalledForInf(
    IN const DWORD     xdwDriverVersion,
    IN const BOOL      bKernelModeCompatible
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::iIsDriverInstalledForInf\n" ) );

    SPLASSERT( bValid() );

    INT iReturn = DRIVER_MODEL_NOT_INSTALLED;
    DWORD dwDriverVersion = xdwDriverVersion == kDefault ? _dwDriverVersion  : xdwDriverVersion;

    //
    // We must have a selected driver to call this API.
    //
    TStatusB bStatus;
    bStatus DBGCHK = bIsDriverSelected( );

    if( bStatus )
    {
        //
        // If we want to check if this a kernel mode compatible driver
        // then the printer setup api's will accept the kKernelModeDriver
        // value and do the compatiblity check.  Note if the driver version is
        // less than version 2 the kernel mode compatibiltiy flag does not apply.
        //
        DWORD dwDriver = bKernelModeCompatible && ( dwDriverVersion >= 2 ) ?  KERNEL_MODE_DRIVER_VERSION : GetDriverVersion( dwDriverVersion );

        //
        // Check if the selected printer is currently installed.
        //
        iReturn = _PSetup.PSetupIsTheDriverFoundInInfInstalled( _pszServerName,
                                                                _hSelectedDrvInfo,
                                                                GetDriverPlatform( dwDriverVersion ),
                                                                GetDriverVersion( dwDriverVersion ),
                                                                dwDriver );
    }

    return iReturn;
}

BOOL
TPrinterDriverInstallation::
bSetSourcePath(
    IN const LPCTSTR pszSourcePath,
    IN const BOOL    bClearSourcePath
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::bSetSourcePath\n" ) );
    SPLASSERT( bValid() );

    DBGMSG( DBG_TRACE, ( "SourcePath " TSTR "\n", DBGSTR( pszSourcePath ) ) );

    if( bClearSourcePath )
    {
        return _strSourcePath.bUpdate( NULL );
    }

    return bValidateSourcePath( pszSourcePath ) && _strSourcePath.bUpdate( pszSourcePath );
}

VOID
TPrinterDriverInstallation::
SetInstallFlags(
    DWORD dwInstallFlags
    )
{
    _dwInstallFlags = dwInstallFlags;
}

DWORD
TPrinterDriverInstallation::
GetInstallFlags(
    VOID
    ) const
{
    return _dwInstallFlags;
}

BOOL
TPrinterDriverInstallation::
bInstallDriver(
    OUT TString       *pstrNewDriverName,
    IN  BOOL           bOfferReplacement,
    IN const BOOL      xInstallFromWeb,
    IN const HWND      xhwnd,
    IN const DWORD     xdwDriverVersion,
    IN const DWORD     xdwAddDrvFlags,
    IN const BOOL      xbUpdateDriver,
    IN const BOOL      xbIgnoreSelectDriverFailure
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::bInstallDriver\n" ) );

    SPLASSERT( bValid() );
    SPLASSERT( !_strDriverName.bEmpty() );

    TStatus     Status;
    TStatusB    bStatus;
    DWORD       dwDriverVersion  = xdwDriverVersion == kDefault ? _dwDriverVersion    : xdwDriverVersion;
    HWND        hwnd             = xhwnd == NULL                ? _hwnd               : xhwnd;
    BOOL        bInstallFromWeb  = xInstallFromWeb == kDefault  ? FALSE               : xInstallFromWeb;
    DWORD       dwAddDrvFlags    = xdwAddDrvFlags == kDefault   ? APD_COPY_NEW_FILES  : xdwAddDrvFlags;
    BOOL        bUseDriverName   = FALSE;

    //
    // Assume success.
    //
    bStatus DBGNOCHK = TRUE;

    //
    // This is an optimization.  Since getting the selected driver actually parses
    // the inf file.  In this routine we will execute the if statement the
    // caller has set the driver name without selecting a driver.
    //
    if( !bIsDriverSelected( ) && xbUpdateDriver == kDefault )
    {
        //
        // If a driver name was set then select a driver using this name.
        //
        BOOL bSelectFromName = _strDriverName.bEmpty() ? FALSE : TRUE;

        //
        // Select the driver.
        //
        bStatus DBGCHK = bSelectDriver( bSelectFromName );

        //
        // In the case the caller just wants to use the inf if one exists
        // if an inf does not exist for this driver then prompt them.  If
        // the caller wants to prompt the user if an inf does not exist they
        // should set the bIgnoreSelectDriverFailure to true.
        //
        if (bStatus == FALSE && xbIgnoreSelectDriverFailure == TRUE)
        {
            bStatus DBGCHK = TRUE;
            bUseDriverName = TRUE;
        }
    }

    if( bStatus )
    {
        //
        // Get the driver architecture name.
        //
        TString strDrvArchName;
        bStatus DBGCHK = bGetArchName(dwDriverVersion, strDrvArchName );

        DBGMSG( DBG_TRACE, ( "Driver Architecture and version " TSTR "\n", static_cast<LPCTSTR>( strDrvArchName ) ) );

        if( bStatus )
        {
            LPCTSTR pszSourcePath = _strSourcePath.bEmpty() ? NULL : (LPCTSTR)_strSourcePath;

            if( bInstallFromWeb )
            {
                //
                // Install the specified printer driver.
                //
                Status DBGCHK = _PSetup.PSetupInstallPrinterDriverFromTheWeb( _hSetupDrvSetupParams,
                                                                              _hSelectedDrvInfo,
                                                                              GetDriverPlatform( dwDriverVersion ),
                                                                              _pszServerName,
                                                                              pGetOsVersionInfo(),
                                                                              hwnd,
                                                                              pszSourcePath );
            }
            else
            {

                HANDLE  hDriverInfo     = _hSelectedDrvInfo;
                LPCTSTR pszDriverName   = _strDriverName;

                //
                // If we are not updating the driver then clear the driver name.
                //
                if( xbUpdateDriver == kDefault && bUseDriverName == FALSE )
                {
                    pszDriverName = NULL;
                }
                else
                {
                    hDriverInfo = NULL;
                }

                //
                // Install the specified printer driver.
                //
                Status DBGCHK = _PSetup.PSetupInstallPrinterDriver( _hSetupDrvSetupParams,
                                                                    hDriverInfo,
                                                                    pszDriverName,
                                                                    GetDriverPlatform( dwDriverVersion ),
                                                                    GetDriverVersion( dwDriverVersion ),
                                                                    _pszServerName,
                                                                    hwnd,
                                                                    strDrvArchName,
                                                                    pszSourcePath,
                                                                    _dwInstallFlags,
                                                                    dwAddDrvFlags,
                                                                    pstrNewDriverName,
                                                                    bOfferReplacement );
            }

            //
            // Set up the correct return value.
            //
            bStatus DBGNOCHK = Status == ERROR_SUCCESS ? TRUE : FALSE;

            if( !bStatus )
            {
                SetLastError( Status );
            }
        }
    }

    return bStatus;
}

VOID
TPrinterDriverInstallation::
vPrinterAdded(
    IN const TString &strFullPrinterName
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::vPrinterAdded\n" ) );
    DBGMSG( DBG_TRACE, ( "strFullPrinterName " TSTR "\n", static_cast<LPCTSTR>( strFullPrinterName ) ) );

    TStatusB bStatus;
    bStatus DBGCHK = bIsDriverSelected( );

    if( bStatus )
    {
        _PSetup.PSetupProcessPrinterAdded( _hSetupDrvSetupParams,
                                           _hSelectedDrvInfo,
                                            strFullPrinterName,
                                           _hwnd );
    }
}

BOOL
TPrinterDriverInstallation::
bGetDriverSetupPage(
    IN OUT HPROPSHEETPAGE *pPage,
    IN LPCTSTR pszTitle,
    IN LPCTSTR pszSubTitle,
    IN LPCTSTR pszInstrn
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::bGetDriverSetupPage\n" ) );

    SPLASSERT( bValid() );

    //
    // Set the title and instructions if provided. Note that this function may fail
    //
    TStatusB bStatus;
    bStatus DBGCHK = bSetDriverSetupPageTitle(pszTitle, pszSubTitle, pszInstrn);

    if( bStatus )
    {
        //
        // Get the select device page handle.
        //
        *pPage = _PSetup.PSetupCreateDrvSetupPage(_hSetupDrvSetupParams, _hwnd);
        bStatus DBGCHK = ((*pPage) ? TRUE : FALSE);
    }

    return bStatus;
}

BOOL
TPrinterDriverInstallation::
bSetWebMode(
    IN BOOL bWebButtonOn
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::bSetWebMode\n" ) );

    SPLASSERT( bValid() );

    //
    // Set the web button state i.e. enabled|disbled, on the model manufacture dialog.
    //
    return _PSetup.PSetupSetWebMode( _hSetupDrvSetupParams, bWebButtonOn );
}


BOOL
TPrinterDriverInstallation::
bShowOem(
    IN BOOL bShowOem
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::bShowOem\n" ) );

    SPLASSERT( bValid() );

    //
    // Enable or Disable the have disk button.
    //
    return _PSetup.PSetupShowOem( _hSetupDrvSetupParams, bShowOem );
}

BOOL
TPrinterDriverInstallation::
bSetDriverSetupPageTitle(
    IN LPCTSTR pszTitle,
    IN LPCTSTR pszSubTitle,
    IN LPCTSTR pszInstrn
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::bSetDriverSetupPageTitle\n" ) );

    SPLASSERT( bValid() );

    BOOL bReturn = FALSE;

    //
    // Set the title and instructions if provided.
    //
    if( ( pszTitle && *pszTitle ) || ( pszInstrn && *pszInstrn ) || ( pszSubTitle && *pszSubTitle ) )
    {
       bReturn = _PSetup.PSetupSetSelectDevTitleAndInstructions( _hSetupDrvSetupParams, pszTitle, pszSubTitle, pszInstrn );
    }
    return bReturn;
}

BOOL
TPrinterDriverInstallation::
bGetSelectedDriver(
    const BOOL bForceReselection
    )
{
    SPLASSERT( bValid() );

    TStatusB bStatus;
    BOOL bSelectFromName = FALSE;

    if( bForceReselection )
    {
        //
        // Release the selected driver
        //
        vReleaseSelectedDriver();

        //
        // Set the reselect flag.
        //
        bSelectFromName = _strDriverName.bEmpty() ? FALSE : TRUE;
    }

    //
    // Select the driver.
    //
    bStatus DBGCHK = bSelectDriver( bSelectFromName );
    bStatus DBGCHK = bIsDriverSelected( );

    if( bStatus )
    {
        if( !bSelectFromName )
        {
            //
            // Update the selected driver name.
            //
            bStatus DBGCHK = _PSetup.bGetSelectedDriverName( _hSelectedDrvInfo,
                                                             _strDriverName,
                                                             GetDriverPlatform( _dwDriverVersion ) );
        }
    }

    return bStatus;
}

BOOL
TPrinterDriverInstallation::
bSelectDriverFromInf(
    IN LPCTSTR         pszInfName,
    IN BOOL            bIsSingleInf
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::bInstallDriverFromInf\n" ) );
    SPLASSERT( bValid() );

    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;

    if( bStatus )
    {
        bStatus DBGCHK = _PSetup.PSetupBuildDriversFromPath( _hSetupDrvSetupParams, pszInfName, bIsSingleInf );
    }

    if( bStatus )
    {
        bStatus DBGCHK = _PSetup.PSetupPreSelectDriver( _hSetupDrvSetupParams, NULL, _strDriverName );
    }

    return bStatus;
}

//
// Return:
// TRUE CodeDownload is available, FALSE CodeDownload not available.
//
BOOL
TPrinterDriverInstallation::
bIsCodeDownLoadAvailable(
    VOID
    )
{
    TLibrary Lib( gszCodeDownLoadDllName );

    if( VALID_OBJ( Lib ) )
    {
        pfDownloadIsInternetAvailable pDownloadAvailable = NULL;

        pDownloadAvailable = reinterpret_cast<pfDownloadIsInternetAvailable>( Lib.pfnGetProc( "DownloadIsInternetAvailable" ) );

        if( pDownloadAvailable )
        {
            return pDownloadAvailable();
        }
    }
    return FALSE;
}

//
// Return the selected print processor name.
//
BOOL
TPrinterDriverInstallation::
bGetPrintProcessor(
    IN TString &strPrintProcessor
    ) const
{
    TStatusB bStatus;
    bStatus DBGCHK = bIsDriverSelected( );

    if( bStatus )
    {
        bStatus DBGCHK = _PSetup.bGetSelectedPrintProcessorName( _hSelectedDrvInfo, strPrintProcessor, GetDriverPlatform( _dwDriverVersion ) );
    }

    return bStatus;
}

//
// Return the selected inf file name.
//
BOOL
TPrinterDriverInstallation::
bGetSelectedInfName(
    IN TString &strInfName
    )  const
{
    TStatusB bStatus;
    bStatus DBGCHK = bIsDriverSelected( );

    if( bStatus )
    {
        bStatus DBGCHK = _PSetup.bGetSelectedInfName( _hSelectedDrvInfo, strInfName, GetDriverPlatform( _dwDriverVersion ) );
    }

    return bStatus;
}

//
// Return if the currently selected driver is an oem driver.
//
BOOL
TPrinterDriverInstallation::
bIsOemDriver(
    VOID
    )  const
{
    TStatusB bStatus;
    bStatus DBGCHK = bIsDriverSelected( );
    BOOL bIsOemDriver = FALSE;

    if( bStatus )
    {
        (VOID)_PSetup.PSetupIsOemDriver( _hSetupDrvSetupParams, _hSelectedDrvInfo, &bIsOemDriver );
    }

    return (bStatus && bIsOemDriver);
}

//
// Return the current driver encoding.  This is useful because
// getting the current driver encode is very expensive accross
// a remote connetion, and this class only fetches the
// version once per instantiation.
//
BOOL
TPrinterDriverInstallation::
bGetCurrentDriverEncode(
    IN DWORD *pdwEncode
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::bGetCurrentDriverEncode\n" ) );
    SPLASSERT( bValid() );

    //
    // The driver version should be initialized at this point.
    //
    SPLASSERT( _dwDriverVersion != (DWORD)kDefault );

    *pdwEncode = _dwDriverVersion;

    return TRUE;
}

//
// Return the current driver version.  This is useful because
// getting the current driver encode is very expensive accross
// a remote connetion.  This class only fetches the
// version once per instantiation.
//
DWORD
TPrinterDriverInstallation::
dwGetCurrentDriverVersion(
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::bGetCurrentDriverVersion\n" ) );
    SPLASSERT( bValid() );

    //
    // The driver version should be initialized at this point.
    //
    SPLASSERT( _dwDriverVersion != (DWORD)kDefault );

    return GetDriverVersion( _dwDriverVersion );
}

//
// Restores the driver list to the default driver list.
//
BOOL
TPrinterDriverInstallation::
bRefreshDriverList(
    VOID
    )
{
    return _PSetup.PSetupRefreshDriverList( _hSetupDrvSetupParams );
}

//
// Expose the original hwnd, user of the class need this
// to ensure they are using the same hwnd when displaying messages.
//
HWND
TPrinterDriverInstallation::
hGetHwnd(
    VOID
    ) const
{
    return _hwnd;
}

/********************************************************************

    Private member functions.

********************************************************************/

BOOL
TPrinterDriverInstallation::
bValidateSourcePath(
    IN LPCTSTR pszSourcePath
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::bValidateSourcePath\n" ) );
    SPLASSERT( bValid() );

    TStatusB bStatus;

    if( GetFileAttributes( pszSourcePath ) & FILE_ATTRIBUTE_DIRECTORY )
    {
        bStatus DBGNOCHK = TRUE;
    }
    else
    {
        SetLastError( ERROR_DIRECTORY );
        bStatus DBGNOCHK = FALSE;
    }

    return bStatus;
}

BOOL
TPrinterDriverInstallation::
bIsDriverSelected(
    VOID
    ) const
{
    SPLASSERT( bValid() );
    return _hSelectedDrvInfo != INVALID_HANDLE_VALUE;
}

BOOL
TPrinterDriverInstallation::
bSelectDriver(
    IN BOOL bFromName
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::bGetSelectedDriverInfo\n" ) );
    SPLASSERT( bValid() );

    vReleaseSelectedDriver();

    if( bFromName )
    {
        _hSelectedDrvInfo = _PSetup.PSetupDriverInfoFromName( _hSetupDrvSetupParams, _strDriverName );
    }
    else
    {
        _hSelectedDrvInfo = _PSetup.PSetupGetSelectedDriverInfo( _hSetupDrvSetupParams );
    }

    BOOL bRetval;

    TStatusB bStatus;
    bStatus DBGCHK = bIsDriverSelected( );

    if( !bStatus )
    {
        DBGMSG( DBG_TRACE, ( "PSetupGetSelectedDriverInfo failed with %d\n", GetLastError() ) );
        bRetval = FALSE;
    }
    else
    {
        bRetval = TRUE;
    }

    return bRetval;
}

VOID
TPrinterDriverInstallation::
vReleaseSelectedDriver(
    VOID
    )
{
    //
    // Release the selected driver information.
    //
    if( _hSelectedDrvInfo != INVALID_HANDLE_VALUE )
    {
        DBGMSG( DBG_TRACE, ( "TPrinterDriverInstallation::vReleaseSelectedDriverInfo\n" ) );
        _PSetup.PSetupDestroySelectedDriverInfo( _hSelectedDrvInfo );
        _hSelectedDrvInfo = INVALID_HANDLE_VALUE;
    }
}

//
// Return the os version info structure.
//
OSVERSIONINFO *
TPrinterDriverInstallation::
pGetOsVersionInfo(
    VOID
    )
{
    //
    // If the os version was not iniaitlized.
    //
    if( !_OsVersionInfo.dwOSVersionInfoSize )
    {
        //
        // Set the osversion info structure size.
        //
        _OsVersionInfo.dwOSVersionInfoSize = sizeof( _OsVersionInfo );

        //
        // Get the osversion info structure size
        //
        if( !SpoolerGetVersionEx( _pszServerName, &_OsVersionInfo ) )
        {
            //
            // Indicate a failure occured.
            //
            _OsVersionInfo.dwOSVersionInfoSize = 0;
        }
    }

    if( _OsVersionInfo.dwOSVersionInfoSize )
    {
        DBGMSG( DBG_TRACE, ("_OsVersionInfo.dwOSVersionInfoSize %d\n",  _OsVersionInfo.dwOSVersionInfoSize ) );
        DBGMSG( DBG_TRACE, ("_OsVersionInfo.dwMajorVersion      %d\n",  _OsVersionInfo.dwMajorVersion ) );
        DBGMSG( DBG_TRACE, ("_OsVersionInfo.dwMinorVersion      %d\n",  _OsVersionInfo.dwMinorVersion ) );
        DBGMSG( DBG_TRACE, ("_OsVersionInfo.dwBuildNumber       %d\n",  _OsVersionInfo.dwBuildNumber ) );
        DBGMSG( DBG_TRACE, ("_OsVersionInfo.dwPlatformId        %d\n",  _OsVersionInfo.dwPlatformId ) );
        DBGMSG( DBG_TRACE, ("_OsVersionInfo.szCSDVersion        "TSTR"\n",  _OsVersionInfo.szCSDVersion ) );
    }

    return &_OsVersionInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\findloc.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999
All rights reserved.

Module Name:

    findloc.cxx

Abstract:

    This module provides all the functions for browsing the
    physical location tree stored in an Active Directory

Author:

    Lazar Ivanov (LazarI)   23-Nov-1998
    Steve Kiraly (SteveKi)  24-Nov-1998
    Lazar Ivanov (LazarI)   Nov-28-2000 - redesign the tokenizer
    Weihai Chen  (WeihaiC)  Mar-28-2001 - use DS search to enumerate location data

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "dsinterf.hxx"
#include "findloc.hxx"
#include "physloc.hxx"

enum
{
    kDSIconIndex = 1,
};

/******************************************************************************

    Utility functions

******************************************************************************/

/*++

Name:

    vRecursiveGetSel

Description:

    Finds the selecton string denoted by parent nodes
    of the current treeview item, then appends
    string of the current item

Arguments:

    hTree - handle to treeview control
    pItem - pointer to current item
    strSel - reference to string to fill in
    hStop - tree item to stop recursing

Return Value:

    None

Notes:


--*/

VOID
vRecursiveGetSel (
    IN  HWND hTree,
    IN  const TVITEM *pItem,
    OUT TString &strSel,
    IN  HTREEITEM hStop
    )
{
    TVITEM tvParent;
    TCHAR szItem[TPhysicalLocation::kMaxPhysicalLocation];
    TStatusB bStatus;

    tvParent.mask = TVIF_TEXT|TVIF_HANDLE;
    tvParent.pszText = szItem;
    tvParent.cchTextMax = TPhysicalLocation::kMaxPhysicalLocation;

    //
    // If we're at the root, init the string
    //
    if ((tvParent.hItem = TreeView_GetParent (hTree, pItem->hItem))==hStop)
    {
        bStatus DBGCHK = strSel.bUpdate (pItem->pszText);
    }
    else
    {
        //
        // Get the string denoted by my parent nodes, then append my string
        //
        TreeView_GetItem (hTree, &tvParent);
        vRecursiveGetSel (hTree, &tvParent, strSel, hStop);
        bStatus DBGCHK = strSel.bCat (pItem->pszText);
    }

    //
    // Append a slash
    //
    bStatus DBGCHK = strSel.bCat (gszSlash);
}

/*++

Name:

    Tokenize

Description:

    Replace any valid separators with NULL in the dest string

Arguments:

    LPTSTR pszDest      - where to put the dest string
    UNIT nMaxLength     - size of the buffer of dest
    LPCTSTR pszSrc      - source string
    LPTSTR *pszStart    - start markup
    LPTSTR *pszEnd      - end markup

Return Value:

    None

--*/

VOID
Tokenize(
    OUT LPTSTR pszDest,
    IN  UINT nMaxLength,
    IN  LPCTSTR pszSrc,
    OUT LPTSTR *pszStart,
    OUT LPTSTR *pszEnd
    )
{
    ASSERT(pszDest);
    ASSERT(nMaxLength);
    ASSERT(pszSrc);
    ASSERT(pszStart);
    ASSERT(pszEnd);

    // make a copy
    lstrcpyn(pszDest, pszSrc, nMaxLength);

    // replace all the valid separators with zeros
    int i, iLen = lstrlen(pszDest);
    for( i=0; i<iLen; i++ )
    {
        if( TEXT('\\') == pszDest[i] || TEXT('/')  == pszDest[i] )
        {
            pszDest[i] = 0;
        }
    }

    // initialize the walk pointers
    *pszStart = pszDest;
    *pszEnd = pszDest + iLen;
}

/******************************************************************************

    TLocData methods

******************************************************************************/

/*++

Name:

    TLocData constructor

Description:

    Creates the TLocData, the TLocData is the data that is shared between
    the UI thread and the background thread.  To ensure the data's life time
    refrence counting is used.

Arguments:

    pszClassName
    pszWindowName          - the class name and window name of toplevel window
                             where the message will be posted when data is ready
    uMsgDataReady          - the user message posted, which should be posted
    bFindPhysicalLocation  - should expand default

Return Value:

    None

Notes:

--*/

TLocData::
TLocData(
    IN LPCTSTR pszClassName,
    IN LPCTSTR pszPropertyName,
    IN UINT    uMsgDataReady,
    IN BOOL    bFindPhysicalLocation
    ) :
       _uMsgDataReady(uMsgDataReady),
       _bFindPhysicalLocation(bFindPhysicalLocation),
       _bIsDataReady(FALSE),
       _strWindowClass( pszClassName ),
       _strPropertyName( pszPropertyName )
{
    _bValid = _strWindowClass.bValid() && _strPropertyName.bValid();
}

/*++

Name:

    TLocData destructor

Description:

    Deletes the linked list nodes

Arguments:

    None

Return Value:

    None

Notes:


--*/

TLocData::
~TLocData(
     VOID
     )
{
    //
    // Free the locations list
    //
    TLoc *pLoc;
    while( !_LocationList_bEmpty() )
    {
        pLoc = _LocationList_pHead();
        pLoc->_Location_vDelinkSelf();
        delete pLoc;
    }
}

/*++

Name:

    bValid

Description:

    Class valid check routine.

Arguments:

    None

Return Value:

    TRUE  - class is valid and usable,
    FALSE - class is not usable.

Notes:

--*/

BOOL
TLocData::
bValid(
    VOID
    ) const
{
    return _bValid;
}

/*++

Name:

    TLocData::vNotifyUIDataIsReady

Description:

    Notify the UI the background work is done

Arguments:

    None

Return Value:

    None

Notes:

--*/

VOID
TLocData::
vNotifyUIDataIsReady(
    VOID
    )
{
    //
    // Check if the data is ready first
    //
    if( _bIsDataReady )
    {
        for (HWND hWnd = FindWindow(_strWindowClass, NULL); hWnd; hWnd = GetWindow(hWnd, GW_HWNDNEXT))
        {
            TCHAR szBuffer[MAX_PATH];

            if( !GetClassName(hWnd, szBuffer, COUNTOF(szBuffer)) )
            {
                continue;
            }

            //
            // check again ensure that class name is same
            // if we obtained this handle from GetWindow( ... )
            //
            if( !_tcsicmp( szBuffer, _strWindowClass ) )
            {
                HANDLE hProp = GetProp( hWnd, _strPropertyName );

                //
                // Just verify who we are?
                //
                if( hProp == reinterpret_cast<HANDLE>(this) )
                {
                    //
                    // Apropriate window found - post the message
                    //
                    PostMessage( hWnd, _uMsgDataReady, 0, reinterpret_cast<LPARAM>(this) );
                    break;
                }
            }
        }
    }
}

/*++

Name:

    TLocData::FindLocationsThread

Description:

    static thread procedure, invokes the real worker proc

Arguments:

    pData - TLocData object pointer to call

Return Value:

    None

Notes:

--*/

VOID
TLocData::
FindLocationsThread (
    IN TLocData *pData
    )
{
    //
    // Explore the locations (this is a
    // slow resource access operation)
    //
    pData->vDoTheWork();

    //
    // Data is consistent to be used here
    //
    pData->_bIsDataReady = TRUE;

    //
    // Notify UI we are ready
    //
    pData->vNotifyUIDataIsReady();

    //
    // Unhook from data
    //
    pData->cDecRef();
}

/*++

Name:

    TLocData::vRefZeroed

Description:

    Called when ref count reaches zero. Deletes the object

Arguments:

    None

Return Value:

    None

Notes:

--*/

VOID
TLocData::
vRefZeroed(
    VOID
    )
{
    //
    // No more clients - just kill myself, game over
    //
    delete this;
}

/*++

Name:

    TLocData::bSearchLocations

Description:

    Opens the Active Directory and searches the configuration
    container to find the location property of each Subnet.

Arguments:

    ds    - The active directory object

Return Value:

    TRUE  - on success
    FALSE - on failure

Notes:

--*/
BOOL
TLocData::
bSearchLocations(
    IN  TDirectoryService &ds
    )
{
    static const DWORD kMaxPageSize = 10000;
    static ADS_SEARCHPREF_INFO prefInfo[3];
    static LPWSTR ppszPropertyName[] = {
        const_cast<LPWSTR>(gszLocation)
    };

    TString           strConfig;
    TString           strSubnet;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCH_COLUMN column;
    IDirectorySearch* pDsSearch = NULL;
    TStatusB          bStatus;
    TStatusH          hResult;
    DWORD             cItems;

    //
    // Set search preferences
    //

    //
    // one level search
    //
    prefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

    //
    // async search
    //
    prefInfo[1].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
    prefInfo[1].vValue.dwType = ADSTYPE_BOOLEAN;
    prefInfo[1].vValue.Boolean = TRUE;

    //
    // paged results
    //
    prefInfo[2].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    prefInfo[2].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[2].vValue.Integer = kMaxPageSize;

    //
    // Get the configuration path
    //
    bStatus DBGCHK = ds.GetConfigurationContainer (strConfig);

    if (bStatus)
    {
        TString strLDAPPrefix;

        //
        // Append config path to the subnet string
        //
        bStatus DBGCHK = strSubnet.bUpdate( gszLdapPrefix )        &&
                         strSubnet.bCat( gszSubnetContainter )     &&
                         strSubnet.bCat( gszComma )                &&
                         strSubnet.bCat( strConfig );

        if(bStatus)
        {
            //
            // Get container interface for the subnets object
            //
            hResult DBGCHK = ds.ADsGetObject ( const_cast<LPTSTR>(static_cast<LPCTSTR>(strSubnet)),
                                               IID_IDirectorySearch,
                                               reinterpret_cast<LPVOID*>(&pDsSearch));
            if (SUCCEEDED(hResult))
            {
                //
                // Search for the subnet objects
                //

                hResult DBGCHK = pDsSearch->SetSearchPreference(prefInfo, ARRAYSIZE(prefInfo));
            }

            if (SUCCEEDED (hResult))
            {
                hResult DBGCHK = pDsSearch->ExecuteSearch(L"(Objectclass=*)",
                                                          ppszPropertyName,
                                                          ARRAYSIZE (ppszPropertyName),
                                                          &hSearch);
            }

            for (cItems = 0 ; cItems < kMaxPageSize && SUCCEEDED (hResult); cItems++)
            {
                hResult DBGCHK = pDsSearch->GetNextRow(hSearch);

                if (hResult == S_ADS_NOMORE_ROWS)
                {
                    //
                    // we have more data so lets continue
                    //
                    hResult DBGCHK = S_OK;
                    break;
                }

                //
                // Get the Name and display it in the list.
                //
                hResult DBGCHK = pDsSearch->GetColumn( hSearch, ppszPropertyName[0], &column );

                if (SUCCEEDED(hResult))
                {
                    switch (column.dwADsType)
                    {
                    case ADSTYPE_CASE_IGNORE_STRING:

                        if (column.pADsValues->CaseIgnoreString && column.pADsValues->CaseIgnoreString[0])
                        {
                            //
                            // This subnet has a location property
                            //
                            TLoc *pLoc = new TLoc();

                            if( VALID_PTR(pLoc) )
                            {
                                pLoc->strLocation.bUpdate( column.pADsValues->CaseIgnoreString );
                                _LocationList_vAppend(pLoc);
                            }
                            else
                            {
                                hResult DBGCHK = E_OUTOFMEMORY;
                                break;
                            }
                        }
                        break;

                    default:
                        hResult DBGCHK = E_INVALIDARG;
                        break;
                    }

                    pDsSearch->FreeColumn(&column);
                }
                else if (hResult == E_ADS_COLUMN_NOT_SET)
                {
                    //
                    // The location data is not available for this subnet, ignore
                    //
                    hResult DBGCHK = S_OK;
                }
            }

            if (hSearch)
            {
                pDsSearch->CloseSearchHandle (hSearch);
            }

            if (pDsSearch)
            {
                pDsSearch->Release();
            }
        }
    }

    //
    // Make this final check
    //
    if(bStatus)
    {
        bStatus DBGCHK = SUCCEEDED(hResult);
    }

    return bStatus;
}

/*++

Name:

    TLocData::vDoTheWork

Description:

    Opens the Active Directory and searches the configuration
    container to find the location property of each Subnet.

Arguments:

    None

Return Value:

    None

Notes:

--*/

VOID
TLocData::
vDoTheWork(
    VOID
    )
{
    TStatusB bStatus;

    TDirectoryService ds;
    bStatus DBGCHK = ds.bValid();

    //
    // Lookup for the DS name first
    //
    if( bStatus )
    {
        bStatus DBGCHK = ds.bGetDirectoryName( _strDSName );
    }

    //
    // Enumerate the subnet objects
    //
    if( bStatus )
    {
        bStatus DBGCHK = bSearchLocations (ds);
    }

    //
    // Find out the exact location of the current machine
    //
    if( bStatus )
    {
        TPhysicalLocation physLoc;

        if (_bFindPhysicalLocation && physLoc.Discover())
        {
            physLoc.GetExact (_strDefault);
        }
    }
}

/******************************************************************************
TLocData::TLoc
******************************************************************************/

TLocData::
TLoc::
TLoc(
    VOID
    )
{
}

TLocData::
TLoc::
~TLoc(
    VOID
    )
{
}

/******************************************************************************

TLocTree methods

******************************************************************************/

/*++

Name:

    TLocTree constructor

Description:

    Creates the imagelist for the tree control and inserts the
    root string that describes the choices.

Arguments:

    None

Return Value:

    None

Notes:

--*/

TLocTree::
TLocTree(
   IN HWND hwnd
   )
{
    HICON                 hIcon;
    TCHAR                 szIconLocation[MAX_PATH];
    INT                   iIconIndex;
    TStatusB              bStatus;

    _hwndTree = hwnd;
    _iGlobe = 0;
    _iSite = 0;

    _bWaitData = TRUE;
    _hCursorWait = LoadCursor(NULL, IDC_WAIT);
    _DefProc = NULL;

    //
    // Create the simple imagelist
    // If this fails, the tree items just won't have icons
    //
    bStatus DBGCHK = Shell_GetImageLists( NULL, &_hIml );

    if (_hIml)
    {
        IDsDisplaySpecifier  *pDisplay = NULL;

        //
        // Use IDsDisplaySpecifier::GetIcon to find path to the icons
        // for sites and subnets.
        //
        if (SUCCEEDED(CoCreateInstance(CLSID_DsDisplaySpecifier,
                                       NULL,
                                       CLSCTX_INPROC_SERVER,
                                       IID_IDsDisplaySpecifier,
                                       reinterpret_cast<LPVOID *>(&pDisplay))))
        {
            _iGlobe = Shell_GetCachedImageIndex (gszDSIconFile,
                                                 kDSIconIndex,
                                                 0);

            pDisplay->GetIconLocation (gszSiteIconClass,
                                       DSGIF_GETDEFAULTICON,
                                       szIconLocation,
                                       MAX_PATH,
                                       &iIconIndex);

            _iSite = Shell_GetCachedImageIndex (szIconLocation,
                                                 iIconIndex,
                                                 0);
            pDisplay->Release();

            TreeView_SetImageList (_hwndTree, _hIml, TVSIL_NORMAL);
        }
    }

    //
    // Subclass tree control to handle WM_SETCURSOR message
    //
    _DefProc = reinterpret_cast<WNDPROC>( GetWindowLongPtr( _hwndTree, GWLP_WNDPROC ) );
    SetWindowLongPtr( _hwndTree, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this) );
    SetWindowLongPtr( _hwndTree, GWLP_WNDPROC,  reinterpret_cast<LONG_PTR>(&TLocTree::ThunkProc) );
}

/*++

Name:

    TLocTree destructor

Description:

    Destroys the image list

Arguments:

    None

Return Value:

    None

Notes:

--*/

TLocTree::
~TLocTree(
    VOID
    )
{
    //
    // Unsubclass here
    //
    SetWindowLongPtr( _hwndTree, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(_DefProc) );
    SetWindowLongPtr( _hwndTree, GWLP_USERDATA, 0 );

    //
    // No longer need the shared image list
    //
    if (_hIml)
    {
        TreeView_SetImageList (_hwndTree, NULL, TVSIL_NORMAL);
    }
}

/*++

Name:

    TLocTree::vResetTree

Description:

    Resets the tree content

Arguments:

    None

Return Value:

    None

Notes:

--*/

VOID
TLocTree::
vResetTree(
   VOID
   )
{
    //
    // Delete all items and start waiting
    // new data
    //
    TreeView_DeleteAllItems( _hwndTree );
    _bWaitData = TRUE;
}

/*++

Name:

    TLocTree::vBuildTree

Description:

    Build the tree control from a ready data

Arguments:

    pLocData - Where to get data from

Return Value:

    None

Notes:

--*/

VOID
TLocTree::
vBuildTree(
    IN const TLocData *pLocData
    )
{
    //
    // Check to reset the data
    //
    if( !_bWaitData )
    {
        vResetTree( );
    }

    if( !pLocData->_LocationList_bEmpty() )
    {
        //
        // Build the tree and Fill the tree with the data.
        //
        vInsertRootString( pLocData );
        vFillTree( pLocData );
    }

    //
    // Stop waiting data
    //
    _bWaitData = FALSE;
}

/*++

Name:

    TLocTree::vInsertRootString

Description:

    Inserts the root string in the tree control


Arguments:

    None

Return Value:

    None

Notes:

--*/

VOID
TLocTree::
vInsertRootString(
   IN const TLocData *pLocData
   )
{
    TVINSERTSTRUCT        tviStruct;
    TString               strRoot;
    TStatusB              bStatus;
    TDirectoryService     ds;
    TString               strDSName;

    //
    // Insert the Root-level string that describes the control
    // This will be a combination of "Entire " + <directory name>
    //
    tviStruct.hParent               = NULL;
    tviStruct.hInsertAfter          = TVI_ROOT;
    tviStruct.item.mask             = TVIF_TEXT|TVIF_IMAGE|TVIF_SELECTEDIMAGE;
    tviStruct.item.iImage           = _iGlobe;
    tviStruct.item.iSelectedImage   = _iGlobe;

    bStatus DBGCHK = strRoot.bLoadString( ghInst, IDS_LOCTREEROOT ) &&
                     strRoot.bCat( pLocData->_strDSName );

    tviStruct.item.pszText      = const_cast<LPTSTR>(static_cast<LPCTSTR>(strRoot));
    tviStruct.item.cchTextMax   = strRoot.uLen();

    _hRoot = TreeView_InsertItem (_hwndTree, &tviStruct);
}

/*++

Name:

    TLocTree::bInsertLocString

Description:

    Add the given location string to the tree control.
    Each level of the hierarchy is indicated by the '/'
    delimiter. Prevents duplicate entries at each level of
    the tree.

Arguments:

    strLoc - location string to insert, Must be '/' delimited

Return Value:

    TRUE  - on success
    FALSE - on failure

Notes:

--*/

BOOL
TLocTree::
bInsertLocString(
   IN const TString &strLoc
   ) const
{
    // Start at the root.
    // For each '/' delimited string in szLoc,
    // add a level to the tree and insert the
    // string as a child node of the current node.
    // At each level don't insert duplicates.
    //
    HTREEITEM       hCurrent, hChild;
    TVINSERTSTRUCT  tviItem;
    TVITEM*         pItem = &tviItem.item;
    DWORD           dwErr;
    TCHAR           szBuffer[512];
    LPTSTR          psz, pszMax;

    if (!_hwndTree)
    {
        return FALSE;
    }

    // tokenize the input string
    Tokenize(szBuffer, ARRAYSIZE(szBuffer), strLoc, &psz, &pszMax);

    // initialize the item to insert
    memset(pItem, 0, sizeof(TVITEM));
    pItem->mask = TVIF_TEXT|TVIF_IMAGE|TVIF_SELECTEDIMAGE;
    pItem->iImage = _iSite;
    pItem->iSelectedImage = _iSite;
    tviItem.hInsertAfter = TVI_SORT;

    hCurrent = _hRoot;
    while( hCurrent )
    {
        // find a valid token
        while( 0 == *psz && psz < pszMax )
        {
            psz++;
        }

        // if we've gone past the buffer break the loop
        if( psz >= pszMax )
        {
            break;
        }

        pItem->pszText  = psz;
        tviItem.hParent = hCurrent;

        // if the current name already exists at this level don't insert
        if( hChild = IsAChild(psz, hCurrent) )
        {
            hCurrent = hChild;
        }
        else
        {
            hCurrent = TreeView_InsertItem (_hwndTree, &tviItem);
        }

        // advance the token pointer
        psz += lstrlen(psz);
    }

    return hCurrent ? TRUE : FALSE;
}

/*++

Name:

    TLocTree::IsAChild

Description:

    Determines if szLoc exists at the level of the
    tree whose parent is hParent. If so, return
    the handle of the node containing szLoc

Arguments:

    szLoc   - string to search for
    hParent - parent node

Return Value:

    Handle to treeview item matching szLoc, or NULL if not found

Notes:

--*/

HTREEITEM
TLocTree::
IsAChild(
   IN LPCTSTR   szLoc,
   IN HTREEITEM hParent
   ) const
{
    TVITEM tvItem;
    HTREEITEM hItem;
    TCHAR szItemText[TPhysicalLocation::kMaxPhysicalLocation];
    BOOL bMatch = FALSE;

    tvItem.mask = TVIF_TEXT | TVIF_HANDLE;
    tvItem.pszText = szItemText;
    tvItem.cchTextMax = TPhysicalLocation::kMaxPhysicalLocation;

    hItem = TreeView_GetChild (_hwndTree, hParent);
    while (hItem && !bMatch)
    {
        tvItem.hItem = hItem;
        TreeView_GetItem (_hwndTree, &tvItem);
        bMatch = !_tcsicmp (szLoc, szItemText);

        if (bMatch)
        {
            break;
        }

        hItem = TreeView_GetNextSibling (_hwndTree, hItem);
    }

    if (!bMatch)
    {
        hItem = NULL;
    }

    return hItem;
}

/*++

Name:

    TLocTree::uGetSelectedLocation

Description:

    Walks the tree control from the selected item to
    the root, building the slash-delimited location
    string name.

Arguments:

    strLoc - string to update

Return Value:

    TRUE  - on success
    FALSE - otherwise

Notes:

--*/

BOOL
TLocTree::
bGetSelectedLocation(
    OUT TString &strLoc
    ) const
{
    TVITEM    tvItem;
    TStatusB  status;
    TCHAR     szTemp[TPhysicalLocation::kMaxPhysicalLocation];

    tvItem.mask       = TVIF_TEXT|TVIF_HANDLE;
    tvItem.cchTextMax = TPhysicalLocation::kMaxPhysicalLocation;
    tvItem.pszText    = szTemp;

    //
    // Get the selected item
    //
    tvItem.hItem = TreeView_GetSelection (_hwndTree);

    if (tvItem.hItem == _hRoot)
    {
        status DBGCHK = strLoc.bUpdate(_T("\0"));
        return status;
    }

    status DBGCHK = TreeView_GetItem (_hwndTree, &tvItem);

    if (status)
    {
        vRecursiveGetSel (_hwndTree, &tvItem, strLoc, _hRoot);
    }

    return  status;
}

/*++

Name:

    TLocTree::vExpandTree

Description:

    Expands the tree view control to make visible the node
    corresponding to the given location string

Arguments:

    strExpand - slash-delimited location string to expand tree by

Return Value:

    None

Notes:

--*/

VOID
TLocTree::
vExpandTree(
    IN const TString &strExpand
    ) const
{
    if( strExpand.uLen() )
    {
        HTREEITEM   hParent, hItem;
        TCHAR       szBuffer[512];
        LPTSTR      psz, pszMax;

        // tokenize the input string
        Tokenize(szBuffer, ARRAYSIZE(szBuffer), strExpand, &psz, &pszMax);

        hParent = _hRoot;
        for( ;; )
        {
            // find a valid token
            while( 0 == *psz && psz < pszMax )
            {
                psz++;
            }

            // if we've gone past the buffer break the loop
            if( psz >= pszMax )
            {
                break;
            }

            if( hItem = IsAChild(psz, hParent) )
            {
                // a valid child - remember
                hParent = hItem;

                // advance to the next token
                psz += lstrlen(psz);
            }
            else
            {
                // not a child, bail out
                break;
            }
        }

        if (hParent)
        {
            TreeView_EnsureVisible(_hwndTree, hParent);
            TreeView_SelectItem(_hwndTree, hParent);
        }
    }
}

/*++

Name:

    vFillTree

Description:

    Walks through the linked list and adds strings to the TLocTree object

Arguments:

    pLocData - Where to get data from

Return Value:

    None

Notes:

--*/

VOID
TLocTree::
vFillTree(
    IN const TLocData *pLocData
    ) const
{
    TIter Iter;
    TLocData::TLoc *pLoc;

    TStatusB status = TRUE;
    for( pLocData->_LocationList_vIterInit(Iter), Iter.vNext(); Iter.bValid(); Iter.vNext() )
    {
        pLoc = pLocData->_LocationList_pConvert( Iter );
        status DBGCHK = bInsertLocString( pLoc->strLocation );
    }
}

/*++

Name:

    TLocTree::ThunkProc

Description:

    Thunk control proc (for subclassing)

Arguments:

    Standard window proc parameters

Return Value:

    None

Notes:

--*/

LRESULT CALLBACK
TLocTree::
ThunkProc(
    IN HWND hwnd,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    LRESULT lResult = 0;
    TLocTree *This = reinterpret_cast<TLocTree*>( GetWindowLongPtr( hwnd, GWLP_USERDATA ) );

    if( This )
    {
        if( WM_DESTROY == uMsg || WM_NCDESTROY == uMsg )
        {
            lResult = This->nHandleMessage( uMsg, wParam, lParam );

            SetWindowLongPtr( hwnd, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(This->_DefProc) );
            SetWindowLongPtr( hwnd, GWLP_USERDATA, 0 );
        }
        else
        {
            SPLASSERT( hwnd == This->_hwndTree );
            lResult = This->nHandleMessage( uMsg, wParam, lParam );

            if( !lResult )
            {
                //
                // Message is not handled go to
                // default processing
                //
                lResult = This->_DefProc( hwnd, uMsg, wParam, lParam );
            }
        }
    }

    return lResult;
}

/*++

Name:

    TLocTree::nHandleMessage

Description:

    Message handler function

Arguments:

    Standard window proc parameters

Return Value:

    None

Notes:

--*/

LRESULT
TLocTree::
nHandleMessage(
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    //
    // assume message is processed
    //
    LRESULT lResult = 1;

    switch( uMsg )
    {
        case WM_SETCURSOR:
            {
                if( _bWaitData )
                {
                    //
                    // Set hourglass cursor
                    //
                    SetCursor( _hCursorWait );
                }
                else
                {
                    //
                    // Message is not processed - go default processing
                    //
                    lResult = 0;
                }
            }
            break;

        default:
            {
                //
                // Message is not processed - go default processing
                //
                lResult = 0;
            }
            break;
    }

    return lResult;
}

/******************************************************************************

    TFindLocDlg functions

******************************************************************************/



/*++

Name:

    TFindLocDlg::bGenerateGUIDAsString

Description:

    This function will generate a GUID,
    convert it to string and return it

Arguments:

    pstrGUID - where to place the genearted GUID

Return Value:

    TRUE  on success
    FALSE on failure

Notes:

--*/

BOOL
TFindLocDlg::
bGenerateGUIDAsString(
    OUT TString *pstrGUID
    )
{
    static const TCHAR szRegFormat[] = _T("{%08lX-%04X-%04x-%02X%02X-%02X%02X%02X%02X%02X%02X}");

    //
    // Assume failue
    //
    TStatusB bStatus = FALSE;

    HRESULT hResult = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if( SUCCEEDED(hResult) )
    {
        GUID guid;
        bStatus DBGCHK = SUCCEEDED(CoCreateGuid(&guid));

        if( bStatus )
        {
            //
            // Generate a registry format GUID string
            //
                bStatus DBGCHK = pstrGUID->bFormat( szRegFormat,
                        // first copy...
                        guid.Data1, guid.Data2, guid.Data3,
                        guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
                        guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7],
                        // second copy...
                        guid.Data1, guid.Data2, guid.Data3,
                        guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
                        guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);
        }

        //
        // Uninitialize COM after we finish
        //
        CoUninitialize( );
    }

    return bStatus;
}

/*++

Name:

    TFindLocDlg constructor

Description:

    Constructs TFindLocDlg object

Arguments:

    flags - UI controlling flags (show/hide help button)

Return Value:

    None

Notes:

--*/

TFindLocDlg::
TFindLocDlg(
    IN ELocationUI flags
    ) :
        _pLocData(NULL),
        _pTree(NULL),
        _UIFlags(flags),
        _bValid(TRUE),
        _uMsgDataReady(0)
{
}

/*++

Name:

    TFindLocDlg destructor

Description:

    Releases refcount on the location object

Arguments:

    None

Return Value:

    None

Notes:

--*/

TFindLocDlg::
~TFindLocDlg(
    VOID
    )
{
    if (VALID_PTR(_pLocData))
    {
        _pLocData->cDecRef();
    }
}

/*++

Name:

    TFindLocDlg::bDoModal

Description:

    Invokes the browse location dialog

Arguments:

    hParent     - hwnd of parent window
    pstrDefault - default selection string, this is optional

Return Value:

    TRUE  - if dialog creation succeeds
    FALSE - otherwise

Notes:

    pstrDefault has NULL default value

--*/

BOOL
TFindLocDlg::
bDoModal(
   IN  HWND     hParent,
   OUT TString *pstrDefault OPTIONAL
   )
{
    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;

    if (pstrDefault)
    {
        bStatus DBGCHK = _strDefault.bUpdate( *pstrDefault );
    }

    //
    // Register the window message, this message is used to inform the
    // UI thread that the data fetched by the background thread is ready.
    //
    _uMsgDataReady = RegisterWindowMessage( _T("WM_BACKGROUNDTASKISREADY") );

    //
    // Check if we succeeded to register the message
    // and update the default location
    //
    if( _bValid && _uMsgDataReady && bStatus )
    {
        //
        // Check if data is not obtained from a previous call
        // of bDoModal() function - if not then start background
        // thread to explore locations from the directory
        // service
        //
        if( !_pLocData )
        {
            //
            // Generate the special property name
            //
            bStatus DBGCHK = bGenerateGUIDAsString( &_strPropertyName );

            if( bStatus )
            {
                _pLocData = new TLocData( _T("#32770"), _strPropertyName, _uMsgDataReady, _strDefault.bEmpty() );
                bStatus DBGCHK = VALID_PTR( _pLocData );

                if( bStatus )
                {
                    _pLocData->vIncRef( );

                    //
                    // Spin the background explorer thread here
                    //
                    bStatus DBGCHK = bStartTheBackgroundThread();
                }
                else
                {
                    delete _pLocData;
                    _pLocData = NULL;
                }
            }
        }

        //
        // Data is expected to be ready here or to be in
        // process of exploration in background
        //
        if( bStatus )
        {
            //
            // Everything looks fine - just show the UI
            //
            bStatus DBGCHK= (BOOL)DialogBoxParam( ghInst,
                                                  MAKEINTRESOURCE(DLG_BROWSE_LOC),
                                                  hParent,
                                                  MGenericDialog::SetupDlgProc,
                                                  reinterpret_cast<LPARAM>(this) );
        }
    }

    return bStatus;
}

/*++

Name:

    TFindLocDlg::uGetLocation

Description:

    Fills in the location string selected when the dialog was open.

Arguments:

    strLocation - TString to update

Return Value:

    TRUE  - on success,
    FALSE - otherwise

Notes:

--*/

BOOL
TFindLocDlg::
bGetLocation(
    OUT TString &strLocation
    )
{
    TStatusB bStatus;
    bStatus DBGCHK = strLocation.bUpdate ((LPCTSTR)_strSelLocation);
    return bStatus;
}

/*++

Name:

    TFindLocDlg::vDataIsReady

Description:

    Called when the background thread completes its work.
    Always stops the wait cursor.

Arguments:

    None

Return Value:

    None

Notes:


--*/

VOID
TFindLocDlg::
vDataIsReady(
    VOID
    )
{
    //
    // Make sure the animation stops
    //
    vStopAnim();

    //
    // Fill in the tree control, and select the default string
    //
    _pTree->vBuildTree( _pLocData );

    if( !_pLocData->_LocationList_bEmpty() )
    {
        //
        // Expand the default location here
        //
        if (!_strDefault.bEmpty())
        {
            _pTree->vExpandTree(_strDefault);
        }
        else
        {
            _pTree->vExpandTree(_pLocData->_strDefault);
        }

        //
        // Enable the OK button
        //
        EnableWindow (GetDlgItem (_hDlg, IDOK), TRUE);
    }

    //
    // Place the focus in the tree control
    //
    PostMessage( _hDlg, WM_NEXTDLGCTL, reinterpret_cast<WPARAM>( GetDlgItem(_hDlg, IDC_LOCTREE) ), 1L );
}

/*++

Name:

    TFindLocDlg::vOnOK

Description:

    Called when the OK button is pressed.
    Updates current selection string

Arguments:

    None

Return Value:

    None

Notes:


--*/

VOID
TFindLocDlg::
vOnOK(
   VOID
   )
{
    //
    // Get the selected location and close the dialog
    //
    _pTree->bGetSelectedLocation (_strSelLocation);
    EndDialog (_hDlg, IDOK);
}

/*++

Name:

    TFindLocDlg::vOnDestroy

Description:

    Cleans up data allocated for current
    dialog window instance


Arguments:

    None

Return Value:

    None

Notes:


--*/

VOID
TFindLocDlg::
vOnDestroy(
    VOID
    )
{
    if (VALID_PTR(_pTree))
    {
        delete _pTree;
        _pTree = NULL;
    }
}

/*++

Name:

    TFindLocDlg::bHandleMessage


Description:

    Dispatches messages to appropriate handlers.


Arguments:

    uMsg - message value
    wParam, lParam - message params

Return Value:

    TRUE  - if message is handled,
    FALSE - otherwise

Notes:


--*/

BOOL
TFindLocDlg::
bHandleMessage(
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    BOOL bHandled = TRUE;

    //
    // Check our registered message first
    //
    if( _uMsgDataReady == uMsg && reinterpret_cast<LPARAM>(_pLocData) == lParam )
    {
        vDataIsReady( );
        bHandled = TRUE;
    }
    else
    {
        //
        // Standard message processing
        //
        switch (uMsg)
        {
            case WM_INITDIALOG:
                {
                    bHandled = bOnInitDialog();
                }
                break;

            case WM_COMMAND:
                {
                    //
                    // Handle WM_COMMAND messages
                    //
                    bHandled = bOnCommand( LOWORD(wParam) );
                }
                break;

            case WM_NOTIFY:
                {
                    //
                    // The only WM_NOTIFY source on the dialog is the TreeView
                    //
                    bHandled = bOnTreeNotify (reinterpret_cast<LPNMTREEVIEW>(lParam));
                }
                break;


            case WM_HELP:
            case WM_CONTEXTMENU:
                {
                    //
                    // Help messages
                    //
                    PrintUIHelp( uMsg, _hDlg, wParam, lParam );
                }
                break;

            case WM_DESTROY:
                {
                    vOnDestroy ();
                }
                break;

            case WM_CTLCOLORSTATIC:
                {
                    bHandled = bOnCtlColorStatic( reinterpret_cast<HDC>(wParam),
                                                  reinterpret_cast<HWND>(lParam) );
                }
                break;

            default:
                {
                    bHandled = FALSE;
                }
                break;

        }
    }

    return bHandled;
}

/*++

Name:

    TFindLocDlg::bOnInitDialog

Description:

    Instantiates the TLocTree object and attempts to
    initialize it if needed. Disable the OK button until
    the worker thread completes.

Arguments:

    None

Return Value:

    TRUE  - on success
    FALSE - on failure

Notes:

--*/

BOOL
TFindLocDlg::
bOnInitDialog(
   VOID
   )
{
    DWORD dwResult;
    TStatusB bStatus;

    _pTree = new TLocTree (GetDlgItem(_hDlg, IDC_LOCTREE));
    bStatus DBGCHK = VALID_PTR(_pTree);

    if( !bStatus )
    {
        delete _pTree;
        _pTree = NULL;
    }
    else
    {
        //
        // Set some special property value to us, so the
        // worker thread could recognize us
        //
        bStatus DBGCHK = SetProp( _hDlg, _strPropertyName, static_cast<HANDLE>(_pLocData) );

        if( bStatus )
        {
            //
            // Hide the help button as requested
            //
            if (!(_UIFlags & kLocationShowHelp))
            {
                ShowWindow (GetDlgItem(_hDlg, IDC_LOCATION_HELP), SW_HIDE);
            }

            //
            // Let the user know we're busy
            //
            EnableWindow (GetDlgItem (_hDlg, IDOK), FALSE);

            vStartAnim();

            //
            // Just verify if the data is ready
            //
            _pLocData->vNotifyUIDataIsReady();
        }
    }

    return bStatus;
}

/*++

Name:

    TFindLocDlg::bOnTreeNotify

Description:

    When the selection is changed on the tree control, update
    the static control that displays the currently selected location


Arguments:

    pTreeNotify - pointer to NMTREEVIEW struct

Return Value:

    TRUE  - if message is handled
    FALSE - otherwise

Notes:

--*/

BOOL
TFindLocDlg::
bOnTreeNotify(
   IN LPNMTREEVIEW pTreeNotify
   )
{
    TStatusB bStatus = TRUE;
    TString  strSel;

    switch (pTreeNotify->hdr.code)
    {
        case TVN_SELCHANGED:
            {
                bStatus DBGCHK = _pTree->bGetSelectedLocation (strSel);

                if (strSel.bEmpty())
                {
                    strSel.bLoadString (ghInst,IDS_NO_LOCATION);
                }

                bStatus DBGCHK = bSetEditText (_hDlg, IDC_CHOSEN_LOCATION, strSel);
            }
            break;

        default:
            {
                bStatus DBGNOCHK = FALSE;
            }
            break;
    }

    return bStatus;
}

/*++

Name:

    TFindLocDlg::vStartAnim

Description:

    Show the animation window


Arguments:

    None

Return Value:

    None

Notes:

--*/

VOID
TFindLocDlg::
vStartAnim(
    VOID
    )
{
    HWND hwndAni = GetDlgItem (_hDlg, IDC_BROWSELOC_ANIM);

    SetWindowPos (hwndAni,
                  HWND_TOP,
                  0,0,0,0,
                  SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW);

    Animate_Open(hwndAni, MAKEINTRESOURCE (IDA_SEARCH));
    Animate_Play(hwndAni, 0, -1, -1);
}

/*++

Name:

    TFindLocDlg::vStopAnim

Description:

    Hide the animation window


Arguments:

    None

Return Value:

    None

Notes:

--*/

VOID
TFindLocDlg::
vStopAnim(
    VOID
    )
{
    //
    // Call LockWindowUpdate() to prevent default drawing of the
    // animation control after stop playing - which is gray rect
    //
    LockWindowUpdate( _hDlg );

    HWND hwndAni = GetDlgItem (_hDlg, IDC_BROWSELOC_ANIM);

    SetWindowPos (hwndAni,
                  HWND_BOTTOM,
                  0,0,0,0,
                  SWP_NOMOVE|SWP_NOSIZE|SWP_HIDEWINDOW);


    Animate_Stop(hwndAni);

    //
    // Unlock window update - tree control will
    // repaint its content
    //
    LockWindowUpdate( NULL );
}

/*++

Name:
    TFindLocDlg::bOnCtlColorStatic

Description:
    Used to set background color of the animation window
    to the same color as the treeview window


Arguments:
    hdc - DC to set background color

Return Value:
    color value used to draw background

Notes:

--*/

BOOL
TFindLocDlg::
bOnCtlColorStatic(
    IN HDC hdc,
    IN HWND hStatic
    )
{
    //
    // Assume default processing of this message
    //
    BOOL bResult = FALSE;

    if (hStatic == GetDlgItem (_hDlg, IDC_BROWSELOC_ANIM))
    {
        //
        // We process this message only to have
        // opportunity to patch the animation control
        // dc just before paint.
        //
        // We do not return a brush here!
        // (which means that we return a NULL brush)
        //
        // We should just return TRUE here to prevent the
        // default message processing of this msg, which will
        // revert the backgound color to gray.
        //
        SetBkColor(hdc, GetSysColor(COLOR_WINDOW));

        //
        // Message is processed. Do not perform default
        // processing!
        //
        bResult = TRUE;
    }

    return bResult;
}

/*++

Name:

    TFindLocDlg::bStartTheBackgroundThread

Description:

    Starts the background thread for reading the subnet locations


Arguments:

    None

Return Value:

    TRUE  - on success
    FALSE - on failure

Notes:


--*/

BOOL
TFindLocDlg::
bStartTheBackgroundThread(
    VOID
    )
{
    TStatusB bStatus;

    DWORD dwThreadID;
    HANDLE hThread;

    //
    // You want to make sure the data is protected for the worker thread.
    //
    _pLocData->vIncRef();

    //
    // Spin the background thread here
    //
    hThread = TSafeThread::Create ( NULL,
                                    0,
                                    (LPTHREAD_START_ROUTINE)TLocData::FindLocationsThread,
                                    _pLocData,
                                    0,
                                    &dwThreadID );
    if( hThread )
    {
        //
        // We don't need this handle any more.
        // Just leave the thread running untill
        // it stops
        //
        CloseHandle( hThread );
    }
    else
    {
        //
        // Ensure the data is release if the thread creation fails.
        //
        _pLocData->cDecRef();
    }

    bStatus DBGCHK = !!hThread;

    return bStatus;
}

/*++

Name:

    TFindLocDlg::bOnCommand

Description:

    Handles WM_COMMAND messages

Arguments:

    None

Return Value:

    TRUE  - on success
    FALSE - on failure

Notes:

--*/

BOOL
TFindLocDlg::
bOnCommand(
    IN UINT uCmdID
    )
{
    //
    // Assume message is handled
    //
    BOOL bHandled = TRUE;

    switch (uCmdID)
    {
        case IDOK:
            vOnOK ();
            break;

        case IDCANCEL:
            EndDialog (_hDlg, 0);
            break;

        case IDC_LOCATION_HELP:
            PrintUIHtmlHelp (_hDlg,
                             gszHtmlPrintingHlp,
                             HH_DISPLAY_TOPIC,
                             reinterpret_cast<ULONG_PTR>(gszLocationHtmFile));
            break;

        default:
            {
                bHandled = FALSE;
            }
            break;
    }

    return bHandled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\drvver.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997
All rights reserved.

Module Name:

    drvrver.hxx

Abstract:

    Driver version detection header.

Author:

    Steve Kiraly (SteveKi)  21-Jan-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "psetup.hxx"
#include "drvver.hxx"
#include "splapip.h"
#include "compinfo.hxx"

BOOL
bGetCurrentDriver(
    IN      LPCTSTR pszServerName,
        OUT LPDWORD pdwCurrentDriver
    )
{
    TCHAR   szArch[kStrMax];
    BOOL    bRetval = FALSE;
    DWORD   dwVer   = 0;

    //
    // Attempt to get the architecture / version from the machine.
    // First attempt to get the information from the spooler.
    //
    bRetval = bGetArchUseSpooler( pszServerName, szArch, COUNTOF( szArch ), &dwVer );

    //
    // If spooler did not respond, this may be a downlevel
    // print spooler.  "Downlevel" meaning older version.
    //
    if( !bRetval )
    {
        //
        // Attempt to get the information using the remote registry calls
        // We only connect to the remote registry if a server name was passed.
        //
        if( pszServerName )
        {
            bRetval = bGetArchUseReg( pszServerName, szArch, COUNTOF( szArch ), &dwVer );
        }
    }

    //
    // Check for any retuned information.
    //
    if( bRetval )
    {
        DBGMSG( DBG_TRACE, ( "Server " TSTR " Arch " TSTR " Ver %d\n", DBGSTR(pszServerName), szArch, dwVer ) );

        //
        // Encode the architecture / version  into a dword.
        //
        if( bEncodeArchVersion( szArch, dwVer, pdwCurrentDriver ) )
        {
            DBGMSG( DBG_TRACE, ( "Encoded Arch / Version %d\n", *pdwCurrentDriver ) );
            bRetval = TRUE;
        }
        else
        {
            DBGMSG( DBG_WARN, ( "Encode architecture and version failed.\n" ) );
            bRetval = FALSE;
        }
    }
    else
    {
        DBGMSG( DBG_WARN, ( "Fetching architecture and version failed.\n" ) );
        bRetval = FALSE;
    }
    return bRetval;
}

BOOL
bGetArchUseSpooler(
    IN      LPCTSTR  pName,
        OUT LPTSTR   pszArch,
    IN      DWORD    dwSize,
    IN  OUT LPDWORD  pdwVer
    )
/*++

Routine Description:

    Gets the specified print server the architectue and
    driver version using the spooler.

Arguments:

    pName       - pointer to print server name.
    pszArch     - pointer to a buffer where to return the machine architecture string
    dwSize      - Size in characters of the provided architecture string
    pdwVersion  - pointer where to return the remote machine driver version.

Return Value:

    TRUE - remote information returned, FALSE - remote information not available.

--*/
{
    //
    // Attempt to open print server with full access.
    //
    BOOL bReturn    = FALSE;
    DWORD dwStatus  = ERROR_SUCCESS;
    DWORD dwAccess  = SERVER_READ;
    HANDLE hServer  = NULL;
    TStatus Status;

    //
    // Open the server for read access.
    //
    Status DBGCHK = TPrinter::sOpenPrinter( pName,
                                            &dwAccess,
                                            &hServer );

    //
    // Save administrator capability flag.
    //
    if( Status == ERROR_SUCCESS ){

        //
        // Get the remote spooler's architecture type and version.
        //
        TCHAR szArch[kStrMax];
        memset( szArch, 0, sizeof( szArch ) );

        DWORD dwNeeded      = 0;
        DWORD dwVer         = 0;
        DWORD dwVerType     = REG_DWORD;
        DWORD dwArchType    = REG_SZ;

        if( dwStatus == ERROR_SUCCESS ){

            dwStatus = GetPrinterData( hServer,
                                       SPLREG_ARCHITECTURE,
                                       &dwArchType,
                                       (PBYTE)szArch,
                                       sizeof( szArch ),
                                       &dwNeeded );
        }

        if( dwStatus == ERROR_SUCCESS ){

            dwStatus = GetPrinterData( hServer,
                                       SPLREG_MAJOR_VERSION,
                                       &dwVerType,
                                       (PBYTE)&dwVer,
                                       sizeof( dwVer ),
                                       &dwNeeded );
        }

        if( dwStatus == ERROR_SUCCESS ){

            DBGMSG( DBG_TRACE, ( "GetPrinterData: Architecture " TSTR "\n" , szArch ) );
            DBGMSG( DBG_TRACE, ( "GetPrinterData: MajorVersion %d\n" , dwVer ) );

            //
            // Only success if provided buffer is big enough.
            //
            if( (DWORD)lstrlen( szArch ) < dwSize ){

                lstrcpy( pszArch, szArch );
                *pdwVer = dwVer;
                bReturn = TRUE;

            } else {
                dwStatus = ERROR_INSUFFICIENT_BUFFER;
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                bReturn = FALSE;
            }

        } else {

            DBGMSG( DBG_WARN, ( "GetPrinterData failed with %d\n", dwStatus ) );

        }
    }

    if( hServer ){
        ClosePrinter( hServer );
    }

    return bReturn;
}

BOOL
bGetArchUseReg(
    IN      LPCTSTR  pName,
        OUT LPTSTR   pszArch,
    IN      DWORD    dwSize,
        OUT LPDWORD  pdwVer
    )
/*++

Routine Description:

    Gets the specified print server the architectue and
    driver version using the remote registry.

Arguments:

    pName       - pointer to print server name.
    pszArch     - pointer to a buffer where to return the machine architecture string
    dwSize      - Size in characters of the provided architecture string
    pdwVersion  - pointer where to return the remote machine driver version.

Return Value:

    TRUE - remote information returned, FALSE - remote information not available.

--*/
{
    BOOL bStatus        = TRUE;
    DWORD dwDriverEnvId = 0;
    DWORD dwArch        = 0;
    TString strDriverEnv;

    //
    // Create the computer information.
    //
    CComputerInfo CompInfo ( pName );

    //
    // Get the information from the remote machine.
    //
    if( !CompInfo.GetInfo() ){

        DBGMSG( DBG_WARN, ( "CComputerInfo.GetInfo failed with %d\n", GetLastError() ) );

        return FALSE;
    }

    //
    // If this is a windows 95 machine set resource string
    // id and set the version to zero.
    //
    if( CompInfo.IsRunningWindows95() ){

        dwDriverEnvId   = IDS_ENVIRONMENT_WIN95;
        *pdwVer         = 0;

    } else {

        //
        // Convert processor type to spooler defined environment string.
        //
        dwArch      = CompInfo.GetProcessorArchitecture();
        *pdwVer     = CompInfo.GetSpoolerVersion();

        struct ArchMap {
            DWORD dwArch;
            DWORD dwVersion;
            UINT uId;
            };

        //
        // disable MIPS & PPC drivers, since they are not supported from setup
        //
        static ArchMap aArchMap [] = {
            { PROCESSOR_ARCHITECTURE_INTEL,   0, IDS_ENVIRONMENT_WIN95  },
            //{ PROCESSOR_ARCHITECTURE_MIPS,    0, IDS_ENVIRONMENT_MIPS   },
            { PROCESSOR_ARCHITECTURE_ALPHA,   0, IDS_ENVIRONMENT_ALPHA  },
            { PROCESSOR_ARCHITECTURE_INTEL,   0, IDS_ENVIRONMENT_X86    },
            //{ PROCESSOR_ARCHITECTURE_MIPS,    1, IDS_ENVIRONMENT_MIPS   },
            { PROCESSOR_ARCHITECTURE_ALPHA,   1, IDS_ENVIRONMENT_ALPHA  },
            //{ PROCESSOR_ARCHITECTURE_PPC,     1, IDS_ENVIRONMENT_PPC    },
            { PROCESSOR_ARCHITECTURE_INTEL,   1, IDS_ENVIRONMENT_X86    },
            //{ PROCESSOR_ARCHITECTURE_MIPS,    2, IDS_ENVIRONMENT_MIPS   },
            { PROCESSOR_ARCHITECTURE_ALPHA,   2, IDS_ENVIRONMENT_ALPHA  },
            //{ PROCESSOR_ARCHITECTURE_PPC,     2, IDS_ENVIRONMENT_PPC    },
            { PROCESSOR_ARCHITECTURE_INTEL,   2, IDS_ENVIRONMENT_X86    },
            { PROCESSOR_ARCHITECTURE_ALPHA,   3, IDS_ENVIRONMENT_ALPHA  },
            { PROCESSOR_ARCHITECTURE_INTEL,   3, IDS_ENVIRONMENT_X86    }};

        bStatus = FALSE;
        for( UINT i = 0; i < COUNTOF( aArchMap ); i++ ){

            //
            // If a version and architecture match.
            //
            if( aArchMap[i].dwVersion == *pdwVer &&
                aArchMap[i].dwArch == dwArch ){

                dwDriverEnvId = aArchMap[i].uId;
                bStatus = TRUE;
                break;
            }
        }
    }

    //
    // If Environment ID and version found.
    //
    if( !bStatus ){
        DBGMSG( DBG_WARN, ( "Failed to find architecture in map.\n" ) );
        return FALSE;
    }

    //
    // Load the environment string from our resource file.
    //
    if( !strDriverEnv.bLoadString( ghInst, dwDriverEnvId ) ){

        DBGMSG( DBG_WARN, ( "Failed to load driver name string resource with %d\n", GetLastError() ) );
        return FALSE;
    }

    //
    // Check the provided buffer is large enough.
    //
    if( (DWORD)lstrlen( strDriverEnv ) >= ( dwSize - 1 ) ){
        DBGMSG( DBG_WARN, ( "Insuffcient buffer provided to bGetArchUseReg.\n" ) );
        return FALSE;
    }

    //
    // Copy back environment string to provided buffer.
    //
    lstrcpy( pszArch, strDriverEnv );

    DBGMSG( DBG_TRACE, ( "CComputerInfo.GetInfo: Architecture " TSTR "\n" , pszArch ) );
    DBGMSG( DBG_TRACE, ( "CComputerInfo.GetInfo: MajorVersion %d\n" , *pdwVer ) );

    return TRUE;

}

BOOL
bEncodeArchVersion(
    IN      LPCTSTR  pszArch,
    IN      DWORD    dwVer,
        OUT LPDWORD  pdwVal
    )
/*++

Routine Description:

    Encode the Architecture and version into a DWORD.

Arguments:

    pszArch     - pointer to machine spooler defined environment string
    dwVer       - machines driver version
    pdwVal      - pointer where to store the encoded value

Return Value:

    TRUE - remote information returned, FALSE - remote information not available.

--*/
{

    struct ArchMap {
        UINT uArchId;
        DWORD dwVersion;
        DWORD dwPUIVer;
        DWORD dwPUIArch;
        };

    //
    // disable MIPS & PPC drivers, since they are not supported from setup
    //
    static ArchMap aArchMap [] = {
        { IDS_ENVIRONMENT_ALPHA,   0,  VERSION_0,  ARCH_ALPHA  },
        { IDS_ENVIRONMENT_X86,     0,  VERSION_0,  ARCH_X86    },
        //{ IDS_ENVIRONMENT_MIPS,    0,  VERSION_0,  ARCH_MIPS   },
        { IDS_ENVIRONMENT_WIN95,   0,  VERSION_0,  ARCH_WIN95  },
        { IDS_ENVIRONMENT_ALPHA,   1,  VERSION_1,  ARCH_ALPHA  },
        { IDS_ENVIRONMENT_X86,     1,  VERSION_1,  ARCH_X86    },
        //{ IDS_ENVIRONMENT_MIPS,    1,  VERSION_1,  ARCH_MIPS   },
        //{ IDS_ENVIRONMENT_PPC,     1,  VERSION_1,  ARCH_PPC    },
        { IDS_ENVIRONMENT_ALPHA,   2,  VERSION_2,  ARCH_ALPHA  },
        { IDS_ENVIRONMENT_X86,     2,  VERSION_2,  ARCH_X86    },
        //{ IDS_ENVIRONMENT_MIPS,    2,  VERSION_2,  ARCH_MIPS   },
        //{ IDS_ENVIRONMENT_PPC,     2,  VERSION_2,  ARCH_PPC    },
        { IDS_ENVIRONMENT_ALPHA,   3,  VERSION_3,  ARCH_ALPHA  },
        { IDS_ENVIRONMENT_X86,     3,  VERSION_3,  ARCH_X86    },
        { IDS_ENVIRONMENT_IA64,    3,  VERSION_3,  ARCH_IA64   }};

    BOOL bRetval = FALSE;
    TString strDriverEnv;
    for( UINT i = 0; i < COUNTOF( aArchMap ); i++ ){

        //
        // Attempt to load the driver environment string from our resource file.
        //
        if( !strDriverEnv.bLoadString( ghInst, aArchMap[i].uArchId ) ){
            DBGMSG( DBG_WARN, ( "Error loading environment string from resource.\n" ) );
            break;
        }

        //
        // If the environment and version match, then encode the environment
        // and version into a single dword.
        //
        if( !lstrcmpi( pszArch, (LPCTSTR)strDriverEnv ) &&
            aArchMap[i].dwVersion == dwVer ){

            *pdwVal = aArchMap[i].dwPUIVer + aArchMap[i].dwPUIArch;
            bRetval = TRUE;
            break;
        }
    }

    return bRetval;
}

BOOL
bGetDriverEnv(
    IN      DWORD   dwDriverVersion,
        OUT TString &strDriverEnv
    )
/*++

Routine Description:

    Convert the Encoded the Architecture and version to a
    spooler defined environment string.

Arguments:

    dwDriverVersion - encoded driver version
    strDriverEnv    - string where to return the environment string.

Return Value:

    TRUE - environment string found, FALSE - error occured.

--*/
{
    struct ArchMap {
        DWORD dwDrvVer;
        UINT uArchId;
        };

    //
    // disable MIPS & PPC drivers, since they are not supported from setup
    //
    static ArchMap aArchMap [] = {
        { DRIVER_IA64_3,      IDS_ENVIRONMENT_IA64  },
        { DRIVER_X86_3,       IDS_ENVIRONMENT_X86   },
        { DRIVER_ALPHA_3,     IDS_ENVIRONMENT_ALPHA },
        { DRIVER_X86_2,       IDS_ENVIRONMENT_X86   },
        //{ DRIVER_MIPS_2,      IDS_ENVIRONMENT_MIPS  },
        { DRIVER_ALPHA_2,     IDS_ENVIRONMENT_ALPHA },
        //{ DRIVER_PPC_2,       IDS_ENVIRONMENT_PPC   },
        { DRIVER_X86_1,       IDS_ENVIRONMENT_X86   },
        //{ DRIVER_MIPS_1,      IDS_ENVIRONMENT_MIPS  },
        { DRIVER_ALPHA_1,     IDS_ENVIRONMENT_ALPHA },
        //{ DRIVER_PPC_1,       IDS_ENVIRONMENT_PPC   },
        { DRIVER_X86_0,       IDS_ENVIRONMENT_X86   },
        //{ DRIVER_MIPS_0,      IDS_ENVIRONMENT_MIPS  },
        { DRIVER_ALPHA_0,     IDS_ENVIRONMENT_ALPHA },
        { DRIVER_WIN95,       IDS_ENVIRONMENT_WIN95 }};

    UINT uId        = 0;
    BOOL bRetval    = FALSE;
    for( UINT i = 0; i < COUNTOF( aArchMap ); i++ ){

        if( aArchMap[i].dwDrvVer == dwDriverVersion ){
            uId = aArchMap[i].uArchId;
            bRetval = TRUE;
            break;
        }
    }

    if( bRetval ){

        //
        // Attempt to load the driver environment string from our resource file.
        //
        if( !strDriverEnv.bLoadString( ghInst, uId ) ){
            DBGMSG( DBG_WARN, ( "Error loading environment string from resource.\n" ) );
            bRetval = FALSE;
        }

    } else {

        DBGMSG( DBG_WARN, ( "Driver / Version not found, bGetDriverEnv.\n" ) );

    }

    return bRetval;
}


PLATFORM
GetDriverPlatform(
    IN DWORD dwDriver
    )
/*++

Routine Description:

    Return the driver platform value  (used by splsetup apis).

Arguments:

    dwDriver - DWORD indicating driver platform/version.

Return Value:

    PLATFORM.

--*/
{
    return (PLATFORM)( dwDriver % ARCH_MAX );
}

DWORD
GetDriverVersion(
    IN DWORD dwDriver
    )

/*++

Routine Description:

    Return the driver version value (used by DRIVER_INFO_x).

Arguments:

    dwDriver - DWORD indicating driver platform/version.

Return Value:

    DWORD version.

--*/

{
    return dwDriver / ARCH_MAX;
}

BOOL
bIsNativeDriver(
    IN LPCTSTR pszServerName,
    IN DWORD dwDriver
    )
/*++

Routine Description:

    Determines whether the platform/version is compatible with the
    current OS.

Arguments:

    dwDriver - DWORD indicating driver platform/version.

Return Value:

    TRUE - compatible, FALSE - not compatible.

--*/
{
    //
    // Get the current driver / version.
    //
    DWORD dwDrv;
    if( bGetCurrentDriver( pszServerName, &dwDrv ) ){
        return dwDrv == dwDriver;
    }
   return FALSE;
}

BOOL
bIs3xDriver(
    IN DWORD dwDriver
    )
/*++

Routine Description:

    Returns TRUE iff driver works with 3.5x.

Arguments:

    dwDriver - DWORD indicating driver platform/version.

Return Value:

--*/

{
    return dwDriver < VERSION_2;
}

BOOL
bGetArchName(
    IN      DWORD    dwDriver,
        OUT TString &strDrvArchName
    )
/*++

Routine Description:

    Retrieves the platform/version name from a driver platform/version.

Arguments:

    dwDriver         - DWORD indicating driver platform/version.
    strDrvArchName   - String where to retun platform/version string.

Return Value:

    TRUE strDrvArchName contains architecture name.
    FALSE error occurred reading string.

--*/

{
    TStatusB bStatus;

    //
    // Load the architecute / driver name.
    //
    bStatus DBGCHK = strDrvArchName.bLoadString( ghInst, IDS_DRIVER_BASE + dwDriver );

    return bStatus;
}


BOOL
bIsCompatibleDriverVersion(
    IN DWORD dwDriver,
    IN DWORD dwVersion
    )
/*++

Routine Description:

    Checks if the specified drivers version is a compatible version.

    NOTE: This function MUST be re-rewritten if the drvier model changes.

Arguments:

    dwDriver         - DWORD indicating driver platform/version.
    dwVersion        - DWORD version number to check.

Return Value:

    TRUE version is compatible.
    FALSE verion is not compatible.

--*/
{
    DWORD dwDriverVersion = GetDriverVersion( dwDriver );

    //
    // If the version are equal then they are compatible.
    //
    if( dwVersion == dwDriverVersion )
        return TRUE;

    //
    // If current driver version is a version 3 (Win2K or above)
    // then version 2 (NT4 Kernel mode) are compatible drivers.
    //
    if( dwDriverVersion == 3 && dwVersion == 2 )
        return TRUE;

    return FALSE;
}


BOOL
SpoolerGetVersionEx(
    IN      LPCTSTR         pszServerName,
    IN OUT  OSVERSIONINFO   *pOsVersionInfo
    )

/*++

Routine Description:

    Gets the osversion using spooler apis, thus it's remotable.

Arguments:

    pszServerName    - pointer to a string which contains the server name
                       a NULL indicates the local machine.
    pOsVersionInf    - pointer to osversion structure to fill in.

Return Value:

    TRUE version structure was filled successfully.
    FALSE error occurred.

--*/

{
    SPLASSERT ( pOsVersionInfo );

    TStatusB bStatus;
    bStatus DBGNOCHK = FALSE;

    if( !pszServerName )
    {
        //
        // Get the osversion info structure size
        //
        bStatus DBGCHK = GetVersionEx( pOsVersionInfo );
    }
    else
    {
        //
        // Attempt to open print server with just read.
        //
        DWORD dwStatus  = ERROR_SUCCESS;
        DWORD dwAccess  = SERVER_READ;
        HANDLE hServer  = NULL;
        DWORD dwNeeded  = 0;
        DWORD dwType    = REG_BINARY;

        //
        // Open the server for read access.
        //
        dwStatus = TPrinter::sOpenPrinter( pszServerName, &dwAccess, &hServer );

        //
        // Get the os version from the remote spooler.
        //
        if( dwStatus == ERROR_SUCCESS )
        {
            dwStatus = GetPrinterData( hServer,
                                       SPLREG_OS_VERSION,
                                       &dwType,
                                       (PBYTE)pOsVersionInfo,
                                       sizeof( OSVERSIONINFO ),
                                       &dwNeeded );

            if( dwStatus == ERROR_SUCCESS )
            {
                bStatus DBGCHK = TRUE;
            }
        }
    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\folder.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    folder.cxx

Abstract:

    Holds support for print folder notifications.  The shell32.dll
    print folder will use the TFolder class to receive data and
    notifications.

    There are two different types of connections on NT SUR:
    'True' connects and 'masq' connects:

        True: Normal uplevel WinNT->WinNT connection.  Connection
        information is stored in HKEY_CURRENT_USER:\Printers\Conenctions.
        Win32spl handles the printer.

        Masq: WinNT client -> downlevel server (win9x, wfw, lm, partial
        print providers).  The connection is really a local printer
        that masquarades as a network printer.  When 1 person connections,
        everyone on that machine suddenly gets the connection.  We
        get create/delete notifications from the server handle, but
        all information about the printer from the server handle is
        incorrect.

    Ideally we would just open a server handle and process all local,
    true, and masq printer connections the same, but the last two are
    not supported.  Therefore we must do the following:

        True: watch the registry and open a separate handle to gather
        information and notficiations.

        Masq: watch the server for creates and deletes, but also
        open a separate handle to get information and notifications.

Author:

    Albert Ting (AlbertT)  30-Oct-1995

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "folder.hxx"

#if DBG
//#define DBG_FLDRINFO                  DBG_INFO
#define DBG_FLDRINFO                    DBG_NONE
#endif

TString *VDSConnection::gpstrConnectStatusOpen = NULL;
TString *VDSConnection::gpstrConnectStatusOpenError = NULL;
TString *VDSConnection::gpstrConnectStatusAccessDenied = NULL;
TString *VDSConnection::gpstrConnectStatusInvalidPrinterName = NULL;

TCHAR gszInternalDefaultPrinter[kPrinterBufMax];

/********************************************************************

    Local prototypes.

********************************************************************/

PBYTE
pPackStrings(
    LPCTSTR* ppszSource,
    PBYTE pDest,
    PDWORD pdwDestOffsets,
    PBYTE pEnd
    );

#if DBG_FOLDER
VOID
vDumpFolderPrinterData(
    PFOLDER_PRINTER_DATA pData
    );
#endif

VOID
vGetInternalDefaultPrinter(
    LPTSTR pszOldDefault
    );

VOID
vUpdateInternalDefaultPrinter(
    VOID
    );

/********************************************************************

    Public interface functions.

    We will try and push as much functionality into printui.dll and
    out of shell32.dll.

********************************************************************/

HRESULT
RegisterPrintNotify(
    IN   LPCTSTR                 pszDataSource,
    IN   IFolderNotify           *pClientNotify,
    OUT  LPHANDLE                phFolder,
    OUT  PBOOL                   pbAdministrator OPTIONAL
    )

/*++

Routine Description:

    Register a notification handler for a data source. This function returns 
    a handle to a folder (in phFolder) when registers handle, which must be 
    closed by calling UnregisterPrintNotify() function below

Arguments:

    pszDataSource - DataSource to query, NULL = local machine.
    pClientNotify - Pointer to client notify interface.
    phFolder      - Where to place the HANDLE to the folder

Return Value:

    S_OK    - Everything looks to be OK
    E_FAIL  - In case of an error. (other error return values are also possibe
              for example: E_OUTOFMEMORY)

--*/

{
    //
    // Allow NULL pointer to be passed, so hack it here
    //
    if( !pszDataSource )
    {
        pszDataSource = gszNULL;
    }

    //
    // Registers the data source passed
    //
    return TFolderList::RegisterDataSource( pszDataSource, pClientNotify, phFolder, pbAdministrator );
}


HRESULT
UnregisterPrintNotify(
    IN   LPCTSTR                 pszDataSource,
    IN   IFolderNotify           *pClientNotify,
    OUT  LPHANDLE                phFolder
    )

/*++

Routine Description:

    Unregister a notification handler (previously registered with 
    RegisterPrintNotify()) for a data source. This function sets the
    phFolder to NULL and free up the notification handler.

Arguments:

    pszDataSource - DataSource to query, NULL = local machine.
    pClientNotify - Pointer to client notify interface.
    phFolder      - Where to place the HANDLE to the folder

Return Value:

    S_OK    - Everything looks to be OK
    E_FAIL  - In case of an error. (other error return values are also possibe
              for example: E_OUTOFMEMORY)

--*/
{
    //
    // Allow NULL pointer to be passed, so hack it here
    //
    if( !pszDataSource )
    {
        pszDataSource = gszNULL;
    }

    //
    // Unregisters the data source passed
    //
    return TFolderList::UnregisterDataSource( pszDataSource, pClientNotify, phFolder );
}

BOOL
bFolderRefresh(
    IN      HANDLE  hFolder,
    OUT     PBOOL   pbAdministrator OPTIONAL
    )

/*++

Routine Description:

    Request that the folder refresh its data by hitting the DataSource.

Arguments:

    hFolder - Folder to refresh.

    pbAdministrator - Returns whether the user has administrative access
        on the hFolder.  If this folder is a server and connections,
        this applies only to the server.

        This should be used to determine if the user can add printers
        to the folder via Add Printer Wizard.

Return Value:

    TRUE = success, FALSE = failure.

--*/

{
    TStatus bStatus;
    bStatus DBGNOCHK = FALSE;
    DWORD dwError = ERROR_SUCCESS;

    // validate the passed in folder handle.
    TFolder* pFolder = (TFolder*)hFolder;
    if (TFolderList::bValidFolderObject(pFolder))
    {
        // enter the notify CS
        CCSLock::Locker notifyLock(pFolder->pPrintLib()->pNotify()->csResumeSuspend());
        if (notifyLock)
        {
            // suspend the background threads callbacks before entering the folder CS
            if (pFolder->pPrintLib()->pNotify()->bSuspendCallbacks())
            {
                {
                    // enter the folder CS while rebuilding the cache.
                    CCSLock::Locker lock(pFolder->CritSec());
                    if (lock)
                    {
                        //
                        // Walk through each DataSource and tell them to refresh.  Start
                        // from the end and go to the beginning to refresh all connections
                        // first, and hit the server last.  When a "masq" printer is
                        // discovered, it is refreshed then added to the end of the
                        // linked list.
                        //
                        bStatus DBGCHK = TRUE;
                        VDataSource* pDataSource;

                        TIter iter;
                        for (pFolder->DataSource_vIterInit(iter), iter.vPrev(); iter.bValid(); iter.vPrev())
                        {
                            pDataSource = pFolder->DataSource_pConvert(iter);
                            bStatus DBGCHK = bStatus && pDataSource->bRefresh();
                        }

                        // do not continue the refresh in case of failure.
                        if (bStatus)
                        {
                            // check to see if the current user is an administrator
                            if (pbAdministrator)
                            {
                                pDataSource = pFolder->DataSource_pHead();
                                *pbAdministrator = pDataSource ? pDataSource->bAdministrator() : FALSE; 
                            }

                            // update the connections.
                            if (pFolder->pConnectionNotify())
                            {
                                pFolder->vConnectionNotifyChange(FALSE);
                            }

                            // revalidate the masq printers.
                            pFolder->vRevalidateMasqPrinters();
                        }
                    }
                    else
                    {
                        // unable to enter the folder CS
                        dwError = ERROR_OUTOFMEMORY;
                    }
                }

                // resume callbacks after releasing the folder CS
                pFolder->pPrintLib()->pNotify()->vResumeCallbacks();
            }
        }
        else
        {
            // unable to enter the notify CS
            dwError = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        // the passed in folder handle is invalid
        dwError = ERROR_INVALID_PARAMETER;
    }

    // set the last error and return
    SetLastError(bStatus ? ERROR_SUCCESS : dwError);
    return bStatus;
}


BOOL
bFolderEnumPrinters(
    IN      HANDLE hFolder,
    OUT     PFOLDER_PRINTER_DATA pData, CHANGE
    IN      DWORD cbData,
    OUT     PDWORD pcbNeeded,
    OUT     PDWORD pcReturned
    )

/*++

Routine Description:

    Main query entrypoint to allow the shell to enumerate printers.
    This is modeled closely after the EnumPrinters call so that
    minimal code in the shell needs to be changed.

Arguments:

    hFolder - Folder to query.

    pData - Pointer to a buffer that receives the return data.  If
        this parameter is NULL, cbData must be 0.

    cbData - Indicates size of pData.

    pcbNeeded - Returns number of bytes needed to hold all printer
        information.

    pcReturned - Returns the number of printers stored in pData.

Return Value:

    TRUE - success, FALSE - failure.

--*/

{
    TStatus bStatus;
    bStatus DBGNOCHK = FALSE;
    DWORD dwError = ERROR_SUCCESS;

    // validate the passed in folder handle.
    TFolder* pFolder = (TFolder*)hFolder;
    if (TFolderList::bValidFolderObject(pFolder))
    {
        *pcbNeeded = 0;
        *pcReturned = 0;

        // lock the folder CS while retreiving data from the cache.
        CCSLock::Locker lock(pFolder->CritSec());
        if (lock)
        {
            // first walk thorugh the DataSources see how much space we need.
            COUNTB cbSize = 0;
            VDataSource* pDataSource;
            
            TIter iter;
            for (pFolder->DataSource_vIterInit(iter), iter.vNext(); iter.bValid(); iter.vNext())
            {
                pDataSource = pFolder->DataSource_pConvert(iter);
                cbSize += pDataSource->cbAllPrinterData();
            }

            // return size to user then check if it's large enough.
            *pcbNeeded = cbSize;
            if (cbData < cbSize)
            {
                // the size of the passed in buffer is not sufficient
                dwError = ERROR_INSUFFICIENT_BUFFER;
            } 
            else 
            {
                // run though all pDataSources again and put them into the buffer.
                PBYTE pBegin = (PBYTE)pData;
                PBYTE pEnd = pBegin + cbData;
                COUNT cReturned = 0;

                for (pFolder->DataSource_vIterInit(iter), iter.vNext(); iter.bValid(); iter.vNext())
                {
                    // pBegin and pEnd are automatically moved inward when the data is packed.
                    pDataSource = pFolder->DataSource_pConvert(iter);
                    cReturned += pDataSource->cPackAllPrinterData(pBegin, pEnd);
                }

                // update the printer's counter.
                if (pcReturned)
                {
                    *pcReturned = cReturned;
                }

#if DBG_FOLDER
                DBGMSG(DBG_FOLDER, ("bFolderEnumPrinters: Return %d Size %d\n", *pcReturned, *pcbNeeded));
                for (UINT i=0; i<*pcReturned; ++i)
                {
                    vDumpFolderPrinterData(&pData[i]);
                }
                DBGMSG(DBG_FOLDER, ("bFolderEnumPrinters DONE\n"));
#endif

                // indicate success here.
                bStatus DBGCHK = TRUE;
            }
        }
        else
        {
            // unable to enter the folder CS
            dwError = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        // the passed in folder handle is invalid
        dwError = ERROR_INVALID_PARAMETER;
    }

    // set the last error and return
    SetLastError(bStatus ? ERROR_SUCCESS : dwError);
    return bStatus;
}


BOOL
bFolderGetPrinter(
    IN      HANDLE hFolder,
    IN      LPCTSTR pszPrinter,
    OUT     PFOLDER_PRINTER_DATA pData,
    IN      DWORD cbData,
    OUT     PDWORD pcbNeeded
    )

/*++

Routine Description:

    Returns information about a specific printer in the hFolder.
    Modeled after GetPrinter to minimize the changes in shell.

Arguments:

    hFolder - Folder that container the printer.

    pszPrinter - Printer that should be queried.  The DataSource prefix
        for remote printers is optional.

    pData - Pointer to a buffer that receives the printer data.
        If this parameter is NULL, cbData must be 0.

    cbData - Size of the input buffer.

    pcbNeeded - Returns the size of the buffer needed to store the
        printer information.


Return Value:

    TRUE = sucess, FALSE = failure.

    When GLE = ERROR_INSUFFICIENT_BUFFER, the client should retry with
    a larger buffer.

--*/

{
    TStatus bStatus;
    bStatus DBGNOCHK = FALSE;
    DWORD dwError = ERROR_SUCCESS;

    // validate the passed in folder handle.
    TFolder* pFolder = (TFolder*)hFolder;
    if (TFolderList::bValidFolderObject(pFolder))
    {
        // lock the folder CS while retreiving the data.
        CCSLock::Locker lock(pFolder->CritSec());
        if (lock)
        {
            // walk through all pDataSources until one has a match.
            VDataSource* pDataSource;

            TIter iter;
            for (pFolder->DataSource_vIterInit(iter), iter.vNext(); iter.bValid(); iter.vNext())
            {
                pDataSource = pFolder->DataSource_pConvert(iter);

                if (pDataSource->bGetPrinter(pszPrinter, pData, cbData, pcbNeeded))
                {
#if DBG_FOLDER
                    vDumpFolderPrinterData(pData);
#endif
                    dwError = ERROR_SUCCESS;
                    bStatus DBGCHK = TRUE;
                    break;
                }

                // on any other error other than INVALID_PRINTER_NAME we should immediately fail.
                dwError = GetLastError();
                if (dwError == ERROR_INVALID_PRINTER_NAME)
                {
                    continue;
                }
                else
                {
                    break;
                }
            }
        }
        else
        {
            // unable to enter the folder CS
            dwError = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        // the passed in folder handle is invalid
        dwError = ERROR_INVALID_PARAMETER;
    }

    // set the last error and return
    SetLastError(bStatus ? ERROR_SUCCESS : dwError);
    return bStatus;
}


/********************************************************************

    Semi-public: called from other printui functions.

********************************************************************/

VOID
TFolder::
vCheckDeleteDefault(
    LPCTSTR pszDeleted
    )
{
    //
    // HACK: WinNT Spooler doesn't support default printer.
    // If the default was deleted, remove it from our internal
    // tracking buffer.
    //
    // If we don't do this, then when we delete the default
    // printer, we try and UPDATEITEM a non-existant item
    // (trying to revert the default printer back to a normal
    // one).  This causes an extra refresh.
    //
    {
        CCSLock::Locker CSL( *gpCritSec );

        if( !lstrcmpi( pszDeleted,
                       gszInternalDefaultPrinter )){

            gszInternalDefaultPrinter[0] = 0;
        }
    }
}


VOID
TFolder::
vDefaultPrinterChanged(
    VOID
    )

/*++

Routine Description:

    The default printer has changed.  Cause the entire windows
    to refresh.  This will force the icon to be refreshed.  (Local
    print folder only.)

    !! HACK !!

    We need to do this since the NT spooler doesn't support
    PRINTER_ATTRIBUTE_DEFAULT, (or per-user notifications).

Arguments:

Return Value:

--*/

{
    TCHAR aszDefault[2][kPrinterBufMax];

    //
    // Send two notification: one for the old default, then
    // one for the new one.
    //
    vGetInternalDefaultPrinter( aszDefault[0] );
    vUpdateInternalDefaultPrinter();
    vGetInternalDefaultPrinter( aszDefault[1] );

    if( lstrcmpi( aszDefault[0], aszDefault[1] )){

        COleComInitializer com; // shell ends up using COM

        DBGMSG( DBG_FOLDER, ( "Folder.vInternalDefaultPrinterChanged: update default printer\n" ));

        INT i;

        for( i=0; i<2; ++i ){

            if( aszDefault[i][0] ){

                SHChangeNotify( SHCNE_UPDATEITEM, SHCNF_PRINTER | SHCNF_FLUSH | SHCNF_FLUSHNOWAIT, aszDefault[i], 0 );
            }
        }
    }
}


/********************************************************************

    Private internal helper functions for Default Printer.

********************************************************************/

VOID
vGetInternalDefaultPrinter(
    IN OUT LPTSTR pszDefaultPrinter CHANGE
    )

/*++

Routine Description:

    Retrieves the default printer from our internal buffer.
    Note: this does not read from win.ini since we may wish to
    get the old default during a WININICHANGE message.

Arguments:

    pszDefault - Receives old default printer.  Must be
        kPrinterBufMax in size.  If there is no default, then
        pszDefault[0] is 0.

Return Value:

--*/

{
    CCSLock::Locker CSL( *gpCritSec );
    lstrcpy( pszDefaultPrinter, gszInternalDefaultPrinter );
}

VOID
vUpdateInternalDefaultPrinter(
    VOID
    )

/*++

Routine Description:

    Updates our internal buffer that hold the default printer.
    This is read from win.ini.

Arguments:

Return Value:

--*/

{
    DWORD       dwSize = kPrinterBufMax;
    TCHAR       szPrinterDefault[kPrinterBufMax];
    TStatusB    bStatus;

    //
    // Get the default printer.
    //
    bStatus DBGNOCHK = GetDefaultPrinter( szPrinterDefault, &dwSize );

    //
    // If there is not default printer then clear our internal buffer.
    //
    if( !bStatus )
    {
        szPrinterDefault[0] = 0;
    }

    //
    // Update the our internal default printer.
    //
    CCSLock::Locker CSL( *gpCritSec );
    lstrcpy( gszInternalDefaultPrinter, szPrinterDefault );

    return;
}

/********************************************************************

    TFolder::TNotifyHandler.

********************************************************************/

TFolder::
TNotifyHandler::
TNotifyHandler(
    IFolderNotify *pClientNotify
    ) :
    _pClientNotify( pClientNotify )
{
    if( _pClientNotify )
    {
        _bValid = TRUE;
    }
}

TFolder::
TNotifyHandler::
~TNotifyHandler(
    VOID
    )
{
    if( bValid() )
    {
        _pClientNotify = NULL;
    }
}

/********************************************************************

    TFolder internal interfaces.

********************************************************************/

TFolder::
TFolder(
    IN LPCTSTR          pszDataSource
    ) : _bValid( FALSE ),
        _pConnectionNotify( NULL )

/*++

Routine Description:

    Construct the folder object.  The base level folder watches
    a DataSource; if the DataSource is local, then it watches connections
    also.

Arguments:

    pszDataSource - DataSource to watch, szNULL indicates local.  This parameter
        must not be NULL.

Return Value:

--*/

{
    TStatusB bSuccess;

    //
    // Keep track for the local data source
    //
    strLocalDataSource().bUpdate( pszDataSource );

    //
    // Ensure the main printlib is initialized.
    //
    bSuccess DBGCHK = TPrintLib::bGetSingleton(_pPrintLib);

    if( bSuccess )
    {
        //
        // Create the notification against the printers on the DataSource
        // first.  Then check if it's a local DataSource.  If so, create a
        // TConnectionNotify object, which watches for printer connections,
        // and adds them as appropriate.
        //

        //
        // Create the main DataSource notification.  This watches all printers
        // on the DataSource.  Other DataSource added from TConnectionNotify
        // are really printer connections (but are handled like DataSources
        // with one printer).
        //
        VDataSource* pDataSource = VDataSource::pNew( this,
                                                      pszDataSource,
                                                      VDataSource::kServer );
        if( !pDataSource ){
            return;
        }

        //
        // kServer always goes at the beginning of the linked list.
        //
        DataSource_vAdd( pDataSource );

        //
        // Now create the connection object if we are watching the DataSource.
        // _pConnectionNotify will always be non-NULL in the local case, and
        // NULL in remote print folders.
        //
        if( !pszDataSource[0] ){

            _pConnectionNotify = new TConnectionNotify( this );
            if( !VALID_PTR( _pConnectionNotify )){
                vCleanup();
                return;
            }
        }

        _bValid = TRUE;
    }
}

TFolder::
~TFolder(
    VOID
    )

/*++

Routine Description:

    Delete the folder.

Arguments:

Return Value:

--*/

{
}

HRESULT
TFolder::
pLookupNotifyHandler(
    IN IFolderNotify     *pClientNotify,
    OUT TNotifyHandler  **ppHandler
    )
/*++

Routine Description:

    Searching for a notification handler.

Arguments:

    pClientNotify - The handler to search for

Return Value:

    NULL  - not found

--*/
{
    SPLASSERT( CritSec( ).bInside( ) );

    TIter iter;
    TFolder::TNotifyHandler *pHandler;
    HRESULT hr = E_INVALIDARG; // Assume pClientNotify is NULL

    if( pClientNotify )
    {
        hr = S_FALSE; // Assume not found
        for( Handlers_vIterInit( iter ), iter.vNext(); iter.bValid(); iter.vNext() )
        {
            pHandler = Handlers_pConvert( iter );
            if( pClientNotify == pHandler->pClientNotify( ) )
            {
                //
                // found!
                //
                hr = S_OK;
                if( ppHandler )
                {
                    *ppHandler = pHandler;
                }
                break;
            }
        }
    }
    else
    {
        //
        // The registration will fail gracefully
        //
        DBGMSG( DBG_ERROR, ( "NULL notify handler is passed to pLookupNotifyHandler(...) function") );
    }

    return hr;
}

HRESULT
TFolder::
RegisterNotifyHandler(
    IN IFolderNotify    *pClientNotify
    )
/*++

Routine Description:

    Registers a new notification handler for this
    folder.

Arguments:

    pClientNotify - The new handler

Return Value:

    S_OK   - on success
    E_FAIL - oterwise

--*/
{
    SPLASSERT( CritSec( ).bInside( ) );

    HRESULT hr = pLookupNotifyHandler(pClientNotify, NULL);

    if( SUCCEEDED(hr) )
    {
        if( S_FALSE == hr )
        {
            //
            // The handler is not found - so register it!
            //
            TFolder::TNotifyHandler *pHandler = new TFolder::TNotifyHandler( pClientNotify );
            DBGMSG( DBG_FLDRINFO, ( "[TFolderList-DBG] TFolder CLIENT ATTACHED!!\n" ) );

            if(VALID_PTR(pHandler))
            {
                Handlers_vAppend( pHandler );
                hr = S_OK;
            }
            else
            {
                delete pHandler;
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            //
            // Trying to register the handler twice
            //
            DBGMSG( DBG_WARN, ( "You are trying to register a notification handler twice\n") );
            hr = E_FAIL;
        }
    }

    return hr;
}

HRESULT
TFolder::
UnregisterNotifyHandler(
    IN IFolderNotify    *pClientNotify
    )
/*++

Routine Description:

    Unregisters a notification handler for this
    folder.

Arguments:

    pClientNotify - The handler, which should be 
                    unregistered

Return Value:

    S_OK   - on success
    E_FAIL - oterwise

--*/
{
    SPLASSERT( CritSec( ).bInside( ) );

    TFolder::TNotifyHandler *pHandler;
    HRESULT hr = pLookupNotifyHandler( pClientNotify, &pHandler );;

    if( SUCCEEDED(hr) )
    {
        if( S_OK == hr )
        {
            //
            // The handler is found! - OK.
            //
            DBGMSG( DBG_FLDRINFO, ( "[TFolderList-DBG] TFolder CLIENT DETACHED!!\n" ) );
            pHandler->Link_vDelinkSelf( );
            delete pHandler;
            hr = S_OK;
        }
        else
        {
            //
            // Trying to unregister a handler which is not regsitered
            //
            DBGMSG( DBG_WARN, ( "You are trying to unregister a handler which is not regsitered\n") );
            hr = E_FAIL;
        }
    }

    return hr;
}

BOOL
TFolder::
bNotifyAllClients( 
    IN FOLDER_NOTIFY_TYPE NotifyType, 
    IN LPCWSTR pszName, 
    IN LPCWSTR pszNewName 
    ) 
/*++

Routine Description:

    Notify all clients of this folder

Arguments:

    Same as for IFolderNotify::ProcessNotify

Return Value:

    TRUE  - on success
    FALSE - oterwise

--*/
{
    //
    // Enter the folder CS as we are going to traverse the
    // notify handlers list (i.e. the folder data)
    //
    CCSLock::Locker CSL( CritSec( ) );

    TIter iter;
    TFolder::TNotifyHandler *pHandler;

    BOOL bResult = TRUE;
    for( Handlers_vIterInit( iter ), iter.vNext(); iter.bValid(); iter.vNext() )
    {
        pHandler = Handlers_pConvert( iter );
        if( !pHandler->_pClientNotify->ProcessNotify( NotifyType, pszName, pszNewName ) )
        {
            bResult = FALSE;
        }
    }

    return bResult;
}

VOID
TFolder::
vRefreshUI(
    VOID
    ) 

/*++

Routine Description:

    A lot of things have changed in the folder: refresh the UI.  Ideally
    we would use SHCNE_UPDATEDIR, but this doesn't seem to work with
    non-fs folders.  Do a complete refresh (note that this doesn't
    update icons, but that's generally ok).

Arguments:

Return Value:

--*/

{
    //
    // Something drastic about the folder has changed.
    // Request that the entire windows refresh.
    // 
    bNotifyAllClients( kFolderUpdateAll, NULL, NULL );
}

BOOL
TFolder::
bLocal(
    VOID
    ) const

/*++

Routine Description:

    Check whether the print folder for the local machine.

Arguments:

Return Value:

    TRUE - This is a local print folder.
    FALSE - It's a remote print folder (or a remote invocation of the
        local print folder).

--*/

{
    return _pConnectionNotify ?
               TRUE :
               FALSE;
}

VOID
TFolder::
vCleanup(
    VOID
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    // This call do not need to be protected with the folder
    // critical section, because it is called only when the 
    // object is detached from any clients and is about to be 
    // destroyed. Actually this is an explicit destructor 
    // function

    //
    // Delete the connection object immediately.  If the
    // pConnectionNotify is currently registered, this will
    // wait until it has been unregistered before deleting it.
    //
    delete _pConnectionNotify;
    {
        //
        // Walk through the DataSources and decrement the refcounts.  The
        // DataSources will be destroyed when the refcount reaches zero.
        //
        VDataSource* pDataSource;
        TIter Iter;
        for( DataSource_vIterInit( Iter ), Iter.vNext();
             Iter.bValid(); ){

            pDataSource = DataSource_pConvert( Iter );
            Iter.vNext();

            pDataSource->DataSource_vDelinkSelf();
            pDataSource->vDelete();
        }
    }
}


/********************************************************************

    TFolder internals.

    Add and Find datasources.

********************************************************************/

VOID
TFolder::
vAddDataSource(
    IN LPCTSTR pszPrinter,
    IN VDataSource::CONNECT_TYPE ConnectType,
    IN BOOL bNotify
    )

/*++

Routine Description:

    Add a data source based on a pszPrinter, and put it on the
    linked list.

Arguments:

    pszPrinter - Name of printer to create.  Client must guarantee
        that this printer does not already have a data source.

    bMasq - Indicates if a masq printer.

    bNotify - Indicates whether we should trigger a notification.
        If this is TRUE, then this is an asynchronous refresh (the
        registry changed).  If this is FALSE, then we don't need
        to notify or refresh since the user is explicitly refreshing.

Return Value:

--*/

{
    SPLASSERT( ConnectType == VDataSource::kTrue ||
               ConnectType == VDataSource::kMasq );

    //
    // Now create one and add it.
    //
    VDataSource* pDataSource = VDataSource::pNew( this,
                                                  pszPrinter,
                                                  ConnectType );
    //
    // If the pointer is invalid, we just punt: the
    // display won't be updated.
    //
    if( pDataSource ){

        //
        // Non-servers always are appended to the end of the list.
        //
        DataSource_vAppend( pDataSource );

        DBGMSG( DBG_FOLDER,
                ( "Folder.vAddDataSource: SHChangeNotify add "TSTR"\n",
                  (LPCTSTR)pDataSource->strDataSource( )));

        //
        // Determine whether we need to send a notification.
        // If we just started, then we don't need one since
        // the user already gets the objects during the enum.
        //
        if( bNotify )
        {
            bNotifyAllClients( kFolderCreate, pDataSource->strDataSource(), NULL );
        }

        //
        // Kick off the notification process.
        //
        pDataSource->bRefresh();
    }
}

VDataSource*
TFolder::
pFindDataSource(
    IN LPCTSTR pszPrinter,
    IN VDataSource::CONNECT_TYPE ConnectType
    ) const

/*++

Routine Description:

    Finds a specified printer, based on a name and type.

Arguments:

    pszPrinter - Printer to find.

    ConnectType - Find only this type of printer.

Return Value:

    VDataSource* if found, NULL if not.

--*/

{
    VDataSource* pDataSource = NULL;
    TIter Iter;
    for( DataSource_vIterInit( Iter ), Iter.vNext();
         Iter.bValid();
         Iter.vNext( )){

        pDataSource = DataSource_pConvert( Iter );

        if( pDataSource->ConnectType() == ConnectType &&
            !lstrcmpi( pDataSource->strDataSource(), pszPrinter )){

            break;
        }
    }

    if( Iter.bValid( )){
        return pDataSource;
    }

    return NULL;
}

/********************************************************************

    Add, delete, and revalidate masq data sources.

********************************************************************/

VOID
TFolder::
vAddMasqDataSource(
    LPCTSTR pszPrinter,
    BOOL bNotify
    )

/*++

Routine Description:

    Add a pszPrinter (that is connection based) to the pFolder.
    Don't add if it already exists.

Arguments:

    pszPrinter - Name of the printer connection (\\server\share format).

Return Value:

--*/

{
    //
    // First verify that one doesn't already exist.
    //
    VDataSource *pDataSource;
    pDataSource = pFindDataSource( pszPrinter, VDataSource::kMasq );

    if( !pDataSource ){
        vAddDataSource( pszPrinter, VDataSource::kMasq, bNotify );
    }
}

VOID
TFolder::
vDeleteMasqDataSource(
    LPCTSTR pszPrinter
    )

/*++

Routine Description:

    Delete a connection based printer data source from the linked
    list.

Arguments:

    pszPrinter - Printer to delete (\\server\share format).

Return Value:

--*/

{
    VDataSource *pDataSource;
    pDataSource = pFindDataSource( pszPrinter, VDataSource::kMasq );

    //
    // Now delete it.
    //
    if( pDataSource ){
        pDataSource->DataSource_vDelinkSelf();
        pDataSource->vDelete();
    }
}

VOID
TFolder::
vRevalidateMasqPrinters(
    VOID
    )

/*++

Routine Description:

    During a refresh, we must verify that all the VDataSource which
    represent the masq printers are in sync with the server.  They
    may get out of sync if one is deleted right when a refresh
    occurs--we'll never get the notification to delete it.

    Note: we don't have to worry about newly added masq printers,
    since they will be added during the refresh.

Arguments:

Return Value:

--*/

{
    CCSLock::Locker CSL( _CritSec );

    TIter Iter;

    DataSource_vIterInit( Iter );
    Iter.vNext();

    SPLASSERT( Iter.bValid( ));

    //
    // Server is always at the head of the list.
    //
    VDataSource *pdsServer = DataSource_pConvert( Iter );
    SPLASSERT( pdsServer->ConnectType() == VDataSource::kServer );

    Iter.vNext();

    while( Iter.bValid( )){

        VDataSource *pDataSource = DataSource_pConvert( Iter );

        //
        // Immediately move iter since we may delink pDataSource.
        //
        Iter.vNext();

        //
        // If it's not a masq case, don't bother to validate it.
        //
        if( pDataSource->ConnectType() != VDataSource::kMasq ){
            continue;
        }

        //
        // Now search for this printer.
        //
        LPCTSTR pszMasq = pDataSource->strDataSource();

        if( !pdsServer->hItemFindByName( pszMasq )){

            //
            // Delete it.
            //

            DBGMSG( DBG_FOLDER,
                    ( "Folder.vRevalidateMasqPrinters: SHChangeNotify: Delete "TSTR"\n",
                      pszMasq ));

            TFolder::vCheckDeleteDefault( pDataSource->strDataSource( ));

            bNotifyAllClients( kFolderDelete, pDataSource->strDataSource( ), NULL );

            pDataSource->DataSource_vDelinkSelf();
            pDataSource->vDelete();
        }
    }
}

VOID
TFolder::
vConnectionNotifyChange(
    BOOL bNotify
    )

/*++

Routine Description:

    The registry has changed.  Enumerate all printer connections and
    see if they match the existing printers.  For printers that
    don't match, delete them, and add any new ones.

    Note: masq printer are not enumerated here, so we don't have
    to worry about making any duplicates.

Arguments:

    bNotify - Indicates whether the connection was created by
        a notification (TRUE) or a refresh (FALSE).

Return Value:

--*/

{
    CCSLock::Locker CSL( _CritSec );

    LPPRINTER_INFO_4 pInfo4 = NULL;
    DWORD cbInfo4 = 0;
    DWORD cPrinters = 0;

    //
    // Retrieve the printer connections for this user.
    //
    if( !VDataRefresh::bEnumPrinters( PRINTER_ENUM_FAVORITE,
                                      NULL,
                                      4,
                                      (PVOID*)&pInfo4,
                                      &cbInfo4,
                                      &cPrinters )){
        //
        // failed! this could be either because the spooler has been stoped (or died 
        // accidentally) - in this case we need to delete all TRUE connects since they
        // are no longer valid.
        //
        VDataSource* pDataSource;
        TIter Iter;
        for( DataSource_vIterInit( Iter ), Iter.vNext(); Iter.bValid(); ){

            //
            // Immediately after we convert the pointer to a pDataSource,
            // increment the iter since we may delete pDataSource.
            //
            pDataSource = DataSource_pConvert( Iter );
            Iter.vNext();

            //
            // if this is a true printer connection - delete it. local
            // printers & masq printers will be taken care separately.
            //
            if( pDataSource->ConnectType() == VDataSource::kTrue ){

                bNotifyAllClients( kFolderDelete, pDataSource->strDataSource( ), NULL );

                pDataSource->DataSource_vDelinkSelf();
                pDataSource->vDelete();
            }
        }

        return;
    }

    //
    // We need to add printers here that we didn't see before,
    // and remove printer connections that no longer exist.
    //

    //
    // HACK: use the Attributes field to indicate whether we've
    // visited this printer before.  Clear them out here.
    //
    UINT i;
    for( i=0; i< cPrinters; ++i ){
        pInfo4[i].Attributes = 0;
    }

    //
    // O(N*N) search.
    //
    VDataSource* pDataSource;
    TIter Iter;
    for( DataSource_vIterInit( Iter ), Iter.vNext(); Iter.bValid(); ){

        //
        // Immediately after we convert the pointer to a pDataSource,
        // increment the iter since we may delete pDataSource.
        //
        pDataSource = DataSource_pConvert( Iter );
        Iter.vNext();

        //
        // Don't look for servers or masq printers, since they don't show
        // up in EnumPrinters( INFO4 ) calls.  They will be separately
        // notified by the regular server handle.
        //
        if( pDataSource->ConnectType() != VDataSource::kTrue ){
            continue;
        }

        //
        // Search printers for a matching one.
        //
        for( i=0; i< cPrinters; ++i ){

            if( !lstrcmpi( pInfo4[i].pPrinterName, pDataSource->strDataSource( ))){
                pInfo4[i].Attributes = 1;
                break;
            }
        }

        if( i == cPrinters ){

            //
            // Printer connection no longer exists, remove and delete it.
            //


            DBGMSG( DBG_FOLDER,
                    ( "Folder.vConnectionNotifyChanged: SHChangeNotify: Delete "TSTR"\n",
                      (LPCTSTR)pDataSource->strDataSource( )));

            TFolder::vCheckDeleteDefault( pDataSource->strDataSource( ));

            bNotifyAllClients( kFolderDelete, pDataSource->strDataSource(), NULL );

            pDataSource->DataSource_vDelinkSelf();
            pDataSource->vDelete();
        }
    }

    //
    // Now walk through pInfo4 and check that all printers have
    // been marked (Attributes set).  Any that are not marked are
    // new printer connections.
    //
    for( i=0; i< cPrinters; ++i ){
        if( !pInfo4[i].Attributes ){
            vAddDataSource( pInfo4[i].pPrinterName,
                            VDataSource::kTrue,
                            bNotify );
        }
    }

    FreeMem( pInfo4 );
}

VOID
TFolder::
vRefZeroed(
    VOID
    )

/*++

Routine Description:

    The reference count to this object has been decremented to zero,
    so delete the object.

    Note: only delete self if the object is valid, since during
    construction, we bump up the refcount then drop it to zero when
    an error occurs.  This occurs in the constructor (since it's
    cleaning up after itself) and we don't want to call the
    destructor in there.   The client is responsible for deleting
    the object if it is invalid.

    TFolder::ctr
        (refcount is zero)
        VDataSource::ctr (acquires reference to TFolder)
            Failure in VDataSource::ctr

        >> Discover VDataSource invalid; delete it:
        VDataSource::dtr (releases reference to TFolder)

        >> Here the refcount has dropped to zero, but we
        >> don't want to delete it since it's not valid.

        >> Don't set valid bit, since VDataSource failed.

    Client deletes TFolder:
    TFolder::dtr called.

Arguments:

Return Value:

--*/

{
    if( bValid( ))
    {
        DBGMSG( DBG_FLDRINFO, ( "[TFolderList-DBG] TFolder OBJECT DESTROYED!!\n" ) );
        delete this;
    }
}

/********************************************************************

    TConnectionNotify

    Watch the registry key for changes to printer connections.  When
    we see a change, we call back to ConnectionNotifyClient.  The
    client then enumerates the printer connections and diffs for any
    changes.

********************************************************************/

TConnectionNotify::
TConnectionNotify(
    TFolder* pFolder
    ) : _pFolder(pFolder), _bRegistered(FALSE)
{
    // create our watch event.
    _shEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!_shEvent)
    {
        DBGMSG(DBG_WARN, ( "Connection.ctr: CreateEvent failed %d\n", GetLastError()));
        return;
    }

    // Create the Printers/Connections key.
    TStatus Status;
    CAutoHandleHKEY shKeyPrinters;
    Status DBGCHK = RegCreateKey(HKEY_CURRENT_USER, gszPrinters, &shKeyPrinters);
    if (Status != ERROR_SUCCESS)
    {
        DBGMSG(DBG_WARN, ( "Connection.ctr: RegCreateKey failed %d\n", GetLastError()));
        return;
    }

    Status DBGCHK = RegCreateKey(shKeyPrinters, gszConnections, &_shKeyConnections);
    if (Status != ERROR_SUCCESS)
    {
        DBGMSG(DBG_WARN, ( "Connection.ctr: RegCreateKey failed %d\n", GetLastError()));
        return;
    }

    if (!bSetupNotify())
    {
        goto Fail;
    }

    Status DBGCHK = _pFolder->pPrintLib()->pNotify()->sRegister(this);
    if (Status != ERROR_SUCCESS)
    {
        goto Fail;
    }
    else
    {
        _bRegistered = TRUE;
    }

    // success
    return;

Fail:
    _shKeyConnections = NULL;
    _shEvent = NULL;
}


TConnectionNotify::
~TConnectionNotify(
    VOID
    )
{
    // check to unregister...
    if (_bRegistered)
    {
        _pFolder->pPrintLib()->pNotify()->sUnregister(this);
    }
}

BOOL
TConnectionNotify::
bSetupNotify(
    VOID
    )
{
    ASSERT(_shKeyConnections);

    TStatus Status;
    Status DBGCHK = RegNotifyChangeKeyValue(_shKeyConnections, TRUE, REG_NOTIFY_CHANGE_NAME, _shEvent, TRUE);

    //
    // Re-enumerate the printers.
    //
    return (Status == ERROR_SUCCESS);
}


/********************************************************************

    Virtual definitions for MExecWork.

********************************************************************/

HANDLE
TConnectionNotify::
hEvent(
    VOID
    ) const
{
    ASSERT(_shEvent);
    return(_shEvent);
}

VOID
TConnectionNotify::
vProcessNotifyWork(
    TNotify* pNotify
    )
{
    UNREFERENCED_PARAMETER(pNotify);

    //
    // What do we do here if this fails?
    //
    TStatusB bStatus;
    bStatus DBGCHK = bSetupNotify();

    //
    // Notify the client that something changed.
    //
    _pFolder->vConnectionNotifyChange(TRUE);
}


/********************************************************************

    VDataSource internals.

    We put in an ugly HACK to handle printer connections: we pretend
    they are DataSources and keep a linked list of DataSources:

       (NULL)             local machine, with many printers.
       \\server\share1    printer connection
       \\server\share2    printer connection

    This is needed when we show the print folder on the local machine:
    we must show both printers on the local machine and printer
    connections.

    The distinction between the two is encapsulated in:

        TDSServer - server view (many printers)
        VDSConnection - single printer connection.

    Another HACK: when we initially open up the print folder, we know
    that the name of the printer connection (via INFO_4) so even
    though we don't have info about the printer yet, we can create a
    "fake" FOLDER_PRINTER_DATA structure that has the printer name, a
    QUERYING token for the printer status, and attributes indicating
    a printer connection.

********************************************************************/

VDataSource*
VDataSource::
pNew(
    TFolder* pFolder,
    LPCTSTR pszDataSource,
    CONNECT_TYPE ConnectType
    )
{
    VDataSource *pDataSource = NULL;

    switch( ConnectType ){
    case kServer:

        pDataSource = new TDSServer( pFolder, pszDataSource );
        break;

    case kTrue:

        pDataSource = new TDSCTrue( pFolder, pszDataSource );
        break;

    case kMasq:

        pDataSource = new TDSCMasq( pFolder, pszDataSource );
        break;

    default:

        SPLASSERT( FALSE );
        break;
    }

    if( !VALID_PTR( pDataSource )){
        delete pDataSource;
        return NULL;
    }

    pDataSource->vIncRef();
    return pDataSource;
}

VOID
VDataSource::
vDelete(
    VOID
    )
{
    //
    // Tell the printer to that the VDataSource (this) is no longer
    // valid.
    //
    _pPrinter->vDelete();

    //
    // Matches pNew IncRef.
    //
    vDecRefDelete();
}

BOOL
VDataSource::
bSkipItem(
    HANDLE hItem
    ) const

/*++

Routine Description:

    Determines whether a particular hItem should be enumerated back
    to the VDataSource.

    We want to skip items like masq printers in servers, since we
    get bogus information about them.  (To get real information,
    we have to hit the connection directly using VDSConnection.)

Arguments:

    hItem - Item to check.

Return Value:

    TRUE - Skip this item from enumeration.
    FALSE - Don't skip it.

--*/

{
    SPLASSERT( _pFolder->CritSec().bInside( ));

    LPCTSTR pszPrinter = pszGetPrinterName( hItem );
    SPLASSERT( pszPrinter );

    //
    // If it's a server, then skip all masq cases, since
    // they are handled by VDSConnection.
    //
    if( ConnectType() == kServer &&
        TDataRPrinter::bSinglePrinter( pszPrinter )){

        return TRUE;
    }

    //
    // !! HACK !!
    //
    // We should fix the spooler so that it does not
    // return non-shared printers remotely from EnumPrinters
    // or the notification apis (unless the user is an
    // admin of the server).
    //
    // If you're not an admin, and it's a remote server
    // (strDataSource is not szNULL), then check if the
    // printer is shared.
    //
    if( !_pFolder->bLocal( )){

        if( !bAdministrator( )){

            //
            // If it's not shared then skip it.
            //
            DWORD dwAttributes = _pPrinter->pData()->GetInfo(
                                     hItem,
                                     TDataNPrinter::kIndexAttributes ).dwData;

            if( !( dwAttributes & PRINTER_ATTRIBUTE_SHARED )){
                return TRUE;
            }
        }
    }

    return FALSE;
}


COUNTB
VDataSource::
cbAllPrinterData(
    VOID
    ) const

/*++

Routine Description:

    Determine the space we need to copy a the entire contents of
    a VDataSource into PFOLDER_PRINTER_DATA structures, including
    strings.

Arguments:

Return Value:

    COUNTB - size in bytes (0 if no printers on machine).

--*/

{
    SPLASSERT( _pFolder->CritSec().bInside( ));

    //
    // Walk through all printers on this DataSource and calculate
    // size.
    //
    COUNTB cbSize = 0;
    HANDLE hItem;
    UINT i;

    COUNT cItems = _lItems > 0 ? static_cast<COUNT>(_lItems) : 0;
    for( i = cItems, hItem = NULL; i; --i ){

        hItem = _pPrinter->pData()->GetNextItem( hItem );
        SPLASSERT( hItem );

        if( bSkipItem( hItem )){
            continue;
        }

        cbSize += cbSinglePrinterData( hItem );
    }

    return cbSize;
}


COUNT
VDataSource::
cPackAllPrinterData(
    IN OUT PBYTE& pBegin, CHANGE
    IN OUT PBYTE& pEnd
    ) const

/*++

Routine Description:

    Pack all printers on this DataSource into the buffer pData.  The
    end of the buffer is marked by pEnd, (strings grow from the end).

    Note: this assumes there is enough space to copy the data.  Callee
    must ensure this.

Arguments:

    pBegin - Buffer to receive the data.  Structures grow from the front,
        strings are added to the end (at pEnd).  On exit, this is moved
        to the end of the structure (aligned so that the next pData in
        the array can be added).

    pEnd - End of the buffer.  When this function returns, the end is
        updated to the new 'end' of the buffer.

Return Value:

    COUNT - number of structures copied.

--*/

{
    SPLASSERT( _pFolder->CritSec().bInside( ));

    UINT i;
    HANDLE hItem = NULL;
    COUNT cReturned;

    COUNT cItems = _lItems > 0 ? static_cast<COUNT>(_lItems) : 0;
    for( cReturned = 0, i = cItems; i; --i ){

        hItem = _pPrinter->pData()->GetNextItem( hItem );
        SPLASSERT( hItem );

        if( bSkipItem( hItem )){
            continue;
        }

        ++cReturned;

        //
        // pBegin and pEnd are updated here--they move from the
        // outside in.
        //
        vPackSinglePrinterData( hItem,
                                pBegin,
                                pEnd );
    }

    SPLASSERT( pBegin <= pEnd );

    return cReturned;
}


BOOL
VDataSource::
bGetPrinter(
    IN     LPCTSTR pszPrinter,
       OUT PFOLDER_PRINTER_DATA pData,
    IN     DWORD cbData,
       OUT PDWORD pcbNeeded
    ) const

/*++

Routine Description:

    Get a printer from a DataSource.  Default implementation.

Arguments:


Return Value:


--*/

{
    SPLASSERT( _pFolder->CritSec().bInside( ));

    HANDLE hItem = hItemFindByName( pszPrinter );

    if( !hItem ){
        SetLastError( ERROR_INVALID_PRINTER_NAME );
        return FALSE;
    }

    *pcbNeeded = cbSinglePrinterData( hItem );

    if( *pcbNeeded > cbData ){
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    PBYTE pBegin = (PBYTE)pData;
    PBYTE pEnd = pBegin + cbData;

    vPackSinglePrinterData( hItem, pBegin, pEnd );

    SPLASSERT( (PBYTE)pData <= (PBYTE)pEnd );

    return TRUE;
}

HANDLE
VDataSource::
hItemFindByName(
    LPCTSTR pszPrinter
    ) const
{
    SPLASSERT( _pFolder->CritSec().bInside( ));

    //
    // Scan through all printers and look for a matching printer.
    //
    UINT i;
    LPCTSTR pszTest;
    HANDLE hItem = NULL;

    COUNT cItems = _lItems > 0 ? static_cast<COUNT>(_lItems) : 0;
    for( i = cItems; i; --i ){

        hItem = _pPrinter->pData()->GetNextItem( hItem );
        SPLASSERT( hItem );

        pszTest = pszGetPrinterName( hItem );
        SPLASSERT( pszTest );

        if( !lstrcmpi( pszTest, pszPrinter )){
            return hItem;
        }
    }
    return NULL;
}


/********************************************************************

    Internal VDataSource functions.

********************************************************************/

VDataSource::
VDataSource(
    TFolder* pFolder,
    LPCTSTR pszDataSource,
    CONNECT_TYPE ConnectType
    ) : _pFolder( pFolder ), 
        _strDataSource( pszDataSource ),
        _cIgnoreNotifications( 0 ), 
        _ConnectType( ConnectType ), 
        _lItems(0)
{
    //
    // Acquire a reference to pFolder.
    //
    pFolder->vIncRef();

    if( !VALID_OBJ( _strDataSource )){
        return;
    }

    _pPrinter = TPrinter::pNew( (VDataSource*)this,
                                pszDataSource,
                                0 );

    //
    // _pPrinter is our valid check.
    //
}

VDataSource::
~VDataSource(
    VOID
    )
{
    //
    // Release the reference to the pFolder.
    //
    _pFolder->cDecRef();
}

COUNTB
VDataSource::
cbSinglePrinterData(
    HANDLE hItem
    ) const

/*++

Routine Description:

    Determines the amount of space needed to store one printer
    on a DataSource.  (Includes space for struct and strings.)

Arguments:

    hItem - Printer to size.

Return Value:

    COUNTB - size in bytes.

--*/

{
    SPLASSERT( _pFolder->CritSec().bInside( ));

    //
    // Add all structure elements.
    //
    COUNTB cbSize = sizeof( FOLDER_PRINTER_DATA );
    COUNT cch;

    cch = lstrlen( pszGetPrinterName( hItem ));
    cch += lstrlen( pszGetCommentString( hItem ));

    cch += lstrlen( pszGetLocationString( hItem ));
    cch += lstrlen( pszGetModelString( hItem ));
    cch += lstrlen( pszGetPortString( hItem ));

    //
    // Four string null terminators.
    //
    cch += 5;

    cbSize += cch * sizeof( TCHAR );

    DBGMSG( DBG_NONE, ( "DataSource.cbPrinterData size of %x is %d\n", hItem, cbSize ));

    return cbSize;
}

LPCTSTR
VDataSource::
pszGetCommentString(
    HANDLE hItem
    ) const

/*++

Routine Description:

    Default implementation for comment string; retrieves comment
    from _pPrinter.

Arguments:

    hItem - Find the comment about this item.  If NULL, returns szNULL.

Return Value:

    LPCTSTR - string if available, szNULL if no string.
    The string is _not_ orphaned and should not be freed.  The
    lifetime is controlled by the hItem.  (Lifetime of hItem is
    controlled by the pFolder->_CritSec.)

--*/

{
    SPLASSERT( _pFolder->CritSec().bInside( ));

    LPCTSTR pszComment;

    if( hItem ){

        pszComment = _pPrinter->pData()->GetInfo(
                         hItem,
                         TDataNPrinter::kIndexComment ).pszData;

        if( pszComment ){
            return pszComment;
        }
    }

    return gszNULL;
}

LPCTSTR
VDataSource::
pszGetLocationString(
    HANDLE hItem
    ) const

/*++

Routine Description:

    Default implementation for location string; retrieves location
    from _pPrinter.

Arguments:

    hItem - Find the location about this item.  If NULL, returns szNULL.

Return Value:

    LPCTSTR - string if available, szNULL if no string.
    The string is _not_ orphaned and should not be freed.  The
    lifetime is controlled by the hItem.  (Lifetime of hItem is
    controlled by the pFolder->_CritSec.)

--*/

{
    SPLASSERT( _pFolder->CritSec().bInside( ));

    LPCTSTR pszLocation = NULL;

    if( hItem ){

        pszLocation = _pPrinter->pData()->GetInfo(
                         hItem,
                         TDataNPrinter::kIndexLocation ).pszData;
        if( pszLocation ){
            return pszLocation;
        }
    }

    return gszNULL;
}

LPCTSTR
VDataSource::
pszGetModelString(
    HANDLE hItem
    ) const

/*++

Routine Description:

    Default implementation for model string; retrieves model
    from _pPrinter.

Arguments:

    hItem - Find the model about this item.  If NULL, returns szNULL.

Return Value:

    LPCTSTR - string if available, szNULL if no string.
    The string is _not_ orphaned and should not be freed.  The
    lifetime is controlled by the hItem.  (Lifetime of hItem is
    controlled by the pFolder->_CritSec.)

--*/

{
    SPLASSERT( _pFolder->CritSec().bInside( ));

    LPCTSTR pszModel = NULL;

    if( hItem ){

        pszModel = _pPrinter->pData()->GetInfo(
                         hItem,
                         TDataNPrinter::kIndexModel ).pszData;
        if( pszModel ){
            return pszModel;
        }
    }

    return gszNULL;
}

LPCTSTR
VDataSource::
pszGetPortString(
    HANDLE hItem
    ) const

/*++

Routine Description:

    Default implementation for port string; retrieves port
    from _pPrinter.

Arguments:

    hItem - Find the port about this item.  If NULL, returns szNULL.

Return Value:

    LPCTSTR - string if available, szNULL if no string.
    The string is _not_ orphaned and should not be freed.  The
    lifetime is controlled by the hItem.  (Lifetime of hItem is
    controlled by the pFolder->_CritSec.)

--*/

{
    SPLASSERT( _pFolder->CritSec().bInside( ));

    LPCTSTR pszPort = NULL;

    if( hItem ){

        pszPort = _pPrinter->pData()->GetInfo(
                         hItem,
                         TDataNPrinter::kIndexPort ).pszData;
        if( pszPort ){
            return pszPort;
        }
    }

    return gszNULL;
}


VOID
VDataSource::
vPackSinglePrinterData(
    IN     HANDLE hItem,
    IN OUT PBYTE& pBegin, CHANGE
    IN OUT PBYTE& pEnd
    ) const

/*++

Routine Description:

    Pack the printer data into a buffer.  We may want to put additional
    structures in this structure, so we will build the strings at
    the end of the buffer (pEnd).

Arguments:

    hItem - Printer to find information.

    pBegin - Buffer to place FOLDER_PRINTER_DATA.

    pEnd - End of buffer.

Return Value:

    New End of buffer.

--*/

{
    SPLASSERT( _pFolder->CritSec().bInside( ));
    PFOLDER_PRINTER_DATA pData = (PFOLDER_PRINTER_DATA)pBegin;

    static DWORD gadwFolderPrinterDataOffsets[] = {
        OFFSETOF( FOLDER_PRINTER_DATA, pName ),
        OFFSETOF( FOLDER_PRINTER_DATA, pComment ),
        OFFSETOF( FOLDER_PRINTER_DATA, pLocation ),
        OFFSETOF( FOLDER_PRINTER_DATA, pDriverName ),
        OFFSETOF( FOLDER_PRINTER_DATA, pPortName ),
        (DWORD)-1
    };

    pData->cbSize = sizeof( FOLDER_PRINTER_DATA );
    pData->pStatus = NULL;

    LPCTSTR ppszSource[5];

    ppszSource[0] = pszGetPrinterName( hItem );
    ppszSource[1] = pszGetCommentString( hItem );
    ppszSource[2] = pszGetLocationString( hItem );
    ppszSource[3] = pszGetModelString( hItem );
    ppszSource[4] = pszGetPortString( hItem );

    pData->Status = _pPrinter->pData()->GetInfo(
                        hItem,
                        TDataNPrinter::kIndexStatus ).dwData;
    pData->Attributes = _pPrinter->pData()->GetInfo(
                            hItem,
                            TDataNPrinter::kIndexAttributes ).dwData;
    //
    // Make sure the attributes have at least the right bits turned on.
    //
    switch( ConnectType( )){
    case kMasq:
        pData->Attributes |= PRINTER_ATTRIBUTE_LOCAL |
                             PRINTER_ATTRIBUTE_NETWORK;
        break;
    case kTrue:
        pData->Attributes |= PRINTER_ATTRIBUTE_NETWORK;
        pData->Attributes &= ~PRINTER_ATTRIBUTE_LOCAL;
        break;
    case kServer:
        //
        // The attribute bits are reported back correctly for
        // local printers.
        //
        break;
    }

    pData->cJobs = _pPrinter->pData()->GetInfo(
                       hItem,
                       TDataNPrinter::kIndexCJobs ).dwData;

    //
    // If it's not connection based, then show the sharing icon
    // over the network icon.
    //
    // However, if it's a connection, then show the network icon
    // since nearly all connections must be shared in the first place
    // (unless the client is an admin of the printers).
    //
    if( ConnectType() == kServer ){
        if( pData->Attributes & PRINTER_ATTRIBUTE_SHARED ){
            pData->Attributes &= ~PRINTER_ATTRIBUTE_NETWORK;
        }
    } else {
        pData->Attributes |= PRINTER_ATTRIBUTE_NETWORK;
        pData->Attributes &= ~PRINTER_ATTRIBUTE_SHARED;
    }

    pEnd = pPackStrings( ppszSource,
                         pBegin,
                         (PDWORD)gadwFolderPrinterDataOffsets,
                         pEnd );

    pBegin += sizeof( FOLDER_PRINTER_DATA );
}


/********************************************************************

    MPrinterClient virtual definitions.

********************************************************************/

VOID
VDataSource::
vContainerChanged(
    IN CONTAINER_CHANGE ContainerChange,
    IN INFO Info
    )

/*++

Routine Description:

    The state of the container (hFolder) has changed.  This is a
    callback notification.

Arguments:

    ContainerChange - Enumerated type indicating the type of change.

    Info - Extra information about the change; exact data dependent
        on the type of ContainerChange.

Return Value:

--*/

{
    DBGMSG( DBG_FOLDER,
            ( "DataSource.vContainerChanged: %x %x\n", ContainerChange, Info.dwData ));

    //
    // We must be inside the critical section since we are going to
    // modify internal datastructures.
    //
    CCSLock::Locker CSL( _pFolder->CritSec( ) );

    switch( ContainerChange ){

    case kContainerClearItems:
        vReloadItems();
        _lItems = 0;

        break;

    case kContainerReloadItems:

        vReloadItems();
        _lItems = Info.dwData;

        break;

    case kContainerNewBlock:

        _pPrinter->pData()->vBlockProcess();
        break;

    case kContainerRefreshComplete:

        DBGMSG( DBG_FOLDER, ( "DataSource.vContainerChanged: refresh complete\n" ));

        //
        // The refresh (which may have been requested by the user)
        // is now complete.  Turn off the flag so that any new
        // item changes will trigger notifications to the shell.
        //
        _cIgnoreNotifications = 0;
        DBGMSG( DBG_FOLDER, ( "DataSource.vContainerChanged: Request => FALSE\n" ));

        vRefreshComplete();
        break;

    default:
        break;
    }
}

BOOL
VDataSource::
bGetPrintLib(
    TRefLock<TPrintLib> &refLock
    ) const
{
    ASSERT(_pFolder);
    ASSERT(_pFolder->pPrintLib().pGet());

    if (_pFolder && _pFolder->pPrintLib().pGet())
    {
        refLock.vAcquire(_pFolder->pPrintLib().pGet());
        return TRUE;
    }

    return FALSE;
}

VOID
VDataSource::
vItemChanged(
    IN ITEM_CHANGE ItemChange,
    IN HITEM hItem,
    IN INFO Info,
    IN INFO InfoNew
    )

/*++

Routine Description:

    Callback from the notification to indicate that an item has changed.
    (In this case a printer on a DataSource.)

Arguments:

    ItemChange - Enumerated type indicating the type of change.

    hItem - Handle to item that has changed.  This may be passed to the
        VData* interface to retrieve information about the item.

    Info - Depends on the type of change; generally the old version
        of the info.

    InfoNew - Depends on the type of change; generally the new version
        of the info.

Return Value:

--*/

{
    //
    // We should always be in the critical section here, since
    // this is a callback from when we call pPrinter->pData->vBlockProcess().
    //
    SPLASSERT( _pFolder->CritSec().bInside( ));

    FOLDER_NOTIFY_TYPE uEvent = kFolderNone;
    LPCTSTR pszPrinter = NULL;

    //
    // Decrement the count since we received a notification.  This is a
    // hack to reduce the flicker: when a new object is added, you
    // get notification for each column.  Wait until the last one
    // before repainting the entire line once.
    //
    if( _cIgnoreNotifications ){
        --_cIgnoreNotifications;
    }

    switch( ItemChange ){
    case kItemCreate:

        //
        // Send a change notification now.
        //
        DBGMSG( DBG_FOLDER,
                ( "Folder.vItemChanged: Create %x  %x %x\n",
                  hItem, Info.dwData, InfoNew.dwData ));

        _lItems++;
        pszPrinter = InfoNew.pszData;

        uEvent = uItemCreate( pszPrinter, !_cIgnoreNotifications );
        break;

    case kItemDelete: {

        //
        // Send a change notification now.
        //

        //
        // Masq hack:
        //
        // If a downlevel printer removed (both NETWORK and CONNECTION)
        // then we need to remove the separate VDSConnection since
        // the notifications isn't plugged into the server.
        //
        pszPrinter = pszGetPrinterName( hItem );
        SPLASSERT( pszPrinter );

        TFolder::vCheckDeleteDefault( pszPrinter );

        if( TDataRPrinter::bSinglePrinter( pszPrinter )){

            //
            // Remove it.
            //
            _pFolder->vDeleteMasqDataSource( pszPrinter );
        }

        DBGMSG( DBG_FOLDER,
                ( "Folder.vItemChanged: Delete %x  %x %x\n",
                  hItem, Info.dwData, InfoNew.dwData ));

        _lItems--;

        //
        // Reopen the printer if it was a conneciton.  The printer may have
        // been deleted and we must display the new new connection status.
        //
        if( bReopen() ){

            uEvent = kFolderNone;

        } else {

            uEvent = kFolderDelete;
        }

        break;
    }
    case kItemName:

        //
        // Send a change notification now.
        //

        DBGMSG( DBG_FOLDER,
                ( "Folder.vItemChanged: Name %x  "TSTR" "TSTR"\n",
                  hItem, Info.pszData, InfoNew.pszData ));

        //
        // Reopen the printer if it was a conneciton.  The printer may have
        // been deleted and we must display the new new connection status.
        //
        if( bReopen() ){

            uEvent = kFolderNone;

        } else {

            //
            // Notify if we're not refreshing and we have a folder pidl.
            //
            if( !_cIgnoreNotifications )
            {
                DBGMSG( DBG_FOLDER,
                        ( "vItemChanged: SHChangeNotify: Rename "TSTR" -> "TSTR"\n",
                          Info.pszData, InfoNew.pszData ));

                _pFolder->bNotifyAllClients( kFolderRename, Info.pszData, InfoNew.pszData );
            }
        }
        break;

    case kItemInfo:

        DBGMSG( DBG_FOLDER,
                ( "Folder.vItemChanged: Info %x  %x %x\n",
                  hItem, Info.dwData, InfoNew.dwData ));
        //
        // Some information about the printer that affects _both_
        // icon and report view has changed.  Update all displays.
        //
        uEvent = kFolderUpdate;
        break;

    case kItemSecurity:

        DBGMSG( DBG_FOLDER,
                ( "Folder.vItemChanged: Security %x  %x %x\n",
                  hItem, Info.dwData, InfoNew.dwData ));
        //
        // Some information about the printer that affects _both_
        // icon and report view has changed.  Update all displays.
        //
        uEvent = kFolderUpdateAll;
        break;

    case kItemAttributes:

        DBGMSG( DBG_FOLDER,
                ( "Folder.vItemChanged: Attribute %x  %x %x\n",
                  hItem, Info.dwData, InfoNew.dwData ));
        //
        // Don't use SHCNE_UPDATEITEM.  When the print folder is
        // placed on the start menu, SHCNE_UPDATEITEMs cause it
        // to refresh/re-enumerate everything.  Since neither
        // the name nor icon changed, we don't want the start menu
        // to do anything.
        //
        // kItemAttributes indicates something about the printer
        // has changed that does _not_ affect icon/list views.  However,
        // it does affect report (details) view.
        //
        uEvent = kFolderAttributes;
        break;

    default:
        break;
    }

    //
    // If we're not refreshing and there is an event, send a notification.
    // We don't want to send a notification when we're refreshing since
    // those items aren't in the client's datastore/listview.  After
    // the refresh, the client will refresh its display anyway.
    //
    if( !_cIgnoreNotifications && uEvent != kFolderNone )
    {
        //
        // If no name set, use the one from the hItem.
        //
        if( !pszPrinter )
        {
            pszPrinter = pszGetPrinterName( hItem );
        }

        if( pszPrinter )
        {
            DBGMSG( DBG_FOLDER,
                    ( "vItemChanged: SHChangeNotify: Event %d, "TSTR"\n",
                      uEvent,
                      pszPrinter ));

            _pFolder->bNotifyAllClients( uEvent, pszPrinter, NULL );

        } else 
        {
            DBGMSG( DBG_WARN,
                    ( "vItemChanged: Event %d, NULL printer event\n",
                      uEvent ));
        }
    }
}


VDataNotify*
VDataSource::
pNewNotify(
    MDataClient* pDataClient
    ) const
{
    return new TDataNPrinter( pDataClient );
}


VDataRefresh*
VDataSource::
pNewRefresh(
    MDataClient* pDataClient
    ) const
{
    return new TDataRPrinter( pDataClient );
}

VOID
VDataSource::
vRefZeroed(
    VOID
    )
{
    if( bValid( )){
        delete this;
    }
}


/********************************************************************

    TDSCTrue

********************************************************************/

TDSCTrue::
TDSCTrue(
    TFolder *pFolder,
    LPCTSTR pszDataSource
    ) : VDSConnection( pFolder, pszDataSource, kTrue )
{
}

TDSCTrue::
~TDSCTrue(
    VOID
    )
{
}


/********************************************************************

    TDSCMasq

********************************************************************/

TDSCMasq::
TDSCMasq(
    TFolder *pFolder,
    LPCTSTR pszDataSource
    ) : VDSConnection( pFolder, pszDataSource, kMasq )
{
}

TDSCMasq::
~TDSCMasq(
    VOID
    )
{
}

/********************************************************************

    General routines.

********************************************************************/

PBYTE
pPackStrings(
    IN LPCTSTR* ppszSource,
    IN PBYTE pDest, CHANGE
    IN PDWORD pdwDestOffsets,
    IN PBYTE pEnd
    )

/*++

Routine Description:

    spoolss.dll's pack strings routine.  Take a list of strings and
    pack them at the end of the buffer.

    For example, if you want to create an array of n structures that
    has embedded strings, but they need to be in a contiguous block,
    you need to put the structures first and the strings last.

    This routine will start from the outside of the buffer, placing
    the struct at the beginning, and the strings at the end:

    FirstCall: >|struct1| free                         |struct1Strings|<
         pDest->*                                               pEnd->#
    SecondCall:        >|struct2| free  |struct2strings|<
                        *                              #

    This call assumes the buffer is large enough to hold the structure.

Arguments:

    ppszSource - Array of string pointers.  These strings need to be
        copied into the end of pDest (pointed to be pEnd), and the
        string pointer is put into pDest + pdwDestOffsets[*].

    pDest - The strings pointers are placed at this address (plus
        the pdwDestOffests[*]).

    pdwOffsets - Indicates where the new strings should be stored
        in pDest.  DWORD array terminated by (DWORD)-1.

    pEnd - Points to the end of the buffer pointed to by pDest.

Return Value:

    New pEnd.

--*/

{
    COUNTB cbStr;

    pEnd = (PBYTE)WordAlignDown( pEnd );
    PBYTE pEndOld = pEnd;

    for( ;
         *pdwDestOffsets != (DWORD)-1;
         ppszSource++, pdwDestOffsets++ ){

         if( *ppszSource ){

            //
            // String exists, copy it over.
            //
            cbStr = ( lstrlen(*ppszSource) + 1 ) * sizeof(TCHAR);

            pEnd -= cbStr;
            CopyMemory( pEnd, *ppszSource, cbStr);

            *(LPTSTR *)(pDest + *pdwDestOffsets) = (LPTSTR)pEnd;

        } else {

            *(LPDWORD *)(pDest+ *pdwDestOffsets) = 0;
        }
    }

    DBGMSG( 0,
            ( "pPackStrings pDest %x, pEnd %x -> %x %d\n",
              pDest, pEndOld, pEnd, (ULONG_PTR)(pEndOld - pEnd) ));

    return pEnd;
}


/********************************************************************

    TDSServer overrides.

********************************************************************/

TDSServer::
TDSServer(
    IN TFolder* pFolder,
    IN LPCTSTR pszDataSource
    ) : VDataSource( pFolder, pszDataSource, kServer ),
        _bDiscardRefresh( FALSE )
{
}

BOOL
TDSServer::
bRefresh(
    VOID
    )

/*++

Routine Description:

    Refresh all information about this TDSServer.

Arguments:

Return Value:

    TRUE = success, FALSE = fail.

--*/

{
    //
    // HACK: The WinNT spooler doesn't support default printer
    // notifications (or even the attribute bit).  When we request
    // a refresh, and we are the local print folder, look for
    // store away the default printer so that if the user changes
    // the default, we can send the old one an UPDATEITEM which
    // will refresh it's icon.
    //
    if( _strDataSource.bEmpty( )){
        vUpdateInternalDefaultPrinter();
    }

    //
    // Sadly, SHCNE_UPDATEITEM of the container doesn't refresh
    // the entire window.  I suspect that it's doing a comparison
    // of pidls to see if something anything new was added or
    // deleted.  This doesn't correctly handle the case where
    // a printer is purged however (the pidls are identical, but
    // something in details view has changed).
    //
    // There's some fSupportsIdentity code (DVM_SUPPORTSIDENTITY);
    // this is used by the fstreex.c to see if the write timestamp
    // has changed (probably to update the details view if anything
    // is different), but we don't store this information in the
    // printer pidl, so we can't support it.
    //
    // Best we can do is let the notifications through.  Now
    // with every refresh we get a huge number of notifications.
    //
    if( _bDiscardRefresh ){
        _bDiscardRefresh = FALSE;
    } else {

        //
        // The _cIgnoreNotifications is used to prevent us from sending
        // notifications.  Once the refresh is complete, we turn this
        // flag off, then changing start calling SHChangeNotify again.
        //
        _cIgnoreNotifications = (COUNT)-1;
    }

    DBGMSG( DBG_FOLDER, ( "bFolderRefresh: %x Request => TRUE\n", this ));

    return _pPrinter->bSyncRefresh();
}


BOOL
TDSServer::
bReopen(
    VOID
    )

/*++

Routine Description:

    Reopen the data source.

Arguments:

Return Value:

    TRUE = success, FALSE = fail.

--*/

{
    return FALSE;
}

VOID
TDSServer::
vContainerChanged(
    IN CONTAINER_CHANGE ContainerChange,
    IN INFO Info
    )
{
    VDataSource::vContainerChanged( ContainerChange, Info );

    switch( ContainerChange ){
    case kContainerStateVar:

        //
        // Force a refresh of everything, since notification state
        // was lost.  This can occur if you purge the printer.
        //

        //
        // Set bDiscardRefresh so that we know we need notifications
        // when the new data comes in.  This is required because even
        // though we send a SHCNE_UPDATEITEM on the container (print
        // folder), the shell doesn't repaint all items.  It only
        // repaints new/deleted items--not ones that have attribute
        // changes.
        //
        _bDiscardRefresh = TRUE;
        _pFolder->vRefreshUI();
        break;
    }
}

VOID
TDSServer::
vReloadItems(
    VOID
    )

/*++

Routine Description:

    The printer is reloading all information about itself.

    This should only be called from the bFolderRefresh synchronous
    case (we'll never get an async refresh because we capture it
    in TDSServer::vContainerChanged( kContainerStateVar, * ) and
    convert it to a vRefreshUI above).

Arguments:

Return Value:

--*/

{
}


VOID
TDSServer::
vRefreshComplete(
    VOID
    ) const

/*++

Routine Description:

    Something about the server has changed, so we need to refresh
    the entire print folder (since we can have muliple printers on
    one TDSServer).

Arguments:

Return Value:

--*/

{
    //
    // If this is a server, tell the folder to validate all it's
    // masq printers.  We need to do this because at the same moment
    // there's a refresh, one of the masq printers could have been
    // deleted.  Since we just refreshed, we won't get any notifications
    // about it.
    //
    // Alternatively, at the beginning of a refresh we could
    // delete all masq printers.  Then the refresh will recreate
    // the currently existing printers.  However, this will force
    // us to close and reopen the printers--an expensive operation.
    //
    _pFolder->vRevalidateMasqPrinters();
}


FOLDER_NOTIFY_TYPE
TDSServer::
uItemCreate(
    IN LPCTSTR pszPrinter,
    IN BOOL bNotify
    )

/*++

Routine Description:

    If this is a server and it's the single printer
    (\\server\share) name, then create a masq printer.
    We do this because the spooler doesn't give us correct
    information about masq printers--we need to go directly
    to the source by creating a VDSConnection.

    We can't rely on the attribute bits
    (PRINTER_ATTRIBUTE_{LOCAL|NETWORK})
    being set since win9x connections don't set both
    of them.

Arguments:

Return Value:

--*/

{
    if( TDataRPrinter::bSinglePrinter( pszPrinter )){

        //
        // Prepend the data source to talk to printer gateway if
        // we are in the remote printers folder.
        //
        TString strPrinter( strDataSource() );

        if( !strPrinter.bEmpty() ){
            strPrinter.bCat( gszWack );
        }

        strPrinter.bCat( pszPrinter );

        //
        // Add the masq printer.  Also send a notification
        // if we're not refreshing.
        //
        _pFolder->vAddMasqDataSource( strPrinter,
                                      bNotify );

        //
        // Don't send a notification since vAddMasqDataSource will.
        //
        return kFolderNone;
    }

    return kFolderCreate;
}


LPCTSTR
TDSServer::
pszGetPrinterName(
    IN HANDLE hItem
    ) const
{
    LPCTSTR pszName;

    pszName = _pPrinter->pData()->GetInfo(
                  hItem,
                  TDataNPrinter::kIndexPrinterName ).pszData;

    if( !pszName ){
        pszName = gszNULL;
    }

    return pszName;
}


BOOL
TDSServer::
bAdministrator(
    VOID
    ) const
{
    return _pPrinter->dwAccess() == SERVER_ALL_ACCESS;
}


BOOL
TDSServer::
bGetPrinter(
    IN     LPCTSTR pszPrinter,
       OUT PFOLDER_PRINTER_DATA pData,
    IN     DWORD cbData,
       OUT PDWORD pcbNeeded
    ) const

/*++

Routine Description:

    Override the default implementation so that we can strip
    off the server prefix if it has one.

Arguments:

Return Value:

--*/

{
    UINT cchDataSource = lstrlen( _strDataSource );

    //
    // Check if there is a server prefix.  If so, strip it off since
    // our stored names don't have prefixes.
    //
    if( cchDataSource &&
        !_tcsnicmp( pszPrinter,
                    _strDataSource,
                    cchDataSource ) &&
        pszPrinter[cchDataSource] == TEXT( '\\' )){

        //
        // Skip the prefix: "\\DataSource\printer" -> "printer."
        // Also skip the '\' separator.
        //
        pszPrinter += cchDataSource + 1;
    }

    //
    // Masq HACK.
    //
    // If this is a server and it's a masq printer, then don't bother
    // searching for it, since there's a VDataSource that has more
    // up to date information.  The spooler does not return accurate
    // information for masq printer in a server handle, so we created
    // a separate VDSConnection for the masq printer.
    //
    if( TDataRPrinter::bSinglePrinter( pszPrinter )){
        SetLastError( ERROR_INVALID_PRINTER_NAME );
        return FALSE;
    }

    return VDataSource::bGetPrinter( pszPrinter,
                                     pData,
                                     cbData,
                                     pcbNeeded );
}

/********************************************************************

    VDSConnection.

********************************************************************/

VDSConnection::
VDSConnection(
    TFolder* pFolder,
    LPCTSTR pszDataSource,
    CONNECT_TYPE ConnectType
    ) : VDataSource( pFolder, pszDataSource, ConnectType ),
        _ConnectStatus( kConnectStatusOpen )
{

    SPLASSERT( ConnectType == VDataSource::kTrue ||
               ConnectType == VDataSource::kMasq );

    //
    // These global strings should be initialized
    // already.
    //
    SPLASSERT( gpstrConnectStatusOpen );
}

BOOL
VDSConnection::
bStaticInitShutdown(
    BOOL bShutdown
    )
{
    if( bShutdown )
    {
        delete gpstrConnectStatusOpen;
        delete gpstrConnectStatusOpenError;
        delete gpstrConnectStatusInvalidPrinterName;
        delete gpstrConnectStatusAccessDenied;

        return TRUE;
    }
    else
    {
        TStatusB bStatus;
        bStatus DBGNOCHK = FALSE;

        gpstrConnectStatusOpen = new TString;
        gpstrConnectStatusOpenError = new TString;
        gpstrConnectStatusInvalidPrinterName = new TString;
        gpstrConnectStatusAccessDenied = new TString;

        if( gpstrConnectStatusOpen && 
            gpstrConnectStatusOpenError &&
            gpstrConnectStatusInvalidPrinterName && 
            gpstrConnectStatusAccessDenied )
        {
            bStatus DBGCHK = gpstrConnectStatusOpen->bLoadString(
                ghInst,
                IDS_SB_OPEN );

            bStatus DBGCHK = bStatus && gpstrConnectStatusOpenError->bLoadString(
                ghInst,
                IDS_SB_OPEN_ERROR );

            bStatus DBGCHK = bStatus && gpstrConnectStatusInvalidPrinterName->bLoadString(
                ghInst,
                IDS_SB_INVALID_PRINTER_NAME );

            bStatus DBGCHK = bStatus && gpstrConnectStatusAccessDenied->bLoadString(
                ghInst,
                IDS_SB_ACCESS_DENIED );
        }

        if( !bStatus )
        {
            delete gpstrConnectStatusOpen;
            delete gpstrConnectStatusOpenError;
            delete gpstrConnectStatusInvalidPrinterName;
            delete gpstrConnectStatusAccessDenied;

            gpstrConnectStatusOpen = 
            gpstrConnectStatusOpenError = 
            gpstrConnectStatusInvalidPrinterName = 
            gpstrConnectStatusAccessDenied = NULL;
        }

        return bStatus;
    }
}

BOOL
VDSConnection::
bRefresh(
    VOID
    )

/*++

Routine Description:

    Refresh all information about this TDSServer.

Arguments:

Return Value:

    TRUE = success, FALSE = fail.

--*/

{
    //
    // Since it's a single printer, make it asynchronous.  This puts
    // the "querying" status on the connection and allows the shell
    // to continue processing UI messages.  We can do this for
    // connection since we know the name of the printer.
    //
    BOOL bResult = FALSE;
    if( _pFolder->pPrintLib()->bJobAdd( _pPrinter, TPrinter::kExecRefreshAll ))
    {
        //
        // HACK: on a refresh, ignore all notifications until the
        // last one, when the refresh is complete.
        //
        // Since this refresh completes asynchronously, we must
        // still send a notification on the very last change.
        //
        _cIgnoreNotifications = TDataNPrinter::kFieldTableSize;
        bResult = TRUE;
    }

    return bResult;
}

BOOL
VDSConnection::
bReopen(
    VOID
    )
/*++

Routine Description:

    Reopen the data source.

Arguments:

Return Value:

    TRUE = success, FALSE = fail.

--*/
{
    if( _ConnectType == kTrue ){

        CCSLock::Locker CSL( _pFolder->CritSec( ));

        //
        // Since it's a single printer, make it asynchronous.  This puts
        // the "querying" status on the connection and allows the shell
        // to continue processing UI messages.  We can do this for
        // connection since we know the name of the printer.
        //
        if( _pFolder->pPrintLib()->bJobAdd( _pPrinter, TPrinter::kExecReopen )){

            return TRUE;
        }

    }
    return FALSE;
}

VOID
VDSConnection::
vReloadItems(
    VOID
    )

/*++

Routine Description:

    The printer is reloading all information about itself.

    Ignore notifications; we'll refresh the entire line when the refresh
    has completed.

Arguments:

Return Value:

--*/

{
    _cIgnoreNotifications = (COUNT)-1;
}

VOID
VDSConnection::
vRefreshComplete(
    VOID
    ) const

/*++

Routine Description:

    The data about the connection has been refreshed.  Update
    the item in the window.

Arguments:

Return Value:

--*/

{
    DBGMSG( DBG_FOLDER,
            ( "DSConnection.vRefreshComplete: SHChangeNotify: Update "TSTR"\n",
              (LPCTSTR)_strDataSource ));

    _pFolder->bNotifyAllClients( kFolderAttributes, _strDataSource, NULL );
}


BOOL
VDSConnection::
bUseFakePrinterData(
    VOID
    ) const
{
    return (_lItems <= 0)                                     ||
           _ConnectStatus == kConnectStatusInvalidPrinterName ||
           _ConnectStatus == kConnectStatusAccessDenied       ||
           _ConnectStatus == kConnectStatusOpen               ||
           _ConnectStatus == kConnectStatusOpenError          ||
           _ConnectStatus == kConnectStatusInitialize;
}

COUNTB
VDSConnection::
cbSinglePrinterData(
    HANDLE hItem
    ) const
{
    //
    // HACK for the single printer (printer connection) case.
    //
    if( bUseFakePrinterData( ))
    {
        return sizeof( FOLDER_PRINTER_DATA ) +
               ( lstrlen( _strDataSource ) + 1) * sizeof( TCHAR );
    }
    return VDataSource::cbSinglePrinterData( hItem );
}



VOID
VDSConnection::
vPackSinglePrinterData(
    IN     HANDLE hItem,
    IN OUT PBYTE& pBegin, CHANGE
    IN OUT PBYTE& pEnd
    ) const
{
    //
    // HACK for the single printer (printer connection) case.
    //
    if( bUseFakePrinterData( ))
    {
        PFOLDER_PRINTER_DATA pData = (PFOLDER_PRINTER_DATA)pBegin;

        //
        // Put the string in the right place, and adjust pEnd so
        // it points to the new place.
        //
        pEnd -= ( lstrlen( _strDataSource ) + 1) * sizeof( TCHAR );
        pBegin += sizeof( FOLDER_PRINTER_DATA );
        lstrcpy( (LPTSTR)pEnd, _strDataSource);

        //
        // Create a fake structure so the shell can display
        // "querying."
        //
        pData->Status = 0;

        if( ConnectType() == kMasq ){

            //
            // Set the attribute bit as both NETWORK and LOCAL
            // so that it appears as a network icon, but when
            // we delete it, we use DeletePrinter instead of
            // DeletePrinterConnection.
            //
            pData->Attributes = PRINTER_ATTRIBUTE_NETWORK |
                                PRINTER_ATTRIBUTE_LOCAL;

        } else {
            pData->Attributes = PRINTER_ATTRIBUTE_NETWORK;
        }

        pData->pComment = NULL;
        pData->cbSize = sizeof( FOLDER_PRINTER_DATA );
        pData->pLocation = NULL;
        pData->pDriverName = NULL;
        pData->pPortName = NULL;
        pData->pStatus = pszGetStatusString( NULL );
        pData->cJobs = 0;
        pData->pName = (LPCTSTR)pEnd;

        SPLASSERT( pBegin <= pEnd );
    }
    else
    {
        //
        // This is the normal case.
        //
        VDataSource::vPackSinglePrinterData( hItem, pBegin, pEnd );
    }
}

COUNTB
VDSConnection::
cbAllPrinterData(
    VOID
    ) const
{
    HANDLE hItem = NULL;

    if( !bUseFakePrinterData( ))
    {
        hItem = _pPrinter->pData()->GetNextItem( NULL );
    }

    return cbSinglePrinterData( hItem );
}

COUNT
VDSConnection::
cPackAllPrinterData(
    IN OUT PBYTE& pBegin, CHANGE
    IN OUT PBYTE& pEnd
    ) const
{
    HANDLE hItem = NULL;

    if( !bUseFakePrinterData( ))
    {
        hItem = _pPrinter->pData()->GetNextItem( NULL );
    }

    vPackSinglePrinterData( hItem,
                            pBegin,
                            pEnd );

    return 1;
}


LPCTSTR
VDSConnection::
pszGetCommentString(
    HANDLE hItem
    ) const

/*++

Routine Description:

    Based on the current connection status, return a string.

Arguments:

    hItem - Item to get the comment about.

Return Value:

    LPCTSTR - Comment string (szNULL if no string).
    This string is _not_ orphaned, and should not be freed by callee.

--*/

{
    SPLASSERT( _pFolder->CritSec().bInside( ));

    //
    // Get comment from the default implementation.
    //
    return VDataSource::pszGetCommentString( hItem );
}

LPCTSTR
VDSConnection::
pszGetStatusString(
    HANDLE hItem
    ) const

/*++

Routine Description:

    Based on the current connection status, return a string.

Arguments:

    hItem - Item to get the comment about.

Return Value:

    LPCTSTR - Comment string (szNULL if no string).
    This string is _not_ orphaned, and should not be freed by callee.

--*/

{
    SPLASSERT( _pFolder->CritSec().bInside( ));

    LPCTSTR pszConnect = NULL;

    //
    // Show an meaningful string.  Note: these strings
    // do not point within the pFolderPrinterData: they
    // are simply pointers to "global" data.
    //
    switch( _ConnectStatus ){

    case kConnectStatusInvalidPrinterName:

        pszConnect = *gpstrConnectStatusInvalidPrinterName;
        break;

    case kConnectStatusAccessDenied:

        pszConnect = *gpstrConnectStatusAccessDenied;
        break;

    case kConnectStatusOpen:

        pszConnect = *gpstrConnectStatusOpen;
        break;

    case kConnectStatusOpenError:

        pszConnect = *gpstrConnectStatusOpenError;
        break;

    default:

        DBGMSG( DBG_FOLDER, ("Unknown connection status found %d.\n", _ConnectStatus ) );
        break;
    }

    return pszConnect;
}


BOOL
VDSConnection::
bGetPrinter(
    IN     LPCTSTR pszPrinter,
       OUT PFOLDER_PRINTER_DATA pData,
    IN     DWORD cbData,
       OUT PDWORD pcbNeeded
    ) const
{
    if( _lItems <= 0 && !lstrcmpi( pszPrinter, _strDataSource)){

        //
        // Get the size of the single fake printer.  Even though
        // this function returns the space for all printers on the
        // DataSource, since there aren't any, it will return the size
        // for the fake printer.
        //
        *pcbNeeded = cbAllPrinterData();

        if( *pcbNeeded > cbData ){
            SetLastError( ERROR_INSUFFICIENT_BUFFER );
            return FALSE;
        }

        PBYTE pBegin = (PBYTE)pData;
        PBYTE pEnd = pBegin + cbData;

        COUNT cFakeItems = cPackAllPrinterData( pBegin, pEnd );

        //
        // We are creating a "fake" printer that has a status
        // of queryring.  Make sure only 1 is returned.
        //
        SPLASSERT( cFakeItems == 1 );
        SPLASSERT( (PBYTE)pData <= (PBYTE)pEnd );

        return TRUE;
    }

    //
    // There actually is printer data there; use it.
    //
    return VDataSource::bGetPrinter( pszPrinter,
                                     pData,
                                     cbData,
                                     pcbNeeded );
}

FOLDER_NOTIFY_TYPE
VDSConnection::
uItemCreate(
    LPCTSTR pszPrinter,
    BOOL bNotify
    )
{
    return kFolderUpdate;
}

LPCTSTR
VDSConnection::
pszGetPrinterName(
    HANDLE hItem
    ) const
{
    UNREFERENCED_PARAMETER( hItem );

    return _strDataSource;
}


VOID
VDSConnection::
vContainerChanged(
    IN CONTAINER_CHANGE ContainerChange,
    IN INFO Info
    )

/*++

Routine Description:

    Something about the printer connection container has changed.
    (The container only holds the 1 printer connection, either a
    masq or true connect.)

Arguments:

    ContainerChange - Type of change.

    Info - Information about the change.

Return Value:

--*/

{
    VDataSource::vContainerChanged( ContainerChange, Info );

    switch( ContainerChange ){
    case kContainerConnectStatus:

        vUpdateConnectStatus((CONNECT_STATUS)Info.dwData);
        break;

    case kContainerStateVar:

        //
        // The printer internal state has changed--probably
        // a refresh or something asynchronous failed.
        // Request a state change.
        //
        _pFolder->pPrintLib()->bJobAdd( _pPrinter, Info.dwData );
        break;
    }
}


VOID
VDSConnection::
vUpdateConnectStatus(
    IN CONNECT_STATUS ConnectStatusNew
    )

/*++

Routine Description:

    The connection status of a printer has changed.  Update
    the comment string if this is an "interesting" state.

    Note: connection state has nothing to do with the "real" state
    of the printer--it's just this particular connection.

Arguments:

    ConnectStatusNew - New connection status.

Return Value:

--*/

{
    //
    // Change the connection status (stored in comment) only
    // for those strings that are interesting.
    //
    switch( ConnectStatusNew ){
    case kConnectStatusNull:
    case kConnectStatusInvalidPrinterName:
    case kConnectStatusAccessDenied:
    case kConnectStatusOpen:
    case kConnectStatusOpenError:

        if( _ConnectStatus != ConnectStatusNew ){

            TString strPrinter;

            {
                //
                // We must be inside the critical section, since changing
                // the ConnectStatus changes the connection string.
                // We could be in VDataSource::bGetPrinter, which assumes
                // that the data doesn't change while inside the CritSec.
                //
                CCSLock::Locker CSL( _pFolder->CritSec( ));
                _ConnectStatus = ConnectStatusNew;

                LPCTSTR pszPrinter = pszGetPrinterName( NULL );

                DBGMSG( DBG_FOLDER,
                        ( "DSConnection.vContainerChanged: SHChangeNotify: Update "TSTR"\n",
                        pszPrinter ));

                strPrinter.bUpdate( pszPrinter );

            }

            if( VALID_OBJ( strPrinter ) ){

                //
                // Don't use SHCNE_UPDATEITEM.  When the print folder is
                // placed on the start menu, SHCNE_UPDATEITEMs cause it
                // to refresh/re-enumerate everything.  Since neither
                // the name nor icon changed, we don't want the start menu
                // to do anything.
                //
                _pFolder->bNotifyAllClients( kFolderAttributes, strPrinter, NULL );
            }
        }
        break;

    default:

        //
        // Other connect status messages will come through here,
        // be we don't want to update the display.
        //
        break;
    }
}

BOOL
VDSConnection::
bAdministrator(
    VOID
    ) const
{
    return _pPrinter->dwAccess() == PRINTER_ALL_ACCESS;
}

/********************************************************************

    TFolderList class

********************************************************************/

TFolderList *TFolderList::gpFolders = NULL;
CCSLock     *TFolderList::gpFolderLock = NULL;

TFolderList::
TFolderList( )

/*++

Routine Description:

    Construct the global folder list object.

Arguments:

Return Value:

--*/

{
    // only one instance of this class can be created (TFolderList::gpFolders)
    SPLASSERT( NULL == gpFolders );
}

TFolderList::
~TFolderList( )

/*++

Routine Description:

    Destruct the global folder list object.

Arguments:

Return Value:

--*/

{
    // only one instance of this class can be created (TFolderList::gpFolders)
    SPLASSERT( NULL != gpFolders );
}

HRESULT
TFolderList::
RegisterDataSource( 
    IN  LPCTSTR         pszDataSource, 
    IN  IFolderNotify   *pClientNotify,
    OUT LPHANDLE        phFolder,
    OUT PBOOL           pbAdministrator OPTIONAL
    )

/*++

Routine Description:

    Registers a client for notification in the corresponding 
    data source.

    Note: pClientNotify can't be NULL

Arguments:

    pszDataSource - Data source name
    pClientNotify - Client feedback connection point
    phFolder      - Where to place a handle of the 
                    folder object for further access

Return Value:

    S_OK  - Success
    E_XXX - Failure (for some reason)

--*/

{
    BOOL bRefresh = FALSE;

    //
    // Lock the global folder list
    //
    CCSLock::Locker CSL( *TFolderList::gpFolderLock );

    HRESULT hr = E_FAIL;
    TFolder *pResult = NULL;

    if( !gpFolders )
    {
        gpFolders = new TFolderList;

        //
        // Check the folder list to be valid
        // 
        if( !VALID_PTR( gpFolders ))
        {
            hr = E_OUTOFMEMORY;
            delete gpFolders;
            gpFolders = NULL;
        }
    }

    if( gpFolders )
    {
        //
        // Lookup for the desired data source. 
        // Returns S_OK if found and S_FALSE if not.
        //
        hr = pLookupFolder(pszDataSource, &pResult);
    }

    if( gpFolders && S_OK != hr )
    {
        //
        // Create new folder object.
        //
        pResult = new TFolder( pszDataSource );
        
        //
        // Check if the folder object was created successfully.
        //
        if( VALID_PTR( pResult ))
        {
            //
            // Remember this folder is new and should be added
            // to the folders list ...
            //
            DBGMSG( DBG_FLDRINFO, ( "[TFolderList-DBG] TFolder OBJECT CREATED!!\n" ) );

            //
            // Acquire a reference to the TFolder.
            //
            pResult->vIncRef();

            //
            // This folder has just been successfully created
            // add has clients hooked up, so add it to the 
            // folder list
            //
            gpFolders->Folders_vAppend( pResult );

            //
            // This is a new folder - request a full refresh.
            //
            bRefresh = TRUE;

            //
            // We have a valid folder. Make the piece of code below
            // to work properly.
            //
            hr = S_OK;
        }   
        else
        {
            //
            // Release the folder memory and mark as invalid.
            //
            hr = E_OUTOFMEMORY;
            delete pResult;
            pResult = NULL;
        }
    }
    
    if( gpFolders && S_OK == hr )
    {
        //
        // Lock the folder CS while registering the new 
        // notify handler.
        //
        CCSLock::Locker lock( pResult->CritSec( ) );

        //
        // Register the new handler for this folder
        //
        hr = pResult->RegisterNotifyHandler( pClientNotify );

        if( FAILED(hr) && pResult->Handlers_bEmpty() )
        {
            //
            // This folder has no more clients, so
            // we will destroy it outside of the
            // global critical section scope
            //
            pResult->Link_vDelinkSelf( );
            pResult->vCleanup();
            pResult->vDecRefDelete();
            pResult = NULL;
        }

        if( SUCCEEDED(hr) && phFolder )
        {
            *phFolder = reinterpret_cast<HANDLE>( pResult );
        }
    }

    if( SUCCEEDED(hr) && pResult )
    {
        if( bRefresh )
        {
            //
            // full refresh has been requested...
            //
            bFolderRefresh(reinterpret_cast<HANDLE>(pResult), pbAdministrator);
        }
        else
        {
            //
            // Check to see if the current user is an administrator
            //
            if( pbAdministrator )
            {
                VDataSource *pDataSource = pResult->DataSource_pHead();
                *pbAdministrator = pDataSource ? pDataSource->bAdministrator() : FALSE; 
            }
        }
    }

    return hr;
}

HRESULT
TFolderList::
UnregisterDataSource( 
    IN  LPCTSTR         pszDataSource, 
    IN  IFolderNotify   *pClientNotify,
    OUT LPHANDLE        phFolder
    )

/*++

Routine Description:

    Unregisters a client for notification previousely 
    registered with RegisterDataSource() function

    Note: pClientNotify can't be NULL

Arguments:

    pszDataSource - Data source name
    pClientNotify - Client feedback connection point
    phFolder      - Where to place a NULL handle 
                    (to clear the handle var if provided)

Return Value:

    S_OK  - Success
    E_XXX - Failure (for some reason)

--*/

{
    TFolder *pFolder = NULL;
    HRESULT hr = E_FAIL;

    //
    // Lock the global folder list
    //
    CCSLock::Locker CSL( *TFolderList::gpFolderLock );

    if( gpFolders )
    {
        //
        // Lookup for the desired data source. 
        // Returns S_OK if found and S_FALSE if not.
        //
        hr = pLookupFolder(pszDataSource, &pFolder);

        if( S_OK == hr && TFolderList::bValidFolderObject(pFolder) )
        {
            //
            // Lock the folder CS while unregistering the 
            // notify handler.
            //
            CCSLock::Locker lock( pFolder->CritSec( ) );

            hr = pFolder->UnregisterNotifyHandler(pClientNotify);

            //
            // Everything is OK here. The client has been detached 
            // successfully
            //
            if( phFolder )
            {
                if( pFolder != *phFolder )
                {
                    DBGMSG( DBG_FOLDER, ( "This must be TRUE: pFolder == *phFolder" ) );
                }

                *phFolder = NULL;
            }

            if( pFolder->Handlers_bEmpty() )
            {
                //
                // This folder has no more clients, so
                // put it in pending deletion mode, so it
                // will be deleted outside the CS's.
                //
                pFolder->Link_vDelinkSelf( );
            }
            else
            {
                //
                // Prevents folder to be deleted.
                //
                pFolder = NULL;
            }
        }

        //
        // Check to delete the folder list if empty
        //
        if( gpFolders->Folders_bEmpty() )
        {
            delete gpFolders;
            gpFolders = NULL;
        }
    }

    if( pFolder )
    {
        pFolder->vCleanup();
        pFolder->vDecRefDelete();
    }

    return hr;
}

BOOL
TFolderList::
bValidFolderObject( 
    IN  const TFolder *pFolder
    )
/*++

Routine Description:

    Verify if this folder object is valid - which means 
    if it is in the global folders list class

Arguments:

    pFolder - The object we are trying to verify

Return Value:

    TRUE  - object is valid
    FALSE - object has been dismised already

--*/
{
    //
    // Lock the global folder list
    //
    CCSLock::Locker fldrCSL( *TFolderList::gpFolderLock );

    BOOL bResult = FALSE;

    if( pFolder && gpFolders )
    {
        TIter iter;
        TFolder *pTemp;

        for( gpFolders->Folders_vIterInit( iter ), iter.vNext(); iter.bValid(); iter.vNext() )
        {
            pTemp = gpFolders->Folders_pConvert( iter );
            if( pTemp == pFolder )
            {
                bResult = TRUE;
                break;
            }
        }
    }

    return bResult;
}

HRESULT
TFolderList::
pLookupFolder( 
    IN  LPCTSTR     pszDataSource,
    OUT TFolder   **ppFolder
    )
/*++

Routine Description:

    Lookup for a folder in the global list for a
    particular datasource.

Arguments:

    pszDataSource - Datasource, which we are seeking folder for.
    ppFolder - Where to return the folder object if found

Return Value:

    S_OK - found
    S_FALSE - not found.
    E_XXXX - in case of an error

--*/
{
    //
    // Lock the global folder list
    //
    CCSLock::Locker fldrCSL( *TFolderList::gpFolderLock );

    SPLASSERT( pszDataSource );
    HRESULT hr = S_FALSE;

    TIter iter;
    TFolder *pFolder;
    for( gpFolders->Folders_vIterInit( iter ), iter.vNext(); iter.bValid(); iter.vNext() )
    {
        pFolder = gpFolders->Folders_pConvert( iter );
        if( 0 == _tcsicmp( pFolder->strLocalDataSource(), pszDataSource ) )
        {
            //
            // found!
            //
            hr = S_OK;
            if( ppFolder )
            {
                *ppFolder = pFolder;
            }
            break;
        }
    }

    return hr;
}

BOOL
TFolderList::
bValid(
    VOID
    ) const
{
    return TRUE;
}

#if DBG_FOLDER

/********************************************************************

    Debug routines: dump a FOLDER_PRINTER_DATA

********************************************************************/

VOID
vDumpFolderPrinterData(
    PFOLDER_PRINTER_DATA pData
    )
{
    DBGMSG( DBG_FOLDER, ( "===vDumpFolderPrinterData begin.\n" ));

    if( !pData ){

        DBGMSG( DBG_FOLDER, ( "---NULL pData\n" ));
        return;
    }

    DBGMSG( DBG_FOLDER, ( "--- %x\n", pData ));

    DBGMSG( DBG_FOLDER, ( "--- %x name:     "TSTR"\n", pData->pName, DBGSTR( pData->pName )));
    DBGMSG( DBG_FOLDER, ( "--- %x comment:  "TSTR"\n", pData->pComment, DBGSTR( pData->pComment )));
    DBGMSG( DBG_FOLDER, ( "--- %x location: "TSTR"\n", pData->pLocation, DBGSTR( pData->pLocation )));
    DBGMSG( DBG_FOLDER, ( "--- %x model:    "TSTR"\n", pData->pDriverName, DBGSTR( pData->pDriverName )));
    DBGMSG( DBG_FOLDER, ( "--- status    : %x\n", pData->Status ));
    DBGMSG( DBG_FOLDER, ( "--- attributes: %x\n", pData->Attributes ));
    DBGMSG( DBG_FOLDER, ( "--- cJobs:      %x\n", pData->cJobs ));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\dsinterf.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998
All rights reserved.

Module Name:

    dsinterf.hxx

Abstract:

    Directory service interface

Author:

    Steve Kiraly (SteveKi)  09-Sept-1996

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dsinterf.hxx"

/*++

Name:

    TDirectoryService constructor.

Description:

    TDirectoryService is a helper class for encapsulating DS
    related functions.

Arguments:

    None.

Return Value:

    Nothing, use bValid for class state check.

--*/
TDirectoryService::
TDirectoryService(
    VOID
    ) : _bValid( FALSE )
 {
    DBGMSG( DBG_TRACE, ( "TDirectoryService::ctor\n" ) );

    //
    // We must initialize OLE for in each thread.  In this
    // case we assume the user of this class only creates
    // one per thread.
    //
    HRESULT hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );


    if( hr == S_OK || hr == S_FALSE )
    {
        _bValid = TRUE;
    }
 }

/*++

Name:

    ~TDirectoryService destructor

Description:

    Destructs this class, all clean up code should be placed here.

Arguments:

    None.

Return Value:

    Nothing.

--*/
TDirectoryService::
~TDirectoryService(
    VOID
    )
 {
    DBGMSG( DBG_TRACE, ( "TDirectoryService::dtor.\n" ) );

    //
    // Coinitlize was only called if we had
    // a valid object.
    //
    if( _bValid )
    {
        //
        // Balance the CoInitialize.
        //
        CoUninitialize();
    }
 }

/*++

Name:

    bValid

Description:

    Indicates if the class is valid.

Arguments:

    None.

Return Value:

    TRUE class is valid, FALSE class is in an invalid state.

--*/
BOOL
TDirectoryService::
bValid(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TDirectoryService::bValid.\n" ) );

    //
    // This class is always valid.
    //
    return TRUE;
}

/*++

Name:

    bGetDirectoryName

Description:

    Retrives the directory display name from the shell, i.e. ds folder.

Arguments:

    strName - refrence to string object where to return
              directory display name.

Return Value:

    TRUE name returne, FALSE error occurred.

--*/
BOOL
TDirectoryService::
bGetDirectoryName(
    IN TString &strName
    )
{
    TStatusB bStatus;

    if( _strDirectoryName.bEmpty() )
    {
        TLibrary Lib( TEXT("dsuiext.dll") );

        if( VALID_OBJ( Lib ) )
        {
            typedef HRESULT (WINAPI *PF_FORMATDIRECTORYNAME)( LPTSTR *, PVOID, UINT );
            typedef VOID (WINAPI *PF_LOCALFREESTRING)( LPTSTR * );

            PF_FORMATDIRECTORYNAME pfFormatDirectoryName = (PF_FORMATDIRECTORYNAME)Lib.pfnGetProc( 578 );
            PF_LOCALFREESTRING pfLocalFreeString = (PF_LOCALFREESTRING)Lib.pfnGetProc( 542 );

            if( pfFormatDirectoryName && pfLocalFreeString )
            {
                HRESULT hr;
                LPTSTR pName = NULL;

                hr = pfFormatDirectoryName( &pName, NULL, 0 );
                if ( SUCCEEDED(hr) )
                {
                    bStatus DBGCHK = _strDirectoryName.bUpdate( pName );
                    pfLocalFreeString(&pName);
                }
            }
        }
    }

    //
    // If the directory name is empty indicate we cannot
    // get the directory name.
    //
    if( _strDirectoryName.bEmpty() )
    {
        bStatus DBGNOCHK = FALSE;
    }
    else
    {
        //
        // Return the directory name.
        //
        bStatus DBGCHK = strName.bUpdate( _strDirectoryName );
    }

    return bStatus;
}


/*++

Name:

    bIsDsAvailable

Description:

    Indicates if the directory service is available either for the
    user or from the machines perspective.

Arguments:

    pName - pointer to a machine name, i.e. this call is remoteable.
    bForUser - TRUE indicate it is a user check, FALSE for machine.

Return Value:

    TRUE if directory is available, otherwize false.

--*/
BOOL
TDirectoryService::
bIsDsAvailable(
    IN LPCTSTR pName,
    IN BOOL    bForUser
    )
{
    BOOL    bReturn     = FALSE;
    DWORD   dwStatus    = ERROR_SUCCESS;
    DWORD   dwAccess    = SERVER_READ;
    DWORD   dwDsStatus  = 0;
    HANDLE  hServer     = NULL;

    //
    // Open the server for read access.
    //
    dwStatus = TPrinter::sOpenPrinter( pName, &dwAccess, &hServer );

    //
    // If server handle opened.
    //
    if( dwStatus == ERROR_SUCCESS )
    {
        DWORD dwNeeded          = 0;
        DWORD dwDsStatusType    = REG_DWORD;

        if( dwStatus == ERROR_SUCCESS )
        {
            //
            // If the request for user or for machine.
            //
            LPTSTR pszKey = bForUser ? SPLREG_DS_PRESENT_FOR_USER : SPLREG_DS_PRESENT;

            //
            // Get the printer data key which indicates the DS is available.
            //
            dwStatus = GetPrinterData( hServer,
                                       pszKey,
                                       &dwDsStatusType,
                                       (PBYTE)&dwDsStatus,
                                       sizeof( dwDsStatus ),
                                       &dwNeeded );
        }

        if( dwStatus == ERROR_SUCCESS )
        {
            bReturn = dwDsStatus;
        }
    }

    //
    // Close the server handle.
    //
    if( hServer )
    {
        ClosePrinter( hServer );
    }

    return bReturn;
}


/*++

Name:

    bIsDsAvailable

Description:

    Indicates if the directory service is available either for the
    using the same check the shell uses.

Arguments:

    None.

Return Value:

    TRUE if directory is available, otherwize false.

--*/
BOOL
TDirectoryService::
bIsDsAvailable(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TDirectoryService::bIsDsAvailble - ShowDirectoryUI.\n" ) );

    BOOL bStatus = FALSE;

    TLibrary Lib( TEXT("dsuiext.dll") );

    if( VALID_OBJ( Lib ) )
    {
        typedef BOOL (WINAPI *PF_SHOWDIRECTORYUI)( VOID );

        PF_SHOWDIRECTORYUI pfShowDirectoryUI = (PF_SHOWDIRECTORYUI)Lib.pfnGetProc( 577 );

        if( pfShowDirectoryUI )
        {
            bStatus = pfShowDirectoryUI();
        }
    }

    return bStatus;
}

HRESULT
TDirectoryService::
ADsGetObject(
    IN      LPWSTR  lpszPathName,
    IN      REFIID  riid,
    IN OUT  VOID    **ppObject
    )
{
    return ::ADsGetObject( lpszPathName, riid, ppObject );
}

HRESULT
TDirectoryService::
ADsBuildEnumerator(
    IADsContainer *pADsContainer,
    IEnumVARIANT   **ppEnumVariant
    )
{
    return ::ADsBuildEnumerator( pADsContainer, ppEnumVariant);
}

HRESULT
TDirectoryService::
ADsFreeEnumerator(
    IEnumVARIANT *pEnumVariant
    )
{
    return ::ADsFreeEnumerator( pEnumVariant );
}

HRESULT
TDirectoryService::
ADsEnumerateNext(
    IEnumVARIANT *pEnumVariant,
    ULONG         cElements,
    VARIANT FAR  *pvar,
    ULONG FAR    *pcElementsFetched
    )
{
    return ::ADsEnumerateNext( pEnumVariant, cElements, pvar, pcElementsFetched);
}

/*++

Name:

    Get

Description:

    This routine gets a string value from the specified DS object using
    the specified property.  A copy of the string is made and placed into
    the provided string object.

Arguments:

    pDsObject       - pointer to the DS object interface
    pszPropertyName - DS object property name
    strString       - refrence to string object where to return string

Return Value:

    TRUE string put successfully, FALSE error occurred.

--*/
BOOL
TDirectoryService::
Get(
    IN IADs    *pDsObject,
    IN LPCTSTR pszPropertyName,
    IN TString &strString
    )
{
    SPLASSERT( pDsObject );
    SPLASSERT( pszPropertyName );

    VARIANT var;

    VariantInit( &var );

    HRESULT hr = pDsObject->Get( const_cast<LPTSTR>( pszPropertyName ), &var );

    if( SUCCEEDED( hr ) && ( var.vt == VT_BSTR ) )
    {
        hr = strString.bUpdate( V_BSTR(&var) ) ? S_OK : E_FAIL;
    }

    VariantClear (&var);

    return SUCCEEDED( hr );
}

/*++

Name:

    Put

Description:

    This routine puts a string value on the specified DS object
    for the specified property.  This routine does not make a copy
    of the string but places it into a variant that is inturn passed
    to Ads::Put method.

Arguments:

    pDsObject       - pointer to the DS object interface
    pszPropertyName - DS object property name
    pszString       - string value to put

Return Value:

    TRUE string put successfully, FALSE error occurred.

--*/
BOOL
TDirectoryService::
Put(
    IN IADs    *pDsObject,
    IN LPCTSTR pszPropertyName,
    IN LPCTSTR pszString
    )
{
    SPLASSERT( pDsObject );
    SPLASSERT( pszPropertyName );

    VARIANT var;
    HRESULT hr;
    VariantInit (&var);

    if( !pszString || !*pszString )
    {
        hr = pDsObject->PutEx( ADS_PROPERTY_CLEAR, const_cast<LPTSTR>( pszPropertyName ), var );
    }
    else
    {
        var.vt      = VT_BSTR;
        var.bstrVal = const_cast<LPTSTR>( pszString );
        hr = pDsObject->Put( const_cast<LPTSTR>( pszPropertyName ), var );
    }

    if( SUCCEEDED( hr ) )
    {
        hr = pDsObject->SetInfo();

        if( FAILED(hr) && ( !pszString || !*pszString ) )
        {
            //
            // From our perspective if we fail to delete a property because it does not exist
            // the operation actually succeeded.
            //
            if( HRESULT_CODE(hr) == ERROR_DS_NO_ATTRIBUTE_OR_VALUE )
            {
                hr = S_OK;
            }
        }

    }

    var.bstrVal = NULL;
    VariantClear (&var);

    return SUCCEEDED(hr);
}


/*++

Name:

    TReadStringProperty

Description:

    This routine reads the specified string using the specified path
    and property name from the DS.

Arguments:

    strString - refrence to class where to returned read string.

Return Value:

    TRUE string was read, FALSE error occurred.

Notes:

--*/
BOOL
TDirectoryService::
ReadStringProperty(
    IN      LPCTSTR     pszPath,
    IN      LPCTSTR     pszProperty,
    IN OUT  TString     &strString
    )
{
    IADs        *pADs;
    HRESULT     hStatus;

    hStatus = ADsGetObject( const_cast<LPTSTR>( pszPath ), IID_IADs, (void **)&pADs);

    if (SUCCEEDED(hStatus))
    {
        VARIANT     var;

        VariantInit(&var);

        hStatus = pADs->Get( const_cast<LPTSTR>( pszProperty ), &var);

        if (SUCCEEDED(hStatus))
        {
            hStatus = strString.bUpdate( V_BSTR(&var) ) ? S_OK : E_FAIL;
        }

        VariantClear (&var);

        pADs->Release();
    }

    if (FAILED(hStatus))
    {
        DBGMSG( DBG_TRACE, ("ReadStringProperty Path " TSTR " Property " TSTR " failed %x\n", pszPath, pszProperty, hStatus ) );
    }

    return SUCCEEDED(hStatus);

}

/*++

Name:

    GetConfigurationContainer

Description:

    This routine figures out the and returnes the path of the
    longged on DS's configuration containter.

Arguments:

    strConfig - Refrence to a string where to return the configuration string.

Return Value:

    TRUE configuration containter returned. FALSE error occurred.

Notes:

--*/
BOOL
TDirectoryService::
GetConfigurationContainer(
    IN OUT TString &strConfig
    )
{
    TStatusB bStatus;

    //
    // If we have not already read the configuration container
    // then read it now.
    //
    if (_strConfigurationContainer.bEmpty())
    {
        TString strRootDSE;
        TString strLDAPPrefix;

        bStatus DBGCHK = GetLDAPPrefix( strLDAPPrefix )    &&
                         strRootDSE.bCat( strLDAPPrefix )  &&
                         strRootDSE.bCat( gszRootDSE );

        if (bStatus)
        {
            bStatus DBGCHK = ReadStringProperty( strRootDSE, gszConfigurationNameingContext, _strConfigurationContainer );
        }
    }

    bStatus DBGCHK = strConfig.bUpdate( _strConfigurationContainer );

    DBGMSG( DBG_TRACE, ( "Configuration Container " TSTR ".\n", (LPCTSTR)strConfig ) );

    return bStatus;

}

/*++

Name:

    GetDsName

Description:

    Returns a the DS UNC name that can be used in the call to
    AddressToSiteNames.

Arguments:

    strDsName - refrence to string where to return the Ds name.

Return Value:

    TRUE success, FALSE error occurred.

Notes:

--*/
BOOL
TDirectoryService::
GetDsName(
    IN TString &strDsName
    )
{
    TString     strDomainName;
    TStatusB    bStatus;

    bStatus DBGCHK = GetDomainName( strDomainName );

    if (bStatus)
    {
        bStatus DBGCHK = strDsName.bUpdate( gszLeadingSlashes ) && strDsName.bCat( strDomainName );
    }

    return bStatus;
}

/*++

Name:

    GetLDAPPrefix

Description:

    Returns the correct LDAP prefix using fully qualified machine account
    domain name (example "LDAP://ntdev.microsoft.com/"

Arguments:

    strLDAPPrefix - where to return The LDAP prefix (domain relative or
                    fully qualified)

Return Value:

    TRUE on success, FALSE othewise

Notes:

--*/
BOOL
TDirectoryService::
GetLDAPPrefix(
    OUT TString &strLDAPPrefix
    )
{
    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;

    if( !_strLDAPPrefix.uLen( ) )
    {
        TString strRootDSE;
        TString strConfig;

        bStatus DBGCHK = strRootDSE.bCat( gszLdapPrefix ) &&
                         strRootDSE.bCat( gszRootDSE );

        if( bStatus )
        {
            //
            // We need to use fully qualified domain LDAP address
            //
            TString strDomainName;
            bStatus DBGCHK = GetDomainName( strDomainName );

            if( bStatus )
            {
                bStatus DBGCHK = _strLDAPPrefix.bUpdate( NULL )       &&
                                 _strLDAPPrefix.bCat( gszLdapPrefix ) &&
                                 _strLDAPPrefix.bCat( strDomainName ) &&
                                 _strLDAPPrefix.bCat( gszSlash );
            }
        }
    }

    if( !_strLDAPPrefix.uLen( ) || !bStatus )
    {
        bStatus DBGCHK = _strLDAPPrefix.bUpdate( gszLdapPrefix );
    }

    if( bStatus )
    {
        bStatus DBGCHK = strLDAPPrefix.bUpdate( _strLDAPPrefix );
    }

    return bStatus;
}

/*++

Name:

    GetLDAPPrefixPerUser

Description:

    Returns the correct LDAP prefix using fully qualified machine account
    domain name (example "LDAP://ntdev.microsoft.com/" if the user domain
    (the domain in which the user is logged on) doesn't have a DS, if the
    user domain has a DS then we are using domain relative prefix (i.e.
    "LDAP://").

Arguments:

    strLDAPPrefix - where to return The LDAP prefix (domain relative or
                    fully qualified)

Return Value:

    TRUE on success, FALSE othewise

Notes:

--*/
BOOL
TDirectoryService::
GetLDAPPrefixPerUser(
    OUT TString &strLDAPPrefix
    )
{
    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;

    if( !_strLDAPPrefixPerUser.uLen( ) )
    {
        TString strRootDSE;
        TString strConfig;

        bStatus DBGCHK = strRootDSE.bCat( gszLdapPrefix ) &&
                         strRootDSE.bCat( gszRootDSE );

        if( bStatus )
        {
            bStatus DBGCHK = ReadStringProperty( strRootDSE, gszConfigurationNameingContext, strConfig );

            if( bStatus )
            {
                //
                // We can use domain relative LDAP address
                //
                bStatus DBGCHK = _strLDAPPrefixPerUser.bUpdate( gszLdapPrefix );
            }
            else
            {
                //
                // We need to use fully qualified domain LDAP address
                //

                bStatus DBGCHK = GetLDAPPrefix (_strLDAPPrefixPerUser);
            }
        }
    }

    if( !_strLDAPPrefixPerUser.uLen( ) || !bStatus )
    {
        bStatus DBGCHK = _strLDAPPrefixPerUser.bUpdate( gszLdapPrefix );
    }

    if( bStatus )
    {
        bStatus DBGCHK = strLDAPPrefix.bUpdate( _strLDAPPrefixPerUser );
    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\forms.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    forms.cxx

Abstract:

    Printer Forms
         
Author:

    Steve Kiraly (SteveKi)  11/20/95
    Lazar Ivanov (LazarI)   Jun-2000 (major changes)

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "forms.hxx"

DWORD pEntryFields[] = { IDD_FM_EF_WIDTH,
                         IDD_FM_EF_HEIGHT,
                         IDD_FM_EF_LEFT,
                         IDD_FM_EF_RIGHT,
                         IDD_FM_EF_TOP,
                         IDD_FM_EF_BOTTOM,
                         0 };

DWORD pTextFields[] = { IDD_FM_TX_WIDTH,
                        IDD_FM_TX_HEIGHT,
                        IDD_FM_TX_LEFT,
                        IDD_FM_TX_RIGHT,
                        IDD_FM_TX_TOP,
                        IDD_FM_TX_BOTTOM,
                        0 };

/*++

Routine Name:

    TPropDriverExists

Routine Description:

    Fix the server handle.  This routine tries to use a 
    server handle to enum the forms on the specified machine.

Arguments:
    hPrintServer,
    pszServerName,
    bAdministrator,
    *phPrinter

Return Value:

    Possible return values
    HANDLE_FIX_NOT_NEEDED
    HANDLE_FIXED_NEW_HANDLE_RETURNED
    HANDLE_NEEDS_FIXING_NO_PRINTERS_FOUND

--*/
UINT
sFormsFixServerHandle( 
    IN HANDLE   hPrintServer,
    IN LPCTSTR  pszServerName,
    IN BOOL     bAdministrator,
    IN HANDLE   *phPrinter
    )
{
    // Check if server handle can be used.
    PFORM_INFO_1 pFormInfo;
    DWORD dwNumberOfForms;
    BOOL bStatus;
    bStatus = bEnumForms(   
                hPrintServer,
                1,
                (PBYTE *)&pFormInfo,
                &dwNumberOfForms );

    // Server handle succeeded.
    if( bStatus && dwNumberOfForms )
    {
        FreeMem(pFormInfo);
        return HANDLE_FIX_NOT_NEEDED;
    }

    // Enumerate the printers on the specified server looking for a printer.
    PRINTER_INFO_2 *pPrinterInfo2   = NULL;
    DWORD cPrinterInfo2             = 0;
    DWORD cbPrinterInfo2            = 0;
    DWORD dwFlags                   = PRINTER_ENUM_NAME;

    bStatus = VDataRefresh::bEnumPrinters( 
                        dwFlags, 
                        (LPTSTR)pszServerName, 
                        2, 
                        (PVOID *)&pPrinterInfo2, 
                        &cbPrinterInfo2,
                        &cPrinterInfo2);

    // If success and at least one printer was enumerated.
    if( bStatus && cPrinterInfo2 )
    {
        TStatus Status;
        Status DBGNOCHK = ERROR_INVALID_FUNCTION;
        DWORD dwAccess = 0;  

        for( UINT i = 0; i < cPrinterInfo2; i++ )
        {
            // Attempt to open the printer using the specified access.
            dwAccess = 0;  
            Status DBGCHK = TPrinter::sOpenPrinter(pPrinterInfo2[i].pPrinterName,
                                                &dwAccess,
                                                phPrinter);

            // Done if a valid printer handle was returned.
            if( Status == ERROR_SUCCESS )
            {
                break;
            } 
            else 
            {
                DBGMSG(DBG_WARN, ( "Error opening printer \"" TSTR "\".\n", pPrinterInfo2[i].pPrinterName));
            }
        }

        // Release the printer enumeration buffer.
        FreeMem(pPrinterInfo2);

        //
        // Return the new handle value.  Note: Access privilage 
        // may have changed.
        //
        DWORD dwAccessType;
        if( Status == ERROR_SUCCESS )
        {
            dwAccessType = bAdministrator ? PRINTER_ALL_ACCESS : PRINTER_READ;

            return (dwAccess == dwAccessType ? 
                    HANDLE_FIXED_NEW_HANDLE_RETURNED : 
                    HANDLE_FIXED_NEW_HANDLE_RETURNED_ACCESS_CHANGED);
        }
    }
     
    // Error no printers were found using the specifed server handle.
    return HANDLE_NEEDS_FIXING_NO_PRINTERS_FOUND;
}


PVOID
FormsInit(
    IN LPCTSTR  pszServerName,
    IN HANDLE   hPrintServer,
    IN BOOL     bAdministrator,
    IN LPCTSTR  pszComputerName
    )
{
    FORMS_DLG_DATA *pFormsDlgData = (FORMS_DLG_DATA *)AllocMem(sizeof(*pFormsDlgData));

    if( pFormsDlgData )
    {
        // initialize the forms dialog data here.
        ZeroMemory(pFormsDlgData, sizeof(*pFormsDlgData));

        // set the forms dialog data.
        pFormsDlgData->pServerName    = (LPTSTR)pszServerName;
        pFormsDlgData->AccessGranted  = bAdministrator;
        pFormsDlgData->hPrinter       = hPrintServer;
        pFormsDlgData->bNeedClose     = FALSE;
        pFormsDlgData->pszComputerName= pszComputerName;  

        // get the current metric setting.
        pFormsDlgData->uMetricMeasurement = !((BOOL)GetProfileInt(TEXT( "intl" ), TEXT("iMeasure"), 0));

        // get decimal point setting.
        GetProfileString(TEXT( "intl" ), TEXT( "sDecimal" ), TEXT( "." ), 
            pFormsDlgData->szDecimalPoint, ARRAYSIZE(pFormsDlgData->szDecimalPoint));

        // if this machine does not suport using a server handle to 
        // administer forms, we need to attempt to acquire a printer handle
        // for the specified access and then remember to close the handle when this
        // dialog terminates.
        HANDLE hPrinter;
        UINT Status = sFormsFixServerHandle(pFormsDlgData->hPrinter, pszServerName, bAdministrator, &hPrinter);

        // there are three cases which can occurr.
        switch( Status )
        {
            case HANDLE_FIXED_NEW_HANDLE_RETURNED:
                pFormsDlgData->hPrinter     = hPrinter;
                pFormsDlgData->bNeedClose   = TRUE;
                break;

            case HANDLE_NEEDS_FIXING_NO_PRINTERS_FOUND:
                pFormsDlgData->hPrinter         = NULL;
                pFormsDlgData->AccessGranted    = FALSE;
                break;

            case HANDLE_FIXED_NEW_HANDLE_RETURNED_ACCESS_CHANGED:
                pFormsDlgData->hPrinter         = hPrinter;
                pFormsDlgData->bNeedClose       = TRUE;
                pFormsDlgData->AccessGranted    = !pFormsDlgData->AccessGranted;
                break;

            case HANDLE_FIX_NOT_NEEDED:
                break;

            default:
                DBGMSG( DBG_TRACE, ( "Un handled case value HANDLE_FIX.\n" ) );
                break;
        }
    }

    return pFormsDlgData;
}

VOID
FormsFini( 
    PVOID p
    )
{
    // Get pointer to forms data.
    FORMS_DLG_DATA *pFormsDlgData = (FORMS_DLG_DATA *)p;

    // Validate forms data pointer
    if( pFormsDlgData )
    {
        // If printer opened ok, then we must close it.
        if( pFormsDlgData->bNeedClose && pFormsDlgData->hPrinter )
        {
            ClosePrinter( pFormsDlgData->hPrinter );
        }

        // Release the forms enumeration.
        FreeMem(pFormsDlgData->pFormInfo);
        
        // Release the forms data
        FreeMem(pFormsDlgData);
    }
}

BOOL APIENTRY
FormsDlg(
   HWND   hwnd,
   UINT   msg,
   WPARAM wparam,
   LPARAM lparam
   )
{
    // clear the last error each time message is about to be 
    // handled
    PFORMS_DLG_DATA pFormsDlgData = 
        (WM_INITDIALOG == msg ? (PFORMS_DLG_DATA)lparam : 
        (PFORMS_DLG_DATA)GetWindowLongPtr(hwnd, GWLP_USERDATA));

    if( pFormsDlgData )
    {
        pFormsDlgData->dwLastError = ERROR_SUCCESS;
    }

    // switch madness
    switch(msg) 
    {
    case WM_INITDIALOG:
        return FormsInitDialog(hwnd, pFormsDlgData);

    case WM_COMMAND:
        switch( LOWORD( wparam ) )
        {
        case IDD_FM_PB_SAVEFORM:
            return FormsCommandAddForm(hwnd);

        case IDD_FM_PB_DELFORM:
            return FormsCommandDelForm(hwnd);

        case IDD_FM_LB_FORMS:
            switch (HIWORD(wparam)) 
            {
            case LBN_SELCHANGE:
                return FormsCommandFormsSelChange(hwnd);
            }
            break;

        case IDD_FM_EF_NAME:
            return FormsCommandNameChange(hwnd, wparam, lparam );

        case IDD_FM_RB_METRIC:
        case IDD_FM_RB_ENGLISH:
            return FormsCommandUnits(hwnd);

        case IDD_FM_CK_NEW_FORM:
            return FormsNewForms(hwnd);
        }
    }

    return FALSE;
}


LPTSTR
AllocStr(
    LPCTSTR  pszStr
    )
{
    if( pszStr && *pszStr )
    {
        LPTSTR  pszRet = (LPTSTR)AllocMem((lstrlen(pszStr) + 1) * sizeof(*pszRet));

        if( pszRet )
        {
            lstrcpy(pszRet, pszStr);
            return pszRet;
        }
    }
    return NULL;
}


VOID
FreeStr(
    LPTSTR pszStr
    )
{
    if( pszStr )
    {
        FreeMem((PVOID)pszStr); 
    }
}


/* Grey Text
 *
 * If the window has an ID of -1, grey it.
 */
BOOL CALLBACK GreyText( HWND hwnd, LPARAM lParam )
{
    UNREFERENCED_PARAMETER( lParam );

    if( GetDlgCtrlID(hwnd) == (int)(USHORT)-1 )
    {
        EnableWindow(hwnd, FALSE);
    }

    return TRUE;
}




/* Macro: FORMSDIFFER
 *
 * Used to determine whether two forms have any differences between them.
 * The Names of the respective forms are not checked.
 */
#define FORMSDIFFER( pFormInfoA, pFormInfoB )      \
    ( memcmp( &(pFormInfoA)->Size, &(pFormInfoB)->Size, sizeof (pFormInfoA)->Size )  \
    ||memcmp( &(pFormInfoA)->ImageableArea, &(pFormInfoB)->ImageableArea,            \
              sizeof (pFormInfoA)->ImageableArea ) )

/*
 *  Initalize the forms dialog fields.
 */
BOOL FormsInitDialog(HWND hwnd, PFORMS_DLG_DATA pFormsDlgData)
{
    DWORD i;

    // Get forms dialog data.
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pFormsDlgData);

    // Set the foms name limit text.
    SendDlgItemMessage(hwnd, IDD_FM_EF_NAME, EM_LIMITTEXT, FORMS_NAME_MAX, 0L);

    for( i = 0; pEntryFields[i]; i++ )
    {
        SendDlgItemMessage(hwnd, pEntryFields[i], EM_LIMITTEXT, FORMS_PARAM_MAX-1, 0L);
    }

    HWND hWndName;
    hWndName = GetDlgItem( hwnd, IDD_FM_EF_NAME );
	::SetWindowLong(hWndName, GWL_STYLE, ::GetWindowLong(hWndName, GWL_STYLE) | WS_CLIPSIBLINGS);
    hWndName = GetDlgItem( hwnd, IDD_FM_DESC_GBOX );
	::SetWindowLong(hWndName, GWL_STYLE, ::GetWindowLong(hWndName, GWL_STYLE) | WS_CLIPSIBLINGS);

    // Set the forms title name.
    SetFormsComputerName(hwnd, pFormsDlgData);

    // Read the forms data 
    InitializeFormsData(hwnd, pFormsDlgData, FALSE);

    // Set up the units default based on the current international setting:
    pFormsDlgData->Units = pFormsDlgData->uMetricMeasurement;
    SETUNITS(hwnd, pFormsDlgData->Units);

    if( pFormsDlgData->cForms > 0 ) 
    {
        SetFormDescription(hwnd, &pFormsDlgData->pFormInfo[0], pFormsDlgData->Units);
        SendDlgItemMessage(hwnd, IDD_FM_LB_FORMS, LB_SETCURSEL, 0, 0L);
    }

    EnableWindow(GetDlgItem( hwnd, IDD_FM_EF_NAME ), FALSE);
    EnableWindow(GetDlgItem( hwnd, IDC_FORMNAME_LABEL ), FALSE);
    EnableWindow(GetDlgItem( hwnd, IDD_FM_TX_NEW_FORM ), FALSE);
    EnableWindow(GetDlgItem( hwnd, IDD_FM_PB_SAVEFORM ), FALSE);
    EnableWindow(GetDlgItem( hwnd, IDD_FM_TX_FORMS_DESC ), TRUE);
    
    if( FALSE == pFormsDlgData->AccessGranted )
    {
        EnableWindow(GetDlgItem(hwnd, IDD_FM_CK_NEW_FORM),  FALSE);
        EnableWindow(GetDlgItem(hwnd, IDD_FM_TX_WIDTH),     FALSE);
        EnableWindow(GetDlgItem(hwnd, IDD_FM_TX_HEIGHT),    FALSE);
        EnableWindow(GetDlgItem(hwnd, IDD_FM_TX_LEFT),      FALSE);
        EnableWindow(GetDlgItem(hwnd, IDD_FM_TX_RIGHT),     FALSE);
        EnableWindow(GetDlgItem(hwnd, IDD_FM_TX_TOP),       FALSE);
        EnableWindow(GetDlgItem(hwnd, IDD_FM_TX_BOTTOM),    FALSE);

        // Handle is invalid disable all controls and set error text.
        if( !pFormsDlgData->hPrinter )
        {
            EnableWindow(GetDlgItem(hwnd, IDD_FM_RB_METRIC),     FALSE);
            EnableWindow(GetDlgItem(hwnd, IDD_FM_RB_ENGLISH),    FALSE);
            EnableWindow(GetDlgItem(hwnd, IDD_FM_RB_ENGLISH),    FALSE);
            SetDlgItemTextFromResID(hwnd, IDC_SERVER_NAME, IDS_SERVER_NO_PRINTER_DEFINED);
        }
    }

    // Enable/Disable the dialog controls here
    EnableDialogFields(hwnd, pFormsDlgData);
    return FALSE; 
}

/*
 *
 */
BOOL FormsCommandAddForm(HWND hwnd)
{
    PFORMS_DLG_DATA pFormsDlgData;
    INT             PrevSel;
    FORM_INFO_1     NewFormInfo;
    INT             i = -1;

    //
    // If the save form button is disable nothing to do.  This
    // Check is needed for handling the apply button or ok 
    // event in a property sheet.
    //
    if( !IsWindowEnabled(GetDlgItem(hwnd, IDD_FM_PB_SAVEFORM)) )
    {
        return TRUE;
    }

    ZeroMemory(&NewFormInfo, sizeof(NewFormInfo));
    pFormsDlgData = (PFORMS_DLG_DATA)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    NewFormInfo.pName = GetFormName(hwnd);
    if( !NewFormInfo.pName )
    {
        //
        // Out of memory.
        //
        iMessage( hwnd,
                  IDS_ERR_FORMS_TITLE,
                  IDS_ERR_GENERIC,
                  MB_OK|MB_ICONSTOP,
                  ERROR_OUTOFMEMORY,
                  NULL );

        // save the last error, so the property sheet won't close
        pFormsDlgData->dwLastError = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // Check if we are to save and existing form.
    //
    if( !Button_GetCheck(GetDlgItem(hwnd, IDD_FM_CK_NEW_FORM)) )
    {
        //
        // Check if the form is currently in the list.
        //
        i = GetFormIndex(NewFormInfo.pName, pFormsDlgData->pFormInfo, pFormsDlgData->cForms); 

        if( i >= 0 )
        {
            //
            // Preserve the old data.
            //
            NewFormInfo.Flags = pFormsDlgData->pFormInfo[i].Flags;
            NewFormInfo.Size = pFormsDlgData->pFormInfo[i].Size;
            NewFormInfo.ImageableArea = pFormsDlgData->pFormInfo[i].ImageableArea;
        }
    }

    //
    // Get the form data from the controls & validate it.
    //
    UINT uIDFailed;
    if( !GetFormDescription(hwnd, &NewFormInfo, pFormsDlgData->Units, &uIDFailed) )
    {
        SetFocus(GetDlgItem(hwnd, uIDFailed));
        SendMessage(GetDlgItem(hwnd, uIDFailed), EM_SETSEL, 0, -1);

        //
        // Form validation failed. Set the focus info the correct control.
        //
        iMessage( hwnd,
                  IDS_ERR_FORMS_TITLE,
                  IDS_FORMS_INVALIDNUMBER,
                  MB_OK|MB_ICONSTOP,
                  kMsgNone,
                  NULL );

        // save the last error, so the property sheet won't close
        pFormsDlgData->dwLastError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Check if we are to save and existing form.
    //
    if( i >= 0 && FORMSDIFFER(&pFormsDlgData->pFormInfo[i], &NewFormInfo) )
    {
        //
        // Call spooler to set the form data.
        //
        if( !SetForm(pFormsDlgData->hPrinter, NewFormInfo.pName, 1, (LPBYTE)&NewFormInfo) )
        {
            //
            // Display error message.
            //
            iMessage( hwnd,
                      IDS_ERR_FORMS_TITLE,
                      IDS_ERR_FORMS_COULDNOTSETFORM,
                      MB_OK|MB_ICONSTOP,
                      kMsgGetLastError,
                      NULL,
                      NewFormInfo.pName );

            // save the last error, so the property sheet won't close
            pFormsDlgData->dwLastError = GetLastError();
        }
        else 
        {
            //
            // Insure we maintain the previous selection state.
            //
            i = ListBox_GetCurSel(GetDlgItem( hwnd, IDD_FM_LB_FORMS));
            InitializeFormsData(hwnd, pFormsDlgData, TRUE);
            ListBox_SetCurSel(GetDlgItem(hwnd, IDD_FM_LB_FORMS), i);

            //
            // Update controls.
            //
            SetFormDescription(hwnd, &NewFormInfo, pFormsDlgData->Units);

            FormChanged(pFormsDlgData); // notify whoever cares
        }
        goto Cleanup;
    }

    if( i < 0 && Button_GetCheck(GetDlgItem(hwnd, IDD_FM_CK_NEW_FORM)) )
    {
        //
        // Add form case.
        //
        if( (PrevSel = ListBox_GetCurSel(GetDlgItem(hwnd, IDD_FM_LB_FORMS))) < 0 )
        {
            PrevSel = 0;
        }

        //
        // Check if the new form name is not currently used.
        //
        LRESULT Status;
        Status = SendDlgItemMessage(hwnd, 
                                    IDD_FM_LB_FORMS,
                                    LB_FINDSTRINGEXACT,
                                    (WPARAM)-1,
                                    (LPARAM)NewFormInfo.pName );

        //
        // If string was found.
        //
        if( Status != LB_ERR )
        {
            iMessage( hwnd,
                      IDS_ERR_FORMS_TITLE,
                      IDS_ERR_FORMS_NAMECONFLICT,
                      MB_OK|MB_ICONEXCLAMATION,
                      kMsgNone,
                      NULL );

            // save the last error, so the property sheet won't close
            pFormsDlgData->dwLastError = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        if( AddForm(pFormsDlgData->hPrinter, 1, (LPBYTE)&NewFormInfo) )
        {
            InitializeFormsData(hwnd, pFormsDlgData, TRUE);

            // highlight the one we just added:
            i = GetFormIndex(NewFormInfo.pName, pFormsDlgData->pFormInfo, pFormsDlgData->cForms);

            // if we can't find it, restore the previous selection.
            // (This assumes that the last EnumForms returned the same buffer
            // as we had last time.)
            if( i < 0 )
            {
                i = (pFormsDlgData->cForms > (DWORD)PrevSel) ? PrevSel : 0;
            }

            if( pFormsDlgData->cForms > 0 )
            {
                SetFormDescription(hwnd, &pFormsDlgData->pFormInfo[i], pFormsDlgData->Units);
                SendDlgItemMessage(hwnd, IDD_FM_LB_FORMS, LB_SETCURSEL, i, 0L);
            }

            // the Add button is about to be greyed, it currently
            // has focus therefore we will shift the focus to the
            // edit box.
            SetFocus(GetDlgItem(hwnd, IDD_FM_EF_NAME));

            FormChanged(pFormsDlgData); // notify whoever cares
        } 
        else 
        {
            iMessage( hwnd,
                      IDS_ERR_FORMS_TITLE,
                      IDS_ERR_FORMS_COULDNOTADDFORM,
                      MB_OK|MB_ICONSTOP,
                      kMsgGetLastError,
                      NULL,
                      NewFormInfo.pName );

            // save the last error, so the property sheet won't close
            pFormsDlgData->dwLastError = GetLastError();
        }
    }

Cleanup:
    
    if( NewFormInfo.pName )
    {
        FreeStr(NewFormInfo.pName);
    }

    EnableDialogFields(hwnd, pFormsDlgData);
    return TRUE;
}


/*
 *
 */
BOOL FormsCommandDelForm(HWND hwnd)
{
    PFORMS_DLG_DATA pFormsDlgData;
    DWORD           i;
    DWORD           TopIndex;
    DWORD           Count;
    LPTSTR          pFormName;

    pFormsDlgData = (PFORMS_DLG_DATA)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(pFormsDlgData);

    i = ListBox_GetCurSel(GetDlgItem(hwnd, IDD_FM_LB_FORMS));
    TopIndex = (DWORD)SendDlgItemMessage(hwnd, IDD_FM_LB_FORMS, LB_GETTOPINDEX, 0, 0L);
    pFormName = GetFormName(hwnd);

    if( DeleteForm(pFormsDlgData->hPrinter, pFormName) )
    {
        InitializeFormsData(hwnd, pFormsDlgData, TRUE);
        Count = (DWORD)SendDlgItemMessage(hwnd, IDD_FM_LB_FORMS, LB_GETCOUNT, 0, 0L);

        if( i >= Count )
        {
            i = ( Count-1 );
        }

        if( pFormsDlgData->cForms > 0 )
        {
            SetFormDescription(hwnd, &pFormsDlgData->pFormInfo[i], pFormsDlgData->Units);
            SendDlgItemMessage(hwnd, IDD_FM_LB_FORMS, LB_SETCURSEL, i, 0L);
            SendDlgItemMessage(hwnd, IDD_FM_LB_FORMS, LB_SETTOPINDEX, TopIndex, 0L);
            PostMessage(hwnd, WM_NEXTDLGCTL, (WPARAM )GetDlgItem(hwnd, IDD_FM_LB_FORMS), (LPARAM )TRUE);
        }

        FormChanged(pFormsDlgData); // notify whoever cares
    }
    else
    {
        iMessage( hwnd,
                  IDS_ERR_FORMS_TITLE,
                  IDS_ERR_FORMS_COULDNOTDELETEFORM,
                  MB_OK|MB_ICONSTOP,
                  kMsgGetLastError,
                  NULL,
                  pFormName );
    }

    if( pFormName )
    {
        FreeStr(pFormName);
    }

    EnableDialogFields( hwnd, pFormsDlgData );
    return TRUE;
}



/*
 *
 */
BOOL FormsCommandFormsSelChange(HWND hwnd)
{
    PFORMS_DLG_DATA pFormsDlgData;
    DWORD           i;

    pFormsDlgData = (PFORMS_DLG_DATA)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    i = ListBox_GetCurSel(GetDlgItem(hwnd, IDD_FM_LB_FORMS));
    SetFormDescription(hwnd, &pFormsDlgData->pFormInfo[i], pFormsDlgData->Units);
    EnableDialogFields(hwnd, pFormsDlgData);

    return TRUE;
}


/*
 * User change the units of the currently selected form.
 */
BOOL FormsCommandUnits(HWND hwnd)
{
    PFORMS_DLG_DATA pFormsDlgData;
    INT             i;
    FORM_INFO_1     FormInfo;

    //
    // Get dialog data.
    //
    pFormsDlgData = (PFORMS_DLG_DATA)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ZeroMemory(&FormInfo, sizeof(FormInfo));

    if( pFormsDlgData->Units == GETUNITS(hwnd) )
        goto Cleanup;


    FormInfo.pName = GetFormName(hwnd);

    if( !FormInfo.pName )
    {
        //
        // Out of memory.
        //
        iMessage( hwnd,
                  IDS_ERR_FORMS_TITLE,
                  IDS_ERR_GENERIC,
                  MB_OK|MB_ICONSTOP,
                  ERROR_OUTOFMEMORY,
                  NULL );

        goto Cleanup;
    }

    //
    // Check if the form is currently in the list.
    //
    i = GetFormIndex(FormInfo.pName, pFormsDlgData->pFormInfo, pFormsDlgData->cForms); 

    if( i >= 0 )
    {
        //
        // Preserve the old data.
        //
        FormInfo.Flags = pFormsDlgData->pFormInfo[i].Flags;
        FormInfo.Size = pFormsDlgData->pFormInfo[i].Size;
        FormInfo.ImageableArea = pFormsDlgData->pFormInfo[i].ImageableArea;
    }

    //
    // Get the forms description.
    //
    UINT uIDFailed;
    if( GetFormDescription(hwnd, &FormInfo, pFormsDlgData->Units, &uIDFailed) )
    {
        //
        // Get and save the currently selected units.
        //
        pFormsDlgData->Units = GETUNITS(hwnd);

        //
        // Set the forms values.
        //
        SetValue(hwnd, IDD_FM_EF_WIDTH,  FormInfo.Size.cx,                                 pFormsDlgData->Units);
        SetValue(hwnd, IDD_FM_EF_HEIGHT, FormInfo.Size.cy,                                 pFormsDlgData->Units);
        SetValue(hwnd, IDD_FM_EF_LEFT,   FormInfo.ImageableArea.left,                      pFormsDlgData->Units);
        SetValue(hwnd, IDD_FM_EF_RIGHT,  FormInfo.Size.cx - FormInfo.ImageableArea.right,  pFormsDlgData->Units);
        SetValue(hwnd, IDD_FM_EF_TOP,    FormInfo.ImageableArea.top,                       pFormsDlgData->Units);
        SetValue(hwnd, IDD_FM_EF_BOTTOM, FormInfo.Size.cy - FormInfo.ImageableArea.bottom, pFormsDlgData->Units);
    }
    else
    {
        SETUNITS(hwnd, pFormsDlgData->Units);
        SetFocus(GetDlgItem(hwnd, uIDFailed));
        SendMessage(GetDlgItem(hwnd, uIDFailed), EM_SETSEL, 0, -1);

        //
        // Form validation failed. Set the focus info the correct control.
        //
        iMessage( hwnd,
                  IDS_ERR_FORMS_TITLE,
                  IDS_FORMS_INVALIDNUMBER,
                  MB_OK|MB_ICONSTOP,
                  kMsgNone,
                  NULL );
    }

Cleanup:
    
    if( FormInfo.pName )
    {
        FreeStr(FormInfo.pName);
    }

    return TRUE;
}


/*
 *
 */
VOID InitializeFormsData(HWND hwnd, PFORMS_DLG_DATA pFormsDlgData, BOOL ResetList)
{
    LPFORM_INFO_1 pFormInfo;
    DWORD         cForms;
    DWORD         i;

    if( ResetList )
    {
        if( pFormsDlgData->pFormInfo )
        {
            FreeMem(pFormsDlgData->pFormInfo);
        }
    }

    pFormInfo = GetFormsList(pFormsDlgData->hPrinter, &cForms);

    if( !pFormInfo )
    {
        DBGMSG( DBG_WARNING, ( "GetFormsList failed.\n") ); 
        pFormsDlgData->pFormInfo = NULL;
        pFormsDlgData->cForms    = 0;
        return;
    }

    pFormsDlgData->pFormInfo = pFormInfo;
    pFormsDlgData->cForms    = cForms;

    if( ResetList )
    {
        ListBox_ResetContent(GetDlgItem( hwnd, IDD_FM_LB_FORMS));
    }

    for( i = 0; i < cForms; i++ )
    {
        SendDlgItemMessage( 
            hwnd, 
            IDD_FM_LB_FORMS, 
            LB_INSERTSTRING,
            (WPARAM)-1, 
            (LPARAM)(LPTSTR)pFormInfo[i].pName
            );
    }
}

/* GetFormsList
 *
 * This function works in exactly the same way as GetPortsList.
 * There's a good case for writing a generic EnumerateObject function
 * (Done!)
 */
LPFORM_INFO_1 GetFormsList(HANDLE hPrinter, PDWORD pNumberOfForms)
{
    PFORM_INFO_1 pFormInfo = NULL;

    TStatusB bStatus;
    bStatus DBGCHK = bEnumForms(hPrinter, 1, (PBYTE *)&pFormInfo, pNumberOfForms);

    if( bStatus && pFormInfo )
    { 
        //
        // Sort the forms list.
        //
        qsort((PVOID )pFormInfo, (UINT)*pNumberOfForms, sizeof(*pFormInfo), CompareFormNames);
    }

    return pFormInfo;
}


/*
 * CompareFormNames
 */
int _cdecl CompareFormNames( const void *p1, const void *p2 )
{
    return lstrcmpi( ( (PFORM_INFO_1)p1 )->pName,
                    ( (PFORM_INFO_1)p2 )->pName );
}

/*
 * SetFormsComputerName
 */
VOID SetFormsComputerName( HWND hwnd, PFORMS_DLG_DATA pFormsDlgData )
{
    //
    // Set the title to the name of this machine.
    //
    SetDlgItemText( hwnd, IDC_SERVER_NAME, pFormsDlgData->pszComputerName );

}


/*
 * SetFormDescription
 */
VOID SetFormDescription( HWND hwnd, LPFORM_INFO_1 pFormInfo, BOOL Units )
{

    SetDlgItemText( hwnd, IDD_FM_EF_NAME, pFormInfo->pName );

    SetValue( hwnd, IDD_FM_EF_WIDTH,  pFormInfo->Size.cx, Units );
    SetValue( hwnd, IDD_FM_EF_HEIGHT, pFormInfo->Size.cy, Units );

    SetValue( hwnd, IDD_FM_EF_LEFT,   pFormInfo->ImageableArea.left, Units );
    SetValue( hwnd, IDD_FM_EF_RIGHT,  ( pFormInfo->Size.cx -
                                        pFormInfo->ImageableArea.right ), Units );
    SetValue( hwnd, IDD_FM_EF_TOP,    pFormInfo->ImageableArea.top, Units );
    SetValue( hwnd, IDD_FM_EF_BOTTOM, ( pFormInfo->Size.cy -
                                        pFormInfo->ImageableArea.bottom ), Units );
}


/*
 * GetFormDescription
 */
BOOL 
GetFormDescription( 
    IN  HWND            hwnd, 
    OUT LPFORM_INFO_1   pFormInfo,
    IN  BOOL            bDefaultMetric,
    OUT PUINT           puIDFailed
    )
{
    BOOL bReturn = FALSE;
    FORM_INFO_1 info;

    LONG lRight = pFormInfo->Size.cx - pFormInfo->ImageableArea.right;
    LONG lBottom = pFormInfo->Size.cy - pFormInfo->ImageableArea.bottom;

    *puIDFailed = 

            !GetValue(hwnd, IDD_FM_EF_WIDTH, pFormInfo->Size.cx, 
                bDefaultMetric, &info.Size.cx) ? IDD_FM_EF_WIDTH :

            !GetValue(hwnd, IDD_FM_EF_HEIGHT, pFormInfo->Size.cy, 
                bDefaultMetric, &info.Size.cy) ? IDD_FM_EF_HEIGHT :

            !GetValue(hwnd, IDD_FM_EF_LEFT, pFormInfo->ImageableArea.left, 
                bDefaultMetric, &info.ImageableArea.left) ? IDD_FM_EF_LEFT :

            !GetValue(hwnd, IDD_FM_EF_TOP, pFormInfo->ImageableArea.top, 
                bDefaultMetric, &info.ImageableArea.top) ? IDD_FM_EF_TOP :

            !GetValue(hwnd, IDD_FM_EF_RIGHT, lRight, 
                bDefaultMetric, &lRight) ? IDD_FM_EF_RIGHT :

            !GetValue(hwnd, IDD_FM_EF_BOTTOM, lBottom, 
                bDefaultMetric, &lBottom) ? IDD_FM_EF_BOTTOM :

            0;

    // validate top, left, rigt & bottom of the ImageableArea.
    if( 0 == *puIDFailed && info.ImageableArea.left >= info.Size.cx )
    {
        *puIDFailed = IDD_FM_EF_LEFT;
    }

    if( 0 == *puIDFailed && info.ImageableArea.top >= info.Size.cy )
    {
        *puIDFailed = IDD_FM_EF_TOP;
    }

    info.ImageableArea.right  = info.Size.cx - lRight;
    if( 0 == *puIDFailed && info.ImageableArea.right <= info.ImageableArea.left )
    {
        *puIDFailed = IDD_FM_EF_RIGHT;
    }

    info.ImageableArea.bottom = info.Size.cy - lBottom;
    if( 0 == *puIDFailed && info.ImageableArea.bottom <= info.ImageableArea.top )
    {
        *puIDFailed = IDD_FM_EF_BOTTOM;
    }

    if( 0 == *puIDFailed )
    {
        pFormInfo->Size = info.Size;
        pFormInfo->ImageableArea = info.ImageableArea;
        bReturn = TRUE;
    }

    return bReturn;
}


/* GetFormIndex
 *
 * Searches an array of FORM_INFO structures for one with name pFormName.
 *
 * Return:
 *
 *     The index of the form found, or -1 if the form is not found.
 */
int GetFormIndex( LPTSTR pFormName, LPFORM_INFO_1 pFormInfo, DWORD cForms )
{
    int  i = 0;
    BOOL Found = FALSE;

    while( i < (int)cForms && !( Found = !lstrcmpi( pFormInfo[i].pName, pFormName ) ) )
        i++;

    if( Found )
        return i;
    else
        return -1;
}


/* GetFormName
 *
 * Returns a pointer to a newly allocated string containing the form name,
 * stripped of leading and trailing blanks.
 * Caller must remember to free up the string.
 *
 */
LPTSTR GetFormName( HWND hwnd )
{
    TCHAR  FormName[FORMS_NAME_MAX+1];
    INT    i = 0;
    PTCHAR pFormNameWithBlanksStripped;
    PTCHAR pReturnFormName = NULL;

    if( GetDlgItemText( hwnd, IDD_FM_EF_NAME, FormName, COUNTOF( FormName ) ) > 0 )
    {
        /* Step over any blank characters at the beginning:
         */
        while( FormName[i] && ( FormName[i] == TEXT(' ') ) )
            i++;

        if( FormName[i] )
        {
            pFormNameWithBlanksStripped = &FormName[i];

            /* Find the NULL terminator:
             */
            while( FormName[i] )
                i++;

            /* Now step back to find the last character that isn't a blank:
             */
            if( i > 0 )
                i--;

            while( ( i > 0 ) && ( FormName[i] == TEXT( ' ' ) ) )
                i--;

            FormName[i+1] = TEXT( '\0' );

            if( *pFormNameWithBlanksStripped )
                pReturnFormName = AllocStr( pFormNameWithBlanksStripped );
        }
        /* Otherwise, the name contains nothing but blanks. */
    }

    return pReturnFormName;
}

/*
 * SetValue
 */
BOOL 
SetValue( 
    HWND hwnd, 
    DWORD uID, 
    LONG lValueInPoint001mm, 
    BOOL bMetric 
    )
{
    PFORMS_DLG_DATA pFormsDlgData = (PFORMS_DLG_DATA)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(pFormsDlgData);

    TCHAR szValue[FORMS_PARAM_MAX];
    BOOL bReturn = Value2String(pFormsDlgData, lValueInPoint001mm, bMetric, TRUE,
        ARRAYSIZE(szValue), szValue);

    if( bReturn )
    {
        bReturn = SetDlgItemText(hwnd, uID, szValue);
    }

    return bReturn;
}

/*
 * GetValue
 */
BOOL 
GetValue(
    HWND hwnd, 
    DWORD uID, 
    LONG lCurrentValueInPoint001mm, 
    BOOL bDefaultMetric, 
    PLONG plValueInPoint001mm
    )
{
    TCHAR  szValue[FORMS_PARAM_MAX];
    szValue[0] = 0;
    GetDlgItemText(hwnd, uID, szValue, ARRAYSIZE(szValue));

    PFORMS_DLG_DATA pFormsDlgData = (PFORMS_DLG_DATA)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    return String2Value(pFormsDlgData, szValue, bDefaultMetric, lCurrentValueInPoint001mm, plValueInPoint001mm);
}

/*
 * SetDlgItemTextFromResID
 */
VOID SetDlgItemTextFromResID(HWND hwnd, int idCtl, int idRes)
{
    TCHAR string[kStrMax];
    LoadString(ghInst, idRes, string, ARRAYSIZE(string));
    SetDlgItemText(hwnd, idCtl, string);
}


/*
 *
 */
VOID EnableDialogFields( HWND hwnd, PFORMS_DLG_DATA pFormsDlgData )
{
    INT   i;
    BOOL  EnableEntryFields = TRUE;
    BOOL  EnableAddButton = TRUE;
    BOOL  EnableDeleteButton = TRUE;
    LPTSTR pFormName;

    // if new form check keep edit fields enabled.
    if( Button_GetCheck(GetDlgItem(hwnd, IDD_FM_CK_NEW_FORM)) )
    {
        vFormsEnableEditFields(hwnd, TRUE);
        return;
    }

    // if not granted all access access.
    if( FALSE == pFormsDlgData->AccessGranted == TRUE )
    {
        EnableWindow(GetDlgItem(hwnd, IDD_FM_EF_NAME), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_FORMNAME_LABEL), FALSE);
        EnableEntryFields = FALSE;
        EnableAddButton = FALSE;
        EnableDeleteButton = FALSE;

        EnumChildWindows(hwnd, GreyText, 0);
    }
    /* else - See whether the Form Name is new:
     */
    else if( ( pFormName = GetFormName(hwnd) ) != NULL )
    {
        /* Now see if the name is already in the list:
         */
        i = GetFormIndex( pFormName, pFormsDlgData->pFormInfo,
                          pFormsDlgData->cForms );

        if( i >= 0 )  
        {
            /* Can't modify a built-in form:
             */
            if( pFormsDlgData->pFormInfo[i].Flags & FORM_BUILTIN )
            {
                EnableEntryFields = FALSE;
                EnableDeleteButton = FALSE;
            }
            else
            {
                EnableEntryFields = TRUE;
                EnableDeleteButton = TRUE;
            }

            /* Can't add a form with the same name:
             */
            EnableAddButton = FALSE;
        }
        else
        {
            EnableDeleteButton = FALSE;
        }

        FreeStr(pFormName);
    }
    else
    {
        /* Name field is blank: Can't add or delete:
         */
        EnableAddButton = FALSE;
        EnableDeleteButton = FALSE;
    }

    // enable the edit fields.
    vFormsEnableEditFields( hwnd, EnableEntryFields );

    // enable the delete button
    EnableWindow( GetDlgItem( hwnd, IDD_FM_PB_DELFORM ), EnableDeleteButton );

    // enable the save form button
    EnableWindow( GetDlgItem( hwnd, IDD_FM_PB_SAVEFORM ), EnableEntryFields );

}


/*++

Routine Name:

    bEnumForms

Routine Description:

    Enumerates the forms on the printer identified by handle.
    
Arguments:

    IN HANDLE   hPrinter,
    IN DWORD    dwLevel,
    IN PBYTE   *ppBuff,
    IN PDWORD   pcReturned

Return Value:

    Pointer to forms array and count of forms in the array if
    success, NULL ponter and zero number of forms if failure.
    TRUE if success, FALSE if error.

--*/
BOOL
bEnumForms( 
    IN HANDLE   hPrinter,
    IN DWORD    dwLevel,
    IN PBYTE   *ppBuff,
    IN PDWORD   pcReturned
    )
{
    BOOL            bReturn     = FALSE;
    DWORD           dwReturned  = 0;
    DWORD           dwNeeded    = 0;
    PBYTE           p           = NULL;
    TStatusB        bStatus( DBG_WARN, ERROR_INSUFFICIENT_BUFFER );

    // get buffer size for enum forms.
    bStatus DBGNOCHK = EnumForms(
                            hPrinter,
                            dwLevel,
                            NULL,
                            0,
                            &dwNeeded,
                            &dwReturned );

    // check if the function returned the buffer size.
    if( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) 
    {
        goto Cleanup;
    }

    // if buffer allocation fails.
    if( (p = (PBYTE)AllocMem(dwNeeded) ) == NULL )
    {
        goto Cleanup;
    }

    // get the forms enumeration
    bStatus DBGCHK = EnumForms(
                            hPrinter,
                            dwLevel,
                            p,
                            dwNeeded,
                            &dwNeeded,
                            &dwReturned );

    // copy back the buffer pointer and count.
    if( bStatus ) 
    {
        bReturn     = TRUE;
        *ppBuff     = p;
        *pcReturned = dwReturned;
    } 

Cleanup: 
           
    if( bReturn == FALSE )
    {
        // indicate failure.
        *ppBuff     = NULL;
        *pcReturned = 0;

        // release any allocated memory.
        if( p )
        {
            FreeMem(p);
        }
    }

    return bReturn;
}


/*
 * Checked new forms check box.
 */
BOOL 
FormsNewForms(
    IN HWND hWnd
    )
{
    // get Current check state.
    BOOL bState = Button_GetCheck(GetDlgItem(hWnd, IDD_FM_CK_NEW_FORM));

    // set the name edit field.
    EnableWindow(GetDlgItem(hWnd, IDD_FM_EF_NAME), bState);
    EnableWindow(GetDlgItem(hWnd, IDC_FORMNAME_LABEL), bState);

    // set the new form text state.
    EnableWindow(GetDlgItem(hWnd, IDD_FM_TX_NEW_FORM), bState);

    // if enabling new form then the delete button should be disabled.
    if( bState )
    {
        EnableWindow(GetDlgItem(hWnd, IDD_FM_PB_DELFORM), FALSE);
    }

    // Enable the edit fields.
    vFormsEnableEditFields(hWnd, bState);

    // if disabling new forms set edit fields based on
    // current selection.
    if( !bState )
    {
        FormsCommandFormsSelChange(hWnd);
    }

    return FALSE;
}

/*
 * vFormsEnableEditFields
 */
VOID
vFormsEnableEditFields(
    IN HWND hWnd,
    IN BOOL bState
    )
{
    UINT i;

    for( i = 0; pEntryFields[i]; i++ )
    {
        EnableWindow( GetDlgItem( hWnd, pEntryFields[i] ), bState );
    }

    for( i = 0; pTextFields[i]; i++ )
    {
        EnableWindow( GetDlgItem( hWnd, pTextFields[i] ), bState );
    }
}

//
// Enable the save form button when the name changes.
//
BOOL
FormsCommandNameChange(
    IN HWND     hWnd,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    BOOL bStatus;
    LPTSTR pFormName    = NULL;
    LRESULT Status         = TRUE;

    switch( GET_WM_COMMAND_CMD(wParam, lParam) ) 
    {
    case EN_CHANGE:

        // if the name edit box is not in the enabled state.
        if( !IsWindowEnabled((HWND)lParam) )
        {
            bStatus = FALSE;
            break;
        }

        // Get the form name from the edit control.
        pFormName = GetFormName(hWnd);

        // If a form name was returned.
        if( pFormName )
        {
            // If the name has length then 
            // check if it's in the list.
            if( lstrlen(pFormName) )
            {
                // Locate the form name in the list box.
                Status = SendDlgItemMessage(
                            hWnd, 
                            IDD_FM_LB_FORMS,
                            LB_FINDSTRINGEXACT,
                            (WPARAM)-1,
                            (LPARAM)pFormName);
            }

            // Insure we release the form name, since we have
            // adopted the nemory.
            if( pFormName )
            {
                FreeMem(pFormName);
            }
        }
         
        // Set the save form enable state.
        EnableWindow(GetDlgItem(hWnd, IDD_FM_PB_SAVEFORM), Status == LB_ERR ? TRUE : FALSE);
        bStatus = TRUE;
        break;

    default:
        bStatus = FALSE;
        break;
    }

    return bStatus;
}

BOOL 
String2Value(
    IN  PFORMS_DLG_DATA     pFormsDlgData,
    IN  LPCTSTR             pszValue,
    IN  BOOL                bDefaultMetric,
    IN  LONG                lCurrentValueInPoint001mm,
    OUT PLONG               plValueInPoint001mm
    )
{
    ASSERT(pFormsDlgData);
    ASSERT(pszValue);
    ASSERT(plValueInPoint001mm);

    double dValue = 0.0;
    *plValueInPoint001mm = 0;
    BOOL bMetric = bDefaultMetric;
    BOOL bResult = TRUE;

    if( *pszValue )
    {
        // make a copy of the input string
        TCHAR szValue[FORMS_PARAM_MAX];
        lstrcpyn(szValue, pszValue, ARRAYSIZE(szValue));

        // convert international decimal separator, if necessary:
        if( *pFormsDlgData->szDecimalPoint != TEXT('.') )
        {
            TCHAR *p = szValue;
            while( *p )
            {
                if( *p == *pFormsDlgData->szDecimalPoint )
                {
                    *p = TEXT('.');
                }
                p++;
            }
        }

        // convert to double, pGarbage should be "in" or "cm" (depends on metric)
        TCHAR *pGarbage = NULL;
        dValue = _tcstod(szValue, &pGarbage);
        ASSERT(pGarbage);

        // load the measurement strings from resource
        TCHAR szUnitsIn[CCH_MAX_UNITS];
        TCHAR szUnitsCm[CCH_MAX_UNITS];
        bResult = LoadString(ghInst, IDS_INCHES, szUnitsIn, ARRAYSIZE(szUnitsIn)) &&
                  LoadString(ghInst, IDS_CENTIMETERS, szUnitsCm, ARRAYSIZE(szUnitsCm));

        if( bResult )
        {
            // check to validate the converted number
            if( dValue < 0.0 )
            {
                // negative values are invalid
                bResult = FALSE;
            }
            else if( 0 == lstrcmpi(pGarbage, szUnitsIn) )
            {
                // enforce inches
                bMetric = FALSE;
            }
            else if( 0 == lstrcmpi(pGarbage, szUnitsCm) )
            {
                // enforce centimeters
                bMetric = TRUE;
            }
            else if( lstrlen(pGarbage) )
            {
                // pGarbage is neither "in" nor "cm" - error!
                bResult = FALSE;
            }
        }

        if( bResult )
        {
            TCHAR szCurrentValue[FORMS_PARAM_MAX];

            // cut the garbage first
            *pGarbage = 0;

            // if the converted number is valid, check to see if not the
            // same as the current one...
            if( bMetric == bDefaultMetric &&
                Value2String(pFormsDlgData, lCurrentValueInPoint001mm,
                    bDefaultMetric, FALSE, ARRAYSIZE(szCurrentValue), szCurrentValue) &&
                0 == lstrcmp(szCurrentValue, szValue) )
            {
                // it is the same. don't recalc, so we don't loose precision.
                *plValueInPoint001mm = lCurrentValueInPoint001mm;
            }
            else
            {
                // calculate in point001mm
                *plValueInPoint001mm = (DWORD)(dValue * (bMetric ? 100*100 : 254*100));
            }
        }
    }

    return bResult;
}

BOOL 
Value2String(
    IN  PFORMS_DLG_DATA     pFormsDlgData,
    IN  LONG                lValueInPoint001mm,
    IN  BOOL                bMetric,
    IN  BOOL                bAppendMetric,
    IN  UINT                cchMaxChars,
    OUT LPTSTR              szOutBuffer
    )
{
    ASSERT(pFormsDlgData);
    ASSERT(szOutBuffer);

    BOOL bReturn = FALSE;
    static const TCHAR szFormat[] = TEXT("%d%s%02d%s");
    static const TCHAR szFormat1[] = TEXT("%d%s%02d");

    TCHAR szUnits[CCH_MAX_UNITS];
    DWORD dwUnitsX100 = (DWORD)((lValueInPoint001mm / (bMetric ? 100.0 : 254.0)) + 0.5);
    if( LoadString(ghInst, bMetric ? IDS_CENTIMETERS: IDS_INCHES, szUnits, ARRAYSIZE(szUnits)) )
    {
        wnsprintf(szOutBuffer, cchMaxChars, bAppendMetric ? szFormat : szFormat1, 
            dwUnitsX100 / 100, pFormsDlgData->szDecimalPoint, dwUnitsX100 % 100, szUnits);
        bReturn = TRUE;
    }

    return bReturn;
}

VOID 
FormChanged(
    IN OUT  PFORMS_DLG_DATA pFormsDlgData
    )
{
    // if part of property sheet this will notify the UI to
    // call PSM_CANCELTOCLOSE
    pFormsDlgData->bFormChanged = TRUE;

}

BOOL
Forms_IsThereCommitedChanges(
    IN PVOID pFormsData
    )
{
    ASSERT(pFormsData);
    PFORMS_DLG_DATA pFormsDlgData = (PFORMS_DLG_DATA)pFormsData;
    return pFormsDlgData->bFormChanged;
}

DWORD
Forms_GetLastError(
    IN PVOID pFormsData
    )
{
    ASSERT(pFormsData);
    PFORMS_DLG_DATA pFormsDlgData = (PFORMS_DLG_DATA)pFormsData;
    return pFormsDlgData->dwLastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\genwin.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1998
All rights reserved.

Module Name:

    GenWin.cxx

Abstract:

    Generic window handler

Author:

    Albert Ting (AlbertT)  21-May-1994

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

/********************************************************************

    Generic window

********************************************************************/

MGenericWin::
MGenericWin(
    VOID
    )
{
}

MGenericWin::
~MGenericWin(
    VOID
    )
{
}

LRESULT
MGenericWin::
nHandleMessage(
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Handles wndproc processing before the dlg is setup, and after
    it has been torn down.

Arguments:

    Standard window parameters.

Return Value:

    LResult

--*/

{
    switch( uMsg ){
    case WM_DESTROY:
        break;

    default:
        return DefWindowProc( hwnd(), uMsg, wParam, lParam );
    }
    return 0;
}


LPARAM APIENTRY
MGenericWin::
SetupWndProc(
    IN HWND hwnd,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Setup the wndproc and initialize GWL_USERDATA.

Arguments:

    Standard wndproc parms.

Return Value:

--*/

{
    MGenericWin* pGenericWin;

    if( WM_NCCREATE == uMsg ){

        pGenericWin = (MGenericWin*)((LPCREATESTRUCT)lParam)->lpCreateParams;

        pGenericWin->_hwnd = hwnd;

        SetWindowLongPtr( hwnd,
                       GWLP_USERDATA,
                       (LONG_PTR)pGenericWin );

        SetWindowLongPtr( hwnd,
                       GWLP_WNDPROC,
                       (LONG_PTR)&MGenericWin::ThunkWndProc );

        return pGenericWin->nHandleMessage( uMsg,
                                            wParam,
                                            lParam );
    }

    return DefWindowProc( hwnd, uMsg, wParam, lParam );
}



LPARAM APIENTRY
MGenericWin::
ThunkWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Generic thunk from wndproc style parm passing to object passing.

Arguments:

    Standard wndproc parms.

Return Value:

--*/

{
    MGenericWin* pGenericWin;

    pGenericWin = (MGenericWin*)GetWindowLongPtr( hwnd, GWLP_USERDATA );

    if( WM_NCDESTROY == uMsg ){

        LRESULT lResult = pGenericWin->nHandleMessage( uMsg,
                                                       wParam,
                                                       lParam );

        SetWindowLongPtr( hwnd, GWLP_USERDATA, 0 );
        SetWindowLongPtr( hwnd, GWLP_WNDPROC, (LONG_PTR)&MGenericWin::SetupWndProc );

        return lResult;
    }

    SPLASSERT( pGenericWin );

    return pGenericWin->nHandleMessage( uMsg,
                                        wParam,
                                        lParam );
}

BOOL
MGenericWin::
bSetText(
    LPCTSTR pszTitle
    )
{
    return SetWindowText( _hwnd, pszTitle );
}

VOID
MGenericWin::
vForceCleanup(
    VOID
    )
{
    SetWindowLongPtr( _hwnd, GWLP_USERDATA, 0L );
}


/********************************************************************

    Property Sheet procs

********************************************************************/

MGenericProp::
MGenericProp(
    VOID
    )
{
}

MGenericProp::
~MGenericProp(
    VOID
    )
{
}

BOOL
MGenericProp::
bHandleMessage(
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Handles Propproc processing before the window is setup and after
    it is torn down.

Arguments:

    Standard window parameters.

Return Value:

    TRUE/FALSE

--*/

{
    UNREFERENCED_PARAMETER( uMsg );
    UNREFERENCED_PARAMETER( wParam );
    UNREFERENCED_PARAMETER( lParam );

    return FALSE;
}

BOOL
MGenericProp::
bCreate(
    VOID
    )
/*++

Routine Description:

    This function specifies an application-defined callback function that 
    a property sheet calls when a page is created and when it is about to 
    be destroyed. An application can use this function to perform 
    initialization and cleanup operations for the page.

    Called when a PSPCB_CREATE message is sent.
    
Arguments:

    None.

Return Value:
    
    A page is being created. Return nonzero to allow the page to 
    be created or zero to prevent it. 

--*/
{
    return TRUE;
}

VOID
MGenericProp::
vDestroy(
    VOID
    )
/*++

Routine Description:

    This function specifies an application-defined callback function that 
    a property sheet calls when a page is created and when it is about to 
    be destroyed. An application can use this function to perform 
    initialization and cleanup operations for the page.

    Called when a PSPCB_RELEASE message is sent.
    
Arguments:

    None.

Return Value:
    
    A page is being destroyed. The return value is ignored.

--*/
{
}

INT_PTR APIENTRY
MGenericProp::
SetupDlgProc(
    IN HWND hDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Setup the wndproc and initialize GWL_USERDATA.

Arguments:

    Standard wndproc parms.

Return Value:


History:

    Lazar Ivanov (LazarI) - Aug-2000 (redesign)


--*/

{
    BOOL bRet = FALSE;
    MGenericProp* pThis = NULL;

    if( WM_INITDIALOG == uMsg )
    {
        pThis = reinterpret_cast<MGenericProp*>(reinterpret_cast<LPPROPSHEETPAGE>(lParam)->lParam);
        if( pThis )
        {
            pThis->_hDlg = hDlg;
            SetWindowLongPtr(hDlg, DWLP_USER, reinterpret_cast<LONG_PTR>(pThis));
            bRet = pThis->bHandleMessage(uMsg, wParam, lParam);
        }
    }
    else
    {
        pThis = reinterpret_cast<MGenericProp*>(GetWindowLongPtr(hDlg, DWLP_USER));
        if( pThis )
        {
            bRet = pThis->bHandleMessage(uMsg, wParam, lParam);
            if( WM_DESTROY == uMsg )
            {
                // our window is about to go away, so we need to cleanup DWLP_USER here 
                SetWindowLongPtr(hDlg, DWLP_USER, 0);
            }
        }
    }

    return bRet;
}

UINT CALLBACK
MGenericProp::
CallbackProc(
    HWND hDlg,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp 
    )
/*++

Routine Description:

    This function specifies an application-defined callback function that 
    a property sheet calls when a page is created and when it is about to 
    be destroyed. An application can use this function to perform 
    initialization and cleanup operations for the page.

    PSPCB_CREATE    - A page is being created. Return nonzero to allow 
                      the page to be created or zero to prevent it. 
    PSPCB_RELEASE	- A page is being destroyed. The return value is ignored.
    
Arguments:

    None.

Return Value:
    
    A page is being destroyed. The return value is ignored.

--*/
{
    BOOL bStatus;
    MGenericProp* pGenericProp;

    pGenericProp = (MGenericProp*)ppsp->lParam;
    
    SPLASSERT( pGenericProp );

    switch( uMsg ){

    case PSPCB_CREATE:
        bStatus = pGenericProp->bCreate();
        break;

    case PSPCB_RELEASE:
        pGenericProp->vDestroy();
        bStatus = FALSE;
        break;

    default:
        bStatus = FALSE;
    }

    return bStatus;
}

BOOL
MGenericProp::
bSetText(
    LPCTSTR pszTitle
    )
{
    return SetWindowText( _hDlg, pszTitle );
}

VOID
MGenericProp::
vForceCleanup(
    VOID
    )
{
    SetWindowLongPtr( _hDlg, DWLP_USER, 0L );
}

VOID
MGenericProp::
vSetDlgMsgResult(
    LONG_PTR lResult
    )
{
    SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, (LPARAM)lResult );
}

VOID
MGenericProp::
vSetParentDlgMsgResult(
    LRESULT lResult
    )
{
    SetWindowLongPtr( GetParent( _hDlg ), DWLP_MSGRESULT, (LPARAM)lResult );
}

/********************************************************************

    Dialog procs

********************************************************************/

MGenericDialog::
MGenericDialog(
    VOID
    )
{
}

MGenericDialog::
~MGenericDialog(
    VOID
    )
{
}

BOOL
MGenericDialog::
bHandleMessage(
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Handles dialog proc processing before the window is setup and after
    it is torn down.

Arguments:

    Standard window parameters.

Return Value:

    TRUE/FALSE

--*/

{
    UNREFERENCED_PARAMETER( uMsg );
    UNREFERENCED_PARAMETER( wParam );
    UNREFERENCED_PARAMETER( lParam );

    return FALSE;
}


INT_PTR APIENTRY
MGenericDialog::
SetupDlgProc(
    IN HWND hDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Setup the wndproc and initialize GWL_USERDATA.

Arguments:

    Standard wndproc parms.

Return Value:

History:

    Lazar Ivanov (LazarI) - Aug-2000 (redesign)

--*/

{
    BOOL bRet = FALSE;
    MGenericDialog *pThis = NULL;

    if( WM_INITDIALOG == uMsg )
    {
        pThis = reinterpret_cast<MGenericDialog*>(lParam);
        if( pThis )
        {
            pThis->_hDlg = hDlg;
            SetWindowLongPtr(hDlg, DWLP_USER, reinterpret_cast<LONG_PTR>(pThis));
            bRet = pThis->bHandleMessage(uMsg, wParam, lParam);
        }
    }
    else
    {
        pThis = reinterpret_cast<MGenericDialog*>(GetWindowLongPtr(hDlg, DWLP_USER));
        if( pThis )
        {
            bRet = pThis->bHandleMessage(uMsg, wParam, lParam);
            if( WM_DESTROY == uMsg )
            {
                // our window is about to go away, so we need to cleanup DWLP_USER here 
                SetWindowLongPtr(hDlg, DWLP_USER, 0);
            }
        }
    }

    return bRet;
}

BOOL
MGenericDialog::
bSetText(
    LPCTSTR pszTitle
    )
{
    return SetWindowText( _hDlg, pszTitle );
}

VOID
MGenericDialog::
vForceCleanup(
    VOID
    )
{
    SetWindowLongPtr( _hDlg, DWLP_USER, 0L );
}

VOID
MGenericDialog::
vSetDlgMsgResult(
    LONG_PTR lResult
    )
{
    SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, (LPARAM)lResult );
}

VOID
MGenericDialog::
vSetParentDlgMsgResult(
    LRESULT lResult
    )
{
    SetWindowLongPtr( GetParent( _hDlg ), DWLP_MSGRESULT, (LPARAM)lResult );
}

/********************************************************************

    Singleton window mixin.

********************************************************************/

MSingletonWin::
MSingletonWin(
    LPCTSTR pszPrinterName,
    HWND    hwnd,
    BOOL    bModal
    ) : _hwnd( hwnd ),
        _strPrinterName( pszPrinterName ),
        _hClassPidl( NULL ),
        _bModal( bModal )
{
}

MSingletonWin::
~MSingletonWin(
    VOID
    )
{
    //
    // hClassPidl is used to prevent multiple instances of the same
    // property sheet.  When we destroy the object, unregister the
    // window.
    //
    if( _hClassPidl ){

        SPLASSERT( _hwnd );
        Printers_UnregisterWindow( _hClassPidl, _hwnd );
    }
}

BOOL
MSingletonWin::
bRegisterWindow(
    DWORD dwType
    )

/*++

Routine Description:

    Registers a window type with the shell based on the _strPrinterName
    and type.  If there already is a printer window of this name and
    type, then return it.

    Clients can use this to prevent duplicate dialogs from coming up.

Arguments:

    dwType - Type of dialog.

Return Value:

    TRUE - success, either a new window or one already exists.
        If _hwnd is not then it is a new window.  If one window
        already exists, then _hwnd is set to NULL.
    
    FALSE - call failed.

--*/

{
    SPLASSERT( !_hClassPidl );

    if( !_bModal ){
        if( !Printers_RegisterWindow( _strPrinterName,
                                      dwType,
                                      &_hClassPidl,
                                      &_hwnd )){

            SPLASSERT( !_hClassPidl );
            SPLASSERT( !_hwnd );
            return FALSE;
        }
    } 

    return TRUE;
}

BOOL
MSingletonWin::
bValid(
    VOID
    )
{
    return _strPrinterName.bValid();
}

BOOL
MSingletonWin::
bIsWindowPresent(
    VOID
    )
{
    BOOL bReturn = FALSE;

    //
    // If the dialog is modal we allow duplicates.
    //
    if( _bModal )
    {
        bReturn = FALSE;
    }

    //
    // If a not modal and we have a null window
    // handle then this window is already present.
    //
    if( !_hwnd && !_bModal )
    {
        bReturn = TRUE;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\getopt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    getopt.cxx

Abstract:

    This module is an implementation of System V get option	
    routine.
         
Author:

    Steve Kiraly (SteveKi)  12/10/95

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include <stdio.h>
#include <string.h>

#ifdef USE_ERRORNO
#include <errno.h>
#endif

#include "getopt.hxx"

/*
  Parse the command line options, System V style.
 
  Standard option syntax is:
 
    option ::= SW [optLetter]* [argLetter space* argument]
 
  where
    - SW is either '-'
    - there is no space before any optLetter or argLetter.
    - opt/arg letters are alphabetic, not punctuation characters.
    - optLetters, if present, must be matched in optionS.
    - argLetters, if present, are found in optionS followed by ':'.
    - argument is any white-space delimited string.  Note that it
      can include the SW character.
    - upper and lower case letters are distinct.
 
  There may be multiple option clusters on a command line, each
  beginning with a SW, but all must appear before any non-option
  arguments (arguments not introduced by SW).  Opt/arg letters may
  be repeated: it is up to the caller to decide if that is an error.
 
  The character SW appearing alone as the last argument is an error.
  The lead-in sequence SWSW ("--" or "//") causes itself and all the
  rest of the line to be ignored (allowing non-options which begin
  with the switch char).

  The string *optionS allows valid opt/arg letters to be recognized.
  argLetters are followed with ':'.  Getopt () returns the value of
  the option character found, or EOF if no more options are in the
  command line.	 If option is an argLetter then the global optarg is
  set to point to the argument string (having skipped any white-space).
 
  The global optind is initially 1 and is always left as the index
  of the next argument of argv[] which getopt has not taken.  Note
  that if "--" or "//" are used then optind is stepped to the next
  argument before getopt() returns EOF.
 
  If an error occurs, that is an SW char precedes an unknown letter,
  then getopt() will return a '?' character and normally prints an
  error message via perror().  If the global variable opterr is set
  to false (zero) before calling getopt() then the error message is
  not printed.
 
  For example, if the MSDOS switch char is '/' (the MSDOS norm) and
 
    *optionS == "A:F:PuU:wXZ:"
 
  then 'P', 'u', 'w', and 'X' are option letters and 'F', 'U', 'Z'
  are followed by arguments.  A valid command line may be:
 
    aCommand  /uPFPi /X /A L someFile
 
  where:
    - 'u' and 'P' will be returned as isolated option letters.
    - 'F' will return with "Pi" as its argument string.
    - 'X' is an isolated option.
    - 'A' will return with "L" as its argument.
    - "someFile" is not an option, and terminates getOpt.  The
      caller may collect remaining arguments using argv pointers.
*/
extern "C"
INT
getopt(
    INT argc, 
    TCHAR *argv[], 
    TCHAR *optionS,
    TGetOptContext &context
    )
	{
	TCHAR ch;
	TCHAR *optP;

	if (argc > context.optind) 
		{
		if (context.letP == NULL) 
			{
			if ((context.letP = argv[context.optind]) == NULL || *(context.letP++) != context.SW)
				goto gopEOF;
			if (*context.letP == context.SW) 
				{
				context.optind++;  goto gopEOF;
				}
			}
		if (0 == (ch = *(context.letP++))) 
			{
			context.optind++;
			goto gopEOF;
			}
		if (TEXT(':') == ch  ||  (optP = _tcschr(optionS, ch)) == NULL)  
			goto gopError;
		if (TEXT(':') == *(++optP)) 
			{
			context.optind++;
			if (0 == *context.letP) 
				{
				if (argc <= context.optind)  
					goto gopError;
				context.letP = argv[context.optind++];
				}
			context.optarg = context.letP;
			context.letP = NULL;
			} 
	 	else 
	 		{
			if (0 == *context.letP) 
				{
				context.optind++;
				context.letP = NULL;
				}
			context.optarg = NULL;
			}
		return (ch);
		}
gopEOF:
	context.optarg = context.letP = NULL;  
	return (EOF);
 
gopError:
	context.optarg = NULL;

#ifdef USE_ERRORNO
	errno  = EINVAL;
	if (opterr)
		perror ("get command line option");
#endif

	return INVALID_COMAND;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\instarch.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999
All rights reserved.

Module Name:

    Instarch.cxx

Abstract:

    Installs alternate drivers for other architectures.

Author:

    Steve Kiraly (SteveKi)  18-Jan-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "psetup.hxx"
#include "drvsetup.hxx"
#include "drvver.hxx"
#include "instarch.hxx"

/********************************************************************

    Additional Drivers Dialog.

********************************************************************/
TAdditionalDrivers::
TAdditionalDrivers(
    IN HWND     hwnd,
    IN LPCTSTR  pszServerName,
    IN LPCTSTR  pszPrinterName,
    IN LPCTSTR  pszDriverName,
    IN BOOL     bAdministrator
    ) : _hwnd( hwnd ),
        _bValid( FALSE ),
        _strServerName( pszServerName ),
        _strPrinterName( pszPrinterName ),
        _strDriverName( pszDriverName ),
        _bAdministrator( bAdministrator )
{
    if( VALID_OBJ( _strServerName ) &&
        VALID_OBJ( _strPrinterName ) &&
        VALID_OBJ( _strDriverName ) &&
        VALID_OBJ( _ArchLV ) )
    {
        _bValid = TRUE;
    }
}

TAdditionalDrivers::
~TAdditionalDrivers(
    VOID
    )
{
}

BOOL
TAdditionalDrivers::
bValid(
    VOID
    )
{
    return _bValid;
}

BOOL
TAdditionalDrivers::
bDoModal(
    VOID
    )
{
    return (BOOL)DialogBoxParam( ghInst,
                                 MAKEINTRESOURCE( DLG_ADDITIONAL_DRIVERS ),
                                 _hwnd,
                                 MGenericDialog::SetupDlgProc,
                                 (LPARAM)this );
}

BOOL
TAdditionalDrivers::
bSetUI(
    VOID
    )
{
    TStatusB bStatus;

    //
    // Set the architecture list view UI.
    //
    bStatus DBGCHK = _ArchLV.bSetUI( _hDlg, kSingleClick, kDoubleClick );

    //
    // Refresh the architecture list.
    //
    bStatus DBGCHK = _ArchLV.bRefreshListView( _strServerName.bEmpty() ? NULL : static_cast<LPCTSTR>(_strServerName), _strDriverName );

    //
    // Select the first item in the list view.
    //
    _ArchLV.vSelectItem( 0 );

    //
    // If we are not an administrator do not allow the user to
    // check a driver to install.
    //
    if( !_bAdministrator )
    {
        _ArchLV.vNoItemCheck();
    }

    //
    // Disable the ok button if we are not an administator.
    //
    if( !_bAdministrator )
    {
        vEnableCtl( _hDlg, IDOK, FALSE );
    }

    //
    // The install button is initialy disabled.
    //
    EnableWindow( GetDlgItem( _hDlg, IDOK ), FALSE );

    return bStatus;
}

BOOL
TAdditionalDrivers::
bInstallSelectedDrivers(
    VOID
    )
{
    TStatusB bStatus;

    bStatus DBGNOCHK = TRUE;

    if( _bAdministrator )
    {
        //
        // Initialize the driver install count.
        //
        UINT nInstallCount = 0;

        //
        // Create the printer driver installation class.
        //
        TPrinterDriverInstallation Di( _strServerName.bEmpty() ? NULL : static_cast<LPCTSTR>(_strServerName), _hDlg );

        if( VALID_OBJ( Di ) && Di.bSetDriverName( _strDriverName ) )
        {
            //
            // Do not copy any INFs during this installation process
            //
            Di.SetInstallFlags( DRVINST_DONOTCOPY_INF );

            //
            // Get the selected item count.
            //
            UINT cSelectedCount = _ArchLV.uGetCheckedItemCount();

            //
            // Install the selected drivers.
            //
            for( UINT i = 0; i < cSelectedCount; i++ )
            {
                BOOL bInstalled;
                DWORD dwEncode;

                //
                // Get the checked items.
                //
                bStatus DBGCHK = _ArchLV.bGetCheckedItems( i, &bInstalled, &dwEncode );

                if( bStatus && !bInstalled )
                {
                    //
                    // Turn on the wait cursor.
                    //
                    TWaitCursor *pCur = new TWaitCursor;

                    //
                    // Install the printer driver.
                    //
                    BOOL bOfferReplacementDriver = FALSE;

                    bStatus DBGCHK = Di.bInstallDriver( NULL,
                                                        bOfferReplacementDriver,
                                                        FALSE,
                                                        _hDlg,
                                                        dwEncode,
                                                        TPrinterDriverInstallation::kDefault,
                                                        TPrinterDriverInstallation::kDefault,
                                                        TRUE);
                    //
                    // Release the wait cursor.
                    //
                    delete pCur;

                    if( bStatus )
                    {
                        nInstallCount++;
                    }
                    else
                    {
                        switch( GetLastError() )
                        {

                            case ERROR_CANCELLED:
                                break;

                            case ERROR_UNKNOWN_PRINTER_DRIVER:
                                {
                                    iMessage( _hDlg,
                                              IDS_ERR_ADD_PRINTER_TITLE,
                                              IDS_ERROR_UNKNOWN_DRIVER,
                                              MB_OK | MB_ICONSTOP,
                                              kMsgNone,
                                              NULL );
                                }
                                break;

                            default:
                                {
                                    TString strArch;
                                    TString strVersion;

                                    (VOID)_ArchLV.bEncodeToArchAndVersion( dwEncode, strArch, strVersion );

                                    //
                                    // An error occurred installing a printer driver.
                                    //
                                    iMessage( _hDlg,
                                              IDS_ADDITIONAL_DRIVER_TITLE,
                                              IDS_ERR_ALL_DRIVER_NOT_INSTALLED,
                                              MB_OK|MB_ICONHAND,
                                              kMsgGetLastError,
                                              NULL,
                                              static_cast<LPCTSTR>( _strDriverName ),
                                              static_cast<LPCTSTR>( strArch ),
                                              static_cast<LPCTSTR>( strVersion ) );
                                }
                                break;
                        }
                    }
                }
            }
        }

        //
        // If something failed and more than one driver was installed
        // refresh the view to show the newly installed drivers.
        //
        if( !bStatus && nInstallCount )
        {
            //
            // Refresh the architecture list.
            //
            (VOID)_ArchLV.bRefreshListView( _strServerName.bEmpty() ? NULL : static_cast<LPCTSTR>(_strServerName), _strDriverName );
        }
    }

    return bStatus;
}

BOOL
TAdditionalDrivers::
IsNonInstalledItemSelected(
    VOID
    )
{
    BOOL        bInstalled  = FALSE;
    DWORD       dwEncode    = 0;

    //
    // Get the selected item count.
    //
    UINT cSelectedCount = _ArchLV.uGetCheckedItemCount();

    //
    // Traverse the selected item list.
    //
    for( UINT i = 0; i < cSelectedCount; i++ )
    {
        //
        // Get the checked items.
        //
        if( _ArchLV.bGetCheckedItems( i, &bInstalled, &dwEncode ) )
        {
            if( !bInstalled )
            {
                break;
            }
        }
    }
    return !bInstalled;
}

BOOL
TAdditionalDrivers::
bHandleMessage(
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    BOOL bStatus = TRUE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        bSetUI();
        break;

    //
    // Handle help and context help.
    //
    case WM_HELP:
    case WM_CONTEXTMENU:
        bStatus = PrintUIHelp( uMsg, _hDlg, wParam, lParam );
        break;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {
        case IDOK:
            if( bInstallSelectedDrivers() )
            {
                EndDialog( _hDlg, LOWORD( wParam ) );
            }
            break;

        case IDCANCEL:
            EndDialog( _hDlg, LOWORD( wParam ) );
            break;

        case kSingleClick:
            EnableWindow( GetDlgItem( _hDlg, IDOK ), IsNonInstalledItemSelected() );
            break;

        case kDoubleClick:
            EnableWindow( GetDlgItem( _hDlg, IDOK ), IsNonInstalledItemSelected() );
            break;

        default:
            bStatus = FALSE;
            break;
        }
        break;

    //
    // Handle notify for this dialog.
    //
    case WM_NOTIFY:
        _ArchLV.bHandleNotifyMessage( WM_NOTIFY, wParam, lParam );
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\guids.h ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    guids.h

Abstract:

    global GUID definitions

Author:

    Lazar Ivanov (LazarI)  10-Mar-2000

Revision History:

--*/

#ifndef _GUIDS_H
#define _GUIDS_H

// IID_IPrintQueueDT
// {A27271FD-176D-4c34-8FDB-326DC79C6B78}
DEFINE_GUID(IID_IPrintQueueDT, 0xa27271fd, 0x176d, 0x4c34, 0x8f, 0xdb, 0x32, 0x6d, 0xc7, 0x9c, 0x6b, 0x78);

#endif // ndef _GUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\help.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1998
All rights reserved.

Module Name:

    help.cxx

Abstract:

    Print UI help facailities

Author:

    Steve Kiraly (SteveKi)  11/19/95

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "prhlpids.h"
#include "help.hxx"

/*++

Routine Name:

    PrintUIHlep

Routine Description:

    All dialogs and property sheets call this routine
    to handle help.  It is important that control ID's
    are unique to this project for this to work.

Arguments:

    UINT        uMsg,
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam

Return Value:

    TRUE if help message was dislayed, FALSE if message not handled,

--*/
BOOL
PrintUIHelp(
    IN UINT        uMsg,
    IN HWND        hDlg,
    IN WPARAM      wParam,
    IN LPARAM      lParam
    )
{
    BOOL bStatus = FALSE;

    switch( uMsg ){

    case WM_HELP:

        bStatus = WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                           gszWindowsHlp,
                           HELP_WM_HELP,
                           (ULONG_PTR)g_aHelpIDs );
        break;

    case WM_CONTEXTMENU:

        bStatus = WinHelp( (HWND)wParam,
                           gszWindowsHlp,
                           HELP_CONTEXTMENU,
                           (ULONG_PTR)g_aHelpIDs );
        break;

    }

    return bStatus;
}


/*++

Routine Name:

    PrintUICloseHelp

Routine Description:

    Close the help file system.  This should be done when the last
    printer queue view is closed.

Arguments:

    UINT        uMsg,
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam

Return Value:

    TRUE if help system was closed, otherwise FALSE.

--*/
BOOL
PrintUICloseHelp(
    IN UINT        uMsg,
    IN HWND        hDlg,
    IN WPARAM      wParam,
    IN LPARAM      lParam
    )
{
    //
    // Close down the help system.
    //
    return WinHelp( hDlg, gszWindowsHlp, HELP_QUIT, NULL );
}

/*++

Routine Name:

    PrintUIHtmlHelp

Routine Description:

    Call to HtmlHelp

Arguments:

    UINT        uMsg,
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam

Return Value:

    Windows handle if help succeded.

--*/
HWND
PrintUIHtmlHelp(
    IN HWND         hwndCaller,
    IN LPCTSTR      pszFile,
    IN UINT         uCommand,
    IN ULONG_PTR    dwData
    )
{
    return HtmlHelp( hwndCaller, pszFile, uCommand, dwData );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\msgbox.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1998
All rights reserved.

Module Name:

    msgbox.cxx

Abstract:

    MessageBox class

Author:

    Steve Kiraly (SteveKi)  03/23/98

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "msgbox.hxx"

/*++

Routine Name:

    PrintUIMessageBox

Routine Description:

    This routine is very similar to the win32 MessageBox except it
    creates a hidden dialog when the user request that a help button
    be displayed.  The MessageBox api is some what broken
    with respect to the way the help button works.  When the help button is
    clicked the MessageBox api will send a help event to the parent window.
    It is the responsiblity of the parent window to respond corectly, i.e.
    start either WinHelp or HtmlHelp.  Unfortunatly not in all cases does the
    caller have a parent window or has ownership to the parent window code to
    add suport for the help event. In these case is why someone would use this
    function.

Arguments:

    hWnd            - handle of owner window
    lpText          - address of text in message box
    lpCaption       - address of title of message box
    uType 	        - style of message box
    pfHelpCallback  - pointer to function called when a WM_HELP message is received, this
                      parameter is can be NULL then api acts like MessageBox.
    pRefData        - user defined refrence data passed along to the callback routine,
                      this paremeter can be NULL.

Return Value:

    See windows sdk for return values from MessageBox

--*/

INT
PrintUIMessageBox(
    IN HWND             hWnd,
    IN LPCTSTR          pszMsg,
    IN LPCTSTR          pszTitle,
    IN UINT             uFlags,
    IN pfHelpCallback   pCallback, OPTIONAL
    IN PVOID            pRefData   OPTIONAL
    )
{
    SPLASSERT( pszMsg );
    SPLASSERT( pszTitle );

    INT iRetval = 0;

    //
    // If the caller specifed the help flag and provided a callback then
    // use the message box dialog class to display the message box, otherwise
    // fall back to the original behavior of MessageBox.
    //
    if( ( uFlags & MB_HELP ) && pCallback )
    {
        TMessageBoxDialog Dialog( hWnd, uFlags, pszTitle, pszMsg, pCallback, pRefData );

        if( VALID_OBJ( Dialog ) )
        {
            iRetval = Dialog.iMessageBox();
        }
    }
    else
    {
        //
        // Display the message box.
        //
        iRetval = ::MessageBox( hWnd, pszMsg, pszTitle, uFlags );
    }
    return iRetval;
}

/********************************************************************

 Message box helper class.

********************************************************************/

TMessageBoxDialog::
TMessageBoxDialog(
    IN HWND             hWnd,
    IN UINT             uFlags,
    IN LPCTSTR          pszTitle,
    IN LPCTSTR          pszMsg,
    IN pfHelpCallback   pCallback,
    IN PVOID            pRefData
    ) : _hWnd( hWnd ),
        _uFlags( uFlags ),
        _pszTitle( pszTitle ),
        _pszMsg( pszMsg ),
        _pCallback( pCallback ),
        _pRefData( pRefData ),
        _iRetval( 0 )
{
}

TMessageBoxDialog::
~TMessageBoxDialog(
    VOID
    )
{
}

BOOL
TMessageBoxDialog::
bValid(
    VOID
    ) const
{
    return TRUE;
}

INT
TMessageBoxDialog::
iMessageBox(
    VOID
    )
{
    _iRetval = 0;

    DialogBoxParam( ghInst,
                    MAKEINTRESOURCE( DLG_MESSAGE_BOX ),
                    _hWnd,
                    MGenericDialog::SetupDlgProc,
                    (LPARAM)this );

    return _iRetval;
}

BOOL
TMessageBoxDialog::
bHandleMessage(
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    BOOL bStatus = TRUE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        ShowWindow( _hDlg, SW_HIDE );
        _iRetval = ::MessageBox( _hDlg, _pszMsg, _pszTitle, _uFlags );
        EndDialog( _hDlg, IDOK );
        break;

    case WM_HELP:
        bStatus = ( _pCallback ) ? _pCallback( _hDlg, _pRefData ) : FALSE;
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\locprop.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999
All rights reserved.

Module Name:

    locprop.cxx

Abstract:

    Server Properties

Author:

    Steve Kiraly (SteveKi)  09/08/98
    Lazar Ivanov (LazarI) Nov-28-2000 - validation

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "dsinterf.hxx"
#include "locprop.hxx"
#include "findloc.hxx"
#include "physloc.hxx"

#define INVALID_RESOURCE_ID           ((UINT )-1)

TLocationPropertySheetFrontEnd::
TLocationPropertySheetFrontEnd(
    IN      IShellPropSheetExt              *pShellPropSheetExt,
    IN      LPDATAOBJECT                    lpdobj,
    IN      LPFNADDPROPSHEETPAGE            lpfnAddPage,
    IN      LPARAM                          lParam
    ) : _bValid( FALSE ),
        _pShellPropSheetExt( pShellPropSheetExt ),
        _lpdobj( lpdobj ),
        _pLocation( NULL )
{
    DBGMSG( DBG_TRACE, ( "TLocationPropertySheetFrontEnd::TLocationPropertySheetFrontEnd\n" ) );

    if( AddPropertyPages( lpfnAddPage, lParam ) )
    {
        _bValid = TRUE;
    }
}

TLocationPropertySheetFrontEnd::
~TLocationPropertySheetFrontEnd(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TLocationPropertySheetFrontEnd::~TLocationPropertySheetFrontEnd\n" ) );
    delete _pLocation;
}

BOOL
TLocationPropertySheetFrontEnd::
bValid(
    VOID
    ) const
{
    DBGMSG( DBG_TRACE, ( "TLocationPropertySheetFrontEnd::bValid\n" ) );
    return _bValid;
}

HRESULT
TLocationPropertySheetFrontEnd::
Create(
    IN OUT  TLocationPropertySheetFrontEnd  **ppPropertySheet,
    IN      IShellPropSheetExt              *pShellPropSheetExt,
    IN      LPDATAOBJECT                    lpdobj,
    IN      LPFNADDPROPSHEETPAGE            lpfnAddPage,
    IN      LPARAM                          lParam
    )
{
    DBGMSG( DBG_TRACE, ( "TLocationPropertySheetFrontEnd::Create\n" ) );

    HRESULT hr = S_OK;

    *ppPropertySheet = new TLocationPropertySheetFrontEnd (pShellPropSheetExt, lpdobj, lpfnAddPage, lParam);

    if (!VALID_PTR(*ppPropertySheet))
    {
        Destroy (ppPropertySheet);
        hr = E_FAIL;
    }

    return hr;
}

VOID
TLocationPropertySheetFrontEnd::
Destroy(
    IN OUT  TLocationPropertySheetFrontEnd  **ppPropertySheet
    )
{
    if (*ppPropertySheet)
    {
        DBGMSG( DBG_TRACE, ( "TLocationPropertySheetFrontEnd::Destroy\n" ) );

        delete *ppPropertySheet;
        *ppPropertySheet = NULL;
    }
}

BOOL
TLocationPropertySheetFrontEnd::
AddPropertyPages(
    IN      LPFNADDPROPSHEETPAGE    lpfnAddPage,
    IN      LPARAM                  lParam
    )
{
    DBGMSG( DBG_TRACE, ( "TLocationPropertySheetFrontEnd::AddPropertyPages\n" ) );

    BOOL bRetval = TRUE;

    if( bRetval )
    {
        _pLocation = new TLocationPropertySheet( _pShellPropSheetExt, _lpdobj );

        if( VALID_PTR( _pLocation ) )
        {
            bRetval = CreatePropertyPage( lpfnAddPage, lParam, _pLocation, _pLocation->uGetResourceTemplateID() );
        }
    }

    return bRetval;
}

BOOL
TLocationPropertySheetFrontEnd::
CreatePropertyPage(
    IN      LPFNADDPROPSHEETPAGE        lpfnAddPage,
    IN      LPARAM                      lParam,
    IN      MGenericProp                *pPage,
    IN      UINT                        Template
    )
{
    DBGMSG( DBG_TRACE, ( "TLocationPropertySheetFrontEnd::CreatePropertyPage\n" ) );

    //
    // Ensure the page pointer and page object is valid.
    //
    BOOL bRetval = VALID_PTR( pPage );

    if( bRetval )
    {
        PROPSHEETPAGE   psp     = {0};

        psp.dwSize              = sizeof( psp );
        psp.dwFlags             = PSP_DEFAULT | PSP_USEREFPARENT | PSP_USECALLBACK | PSP_PREMATURE;
        psp.hInstance           = ghInst;
        psp.pfnDlgProc          = MGenericProp::SetupDlgProc;
        psp.pfnCallback         = MGenericProp::CallbackProc;
        psp.pcRefParent         = reinterpret_cast<UINT *>( &gcRefThisDll );
        psp.pszTemplate         = MAKEINTRESOURCE( Template );
        psp.lParam              = reinterpret_cast<LPARAM>( pPage );

        //
        // Create the actual page and get the pages handle.
        //
        HPROPSHEETPAGE hPage = ::CreatePropertySheetPage( &psp );

        //
        // Add the page to the property sheet.
        //
        if( hPage && lpfnAddPage( hPage, lParam ) )
        {
            if( _pShellPropSheetExt )
            {
                _pShellPropSheetExt->AddRef();
            }
        }
        else
        {
            //
            // We could not add the page, remember to destroy the handle
            //
            if( hPage )
            {
                ::DestroyPropertySheetPage (hPage);
            }

            bRetval = FALSE;
        }
    }
    return bRetval;
}

/********************************************************************

    Location property sheet.

********************************************************************/

TLocationPropertySheet::
TLocationPropertySheet(
    IN  IShellPropSheetExt  *pShellPropSheetExt,
    IN IDataObject          *pdobj
    ) : _pShellPropSheetExt( pShellPropSheetExt ),
        _bValid( FALSE ),
        _cfDsObjectNames( 0 ),
        _pDsObject( NULL ),
        _uLocationEditID( INVALID_RESOURCE_ID ),
        _uBrowseID( INVALID_RESOURCE_ID ),
        _PropertyAccess( kPropertyAccessNone )
{
    DBGMSG( DBG_TRACE, ( "TLocationPropertySheet::TLocationPropertySheet\n" ) );

    TStatusB bStatus;

    //
    // Ensure the ds interface object is in a valid state.
    //
    if( VALID_OBJ( _Ds ) )
    {
        //
        // Initialize the ds object clipboard format.
        //
        bStatus DBGCHK = InitializeDsObjectClipboardFormat();

        if( bStatus )
        {
            //
            // Get the ds object name.
            //
            bStatus DBGCHK = GetDsObjectNameFromIDataObject( pdobj, _strDsObjectName, _strDsObjectClass );

            if( bStatus )
            {
                DBGMSG( DBG_TRACE, ( "DsObjectName " TSTR "\n", (LPCTSTR)_strDsObjectName ) );
                DBGMSG( DBG_TRACE, ( "DsObjectClass " TSTR "\n", (LPCTSTR)_strDsObjectClass ) );

                //
                // Computer location page will have different resource
                // template in order to have different control IDs and
                // thereafter different help IDs.
                //
                _uBrowseID       = IDC_BROWSE_PHYSICAL_LOCATION;
                if( !_tcsicmp( _strDsObjectClass, gszComputer ) )
                {
                    _uLocationEditID = IDC_PHYSICAL_COMPUTER_LOCATION;
                }
                else
                {
                    _uLocationEditID = IDC_PHYSICAL_LOCATION;
                }

                //
                // Get the objects interface.
                //
                bStatus DBGCHK = GetObjectInterface( _strDsObjectName, &_pDsObject );

                if( bStatus )
                {
                    //
                    // Check our current access priviliges.  None, Read, Read|Write
                    //
                    bStatus DBGCHK = CheckPropertyAccess( gszLocation, _PropertyAccess );

                    //
                    // If were able to determine our access and we have at least read
                    // access then display the property sheet.
                    //
                    if( bStatus && ( _PropertyAccess != kPropertyAccessNone ) )
                    {
                        //
                        // If we get here every this is ok, ready to display the page.
                        //
                        _bValid = TRUE;
                    }
                }
            }
        }
    }
}

TLocationPropertySheet::
~TLocationPropertySheet(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TLocationPropertySheet::~TLocationPropertySheet\n" ) );

    //
    // Release the adsi interface, if aquired.
    //
    if( _pDsObject )
    {
        _pDsObject->Release();
    }
}

BOOL
TLocationPropertySheet::
bValid(
    VOID
    ) const
{
    return _bValid;
}

UINT
TLocationPropertySheet::
uGetResourceTemplateID(
    VOID
    ) const
{
    UINT uDefTemplateID = DLG_PRINTER_LOCATION;

    //
    // Computer location page will have different resource
    // template in order to have different control IDs and
    // different help IDs.
    //
    if( !_tcsicmp( _strDsObjectClass, gszComputer ) )
    {
        uDefTemplateID = DLG_COMPUTER_LOCATION;
    }

    return uDefTemplateID;
}

VOID
TLocationPropertySheet::
vDestroy(
    VOID
    )
{
    //
    // This fuction is called from the property sheet callback when the
    // sheet is destroyed.
    //
    if( _pShellPropSheetExt )
    {
        _pShellPropSheetExt->Release();
    }
}

BOOL
TLocationPropertySheet::
InitializeDsObjectClipboardFormat(
    VOID
    )
{
    //
    // If the clipboard format has not been registred then do it now.
    //
    if( !_cfDsObjectNames )
    {
        _cfDsObjectNames = RegisterClipboardFormat( CFSTR_DSOBJECTNAMES );
    }

    return _cfDsObjectNames != 0;
}

BOOL
TLocationPropertySheet::
GetDsObjectNameFromIDataObject(
    IN IDataObject      *pdobj,
    IN TString          &strDsObjectName,
    IN TString          &strDsObjectClass
    )
{
    HRESULT     hr = E_FAIL;
    TStatusB    bStatus;

    if( pdobj )
    {
        STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
        FORMATETC formatetc = { (CLIPFORMAT)_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

        hr = pdobj->GetData(&formatetc, &stgmedium);

        if (SUCCEEDED(hr))
        {
            LPDSOBJECTNAMES pDsObjectNames = reinterpret_cast<LPDSOBJECTNAMES>( stgmedium.hGlobal );

            hr = pDsObjectNames ? S_OK : E_FAIL;

            if( SUCCEEDED(hr) )
            {
                if( pDsObjectNames->cItems == 1 )
                {
                    bStatus DBGCHK = strDsObjectName.bUpdate( ByteOffset( pDsObjectNames, pDsObjectNames->aObjects[0].offsetName ) );

                    if( bStatus )
                    {
                        bStatus DBGCHK = strDsObjectClass.bUpdate( ByteOffset( pDsObjectNames, pDsObjectNames->aObjects[0].offsetClass ) );
                    }

                    hr = bStatus ? S_OK : E_FAIL;
                }
                else
                {
                    hr = E_FAIL;
                }
            }

            ReleaseStgMedium(&stgmedium);
        }
    }

    return SUCCEEDED(hr);
}

BOOL
TLocationPropertySheet::
CheckPropertyAccess(
    IN LPCTSTR          pszPropertyNam